
Entering the Souper pass's runOnModule()


; entering Souper's runOnFunction() for argon2_decode_string()

; ModuleID = './argon2-encoding.c.bc'
source_filename = "crypto_pwhash/argon2/argon2-encoding.c"
target datalayout = "e-m:e-p:32:32-i64:64-n32:64-S128"
target triple = "wasm32-unknown-wasi"

%struct.Argon2_Context = type { i8*, i32, i8*, i32, i8*, i32, i8*, i32, i8*, i32, i32, i32, i32, i32, i32 }

@.str = private unnamed_addr constant [10 x i8] c"$argon2id\00", align 1
@.str.1 = private unnamed_addr constant [9 x i8] c"$argon2i\00", align 1
@.str.2 = private unnamed_addr constant [4 x i8] c"$v=\00", align 1
@.str.3 = private unnamed_addr constant [4 x i8] c"$m=\00", align 1
@.str.4 = private unnamed_addr constant [4 x i8] c",t=\00", align 1
@.str.5 = private unnamed_addr constant [4 x i8] c",p=\00", align 1
@.str.7 = private unnamed_addr constant [13 x i8] c"$argon2id$v=\00", align 1
@.str.8 = private unnamed_addr constant [12 x i8] c"$argon2i$v=\00", align 1

; Function Attrs: nounwind
define hidden i32 @argon2_decode_string(%struct.Argon2_Context* %0, i8* %1, i32 %2) local_unnamed_addr #0 {
  %4 = alloca i32, align 4
  %5 = alloca i8*, align 4
  %6 = alloca i32, align 4
  %7 = alloca i8*, align 4
  %8 = getelementptr inbounds %struct.Argon2_Context, %struct.Argon2_Context* %0, i32 0, i32 5
  %9 = load i32, i32* %8, align 4
  %10 = getelementptr inbounds %struct.Argon2_Context, %struct.Argon2_Context* %0, i32 0, i32 1
  %11 = load i32, i32* %10, align 4
  store i32 0, i32* %8, align 4
  store i32 0, i32* %10, align 4
  switch i32 %2, label %194 [
    i32 2, label %12
    i32 1, label %16
  ]

12:                                               ; preds = %3
  %13 = tail call i32 @strncmp(i8* nonnull dereferenceable(1) %1, i8* nonnull dereferenceable(10) getelementptr inbounds ([10 x i8], [10 x i8]* @.str, i32 0, i32 0), i32 9)
  %14 = icmp eq i32 %13, 0
  %15 = getelementptr i8, i8* %1, i32 9
  br i1 %14, label %20, label %194

16:                                               ; preds = %3
  %17 = tail call i32 @strncmp(i8* nonnull dereferenceable(1) %1, i8* nonnull dereferenceable(9) getelementptr inbounds ([9 x i8], [9 x i8]* @.str.1, i32 0, i32 0), i32 8)
  %18 = icmp eq i32 %17, 0
  %19 = getelementptr i8, i8* %1, i32 8
  br i1 %18, label %20, label %194

20:                                               ; preds = %12, %16
  %21 = phi i8* [ %15, %12 ], [ %19, %16 ]
  %22 = tail call i32 @strncmp(i8* nonnull dereferenceable(1) %21, i8* nonnull dereferenceable(4) getelementptr inbounds ([4 x i8], [4 x i8]* @.str.2, i32 0, i32 0), i32 3)
  %23 = icmp eq i32 %22, 0
  %24 = getelementptr i8, i8* %21, i32 3
  %25 = select i1 %23, i8* %24, i8* %21
  br i1 %23, label %26, label %194

26:                                               ; preds = %20
  %27 = load i8, i8* %25, align 1
  %28 = add i8 %27, -48
  %29 = icmp ugt i8 %28, 9
  br i1 %29, label %194, label %30

30:                                               ; preds = %26, %41
  %31 = phi i8 [ %44, %41 ], [ %27, %26 ]
  %32 = phi i32 [ %42, %41 ], [ 0, %26 ]
  %33 = phi i8* [ %43, %41 ], [ %24, %26 ]
  %34 = zext i8 %31 to i32
  %35 = add nsw i32 %34, -48
  %36 = icmp ugt i32 %32, 429496729
  br i1 %36, label %194, label %37

37:                                               ; preds = %30
  %38 = mul nuw i32 %32, 10
  %39 = xor i32 %38, -1
  %40 = icmp ugt i32 %35, %39
  br i1 %40, label %194, label %41

41:                                               ; preds = %37
  %42 = add i32 %35, %38
  %43 = getelementptr i8, i8* %33, i32 1
  %44 = load i8, i8* %43, align 1
  %45 = add i8 %44, -48
  %46 = icmp ugt i8 %45, 9
  br i1 %46, label %47, label %30

47:                                               ; preds = %41
  %48 = icmp eq i8* %43, %25
  br i1 %48, label %194, label %49

49:                                               ; preds = %47
  %50 = icmp ne i8 %27, 48
  %51 = icmp eq i8* %33, %25
  %52 = or i1 %50, %51
  br i1 %52, label %53, label %194

53:                                               ; preds = %49
  %54 = icmp eq i32 %42, 19
  br i1 %54, label %55, label %194

55:                                               ; preds = %53
  %56 = tail call i32 @strncmp(i8* nonnull dereferenceable(1) %43, i8* nonnull dereferenceable(4) getelementptr inbounds ([4 x i8], [4 x i8]* @.str.3, i32 0, i32 0), i32 3)
  %57 = icmp eq i32 %56, 0
  %58 = getelementptr i8, i8* %33, i32 4
  %59 = select i1 %57, i8* %58, i8* %43
  br i1 %57, label %60, label %194

60:                                               ; preds = %55
  %61 = load i8, i8* %59, align 1
  %62 = add i8 %61, -48
  %63 = icmp ugt i8 %62, 9
  br i1 %63, label %194, label %64

64:                                               ; preds = %60, %75
  %65 = phi i8 [ %78, %75 ], [ %61, %60 ]
  %66 = phi i32 [ %76, %75 ], [ 0, %60 ]
  %67 = phi i8* [ %77, %75 ], [ %58, %60 ]
  %68 = zext i8 %65 to i32
  %69 = add nsw i32 %68, -48
  %70 = icmp ugt i32 %66, 429496729
  br i1 %70, label %194, label %71

71:                                               ; preds = %64
  %72 = mul nuw i32 %66, 10
  %73 = xor i32 %72, -1
  %74 = icmp ugt i32 %69, %73
  br i1 %74, label %194, label %75

75:                                               ; preds = %71
  %76 = add i32 %69, %72
  %77 = getelementptr i8, i8* %67, i32 1
  %78 = load i8, i8* %77, align 1
  %79 = add i8 %78, -48
  %80 = icmp ugt i8 %79, 9
  br i1 %80, label %81, label %64

81:                                               ; preds = %75
  %82 = icmp eq i8* %77, %59
  br i1 %82, label %194, label %83

83:                                               ; preds = %81
  %84 = icmp eq i8 %61, 48
  %85 = icmp ne i8* %67, %59
  %86 = and i1 %84, %85
  br i1 %86, label %194, label %87

87:                                               ; preds = %83
  %88 = getelementptr inbounds %struct.Argon2_Context, %struct.Argon2_Context* %0, i32 0, i32 11
  store i32 %76, i32* %88, align 4
  %89 = tail call i32 @strncmp(i8* nonnull dereferenceable(1) %77, i8* nonnull dereferenceable(4) getelementptr inbounds ([4 x i8], [4 x i8]* @.str.4, i32 0, i32 0), i32 3)
  %90 = icmp eq i32 %89, 0
  %91 = getelementptr i8, i8* %67, i32 4
  %92 = select i1 %90, i8* %91, i8* %77
  br i1 %90, label %93, label %194

93:                                               ; preds = %87
  %94 = load i8, i8* %92, align 1
  %95 = add i8 %94, -48
  %96 = icmp ugt i8 %95, 9
  br i1 %96, label %194, label %97

97:                                               ; preds = %93, %108
  %98 = phi i8 [ %111, %108 ], [ %94, %93 ]
  %99 = phi i32 [ %109, %108 ], [ 0, %93 ]
  %100 = phi i8* [ %110, %108 ], [ %91, %93 ]
  %101 = zext i8 %98 to i32
  %102 = add nsw i32 %101, -48
  %103 = icmp ugt i32 %99, 429496729
  br i1 %103, label %194, label %104

104:                                              ; preds = %97
  %105 = mul nuw i32 %99, 10
  %106 = xor i32 %105, -1
  %107 = icmp ugt i32 %102, %106
  br i1 %107, label %194, label %108

108:                                              ; preds = %104
  %109 = add i32 %102, %105
  %110 = getelementptr i8, i8* %100, i32 1
  %111 = load i8, i8* %110, align 1
  %112 = add i8 %111, -48
  %113 = icmp ugt i8 %112, 9
  br i1 %113, label %114, label %97

114:                                              ; preds = %108
  %115 = icmp eq i8* %110, %92
  br i1 %115, label %194, label %116

116:                                              ; preds = %114
  %117 = icmp eq i8 %94, 48
  %118 = icmp ne i8* %100, %92
  %119 = and i1 %117, %118
  br i1 %119, label %194, label %120

120:                                              ; preds = %116
  %121 = getelementptr inbounds %struct.Argon2_Context, %struct.Argon2_Context* %0, i32 0, i32 10
  store i32 %109, i32* %121, align 4
  %122 = tail call i32 @strncmp(i8* nonnull dereferenceable(1) %110, i8* nonnull dereferenceable(4) getelementptr inbounds ([4 x i8], [4 x i8]* @.str.5, i32 0, i32 0), i32 3)
  %123 = icmp eq i32 %122, 0
  %124 = getelementptr i8, i8* %100, i32 4
  %125 = select i1 %123, i8* %124, i8* %110
  br i1 %123, label %126, label %194

126:                                              ; preds = %120
  %127 = load i8, i8* %125, align 1
  %128 = add i8 %127, -48
  %129 = icmp ugt i8 %128, 9
  br i1 %129, label %194, label %130

130:                                              ; preds = %126, %141
  %131 = phi i8 [ %144, %141 ], [ %127, %126 ]
  %132 = phi i32 [ %142, %141 ], [ 0, %126 ]
  %133 = phi i8* [ %143, %141 ], [ %124, %126 ]
  %134 = zext i8 %131 to i32
  %135 = add nsw i32 %134, -48
  %136 = icmp ugt i32 %132, 429496729
  br i1 %136, label %194, label %137

137:                                              ; preds = %130
  %138 = mul nuw i32 %132, 10
  %139 = xor i32 %138, -1
  %140 = icmp ugt i32 %135, %139
  br i1 %140, label %194, label %141

141:                                              ; preds = %137
  %142 = add i32 %135, %138
  %143 = getelementptr i8, i8* %133, i32 1
  %144 = load i8, i8* %143, align 1
  %145 = add i8 %144, -48
  %146 = icmp ugt i8 %145, 9
  br i1 %146, label %147, label %130

147:                                              ; preds = %141
  %148 = icmp eq i8* %143, %125
  br i1 %148, label %194, label %149

149:                                              ; preds = %147
  %150 = icmp eq i8 %127, 48
  %151 = icmp ne i8* %133, %125
  %152 = and i1 %150, %151
  br i1 %152, label %194, label %153

153:                                              ; preds = %149
  %154 = getelementptr inbounds %struct.Argon2_Context, %struct.Argon2_Context* %0, i32 0, i32 12
  store i32 %142, i32* %154, align 4
  %155 = getelementptr inbounds %struct.Argon2_Context, %struct.Argon2_Context* %0, i32 0, i32 13
  store i32 %142, i32* %155, align 4
  %156 = load i8, i8* %143, align 1
  %157 = icmp eq i8 %156, 36
  %158 = getelementptr i8, i8* %133, i32 2
  %159 = select i1 %157, i8* %158, i8* %143
  br i1 %157, label %160, label %194

160:                                              ; preds = %153
  %161 = bitcast i32* %4 to i8*
  call void @llvm.lifetime.start.p0i8(i64 4, i8* nonnull %161) #5
  store i32 %9, i32* %4, align 4
  %162 = bitcast i8** %5 to i8*
  call void @llvm.lifetime.start.p0i8(i64 4, i8* nonnull %162) #5
  %163 = getelementptr inbounds %struct.Argon2_Context, %struct.Argon2_Context* %0, i32 0, i32 4
  %164 = load i8*, i8** %163, align 4
  %165 = tail call i32 @strlen(i8* nonnull dereferenceable(1) %159) #6
  %166 = call i32 @sodium_base642bin(i8* %164, i32 %9, i8* %159, i32 %165, i8* null, i32* nonnull %4, i8** nonnull %5, i32 3) #5
  %167 = icmp eq i32 %166, 0
  br i1 %167, label %169, label %168

168:                                              ; preds = %160
  call void @llvm.lifetime.end.p0i8(i64 4, i8* nonnull %162) #5
  call void @llvm.lifetime.end.p0i8(i64 4, i8* nonnull %161) #5
  br label %194

169:                                              ; preds = %160
  %170 = load i32, i32* %4, align 4
  store i32 %170, i32* %8, align 4
  %171 = load i8*, i8** %5, align 4
  call void @llvm.lifetime.end.p0i8(i64 4, i8* nonnull %162) #5
  call void @llvm.lifetime.end.p0i8(i64 4, i8* nonnull %161) #5
  %172 = load i8, i8* %171, align 1
  %173 = icmp eq i8 %172, 36
  %174 = getelementptr i8, i8* %171, i32 1
  %175 = select i1 %173, i8* %174, i8* %171
  br i1 %173, label %176, label %194

176:                                              ; preds = %169
  %177 = bitcast i32* %6 to i8*
  call void @llvm.lifetime.start.p0i8(i64 4, i8* nonnull %177) #5
  store i32 %11, i32* %6, align 4
  %178 = bitcast i8** %7 to i8*
  call void @llvm.lifetime.start.p0i8(i64 4, i8* nonnull %178) #5
  %179 = getelementptr inbounds %struct.Argon2_Context, %struct.Argon2_Context* %0, i32 0, i32 0
  %180 = load i8*, i8** %179, align 4
  %181 = call i32 @strlen(i8* nonnull dereferenceable(1) %175) #6
  %182 = call i32 @sodium_base642bin(i8* %180, i32 %11, i8* %175, i32 %181, i8* null, i32* nonnull %6, i8** nonnull %7, i32 3) #5
  %183 = icmp eq i32 %182, 0
  br i1 %183, label %185, label %184

184:                                              ; preds = %176
  call void @llvm.lifetime.end.p0i8(i64 4, i8* nonnull %178) #5
  call void @llvm.lifetime.end.p0i8(i64 4, i8* nonnull %177) #5
  br label %194

185:                                              ; preds = %176
  %186 = load i32, i32* %6, align 4
  store i32 %186, i32* %10, align 4
  %187 = load i8*, i8** %7, align 4
  call void @llvm.lifetime.end.p0i8(i64 4, i8* nonnull %178) #5
  call void @llvm.lifetime.end.p0i8(i64 4, i8* nonnull %177) #5
  %188 = call i32 @argon2_validate_inputs(%struct.Argon2_Context* nonnull %0) #5
  %189 = icmp eq i32 %188, 0
  br i1 %189, label %190, label %194

190:                                              ; preds = %185
  %191 = load i8, i8* %187, align 1
  %192 = icmp eq i8 %191, 0
  %193 = select i1 %192, i32 0, i32 -32
  br label %194

194:                                              ; preds = %37, %30, %71, %64, %104, %97, %137, %130, %149, %116, %83, %126, %147, %93, %114, %60, %81, %26, %47, %49, %184, %168, %190, %185, %53, %3, %12, %169, %153, %120, %87, %55, %20, %16
  %195 = phi i32 [ -32, %184 ], [ -32, %169 ], [ -32, %168 ], [ -32, %153 ], [ -32, %120 ], [ -32, %87 ], [ -32, %55 ], [ -32, %20 ], [ -32, %12 ], [ -32, %16 ], [ -26, %3 ], [ -26, %53 ], [ %188, %185 ], [ %193, %190 ], [ -32, %49 ], [ -32, %47 ], [ -32, %26 ], [ -32, %83 ], [ -32, %81 ], [ -32, %60 ], [ -32, %116 ], [ -32, %114 ], [ -32, %93 ], [ -32, %149 ], [ -32, %147 ], [ -32, %126 ], [ -32, %130 ], [ -32, %137 ], [ -32, %97 ], [ -32, %104 ], [ -32, %64 ], [ -32, %71 ], [ -32, %30 ], [ -32, %37 ]
  ret i32 %195
}

; Function Attrs: argmemonly nounwind willreturn
declare void @llvm.lifetime.start.p0i8(i64 immarg %0, i8* nocapture %1) #1

; Function Attrs: nofree nounwind readonly
declare i32 @strncmp(i8* nocapture %0, i8* nocapture %1, i32 %2) local_unnamed_addr #2

; Function Attrs: argmemonly nounwind willreturn
declare void @llvm.lifetime.end.p0i8(i64 immarg %0, i8* nocapture %1) #1

declare i32 @sodium_base642bin(i8* %0, i32 %1, i8* %2, i32 %3, i8* %4, i32* %5, i8** %6, i32 %7) local_unnamed_addr #3

; Function Attrs: argmemonly nofree nounwind readonly
declare i32 @strlen(i8* nocapture %0) local_unnamed_addr #4

declare i32 @argon2_validate_inputs(%struct.Argon2_Context* %0) local_unnamed_addr #3

; Function Attrs: nounwind
define hidden i32 @argon2_encode_string(i8* %0, i32 %1, %struct.Argon2_Context* %2, i32 %3) local_unnamed_addr #0 {
  %5 = alloca [10 x i8], align 1
  %6 = alloca [11 x i8], align 2
  %7 = alloca [11 x i8], align 1
  %8 = alloca [11 x i8], align 1
  %9 = alloca [11 x i8], align 1
  switch i32 %3, label %159 [
    i32 2, label %10
    i32 1, label %13
  ]

10:                                               ; preds = %4
  %11 = icmp ult i32 %1, 13
  br i1 %11, label %159, label %12

12:                                               ; preds = %10
  tail call void @llvm.memcpy.p0i8.p0i8.i32(i8* nonnull align 1 dereferenceable(13) %0, i8* nonnull align 1 dereferenceable(13) getelementptr inbounds ([13 x i8], [13 x i8]* @.str.7, i32 0, i32 0), i32 13, i1 false)
  br label %16

13:                                               ; preds = %4
  %14 = icmp ult i32 %1, 12
  br i1 %14, label %159, label %15

15:                                               ; preds = %13
  tail call void @llvm.memcpy.p0i8.p0i8.i32(i8* nonnull align 1 dereferenceable(12) %0, i8* nonnull align 1 dereferenceable(12) getelementptr inbounds ([12 x i8], [12 x i8]* @.str.8, i32 0, i32 0), i32 12, i1 false)
  br label %16

16:                                               ; preds = %15, %12
  %17 = phi i32 [ 11, %15 ], [ 12, %12 ]
  %18 = phi i32 [ -11, %15 ], [ -12, %12 ]
  %19 = getelementptr i8, i8* %0, i32 %17
  %20 = add i32 %18, %1
  %21 = tail call i32 @argon2_validate_inputs(%struct.Argon2_Context* %2) #5
  %22 = icmp eq i32 %21, 0
  br i1 %22, label %23, label %159

23:                                               ; preds = %16
  %24 = getelementptr inbounds [11 x i8], [11 x i8]* %6, i32 0, i32 0
  call void @llvm.lifetime.start.p0i8(i64 11, i8* nonnull %24) #5
  %25 = getelementptr inbounds [10 x i8], [10 x i8]* %5, i32 0, i32 0
  call void @llvm.lifetime.start.p0i8(i64 10, i8* nonnull %25) #5
  %26 = getelementptr inbounds [10 x i8], [10 x i8]* %5, i32 0, i32 9
  store i8 57, i8* %26, align 1
  %27 = getelementptr inbounds [10 x i8], [10 x i8]* %5, i32 0, i32 8
  store i8 49, i8* %27, align 1
  %28 = bitcast i8* %27 to i16*
  %29 = bitcast [11 x i8]* %6 to i16*
  %30 = load i16, i16* %28, align 1
  store i16 %30, i16* %29, align 2
  %31 = getelementptr inbounds [11 x i8], [11 x i8]* %6, i32 0, i32 2
  store i8 0, i8* %31, align 2
  call void @llvm.lifetime.end.p0i8(i64 10, i8* nonnull %25) #5
  %32 = call i32 @strlen(i8* nonnull %24) #6
  %33 = icmp ugt i32 %20, %32
  br i1 %33, label %35, label %34

34:                                               ; preds = %23
  call void @llvm.lifetime.end.p0i8(i64 11, i8* nonnull %24) #5
  br label %159

35:                                               ; preds = %23
  %36 = add nuw i32 %32, 1
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 1 %19, i8* nonnull align 2 %24, i32 %36, i1 false)
  %37 = getelementptr i8, i8* %19, i32 %32
  %38 = sub i32 %20, %32
  call void @llvm.lifetime.end.p0i8(i64 11, i8* nonnull %24) #5
  %39 = icmp ult i32 %38, 4
  br i1 %39, label %159, label %40

40:                                               ; preds = %35
  %41 = bitcast i8* %37 to i32*
  store i32 4025636, i32* %41, align 1
  %42 = getelementptr i8, i8* %37, i32 3
  %43 = getelementptr inbounds [11 x i8], [11 x i8]* %7, i32 0, i32 0
  call void @llvm.lifetime.start.p0i8(i64 11, i8* nonnull %43) #5
  %44 = getelementptr inbounds %struct.Argon2_Context, %struct.Argon2_Context* %2, i32 0, i32 11
  %45 = load i32, i32* %44, align 4
  call void @llvm.lifetime.start.p0i8(i64 10, i8* nonnull %25) #5
  br label %46

46:                                               ; preds = %46, %40
  %47 = phi i32 [ %45, %40 ], [ %49, %46 ]
  %48 = phi i32 [ 10, %40 ], [ %54, %46 ]
  %49 = udiv i32 %47, 10
  %50 = mul i32 %49, 10
  %51 = sub i32 %47, %50
  %52 = trunc i32 %51 to i8
  %53 = or i8 %52, 48
  %54 = add nsw i32 %48, -1
  %55 = getelementptr [10 x i8], [10 x i8]* %5, i32 0, i32 %54
  store i8 %53, i8* %55, align 1
  %56 = icmp ugt i32 %47, 9
  %57 = icmp ne i32 %54, 0
  %58 = and i1 %56, %57
  br i1 %58, label %46, label %59

59:                                               ; preds = %46
  %60 = add i32 %38, -3
  %61 = sub i32 11, %48
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* nonnull align 1 %43, i8* nonnull align 1 %55, i32 %61, i1 false) #5
  %62 = getelementptr [11 x i8], [11 x i8]* %7, i32 0, i32 %61
  store i8 0, i8* %62, align 1
  call void @llvm.lifetime.end.p0i8(i64 10, i8* nonnull %25) #5
  %63 = call i32 @strlen(i8* nonnull %43) #6
  %64 = icmp ugt i32 %60, %63
  br i1 %64, label %66, label %65

65:                                               ; preds = %59
  call void @llvm.lifetime.end.p0i8(i64 11, i8* nonnull %43) #5
  br label %159

66:                                               ; preds = %59
  %67 = add nuw i32 %63, 1
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 1 %42, i8* nonnull align 1 %43, i32 %67, i1 false)
  %68 = getelementptr i8, i8* %42, i32 %63
  %69 = sub i32 %60, %63
  call void @llvm.lifetime.end.p0i8(i64 11, i8* nonnull %43) #5
  %70 = icmp ult i32 %69, 4
  br i1 %70, label %159, label %71

71:                                               ; preds = %66
  %72 = bitcast i8* %68 to i32*
  store i32 4027436, i32* %72, align 1
  %73 = getelementptr i8, i8* %68, i32 3
  %74 = getelementptr inbounds [11 x i8], [11 x i8]* %8, i32 0, i32 0
  call void @llvm.lifetime.start.p0i8(i64 11, i8* nonnull %74) #5
  %75 = getelementptr inbounds %struct.Argon2_Context, %struct.Argon2_Context* %2, i32 0, i32 10
  %76 = load i32, i32* %75, align 4
  call void @llvm.lifetime.start.p0i8(i64 10, i8* nonnull %25) #5
  br label %77

77:                                               ; preds = %77, %71
  %78 = phi i32 [ %76, %71 ], [ %80, %77 ]
  %79 = phi i32 [ 10, %71 ], [ %85, %77 ]
  %80 = udiv i32 %78, 10
  %81 = mul i32 %80, 10
  %82 = sub i32 %78, %81
  %83 = trunc i32 %82 to i8
  %84 = or i8 %83, 48
  %85 = add nsw i32 %79, -1
  %86 = getelementptr [10 x i8], [10 x i8]* %5, i32 0, i32 %85
  store i8 %84, i8* %86, align 1
  %87 = icmp ugt i32 %78, 9
  %88 = icmp ne i32 %85, 0
  %89 = and i1 %87, %88
  br i1 %89, label %77, label %90

90:                                               ; preds = %77
  %91 = add i32 %69, -3
  %92 = sub i32 11, %79
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* nonnull align 1 %74, i8* nonnull align 1 %86, i32 %92, i1 false) #5
  %93 = getelementptr [11 x i8], [11 x i8]* %8, i32 0, i32 %92
  store i8 0, i8* %93, align 1
  call void @llvm.lifetime.end.p0i8(i64 10, i8* nonnull %25) #5
  %94 = call i32 @strlen(i8* nonnull %74) #6
  %95 = icmp ugt i32 %91, %94
  br i1 %95, label %97, label %96

96:                                               ; preds = %90
  call void @llvm.lifetime.end.p0i8(i64 11, i8* nonnull %74) #5
  br label %159

97:                                               ; preds = %90
  %98 = add nuw i32 %94, 1
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 1 %73, i8* nonnull align 1 %74, i32 %98, i1 false)
  %99 = getelementptr i8, i8* %73, i32 %94
  %100 = sub i32 %91, %94
  call void @llvm.lifetime.end.p0i8(i64 11, i8* nonnull %74) #5
  %101 = icmp ult i32 %100, 4
  br i1 %101, label %159, label %102

102:                                              ; preds = %97
  %103 = bitcast i8* %99 to i32*
  store i32 4026412, i32* %103, align 1
  %104 = getelementptr i8, i8* %99, i32 3
  %105 = getelementptr inbounds [11 x i8], [11 x i8]* %9, i32 0, i32 0
  call void @llvm.lifetime.start.p0i8(i64 11, i8* nonnull %105) #5
  %106 = getelementptr inbounds %struct.Argon2_Context, %struct.Argon2_Context* %2, i32 0, i32 12
  %107 = load i32, i32* %106, align 4
  call void @llvm.lifetime.start.p0i8(i64 10, i8* nonnull %25) #5
  br label %108

108:                                              ; preds = %108, %102
  %109 = phi i32 [ %107, %102 ], [ %111, %108 ]
  %110 = phi i32 [ 10, %102 ], [ %116, %108 ]
  %111 = udiv i32 %109, 10
  %112 = mul i32 %111, 10
  %113 = sub i32 %109, %112
  %114 = trunc i32 %113 to i8
  %115 = or i8 %114, 48
  %116 = add nsw i32 %110, -1
  %117 = getelementptr [10 x i8], [10 x i8]* %5, i32 0, i32 %116
  store i8 %115, i8* %117, align 1
  %118 = icmp ugt i32 %109, 9
  %119 = icmp ne i32 %116, 0
  %120 = and i1 %118, %119
  br i1 %120, label %108, label %121

121:                                              ; preds = %108
  %122 = add i32 %100, -3
  %123 = sub i32 11, %110
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* nonnull align 1 %105, i8* nonnull align 1 %117, i32 %123, i1 false) #5
  %124 = getelementptr [11 x i8], [11 x i8]* %9, i32 0, i32 %123
  store i8 0, i8* %124, align 1
  call void @llvm.lifetime.end.p0i8(i64 10, i8* nonnull %25) #5
  %125 = call i32 @strlen(i8* nonnull %105) #6
  %126 = icmp ugt i32 %122, %125
  br i1 %126, label %128, label %127

127:                                              ; preds = %121
  call void @llvm.lifetime.end.p0i8(i64 11, i8* nonnull %105) #5
  br label %159

128:                                              ; preds = %121
  %129 = add nuw i32 %125, 1
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 1 %104, i8* nonnull align 1 %105, i32 %129, i1 false)
  %130 = getelementptr i8, i8* %104, i32 %125
  %131 = sub i32 %122, %125
  call void @llvm.lifetime.end.p0i8(i64 11, i8* nonnull %105) #5
  %132 = icmp ult i32 %131, 2
  br i1 %132, label %159, label %133

133:                                              ; preds = %128
  %134 = bitcast i8* %130 to i16*
  store i16 36, i16* %134, align 1
  %135 = getelementptr i8, i8* %130, i32 1
  %136 = add i32 %131, -1
  %137 = getelementptr inbounds %struct.Argon2_Context, %struct.Argon2_Context* %2, i32 0, i32 4
  %138 = load i8*, i8** %137, align 4
  %139 = getelementptr inbounds %struct.Argon2_Context, %struct.Argon2_Context* %2, i32 0, i32 5
  %140 = load i32, i32* %139, align 4
  %141 = tail call i8* @sodium_bin2base64(i8* %135, i32 %136, i8* %138, i32 %140, i32 3) #5
  %142 = icmp eq i8* %141, null
  br i1 %142, label %159, label %143

143:                                              ; preds = %133
  %144 = tail call i32 @strlen(i8* nonnull dereferenceable(1) %135) #6
  %145 = getelementptr i8, i8* %135, i32 %144
  %146 = sub i32 %136, %144
  %147 = icmp ult i32 %146, 2
  br i1 %147, label %159, label %148

148:                                              ; preds = %143
  %149 = bitcast i8* %145 to i16*
  store i16 36, i16* %149, align 1
  %150 = getelementptr i8, i8* %145, i32 1
  %151 = add i32 %146, -1
  %152 = getelementptr inbounds %struct.Argon2_Context, %struct.Argon2_Context* %2, i32 0, i32 0
  %153 = load i8*, i8** %152, align 4
  %154 = getelementptr inbounds %struct.Argon2_Context, %struct.Argon2_Context* %2, i32 0, i32 1
  %155 = load i32, i32* %154, align 4
  %156 = tail call i8* @sodium_bin2base64(i8* %150, i32 %151, i8* %153, i32 %155, i32 3) #5
  %157 = icmp eq i8* %156, null
  %158 = select i1 %157, i32 -31, i32 0
  ret i32 %158

159:                                              ; preds = %143, %133, %128, %127, %97, %96, %66, %65, %35, %34, %13, %10, %16, %4
  %160 = phi i32 [ -31, %127 ], [ -31, %96 ], [ -31, %65 ], [ -31, %34 ], [ -31, %4 ], [ %21, %16 ], [ -31, %10 ], [ -31, %13 ], [ -31, %35 ], [ -31, %66 ], [ -31, %97 ], [ -31, %128 ], [ -31, %133 ], [ -31, %143 ]
  ret i32 %160
}

; Function Attrs: argmemonly nounwind willreturn
declare void @llvm.memcpy.p0i8.p0i8.i32(i8* noalias nocapture writeonly %0, i8* noalias nocapture readonly %1, i32 %2, i1 immarg %3) #1

declare i8* @sodium_bin2base64(i8* %0, i32 %1, i8* %2, i32 %3, i32 %4) local_unnamed_addr #3

attributes #0 = { nounwind "correctly-rounded-divide-sqrt-fp-math"="false" "disable-tail-calls"="false" "frame-pointer"="none" "less-precise-fpmad"="false" "min-legal-vector-width"="0" "no-infs-fp-math"="false" "no-jump-tables"="false" "no-nans-fp-math"="false" "no-signed-zeros-fp-math"="false" "no-trapping-math"="false" "stack-protector-buffer-size"="8" "target-cpu"="generic" "unsafe-fp-math"="false" "use-soft-float"="false" }
attributes #1 = { argmemonly nounwind willreturn }
attributes #2 = { nofree nounwind readonly "correctly-rounded-divide-sqrt-fp-math"="false" "disable-tail-calls"="false" "frame-pointer"="none" "less-precise-fpmad"="false" "no-infs-fp-math"="false" "no-nans-fp-math"="false" "no-signed-zeros-fp-math"="false" "no-trapping-math"="false" "stack-protector-buffer-size"="8" "target-cpu"="generic" "unsafe-fp-math"="false" "use-soft-float"="false" }
attributes #3 = { "correctly-rounded-divide-sqrt-fp-math"="false" "disable-tail-calls"="false" "frame-pointer"="none" "less-precise-fpmad"="false" "no-infs-fp-math"="false" "no-nans-fp-math"="false" "no-signed-zeros-fp-math"="false" "no-trapping-math"="false" "stack-protector-buffer-size"="8" "target-cpu"="generic" "unsafe-fp-math"="false" "use-soft-float"="false" }
attributes #4 = { argmemonly nofree nounwind readonly "correctly-rounded-divide-sqrt-fp-math"="false" "disable-tail-calls"="false" "frame-pointer"="none" "less-precise-fpmad"="false" "no-infs-fp-math"="false" "no-nans-fp-math"="false" "no-signed-zeros-fp-math"="false" "no-trapping-math"="false" "stack-protector-buffer-size"="8" "target-cpu"="generic" "unsafe-fp-math"="false" "use-soft-float"="false" }
attributes #5 = { nounwind }
attributes #6 = { nounwind readonly }

!llvm.module.flags = !{!0, !1, !2}
!llvm.ident = !{!3}

!0 = !{i32 1, !"wchar_size", i32 4}
!1 = !{i32 7, !"PIC Level", i32 2}
!2 = !{i32 7, !"PIE Level", i32 2}
!3 = !{!"clang version 10.0.0 (https://github.com/llvm/llvm-project d32170dbd5b0d54436537b6b75beaf44324e0c28)"}

; extracted candidates

; *****
; For LLVM instruction:
;  %9 = load i32, i32* %8, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %11 = load i32, i32* %10, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %13 = tail call i32 @strncmp(i8* nonnull dereferenceable(1) %1, i8* nonnull dereferenceable(10) getelementptr inbounds ([10 x i8], [10 x i8]* @.str, i32 0, i32 0), i32 9)
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %14 = icmp eq i32 %13, 0
; Looking for a replacement for:
%0:i32 = var
%1:i1 = eq 0:i32, %0
infer %1

; *****
; For LLVM instruction:
;  %17 = tail call i32 @strncmp(i8* nonnull dereferenceable(1) %1, i8* nonnull dereferenceable(9) getelementptr inbounds ([9 x i8], [9 x i8]* @.str.1, i32 0, i32 0), i32 8)
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %18 = icmp eq i32 %17, 0
; Looking for a replacement for:
%0:i32 = var
%1:i1 = eq 0:i32, %0
infer %1

; *****
; For LLVM instruction:
;  %22 = tail call i32 @strncmp(i8* nonnull dereferenceable(1) %21, i8* nonnull dereferenceable(4) getelementptr inbounds ([4 x i8], [4 x i8]* @.str.2, i32 0, i32 0), i32 3)
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %23 = icmp eq i32 %22, 0
; Looking for a replacement for:
%0:i32 = var
%1:i1 = eq 0:i32, %0
infer %1

; *****
; For LLVM instruction:
;  %27 = load i8, i8* %25, align 1
; Looking for a replacement for:
%0:i8 = var
infer %0

; *****
; For LLVM instruction:
;  %28 = add i8 %27, -48
; Looking for a replacement for:
%0:i8 = var
%1:i8 = add 208:i8, %0
infer %1

; *****
; For LLVM instruction:
;  %29 = icmp ugt i8 %28, 9
; Looking for a replacement for:
%0:i8 = var
%1:i8 = add 208:i8, %0
%2:i1 = ult 9:i8, %1
infer %2

; *****
; For LLVM instruction:
;  %31 = phi i8 [ %44, %41 ], [ %27, %26 ]
; Looking for a replacement for:
%0:i8 = var (range=[48,58))
infer %0

; *****
; For LLVM instruction:
;  %32 = phi i32 [ %42, %41 ], [ 0, %26 ]
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %34 = zext i8 %31 to i32
; Looking for a replacement for:
%0:i8 = var (range=[48,58))
%1:i32 = zext %0
infer %1

; *****
; For LLVM instruction:
;  %35 = add nsw i32 %34, -48
; Looking for a replacement for:
%0:i8 = var (range=[48,58))
%1:i32 = zext %0
%2:i32 = addnsw 4294967248:i32, %1
infer %2

; *****
; For LLVM instruction:
;  %36 = icmp ugt i32 %32, 429496729
; Looking for a replacement for:
%0:i32 = var
%1:i1 = ult 429496729:i32, %0
infer %1

; *****
; For LLVM instruction:
;  %38 = mul nuw i32 %32, 10
; Looking for a replacement for:
%0:i32 = var
%1:i1 = ult 429496729:i32, %0
pc %1 0:i1
%2:i32 = mulnuw 10:i32, %0
infer %2

; *****
; For LLVM instruction:
;  %39 = xor i32 %38, -1
; Looking for a replacement for:
%0:i32 = var
%1:i1 = ult 429496729:i32, %0
pc %1 0:i1
%2:i32 = mulnuw 10:i32, %0 (hasExternalUses)
%3:i32 = xor 4294967295:i32, %2
infer %3

; *****
; For LLVM instruction:
;  %40 = icmp ugt i32 %35, %39
; Looking for a replacement for:
%0:i32 = var
%1:i1 = ult 429496729:i32, %0
pc %1 0:i1
%2:i32 = mulnuw 10:i32, %0 (hasExternalUses)
%3:i32 = xor 4294967295:i32, %2
%4:i8 = var (range=[48,58))
%5:i32 = zext %4
%6:i32 = addnsw 4294967248:i32, %5 (hasExternalUses)
%7:i1 = ult %3, %6
infer %7

; *****
; For LLVM instruction:
;  %42 = add i32 %35, %38
; Looking for a replacement for:
%0:i32 = var
%1:i1 = ult 429496729:i32, %0
pc %1 0:i1
%2:i32 = mulnuw 10:i32, %0 (hasExternalUses)
%3:i32 = xor 4294967295:i32, %2
%4:i8 = var (range=[48,58))
%5:i32 = zext %4
%6:i32 = addnsw 4294967248:i32, %5 (hasExternalUses)
%7:i1 = ult %3, %6
pc %7 0:i1
%8:i32 = add %6, %2
infer %8

; *****
; For LLVM instruction:
;  %44 = load i8, i8* %43, align 1
; Looking for a replacement for:
%0:i8 = var
infer %0

; *****
; For LLVM instruction:
;  %45 = add i8 %44, -48
; Looking for a replacement for:
%0:i8 = var
%1:i8 = add 208:i8, %0
infer %1

; *****
; For LLVM instruction:
;  %46 = icmp ugt i8 %45, 9
; Looking for a replacement for:
%0:i8 = var
%1:i8 = add 208:i8, %0
%2:i1 = ult 9:i8, %1
infer %2

; *****
; For LLVM instruction:
;  %48 = icmp eq i8* %43, %25
; Looking for a replacement for:
%0:i32 = var
%1:i32 = var
%2:i1 = eq %0, %1
infer %2

; *****
; For LLVM instruction:
;  %50 = icmp ne i8 %27, 48
; Looking for a replacement for:
%0:i8 = var
%1:i1 = ne 48:i8, %0
infer %1

; *****
; For LLVM instruction:
;  %51 = icmp eq i8* %33, %25
; Looking for a replacement for:
%0:i32 = var
%1:i32 = var
%2:i1 = eq %0, %1
pc %2 0:i1
%3:i32 = var
%4:i1 = eq %1, %3
infer %4

; *****
; For LLVM instruction:
;  %52 = or i1 %50, %51
; Looking for a replacement for:
%0:i32 = var
%1:i32 = var
%2:i1 = eq %0, %1
pc %2 0:i1
%3:i32 = var
%4:i1 = eq %1, %3
%5:i8 = var
%6:i1 = ne 48:i8, %5
%7:i1 = or %4, %6
infer %7

; *****
; For LLVM instruction:
;  %54 = icmp eq i32 %42, 19
; Looking for a replacement for:
%0:i32 = var
%1:i1 = ult 429496729:i32, %0
pc %1 0:i1
%2:i32 = mulnuw 10:i32, %0 (hasExternalUses)
%3:i32 = xor 4294967295:i32, %2
%4:i8 = var (range=[48,58))
%5:i32 = zext %4
%6:i32 = addnsw 4294967248:i32, %5 (hasExternalUses)
%7:i1 = ult %3, %6
pc %7 0:i1
%8:i32 = add %6, %2 (hasExternalUses)
%9:i1 = eq 19:i32, %8
infer %9

; *****
; For LLVM instruction:
;  %56 = tail call i32 @strncmp(i8* nonnull dereferenceable(1) %43, i8* nonnull dereferenceable(4) getelementptr inbounds ([4 x i8], [4 x i8]* @.str.3, i32 0, i32 0), i32 3)
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %57 = icmp eq i32 %56, 0
; Looking for a replacement for:
%0:i32 = var
%1:i1 = eq 0:i32, %0
infer %1

; *****
; For LLVM instruction:
;  %61 = load i8, i8* %59, align 1
; Looking for a replacement for:
%0:i8 = var
infer %0

; *****
; For LLVM instruction:
;  %62 = add i8 %61, -48
; Looking for a replacement for:
%0:i8 = var
%1:i8 = add 208:i8, %0
infer %1

; *****
; For LLVM instruction:
;  %63 = icmp ugt i8 %62, 9
; Looking for a replacement for:
%0:i8 = var
%1:i8 = add 208:i8, %0
%2:i1 = ult 9:i8, %1
infer %2

; *****
; For LLVM instruction:
;  %65 = phi i8 [ %78, %75 ], [ %61, %60 ]
; Looking for a replacement for:
%0:i8 = var (range=[48,58))
infer %0

; *****
; For LLVM instruction:
;  %66 = phi i32 [ %76, %75 ], [ 0, %60 ]
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %68 = zext i8 %65 to i32
; Looking for a replacement for:
%0:i8 = var (range=[48,58))
%1:i32 = zext %0
infer %1

; *****
; For LLVM instruction:
;  %69 = add nsw i32 %68, -48
; Looking for a replacement for:
%0:i8 = var (range=[48,58))
%1:i32 = zext %0
%2:i32 = addnsw 4294967248:i32, %1
infer %2

; *****
; For LLVM instruction:
;  %70 = icmp ugt i32 %66, 429496729
; Looking for a replacement for:
%0:i32 = var
%1:i1 = ult 429496729:i32, %0
infer %1

; *****
; For LLVM instruction:
;  %72 = mul nuw i32 %66, 10
; Looking for a replacement for:
%0:i32 = var
%1:i1 = ult 429496729:i32, %0
pc %1 0:i1
%2:i32 = mulnuw 10:i32, %0
infer %2

; *****
; For LLVM instruction:
;  %73 = xor i32 %72, -1
; Looking for a replacement for:
%0:i32 = var
%1:i1 = ult 429496729:i32, %0
pc %1 0:i1
%2:i32 = mulnuw 10:i32, %0 (hasExternalUses)
%3:i32 = xor 4294967295:i32, %2
infer %3

; *****
; For LLVM instruction:
;  %74 = icmp ugt i32 %69, %73
; Looking for a replacement for:
%0:i32 = var
%1:i1 = ult 429496729:i32, %0
pc %1 0:i1
%2:i32 = mulnuw 10:i32, %0 (hasExternalUses)
%3:i32 = xor 4294967295:i32, %2
%4:i8 = var (range=[48,58))
%5:i32 = zext %4
%6:i32 = addnsw 4294967248:i32, %5 (hasExternalUses)
%7:i1 = ult %3, %6
infer %7

; *****
; For LLVM instruction:
;  %76 = add i32 %69, %72
; Looking for a replacement for:
%0:i32 = var
%1:i1 = ult 429496729:i32, %0
pc %1 0:i1
%2:i32 = mulnuw 10:i32, %0 (hasExternalUses)
%3:i32 = xor 4294967295:i32, %2
%4:i8 = var (range=[48,58))
%5:i32 = zext %4
%6:i32 = addnsw 4294967248:i32, %5 (hasExternalUses)
%7:i1 = ult %3, %6
pc %7 0:i1
%8:i32 = add %6, %2
infer %8

; *****
; For LLVM instruction:
;  %78 = load i8, i8* %77, align 1
; Looking for a replacement for:
%0:i8 = var
infer %0

; *****
; For LLVM instruction:
;  %79 = add i8 %78, -48
; Looking for a replacement for:
%0:i8 = var
%1:i8 = add 208:i8, %0
infer %1

; *****
; For LLVM instruction:
;  %80 = icmp ugt i8 %79, 9
; Looking for a replacement for:
%0:i8 = var
%1:i8 = add 208:i8, %0
%2:i1 = ult 9:i8, %1
infer %2

; *****
; For LLVM instruction:
;  %82 = icmp eq i8* %77, %59
; Looking for a replacement for:
%0:i32 = var
%1:i32 = var
%2:i1 = eq %0, %1
infer %2

; *****
; For LLVM instruction:
;  %84 = icmp eq i8 %61, 48
; Looking for a replacement for:
%0:i8 = var
%1:i1 = eq 48:i8, %0
infer %1

; *****
; For LLVM instruction:
;  %85 = icmp ne i8* %67, %59
; Looking for a replacement for:
%0:i32 = var
%1:i32 = var
%2:i1 = eq %0, %1
pc %2 0:i1
%3:i32 = var
%4:i1 = ne %1, %3
infer %4

; *****
; For LLVM instruction:
;  %86 = and i1 %84, %85
; Looking for a replacement for:
%0:i32 = var
%1:i32 = var
%2:i1 = eq %0, %1
pc %2 0:i1
%3:i8 = var
%4:i1 = eq 48:i8, %3
%5:i32 = var
%6:i1 = ne %1, %5
%7:i1 = and %4, %6
infer %7

; *****
; For LLVM instruction:
;  %89 = tail call i32 @strncmp(i8* nonnull dereferenceable(1) %77, i8* nonnull dereferenceable(4) getelementptr inbounds ([4 x i8], [4 x i8]* @.str.4, i32 0, i32 0), i32 3)
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %90 = icmp eq i32 %89, 0
; Looking for a replacement for:
%0:i32 = var
%1:i1 = eq 0:i32, %0
infer %1

; *****
; For LLVM instruction:
;  %94 = load i8, i8* %92, align 1
; Looking for a replacement for:
%0:i8 = var
infer %0

; *****
; For LLVM instruction:
;  %95 = add i8 %94, -48
; Looking for a replacement for:
%0:i8 = var
%1:i8 = add 208:i8, %0
infer %1

; *****
; For LLVM instruction:
;  %96 = icmp ugt i8 %95, 9
; Looking for a replacement for:
%0:i8 = var
%1:i8 = add 208:i8, %0
%2:i1 = ult 9:i8, %1
infer %2

; *****
; For LLVM instruction:
;  %98 = phi i8 [ %111, %108 ], [ %94, %93 ]
; Looking for a replacement for:
%0:i8 = var (range=[48,58))
infer %0

; *****
; For LLVM instruction:
;  %99 = phi i32 [ %109, %108 ], [ 0, %93 ]
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %101 = zext i8 %98 to i32
; Looking for a replacement for:
%0:i8 = var (range=[48,58))
%1:i32 = zext %0
infer %1

; *****
; For LLVM instruction:
;  %102 = add nsw i32 %101, -48
; Looking for a replacement for:
%0:i8 = var (range=[48,58))
%1:i32 = zext %0
%2:i32 = addnsw 4294967248:i32, %1
infer %2

; *****
; For LLVM instruction:
;  %103 = icmp ugt i32 %99, 429496729
; Looking for a replacement for:
%0:i32 = var
%1:i1 = ult 429496729:i32, %0
infer %1

; *****
; For LLVM instruction:
;  %105 = mul nuw i32 %99, 10
; Looking for a replacement for:
%0:i32 = var
%1:i1 = ult 429496729:i32, %0
pc %1 0:i1
%2:i32 = mulnuw 10:i32, %0
infer %2

; *****
; For LLVM instruction:
;  %106 = xor i32 %105, -1
; Looking for a replacement for:
%0:i32 = var
%1:i1 = ult 429496729:i32, %0
pc %1 0:i1
%2:i32 = mulnuw 10:i32, %0 (hasExternalUses)
%3:i32 = xor 4294967295:i32, %2
infer %3

; *****
; For LLVM instruction:
;  %107 = icmp ugt i32 %102, %106
; Looking for a replacement for:
%0:i32 = var
%1:i1 = ult 429496729:i32, %0
pc %1 0:i1
%2:i32 = mulnuw 10:i32, %0 (hasExternalUses)
%3:i32 = xor 4294967295:i32, %2
%4:i8 = var (range=[48,58))
%5:i32 = zext %4
%6:i32 = addnsw 4294967248:i32, %5 (hasExternalUses)
%7:i1 = ult %3, %6
infer %7

; *****
; For LLVM instruction:
;  %109 = add i32 %102, %105
; Looking for a replacement for:
%0:i32 = var
%1:i1 = ult 429496729:i32, %0
pc %1 0:i1
%2:i32 = mulnuw 10:i32, %0 (hasExternalUses)
%3:i32 = xor 4294967295:i32, %2
%4:i8 = var (range=[48,58))
%5:i32 = zext %4
%6:i32 = addnsw 4294967248:i32, %5 (hasExternalUses)
%7:i1 = ult %3, %6
pc %7 0:i1
%8:i32 = add %6, %2
infer %8

; *****
; For LLVM instruction:
;  %111 = load i8, i8* %110, align 1
; Looking for a replacement for:
%0:i8 = var
infer %0

; *****
; For LLVM instruction:
;  %112 = add i8 %111, -48
; Looking for a replacement for:
%0:i8 = var
%1:i8 = add 208:i8, %0
infer %1

; *****
; For LLVM instruction:
;  %113 = icmp ugt i8 %112, 9
; Looking for a replacement for:
%0:i8 = var
%1:i8 = add 208:i8, %0
%2:i1 = ult 9:i8, %1
infer %2

; *****
; For LLVM instruction:
;  %115 = icmp eq i8* %110, %92
; Looking for a replacement for:
%0:i32 = var
%1:i32 = var
%2:i1 = eq %0, %1
infer %2

; *****
; For LLVM instruction:
;  %117 = icmp eq i8 %94, 48
; Looking for a replacement for:
%0:i8 = var
%1:i1 = eq 48:i8, %0
infer %1

; *****
; For LLVM instruction:
;  %118 = icmp ne i8* %100, %92
; Looking for a replacement for:
%0:i32 = var
%1:i32 = var
%2:i1 = eq %0, %1
pc %2 0:i1
%3:i32 = var
%4:i1 = ne %1, %3
infer %4

; *****
; For LLVM instruction:
;  %119 = and i1 %117, %118
; Looking for a replacement for:
%0:i32 = var
%1:i32 = var
%2:i1 = eq %0, %1
pc %2 0:i1
%3:i8 = var
%4:i1 = eq 48:i8, %3
%5:i32 = var
%6:i1 = ne %1, %5
%7:i1 = and %4, %6
infer %7

; *****
; For LLVM instruction:
;  %122 = tail call i32 @strncmp(i8* nonnull dereferenceable(1) %110, i8* nonnull dereferenceable(4) getelementptr inbounds ([4 x i8], [4 x i8]* @.str.5, i32 0, i32 0), i32 3)
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %123 = icmp eq i32 %122, 0
; Looking for a replacement for:
%0:i32 = var
%1:i1 = eq 0:i32, %0
infer %1

; *****
; For LLVM instruction:
;  %127 = load i8, i8* %125, align 1
; Looking for a replacement for:
%0:i8 = var
infer %0

; *****
; For LLVM instruction:
;  %128 = add i8 %127, -48
; Looking for a replacement for:
%0:i8 = var
%1:i8 = add 208:i8, %0
infer %1

; *****
; For LLVM instruction:
;  %129 = icmp ugt i8 %128, 9
; Looking for a replacement for:
%0:i8 = var
%1:i8 = add 208:i8, %0
%2:i1 = ult 9:i8, %1
infer %2

; *****
; For LLVM instruction:
;  %131 = phi i8 [ %144, %141 ], [ %127, %126 ]
; Looking for a replacement for:
%0:i8 = var (range=[48,58))
infer %0

; *****
; For LLVM instruction:
;  %132 = phi i32 [ %142, %141 ], [ 0, %126 ]
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %134 = zext i8 %131 to i32
; Looking for a replacement for:
%0:i8 = var (range=[48,58))
%1:i32 = zext %0
infer %1

; *****
; For LLVM instruction:
;  %135 = add nsw i32 %134, -48
; Looking for a replacement for:
%0:i8 = var (range=[48,58))
%1:i32 = zext %0
%2:i32 = addnsw 4294967248:i32, %1
infer %2

; *****
; For LLVM instruction:
;  %136 = icmp ugt i32 %132, 429496729
; Looking for a replacement for:
%0:i32 = var
%1:i1 = ult 429496729:i32, %0
infer %1

; *****
; For LLVM instruction:
;  %138 = mul nuw i32 %132, 10
; Looking for a replacement for:
%0:i32 = var
%1:i1 = ult 429496729:i32, %0
pc %1 0:i1
%2:i32 = mulnuw 10:i32, %0
infer %2

; *****
; For LLVM instruction:
;  %139 = xor i32 %138, -1
; Looking for a replacement for:
%0:i32 = var
%1:i1 = ult 429496729:i32, %0
pc %1 0:i1
%2:i32 = mulnuw 10:i32, %0 (hasExternalUses)
%3:i32 = xor 4294967295:i32, %2
infer %3

; *****
; For LLVM instruction:
;  %140 = icmp ugt i32 %135, %139
; Looking for a replacement for:
%0:i32 = var
%1:i1 = ult 429496729:i32, %0
pc %1 0:i1
%2:i32 = mulnuw 10:i32, %0 (hasExternalUses)
%3:i32 = xor 4294967295:i32, %2
%4:i8 = var (range=[48,58))
%5:i32 = zext %4
%6:i32 = addnsw 4294967248:i32, %5 (hasExternalUses)
%7:i1 = ult %3, %6
infer %7

; *****
; For LLVM instruction:
;  %142 = add i32 %135, %138
; Looking for a replacement for:
%0:i32 = var
%1:i1 = ult 429496729:i32, %0
pc %1 0:i1
%2:i32 = mulnuw 10:i32, %0 (hasExternalUses)
%3:i32 = xor 4294967295:i32, %2
%4:i8 = var (range=[48,58))
%5:i32 = zext %4
%6:i32 = addnsw 4294967248:i32, %5 (hasExternalUses)
%7:i1 = ult %3, %6
pc %7 0:i1
%8:i32 = add %6, %2
infer %8

; *****
; For LLVM instruction:
;  %144 = load i8, i8* %143, align 1
; Looking for a replacement for:
%0:i8 = var
infer %0

; *****
; For LLVM instruction:
;  %145 = add i8 %144, -48
; Looking for a replacement for:
%0:i8 = var
%1:i8 = add 208:i8, %0
infer %1

; *****
; For LLVM instruction:
;  %146 = icmp ugt i8 %145, 9
; Looking for a replacement for:
%0:i8 = var
%1:i8 = add 208:i8, %0
%2:i1 = ult 9:i8, %1
infer %2

; *****
; For LLVM instruction:
;  %148 = icmp eq i8* %143, %125
; Looking for a replacement for:
%0:i32 = var
%1:i32 = var
%2:i1 = eq %0, %1
infer %2

; *****
; For LLVM instruction:
;  %150 = icmp eq i8 %127, 48
; Looking for a replacement for:
%0:i8 = var
%1:i1 = eq 48:i8, %0
infer %1

; *****
; For LLVM instruction:
;  %151 = icmp ne i8* %133, %125
; Looking for a replacement for:
%0:i32 = var
%1:i32 = var
%2:i1 = eq %0, %1
pc %2 0:i1
%3:i32 = var
%4:i1 = ne %1, %3
infer %4

; *****
; For LLVM instruction:
;  %152 = and i1 %150, %151
; Looking for a replacement for:
%0:i32 = var
%1:i32 = var
%2:i1 = eq %0, %1
pc %2 0:i1
%3:i8 = var
%4:i1 = eq 48:i8, %3
%5:i32 = var
%6:i1 = ne %1, %5
%7:i1 = and %4, %6
infer %7

; *****
; For LLVM instruction:
;  %156 = load i8, i8* %143, align 1
; Looking for a replacement for:
%0:i8 = var
infer %0

; *****
; For LLVM instruction:
;  %157 = icmp eq i8 %156, 36
; Looking for a replacement for:
%0:i8 = var
%1:i1 = eq 36:i8, %0
infer %1

; *****
; For LLVM instruction:
;  %165 = tail call i32 @strlen(i8* nonnull dereferenceable(1) %159) #6
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %166 = call i32 @sodium_base642bin(i8* %164, i32 %9, i8* %159, i32 %165, i8* null, i32* nonnull %4, i8** nonnull %5, i32 3) #5
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %167 = icmp eq i32 %166, 0
; Looking for a replacement for:
%0:i32 = var
%1:i1 = eq 0:i32, %0
infer %1

; *****
; For LLVM instruction:
;  %170 = load i32, i32* %4, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %172 = load i8, i8* %171, align 1
; Looking for a replacement for:
%0:i8 = var
infer %0

; *****
; For LLVM instruction:
;  %173 = icmp eq i8 %172, 36
; Looking for a replacement for:
%0:i8 = var
%1:i1 = eq 36:i8, %0
infer %1

; *****
; For LLVM instruction:
;  %181 = call i32 @strlen(i8* nonnull dereferenceable(1) %175) #6
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %182 = call i32 @sodium_base642bin(i8* %180, i32 %11, i8* %175, i32 %181, i8* null, i32* nonnull %6, i8** nonnull %7, i32 3) #5
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %183 = icmp eq i32 %182, 0
; Looking for a replacement for:
%0:i32 = var
%1:i1 = eq 0:i32, %0
infer %1

; *****
; For LLVM instruction:
;  %186 = load i32, i32* %6, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %188 = call i32 @argon2_validate_inputs(%struct.Argon2_Context* nonnull %0) #5
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %189 = icmp eq i32 %188, 0
; Looking for a replacement for:
%0:i32 = var
%1:i1 = eq 0:i32, %0
infer %1

; *****
; For LLVM instruction:
;  %191 = load i8, i8* %187, align 1
; Looking for a replacement for:
%0:i8 = var
infer %0

; *****
; For LLVM instruction:
;  %192 = icmp eq i8 %191, 0
; Looking for a replacement for:
%0:i8 = var
%1:i1 = eq 0:i8, %0
infer %1

; *****
; For LLVM instruction:
;  %193 = select i1 %192, i32 0, i32 -32
; Looking for a replacement for:
%0:i8 = var
%1:i1 = eq 0:i8, %0
%2:i32 = select %1, 0:i32, 4294967264:i32
infer %2

; *****
; For LLVM instruction:
;  %195 = phi i32 [ -32, %184 ], [ -32, %169 ], [ -32, %168 ], [ -32, %153 ], [ -32, %120 ], [ -32, %87 ], [ -32, %55 ], [ -32, %20 ], [ -32, %12 ], [ -32, %16 ], [ -26, %3 ], [ -26, %53 ], [ %188, %185 ], [ %193, %190 ], [ -32, %49 ], [ -32, %47 ], [ -32, %26 ], [ -32, %83 ], [ -32, %81 ], [ -32, %60 ], [ -32, %116 ], [ -32, %114 ], [ -32, %93 ], [ -32, %149 ], [ -32, %147 ], [ -32, %126 ], [ -32, %130 ], [ -32, %137 ], [ -32, %97 ], [ -32, %104 ], [ -32, %64 ], [ -32, %71 ], [ -32, %30 ], [ -32, %37 ]
; Looking for a replacement for:
%0 = block 34
%1:i32 = var
%2:i8 = var
%3:i1 = eq 0:i8, %2
%4:i32 = select %3, 0:i32, 4294967264:i32
%5:i32 = phi %0, 4294967264:i32, 4294967264:i32, 4294967264:i32, 4294967264:i32, 4294967264:i32, 4294967264:i32, 4294967264:i32, 4294967264:i32, 4294967264:i32, 4294967264:i32, 4294967270:i32, 4294967270:i32, %1, %4, 4294967264:i32, 4294967264:i32, 4294967264:i32, 4294967264:i32, 4294967264:i32, 4294967264:i32, 4294967264:i32, 4294967264:i32, 4294967264:i32, 4294967264:i32, 4294967264:i32, 4294967264:i32, 4294967264:i32, 4294967264:i32, 4294967264:i32, 4294967264:i32, 4294967264:i32, 4294967264:i32, 4294967264:i32, 4294967264:i32
infer %5
got 1 candidates from LHS

-------------------------------------------------
%0:i32 = var
infer %0


--------------------------------
guess 0

%0:i32 = var ; reservedconst_1

Cost = 0
first query is SAT, returning the model:
reservedconst_1: 0
0 th attempt: second query is SAT-- constant doesn't work
first query is SAT, returning the model:
reservedconst_1: -1
1 th attempt: second query is SAT-- constant doesn't work
first query is UNSAT-- no more guesses
Dataflow Pruned 0/0
There are 1 Guesses
There are 0 RHSs before deduplication
There are 0 RHSs after deduplication
got 2 candidates from LHS

-------------------------------------------------
%0:i32 = var
%1:i1 = eq 0:i32, %0
infer %1


--------------------------------
guess 0

%0:i1 = var ; reservedconst_1

Cost = 0
first query is SAT, returning the model:
reservedconst_1: -1
0 th attempt: second query is SAT-- constant doesn't work
first query is SAT, returning the model:
reservedconst_1: 0
1 th attempt: second query is SAT-- constant doesn't work
first query is UNSAT-- no more guesses
Dataflow Pruned 0/0
There are 1 Guesses
There are 0 RHSs before deduplication
There are 0 RHSs after deduplication
got 1 candidates from LHS

-------------------------------------------------
%0:i8 = var
infer %0


--------------------------------
guess 0

%0:i8 = var ; reservedconst_1

Cost = 0
first query is SAT, returning the model:
reservedconst_1: 0
0 th attempt: second query is SAT-- constant doesn't work
first query is SAT, returning the model:
reservedconst_1: -1
1 th attempt: second query is SAT-- constant doesn't work
first query is UNSAT-- no more guesses
Dataflow Pruned 0/0
There are 1 Guesses
There are 0 RHSs before deduplication
There are 0 RHSs after deduplication
got 2 candidates from LHS

-------------------------------------------------
%0:i8 = var
%1:i8 = add 208:i8, %0
infer %1


--------------------------------
guess 0

%0:i8 = var ; reservedconst_1

Cost = 0
first query is SAT, returning the model:
reservedconst_1: -48
0 th attempt: second query is SAT-- constant doesn't work
first query is SAT, returning the model:
reservedconst_1: -49
1 th attempt: second query is SAT-- constant doesn't work
first query is UNSAT-- no more guesses

--------------------------------
guess 1

%0:i8 = var

Cost = 0
second query is SAT-- constant doesn't work
Dataflow Pruned 0/0
There are 2 Guesses
There are 0 RHSs before deduplication
There are 0 RHSs after deduplication
got 3 candidates from LHS

-------------------------------------------------
%0:i8 = var
%1:i8 = add 208:i8, %0
%2:i1 = ult 9:i8, %1
infer %2


--------------------------------
guess 0

%0:i1 = var ; reservedconst_1

Cost = 0
first query is SAT, returning the model:
reservedconst_1: -1
0 th attempt: second query is SAT-- constant doesn't work
first query is SAT, returning the model:
reservedconst_1: 0
1 th attempt: second query is SAT-- constant doesn't work
first query is UNSAT-- no more guesses
Dataflow Pruned 0/0
There are 1 Guesses
There are 0 RHSs before deduplication
There are 0 RHSs after deduplication
got 1 candidates from LHS

-------------------------------------------------
%0:i8 = var (range=[48,58))
infer %0


--------------------------------
guess 0

%0:i8 = var ; reservedconst_1

Cost = 0
first query is SAT, returning the model:
reservedconst_1: 48
0 th attempt: second query is SAT-- constant doesn't work
first query is SAT, returning the model:
reservedconst_1: 49
1 th attempt: second query is SAT-- constant doesn't work
first query is UNSAT-- no more guesses
Dataflow Pruned 0/0
There are 1 Guesses
There are 0 RHSs before deduplication
There are 0 RHSs after deduplication
got 2 candidates from LHS

-------------------------------------------------
%0:i8 = var (range=[48,58))
%1:i32 = zext %0
infer %1


--------------------------------
guess 0

%0:i32 = var ; reservedconst_1

Cost = 0
first query is SAT, returning the model:
reservedconst_1: 48
0 th attempt: second query is SAT-- constant doesn't work
first query is SAT, returning the model:
reservedconst_1: 49
1 th attempt: second query is SAT-- constant doesn't work
first query is UNSAT-- no more guesses
Dataflow Pruned 0/0
There are 1 Guesses
There are 0 RHSs before deduplication
There are 0 RHSs after deduplication
got 3 candidates from LHS

-------------------------------------------------
%0:i8 = var (range=[48,58))
%1:i32 = zext %0
%2:i32 = addnsw 4294967248:i32, %1
infer %2


--------------------------------
guess 0

%0:i32 = var ; reservedconst_1

Cost = 0
first query is SAT, returning the model:
reservedconst_1: 0
0 th attempt: second query is SAT-- constant doesn't work
first query is SAT, returning the model:
reservedconst_1: 1
1 th attempt: second query is SAT-- constant doesn't work
first query is UNSAT-- no more guesses

--------------------------------
guess 1

%0:i8 = var (range=[48,58))
%1:i32 = zext %0

Cost = 1
second query is SAT-- constant doesn't work
Dataflow Pruned 0/0
There are 2 Guesses
There are 0 RHSs before deduplication
There are 0 RHSs after deduplication
got 2 candidates from LHS

-------------------------------------------------
%0:i32 = var
%1:i1 = ult 429496729:i32, %0
infer %1


--------------------------------
guess 0

%0:i1 = var ; reservedconst_1

Cost = 0
first query is SAT, returning the model:
reservedconst_1: 0
0 th attempt: second query is SAT-- constant doesn't work
first query is SAT, returning the model:
reservedconst_1: -1
1 th attempt: second query is SAT-- constant doesn't work
first query is UNSAT-- no more guesses
Dataflow Pruned 0/0
There are 1 Guesses
There are 0 RHSs before deduplication
There are 0 RHSs after deduplication
got 2 candidates from LHS

-------------------------------------------------
%0:i32 = var
%1:i1 = ult 429496729:i32, %0
pc %1 0:i1
%2:i32 = mulnuw 10:i32, %0
infer %2


--------------------------------
guess 0

%0:i32 = var ; reservedconst_1

Cost = 0
first query is SAT, returning the model:
reservedconst_1: 4120
0 th attempt: second query is SAT-- constant doesn't work
first query is SAT, returning the model:
reservedconst_1: 80
1 th attempt: second query is SAT-- constant doesn't work
first query is UNSAT-- no more guesses

--------------------------------
guess 1

%0:i32 = var

Cost = 0
second query is SAT-- constant doesn't work
Dataflow Pruned 0/0
There are 2 Guesses
There are 0 RHSs before deduplication
There are 0 RHSs after deduplication
got 3 candidates from LHS

-------------------------------------------------
%0:i32 = var
%1:i1 = ult 429496729:i32, %0
pc %1 0:i1
%2:i32 = mulnuw 10:i32, %0 (hasExternalUses)
%3:i32 = xor 4294967295:i32, %2
infer %3


--------------------------------
guess 0

%0:i32 = var ; reservedconst_1

Cost = 0
first query is SAT, returning the model:
reservedconst_1: -4121
0 th attempt: second query is SAT-- constant doesn't work
first query is SAT, returning the model:
reservedconst_1: -81
1 th attempt: second query is SAT-- constant doesn't work
first query is UNSAT-- no more guesses

--------------------------------
guess 1

%0:i32 = var

Cost = 0
second query is SAT-- constant doesn't work
Dataflow Pruned 0/0
There are 2 Guesses
There are 0 RHSs before deduplication
There are 0 RHSs after deduplication
got 7 candidates from LHS

-------------------------------------------------
%0:i32 = var
%1:i1 = ult 429496729:i32, %0
pc %1 0:i1
%2:i32 = mulnuw 10:i32, %0 (hasExternalUses)
%3:i32 = xor 4294967295:i32, %2
%4:i8 = var (range=[48,58))
%5:i32 = zext %4
%6:i32 = addnsw 4294967248:i32, %5 (hasExternalUses)
%7:i1 = ult %3, %6
infer %7


--------------------------------
guess 0

%0:i1 = var ; reservedconst_1

Cost = 0
first query is SAT, returning the model:
reservedconst_1: 0
0 th attempt: second query is SAT-- constant doesn't work
first query is SAT, returning the model:
reservedconst_1: -1
1 th attempt: second query is SAT-- constant doesn't work
first query is UNSAT-- no more guesses
Dataflow Pruned 0/0
There are 1 Guesses
There are 0 RHSs before deduplication
There are 0 RHSs after deduplication
got 6 candidates from LHS

-------------------------------------------------
%0:i32 = var
%1:i1 = ult 429496729:i32, %0
pc %1 0:i1
%2:i32 = mulnuw 10:i32, %0 (hasExternalUses)
%3:i32 = xor 4294967295:i32, %2
%4:i8 = var (range=[48,58))
%5:i32 = zext %4
%6:i32 = addnsw 4294967248:i32, %5 (hasExternalUses)
%7:i1 = ult %3, %6
pc %7 0:i1
%8:i32 = add %6, %2
infer %8


--------------------------------
guess 0

%0:i32 = var ; reservedconst_1

Cost = 0
first query is SAT, returning the model:
reservedconst_1: -1342177278
0 th attempt: second query is SAT-- constant doesn't work
first query is SAT, returning the model:
reservedconst_1: 262184960
1 th attempt: second query is SAT-- constant doesn't work
first query is UNSAT-- no more guesses

--------------------------------
guess 1

%0:i32 = var

Cost = 0
second query is SAT-- constant doesn't work
Dataflow Pruned 0/0
There are 2 Guesses
There are 0 RHSs before deduplication
There are 0 RHSs after deduplication
got 3 candidates from LHS

-------------------------------------------------
%0:i32 = var
%1:i32 = var
%2:i1 = eq %0, %1
infer %2


--------------------------------
guess 0

%0:i1 = var ; reservedconst_1

Cost = 0
first query is SAT, returning the model:
reservedconst_1: -1
0 th attempt: second query is SAT-- constant doesn't work
first query is SAT, returning the model:
reservedconst_1: 0
1 th attempt: second query is SAT-- constant doesn't work
first query is UNSAT-- no more guesses
Dataflow Pruned 0/0
There are 1 Guesses
There are 0 RHSs before deduplication
There are 0 RHSs after deduplication
got 2 candidates from LHS

-------------------------------------------------
%0:i8 = var
%1:i1 = ne 48:i8, %0
infer %1


--------------------------------
guess 0

%0:i1 = var ; reservedconst_1

Cost = 0
first query is SAT, returning the model:
reservedconst_1: -1
0 th attempt: second query is SAT-- constant doesn't work
first query is SAT, returning the model:
reservedconst_1: 0
1 th attempt: second query is SAT-- constant doesn't work
first query is UNSAT-- no more guesses
Dataflow Pruned 0/0
There are 1 Guesses
There are 0 RHSs before deduplication
There are 0 RHSs after deduplication
got 3 candidates from LHS

-------------------------------------------------
%0:i32 = var
%1:i32 = var
%2:i1 = eq %0, %1
pc %2 0:i1
%3:i32 = var
%4:i1 = eq %1, %3
infer %4


--------------------------------
guess 0

%0:i1 = var ; reservedconst_1

Cost = 0
first query is SAT, returning the model:
reservedconst_1: -1
0 th attempt: second query is SAT-- constant doesn't work
first query is SAT, returning the model:
reservedconst_1: 0
1 th attempt: second query is SAT-- constant doesn't work
first query is UNSAT-- no more guesses
Dataflow Pruned 0/0
There are 1 Guesses
There are 0 RHSs before deduplication
There are 0 RHSs after deduplication
got 6 candidates from LHS

-------------------------------------------------
%0:i32 = var
%1:i32 = var
%2:i1 = eq %0, %1
pc %2 0:i1
%3:i32 = var
%4:i1 = eq %1, %3
%5:i8 = var
%6:i1 = ne 48:i8, %5
%7:i1 = or %4, %6
infer %7


--------------------------------
guess 0

%0:i1 = var ; reservedconst_1

Cost = 0
first query is SAT, returning the model:
reservedconst_1: -1
0 th attempt: second query is SAT-- constant doesn't work
first query is SAT, returning the model:
reservedconst_1: 0
1 th attempt: second query is SAT-- constant doesn't work
first query is UNSAT-- no more guesses

--------------------------------
guess 1

%0:i8 = var
%1:i1 = ne 48:i8, %0

Cost = 1
second query is SAT-- constant doesn't work

--------------------------------
guess 2

%0:i32 = var
%1:i32 = var
%2:i1 = eq %0, %1

Cost = 1
second query is SAT-- constant doesn't work
Dataflow Pruned 0/0
There are 3 Guesses
There are 0 RHSs before deduplication
There are 0 RHSs after deduplication
got 7 candidates from LHS

-------------------------------------------------
%0:i32 = var
%1:i1 = ult 429496729:i32, %0
pc %1 0:i1
%2:i32 = mulnuw 10:i32, %0 (hasExternalUses)
%3:i32 = xor 4294967295:i32, %2
%4:i8 = var (range=[48,58))
%5:i32 = zext %4
%6:i32 = addnsw 4294967248:i32, %5 (hasExternalUses)
%7:i1 = ult %3, %6
pc %7 0:i1
%8:i32 = add %6, %2 (hasExternalUses)
%9:i1 = eq 19:i32, %8
infer %9


--------------------------------
guess 0

%0:i1 = var ; reservedconst_1

Cost = 0
first query is SAT, returning the model:
reservedconst_1: 0
0 th attempt: second query is SAT-- constant doesn't work
first query is SAT, returning the model:
reservedconst_1: -1
1 th attempt: second query is SAT-- constant doesn't work
first query is UNSAT-- no more guesses
Dataflow Pruned 0/0
There are 1 Guesses
There are 0 RHSs before deduplication
There are 0 RHSs after deduplication
got 2 candidates from LHS

-------------------------------------------------
%0:i8 = var
%1:i1 = eq 48:i8, %0
infer %1


--------------------------------
guess 0

%0:i1 = var ; reservedconst_1

Cost = 0
first query is SAT, returning the model:
reservedconst_1: 0
0 th attempt: second query is SAT-- constant doesn't work
first query is SAT, returning the model:
reservedconst_1: -1
1 th attempt: second query is SAT-- constant doesn't work
first query is UNSAT-- no more guesses
Dataflow Pruned 0/0
There are 1 Guesses
There are 0 RHSs before deduplication
There are 0 RHSs after deduplication
got 3 candidates from LHS

-------------------------------------------------
%0:i32 = var
%1:i32 = var
%2:i1 = eq %0, %1
pc %2 0:i1
%3:i32 = var
%4:i1 = ne %1, %3
infer %4


--------------------------------
guess 0

%0:i1 = var ; reservedconst_1

Cost = 0
first query is SAT, returning the model:
reservedconst_1: 0
0 th attempt: second query is SAT-- constant doesn't work
first query is SAT, returning the model:
reservedconst_1: -1
1 th attempt: second query is SAT-- constant doesn't work
first query is UNSAT-- no more guesses
Dataflow Pruned 0/0
There are 1 Guesses
There are 0 RHSs before deduplication
There are 0 RHSs after deduplication
got 6 candidates from LHS

-------------------------------------------------
%0:i32 = var
%1:i32 = var
%2:i1 = eq %0, %1
pc %2 0:i1
%3:i8 = var
%4:i1 = eq 48:i8, %3
%5:i32 = var
%6:i1 = ne %1, %5
%7:i1 = and %4, %6
infer %7


--------------------------------
guess 0

%0:i1 = var ; reservedconst_1

Cost = 0
first query is SAT, returning the model:
reservedconst_1: 0
0 th attempt: second query is SAT-- constant doesn't work
first query is SAT, returning the model:
reservedconst_1: -1
1 th attempt: second query is SAT-- constant doesn't work
first query is UNSAT-- no more guesses

--------------------------------
guess 1

%0:i8 = var
%1:i1 = eq 48:i8, %0

Cost = 1
second query is SAT-- constant doesn't work

--------------------------------
guess 2

%0:i32 = var
%1:i32 = var
%2:i1 = ne %0, %1

Cost = 1
second query is SAT-- constant doesn't work
Dataflow Pruned 0/0
There are 3 Guesses
There are 0 RHSs before deduplication
There are 0 RHSs after deduplication
got 2 candidates from LHS

-------------------------------------------------
%0:i8 = var
%1:i1 = eq 36:i8, %0
infer %1


--------------------------------
guess 0

%0:i1 = var ; reservedconst_1

Cost = 0
first query is SAT, returning the model:
reservedconst_1: 0
0 th attempt: second query is SAT-- constant doesn't work
first query is SAT, returning the model:
reservedconst_1: -1
1 th attempt: second query is SAT-- constant doesn't work
first query is UNSAT-- no more guesses
Dataflow Pruned 0/0
There are 1 Guesses
There are 0 RHSs before deduplication
There are 0 RHSs after deduplication
got 2 candidates from LHS

-------------------------------------------------
%0:i8 = var
%1:i1 = eq 0:i8, %0
infer %1


--------------------------------
guess 0

%0:i1 = var ; reservedconst_1

Cost = 0
first query is SAT, returning the model:
reservedconst_1: -1
0 th attempt: second query is SAT-- constant doesn't work
first query is SAT, returning the model:
reservedconst_1: 0
1 th attempt: second query is SAT-- constant doesn't work
first query is UNSAT-- no more guesses
Dataflow Pruned 0/0
There are 1 Guesses
There are 0 RHSs before deduplication
There are 0 RHSs after deduplication
got 3 candidates from LHS

-------------------------------------------------
%0:i8 = var
%1:i1 = eq 0:i8, %0
%2:i32 = select %1, 0:i32, 4294967264:i32
infer %2


--------------------------------
guess 0

%0:i32 = var ; reservedconst_1

Cost = 0
first query is SAT, returning the model:
reservedconst_1: 0
0 th attempt: second query is SAT-- constant doesn't work
first query is SAT, returning the model:
reservedconst_1: -32
1 th attempt: second query is SAT-- constant doesn't work
first query is UNSAT-- no more guesses
Dataflow Pruned 0/0
There are 1 Guesses
There are 0 RHSs before deduplication
There are 0 RHSs after deduplication
got 5 candidates from LHS

-------------------------------------------------
%0 = block 34
%1:i32 = var
%2:i8 = var
%3:i1 = eq 0:i8, %2
%4:i32 = select %3, 0:i32, 4294967264:i32
%5:i32 = phi %0, 4294967264:i32, 4294967264:i32, 4294967264:i32, 4294967264:i32, 4294967264:i32, 4294967264:i32, 4294967264:i32, 4294967264:i32, 4294967264:i32, 4294967264:i32, 4294967270:i32, 4294967270:i32, %1, %4, 4294967264:i32, 4294967264:i32, 4294967264:i32, 4294967264:i32, 4294967264:i32, 4294967264:i32, 4294967264:i32, 4294967264:i32, 4294967264:i32, 4294967264:i32, 4294967264:i32, 4294967264:i32, 4294967264:i32, 4294967264:i32, 4294967264:i32, 4294967264:i32, 4294967264:i32, 4294967264:i32, 4294967264:i32, 4294967264:i32
infer %5


--------------------------------
guess 0

%0:i32 = var ; reservedconst_1

Cost = 0
first query is SAT, returning the model:
reservedconst_1: -32
0 th attempt: second query is SAT-- constant doesn't work
first query is SAT, returning the model:
reservedconst_1: 31
1 th attempt: second query is SAT-- constant doesn't work
first query is SAT, returning the model:
reservedconst_1: -26
2 th attempt: second query is SAT-- constant doesn't work
first query is UNSAT-- no more guesses

--------------------------------
guess 1

%0:i32 = var

Cost = 0
second query is SAT-- constant doesn't work

--------------------------------
guess 2

%0:i8 = var
%1:i1 = eq 0:i8, %0
%2:i32 = select %1, 0:i32, 4294967264:i32

Cost = 4
second query is SAT-- constant doesn't work
Dataflow Pruned 0/0
There are 3 Guesses
There are 0 RHSs before deduplication
There are 0 RHSs after deduplication
#########################################################
; exiting Souper's runOnFunction() for argon2_decode_string()

; entering Souper's runOnFunction() for argon2_encode_string()

; ModuleID = './argon2-encoding.c.bc'
source_filename = "crypto_pwhash/argon2/argon2-encoding.c"
target datalayout = "e-m:e-p:32:32-i64:64-n32:64-S128"
target triple = "wasm32-unknown-wasi"

%struct.Argon2_Context = type { i8*, i32, i8*, i32, i8*, i32, i8*, i32, i8*, i32, i32, i32, i32, i32, i32 }

@.str = private unnamed_addr constant [10 x i8] c"$argon2id\00", align 1
@.str.1 = private unnamed_addr constant [9 x i8] c"$argon2i\00", align 1
@.str.2 = private unnamed_addr constant [4 x i8] c"$v=\00", align 1
@.str.3 = private unnamed_addr constant [4 x i8] c"$m=\00", align 1
@.str.4 = private unnamed_addr constant [4 x i8] c",t=\00", align 1
@.str.5 = private unnamed_addr constant [4 x i8] c",p=\00", align 1
@.str.7 = private unnamed_addr constant [13 x i8] c"$argon2id$v=\00", align 1
@.str.8 = private unnamed_addr constant [12 x i8] c"$argon2i$v=\00", align 1

; Function Attrs: nounwind
define hidden i32 @argon2_decode_string(%struct.Argon2_Context* %0, i8* %1, i32 %2) local_unnamed_addr #0 {
  %4 = alloca i32, align 4
  %5 = alloca i8*, align 4
  %6 = alloca i32, align 4
  %7 = alloca i8*, align 4
  %8 = getelementptr inbounds %struct.Argon2_Context, %struct.Argon2_Context* %0, i32 0, i32 5
  %9 = load i32, i32* %8, align 4
  %10 = getelementptr inbounds %struct.Argon2_Context, %struct.Argon2_Context* %0, i32 0, i32 1
  %11 = load i32, i32* %10, align 4
  store i32 0, i32* %8, align 4
  store i32 0, i32* %10, align 4
  switch i32 %2, label %194 [
    i32 2, label %12
    i32 1, label %16
  ]

12:                                               ; preds = %3
  %13 = tail call i32 @strncmp(i8* nonnull dereferenceable(1) %1, i8* nonnull dereferenceable(10) getelementptr inbounds ([10 x i8], [10 x i8]* @.str, i32 0, i32 0), i32 9)
  %14 = icmp eq i32 %13, 0
  %15 = getelementptr i8, i8* %1, i32 9
  br i1 %14, label %20, label %194

16:                                               ; preds = %3
  %17 = tail call i32 @strncmp(i8* nonnull dereferenceable(1) %1, i8* nonnull dereferenceable(9) getelementptr inbounds ([9 x i8], [9 x i8]* @.str.1, i32 0, i32 0), i32 8)
  %18 = icmp eq i32 %17, 0
  %19 = getelementptr i8, i8* %1, i32 8
  br i1 %18, label %20, label %194

20:                                               ; preds = %12, %16
  %21 = phi i8* [ %15, %12 ], [ %19, %16 ]
  %22 = tail call i32 @strncmp(i8* nonnull dereferenceable(1) %21, i8* nonnull dereferenceable(4) getelementptr inbounds ([4 x i8], [4 x i8]* @.str.2, i32 0, i32 0), i32 3)
  %23 = icmp eq i32 %22, 0
  %24 = getelementptr i8, i8* %21, i32 3
  %25 = select i1 %23, i8* %24, i8* %21
  br i1 %23, label %26, label %194

26:                                               ; preds = %20
  %27 = load i8, i8* %25, align 1
  %28 = add i8 %27, -48
  %29 = icmp ugt i8 %28, 9
  br i1 %29, label %194, label %30

30:                                               ; preds = %26, %41
  %31 = phi i8 [ %44, %41 ], [ %27, %26 ]
  %32 = phi i32 [ %42, %41 ], [ 0, %26 ]
  %33 = phi i8* [ %43, %41 ], [ %24, %26 ]
  %34 = zext i8 %31 to i32
  %35 = add nsw i32 %34, -48
  %36 = icmp ugt i32 %32, 429496729
  br i1 %36, label %194, label %37

37:                                               ; preds = %30
  %38 = mul nuw i32 %32, 10
  %39 = xor i32 %38, -1
  %40 = icmp ugt i32 %35, %39
  br i1 %40, label %194, label %41

41:                                               ; preds = %37
  %42 = add i32 %35, %38
  %43 = getelementptr i8, i8* %33, i32 1
  %44 = load i8, i8* %43, align 1
  %45 = add i8 %44, -48
  %46 = icmp ugt i8 %45, 9
  br i1 %46, label %47, label %30

47:                                               ; preds = %41
  %48 = icmp eq i8* %43, %25
  br i1 %48, label %194, label %49

49:                                               ; preds = %47
  %50 = icmp ne i8 %27, 48
  %51 = icmp eq i8* %33, %25
  %52 = or i1 %50, %51
  br i1 %52, label %53, label %194

53:                                               ; preds = %49
  %54 = icmp eq i32 %42, 19
  br i1 %54, label %55, label %194

55:                                               ; preds = %53
  %56 = tail call i32 @strncmp(i8* nonnull dereferenceable(1) %43, i8* nonnull dereferenceable(4) getelementptr inbounds ([4 x i8], [4 x i8]* @.str.3, i32 0, i32 0), i32 3)
  %57 = icmp eq i32 %56, 0
  %58 = getelementptr i8, i8* %33, i32 4
  %59 = select i1 %57, i8* %58, i8* %43
  br i1 %57, label %60, label %194

60:                                               ; preds = %55
  %61 = load i8, i8* %59, align 1
  %62 = add i8 %61, -48
  %63 = icmp ugt i8 %62, 9
  br i1 %63, label %194, label %64

64:                                               ; preds = %60, %75
  %65 = phi i8 [ %78, %75 ], [ %61, %60 ]
  %66 = phi i32 [ %76, %75 ], [ 0, %60 ]
  %67 = phi i8* [ %77, %75 ], [ %58, %60 ]
  %68 = zext i8 %65 to i32
  %69 = add nsw i32 %68, -48
  %70 = icmp ugt i32 %66, 429496729
  br i1 %70, label %194, label %71

71:                                               ; preds = %64
  %72 = mul nuw i32 %66, 10
  %73 = xor i32 %72, -1
  %74 = icmp ugt i32 %69, %73
  br i1 %74, label %194, label %75

75:                                               ; preds = %71
  %76 = add i32 %69, %72
  %77 = getelementptr i8, i8* %67, i32 1
  %78 = load i8, i8* %77, align 1
  %79 = add i8 %78, -48
  %80 = icmp ugt i8 %79, 9
  br i1 %80, label %81, label %64

81:                                               ; preds = %75
  %82 = icmp eq i8* %77, %59
  br i1 %82, label %194, label %83

83:                                               ; preds = %81
  %84 = icmp eq i8 %61, 48
  %85 = icmp ne i8* %67, %59
  %86 = and i1 %84, %85
  br i1 %86, label %194, label %87

87:                                               ; preds = %83
  %88 = getelementptr inbounds %struct.Argon2_Context, %struct.Argon2_Context* %0, i32 0, i32 11
  store i32 %76, i32* %88, align 4
  %89 = tail call i32 @strncmp(i8* nonnull dereferenceable(1) %77, i8* nonnull dereferenceable(4) getelementptr inbounds ([4 x i8], [4 x i8]* @.str.4, i32 0, i32 0), i32 3)
  %90 = icmp eq i32 %89, 0
  %91 = getelementptr i8, i8* %67, i32 4
  %92 = select i1 %90, i8* %91, i8* %77
  br i1 %90, label %93, label %194

93:                                               ; preds = %87
  %94 = load i8, i8* %92, align 1
  %95 = add i8 %94, -48
  %96 = icmp ugt i8 %95, 9
  br i1 %96, label %194, label %97

97:                                               ; preds = %93, %108
  %98 = phi i8 [ %111, %108 ], [ %94, %93 ]
  %99 = phi i32 [ %109, %108 ], [ 0, %93 ]
  %100 = phi i8* [ %110, %108 ], [ %91, %93 ]
  %101 = zext i8 %98 to i32
  %102 = add nsw i32 %101, -48
  %103 = icmp ugt i32 %99, 429496729
  br i1 %103, label %194, label %104

104:                                              ; preds = %97
  %105 = mul nuw i32 %99, 10
  %106 = xor i32 %105, -1
  %107 = icmp ugt i32 %102, %106
  br i1 %107, label %194, label %108

108:                                              ; preds = %104
  %109 = add i32 %102, %105
  %110 = getelementptr i8, i8* %100, i32 1
  %111 = load i8, i8* %110, align 1
  %112 = add i8 %111, -48
  %113 = icmp ugt i8 %112, 9
  br i1 %113, label %114, label %97

114:                                              ; preds = %108
  %115 = icmp eq i8* %110, %92
  br i1 %115, label %194, label %116

116:                                              ; preds = %114
  %117 = icmp eq i8 %94, 48
  %118 = icmp ne i8* %100, %92
  %119 = and i1 %117, %118
  br i1 %119, label %194, label %120

120:                                              ; preds = %116
  %121 = getelementptr inbounds %struct.Argon2_Context, %struct.Argon2_Context* %0, i32 0, i32 10
  store i32 %109, i32* %121, align 4
  %122 = tail call i32 @strncmp(i8* nonnull dereferenceable(1) %110, i8* nonnull dereferenceable(4) getelementptr inbounds ([4 x i8], [4 x i8]* @.str.5, i32 0, i32 0), i32 3)
  %123 = icmp eq i32 %122, 0
  %124 = getelementptr i8, i8* %100, i32 4
  %125 = select i1 %123, i8* %124, i8* %110
  br i1 %123, label %126, label %194

126:                                              ; preds = %120
  %127 = load i8, i8* %125, align 1
  %128 = add i8 %127, -48
  %129 = icmp ugt i8 %128, 9
  br i1 %129, label %194, label %130

130:                                              ; preds = %126, %141
  %131 = phi i8 [ %144, %141 ], [ %127, %126 ]
  %132 = phi i32 [ %142, %141 ], [ 0, %126 ]
  %133 = phi i8* [ %143, %141 ], [ %124, %126 ]
  %134 = zext i8 %131 to i32
  %135 = add nsw i32 %134, -48
  %136 = icmp ugt i32 %132, 429496729
  br i1 %136, label %194, label %137

137:                                              ; preds = %130
  %138 = mul nuw i32 %132, 10
  %139 = xor i32 %138, -1
  %140 = icmp ugt i32 %135, %139
  br i1 %140, label %194, label %141

141:                                              ; preds = %137
  %142 = add i32 %135, %138
  %143 = getelementptr i8, i8* %133, i32 1
  %144 = load i8, i8* %143, align 1
  %145 = add i8 %144, -48
  %146 = icmp ugt i8 %145, 9
  br i1 %146, label %147, label %130

147:                                              ; preds = %141
  %148 = icmp eq i8* %143, %125
  br i1 %148, label %194, label %149

149:                                              ; preds = %147
  %150 = icmp eq i8 %127, 48
  %151 = icmp ne i8* %133, %125
  %152 = and i1 %150, %151
  br i1 %152, label %194, label %153

153:                                              ; preds = %149
  %154 = getelementptr inbounds %struct.Argon2_Context, %struct.Argon2_Context* %0, i32 0, i32 12
  store i32 %142, i32* %154, align 4
  %155 = getelementptr inbounds %struct.Argon2_Context, %struct.Argon2_Context* %0, i32 0, i32 13
  store i32 %142, i32* %155, align 4
  %156 = load i8, i8* %143, align 1
  %157 = icmp eq i8 %156, 36
  %158 = getelementptr i8, i8* %133, i32 2
  %159 = select i1 %157, i8* %158, i8* %143
  br i1 %157, label %160, label %194

160:                                              ; preds = %153
  %161 = bitcast i32* %4 to i8*
  call void @llvm.lifetime.start.p0i8(i64 4, i8* nonnull %161) #5
  store i32 %9, i32* %4, align 4
  %162 = bitcast i8** %5 to i8*
  call void @llvm.lifetime.start.p0i8(i64 4, i8* nonnull %162) #5
  %163 = getelementptr inbounds %struct.Argon2_Context, %struct.Argon2_Context* %0, i32 0, i32 4
  %164 = load i8*, i8** %163, align 4
  %165 = tail call i32 @strlen(i8* nonnull dereferenceable(1) %159) #6
  %166 = call i32 @sodium_base642bin(i8* %164, i32 %9, i8* %159, i32 %165, i8* null, i32* nonnull %4, i8** nonnull %5, i32 3) #5
  %167 = icmp eq i32 %166, 0
  br i1 %167, label %169, label %168

168:                                              ; preds = %160
  call void @llvm.lifetime.end.p0i8(i64 4, i8* nonnull %162) #5
  call void @llvm.lifetime.end.p0i8(i64 4, i8* nonnull %161) #5
  br label %194

169:                                              ; preds = %160
  %170 = load i32, i32* %4, align 4
  store i32 %170, i32* %8, align 4
  %171 = load i8*, i8** %5, align 4
  call void @llvm.lifetime.end.p0i8(i64 4, i8* nonnull %162) #5
  call void @llvm.lifetime.end.p0i8(i64 4, i8* nonnull %161) #5
  %172 = load i8, i8* %171, align 1
  %173 = icmp eq i8 %172, 36
  %174 = getelementptr i8, i8* %171, i32 1
  %175 = select i1 %173, i8* %174, i8* %171
  br i1 %173, label %176, label %194

176:                                              ; preds = %169
  %177 = bitcast i32* %6 to i8*
  call void @llvm.lifetime.start.p0i8(i64 4, i8* nonnull %177) #5
  store i32 %11, i32* %6, align 4
  %178 = bitcast i8** %7 to i8*
  call void @llvm.lifetime.start.p0i8(i64 4, i8* nonnull %178) #5
  %179 = getelementptr inbounds %struct.Argon2_Context, %struct.Argon2_Context* %0, i32 0, i32 0
  %180 = load i8*, i8** %179, align 4
  %181 = call i32 @strlen(i8* nonnull dereferenceable(1) %175) #6
  %182 = call i32 @sodium_base642bin(i8* %180, i32 %11, i8* %175, i32 %181, i8* null, i32* nonnull %6, i8** nonnull %7, i32 3) #5
  %183 = icmp eq i32 %182, 0
  br i1 %183, label %185, label %184

184:                                              ; preds = %176
  call void @llvm.lifetime.end.p0i8(i64 4, i8* nonnull %178) #5
  call void @llvm.lifetime.end.p0i8(i64 4, i8* nonnull %177) #5
  br label %194

185:                                              ; preds = %176
  %186 = load i32, i32* %6, align 4
  store i32 %186, i32* %10, align 4
  %187 = load i8*, i8** %7, align 4
  call void @llvm.lifetime.end.p0i8(i64 4, i8* nonnull %178) #5
  call void @llvm.lifetime.end.p0i8(i64 4, i8* nonnull %177) #5
  %188 = call i32 @argon2_validate_inputs(%struct.Argon2_Context* nonnull %0) #5
  %189 = icmp eq i32 %188, 0
  br i1 %189, label %190, label %194

190:                                              ; preds = %185
  %191 = load i8, i8* %187, align 1
  %192 = icmp eq i8 %191, 0
  %193 = select i1 %192, i32 0, i32 -32
  br label %194

194:                                              ; preds = %37, %30, %71, %64, %104, %97, %137, %130, %149, %116, %83, %126, %147, %93, %114, %60, %81, %26, %47, %49, %184, %168, %190, %185, %53, %3, %12, %169, %153, %120, %87, %55, %20, %16
  %195 = phi i32 [ -32, %184 ], [ -32, %169 ], [ -32, %168 ], [ -32, %153 ], [ -32, %120 ], [ -32, %87 ], [ -32, %55 ], [ -32, %20 ], [ -32, %12 ], [ -32, %16 ], [ -26, %3 ], [ -26, %53 ], [ %188, %185 ], [ %193, %190 ], [ -32, %49 ], [ -32, %47 ], [ -32, %26 ], [ -32, %83 ], [ -32, %81 ], [ -32, %60 ], [ -32, %116 ], [ -32, %114 ], [ -32, %93 ], [ -32, %149 ], [ -32, %147 ], [ -32, %126 ], [ -32, %130 ], [ -32, %137 ], [ -32, %97 ], [ -32, %104 ], [ -32, %64 ], [ -32, %71 ], [ -32, %30 ], [ -32, %37 ]
  ret i32 %195
}

; Function Attrs: argmemonly nounwind willreturn
declare void @llvm.lifetime.start.p0i8(i64 immarg %0, i8* nocapture %1) #1

; Function Attrs: nofree nounwind readonly
declare i32 @strncmp(i8* nocapture %0, i8* nocapture %1, i32 %2) local_unnamed_addr #2

; Function Attrs: argmemonly nounwind willreturn
declare void @llvm.lifetime.end.p0i8(i64 immarg %0, i8* nocapture %1) #1

declare i32 @sodium_base642bin(i8* %0, i32 %1, i8* %2, i32 %3, i8* %4, i32* %5, i8** %6, i32 %7) local_unnamed_addr #3

; Function Attrs: argmemonly nofree nounwind readonly
declare i32 @strlen(i8* nocapture %0) local_unnamed_addr #4

declare i32 @argon2_validate_inputs(%struct.Argon2_Context* %0) local_unnamed_addr #3

; Function Attrs: nounwind
define hidden i32 @argon2_encode_string(i8* %0, i32 %1, %struct.Argon2_Context* %2, i32 %3) local_unnamed_addr #0 {
  %5 = alloca [10 x i8], align 1
  %6 = alloca [11 x i8], align 2
  %7 = alloca [11 x i8], align 1
  %8 = alloca [11 x i8], align 1
  %9 = alloca [11 x i8], align 1
  switch i32 %3, label %159 [
    i32 2, label %10
    i32 1, label %13
  ]

10:                                               ; preds = %4
  %11 = icmp ult i32 %1, 13
  br i1 %11, label %159, label %12

12:                                               ; preds = %10
  tail call void @llvm.memcpy.p0i8.p0i8.i32(i8* nonnull align 1 dereferenceable(13) %0, i8* nonnull align 1 dereferenceable(13) getelementptr inbounds ([13 x i8], [13 x i8]* @.str.7, i32 0, i32 0), i32 13, i1 false)
  br label %16

13:                                               ; preds = %4
  %14 = icmp ult i32 %1, 12
  br i1 %14, label %159, label %15

15:                                               ; preds = %13
  tail call void @llvm.memcpy.p0i8.p0i8.i32(i8* nonnull align 1 dereferenceable(12) %0, i8* nonnull align 1 dereferenceable(12) getelementptr inbounds ([12 x i8], [12 x i8]* @.str.8, i32 0, i32 0), i32 12, i1 false)
  br label %16

16:                                               ; preds = %15, %12
  %17 = phi i32 [ 11, %15 ], [ 12, %12 ]
  %18 = phi i32 [ -11, %15 ], [ -12, %12 ]
  %19 = getelementptr i8, i8* %0, i32 %17
  %20 = add i32 %18, %1
  %21 = tail call i32 @argon2_validate_inputs(%struct.Argon2_Context* %2) #5
  %22 = icmp eq i32 %21, 0
  br i1 %22, label %23, label %159

23:                                               ; preds = %16
  %24 = getelementptr inbounds [11 x i8], [11 x i8]* %6, i32 0, i32 0
  call void @llvm.lifetime.start.p0i8(i64 11, i8* nonnull %24) #5
  %25 = getelementptr inbounds [10 x i8], [10 x i8]* %5, i32 0, i32 0
  call void @llvm.lifetime.start.p0i8(i64 10, i8* nonnull %25) #5
  %26 = getelementptr inbounds [10 x i8], [10 x i8]* %5, i32 0, i32 9
  store i8 57, i8* %26, align 1
  %27 = getelementptr inbounds [10 x i8], [10 x i8]* %5, i32 0, i32 8
  store i8 49, i8* %27, align 1
  %28 = bitcast i8* %27 to i16*
  %29 = bitcast [11 x i8]* %6 to i16*
  %30 = load i16, i16* %28, align 1
  store i16 %30, i16* %29, align 2
  %31 = getelementptr inbounds [11 x i8], [11 x i8]* %6, i32 0, i32 2
  store i8 0, i8* %31, align 2
  call void @llvm.lifetime.end.p0i8(i64 10, i8* nonnull %25) #5
  %32 = call i32 @strlen(i8* nonnull %24) #6
  %33 = icmp ugt i32 %20, %32
  br i1 %33, label %35, label %34

34:                                               ; preds = %23
  call void @llvm.lifetime.end.p0i8(i64 11, i8* nonnull %24) #5
  br label %159

35:                                               ; preds = %23
  %36 = add nuw i32 %32, 1
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 1 %19, i8* nonnull align 2 %24, i32 %36, i1 false)
  %37 = getelementptr i8, i8* %19, i32 %32
  %38 = sub i32 %20, %32
  call void @llvm.lifetime.end.p0i8(i64 11, i8* nonnull %24) #5
  %39 = icmp ult i32 %38, 4
  br i1 %39, label %159, label %40

40:                                               ; preds = %35
  %41 = bitcast i8* %37 to i32*
  store i32 4025636, i32* %41, align 1
  %42 = getelementptr i8, i8* %37, i32 3
  %43 = getelementptr inbounds [11 x i8], [11 x i8]* %7, i32 0, i32 0
  call void @llvm.lifetime.start.p0i8(i64 11, i8* nonnull %43) #5
  %44 = getelementptr inbounds %struct.Argon2_Context, %struct.Argon2_Context* %2, i32 0, i32 11
  %45 = load i32, i32* %44, align 4
  call void @llvm.lifetime.start.p0i8(i64 10, i8* nonnull %25) #5
  br label %46

46:                                               ; preds = %46, %40
  %47 = phi i32 [ %45, %40 ], [ %49, %46 ]
  %48 = phi i32 [ 10, %40 ], [ %54, %46 ]
  %49 = udiv i32 %47, 10
  %50 = mul i32 %49, 10
  %51 = sub i32 %47, %50
  %52 = trunc i32 %51 to i8
  %53 = or i8 %52, 48
  %54 = add nsw i32 %48, -1
  %55 = getelementptr [10 x i8], [10 x i8]* %5, i32 0, i32 %54
  store i8 %53, i8* %55, align 1
  %56 = icmp ugt i32 %47, 9
  %57 = icmp ne i32 %54, 0
  %58 = and i1 %56, %57
  br i1 %58, label %46, label %59

59:                                               ; preds = %46
  %60 = add i32 %38, -3
  %61 = sub i32 11, %48
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* nonnull align 1 %43, i8* nonnull align 1 %55, i32 %61, i1 false) #5
  %62 = getelementptr [11 x i8], [11 x i8]* %7, i32 0, i32 %61
  store i8 0, i8* %62, align 1
  call void @llvm.lifetime.end.p0i8(i64 10, i8* nonnull %25) #5
  %63 = call i32 @strlen(i8* nonnull %43) #6
  %64 = icmp ugt i32 %60, %63
  br i1 %64, label %66, label %65

65:                                               ; preds = %59
  call void @llvm.lifetime.end.p0i8(i64 11, i8* nonnull %43) #5
  br label %159

66:                                               ; preds = %59
  %67 = add nuw i32 %63, 1
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 1 %42, i8* nonnull align 1 %43, i32 %67, i1 false)
  %68 = getelementptr i8, i8* %42, i32 %63
  %69 = sub i32 %60, %63
  call void @llvm.lifetime.end.p0i8(i64 11, i8* nonnull %43) #5
  %70 = icmp ult i32 %69, 4
  br i1 %70, label %159, label %71

71:                                               ; preds = %66
  %72 = bitcast i8* %68 to i32*
  store i32 4027436, i32* %72, align 1
  %73 = getelementptr i8, i8* %68, i32 3
  %74 = getelementptr inbounds [11 x i8], [11 x i8]* %8, i32 0, i32 0
  call void @llvm.lifetime.start.p0i8(i64 11, i8* nonnull %74) #5
  %75 = getelementptr inbounds %struct.Argon2_Context, %struct.Argon2_Context* %2, i32 0, i32 10
  %76 = load i32, i32* %75, align 4
  call void @llvm.lifetime.start.p0i8(i64 10, i8* nonnull %25) #5
  br label %77

77:                                               ; preds = %77, %71
  %78 = phi i32 [ %76, %71 ], [ %80, %77 ]
  %79 = phi i32 [ 10, %71 ], [ %85, %77 ]
  %80 = udiv i32 %78, 10
  %81 = mul i32 %80, 10
  %82 = sub i32 %78, %81
  %83 = trunc i32 %82 to i8
  %84 = or i8 %83, 48
  %85 = add nsw i32 %79, -1
  %86 = getelementptr [10 x i8], [10 x i8]* %5, i32 0, i32 %85
  store i8 %84, i8* %86, align 1
  %87 = icmp ugt i32 %78, 9
  %88 = icmp ne i32 %85, 0
  %89 = and i1 %87, %88
  br i1 %89, label %77, label %90

90:                                               ; preds = %77
  %91 = add i32 %69, -3
  %92 = sub i32 11, %79
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* nonnull align 1 %74, i8* nonnull align 1 %86, i32 %92, i1 false) #5
  %93 = getelementptr [11 x i8], [11 x i8]* %8, i32 0, i32 %92
  store i8 0, i8* %93, align 1
  call void @llvm.lifetime.end.p0i8(i64 10, i8* nonnull %25) #5
  %94 = call i32 @strlen(i8* nonnull %74) #6
  %95 = icmp ugt i32 %91, %94
  br i1 %95, label %97, label %96

96:                                               ; preds = %90
  call void @llvm.lifetime.end.p0i8(i64 11, i8* nonnull %74) #5
  br label %159

97:                                               ; preds = %90
  %98 = add nuw i32 %94, 1
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 1 %73, i8* nonnull align 1 %74, i32 %98, i1 false)
  %99 = getelementptr i8, i8* %73, i32 %94
  %100 = sub i32 %91, %94
  call void @llvm.lifetime.end.p0i8(i64 11, i8* nonnull %74) #5
  %101 = icmp ult i32 %100, 4
  br i1 %101, label %159, label %102

102:                                              ; preds = %97
  %103 = bitcast i8* %99 to i32*
  store i32 4026412, i32* %103, align 1
  %104 = getelementptr i8, i8* %99, i32 3
  %105 = getelementptr inbounds [11 x i8], [11 x i8]* %9, i32 0, i32 0
  call void @llvm.lifetime.start.p0i8(i64 11, i8* nonnull %105) #5
  %106 = getelementptr inbounds %struct.Argon2_Context, %struct.Argon2_Context* %2, i32 0, i32 12
  %107 = load i32, i32* %106, align 4
  call void @llvm.lifetime.start.p0i8(i64 10, i8* nonnull %25) #5
  br label %108

108:                                              ; preds = %108, %102
  %109 = phi i32 [ %107, %102 ], [ %111, %108 ]
  %110 = phi i32 [ 10, %102 ], [ %116, %108 ]
  %111 = udiv i32 %109, 10
  %112 = mul i32 %111, 10
  %113 = sub i32 %109, %112
  %114 = trunc i32 %113 to i8
  %115 = or i8 %114, 48
  %116 = add nsw i32 %110, -1
  %117 = getelementptr [10 x i8], [10 x i8]* %5, i32 0, i32 %116
  store i8 %115, i8* %117, align 1
  %118 = icmp ugt i32 %109, 9
  %119 = icmp ne i32 %116, 0
  %120 = and i1 %118, %119
  br i1 %120, label %108, label %121

121:                                              ; preds = %108
  %122 = add i32 %100, -3
  %123 = sub i32 11, %110
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* nonnull align 1 %105, i8* nonnull align 1 %117, i32 %123, i1 false) #5
  %124 = getelementptr [11 x i8], [11 x i8]* %9, i32 0, i32 %123
  store i8 0, i8* %124, align 1
  call void @llvm.lifetime.end.p0i8(i64 10, i8* nonnull %25) #5
  %125 = call i32 @strlen(i8* nonnull %105) #6
  %126 = icmp ugt i32 %122, %125
  br i1 %126, label %128, label %127

127:                                              ; preds = %121
  call void @llvm.lifetime.end.p0i8(i64 11, i8* nonnull %105) #5
  br label %159

128:                                              ; preds = %121
  %129 = add nuw i32 %125, 1
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 1 %104, i8* nonnull align 1 %105, i32 %129, i1 false)
  %130 = getelementptr i8, i8* %104, i32 %125
  %131 = sub i32 %122, %125
  call void @llvm.lifetime.end.p0i8(i64 11, i8* nonnull %105) #5
  %132 = icmp ult i32 %131, 2
  br i1 %132, label %159, label %133

133:                                              ; preds = %128
  %134 = bitcast i8* %130 to i16*
  store i16 36, i16* %134, align 1
  %135 = getelementptr i8, i8* %130, i32 1
  %136 = add i32 %131, -1
  %137 = getelementptr inbounds %struct.Argon2_Context, %struct.Argon2_Context* %2, i32 0, i32 4
  %138 = load i8*, i8** %137, align 4
  %139 = getelementptr inbounds %struct.Argon2_Context, %struct.Argon2_Context* %2, i32 0, i32 5
  %140 = load i32, i32* %139, align 4
  %141 = tail call i8* @sodium_bin2base64(i8* %135, i32 %136, i8* %138, i32 %140, i32 3) #5
  %142 = icmp eq i8* %141, null
  br i1 %142, label %159, label %143

143:                                              ; preds = %133
  %144 = tail call i32 @strlen(i8* nonnull dereferenceable(1) %135) #6
  %145 = getelementptr i8, i8* %135, i32 %144
  %146 = sub i32 %136, %144
  %147 = icmp ult i32 %146, 2
  br i1 %147, label %159, label %148

148:                                              ; preds = %143
  %149 = bitcast i8* %145 to i16*
  store i16 36, i16* %149, align 1
  %150 = getelementptr i8, i8* %145, i32 1
  %151 = add i32 %146, -1
  %152 = getelementptr inbounds %struct.Argon2_Context, %struct.Argon2_Context* %2, i32 0, i32 0
  %153 = load i8*, i8** %152, align 4
  %154 = getelementptr inbounds %struct.Argon2_Context, %struct.Argon2_Context* %2, i32 0, i32 1
  %155 = load i32, i32* %154, align 4
  %156 = tail call i8* @sodium_bin2base64(i8* %150, i32 %151, i8* %153, i32 %155, i32 3) #5
  %157 = icmp eq i8* %156, null
  %158 = select i1 %157, i32 -31, i32 0
  ret i32 %158

159:                                              ; preds = %143, %133, %128, %127, %97, %96, %66, %65, %35, %34, %13, %10, %16, %4
  %160 = phi i32 [ -31, %127 ], [ -31, %96 ], [ -31, %65 ], [ -31, %34 ], [ -31, %4 ], [ %21, %16 ], [ -31, %10 ], [ -31, %13 ], [ -31, %35 ], [ -31, %66 ], [ -31, %97 ], [ -31, %128 ], [ -31, %133 ], [ -31, %143 ]
  ret i32 %160
}

; Function Attrs: argmemonly nounwind willreturn
declare void @llvm.memcpy.p0i8.p0i8.i32(i8* noalias nocapture writeonly %0, i8* noalias nocapture readonly %1, i32 %2, i1 immarg %3) #1

declare i8* @sodium_bin2base64(i8* %0, i32 %1, i8* %2, i32 %3, i32 %4) local_unnamed_addr #3

attributes #0 = { nounwind "correctly-rounded-divide-sqrt-fp-math"="false" "disable-tail-calls"="false" "frame-pointer"="none" "less-precise-fpmad"="false" "min-legal-vector-width"="0" "no-infs-fp-math"="false" "no-jump-tables"="false" "no-nans-fp-math"="false" "no-signed-zeros-fp-math"="false" "no-trapping-math"="false" "stack-protector-buffer-size"="8" "target-cpu"="generic" "unsafe-fp-math"="false" "use-soft-float"="false" }
attributes #1 = { argmemonly nounwind willreturn }
attributes #2 = { nofree nounwind readonly "correctly-rounded-divide-sqrt-fp-math"="false" "disable-tail-calls"="false" "frame-pointer"="none" "less-precise-fpmad"="false" "no-infs-fp-math"="false" "no-nans-fp-math"="false" "no-signed-zeros-fp-math"="false" "no-trapping-math"="false" "stack-protector-buffer-size"="8" "target-cpu"="generic" "unsafe-fp-math"="false" "use-soft-float"="false" }
attributes #3 = { "correctly-rounded-divide-sqrt-fp-math"="false" "disable-tail-calls"="false" "frame-pointer"="none" "less-precise-fpmad"="false" "no-infs-fp-math"="false" "no-nans-fp-math"="false" "no-signed-zeros-fp-math"="false" "no-trapping-math"="false" "stack-protector-buffer-size"="8" "target-cpu"="generic" "unsafe-fp-math"="false" "use-soft-float"="false" }
attributes #4 = { argmemonly nofree nounwind readonly "correctly-rounded-divide-sqrt-fp-math"="false" "disable-tail-calls"="false" "frame-pointer"="none" "less-precise-fpmad"="false" "no-infs-fp-math"="false" "no-nans-fp-math"="false" "no-signed-zeros-fp-math"="false" "no-trapping-math"="false" "stack-protector-buffer-size"="8" "target-cpu"="generic" "unsafe-fp-math"="false" "use-soft-float"="false" }
attributes #5 = { nounwind }
attributes #6 = { nounwind readonly }

!llvm.module.flags = !{!0, !1, !2}
!llvm.ident = !{!3}

!0 = !{i32 1, !"wchar_size", i32 4}
!1 = !{i32 7, !"PIC Level", i32 2}
!2 = !{i32 7, !"PIE Level", i32 2}
!3 = !{!"clang version 10.0.0 (https://github.com/llvm/llvm-project d32170dbd5b0d54436537b6b75beaf44324e0c28)"}

; extracted candidates

; *****
; For LLVM instruction:
;  %11 = icmp ult i32 %1, 13
; Looking for a replacement for:
%0:i32 = var
%1:i1 = ult %0, 13:i32
infer %1

; *****
; For LLVM instruction:
;  %14 = icmp ult i32 %1, 12
; Looking for a replacement for:
%0:i32 = var
%1:i1 = ult %0, 12:i32
infer %1

; *****
; For LLVM instruction:
;  %17 = phi i32 [ 11, %15 ], [ 12, %12 ]
; Looking for a replacement for:
%0 = block 2
%1:i32 = phi %0, 11:i32, 12:i32
infer %1

; *****
; For LLVM instruction:
;  %18 = phi i32 [ -11, %15 ], [ -12, %12 ]
; Looking for a replacement for:
%0 = block 2
%1:i32 = phi %0, 4294967285:i32, 4294967284:i32
infer %1

; *****
; For LLVM instruction:
;  %20 = add i32 %18, %1
; Looking for a replacement for:
%0:i32 = var
%1 = block 2
%2:i32 = phi %1, 4294967285:i32, 4294967284:i32
%3:i32 = add %0, %2
infer %3

; *****
; For LLVM instruction:
;  %21 = tail call i32 @argon2_validate_inputs(%struct.Argon2_Context* %2) #5
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %22 = icmp eq i32 %21, 0
; Looking for a replacement for:
%0:i32 = var
%1:i1 = eq 0:i32, %0
infer %1

; *****
; For LLVM instruction:
;  %30 = load i16, i16* %28, align 1
; Looking for a replacement for:
%0:i16 = var
infer %0

; *****
; For LLVM instruction:
;  %32 = call i32 @strlen(i8* nonnull %24) #6
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %33 = icmp ugt i32 %20, %32
; Looking for a replacement for:
%0:i32 = var
%1:i32 = var
%2 = block 2
%3:i32 = phi %2, 4294967285:i32, 4294967284:i32
%4:i32 = add %1, %3 (hasExternalUses)
%5:i1 = ult %0, %4
infer %5

; *****
; For LLVM instruction:
;  %36 = add nuw i32 %32, 1
; Looking for a replacement for:
%0:i32 = var
%1:i32 = var
%2 = block 2
%3:i32 = phi %2, 4294967285:i32, 4294967284:i32
%4:i32 = add %1, %3 (hasExternalUses)
%5:i1 = ult %0, %4
pc %5 1:i1
%6:i32 = addnuw 1:i32, %0
infer %6

; *****
; For LLVM instruction:
;  %38 = sub i32 %20, %32
; Looking for a replacement for:
%0:i32 = var
%1:i32 = var
%2 = block 2
%3:i32 = phi %2, 4294967285:i32, 4294967284:i32
%4:i32 = add %1, %3 (hasExternalUses)
%5:i1 = ult %0, %4
pc %5 1:i1
%6:i32 = sub %4, %0
infer %6

; *****
; For LLVM instruction:
;  %39 = icmp ult i32 %38, 4
; Looking for a replacement for:
%0:i32 = var
%1:i32 = var
%2 = block 2
%3:i32 = phi %2, 4294967285:i32, 4294967284:i32
%4:i32 = add %1, %3 (hasExternalUses)
%5:i1 = ult %0, %4
pc %5 1:i1
%6:i32 = sub %4, %0 (hasExternalUses)
%7:i1 = ult %6, 4:i32
infer %7

; *****
; For LLVM instruction:
;  %45 = load i32, i32* %44, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %47 = phi i32 [ %45, %40 ], [ %49, %46 ]
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %48 = phi i32 [ 10, %40 ], [ %54, %46 ]
; Looking for a replacement for:
%0:i32 = var (range=[1,11))
infer %0

; *****
; For LLVM instruction:
;  %49 = udiv i32 %47, 10
; Looking for a replacement for:
%0:i32 = var
%1:i32 = udiv %0, 10:i32
infer %1

; *****
; For LLVM instruction:
;  %50 = mul i32 %49, 10
; Looking for a replacement for:
%0:i32 = var
%1:i32 = udiv %0, 10:i32 (hasExternalUses)
%2:i32 = mul 10:i32, %1
infer %2 (demandedBits=00000000000000000000000011111111)

; *****
; For LLVM instruction:
;  %51 = sub i32 %47, %50
; Looking for a replacement for:
%0:i32 = var
%1:i32 = udiv %0, 10:i32 (hasExternalUses)
%2:i32 = mul 10:i32, %1
%3:i32 = sub %0, %2
infer %3 (demandedBits=00000000000000000000000011001111)

; *****
; For LLVM instruction:
;  %52 = trunc i32 %51 to i8
; Looking for a replacement for:
%0:i32 = var
%1:i32 = udiv %0, 10:i32 (hasExternalUses)
%2:i32 = mul 10:i32, %1
%3:i32 = sub %0, %2
%4:i8 = trunc %3
infer %4 (demandedBits=11001111)

; *****
; For LLVM instruction:
;  %53 = or i8 %52, 48
; Looking for a replacement for:
%0:i32 = var
%1:i32 = udiv %0, 10:i32 (hasExternalUses)
%2:i32 = mul 10:i32, %1
%3:i32 = sub %0, %2
%4:i8 = trunc %3
%5:i8 = or 48:i8, %4
infer %5

; *****
; For LLVM instruction:
;  %54 = add nsw i32 %48, -1
; Looking for a replacement for:
%0:i32 = var (range=[1,11))
%1:i32 = addnsw 4294967295:i32, %0
infer %1

; *****
; For LLVM instruction:
;  %56 = icmp ugt i32 %47, 9
; Looking for a replacement for:
%0:i32 = var
%1:i1 = ult 9:i32, %0
infer %1

; *****
; For LLVM instruction:
;  %57 = icmp ne i32 %54, 0
; Looking for a replacement for:
%0:i32 = var (range=[1,11))
%1:i32 = addnsw 4294967295:i32, %0 (hasExternalUses)
%2:i1 = ne 0:i32, %1
infer %2

; *****
; For LLVM instruction:
;  %58 = and i1 %56, %57
; Looking for a replacement for:
%0:i32 = var (range=[1,11))
%1:i32 = addnsw 4294967295:i32, %0 (hasExternalUses)
%2:i1 = ne 0:i32, %1
%3:i32 = var
%4:i1 = ult 9:i32, %3
%5:i1 = and %2, %4
infer %5

; *****
; For LLVM instruction:
;  %60 = add i32 %38, -3
; Looking for a replacement for:
%0:i32 = var
%1 = block 2
%2:i32 = phi %1, 4294967285:i32, 4294967284:i32
%3:i32 = add %0, %2 (hasExternalUses)
%4:i32 = var
%5:i32 = sub %3, %4 (hasExternalUses)
%6:i32 = add 4294967293:i32, %5
infer %6

; *****
; For LLVM instruction:
;  %61 = sub i32 11, %48
; Looking for a replacement for:
%0:i32 = var (range=[1,11))
%1:i32 = addnsw 4294967295:i32, %0 (hasExternalUses)
%2:i1 = ne 0:i32, %1
%3:i32 = var
%4:i1 = ult 9:i32, %3
%5:i1 = and %2, %4
pc %5 0:i1
%6:i32 = sub 11:i32, %0
infer %6

; *****
; For LLVM instruction:
;  %63 = call i32 @strlen(i8* nonnull %43) #6
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %64 = icmp ugt i32 %60, %63
; Looking for a replacement for:
%0:i32 = var
%1:i32 = var
%2 = block 2
%3:i32 = phi %2, 4294967285:i32, 4294967284:i32
%4:i32 = add %1, %3 (hasExternalUses)
%5:i32 = var
%6:i32 = sub %4, %5 (hasExternalUses)
%7:i32 = add 4294967293:i32, %6 (hasExternalUses)
%8:i1 = ult %0, %7
infer %8

; *****
; For LLVM instruction:
;  %67 = add nuw i32 %63, 1
; Looking for a replacement for:
%0:i32 = var
%1:i32 = var
%2 = block 2
%3:i32 = phi %2, 4294967285:i32, 4294967284:i32
%4:i32 = add %1, %3 (hasExternalUses)
%5:i32 = var
%6:i32 = sub %4, %5 (hasExternalUses)
%7:i32 = add 4294967293:i32, %6 (hasExternalUses)
%8:i1 = ult %0, %7
pc %8 1:i1
%9:i32 = addnuw 1:i32, %0
infer %9

; *****
; For LLVM instruction:
;  %69 = sub i32 %60, %63
; Looking for a replacement for:
%0:i32 = var
%1:i32 = var
%2 = block 2
%3:i32 = phi %2, 4294967285:i32, 4294967284:i32
%4:i32 = add %1, %3 (hasExternalUses)
%5:i32 = var
%6:i32 = sub %4, %5 (hasExternalUses)
%7:i32 = add 4294967293:i32, %6 (hasExternalUses)
%8:i1 = ult %0, %7
pc %8 1:i1
%9:i32 = sub %7, %0
infer %9

; *****
; For LLVM instruction:
;  %70 = icmp ult i32 %69, 4
; Looking for a replacement for:
%0:i32 = var
%1:i32 = var
%2 = block 2
%3:i32 = phi %2, 4294967285:i32, 4294967284:i32
%4:i32 = add %1, %3 (hasExternalUses)
%5:i32 = var
%6:i32 = sub %4, %5 (hasExternalUses)
%7:i32 = add 4294967293:i32, %6 (hasExternalUses)
%8:i1 = ult %0, %7
pc %8 1:i1
%9:i32 = sub %7, %0 (hasExternalUses)
%10:i1 = ult %9, 4:i32
infer %10

; *****
; For LLVM instruction:
;  %76 = load i32, i32* %75, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %78 = phi i32 [ %76, %71 ], [ %80, %77 ]
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %79 = phi i32 [ 10, %71 ], [ %85, %77 ]
; Looking for a replacement for:
%0:i32 = var (range=[1,11))
infer %0

; *****
; For LLVM instruction:
;  %80 = udiv i32 %78, 10
; Looking for a replacement for:
%0:i32 = var
%1:i32 = udiv %0, 10:i32
infer %1

; *****
; For LLVM instruction:
;  %81 = mul i32 %80, 10
; Looking for a replacement for:
%0:i32 = var
%1:i32 = udiv %0, 10:i32 (hasExternalUses)
%2:i32 = mul 10:i32, %1
infer %2 (demandedBits=00000000000000000000000011111111)

; *****
; For LLVM instruction:
;  %82 = sub i32 %78, %81
; Looking for a replacement for:
%0:i32 = var
%1:i32 = udiv %0, 10:i32 (hasExternalUses)
%2:i32 = mul 10:i32, %1
%3:i32 = sub %0, %2
infer %3 (demandedBits=00000000000000000000000011001111)

; *****
; For LLVM instruction:
;  %83 = trunc i32 %82 to i8
; Looking for a replacement for:
%0:i32 = var
%1:i32 = udiv %0, 10:i32 (hasExternalUses)
%2:i32 = mul 10:i32, %1
%3:i32 = sub %0, %2
%4:i8 = trunc %3
infer %4 (demandedBits=11001111)

; *****
; For LLVM instruction:
;  %84 = or i8 %83, 48
; Looking for a replacement for:
%0:i32 = var
%1:i32 = udiv %0, 10:i32 (hasExternalUses)
%2:i32 = mul 10:i32, %1
%3:i32 = sub %0, %2
%4:i8 = trunc %3
%5:i8 = or 48:i8, %4
infer %5

; *****
; For LLVM instruction:
;  %85 = add nsw i32 %79, -1
; Looking for a replacement for:
%0:i32 = var (range=[1,11))
%1:i32 = addnsw 4294967295:i32, %0
infer %1

; *****
; For LLVM instruction:
;  %87 = icmp ugt i32 %78, 9
; Looking for a replacement for:
%0:i32 = var
%1:i1 = ult 9:i32, %0
infer %1

; *****
; For LLVM instruction:
;  %88 = icmp ne i32 %85, 0
; Looking for a replacement for:
%0:i32 = var (range=[1,11))
%1:i32 = addnsw 4294967295:i32, %0 (hasExternalUses)
%2:i1 = ne 0:i32, %1
infer %2

; *****
; For LLVM instruction:
;  %89 = and i1 %87, %88
; Looking for a replacement for:
%0:i32 = var (range=[1,11))
%1:i32 = addnsw 4294967295:i32, %0 (hasExternalUses)
%2:i1 = ne 0:i32, %1
%3:i32 = var
%4:i1 = ult 9:i32, %3
%5:i1 = and %2, %4
infer %5

; *****
; For LLVM instruction:
;  %91 = add i32 %69, -3
; Looking for a replacement for:
%0:i32 = var
%1 = block 2
%2:i32 = phi %1, 4294967285:i32, 4294967284:i32
%3:i32 = add %0, %2 (hasExternalUses)
%4:i32 = var
%5:i32 = sub %3, %4 (hasExternalUses)
%6:i32 = add 4294967293:i32, %5 (hasExternalUses)
%7:i32 = var
%8:i32 = sub %6, %7 (hasExternalUses)
%9:i32 = add 4294967293:i32, %8
infer %9

; *****
; For LLVM instruction:
;  %92 = sub i32 11, %79
; Looking for a replacement for:
%0:i32 = var (range=[1,11))
%1:i32 = addnsw 4294967295:i32, %0 (hasExternalUses)
%2:i1 = ne 0:i32, %1
%3:i32 = var
%4:i1 = ult 9:i32, %3
%5:i1 = and %2, %4
pc %5 0:i1
%6:i32 = sub 11:i32, %0
infer %6

; *****
; For LLVM instruction:
;  %94 = call i32 @strlen(i8* nonnull %74) #6
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %95 = icmp ugt i32 %91, %94
; Looking for a replacement for:
%0:i32 = var
%1:i32 = var
%2 = block 2
%3:i32 = phi %2, 4294967285:i32, 4294967284:i32
%4:i32 = add %1, %3 (hasExternalUses)
%5:i32 = var
%6:i32 = sub %4, %5 (hasExternalUses)
%7:i32 = add 4294967293:i32, %6 (hasExternalUses)
%8:i32 = var
%9:i32 = sub %7, %8 (hasExternalUses)
%10:i32 = add 4294967293:i32, %9 (hasExternalUses)
%11:i1 = ult %0, %10
infer %11

; *****
; For LLVM instruction:
;  %98 = add nuw i32 %94, 1
; Looking for a replacement for:
%0:i32 = var
%1:i32 = var
%2 = block 2
%3:i32 = phi %2, 4294967285:i32, 4294967284:i32
%4:i32 = add %1, %3 (hasExternalUses)
%5:i32 = var
%6:i32 = sub %4, %5 (hasExternalUses)
%7:i32 = add 4294967293:i32, %6 (hasExternalUses)
%8:i32 = var
%9:i32 = sub %7, %8 (hasExternalUses)
%10:i32 = add 4294967293:i32, %9 (hasExternalUses)
%11:i1 = ult %0, %10
pc %11 1:i1
%12:i32 = addnuw 1:i32, %0
infer %12

; *****
; For LLVM instruction:
;  %100 = sub i32 %91, %94
; Looking for a replacement for:
%0:i32 = var
%1:i32 = var
%2 = block 2
%3:i32 = phi %2, 4294967285:i32, 4294967284:i32
%4:i32 = add %1, %3 (hasExternalUses)
%5:i32 = var
%6:i32 = sub %4, %5 (hasExternalUses)
%7:i32 = add 4294967293:i32, %6 (hasExternalUses)
%8:i32 = var
%9:i32 = sub %7, %8 (hasExternalUses)
%10:i32 = add 4294967293:i32, %9 (hasExternalUses)
%11:i1 = ult %0, %10
pc %11 1:i1
%12:i32 = sub %10, %0
infer %12

; *****
; For LLVM instruction:
;  %101 = icmp ult i32 %100, 4
; Looking for a replacement for:
%0:i32 = var
%1:i32 = var
%2 = block 2
%3:i32 = phi %2, 4294967285:i32, 4294967284:i32
%4:i32 = add %1, %3 (hasExternalUses)
%5:i32 = var
%6:i32 = sub %4, %5 (hasExternalUses)
%7:i32 = add 4294967293:i32, %6 (hasExternalUses)
%8:i32 = var
%9:i32 = sub %7, %8 (hasExternalUses)
%10:i32 = add 4294967293:i32, %9 (hasExternalUses)
%11:i1 = ult %0, %10
pc %11 1:i1
%12:i32 = sub %10, %0 (hasExternalUses)
%13:i1 = ult %12, 4:i32
infer %13

; *****
; For LLVM instruction:
;  %107 = load i32, i32* %106, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %109 = phi i32 [ %107, %102 ], [ %111, %108 ]
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %110 = phi i32 [ 10, %102 ], [ %116, %108 ]
; Looking for a replacement for:
%0:i32 = var (range=[1,11))
infer %0

; *****
; For LLVM instruction:
;  %111 = udiv i32 %109, 10
; Looking for a replacement for:
%0:i32 = var
%1:i32 = udiv %0, 10:i32
infer %1

; *****
; For LLVM instruction:
;  %112 = mul i32 %111, 10
; Looking for a replacement for:
%0:i32 = var
%1:i32 = udiv %0, 10:i32 (hasExternalUses)
%2:i32 = mul 10:i32, %1
infer %2 (demandedBits=00000000000000000000000011111111)

; *****
; For LLVM instruction:
;  %113 = sub i32 %109, %112
; Looking for a replacement for:
%0:i32 = var
%1:i32 = udiv %0, 10:i32 (hasExternalUses)
%2:i32 = mul 10:i32, %1
%3:i32 = sub %0, %2
infer %3 (demandedBits=00000000000000000000000011001111)

; *****
; For LLVM instruction:
;  %114 = trunc i32 %113 to i8
; Looking for a replacement for:
%0:i32 = var
%1:i32 = udiv %0, 10:i32 (hasExternalUses)
%2:i32 = mul 10:i32, %1
%3:i32 = sub %0, %2
%4:i8 = trunc %3
infer %4 (demandedBits=11001111)

; *****
; For LLVM instruction:
;  %115 = or i8 %114, 48
; Looking for a replacement for:
%0:i32 = var
%1:i32 = udiv %0, 10:i32 (hasExternalUses)
%2:i32 = mul 10:i32, %1
%3:i32 = sub %0, %2
%4:i8 = trunc %3
%5:i8 = or 48:i8, %4
infer %5

; *****
; For LLVM instruction:
;  %116 = add nsw i32 %110, -1
; Looking for a replacement for:
%0:i32 = var (range=[1,11))
%1:i32 = addnsw 4294967295:i32, %0
infer %1

; *****
; For LLVM instruction:
;  %118 = icmp ugt i32 %109, 9
; Looking for a replacement for:
%0:i32 = var
%1:i1 = ult 9:i32, %0
infer %1

; *****
; For LLVM instruction:
;  %119 = icmp ne i32 %116, 0
; Looking for a replacement for:
%0:i32 = var (range=[1,11))
%1:i32 = addnsw 4294967295:i32, %0 (hasExternalUses)
%2:i1 = ne 0:i32, %1
infer %2

; *****
; For LLVM instruction:
;  %120 = and i1 %118, %119
; Looking for a replacement for:
%0:i32 = var (range=[1,11))
%1:i32 = addnsw 4294967295:i32, %0 (hasExternalUses)
%2:i1 = ne 0:i32, %1
%3:i32 = var
%4:i1 = ult 9:i32, %3
%5:i1 = and %2, %4
infer %5

; *****
; For LLVM instruction:
;  %122 = add i32 %100, -3
; Looking for a replacement for:
%0:i32 = var
%1 = block 2
%2:i32 = phi %1, 4294967285:i32, 4294967284:i32
%3:i32 = add %0, %2 (hasExternalUses)
%4:i32 = var
%5:i32 = sub %3, %4 (hasExternalUses)
%6:i32 = add 4294967293:i32, %5 (hasExternalUses)
%7:i32 = var
%8:i32 = sub %6, %7 (hasExternalUses)
%9:i32 = add 4294967293:i32, %8 (hasExternalUses)
%10:i32 = var
%11:i32 = sub %9, %10 (hasExternalUses)
%12:i32 = add 4294967293:i32, %11
infer %12

; *****
; For LLVM instruction:
;  %123 = sub i32 11, %110
; Looking for a replacement for:
%0:i32 = var (range=[1,11))
%1:i32 = addnsw 4294967295:i32, %0 (hasExternalUses)
%2:i1 = ne 0:i32, %1
%3:i32 = var
%4:i1 = ult 9:i32, %3
%5:i1 = and %2, %4
pc %5 0:i1
%6:i32 = sub 11:i32, %0
infer %6

; *****
; For LLVM instruction:
;  %125 = call i32 @strlen(i8* nonnull %105) #6
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %126 = icmp ugt i32 %122, %125
; Looking for a replacement for:
%0:i32 = var
%1:i32 = var
%2 = block 2
%3:i32 = phi %2, 4294967285:i32, 4294967284:i32
%4:i32 = add %1, %3 (hasExternalUses)
%5:i32 = var
%6:i32 = sub %4, %5 (hasExternalUses)
%7:i32 = add 4294967293:i32, %6 (hasExternalUses)
%8:i32 = var
%9:i32 = sub %7, %8 (hasExternalUses)
%10:i32 = add 4294967293:i32, %9 (hasExternalUses)
%11:i32 = var
%12:i32 = sub %10, %11 (hasExternalUses)
%13:i32 = add 4294967293:i32, %12 (hasExternalUses)
%14:i1 = ult %0, %13
infer %14

; *****
; For LLVM instruction:
;  %129 = add nuw i32 %125, 1
; Looking for a replacement for:
%0:i32 = var
%1:i32 = var
%2 = block 2
%3:i32 = phi %2, 4294967285:i32, 4294967284:i32
%4:i32 = add %1, %3 (hasExternalUses)
%5:i32 = var
%6:i32 = sub %4, %5 (hasExternalUses)
%7:i32 = add 4294967293:i32, %6 (hasExternalUses)
%8:i32 = var
%9:i32 = sub %7, %8 (hasExternalUses)
%10:i32 = add 4294967293:i32, %9 (hasExternalUses)
%11:i32 = var
%12:i32 = sub %10, %11 (hasExternalUses)
%13:i32 = add 4294967293:i32, %12 (hasExternalUses)
%14:i1 = ult %0, %13
pc %14 1:i1
%15:i32 = addnuw 1:i32, %0
infer %15

; *****
; For LLVM instruction:
;  %131 = sub i32 %122, %125
; Looking for a replacement for:
%0:i32 = var
%1:i32 = var
%2 = block 2
%3:i32 = phi %2, 4294967285:i32, 4294967284:i32
%4:i32 = add %1, %3 (hasExternalUses)
%5:i32 = var
%6:i32 = sub %4, %5 (hasExternalUses)
%7:i32 = add 4294967293:i32, %6 (hasExternalUses)
%8:i32 = var
%9:i32 = sub %7, %8 (hasExternalUses)
%10:i32 = add 4294967293:i32, %9 (hasExternalUses)
%11:i32 = var
%12:i32 = sub %10, %11 (hasExternalUses)
%13:i32 = add 4294967293:i32, %12 (hasExternalUses)
%14:i1 = ult %0, %13
pc %14 1:i1
%15:i32 = sub %13, %0
infer %15

; *****
; For LLVM instruction:
;  %132 = icmp ult i32 %131, 2
; Looking for a replacement for:
%0:i32 = var
%1:i32 = var
%2 = block 2
%3:i32 = phi %2, 4294967285:i32, 4294967284:i32
%4:i32 = add %1, %3 (hasExternalUses)
%5:i32 = var
%6:i32 = sub %4, %5 (hasExternalUses)
%7:i32 = add 4294967293:i32, %6 (hasExternalUses)
%8:i32 = var
%9:i32 = sub %7, %8 (hasExternalUses)
%10:i32 = add 4294967293:i32, %9 (hasExternalUses)
%11:i32 = var
%12:i32 = sub %10, %11 (hasExternalUses)
%13:i32 = add 4294967293:i32, %12 (hasExternalUses)
%14:i1 = ult %0, %13
pc %14 1:i1
%15:i32 = sub %13, %0 (hasExternalUses)
%16:i1 = ult %15, 2:i32
infer %16

; *****
; For LLVM instruction:
;  %136 = add i32 %131, -1
; Looking for a replacement for:
%0:i32 = var
%1:i32 = var
%2 = block 2
%3:i32 = phi %2, 4294967285:i32, 4294967284:i32
%4:i32 = add %1, %3 (hasExternalUses)
%5:i32 = var
%6:i32 = sub %4, %5 (hasExternalUses)
%7:i32 = add 4294967293:i32, %6 (hasExternalUses)
%8:i32 = var
%9:i32 = sub %7, %8 (hasExternalUses)
%10:i32 = add 4294967293:i32, %9 (hasExternalUses)
%11:i32 = var
%12:i32 = sub %10, %11 (hasExternalUses)
%13:i32 = add 4294967293:i32, %12 (hasExternalUses)
%14:i1 = ult %0, %13
pc %14 1:i1
%15:i32 = sub %13, %0 (hasExternalUses)
%16:i1 = ult %15, 2:i32
pc %16 0:i1
%17:i32 = add 4294967295:i32, %15
infer %17

; *****
; For LLVM instruction:
;  %140 = load i32, i32* %139, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %142 = icmp eq i8* %141, null
; Looking for a replacement for:
%0:i32 = var
%1:i1 = eq 0:i32, %0
infer %1

; *****
; For LLVM instruction:
;  %144 = tail call i32 @strlen(i8* nonnull dereferenceable(1) %135) #6
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %146 = sub i32 %136, %144
; Looking for a replacement for:
%0:i32 = var
%1:i32 = var
%2 = block 2
%3:i32 = phi %2, 4294967285:i32, 4294967284:i32
%4:i32 = add %1, %3 (hasExternalUses)
%5:i32 = var
%6:i32 = sub %4, %5 (hasExternalUses)
%7:i32 = add 4294967293:i32, %6 (hasExternalUses)
%8:i32 = var
%9:i32 = sub %7, %8 (hasExternalUses)
%10:i32 = add 4294967293:i32, %9 (hasExternalUses)
%11:i32 = var
%12:i32 = sub %10, %11 (hasExternalUses)
%13:i32 = add 4294967293:i32, %12 (hasExternalUses)
%14:i1 = ult %0, %13
pc %14 1:i1
%15:i32 = sub %13, %0 (hasExternalUses)
%16:i1 = ult %15, 2:i32
pc %16 0:i1
%17:i32 = add 4294967295:i32, %15 (hasExternalUses)
%18:i32 = var
%19:i32 = sub %17, %18
infer %19

; *****
; For LLVM instruction:
;  %147 = icmp ult i32 %146, 2
; Looking for a replacement for:
%0:i32 = var
%1:i32 = var
%2 = block 2
%3:i32 = phi %2, 4294967285:i32, 4294967284:i32
%4:i32 = add %1, %3 (hasExternalUses)
%5:i32 = var
%6:i32 = sub %4, %5 (hasExternalUses)
%7:i32 = add 4294967293:i32, %6 (hasExternalUses)
%8:i32 = var
%9:i32 = sub %7, %8 (hasExternalUses)
%10:i32 = add 4294967293:i32, %9 (hasExternalUses)
%11:i32 = var
%12:i32 = sub %10, %11 (hasExternalUses)
%13:i32 = add 4294967293:i32, %12 (hasExternalUses)
%14:i1 = ult %0, %13
pc %14 1:i1
%15:i32 = sub %13, %0 (hasExternalUses)
%16:i1 = ult %15, 2:i32
pc %16 0:i1
%17:i32 = add 4294967295:i32, %15 (hasExternalUses)
%18:i32 = var
%19:i32 = sub %17, %18 (hasExternalUses)
%20:i1 = ult %19, 2:i32
infer %20

; *****
; For LLVM instruction:
;  %151 = add i32 %146, -1
; Looking for a replacement for:
%0:i32 = var
%1:i32 = var
%2 = block 2
%3:i32 = phi %2, 4294967285:i32, 4294967284:i32
%4:i32 = add %1, %3 (hasExternalUses)
%5:i32 = var
%6:i32 = sub %4, %5 (hasExternalUses)
%7:i32 = add 4294967293:i32, %6 (hasExternalUses)
%8:i32 = var
%9:i32 = sub %7, %8 (hasExternalUses)
%10:i32 = add 4294967293:i32, %9 (hasExternalUses)
%11:i32 = var
%12:i32 = sub %10, %11 (hasExternalUses)
%13:i32 = add 4294967293:i32, %12 (hasExternalUses)
%14:i1 = ult %0, %13
pc %14 1:i1
%15:i32 = sub %13, %0 (hasExternalUses)
%16:i1 = ult %15, 2:i32
pc %16 0:i1
%17:i32 = add 4294967295:i32, %15 (hasExternalUses)
%18:i32 = var
%19:i32 = sub %17, %18 (hasExternalUses)
%20:i1 = ult %19, 2:i32
pc %20 0:i1
%21:i32 = add 4294967295:i32, %19
infer %21

; *****
; For LLVM instruction:
;  %155 = load i32, i32* %154, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %157 = icmp eq i8* %156, null
; Looking for a replacement for:
%0:i32 = var
%1:i1 = eq 0:i32, %0
infer %1

; *****
; For LLVM instruction:
;  %158 = select i1 %157, i32 -31, i32 0
; Looking for a replacement for:
%0:i32 = var
%1:i1 = eq 0:i32, %0
%2:i32 = select %1, 4294967265:i32, 0:i32
infer %2

; *****
; For LLVM instruction:
;  %160 = phi i32 [ -31, %127 ], [ -31, %96 ], [ -31, %65 ], [ -31, %34 ], [ -31, %4 ], [ %21, %16 ], [ -31, %10 ], [ -31, %13 ], [ -31, %35 ], [ -31, %66 ], [ -31, %97 ], [ -31, %128 ], [ -31, %133 ], [ -31, %143 ]
; Looking for a replacement for:
%0 = block 14
%1:i32 = var
%2:i32 = phi %0, 4294967265:i32, 4294967265:i32, 4294967265:i32, 4294967265:i32, 4294967265:i32, %1, 4294967265:i32, 4294967265:i32, 4294967265:i32, 4294967265:i32, 4294967265:i32, 4294967265:i32, 4294967265:i32, 4294967265:i32
infer %2
got 2 candidates from LHS

-------------------------------------------------
%0:i32 = var
%1:i1 = ult %0, 13:i32
infer %1


--------------------------------
guess 0

%0:i1 = var ; reservedconst_1

Cost = 0
first query is SAT, returning the model:
reservedconst_1: -1
0 th attempt: second query is SAT-- constant doesn't work
first query is SAT, returning the model:
reservedconst_1: 0
1 th attempt: second query is SAT-- constant doesn't work
first query is UNSAT-- no more guesses
Dataflow Pruned 0/0
There are 1 Guesses
There are 0 RHSs before deduplication
There are 0 RHSs after deduplication
got 2 candidates from LHS

-------------------------------------------------
%0:i32 = var
%1:i1 = ult %0, 12:i32
infer %1


--------------------------------
guess 0

%0:i1 = var ; reservedconst_1

Cost = 0
first query is SAT, returning the model:
reservedconst_1: -1
0 th attempt: second query is SAT-- constant doesn't work
first query is SAT, returning the model:
reservedconst_1: 0
1 th attempt: second query is SAT-- constant doesn't work
first query is UNSAT-- no more guesses
Dataflow Pruned 0/0
There are 1 Guesses
There are 0 RHSs before deduplication
There are 0 RHSs after deduplication
got 1 candidates from LHS

-------------------------------------------------
%0 = block 2
%1:i32 = phi %0, 11:i32, 12:i32
infer %1


--------------------------------
guess 0

%0:i32 = var ; reservedconst_1

Cost = 0
first query is SAT, returning the model:
reservedconst_1: 12
0 th attempt: second query is SAT-- constant doesn't work
first query is SAT, returning the model:
reservedconst_1: 11
1 th attempt: second query is SAT-- constant doesn't work
first query is UNSAT-- no more guesses
Dataflow Pruned 0/0
There are 1 Guesses
There are 0 RHSs before deduplication
There are 0 RHSs after deduplication
got 1 candidates from LHS

-------------------------------------------------
%0 = block 2
%1:i32 = phi %0, 4294967285:i32, 4294967284:i32
infer %1


--------------------------------
guess 0

%0:i32 = var ; reservedconst_1

Cost = 0
first query is SAT, returning the model:
reservedconst_1: -12
0 th attempt: second query is SAT-- constant doesn't work
first query is SAT, returning the model:
reservedconst_1: -11
1 th attempt: second query is SAT-- constant doesn't work
first query is UNSAT-- no more guesses
Dataflow Pruned 0/0
There are 1 Guesses
There are 0 RHSs before deduplication
There are 0 RHSs after deduplication
got 3 candidates from LHS

-------------------------------------------------
%0:i32 = var
%1 = block 2
%2:i32 = phi %1, 4294967285:i32, 4294967284:i32
%3:i32 = add %0, %2
infer %3


--------------------------------
guess 0

%0:i32 = var ; reservedconst_1

Cost = 0
first query is SAT, returning the model:
reservedconst_1: -12
0 th attempt: second query is SAT-- constant doesn't work
first query is SAT, returning the model:
reservedconst_1: -11
1 th attempt: second query is SAT-- constant doesn't work
first query is UNSAT-- no more guesses

--------------------------------
guess 1

%0:i32 = var

Cost = 0
second query is SAT-- constant doesn't work

--------------------------------
guess 2

%0 = block 2
%1:i32 = phi %0, 4294967285:i32, 4294967284:i32

Cost = 1
second query is SAT-- constant doesn't work
Dataflow Pruned 0/0
There are 3 Guesses
There are 0 RHSs before deduplication
There are 0 RHSs after deduplication
got 1 candidates from LHS

-------------------------------------------------
%0:i16 = var
infer %0


--------------------------------
guess 0

%0:i16 = var ; reservedconst_1

Cost = 0
first query is SAT, returning the model:
reservedconst_1: 0
0 th attempt: second query is SAT-- constant doesn't work
first query is SAT, returning the model:
reservedconst_1: -1
1 th attempt: second query is SAT-- constant doesn't work
first query is UNSAT-- no more guesses
Dataflow Pruned 0/0
There are 1 Guesses
There are 0 RHSs before deduplication
There are 0 RHSs after deduplication
got 5 candidates from LHS

-------------------------------------------------
%0:i32 = var
%1:i32 = var
%2 = block 2
%3:i32 = phi %2, 4294967285:i32, 4294967284:i32
%4:i32 = add %1, %3 (hasExternalUses)
%5:i1 = ult %0, %4
infer %5


--------------------------------
guess 0

%0:i1 = var ; reservedconst_1

Cost = 0
first query is SAT, returning the model:
reservedconst_1: -1
0 th attempt: second query is SAT-- constant doesn't work
first query is SAT, returning the model:
reservedconst_1: 0
1 th attempt: second query is SAT-- constant doesn't work
first query is UNSAT-- no more guesses
Dataflow Pruned 0/0
There are 1 Guesses
There are 0 RHSs before deduplication
There are 0 RHSs after deduplication
got 2 candidates from LHS

-------------------------------------------------
%0:i32 = var
%1:i32 = var
%2 = block 2
%3:i32 = phi %2, 4294967285:i32, 4294967284:i32
%4:i32 = add %1, %3 (hasExternalUses)
%5:i1 = ult %0, %4
pc %5 1:i1
%6:i32 = addnuw 1:i32, %0
infer %6


--------------------------------
guess 0

%0:i32 = var ; reservedconst_1

Cost = 0
first query is SAT, returning the model:
reservedconst_1: -1
0 th attempt: second query is SAT-- constant doesn't work
first query is SAT, returning the model:
reservedconst_1: 1
1 th attempt: second query is SAT-- constant doesn't work
first query is UNSAT-- no more guesses

--------------------------------
guess 1

%0:i32 = var

Cost = 0
second query is SAT-- constant doesn't work
Dataflow Pruned 0/0
There are 2 Guesses
There are 0 RHSs before deduplication
There are 0 RHSs after deduplication
got 5 candidates from LHS

-------------------------------------------------
%0:i32 = var
%1:i32 = var
%2 = block 2
%3:i32 = phi %2, 4294967285:i32, 4294967284:i32
%4:i32 = add %1, %3 (hasExternalUses)
%5:i1 = ult %0, %4
pc %5 1:i1
%6:i32 = sub %4, %0
infer %6


--------------------------------
guess 0

%0:i32 = var ; reservedconst_1

Cost = 0
first query is SAT, returning the model:
reservedconst_1: 1
0 th attempt: second query is SAT-- constant doesn't work
first query is SAT, returning the model:
reservedconst_1: 2147483642
1 th attempt: second query is SAT-- constant doesn't work
first query is UNSAT-- no more guesses

--------------------------------
guess 1

%0:i32 = var

Cost = 0
second query is SAT-- constant doesn't work

--------------------------------
guess 2

%0:i32 = var

Cost = 0
second query is SAT-- constant doesn't work
Dataflow Pruned 0/0
There are 3 Guesses
There are 0 RHSs before deduplication
There are 0 RHSs after deduplication
got 6 candidates from LHS

-------------------------------------------------
%0:i32 = var
%1:i32 = var
%2 = block 2
%3:i32 = phi %2, 4294967285:i32, 4294967284:i32
%4:i32 = add %1, %3 (hasExternalUses)
%5:i1 = ult %0, %4
pc %5 1:i1
%6:i32 = sub %4, %0 (hasExternalUses)
%7:i1 = ult %6, 4:i32
infer %7


--------------------------------
guess 0

%0:i1 = var ; reservedconst_1

Cost = 0
first query is SAT, returning the model:
reservedconst_1: -1
0 th attempt: second query is SAT-- constant doesn't work
first query is SAT, returning the model:
reservedconst_1: 0
1 th attempt: second query is SAT-- constant doesn't work
first query is UNSAT-- no more guesses
Dataflow Pruned 0/0
There are 1 Guesses
There are 0 RHSs before deduplication
There are 0 RHSs after deduplication
got 1 candidates from LHS

-------------------------------------------------
%0:i32 = var (range=[1,11))
infer %0


--------------------------------
guess 0

%0:i32 = var ; reservedconst_1

Cost = 0
first query is SAT, returning the model:
reservedconst_1: 1
0 th attempt: second query is SAT-- constant doesn't work
first query is SAT, returning the model:
reservedconst_1: 4
1 th attempt: second query is SAT-- constant doesn't work
first query is UNSAT-- no more guesses
Dataflow Pruned 0/0
There are 1 Guesses
There are 0 RHSs before deduplication
There are 0 RHSs after deduplication
got 2 candidates from LHS

-------------------------------------------------
%0:i32 = var
%1:i32 = udiv %0, 10:i32
infer %1


--------------------------------
guess 0

%0:i32 = var ; reservedconst_1

Cost = 0
first query is SAT, returning the model:
reservedconst_1: 0
0 th attempt: second query is SAT-- constant doesn't work
first query is SAT, returning the model:
reservedconst_1: 85041980
1 th attempt: second query is SAT-- constant doesn't work
first query is UNSAT-- no more guesses

--------------------------------
guess 1

%0:i32 = var

Cost = 0
second query is SAT-- constant doesn't work
Dataflow Pruned 0/0
There are 2 Guesses
There are 0 RHSs before deduplication
There are 0 RHSs after deduplication
got 3 candidates from LHS

-------------------------------------------------
%0:i32 = var
%1:i32 = udiv %0, 10:i32 (hasExternalUses)
%2:i32 = mul 10:i32, %1
infer %2 (demandedBits=00000000000000000000000011111111)


--------------------------------
guess 0

%0:i32 = var ; reservedconst_1

Cost = 0
first query is SAT, returning the model:
reservedconst_1: 0
0 th attempt: second query is SAT-- constant doesn't work
first query is SAT, returning the model:
reservedconst_1: 1081307200
1 th attempt: second query is SAT-- constant doesn't work
first query is UNSAT-- no more guesses

--------------------------------
guess 1

%0:i32 = var

Cost = 0
second query is SAT-- constant doesn't work
Dataflow Pruned 0/0
There are 2 Guesses
There are 0 RHSs before deduplication
There are 0 RHSs after deduplication
got 4 candidates from LHS

-------------------------------------------------
%0:i32 = var
%1:i32 = udiv %0, 10:i32 (hasExternalUses)
%2:i32 = mul 10:i32, %1
%3:i32 = sub %0, %2
infer %3 (demandedBits=00000000000000000000000011001111)


--------------------------------
guess 0

%0:i32 = var ; reservedconst_1

Cost = 0
first query is SAT, returning the model:
reservedconst_1: 0
0 th attempt: second query is SAT-- constant doesn't work
first query is SAT, returning the model:
reservedconst_1: 2
1 th attempt: second query is SAT-- constant doesn't work
first query is UNSAT-- no more guesses

--------------------------------
guess 1

%0:i32 = var

Cost = 0
second query is SAT-- constant doesn't work
Dataflow Pruned 0/0
There are 2 Guesses
There are 0 RHSs before deduplication
There are 0 RHSs after deduplication
got 5 candidates from LHS

-------------------------------------------------
%0:i32 = var
%1:i32 = udiv %0, 10:i32 (hasExternalUses)
%2:i32 = mul 10:i32, %1
%3:i32 = sub %0, %2
%4:i8 = trunc %3
infer %4 (demandedBits=11001111)


--------------------------------
guess 0

%0:i8 = var ; reservedconst_1

Cost = 0
first query is SAT, returning the model:
reservedconst_1: 0
0 th attempt: second query is SAT-- constant doesn't work
first query is SAT, returning the model:
reservedconst_1: 6
1 th attempt: second query is SAT-- constant doesn't work
first query is UNSAT-- no more guesses
Dataflow Pruned 0/0
There are 1 Guesses
There are 0 RHSs before deduplication
There are 0 RHSs after deduplication
got 6 candidates from LHS

-------------------------------------------------
%0:i32 = var
%1:i32 = udiv %0, 10:i32 (hasExternalUses)
%2:i32 = mul 10:i32, %1
%3:i32 = sub %0, %2
%4:i8 = trunc %3
%5:i8 = or 48:i8, %4
infer %5


--------------------------------
guess 0

%0:i8 = var ; reservedconst_1

Cost = 0
first query is SAT, returning the model:
reservedconst_1: 48
0 th attempt: second query is SAT-- constant doesn't work
first query is SAT, returning the model:
reservedconst_1: 54
1 th attempt: second query is SAT-- constant doesn't work
first query is UNSAT-- no more guesses
Dataflow Pruned 0/0
There are 1 Guesses
There are 0 RHSs before deduplication
There are 0 RHSs after deduplication
got 2 candidates from LHS

-------------------------------------------------
%0:i32 = var (range=[1,11))
%1:i32 = addnsw 4294967295:i32, %0
infer %1


--------------------------------
guess 0

%0:i32 = var ; reservedconst_1

Cost = 0
first query is SAT, returning the model:
reservedconst_1: 0
0 th attempt: second query is SAT-- constant doesn't work
first query is SAT, returning the model:
reservedconst_1: 3
1 th attempt: second query is SAT-- constant doesn't work
first query is UNSAT-- no more guesses

--------------------------------
guess 1

%0:i32 = var (range=[1,11))

Cost = 0
second query is SAT-- constant doesn't work
Dataflow Pruned 0/0
There are 2 Guesses
There are 0 RHSs before deduplication
There are 0 RHSs after deduplication
got 2 candidates from LHS

-------------------------------------------------
%0:i32 = var
%1:i1 = ult 9:i32, %0
infer %1


--------------------------------
guess 0

%0:i1 = var ; reservedconst_1

Cost = 0
first query is SAT, returning the model:
reservedconst_1: 0
0 th attempt: second query is SAT-- constant doesn't work
first query is SAT, returning the model:
reservedconst_1: -1
1 th attempt: second query is SAT-- constant doesn't work
first query is UNSAT-- no more guesses
Dataflow Pruned 0/0
There are 1 Guesses
There are 0 RHSs before deduplication
There are 0 RHSs after deduplication
got 3 candidates from LHS

-------------------------------------------------
%0:i32 = var (range=[1,11))
%1:i32 = addnsw 4294967295:i32, %0 (hasExternalUses)
%2:i1 = ne 0:i32, %1
infer %2


--------------------------------
guess 0

%0:i1 = var ; reservedconst_1

Cost = 0
first query is SAT, returning the model:
reservedconst_1: 0
0 th attempt: second query is SAT-- constant doesn't work
first query is SAT, returning the model:
reservedconst_1: -1
1 th attempt: second query is SAT-- constant doesn't work
first query is UNSAT-- no more guesses
Dataflow Pruned 0/0
There are 1 Guesses
There are 0 RHSs before deduplication
There are 0 RHSs after deduplication
got 6 candidates from LHS

-------------------------------------------------
%0:i32 = var (range=[1,11))
%1:i32 = addnsw 4294967295:i32, %0 (hasExternalUses)
%2:i1 = ne 0:i32, %1
%3:i32 = var
%4:i1 = ult 9:i32, %3
%5:i1 = and %2, %4
infer %5


--------------------------------
guess 0

%0:i1 = var ; reservedconst_1

Cost = 0
first query is SAT, returning the model:
reservedconst_1: 0
0 th attempt: second query is SAT-- constant doesn't work
first query is SAT, returning the model:
reservedconst_1: -1
1 th attempt: second query is SAT-- constant doesn't work
first query is UNSAT-- no more guesses

--------------------------------
guess 1

%0:i32 = var
%1:i1 = ult 9:i32, %0

Cost = 1
second query is SAT-- constant doesn't work

--------------------------------
guess 2

%0:i32 = var (range=[1,11))
%1:i32 = addnsw 4294967295:i32, %0 (hasExternalUses)
%2:i1 = ne 0:i32, %1

Cost = 1
second query is SAT-- constant doesn't work
Dataflow Pruned 0/0
There are 3 Guesses
There are 0 RHSs before deduplication
There are 0 RHSs after deduplication
got 6 candidates from LHS

-------------------------------------------------
%0:i32 = var
%1 = block 2
%2:i32 = phi %1, 4294967285:i32, 4294967284:i32
%3:i32 = add %0, %2 (hasExternalUses)
%4:i32 = var
%5:i32 = sub %3, %4 (hasExternalUses)
%6:i32 = add 4294967293:i32, %5
infer %6


--------------------------------
guess 0

%0:i32 = var ; reservedconst_1

Cost = 0
first query is SAT, returning the model:
reservedconst_1: -15
0 th attempt: second query is SAT-- constant doesn't work
first query is SAT, returning the model:
reservedconst_1: -17
1 th attempt: second query is SAT-- constant doesn't work
first query is UNSAT-- no more guesses

--------------------------------
guess 1

%0:i32 = var

Cost = 0
second query is SAT-- constant doesn't work

--------------------------------
guess 2

%0:i32 = var

Cost = 0
second query is SAT-- constant doesn't work
Dataflow Pruned 0/0
There are 3 Guesses
There are 0 RHSs before deduplication
There are 0 RHSs after deduplication
got 2 candidates from LHS

-------------------------------------------------
%0:i32 = var (range=[1,11))
%1:i32 = addnsw 4294967295:i32, %0 (hasExternalUses)
%2:i1 = ne 0:i32, %1
%3:i32 = var
%4:i1 = ult 9:i32, %3
%5:i1 = and %2, %4
pc %5 0:i1
%6:i32 = sub 11:i32, %0
infer %6


--------------------------------
guess 0

%0:i32 = var ; reservedconst_1

Cost = 0
first query is SAT, returning the model:
reservedconst_1: 10
0 th attempt: second query is SAT-- constant doesn't work
first query is SAT, returning the model:
reservedconst_1: 9
1 th attempt: second query is SAT-- constant doesn't work
first query is UNSAT-- no more guesses

--------------------------------
guess 1

%0:i32 = var (range=[1,11))

Cost = 0
second query is SAT-- constant doesn't work
Dataflow Pruned 0/0
There are 2 Guesses
There are 0 RHSs before deduplication
There are 0 RHSs after deduplication
got 8 candidates from LHS

-------------------------------------------------
%0:i32 = var
%1:i32 = var
%2 = block 2
%3:i32 = phi %2, 4294967285:i32, 4294967284:i32
%4:i32 = add %1, %3 (hasExternalUses)
%5:i32 = var
%6:i32 = sub %4, %5 (hasExternalUses)
%7:i32 = add 4294967293:i32, %6 (hasExternalUses)
%8:i1 = ult %0, %7
infer %8


--------------------------------
guess 0

%0:i1 = var ; reservedconst_1

Cost = 0
first query is SAT, returning the model:
reservedconst_1: -1
0 th attempt: second query is SAT-- constant doesn't work
first query is SAT, returning the model:
reservedconst_1: 0
1 th attempt: second query is SAT-- constant doesn't work
first query is UNSAT-- no more guesses
Dataflow Pruned 0/0
There are 1 Guesses
There are 0 RHSs before deduplication
There are 0 RHSs after deduplication
got 2 candidates from LHS

-------------------------------------------------
%0:i32 = var
%1:i32 = var
%2 = block 2
%3:i32 = phi %2, 4294967285:i32, 4294967284:i32
%4:i32 = add %1, %3 (hasExternalUses)
%5:i32 = var
%6:i32 = sub %4, %5 (hasExternalUses)
%7:i32 = add 4294967293:i32, %6 (hasExternalUses)
%8:i1 = ult %0, %7
pc %8 1:i1
%9:i32 = addnuw 1:i32, %0
infer %9


--------------------------------
guess 0

%0:i32 = var ; reservedconst_1

Cost = 0
first query is SAT, returning the model:
reservedconst_1: -1
0 th attempt: second query is SAT-- constant doesn't work
first query is SAT, returning the model:
reservedconst_1: 1
1 th attempt: second query is SAT-- constant doesn't work
first query is UNSAT-- no more guesses

--------------------------------
guess 1

%0:i32 = var

Cost = 0
second query is SAT-- constant doesn't work
Dataflow Pruned 0/0
There are 2 Guesses
There are 0 RHSs before deduplication
There are 0 RHSs after deduplication
got 8 candidates from LHS

-------------------------------------------------
%0:i32 = var
%1:i32 = var
%2 = block 2
%3:i32 = phi %2, 4294967285:i32, 4294967284:i32
%4:i32 = add %1, %3 (hasExternalUses)
%5:i32 = var
%6:i32 = sub %4, %5 (hasExternalUses)
%7:i32 = add 4294967293:i32, %6 (hasExternalUses)
%8:i1 = ult %0, %7
pc %8 1:i1
%9:i32 = sub %7, %0
infer %9


--------------------------------
guess 0

%0:i32 = var ; reservedconst_1

Cost = 0
first query is SAT, returning the model:
reservedconst_1: 1
0 th attempt: second query is SAT-- constant doesn't work
first query is SAT, returning the model:
reservedconst_1: 111149058
1 th attempt: second query is SAT-- constant doesn't work
first query is UNSAT-- no more guesses

--------------------------------
guess 1

%0:i32 = var

Cost = 0
second query is SAT-- constant doesn't work

--------------------------------
guess 2

%0:i32 = var

Cost = 0
second query is SAT-- constant doesn't work

--------------------------------
guess 3

%0:i32 = var

Cost = 0
second query is SAT-- constant doesn't work
Dataflow Pruned 0/0
There are 4 Guesses
There are 0 RHSs before deduplication
There are 0 RHSs after deduplication
got 8 candidates from LHS

-------------------------------------------------
%0:i32 = var
%1:i32 = var
%2 = block 2
%3:i32 = phi %2, 4294967285:i32, 4294967284:i32
%4:i32 = add %1, %3 (hasExternalUses)
%5:i32 = var
%6:i32 = sub %4, %5 (hasExternalUses)
%7:i32 = add 4294967293:i32, %6 (hasExternalUses)
%8:i1 = ult %0, %7
pc %8 1:i1
%9:i32 = sub %7, %0 (hasExternalUses)
%10:i1 = ult %9, 4:i32
infer %10


--------------------------------
guess 0

%0:i1 = var ; reservedconst_1

Cost = 0
first query is SAT, returning the model:
reservedconst_1: -1
0 th attempt: second query is SAT-- constant doesn't work
first query is SAT, returning the model:
reservedconst_1: 0
1 th attempt: second query is SAT-- constant doesn't work
first query is UNSAT-- no more guesses
Dataflow Pruned 0/0
There are 1 Guesses
There are 0 RHSs before deduplication
There are 0 RHSs after deduplication
got 8 candidates from LHS

-------------------------------------------------
%0:i32 = var
%1 = block 2
%2:i32 = phi %1, 4294967285:i32, 4294967284:i32
%3:i32 = add %0, %2 (hasExternalUses)
%4:i32 = var
%5:i32 = sub %3, %4 (hasExternalUses)
%6:i32 = add 4294967293:i32, %5 (hasExternalUses)
%7:i32 = var
%8:i32 = sub %6, %7 (hasExternalUses)
%9:i32 = add 4294967293:i32, %8
infer %9


--------------------------------
guess 0

%0:i32 = var ; reservedconst_1

Cost = 0
first query is SAT, returning the model:
reservedconst_1: -18
0 th attempt: second query is SAT-- constant doesn't work
first query is SAT, returning the model:
reservedconst_1: -20
1 th attempt: second query is SAT-- constant doesn't work
first query is UNSAT-- no more guesses

--------------------------------
guess 1

%0:i32 = var

Cost = 0
second query is SAT-- constant doesn't work

--------------------------------
guess 2

%0:i32 = var

Cost = 0
second query is SAT-- constant doesn't work
Dataflow Pruned 0/0
There are 3 Guesses
There are 0 RHSs before deduplication
There are 0 RHSs after deduplication
got 8 candidates from LHS

-------------------------------------------------
%0:i32 = var
%1:i32 = var
%2 = block 2
%3:i32 = phi %2, 4294967285:i32, 4294967284:i32
%4:i32 = add %1, %3 (hasExternalUses)
%5:i32 = var
%6:i32 = sub %4, %5 (hasExternalUses)
%7:i32 = add 4294967293:i32, %6 (hasExternalUses)
%8:i32 = var
%9:i32 = sub %7, %8 (hasExternalUses)
%10:i32 = add 4294967293:i32, %9 (hasExternalUses)
%11:i1 = ult %0, %10
infer %11


--------------------------------
guess 0

%0:i1 = var ; reservedconst_1

Cost = 0
first query is SAT, returning the model:
reservedconst_1: -1
0 th attempt: second query is SAT-- constant doesn't work
first query is SAT, returning the model:
reservedconst_1: 0
1 th attempt: second query is SAT-- constant doesn't work
first query is UNSAT-- no more guesses
Dataflow Pruned 0/0
There are 1 Guesses
There are 0 RHSs before deduplication
There are 0 RHSs after deduplication
got 2 candidates from LHS

-------------------------------------------------
%0:i32 = var
%1:i32 = var
%2 = block 2
%3:i32 = phi %2, 4294967285:i32, 4294967284:i32
%4:i32 = add %1, %3 (hasExternalUses)
%5:i32 = var
%6:i32 = sub %4, %5 (hasExternalUses)
%7:i32 = add 4294967293:i32, %6 (hasExternalUses)
%8:i32 = var
%9:i32 = sub %7, %8 (hasExternalUses)
%10:i32 = add 4294967293:i32, %9 (hasExternalUses)
%11:i1 = ult %0, %10
pc %11 1:i1
%12:i32 = addnuw 1:i32, %0
infer %12


--------------------------------
guess 0

%0:i32 = var ; reservedconst_1

Cost = 0
first query is SAT, returning the model:
reservedconst_1: -1
0 th attempt: second query is SAT-- constant doesn't work
first query is SAT, returning the model:
reservedconst_1: 1
1 th attempt: second query is SAT-- constant doesn't work
first query is UNSAT-- no more guesses

--------------------------------
guess 1

%0:i32 = var

Cost = 0
second query is SAT-- constant doesn't work
Dataflow Pruned 0/0
There are 2 Guesses
There are 0 RHSs before deduplication
There are 0 RHSs after deduplication
got 8 candidates from LHS

-------------------------------------------------
%0:i32 = var
%1:i32 = var
%2 = block 2
%3:i32 = phi %2, 4294967285:i32, 4294967284:i32
%4:i32 = add %1, %3 (hasExternalUses)
%5:i32 = var
%6:i32 = sub %4, %5 (hasExternalUses)
%7:i32 = add 4294967293:i32, %6 (hasExternalUses)
%8:i32 = var
%9:i32 = sub %7, %8 (hasExternalUses)
%10:i32 = add 4294967293:i32, %9 (hasExternalUses)
%11:i1 = ult %0, %10
pc %11 1:i1
%12:i32 = sub %10, %0
infer %12


--------------------------------
guess 0

%0:i32 = var ; reservedconst_1

Cost = 0
first query is SAT, returning the model:
reservedconst_1: 1
0 th attempt: second query is SAT-- constant doesn't work
first query is SAT, returning the model:
reservedconst_1: -2147483646
1 th attempt: second query is SAT-- constant doesn't work
first query is UNSAT-- no more guesses

--------------------------------
guess 1

%0:i32 = var

Cost = 0
second query is SAT-- constant doesn't work

--------------------------------
guess 2

%0:i32 = var

Cost = 0
second query is SAT-- constant doesn't work
Dataflow Pruned 0/0
There are 3 Guesses
There are 0 RHSs before deduplication
There are 0 RHSs after deduplication
got 8 candidates from LHS

-------------------------------------------------
%0:i32 = var
%1:i32 = var
%2 = block 2
%3:i32 = phi %2, 4294967285:i32, 4294967284:i32
%4:i32 = add %1, %3 (hasExternalUses)
%5:i32 = var
%6:i32 = sub %4, %5 (hasExternalUses)
%7:i32 = add 4294967293:i32, %6 (hasExternalUses)
%8:i32 = var
%9:i32 = sub %7, %8 (hasExternalUses)
%10:i32 = add 4294967293:i32, %9 (hasExternalUses)
%11:i1 = ult %0, %10
pc %11 1:i1
%12:i32 = sub %10, %0 (hasExternalUses)
%13:i1 = ult %12, 4:i32
infer %13


--------------------------------
guess 0

%0:i1 = var ; reservedconst_1

Cost = 0
first query is SAT, returning the model:
reservedconst_1: -1
0 th attempt: second query is SAT-- constant doesn't work
first query is SAT, returning the model:
reservedconst_1: 0
1 th attempt: second query is SAT-- constant doesn't work
first query is UNSAT-- no more guesses
Dataflow Pruned 0/0
There are 1 Guesses
There are 0 RHSs before deduplication
There are 0 RHSs after deduplication
got 8 candidates from LHS

-------------------------------------------------
%0:i32 = var
%1 = block 2
%2:i32 = phi %1, 4294967285:i32, 4294967284:i32
%3:i32 = add %0, %2 (hasExternalUses)
%4:i32 = var
%5:i32 = sub %3, %4 (hasExternalUses)
%6:i32 = add 4294967293:i32, %5 (hasExternalUses)
%7:i32 = var
%8:i32 = sub %6, %7 (hasExternalUses)
%9:i32 = add 4294967293:i32, %8 (hasExternalUses)
%10:i32 = var
%11:i32 = sub %9, %10 (hasExternalUses)
%12:i32 = add 4294967293:i32, %11
infer %12


--------------------------------
guess 0

%0:i32 = var ; reservedconst_1

Cost = 0
first query is SAT, returning the model:
reservedconst_1: -21
0 th attempt: second query is SAT-- constant doesn't work
first query is SAT, returning the model:
reservedconst_1: -23
1 th attempt: second query is SAT-- constant doesn't work
first query is UNSAT-- no more guesses

--------------------------------
guess 1

%0:i32 = var

Cost = 0
second query is SAT-- constant doesn't work

--------------------------------
guess 2

%0:i32 = var

Cost = 0
second query is SAT-- constant doesn't work
Dataflow Pruned 0/0
There are 3 Guesses
There are 0 RHSs before deduplication
There are 0 RHSs after deduplication
got 8 candidates from LHS

-------------------------------------------------
%0:i32 = var
%1:i32 = var
%2 = block 2
%3:i32 = phi %2, 4294967285:i32, 4294967284:i32
%4:i32 = add %1, %3 (hasExternalUses)
%5:i32 = var
%6:i32 = sub %4, %5 (hasExternalUses)
%7:i32 = add 4294967293:i32, %6 (hasExternalUses)
%8:i32 = var
%9:i32 = sub %7, %8 (hasExternalUses)
%10:i32 = add 4294967293:i32, %9 (hasExternalUses)
%11:i32 = var
%12:i32 = sub %10, %11 (hasExternalUses)
%13:i32 = add 4294967293:i32, %12 (hasExternalUses)
%14:i1 = ult %0, %13
infer %14


--------------------------------
guess 0

%0:i1 = var ; reservedconst_1

Cost = 0
first query is SAT, returning the model:
reservedconst_1: -1
0 th attempt: second query is SAT-- constant doesn't work
first query is SAT, returning the model:
reservedconst_1: 0
1 th attempt: second query is SAT-- constant doesn't work
first query is UNSAT-- no more guesses
Dataflow Pruned 0/0
There are 1 Guesses
There are 0 RHSs before deduplication
There are 0 RHSs after deduplication
got 2 candidates from LHS

-------------------------------------------------
%0:i32 = var
%1:i32 = var
%2 = block 2
%3:i32 = phi %2, 4294967285:i32, 4294967284:i32
%4:i32 = add %1, %3 (hasExternalUses)
%5:i32 = var
%6:i32 = sub %4, %5 (hasExternalUses)
%7:i32 = add 4294967293:i32, %6 (hasExternalUses)
%8:i32 = var
%9:i32 = sub %7, %8 (hasExternalUses)
%10:i32 = add 4294967293:i32, %9 (hasExternalUses)
%11:i32 = var
%12:i32 = sub %10, %11 (hasExternalUses)
%13:i32 = add 4294967293:i32, %12 (hasExternalUses)
%14:i1 = ult %0, %13
pc %14 1:i1
%15:i32 = addnuw 1:i32, %0
infer %15


--------------------------------
guess 0

%0:i32 = var ; reservedconst_1

Cost = 0
first query is SAT, returning the model:
reservedconst_1: -1
0 th attempt: second query is SAT-- constant doesn't work
first query is SAT, returning the model:
reservedconst_1: 1
1 th attempt: second query is SAT-- constant doesn't work
first query is UNSAT-- no more guesses

--------------------------------
guess 1

%0:i32 = var

Cost = 0
second query is SAT-- constant doesn't work
Dataflow Pruned 0/0
There are 2 Guesses
There are 0 RHSs before deduplication
There are 0 RHSs after deduplication
got 8 candidates from LHS

-------------------------------------------------
%0:i32 = var
%1:i32 = var
%2 = block 2
%3:i32 = phi %2, 4294967285:i32, 4294967284:i32
%4:i32 = add %1, %3 (hasExternalUses)
%5:i32 = var
%6:i32 = sub %4, %5 (hasExternalUses)
%7:i32 = add 4294967293:i32, %6 (hasExternalUses)
%8:i32 = var
%9:i32 = sub %7, %8 (hasExternalUses)
%10:i32 = add 4294967293:i32, %9 (hasExternalUses)
%11:i32 = var
%12:i32 = sub %10, %11 (hasExternalUses)
%13:i32 = add 4294967293:i32, %12 (hasExternalUses)
%14:i1 = ult %0, %13
pc %14 1:i1
%15:i32 = sub %13, %0
infer %15


--------------------------------
guess 0

%0:i32 = var ; reservedconst_1

Cost = 0
first query is SAT, returning the model:
reservedconst_1: 1
0 th attempt: second query is SAT-- constant doesn't work
first query is SAT, returning the model:
reservedconst_1: -2147483647
1 th attempt: second query is SAT-- constant doesn't work
first query is UNSAT-- no more guesses

--------------------------------
guess 1

%0:i32 = var

Cost = 0
second query is SAT-- constant doesn't work

--------------------------------
guess 2

%0:i32 = var

Cost = 0
second query is SAT-- constant doesn't work
Dataflow Pruned 0/0
There are 3 Guesses
There are 0 RHSs before deduplication
There are 0 RHSs after deduplication
got 8 candidates from LHS

-------------------------------------------------
%0:i32 = var
%1:i32 = var
%2 = block 2
%3:i32 = phi %2, 4294967285:i32, 4294967284:i32
%4:i32 = add %1, %3 (hasExternalUses)
%5:i32 = var
%6:i32 = sub %4, %5 (hasExternalUses)
%7:i32 = add 4294967293:i32, %6 (hasExternalUses)
%8:i32 = var
%9:i32 = sub %7, %8 (hasExternalUses)
%10:i32 = add 4294967293:i32, %9 (hasExternalUses)
%11:i32 = var
%12:i32 = sub %10, %11 (hasExternalUses)
%13:i32 = add 4294967293:i32, %12 (hasExternalUses)
%14:i1 = ult %0, %13
pc %14 1:i1
%15:i32 = sub %13, %0 (hasExternalUses)
%16:i1 = ult %15, 2:i32
infer %16


--------------------------------
guess 0

%0:i1 = var ; reservedconst_1

Cost = 0
first query is SAT, returning the model:
reservedconst_1: -1
0 th attempt: second query is SAT-- constant doesn't work
first query is SAT, returning the model:
reservedconst_1: 0
1 th attempt: second query is SAT-- constant doesn't work
first query is UNSAT-- no more guesses
Dataflow Pruned 0/0
There are 1 Guesses
There are 0 RHSs before deduplication
There are 0 RHSs after deduplication
got 8 candidates from LHS

-------------------------------------------------
%0:i32 = var
%1:i32 = var
%2 = block 2
%3:i32 = phi %2, 4294967285:i32, 4294967284:i32
%4:i32 = add %1, %3 (hasExternalUses)
%5:i32 = var
%6:i32 = sub %4, %5 (hasExternalUses)
%7:i32 = add 4294967293:i32, %6 (hasExternalUses)
%8:i32 = var
%9:i32 = sub %7, %8 (hasExternalUses)
%10:i32 = add 4294967293:i32, %9 (hasExternalUses)
%11:i32 = var
%12:i32 = sub %10, %11 (hasExternalUses)
%13:i32 = add 4294967293:i32, %12 (hasExternalUses)
%14:i1 = ult %0, %13
pc %14 1:i1
%15:i32 = sub %13, %0 (hasExternalUses)
%16:i1 = ult %15, 2:i32
pc %16 0:i1
%17:i32 = add 4294967295:i32, %15
infer %17


--------------------------------
guess 0

%0:i32 = var ; reservedconst_1

Cost = 0
first query is SAT, returning the model:
reservedconst_1: 1704188950
0 th attempt: second query is SAT-- constant doesn't work
first query is SAT, returning the model:
reservedconst_1: 601620467
1 th attempt: second query is SAT-- constant doesn't work
first query is UNSAT-- no more guesses

--------------------------------
guess 1

%0:i32 = var

Cost = 0
second query is SAT-- constant doesn't work

--------------------------------
guess 2

%0:i32 = var

Cost = 0
second query is SAT-- constant doesn't work
Dataflow Pruned 0/0
There are 3 Guesses
There are 0 RHSs before deduplication
There are 0 RHSs after deduplication
got 8 candidates from LHS

-------------------------------------------------
%0:i32 = var
%1:i32 = var
%2 = block 2
%3:i32 = phi %2, 4294967285:i32, 4294967284:i32
%4:i32 = add %1, %3 (hasExternalUses)
%5:i32 = var
%6:i32 = sub %4, %5 (hasExternalUses)
%7:i32 = add 4294967293:i32, %6 (hasExternalUses)
%8:i32 = var
%9:i32 = sub %7, %8 (hasExternalUses)
%10:i32 = add 4294967293:i32, %9 (hasExternalUses)
%11:i32 = var
%12:i32 = sub %10, %11 (hasExternalUses)
%13:i32 = add 4294967293:i32, %12 (hasExternalUses)
%14:i1 = ult %0, %13
pc %14 1:i1
%15:i32 = sub %13, %0 (hasExternalUses)
%16:i1 = ult %15, 2:i32
pc %16 0:i1
%17:i32 = add 4294967295:i32, %15 (hasExternalUses)
%18:i32 = var
%19:i32 = sub %17, %18
infer %19


--------------------------------
guess 0

%0:i32 = var ; reservedconst_1

Cost = 0
first query is SAT, returning the model:
reservedconst_1: 1704188950
0 th attempt: second query is SAT-- constant doesn't work
first query is SAT, returning the model:
reservedconst_1: 695818656
1 th attempt: second query is SAT-- constant doesn't work
first query is UNSAT-- no more guesses

--------------------------------
guess 1

%0:i32 = var

Cost = 0
second query is SAT-- constant doesn't work

--------------------------------
guess 2

%0:i32 = var

Cost = 0
second query is SAT-- constant doesn't work
Dataflow Pruned 0/0
There are 3 Guesses
There are 0 RHSs before deduplication
There are 0 RHSs after deduplication
got 8 candidates from LHS

-------------------------------------------------
%0:i32 = var
%1:i32 = var
%2 = block 2
%3:i32 = phi %2, 4294967285:i32, 4294967284:i32
%4:i32 = add %1, %3 (hasExternalUses)
%5:i32 = var
%6:i32 = sub %4, %5 (hasExternalUses)
%7:i32 = add 4294967293:i32, %6 (hasExternalUses)
%8:i32 = var
%9:i32 = sub %7, %8 (hasExternalUses)
%10:i32 = add 4294967293:i32, %9 (hasExternalUses)
%11:i32 = var
%12:i32 = sub %10, %11 (hasExternalUses)
%13:i32 = add 4294967293:i32, %12 (hasExternalUses)
%14:i1 = ult %0, %13
pc %14 1:i1
%15:i32 = sub %13, %0 (hasExternalUses)
%16:i1 = ult %15, 2:i32
pc %16 0:i1
%17:i32 = add 4294967295:i32, %15 (hasExternalUses)
%18:i32 = var
%19:i32 = sub %17, %18 (hasExternalUses)
%20:i1 = ult %19, 2:i32
infer %20


--------------------------------
guess 0

%0:i1 = var ; reservedconst_1

Cost = 0
first query is SAT, returning the model:
reservedconst_1: 0
0 th attempt: second query is SAT-- constant doesn't work
first query is SAT, returning the model:
reservedconst_1: -1
1 th attempt: second query is SAT-- constant doesn't work
first query is UNSAT-- no more guesses
Dataflow Pruned 0/0
There are 1 Guesses
There are 0 RHSs before deduplication
There are 0 RHSs after deduplication
got 8 candidates from LHS

-------------------------------------------------
%0:i32 = var
%1:i32 = var
%2 = block 2
%3:i32 = phi %2, 4294967285:i32, 4294967284:i32
%4:i32 = add %1, %3 (hasExternalUses)
%5:i32 = var
%6:i32 = sub %4, %5 (hasExternalUses)
%7:i32 = add 4294967293:i32, %6 (hasExternalUses)
%8:i32 = var
%9:i32 = sub %7, %8 (hasExternalUses)
%10:i32 = add 4294967293:i32, %9 (hasExternalUses)
%11:i32 = var
%12:i32 = sub %10, %11 (hasExternalUses)
%13:i32 = add 4294967293:i32, %12 (hasExternalUses)
%14:i1 = ult %0, %13
pc %14 1:i1
%15:i32 = sub %13, %0 (hasExternalUses)
%16:i1 = ult %15, 2:i32
pc %16 0:i1
%17:i32 = add 4294967295:i32, %15 (hasExternalUses)
%18:i32 = var
%19:i32 = sub %17, %18 (hasExternalUses)
%20:i1 = ult %19, 2:i32
pc %20 0:i1
%21:i32 = add 4294967295:i32, %19
infer %21


--------------------------------
guess 0

%0:i32 = var ; reservedconst_1

Cost = 0
first query is SAT, returning the model:
reservedconst_1: 1
0 th attempt: second query is SAT-- constant doesn't work
first query is SAT, returning the model:
reservedconst_1: -947912705
1 th attempt: second query is SAT-- constant doesn't work
first query is UNSAT-- no more guesses

--------------------------------
guess 1

%0:i32 = var

Cost = 0
second query is SAT-- constant doesn't work

--------------------------------
guess 2

%0:i32 = var

Cost = 0
second query is SAT-- constant doesn't work
Dataflow Pruned 0/0
There are 3 Guesses
There are 0 RHSs before deduplication
There are 0 RHSs after deduplication
got 3 candidates from LHS

-------------------------------------------------
%0:i32 = var
%1:i1 = eq 0:i32, %0
%2:i32 = select %1, 4294967265:i32, 0:i32
infer %2


--------------------------------
guess 0

%0:i32 = var ; reservedconst_1

Cost = 0
first query is SAT, returning the model:
reservedconst_1: -31
0 th attempt: second query is SAT-- constant doesn't work
first query is SAT, returning the model:
reservedconst_1: 0
1 th attempt: second query is SAT-- constant doesn't work
first query is UNSAT-- no more guesses

--------------------------------
guess 1

%0:i32 = var

Cost = 0
second query is SAT-- constant doesn't work
Dataflow Pruned 0/0
There are 2 Guesses
There are 0 RHSs before deduplication
There are 0 RHSs after deduplication
got 2 candidates from LHS

-------------------------------------------------
%0 = block 14
%1:i32 = var
%2:i32 = phi %0, 4294967265:i32, 4294967265:i32, 4294967265:i32, 4294967265:i32, 4294967265:i32, %1, 4294967265:i32, 4294967265:i32, 4294967265:i32, 4294967265:i32, 4294967265:i32, 4294967265:i32, 4294967265:i32, 4294967265:i32
infer %2


--------------------------------
guess 0

%0:i32 = var ; reservedconst_1

Cost = 0
first query is SAT, returning the model:
reservedconst_1: -31
0 th attempt: second query is SAT-- constant doesn't work
first query is SAT, returning the model:
reservedconst_1: 30
1 th attempt: second query is SAT-- constant doesn't work
first query is UNSAT-- no more guesses

--------------------------------
guess 1

%0:i32 = var

Cost = 0
second query is SAT-- constant doesn't work
Dataflow Pruned 0/0
There are 2 Guesses
There are 0 RHSs before deduplication
There are 0 RHSs after deduplication
#########################################################
; exiting Souper's runOnFunction() for argon2_encode_string()
Total of 0 replacements done on this module
Total of 0 replacements candidates on this module
