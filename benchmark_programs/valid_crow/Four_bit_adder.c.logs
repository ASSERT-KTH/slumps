
Entering the Souper pass's runOnModule()


; entering Souper's runOnFunction() for halfadder()

; ModuleID = './Four_bit_adder.c.bc'
source_filename = "./Four_bit_adder.c"
target datalayout = "e-m:e-p:32:32-i64:64-n32:64-S128"
target triple = "wasm32-unknown-wasi"

@.str = private unnamed_addr constant [47 x i8] c"%d%d%d%d + %d%d%d%d = %d%d%d%d, overflow = %d\0A\00", align 1
@llvm.used = appending global [1 x i8*] [i8* bitcast (i32 ()* @__main_void to i8*)], section "llvm.metadata"

@__main_void = alias i32 (), i32 ()* @main

; Function Attrs: noinline nounwind optnone
define hidden void @halfadder(i8* %a, i8* %b, i8* %s, i8* %c) #0 {
entry:
  %a.addr = alloca i8*, align 4
  %b.addr = alloca i8*, align 4
  %s.addr = alloca i8*, align 4
  %c.addr = alloca i8*, align 4
  store i8* %a, i8** %a.addr, align 4
  store i8* %b, i8** %b.addr, align 4
  store i8* %s, i8** %s.addr, align 4
  store i8* %c, i8** %c.addr, align 4
  %0 = load i8*, i8** %a.addr, align 4
  %1 = load i8, i8* %0, align 1
  %conv = sext i8 %1 to i32
  %neg = xor i32 %conv, -1
  %and = and i32 %neg, 1
  %2 = load i8*, i8** %b.addr, align 4
  %3 = load i8, i8* %2, align 1
  %conv1 = sext i8 %3 to i32
  %and2 = and i32 %and, %conv1
  %4 = load i8*, i8** %a.addr, align 4
  %5 = load i8, i8* %4, align 1
  %conv3 = sext i8 %5 to i32
  %6 = load i8*, i8** %b.addr, align 4
  %7 = load i8, i8* %6, align 1
  %conv4 = sext i8 %7 to i32
  %neg5 = xor i32 %conv4, -1
  %and6 = and i32 %neg5, 1
  %and7 = and i32 %conv3, %and6
  %or = or i32 %and2, %and7
  %conv8 = trunc i32 %or to i8
  %8 = load i8*, i8** %s.addr, align 4
  store i8 %conv8, i8* %8, align 1
  %9 = load i8*, i8** %a.addr, align 4
  %10 = load i8, i8* %9, align 1
  %conv9 = sext i8 %10 to i32
  %11 = load i8*, i8** %b.addr, align 4
  %12 = load i8, i8* %11, align 1
  %conv10 = sext i8 %12 to i32
  %and11 = and i32 %conv9, %conv10
  %conv12 = trunc i32 %and11 to i8
  %13 = load i8*, i8** %c.addr, align 4
  store i8 %conv12, i8* %13, align 1
  ret void
}

; Function Attrs: noinline nounwind optnone
define hidden void @fulladder(i8* %a, i8* %b, i8* %ic, i8* %s, i8* %oc) #0 {
entry:
  %a.addr = alloca i8*, align 4
  %b.addr = alloca i8*, align 4
  %ic.addr = alloca i8*, align 4
  %s.addr = alloca i8*, align 4
  %oc.addr = alloca i8*, align 4
  %_ps = alloca i8, align 1
  %ps = alloca i8*, align 4
  %_pc = alloca i8, align 1
  %pc = alloca i8*, align 4
  %_tc = alloca i8, align 1
  %tc = alloca i8*, align 4
  store i8* %a, i8** %a.addr, align 4
  store i8* %b, i8** %b.addr, align 4
  store i8* %ic, i8** %ic.addr, align 4
  store i8* %s, i8** %s.addr, align 4
  store i8* %oc, i8** %oc.addr, align 4
  store i8* %_ps, i8** %ps, align 4
  store i8* %_pc, i8** %pc, align 4
  store i8* %_tc, i8** %tc, align 4
  %0 = load i8*, i8** %a.addr, align 4
  %1 = load i8*, i8** %b.addr, align 4
  %2 = load i8*, i8** %ps, align 4
  %3 = load i8*, i8** %pc, align 4
  call void @halfadder(i8* %0, i8* %1, i8* %2, i8* %3)
  %4 = load i8*, i8** %ps, align 4
  %5 = load i8*, i8** %ic.addr, align 4
  %6 = load i8*, i8** %s.addr, align 4
  %7 = load i8*, i8** %tc, align 4
  call void @halfadder(i8* %4, i8* %5, i8* %6, i8* %7)
  %8 = load i8*, i8** %tc, align 4
  %9 = load i8, i8* %8, align 1
  %conv = sext i8 %9 to i32
  %10 = load i8*, i8** %pc, align 4
  %11 = load i8, i8* %10, align 1
  %conv1 = sext i8 %11 to i32
  %or = or i32 %conv, %conv1
  %conv2 = trunc i32 %or to i8
  %12 = load i8*, i8** %oc.addr, align 4
  store i8 %conv2, i8* %12, align 1
  ret void
}

; Function Attrs: noinline nounwind optnone
define hidden void @fourbitsadder(i8* %a0, i8* %a1, i8* %a2, i8* %a3, i8* %b0, i8* %b1, i8* %b2, i8* %b3, i8* %o0, i8* %o1, i8* %o2, i8* %o3, i8* %overflow) #0 {
entry:
  %a0.addr = alloca i8*, align 4
  %a1.addr = alloca i8*, align 4
  %a2.addr = alloca i8*, align 4
  %a3.addr = alloca i8*, align 4
  %b0.addr = alloca i8*, align 4
  %b1.addr = alloca i8*, align 4
  %b2.addr = alloca i8*, align 4
  %b3.addr = alloca i8*, align 4
  %o0.addr = alloca i8*, align 4
  %o1.addr = alloca i8*, align 4
  %o2.addr = alloca i8*, align 4
  %o3.addr = alloca i8*, align 4
  %overflow.addr = alloca i8*, align 4
  %_zero = alloca i8, align 1
  %zero = alloca i8*, align 4
  %_tc0 = alloca i8, align 1
  %tc0 = alloca i8*, align 4
  %_tc1 = alloca i8, align 1
  %tc1 = alloca i8*, align 4
  %_tc2 = alloca i8, align 1
  %tc2 = alloca i8*, align 4
  store i8* %a0, i8** %a0.addr, align 4
  store i8* %a1, i8** %a1.addr, align 4
  store i8* %a2, i8** %a2.addr, align 4
  store i8* %a3, i8** %a3.addr, align 4
  store i8* %b0, i8** %b0.addr, align 4
  store i8* %b1, i8** %b1.addr, align 4
  store i8* %b2, i8** %b2.addr, align 4
  store i8* %b3, i8** %b3.addr, align 4
  store i8* %o0, i8** %o0.addr, align 4
  store i8* %o1, i8** %o1.addr, align 4
  store i8* %o2, i8** %o2.addr, align 4
  store i8* %o3, i8** %o3.addr, align 4
  store i8* %overflow, i8** %overflow.addr, align 4
  store i8* %_zero, i8** %zero, align 4
  %0 = load i8*, i8** %zero, align 4
  store i8 0, i8* %0, align 1
  store i8* %_tc0, i8** %tc0, align 4
  store i8* %_tc1, i8** %tc1, align 4
  store i8* %_tc2, i8** %tc2, align 4
  %1 = load i8*, i8** %a0.addr, align 4
  %2 = load i8*, i8** %b0.addr, align 4
  %3 = load i8*, i8** %zero, align 4
  %4 = load i8*, i8** %o0.addr, align 4
  %5 = load i8*, i8** %tc0, align 4
  call void @fulladder(i8* %1, i8* %2, i8* %3, i8* %4, i8* %5)
  %6 = load i8*, i8** %a1.addr, align 4
  %7 = load i8*, i8** %b1.addr, align 4
  %8 = load i8*, i8** %tc0, align 4
  %9 = load i8*, i8** %o1.addr, align 4
  %10 = load i8*, i8** %tc1, align 4
  call void @fulladder(i8* %6, i8* %7, i8* %8, i8* %9, i8* %10)
  %11 = load i8*, i8** %a2.addr, align 4
  %12 = load i8*, i8** %b2.addr, align 4
  %13 = load i8*, i8** %tc1, align 4
  %14 = load i8*, i8** %o2.addr, align 4
  %15 = load i8*, i8** %tc2, align 4
  call void @fulladder(i8* %11, i8* %12, i8* %13, i8* %14, i8* %15)
  %16 = load i8*, i8** %a3.addr, align 4
  %17 = load i8*, i8** %b3.addr, align 4
  %18 = load i8*, i8** %tc2, align 4
  %19 = load i8*, i8** %o3.addr, align 4
  %20 = load i8*, i8** %overflow.addr, align 4
  call void @fulladder(i8* %16, i8* %17, i8* %18, i8* %19, i8* %20)
  ret void
}

; Function Attrs: noinline nounwind optnone
define hidden i32 @main() #0 {
entry:
  %retval = alloca i32, align 4
  %_a0 = alloca i8, align 1
  %a0 = alloca i8*, align 4
  %_a1 = alloca i8, align 1
  %a1 = alloca i8*, align 4
  %_a2 = alloca i8, align 1
  %a2 = alloca i8*, align 4
  %_a3 = alloca i8, align 1
  %a3 = alloca i8*, align 4
  %_b0 = alloca i8, align 1
  %b0 = alloca i8*, align 4
  %_b1 = alloca i8, align 1
  %b1 = alloca i8*, align 4
  %_b2 = alloca i8, align 1
  %b2 = alloca i8*, align 4
  %_b3 = alloca i8, align 1
  %b3 = alloca i8*, align 4
  %_s0 = alloca i8, align 1
  %s0 = alloca i8*, align 4
  %_s1 = alloca i8, align 1
  %s1 = alloca i8*, align 4
  %_s2 = alloca i8, align 1
  %s2 = alloca i8*, align 4
  %_s3 = alloca i8, align 1
  %s3 = alloca i8*, align 4
  %_overflow = alloca i8, align 1
  %overflow = alloca i8*, align 4
  store i32 0, i32* %retval, align 4
  store i8* %_a0, i8** %a0, align 4
  store i8* %_a1, i8** %a1, align 4
  store i8* %_a2, i8** %a2, align 4
  store i8* %_a3, i8** %a3, align 4
  store i8* %_b0, i8** %b0, align 4
  store i8* %_b1, i8** %b1, align 4
  store i8* %_b2, i8** %b2, align 4
  store i8* %_b3, i8** %b3, align 4
  store i8* %_s0, i8** %s0, align 4
  store i8* %_s1, i8** %s1, align 4
  store i8* %_s2, i8** %s2, align 4
  store i8* %_s3, i8** %s3, align 4
  store i8* %_overflow, i8** %overflow, align 4
  %0 = load i8*, i8** %a3, align 4
  store i8 0, i8* %0, align 1
  %1 = load i8*, i8** %b3, align 4
  store i8 1, i8* %1, align 1
  %2 = load i8*, i8** %a2, align 4
  store i8 0, i8* %2, align 1
  %3 = load i8*, i8** %b2, align 4
  store i8 1, i8* %3, align 1
  %4 = load i8*, i8** %a1, align 4
  store i8 1, i8* %4, align 1
  %5 = load i8*, i8** %b1, align 4
  store i8 1, i8* %5, align 1
  %6 = load i8*, i8** %a0, align 4
  store i8 0, i8* %6, align 1
  %7 = load i8*, i8** %b0, align 4
  store i8 0, i8* %7, align 1
  %8 = load i8*, i8** %a0, align 4
  %9 = load i8*, i8** %a1, align 4
  %10 = load i8*, i8** %a2, align 4
  %11 = load i8*, i8** %a3, align 4
  %12 = load i8*, i8** %b0, align 4
  %13 = load i8*, i8** %b1, align 4
  %14 = load i8*, i8** %b2, align 4
  %15 = load i8*, i8** %b3, align 4
  %16 = load i8*, i8** %s0, align 4
  %17 = load i8*, i8** %s1, align 4
  %18 = load i8*, i8** %s2, align 4
  %19 = load i8*, i8** %s3, align 4
  %20 = load i8*, i8** %overflow, align 4
  call void @fourbitsadder(i8* %8, i8* %9, i8* %10, i8* %11, i8* %12, i8* %13, i8* %14, i8* %15, i8* %16, i8* %17, i8* %18, i8* %19, i8* %20)
  %21 = load i8*, i8** %a3, align 4
  %22 = load i8, i8* %21, align 1
  %conv = sext i8 %22 to i32
  %23 = load i8*, i8** %a2, align 4
  %24 = load i8, i8* %23, align 1
  %conv1 = sext i8 %24 to i32
  %25 = load i8*, i8** %a1, align 4
  %26 = load i8, i8* %25, align 1
  %conv2 = sext i8 %26 to i32
  %27 = load i8*, i8** %a0, align 4
  %28 = load i8, i8* %27, align 1
  %conv3 = sext i8 %28 to i32
  %29 = load i8*, i8** %b3, align 4
  %30 = load i8, i8* %29, align 1
  %conv4 = sext i8 %30 to i32
  %31 = load i8*, i8** %b2, align 4
  %32 = load i8, i8* %31, align 1
  %conv5 = sext i8 %32 to i32
  %33 = load i8*, i8** %b1, align 4
  %34 = load i8, i8* %33, align 1
  %conv6 = sext i8 %34 to i32
  %35 = load i8*, i8** %b0, align 4
  %36 = load i8, i8* %35, align 1
  %conv7 = sext i8 %36 to i32
  %37 = load i8*, i8** %s3, align 4
  %38 = load i8, i8* %37, align 1
  %conv8 = sext i8 %38 to i32
  %39 = load i8*, i8** %s2, align 4
  %40 = load i8, i8* %39, align 1
  %conv9 = sext i8 %40 to i32
  %41 = load i8*, i8** %s1, align 4
  %42 = load i8, i8* %41, align 1
  %conv10 = sext i8 %42 to i32
  %43 = load i8*, i8** %s0, align 4
  %44 = load i8, i8* %43, align 1
  %conv11 = sext i8 %44 to i32
  %45 = load i8*, i8** %overflow, align 4
  %46 = load i8, i8* %45, align 1
  %conv12 = sext i8 %46 to i32
  %call = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([47 x i8], [47 x i8]* @.str, i32 0, i32 0), i32 %conv, i32 %conv1, i32 %conv2, i32 %conv3, i32 %conv4, i32 %conv5, i32 %conv6, i32 %conv7, i32 %conv8, i32 %conv9, i32 %conv10, i32 %conv11, i32 %conv12)
  ret i32 0
}

declare i32 @printf(i8* %0, ...) #1

attributes #0 = { noinline nounwind optnone "correctly-rounded-divide-sqrt-fp-math"="false" "disable-tail-calls"="false" "frame-pointer"="none" "less-precise-fpmad"="false" "min-legal-vector-width"="0" "no-infs-fp-math"="false" "no-jump-tables"="false" "no-nans-fp-math"="false" "no-signed-zeros-fp-math"="false" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="generic" "unsafe-fp-math"="false" "use-soft-float"="false" }
attributes #1 = { "correctly-rounded-divide-sqrt-fp-math"="false" "disable-tail-calls"="false" "frame-pointer"="none" "less-precise-fpmad"="false" "no-infs-fp-math"="false" "no-nans-fp-math"="false" "no-signed-zeros-fp-math"="false" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="generic" "unsafe-fp-math"="false" "use-soft-float"="false" }

!llvm.module.flags = !{!0}
!llvm.ident = !{!1}

!0 = !{i32 1, !"wchar_size", i32 4}
!1 = !{!"clang version 11.0.0 (https://github.com/Jacarte/llvm-project.git 0f6dea67136cc1e0b3d200eb2bb165628970c44b)"}

; extracted candidates

; *****
; For LLVM instruction:
;  %1 = load i8, i8* %0, align 1
; Looking for a replacement for:
%0:i8 = var
infer %0 (demandedBits=00000001)

; *****
; For LLVM instruction:
;  %conv = sext i8 %1 to i32
; Looking for a replacement for:
%0:i8 = var
%1:i32 = sext %0
infer %1 (demandedBits=00000000000000000000000000000001)

; *****
; For LLVM instruction:
;  %neg = xor i32 %conv, -1
; Looking for a replacement for:
%0:i8 = var
%1:i32 = sext %0
%2:i32 = xor 4294967295:i32, %1
infer %2 (demandedBits=00000000000000000000000000000001)

; *****
; For LLVM instruction:
;  %and = and i32 %neg, 1
; Looking for a replacement for:
%0:i8 = var
%1:i32 = sext %0
%2:i32 = xor 4294967295:i32, %1
%3:i32 = and 1:i32, %2
infer %3 (demandedBits=00000000000000000000000011111111)

; *****
; For LLVM instruction:
;  %3 = load i8, i8* %2, align 1
; Looking for a replacement for:
%0:i8 = var
infer %0 (demandedBits=00000001)

; *****
; For LLVM instruction:
;  %conv1 = sext i8 %3 to i32
; Looking for a replacement for:
%0:i8 = var
%1:i32 = sext %0
infer %1 (demandedBits=00000000000000000000000000000001)

; *****
; For LLVM instruction:
;  %and2 = and i32 %and, %conv1
; Looking for a replacement for:
%0:i8 = var
%1:i32 = sext %0
%2:i32 = xor 4294967295:i32, %1
%3:i32 = and 1:i32, %2
%4:i8 = var
%5:i32 = sext %4
%6:i32 = and %3, %5
infer %6 (demandedBits=00000000000000000000000011111111)

; *****
; For LLVM instruction:
;  %5 = load i8, i8* %4, align 1
; Looking for a replacement for:
%0:i8 = var
infer %0 (demandedBits=00000001)

; *****
; For LLVM instruction:
;  %conv3 = sext i8 %5 to i32
; Looking for a replacement for:
%0:i8 = var
%1:i32 = sext %0
infer %1 (demandedBits=00000000000000000000000000000001)

; *****
; For LLVM instruction:
;  %7 = load i8, i8* %6, align 1
; Looking for a replacement for:
%0:i8 = var
infer %0 (demandedBits=00000001)

; *****
; For LLVM instruction:
;  %conv4 = sext i8 %7 to i32
; Looking for a replacement for:
%0:i8 = var
%1:i32 = sext %0
infer %1 (demandedBits=00000000000000000000000000000001)

; *****
; For LLVM instruction:
;  %neg5 = xor i32 %conv4, -1
; Looking for a replacement for:
%0:i8 = var
%1:i32 = sext %0
%2:i32 = xor 4294967295:i32, %1
infer %2 (demandedBits=00000000000000000000000000000001)

; *****
; For LLVM instruction:
;  %and6 = and i32 %neg5, 1
; Looking for a replacement for:
%0:i8 = var
%1:i32 = sext %0
%2:i32 = xor 4294967295:i32, %1
%3:i32 = and 1:i32, %2
infer %3 (demandedBits=00000000000000000000000011111111)

; *****
; For LLVM instruction:
;  %and7 = and i32 %conv3, %and6
; Looking for a replacement for:
%0:i8 = var
%1:i32 = sext %0
%2:i32 = xor 4294967295:i32, %1
%3:i32 = and 1:i32, %2
%4:i8 = var
%5:i32 = sext %4
%6:i32 = and %3, %5
infer %6 (demandedBits=00000000000000000000000011111111)

; *****
; For LLVM instruction:
;  %or = or i32 %and2, %and7
; Looking for a replacement for:
%0:i8 = var
%1:i32 = sext %0
%2:i32 = xor 4294967295:i32, %1
%3:i32 = and 1:i32, %2
%4:i8 = var
%5:i32 = sext %4
%6:i32 = and %3, %5
%7:i8 = var
%8:i32 = sext %7
%9:i32 = xor 4294967295:i32, %8
%10:i32 = and 1:i32, %9
%11:i8 = var
%12:i32 = sext %11
%13:i32 = and %10, %12
%14:i32 = or %6, %13
infer %14 (demandedBits=00000000000000000000000011111111)

; *****
; For LLVM instruction:
;  %conv8 = trunc i32 %or to i8
; Looking for a replacement for:
%0:i8 = var
%1:i32 = sext %0
%2:i32 = xor 4294967295:i32, %1
%3:i32 = and 1:i32, %2
%4:i8 = var
%5:i32 = sext %4
%6:i32 = and %3, %5
%7:i8 = var
%8:i32 = sext %7
%9:i32 = xor 4294967295:i32, %8
%10:i32 = and 1:i32, %9
%11:i8 = var
%12:i32 = sext %11
%13:i32 = and %10, %12
%14:i32 = or %6, %13
%15:i8 = trunc %14
infer %15

; *****
; For LLVM instruction:
;  %10 = load i8, i8* %9, align 1
; Looking for a replacement for:
%0:i8 = var
infer %0

; *****
; For LLVM instruction:
;  %conv9 = sext i8 %10 to i32
; Looking for a replacement for:
%0:i8 = var
%1:i32 = sext %0
infer %1 (demandedBits=00000000000000000000000011111111)

; *****
; For LLVM instruction:
;  %12 = load i8, i8* %11, align 1
; Looking for a replacement for:
%0:i8 = var
infer %0

; *****
; For LLVM instruction:
;  %conv10 = sext i8 %12 to i32
; Looking for a replacement for:
%0:i8 = var
%1:i32 = sext %0
infer %1 (demandedBits=00000000000000000000000011111111)

; *****
; For LLVM instruction:
;  %and11 = and i32 %conv9, %conv10
; Looking for a replacement for:
%0:i8 = var
%1:i32 = sext %0
%2:i8 = var
%3:i32 = sext %2
%4:i32 = and %1, %3
infer %4 (demandedBits=00000000000000000000000011111111)

; *****
; For LLVM instruction:
;  %conv12 = trunc i32 %and11 to i8
; Looking for a replacement for:
%0:i8 = var
%1:i32 = sext %0
%2:i8 = var
%3:i32 = sext %2
%4:i32 = and %1, %3
%5:i8 = trunc %4
infer %5
got 1 candidates from LHS

-------------------------------------------------
%0:i8 = var
infer %0 (demandedBits=00000001)


--------------------------------
guess 0

%0:i8 = var ; reservedconst_1

Cost = 0
first query is SAT, returning the model:
reservedconst_1: 0
0 th attempt: second query is SAT-- constant doesn't work
first query is SAT, returning the model:
reservedconst_1: 1
1 th attempt: second query is SAT-- constant doesn't work
first query is UNSAT-- no more guesses
Dataflow Pruned 0/0
There are 1 Guesses
There are 0 RHSs before deduplication
There are 0 RHSs after deduplication
got 2 candidates from LHS

-------------------------------------------------
%0:i8 = var
%1:i32 = sext %0
infer %1 (demandedBits=00000000000000000000000000000001)


--------------------------------
guess 0

%0:i32 = var ; reservedconst_1

Cost = 0
first query is SAT, returning the model:
reservedconst_1: 0
0 th attempt: second query is SAT-- constant doesn't work
first query is SAT, returning the model:
reservedconst_1: 1
1 th attempt: second query is SAT-- constant doesn't work
first query is UNSAT-- no more guesses
Dataflow Pruned 0/0
There are 1 Guesses
There are 0 RHSs before deduplication
There are 0 RHSs after deduplication
got 3 candidates from LHS

-------------------------------------------------
%0:i8 = var
%1:i32 = sext %0
%2:i32 = xor 4294967295:i32, %1
infer %2 (demandedBits=00000000000000000000000000000001)


--------------------------------
guess 0

%0:i32 = var ; reservedconst_1

Cost = 0
first query is SAT, returning the model:
reservedconst_1: 0
0 th attempt: second query is SAT-- constant doesn't work
first query is SAT, returning the model:
reservedconst_1: -1
1 th attempt: second query is SAT-- constant doesn't work
first query is UNSAT-- no more guesses

--------------------------------
guess 1

%0:i8 = var
%1:i32 = sext %0

Cost = 1
second query is SAT-- constant doesn't work
Dataflow Pruned 0/0
There are 2 Guesses
There are 0 RHSs before deduplication
There are 0 RHSs after deduplication
got 4 candidates from LHS

-------------------------------------------------
%0:i8 = var
%1:i32 = sext %0
%2:i32 = xor 4294967295:i32, %1
%3:i32 = and 1:i32, %2
infer %3 (demandedBits=00000000000000000000000011111111)


--------------------------------
guess 0

%0:i32 = var ; reservedconst_1

Cost = 0
first query is SAT, returning the model:
reservedconst_1: 0
0 th attempt: second query is SAT-- constant doesn't work
first query is SAT, returning the model:
reservedconst_1: 1
1 th attempt: second query is SAT-- constant doesn't work
first query is UNSAT-- no more guesses

--------------------------------
guess 1

%0:i8 = var
%1:i32 = sext %0

Cost = 1
second query is SAT-- constant doesn't work

--------------------------------
guess 2

%0:i8 = var
%1:i32 = sext %0
%2:i32 = xor 4294967295:i32, %1

Cost = 2
second query is SAT-- constant doesn't work
Dataflow Pruned 0/0
There are 3 Guesses
There are 0 RHSs before deduplication
There are 0 RHSs after deduplication
got 7 candidates from LHS

-------------------------------------------------
%0:i8 = var
%1:i32 = sext %0
%2:i32 = xor 4294967295:i32, %1
%3:i32 = and 1:i32, %2
%4:i8 = var
%5:i32 = sext %4
%6:i32 = and %3, %5
infer %6 (demandedBits=00000000000000000000000011111111)


--------------------------------
guess 0

%0:i32 = var ; reservedconst_1

Cost = 0
first query is SAT, returning the model:
reservedconst_1: 1
0 th attempt: second query is SAT-- constant doesn't work
first query is SAT, returning the model:
reservedconst_1: 0
1 th attempt: second query is SAT-- constant doesn't work
first query is UNSAT-- no more guesses

--------------------------------
guess 1

%0:i8 = var
%1:i32 = sext %0

Cost = 1
second query is SAT-- constant doesn't work

--------------------------------
guess 2

%0:i8 = var
%1:i32 = sext %0

Cost = 1
second query is SAT-- constant doesn't work

--------------------------------
guess 3

%0:i8 = var
%1:i32 = sext %0
%2:i32 = xor 4294967295:i32, %1

Cost = 2
second query is SAT-- constant doesn't work

--------------------------------
guess 4

%0:i8 = var
%1:i32 = sext %0
%2:i32 = xor 4294967295:i32, %1
%3:i32 = and 1:i32, %2

Cost = 3
second query is SAT-- constant doesn't work
Dataflow Pruned 0/0
There are 5 Guesses
There are 0 RHSs before deduplication
There are 0 RHSs after deduplication
got 8 candidates from LHS

-------------------------------------------------
%0:i8 = var
%1:i32 = sext %0
%2:i32 = xor 4294967295:i32, %1
%3:i32 = and 1:i32, %2
%4:i8 = var
%5:i32 = sext %4
%6:i32 = and %3, %5
%7:i8 = var
%8:i32 = sext %7
%9:i32 = xor 4294967295:i32, %8
%10:i32 = and 1:i32, %9
%11:i8 = var
%12:i32 = sext %11
%13:i32 = and %10, %12
%14:i32 = or %6, %13
infer %14 (demandedBits=00000000000000000000000011111111)


--------------------------------
guess 0

%0:i32 = var ; reservedconst_1

Cost = 0
first query is SAT, returning the model:
reservedconst_1: 1
0 th attempt: second query is SAT-- constant doesn't work
first query is SAT, returning the model:
reservedconst_1: 0
1 th attempt: second query is SAT-- constant doesn't work
first query is UNSAT-- no more guesses

--------------------------------
guess 1

%0:i8 = var
%1:i32 = sext %0

Cost = 1
second query is SAT-- constant doesn't work

--------------------------------
guess 2

%0:i8 = var
%1:i32 = sext %0

Cost = 1
second query is SAT-- constant doesn't work

--------------------------------
guess 3

%0:i8 = var
%1:i32 = sext %0
%2:i32 = xor 4294967295:i32, %1

Cost = 2
second query is SAT-- constant doesn't work

--------------------------------
guess 4

%0:i8 = var
%1:i32 = sext %0
%2:i32 = xor 4294967295:i32, %1
%3:i32 = and 1:i32, %2

Cost = 3
second query is SAT-- constant doesn't work

--------------------------------
guess 5

%0:i8 = var
%1:i32 = sext %0
%2:i32 = xor 4294967295:i32, %1
%3:i32 = and 1:i32, %2

Cost = 3
second query is SAT-- constant doesn't work

--------------------------------
guess 6

%0:i8 = var
%1:i32 = sext %0
%2:i32 = xor 4294967295:i32, %1
%3:i32 = and 1:i32, %2
%4:i8 = var
%5:i32 = sext %4
%6:i32 = and %3, %5

Cost = 5
second query is SAT-- constant doesn't work

--------------------------------
guess 7

%0:i8 = var
%1:i32 = sext %0
%2:i32 = xor 4294967295:i32, %1
%3:i32 = and 1:i32, %2
%4:i8 = var
%5:i32 = sext %4
%6:i32 = and %3, %5

Cost = 5
second query is SAT-- constant doesn't work
Dataflow Pruned 0/0
There are 8 Guesses
There are 0 RHSs before deduplication
There are 0 RHSs after deduplication
got 8 candidates from LHS

-------------------------------------------------
%0:i8 = var
%1:i32 = sext %0
%2:i32 = xor 4294967295:i32, %1
%3:i32 = and 1:i32, %2
%4:i8 = var
%5:i32 = sext %4
%6:i32 = and %3, %5
%7:i8 = var
%8:i32 = sext %7
%9:i32 = xor 4294967295:i32, %8
%10:i32 = and 1:i32, %9
%11:i8 = var
%12:i32 = sext %11
%13:i32 = and %10, %12
%14:i32 = or %6, %13
%15:i8 = trunc %14
infer %15


--------------------------------
guess 0

%0:i8 = var ; reservedconst_1

Cost = 0
first query is SAT, returning the model:
reservedconst_1: 0
0 th attempt: second query is SAT-- constant doesn't work
first query is SAT, returning the model:
reservedconst_1: 1
1 th attempt: second query is SAT-- constant doesn't work
first query is UNSAT-- no more guesses
Dataflow Pruned 0/0
There are 1 Guesses
There are 0 RHSs before deduplication
There are 0 RHSs after deduplication
got 1 candidates from LHS

-------------------------------------------------
%0:i8 = var
infer %0


--------------------------------
guess 0

%0:i8 = var ; reservedconst_1

Cost = 0
first query is SAT, returning the model:
reservedconst_1: 0
0 th attempt: second query is SAT-- constant doesn't work
first query is SAT, returning the model:
reservedconst_1: -1
1 th attempt: second query is SAT-- constant doesn't work
first query is UNSAT-- no more guesses
Dataflow Pruned 0/0
There are 1 Guesses
There are 0 RHSs before deduplication
There are 0 RHSs after deduplication
got 2 candidates from LHS

-------------------------------------------------
%0:i8 = var
%1:i32 = sext %0
infer %1 (demandedBits=00000000000000000000000011111111)


--------------------------------
guess 0

%0:i32 = var ; reservedconst_1

Cost = 0
first query is SAT, returning the model:
reservedconst_1: 0
0 th attempt: second query is SAT-- constant doesn't work
first query is SAT, returning the model:
reservedconst_1: -1
1 th attempt: second query is SAT-- constant doesn't work
first query is UNSAT-- no more guesses
Dataflow Pruned 0/0
There are 1 Guesses
There are 0 RHSs before deduplication
There are 0 RHSs after deduplication
got 5 candidates from LHS

-------------------------------------------------
%0:i8 = var
%1:i32 = sext %0
%2:i8 = var
%3:i32 = sext %2
%4:i32 = and %1, %3
infer %4 (demandedBits=00000000000000000000000011111111)


--------------------------------
guess 0

%0:i32 = var ; reservedconst_1

Cost = 0
first query is SAT, returning the model:
reservedconst_1: 127
0 th attempt: second query is SAT-- constant doesn't work
first query is SAT, returning the model:
reservedconst_1: 0
1 th attempt: second query is SAT-- constant doesn't work
first query is UNSAT-- no more guesses

--------------------------------
guess 1

%0:i8 = var
%1:i32 = sext %0

Cost = 1
second query is SAT-- constant doesn't work

--------------------------------
guess 2

%0:i8 = var
%1:i32 = sext %0

Cost = 1
second query is SAT-- constant doesn't work
Dataflow Pruned 0/0
There are 3 Guesses
There are 0 RHSs before deduplication
There are 0 RHSs after deduplication
got 6 candidates from LHS

-------------------------------------------------
%0:i8 = var
%1:i32 = sext %0
%2:i8 = var
%3:i32 = sext %2
%4:i32 = and %1, %3
%5:i8 = trunc %4
infer %5


--------------------------------
guess 0

%0:i8 = var ; reservedconst_1

Cost = 0
first query is SAT, returning the model:
reservedconst_1: 0
0 th attempt: second query is SAT-- constant doesn't work
first query is SAT, returning the model:
reservedconst_1: -1
1 th attempt: second query is SAT-- constant doesn't work
first query is UNSAT-- no more guesses

--------------------------------
guess 1

%0:i8 = var

Cost = 0
second query is SAT-- constant doesn't work

--------------------------------
guess 2

%0:i8 = var

Cost = 0
second query is SAT-- constant doesn't work
Dataflow Pruned 0/0
There are 3 Guesses
There are 0 RHSs before deduplication
There are 0 RHSs after deduplication
#########################################################
; exiting Souper's runOnFunction() for halfadder()

; entering Souper's runOnFunction() for fulladder()

; ModuleID = './Four_bit_adder.c.bc'
source_filename = "./Four_bit_adder.c"
target datalayout = "e-m:e-p:32:32-i64:64-n32:64-S128"
target triple = "wasm32-unknown-wasi"

@.str = private unnamed_addr constant [47 x i8] c"%d%d%d%d + %d%d%d%d = %d%d%d%d, overflow = %d\0A\00", align 1
@llvm.used = appending global [1 x i8*] [i8* bitcast (i32 ()* @__main_void to i8*)], section "llvm.metadata"

@__main_void = alias i32 (), i32 ()* @main

; Function Attrs: noinline nounwind optnone
define hidden void @halfadder(i8* %a, i8* %b, i8* %s, i8* %c) #0 {
entry:
  %a.addr = alloca i8*, align 4
  %b.addr = alloca i8*, align 4
  %s.addr = alloca i8*, align 4
  %c.addr = alloca i8*, align 4
  store i8* %a, i8** %a.addr, align 4
  store i8* %b, i8** %b.addr, align 4
  store i8* %s, i8** %s.addr, align 4
  store i8* %c, i8** %c.addr, align 4
  %0 = load i8*, i8** %a.addr, align 4
  %1 = load i8, i8* %0, align 1
  %conv = sext i8 %1 to i32
  %neg = xor i32 %conv, -1
  %and = and i32 %neg, 1
  %2 = load i8*, i8** %b.addr, align 4
  %3 = load i8, i8* %2, align 1
  %conv1 = sext i8 %3 to i32
  %and2 = and i32 %and, %conv1
  %4 = load i8*, i8** %a.addr, align 4
  %5 = load i8, i8* %4, align 1
  %conv3 = sext i8 %5 to i32
  %6 = load i8*, i8** %b.addr, align 4
  %7 = load i8, i8* %6, align 1
  %conv4 = sext i8 %7 to i32
  %neg5 = xor i32 %conv4, -1
  %and6 = and i32 %neg5, 1
  %and7 = and i32 %conv3, %and6
  %or = or i32 %and2, %and7
  %conv8 = trunc i32 %or to i8
  %8 = load i8*, i8** %s.addr, align 4
  store i8 %conv8, i8* %8, align 1
  %9 = load i8*, i8** %a.addr, align 4
  %10 = load i8, i8* %9, align 1
  %conv9 = sext i8 %10 to i32
  %11 = load i8*, i8** %b.addr, align 4
  %12 = load i8, i8* %11, align 1
  %conv10 = sext i8 %12 to i32
  %and11 = and i32 %conv9, %conv10
  %conv12 = trunc i32 %and11 to i8
  %13 = load i8*, i8** %c.addr, align 4
  store i8 %conv12, i8* %13, align 1
  ret void
}

; Function Attrs: noinline nounwind optnone
define hidden void @fulladder(i8* %a, i8* %b, i8* %ic, i8* %s, i8* %oc) #0 {
entry:
  %a.addr = alloca i8*, align 4
  %b.addr = alloca i8*, align 4
  %ic.addr = alloca i8*, align 4
  %s.addr = alloca i8*, align 4
  %oc.addr = alloca i8*, align 4
  %_ps = alloca i8, align 1
  %ps = alloca i8*, align 4
  %_pc = alloca i8, align 1
  %pc = alloca i8*, align 4
  %_tc = alloca i8, align 1
  %tc = alloca i8*, align 4
  store i8* %a, i8** %a.addr, align 4
  store i8* %b, i8** %b.addr, align 4
  store i8* %ic, i8** %ic.addr, align 4
  store i8* %s, i8** %s.addr, align 4
  store i8* %oc, i8** %oc.addr, align 4
  store i8* %_ps, i8** %ps, align 4
  store i8* %_pc, i8** %pc, align 4
  store i8* %_tc, i8** %tc, align 4
  %0 = load i8*, i8** %a.addr, align 4
  %1 = load i8*, i8** %b.addr, align 4
  %2 = load i8*, i8** %ps, align 4
  %3 = load i8*, i8** %pc, align 4
  call void @halfadder(i8* %0, i8* %1, i8* %2, i8* %3)
  %4 = load i8*, i8** %ps, align 4
  %5 = load i8*, i8** %ic.addr, align 4
  %6 = load i8*, i8** %s.addr, align 4
  %7 = load i8*, i8** %tc, align 4
  call void @halfadder(i8* %4, i8* %5, i8* %6, i8* %7)
  %8 = load i8*, i8** %tc, align 4
  %9 = load i8, i8* %8, align 1
  %conv = sext i8 %9 to i32
  %10 = load i8*, i8** %pc, align 4
  %11 = load i8, i8* %10, align 1
  %conv1 = sext i8 %11 to i32
  %or = or i32 %conv, %conv1
  %conv2 = trunc i32 %or to i8
  %12 = load i8*, i8** %oc.addr, align 4
  store i8 %conv2, i8* %12, align 1
  ret void
}

; Function Attrs: noinline nounwind optnone
define hidden void @fourbitsadder(i8* %a0, i8* %a1, i8* %a2, i8* %a3, i8* %b0, i8* %b1, i8* %b2, i8* %b3, i8* %o0, i8* %o1, i8* %o2, i8* %o3, i8* %overflow) #0 {
entry:
  %a0.addr = alloca i8*, align 4
  %a1.addr = alloca i8*, align 4
  %a2.addr = alloca i8*, align 4
  %a3.addr = alloca i8*, align 4
  %b0.addr = alloca i8*, align 4
  %b1.addr = alloca i8*, align 4
  %b2.addr = alloca i8*, align 4
  %b3.addr = alloca i8*, align 4
  %o0.addr = alloca i8*, align 4
  %o1.addr = alloca i8*, align 4
  %o2.addr = alloca i8*, align 4
  %o3.addr = alloca i8*, align 4
  %overflow.addr = alloca i8*, align 4
  %_zero = alloca i8, align 1
  %zero = alloca i8*, align 4
  %_tc0 = alloca i8, align 1
  %tc0 = alloca i8*, align 4
  %_tc1 = alloca i8, align 1
  %tc1 = alloca i8*, align 4
  %_tc2 = alloca i8, align 1
  %tc2 = alloca i8*, align 4
  store i8* %a0, i8** %a0.addr, align 4
  store i8* %a1, i8** %a1.addr, align 4
  store i8* %a2, i8** %a2.addr, align 4
  store i8* %a3, i8** %a3.addr, align 4
  store i8* %b0, i8** %b0.addr, align 4
  store i8* %b1, i8** %b1.addr, align 4
  store i8* %b2, i8** %b2.addr, align 4
  store i8* %b3, i8** %b3.addr, align 4
  store i8* %o0, i8** %o0.addr, align 4
  store i8* %o1, i8** %o1.addr, align 4
  store i8* %o2, i8** %o2.addr, align 4
  store i8* %o3, i8** %o3.addr, align 4
  store i8* %overflow, i8** %overflow.addr, align 4
  store i8* %_zero, i8** %zero, align 4
  %0 = load i8*, i8** %zero, align 4
  store i8 0, i8* %0, align 1
  store i8* %_tc0, i8** %tc0, align 4
  store i8* %_tc1, i8** %tc1, align 4
  store i8* %_tc2, i8** %tc2, align 4
  %1 = load i8*, i8** %a0.addr, align 4
  %2 = load i8*, i8** %b0.addr, align 4
  %3 = load i8*, i8** %zero, align 4
  %4 = load i8*, i8** %o0.addr, align 4
  %5 = load i8*, i8** %tc0, align 4
  call void @fulladder(i8* %1, i8* %2, i8* %3, i8* %4, i8* %5)
  %6 = load i8*, i8** %a1.addr, align 4
  %7 = load i8*, i8** %b1.addr, align 4
  %8 = load i8*, i8** %tc0, align 4
  %9 = load i8*, i8** %o1.addr, align 4
  %10 = load i8*, i8** %tc1, align 4
  call void @fulladder(i8* %6, i8* %7, i8* %8, i8* %9, i8* %10)
  %11 = load i8*, i8** %a2.addr, align 4
  %12 = load i8*, i8** %b2.addr, align 4
  %13 = load i8*, i8** %tc1, align 4
  %14 = load i8*, i8** %o2.addr, align 4
  %15 = load i8*, i8** %tc2, align 4
  call void @fulladder(i8* %11, i8* %12, i8* %13, i8* %14, i8* %15)
  %16 = load i8*, i8** %a3.addr, align 4
  %17 = load i8*, i8** %b3.addr, align 4
  %18 = load i8*, i8** %tc2, align 4
  %19 = load i8*, i8** %o3.addr, align 4
  %20 = load i8*, i8** %overflow.addr, align 4
  call void @fulladder(i8* %16, i8* %17, i8* %18, i8* %19, i8* %20)
  ret void
}

; Function Attrs: noinline nounwind optnone
define hidden i32 @main() #0 {
entry:
  %retval = alloca i32, align 4
  %_a0 = alloca i8, align 1
  %a0 = alloca i8*, align 4
  %_a1 = alloca i8, align 1
  %a1 = alloca i8*, align 4
  %_a2 = alloca i8, align 1
  %a2 = alloca i8*, align 4
  %_a3 = alloca i8, align 1
  %a3 = alloca i8*, align 4
  %_b0 = alloca i8, align 1
  %b0 = alloca i8*, align 4
  %_b1 = alloca i8, align 1
  %b1 = alloca i8*, align 4
  %_b2 = alloca i8, align 1
  %b2 = alloca i8*, align 4
  %_b3 = alloca i8, align 1
  %b3 = alloca i8*, align 4
  %_s0 = alloca i8, align 1
  %s0 = alloca i8*, align 4
  %_s1 = alloca i8, align 1
  %s1 = alloca i8*, align 4
  %_s2 = alloca i8, align 1
  %s2 = alloca i8*, align 4
  %_s3 = alloca i8, align 1
  %s3 = alloca i8*, align 4
  %_overflow = alloca i8, align 1
  %overflow = alloca i8*, align 4
  store i32 0, i32* %retval, align 4
  store i8* %_a0, i8** %a0, align 4
  store i8* %_a1, i8** %a1, align 4
  store i8* %_a2, i8** %a2, align 4
  store i8* %_a3, i8** %a3, align 4
  store i8* %_b0, i8** %b0, align 4
  store i8* %_b1, i8** %b1, align 4
  store i8* %_b2, i8** %b2, align 4
  store i8* %_b3, i8** %b3, align 4
  store i8* %_s0, i8** %s0, align 4
  store i8* %_s1, i8** %s1, align 4
  store i8* %_s2, i8** %s2, align 4
  store i8* %_s3, i8** %s3, align 4
  store i8* %_overflow, i8** %overflow, align 4
  %0 = load i8*, i8** %a3, align 4
  store i8 0, i8* %0, align 1
  %1 = load i8*, i8** %b3, align 4
  store i8 1, i8* %1, align 1
  %2 = load i8*, i8** %a2, align 4
  store i8 0, i8* %2, align 1
  %3 = load i8*, i8** %b2, align 4
  store i8 1, i8* %3, align 1
  %4 = load i8*, i8** %a1, align 4
  store i8 1, i8* %4, align 1
  %5 = load i8*, i8** %b1, align 4
  store i8 1, i8* %5, align 1
  %6 = load i8*, i8** %a0, align 4
  store i8 0, i8* %6, align 1
  %7 = load i8*, i8** %b0, align 4
  store i8 0, i8* %7, align 1
  %8 = load i8*, i8** %a0, align 4
  %9 = load i8*, i8** %a1, align 4
  %10 = load i8*, i8** %a2, align 4
  %11 = load i8*, i8** %a3, align 4
  %12 = load i8*, i8** %b0, align 4
  %13 = load i8*, i8** %b1, align 4
  %14 = load i8*, i8** %b2, align 4
  %15 = load i8*, i8** %b3, align 4
  %16 = load i8*, i8** %s0, align 4
  %17 = load i8*, i8** %s1, align 4
  %18 = load i8*, i8** %s2, align 4
  %19 = load i8*, i8** %s3, align 4
  %20 = load i8*, i8** %overflow, align 4
  call void @fourbitsadder(i8* %8, i8* %9, i8* %10, i8* %11, i8* %12, i8* %13, i8* %14, i8* %15, i8* %16, i8* %17, i8* %18, i8* %19, i8* %20)
  %21 = load i8*, i8** %a3, align 4
  %22 = load i8, i8* %21, align 1
  %conv = sext i8 %22 to i32
  %23 = load i8*, i8** %a2, align 4
  %24 = load i8, i8* %23, align 1
  %conv1 = sext i8 %24 to i32
  %25 = load i8*, i8** %a1, align 4
  %26 = load i8, i8* %25, align 1
  %conv2 = sext i8 %26 to i32
  %27 = load i8*, i8** %a0, align 4
  %28 = load i8, i8* %27, align 1
  %conv3 = sext i8 %28 to i32
  %29 = load i8*, i8** %b3, align 4
  %30 = load i8, i8* %29, align 1
  %conv4 = sext i8 %30 to i32
  %31 = load i8*, i8** %b2, align 4
  %32 = load i8, i8* %31, align 1
  %conv5 = sext i8 %32 to i32
  %33 = load i8*, i8** %b1, align 4
  %34 = load i8, i8* %33, align 1
  %conv6 = sext i8 %34 to i32
  %35 = load i8*, i8** %b0, align 4
  %36 = load i8, i8* %35, align 1
  %conv7 = sext i8 %36 to i32
  %37 = load i8*, i8** %s3, align 4
  %38 = load i8, i8* %37, align 1
  %conv8 = sext i8 %38 to i32
  %39 = load i8*, i8** %s2, align 4
  %40 = load i8, i8* %39, align 1
  %conv9 = sext i8 %40 to i32
  %41 = load i8*, i8** %s1, align 4
  %42 = load i8, i8* %41, align 1
  %conv10 = sext i8 %42 to i32
  %43 = load i8*, i8** %s0, align 4
  %44 = load i8, i8* %43, align 1
  %conv11 = sext i8 %44 to i32
  %45 = load i8*, i8** %overflow, align 4
  %46 = load i8, i8* %45, align 1
  %conv12 = sext i8 %46 to i32
  %call = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([47 x i8], [47 x i8]* @.str, i32 0, i32 0), i32 %conv, i32 %conv1, i32 %conv2, i32 %conv3, i32 %conv4, i32 %conv5, i32 %conv6, i32 %conv7, i32 %conv8, i32 %conv9, i32 %conv10, i32 %conv11, i32 %conv12)
  ret i32 0
}

declare i32 @printf(i8* %0, ...) #1

attributes #0 = { noinline nounwind optnone "correctly-rounded-divide-sqrt-fp-math"="false" "disable-tail-calls"="false" "frame-pointer"="none" "less-precise-fpmad"="false" "min-legal-vector-width"="0" "no-infs-fp-math"="false" "no-jump-tables"="false" "no-nans-fp-math"="false" "no-signed-zeros-fp-math"="false" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="generic" "unsafe-fp-math"="false" "use-soft-float"="false" }
attributes #1 = { "correctly-rounded-divide-sqrt-fp-math"="false" "disable-tail-calls"="false" "frame-pointer"="none" "less-precise-fpmad"="false" "no-infs-fp-math"="false" "no-nans-fp-math"="false" "no-signed-zeros-fp-math"="false" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="generic" "unsafe-fp-math"="false" "use-soft-float"="false" }

!llvm.module.flags = !{!0}
!llvm.ident = !{!1}

!0 = !{i32 1, !"wchar_size", i32 4}
!1 = !{!"clang version 11.0.0 (https://github.com/Jacarte/llvm-project.git 0f6dea67136cc1e0b3d200eb2bb165628970c44b)"}

; extracted candidates

; *****
; For LLVM instruction:
;  %9 = load i8, i8* %8, align 1
; Looking for a replacement for:
%0:i8 = var
infer %0

; *****
; For LLVM instruction:
;  %conv = sext i8 %9 to i32
; Looking for a replacement for:
%0:i8 = var
%1:i32 = sext %0
infer %1 (demandedBits=00000000000000000000000011111111)

; *****
; For LLVM instruction:
;  %11 = load i8, i8* %10, align 1
; Looking for a replacement for:
%0:i8 = var
infer %0

; *****
; For LLVM instruction:
;  %conv1 = sext i8 %11 to i32
; Looking for a replacement for:
%0:i8 = var
%1:i32 = sext %0
infer %1 (demandedBits=00000000000000000000000011111111)

; *****
; For LLVM instruction:
;  %or = or i32 %conv, %conv1
; Looking for a replacement for:
%0:i8 = var
%1:i32 = sext %0
%2:i8 = var
%3:i32 = sext %2
%4:i32 = or %1, %3
infer %4 (demandedBits=00000000000000000000000011111111)

; *****
; For LLVM instruction:
;  %conv2 = trunc i32 %or to i8
; Looking for a replacement for:
%0:i8 = var
%1:i32 = sext %0
%2:i8 = var
%3:i32 = sext %2
%4:i32 = or %1, %3
%5:i8 = trunc %4
infer %5
got 5 candidates from LHS

-------------------------------------------------
%0:i8 = var
%1:i32 = sext %0
%2:i8 = var
%3:i32 = sext %2
%4:i32 = or %1, %3
infer %4 (demandedBits=00000000000000000000000011111111)


--------------------------------
guess 0

%0:i32 = var ; reservedconst_1

Cost = 0
first query is SAT, returning the model:
reservedconst_1: 0
0 th attempt: second query is SAT-- constant doesn't work
first query is SAT, returning the model:
reservedconst_1: -1
1 th attempt: second query is SAT-- constant doesn't work
first query is UNSAT-- no more guesses

--------------------------------
guess 1

%0:i8 = var
%1:i32 = sext %0

Cost = 1
second query is SAT-- constant doesn't work

--------------------------------
guess 2

%0:i8 = var
%1:i32 = sext %0

Cost = 1
second query is SAT-- constant doesn't work
Dataflow Pruned 0/0
There are 3 Guesses
There are 0 RHSs before deduplication
There are 0 RHSs after deduplication
got 6 candidates from LHS

-------------------------------------------------
%0:i8 = var
%1:i32 = sext %0
%2:i8 = var
%3:i32 = sext %2
%4:i32 = or %1, %3
%5:i8 = trunc %4
infer %5


--------------------------------
guess 0

%0:i8 = var ; reservedconst_1

Cost = 0
first query is SAT, returning the model:
reservedconst_1: 0
0 th attempt: second query is SAT-- constant doesn't work
first query is SAT, returning the model:
reservedconst_1: -1
1 th attempt: second query is SAT-- constant doesn't work
first query is UNSAT-- no more guesses

--------------------------------
guess 1

%0:i8 = var

Cost = 0
second query is SAT-- constant doesn't work

--------------------------------
guess 2

%0:i8 = var

Cost = 0
second query is SAT-- constant doesn't work
Dataflow Pruned 0/0
There are 3 Guesses
There are 0 RHSs before deduplication
There are 0 RHSs after deduplication
#########################################################
; exiting Souper's runOnFunction() for fulladder()

; entering Souper's runOnFunction() for fourbitsadder()

; ModuleID = './Four_bit_adder.c.bc'
source_filename = "./Four_bit_adder.c"
target datalayout = "e-m:e-p:32:32-i64:64-n32:64-S128"
target triple = "wasm32-unknown-wasi"

@.str = private unnamed_addr constant [47 x i8] c"%d%d%d%d + %d%d%d%d = %d%d%d%d, overflow = %d\0A\00", align 1
@llvm.used = appending global [1 x i8*] [i8* bitcast (i32 ()* @__main_void to i8*)], section "llvm.metadata"

@__main_void = alias i32 (), i32 ()* @main

; Function Attrs: noinline nounwind optnone
define hidden void @halfadder(i8* %a, i8* %b, i8* %s, i8* %c) #0 {
entry:
  %a.addr = alloca i8*, align 4
  %b.addr = alloca i8*, align 4
  %s.addr = alloca i8*, align 4
  %c.addr = alloca i8*, align 4
  store i8* %a, i8** %a.addr, align 4
  store i8* %b, i8** %b.addr, align 4
  store i8* %s, i8** %s.addr, align 4
  store i8* %c, i8** %c.addr, align 4
  %0 = load i8*, i8** %a.addr, align 4
  %1 = load i8, i8* %0, align 1
  %conv = sext i8 %1 to i32
  %neg = xor i32 %conv, -1
  %and = and i32 %neg, 1
  %2 = load i8*, i8** %b.addr, align 4
  %3 = load i8, i8* %2, align 1
  %conv1 = sext i8 %3 to i32
  %and2 = and i32 %and, %conv1
  %4 = load i8*, i8** %a.addr, align 4
  %5 = load i8, i8* %4, align 1
  %conv3 = sext i8 %5 to i32
  %6 = load i8*, i8** %b.addr, align 4
  %7 = load i8, i8* %6, align 1
  %conv4 = sext i8 %7 to i32
  %neg5 = xor i32 %conv4, -1
  %and6 = and i32 %neg5, 1
  %and7 = and i32 %conv3, %and6
  %or = or i32 %and2, %and7
  %conv8 = trunc i32 %or to i8
  %8 = load i8*, i8** %s.addr, align 4
  store i8 %conv8, i8* %8, align 1
  %9 = load i8*, i8** %a.addr, align 4
  %10 = load i8, i8* %9, align 1
  %conv9 = sext i8 %10 to i32
  %11 = load i8*, i8** %b.addr, align 4
  %12 = load i8, i8* %11, align 1
  %conv10 = sext i8 %12 to i32
  %and11 = and i32 %conv9, %conv10
  %conv12 = trunc i32 %and11 to i8
  %13 = load i8*, i8** %c.addr, align 4
  store i8 %conv12, i8* %13, align 1
  ret void
}

; Function Attrs: noinline nounwind optnone
define hidden void @fulladder(i8* %a, i8* %b, i8* %ic, i8* %s, i8* %oc) #0 {
entry:
  %a.addr = alloca i8*, align 4
  %b.addr = alloca i8*, align 4
  %ic.addr = alloca i8*, align 4
  %s.addr = alloca i8*, align 4
  %oc.addr = alloca i8*, align 4
  %_ps = alloca i8, align 1
  %ps = alloca i8*, align 4
  %_pc = alloca i8, align 1
  %pc = alloca i8*, align 4
  %_tc = alloca i8, align 1
  %tc = alloca i8*, align 4
  store i8* %a, i8** %a.addr, align 4
  store i8* %b, i8** %b.addr, align 4
  store i8* %ic, i8** %ic.addr, align 4
  store i8* %s, i8** %s.addr, align 4
  store i8* %oc, i8** %oc.addr, align 4
  store i8* %_ps, i8** %ps, align 4
  store i8* %_pc, i8** %pc, align 4
  store i8* %_tc, i8** %tc, align 4
  %0 = load i8*, i8** %a.addr, align 4
  %1 = load i8*, i8** %b.addr, align 4
  %2 = load i8*, i8** %ps, align 4
  %3 = load i8*, i8** %pc, align 4
  call void @halfadder(i8* %0, i8* %1, i8* %2, i8* %3)
  %4 = load i8*, i8** %ps, align 4
  %5 = load i8*, i8** %ic.addr, align 4
  %6 = load i8*, i8** %s.addr, align 4
  %7 = load i8*, i8** %tc, align 4
  call void @halfadder(i8* %4, i8* %5, i8* %6, i8* %7)
  %8 = load i8*, i8** %tc, align 4
  %9 = load i8, i8* %8, align 1
  %conv = sext i8 %9 to i32
  %10 = load i8*, i8** %pc, align 4
  %11 = load i8, i8* %10, align 1
  %conv1 = sext i8 %11 to i32
  %or = or i32 %conv, %conv1
  %conv2 = trunc i32 %or to i8
  %12 = load i8*, i8** %oc.addr, align 4
  store i8 %conv2, i8* %12, align 1
  ret void
}

; Function Attrs: noinline nounwind optnone
define hidden void @fourbitsadder(i8* %a0, i8* %a1, i8* %a2, i8* %a3, i8* %b0, i8* %b1, i8* %b2, i8* %b3, i8* %o0, i8* %o1, i8* %o2, i8* %o3, i8* %overflow) #0 {
entry:
  %a0.addr = alloca i8*, align 4
  %a1.addr = alloca i8*, align 4
  %a2.addr = alloca i8*, align 4
  %a3.addr = alloca i8*, align 4
  %b0.addr = alloca i8*, align 4
  %b1.addr = alloca i8*, align 4
  %b2.addr = alloca i8*, align 4
  %b3.addr = alloca i8*, align 4
  %o0.addr = alloca i8*, align 4
  %o1.addr = alloca i8*, align 4
  %o2.addr = alloca i8*, align 4
  %o3.addr = alloca i8*, align 4
  %overflow.addr = alloca i8*, align 4
  %_zero = alloca i8, align 1
  %zero = alloca i8*, align 4
  %_tc0 = alloca i8, align 1
  %tc0 = alloca i8*, align 4
  %_tc1 = alloca i8, align 1
  %tc1 = alloca i8*, align 4
  %_tc2 = alloca i8, align 1
  %tc2 = alloca i8*, align 4
  store i8* %a0, i8** %a0.addr, align 4
  store i8* %a1, i8** %a1.addr, align 4
  store i8* %a2, i8** %a2.addr, align 4
  store i8* %a3, i8** %a3.addr, align 4
  store i8* %b0, i8** %b0.addr, align 4
  store i8* %b1, i8** %b1.addr, align 4
  store i8* %b2, i8** %b2.addr, align 4
  store i8* %b3, i8** %b3.addr, align 4
  store i8* %o0, i8** %o0.addr, align 4
  store i8* %o1, i8** %o1.addr, align 4
  store i8* %o2, i8** %o2.addr, align 4
  store i8* %o3, i8** %o3.addr, align 4
  store i8* %overflow, i8** %overflow.addr, align 4
  store i8* %_zero, i8** %zero, align 4
  %0 = load i8*, i8** %zero, align 4
  store i8 0, i8* %0, align 1
  store i8* %_tc0, i8** %tc0, align 4
  store i8* %_tc1, i8** %tc1, align 4
  store i8* %_tc2, i8** %tc2, align 4
  %1 = load i8*, i8** %a0.addr, align 4
  %2 = load i8*, i8** %b0.addr, align 4
  %3 = load i8*, i8** %zero, align 4
  %4 = load i8*, i8** %o0.addr, align 4
  %5 = load i8*, i8** %tc0, align 4
  call void @fulladder(i8* %1, i8* %2, i8* %3, i8* %4, i8* %5)
  %6 = load i8*, i8** %a1.addr, align 4
  %7 = load i8*, i8** %b1.addr, align 4
  %8 = load i8*, i8** %tc0, align 4
  %9 = load i8*, i8** %o1.addr, align 4
  %10 = load i8*, i8** %tc1, align 4
  call void @fulladder(i8* %6, i8* %7, i8* %8, i8* %9, i8* %10)
  %11 = load i8*, i8** %a2.addr, align 4
  %12 = load i8*, i8** %b2.addr, align 4
  %13 = load i8*, i8** %tc1, align 4
  %14 = load i8*, i8** %o2.addr, align 4
  %15 = load i8*, i8** %tc2, align 4
  call void @fulladder(i8* %11, i8* %12, i8* %13, i8* %14, i8* %15)
  %16 = load i8*, i8** %a3.addr, align 4
  %17 = load i8*, i8** %b3.addr, align 4
  %18 = load i8*, i8** %tc2, align 4
  %19 = load i8*, i8** %o3.addr, align 4
  %20 = load i8*, i8** %overflow.addr, align 4
  call void @fulladder(i8* %16, i8* %17, i8* %18, i8* %19, i8* %20)
  ret void
}

; Function Attrs: noinline nounwind optnone
define hidden i32 @main() #0 {
entry:
  %retval = alloca i32, align 4
  %_a0 = alloca i8, align 1
  %a0 = alloca i8*, align 4
  %_a1 = alloca i8, align 1
  %a1 = alloca i8*, align 4
  %_a2 = alloca i8, align 1
  %a2 = alloca i8*, align 4
  %_a3 = alloca i8, align 1
  %a3 = alloca i8*, align 4
  %_b0 = alloca i8, align 1
  %b0 = alloca i8*, align 4
  %_b1 = alloca i8, align 1
  %b1 = alloca i8*, align 4
  %_b2 = alloca i8, align 1
  %b2 = alloca i8*, align 4
  %_b3 = alloca i8, align 1
  %b3 = alloca i8*, align 4
  %_s0 = alloca i8, align 1
  %s0 = alloca i8*, align 4
  %_s1 = alloca i8, align 1
  %s1 = alloca i8*, align 4
  %_s2 = alloca i8, align 1
  %s2 = alloca i8*, align 4
  %_s3 = alloca i8, align 1
  %s3 = alloca i8*, align 4
  %_overflow = alloca i8, align 1
  %overflow = alloca i8*, align 4
  store i32 0, i32* %retval, align 4
  store i8* %_a0, i8** %a0, align 4
  store i8* %_a1, i8** %a1, align 4
  store i8* %_a2, i8** %a2, align 4
  store i8* %_a3, i8** %a3, align 4
  store i8* %_b0, i8** %b0, align 4
  store i8* %_b1, i8** %b1, align 4
  store i8* %_b2, i8** %b2, align 4
  store i8* %_b3, i8** %b3, align 4
  store i8* %_s0, i8** %s0, align 4
  store i8* %_s1, i8** %s1, align 4
  store i8* %_s2, i8** %s2, align 4
  store i8* %_s3, i8** %s3, align 4
  store i8* %_overflow, i8** %overflow, align 4
  %0 = load i8*, i8** %a3, align 4
  store i8 0, i8* %0, align 1
  %1 = load i8*, i8** %b3, align 4
  store i8 1, i8* %1, align 1
  %2 = load i8*, i8** %a2, align 4
  store i8 0, i8* %2, align 1
  %3 = load i8*, i8** %b2, align 4
  store i8 1, i8* %3, align 1
  %4 = load i8*, i8** %a1, align 4
  store i8 1, i8* %4, align 1
  %5 = load i8*, i8** %b1, align 4
  store i8 1, i8* %5, align 1
  %6 = load i8*, i8** %a0, align 4
  store i8 0, i8* %6, align 1
  %7 = load i8*, i8** %b0, align 4
  store i8 0, i8* %7, align 1
  %8 = load i8*, i8** %a0, align 4
  %9 = load i8*, i8** %a1, align 4
  %10 = load i8*, i8** %a2, align 4
  %11 = load i8*, i8** %a3, align 4
  %12 = load i8*, i8** %b0, align 4
  %13 = load i8*, i8** %b1, align 4
  %14 = load i8*, i8** %b2, align 4
  %15 = load i8*, i8** %b3, align 4
  %16 = load i8*, i8** %s0, align 4
  %17 = load i8*, i8** %s1, align 4
  %18 = load i8*, i8** %s2, align 4
  %19 = load i8*, i8** %s3, align 4
  %20 = load i8*, i8** %overflow, align 4
  call void @fourbitsadder(i8* %8, i8* %9, i8* %10, i8* %11, i8* %12, i8* %13, i8* %14, i8* %15, i8* %16, i8* %17, i8* %18, i8* %19, i8* %20)
  %21 = load i8*, i8** %a3, align 4
  %22 = load i8, i8* %21, align 1
  %conv = sext i8 %22 to i32
  %23 = load i8*, i8** %a2, align 4
  %24 = load i8, i8* %23, align 1
  %conv1 = sext i8 %24 to i32
  %25 = load i8*, i8** %a1, align 4
  %26 = load i8, i8* %25, align 1
  %conv2 = sext i8 %26 to i32
  %27 = load i8*, i8** %a0, align 4
  %28 = load i8, i8* %27, align 1
  %conv3 = sext i8 %28 to i32
  %29 = load i8*, i8** %b3, align 4
  %30 = load i8, i8* %29, align 1
  %conv4 = sext i8 %30 to i32
  %31 = load i8*, i8** %b2, align 4
  %32 = load i8, i8* %31, align 1
  %conv5 = sext i8 %32 to i32
  %33 = load i8*, i8** %b1, align 4
  %34 = load i8, i8* %33, align 1
  %conv6 = sext i8 %34 to i32
  %35 = load i8*, i8** %b0, align 4
  %36 = load i8, i8* %35, align 1
  %conv7 = sext i8 %36 to i32
  %37 = load i8*, i8** %s3, align 4
  %38 = load i8, i8* %37, align 1
  %conv8 = sext i8 %38 to i32
  %39 = load i8*, i8** %s2, align 4
  %40 = load i8, i8* %39, align 1
  %conv9 = sext i8 %40 to i32
  %41 = load i8*, i8** %s1, align 4
  %42 = load i8, i8* %41, align 1
  %conv10 = sext i8 %42 to i32
  %43 = load i8*, i8** %s0, align 4
  %44 = load i8, i8* %43, align 1
  %conv11 = sext i8 %44 to i32
  %45 = load i8*, i8** %overflow, align 4
  %46 = load i8, i8* %45, align 1
  %conv12 = sext i8 %46 to i32
  %call = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([47 x i8], [47 x i8]* @.str, i32 0, i32 0), i32 %conv, i32 %conv1, i32 %conv2, i32 %conv3, i32 %conv4, i32 %conv5, i32 %conv6, i32 %conv7, i32 %conv8, i32 %conv9, i32 %conv10, i32 %conv11, i32 %conv12)
  ret i32 0
}

declare i32 @printf(i8* %0, ...) #1

attributes #0 = { noinline nounwind optnone "correctly-rounded-divide-sqrt-fp-math"="false" "disable-tail-calls"="false" "frame-pointer"="none" "less-precise-fpmad"="false" "min-legal-vector-width"="0" "no-infs-fp-math"="false" "no-jump-tables"="false" "no-nans-fp-math"="false" "no-signed-zeros-fp-math"="false" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="generic" "unsafe-fp-math"="false" "use-soft-float"="false" }
attributes #1 = { "correctly-rounded-divide-sqrt-fp-math"="false" "disable-tail-calls"="false" "frame-pointer"="none" "less-precise-fpmad"="false" "no-infs-fp-math"="false" "no-nans-fp-math"="false" "no-signed-zeros-fp-math"="false" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="generic" "unsafe-fp-math"="false" "use-soft-float"="false" }

!llvm.module.flags = !{!0}
!llvm.ident = !{!1}

!0 = !{i32 1, !"wchar_size", i32 4}
!1 = !{!"clang version 11.0.0 (https://github.com/Jacarte/llvm-project.git 0f6dea67136cc1e0b3d200eb2bb165628970c44b)"}

; extracted candidates
#########################################################
; exiting Souper's runOnFunction() for fourbitsadder()

; entering Souper's runOnFunction() for main()

; ModuleID = './Four_bit_adder.c.bc'
source_filename = "./Four_bit_adder.c"
target datalayout = "e-m:e-p:32:32-i64:64-n32:64-S128"
target triple = "wasm32-unknown-wasi"

@.str = private unnamed_addr constant [47 x i8] c"%d%d%d%d + %d%d%d%d = %d%d%d%d, overflow = %d\0A\00", align 1
@llvm.used = appending global [1 x i8*] [i8* bitcast (i32 ()* @__main_void to i8*)], section "llvm.metadata"

@__main_void = alias i32 (), i32 ()* @main

; Function Attrs: noinline nounwind optnone
define hidden void @halfadder(i8* %a, i8* %b, i8* %s, i8* %c) #0 {
entry:
  %a.addr = alloca i8*, align 4
  %b.addr = alloca i8*, align 4
  %s.addr = alloca i8*, align 4
  %c.addr = alloca i8*, align 4
  store i8* %a, i8** %a.addr, align 4
  store i8* %b, i8** %b.addr, align 4
  store i8* %s, i8** %s.addr, align 4
  store i8* %c, i8** %c.addr, align 4
  %0 = load i8*, i8** %a.addr, align 4
  %1 = load i8, i8* %0, align 1
  %conv = sext i8 %1 to i32
  %neg = xor i32 %conv, -1
  %and = and i32 %neg, 1
  %2 = load i8*, i8** %b.addr, align 4
  %3 = load i8, i8* %2, align 1
  %conv1 = sext i8 %3 to i32
  %and2 = and i32 %and, %conv1
  %4 = load i8*, i8** %a.addr, align 4
  %5 = load i8, i8* %4, align 1
  %conv3 = sext i8 %5 to i32
  %6 = load i8*, i8** %b.addr, align 4
  %7 = load i8, i8* %6, align 1
  %conv4 = sext i8 %7 to i32
  %neg5 = xor i32 %conv4, -1
  %and6 = and i32 %neg5, 1
  %and7 = and i32 %conv3, %and6
  %or = or i32 %and2, %and7
  %conv8 = trunc i32 %or to i8
  %8 = load i8*, i8** %s.addr, align 4
  store i8 %conv8, i8* %8, align 1
  %9 = load i8*, i8** %a.addr, align 4
  %10 = load i8, i8* %9, align 1
  %conv9 = sext i8 %10 to i32
  %11 = load i8*, i8** %b.addr, align 4
  %12 = load i8, i8* %11, align 1
  %conv10 = sext i8 %12 to i32
  %and11 = and i32 %conv9, %conv10
  %conv12 = trunc i32 %and11 to i8
  %13 = load i8*, i8** %c.addr, align 4
  store i8 %conv12, i8* %13, align 1
  ret void
}

; Function Attrs: noinline nounwind optnone
define hidden void @fulladder(i8* %a, i8* %b, i8* %ic, i8* %s, i8* %oc) #0 {
entry:
  %a.addr = alloca i8*, align 4
  %b.addr = alloca i8*, align 4
  %ic.addr = alloca i8*, align 4
  %s.addr = alloca i8*, align 4
  %oc.addr = alloca i8*, align 4
  %_ps = alloca i8, align 1
  %ps = alloca i8*, align 4
  %_pc = alloca i8, align 1
  %pc = alloca i8*, align 4
  %_tc = alloca i8, align 1
  %tc = alloca i8*, align 4
  store i8* %a, i8** %a.addr, align 4
  store i8* %b, i8** %b.addr, align 4
  store i8* %ic, i8** %ic.addr, align 4
  store i8* %s, i8** %s.addr, align 4
  store i8* %oc, i8** %oc.addr, align 4
  store i8* %_ps, i8** %ps, align 4
  store i8* %_pc, i8** %pc, align 4
  store i8* %_tc, i8** %tc, align 4
  %0 = load i8*, i8** %a.addr, align 4
  %1 = load i8*, i8** %b.addr, align 4
  %2 = load i8*, i8** %ps, align 4
  %3 = load i8*, i8** %pc, align 4
  call void @halfadder(i8* %0, i8* %1, i8* %2, i8* %3)
  %4 = load i8*, i8** %ps, align 4
  %5 = load i8*, i8** %ic.addr, align 4
  %6 = load i8*, i8** %s.addr, align 4
  %7 = load i8*, i8** %tc, align 4
  call void @halfadder(i8* %4, i8* %5, i8* %6, i8* %7)
  %8 = load i8*, i8** %tc, align 4
  %9 = load i8, i8* %8, align 1
  %conv = sext i8 %9 to i32
  %10 = load i8*, i8** %pc, align 4
  %11 = load i8, i8* %10, align 1
  %conv1 = sext i8 %11 to i32
  %or = or i32 %conv, %conv1
  %conv2 = trunc i32 %or to i8
  %12 = load i8*, i8** %oc.addr, align 4
  store i8 %conv2, i8* %12, align 1
  ret void
}

; Function Attrs: noinline nounwind optnone
define hidden void @fourbitsadder(i8* %a0, i8* %a1, i8* %a2, i8* %a3, i8* %b0, i8* %b1, i8* %b2, i8* %b3, i8* %o0, i8* %o1, i8* %o2, i8* %o3, i8* %overflow) #0 {
entry:
  %a0.addr = alloca i8*, align 4
  %a1.addr = alloca i8*, align 4
  %a2.addr = alloca i8*, align 4
  %a3.addr = alloca i8*, align 4
  %b0.addr = alloca i8*, align 4
  %b1.addr = alloca i8*, align 4
  %b2.addr = alloca i8*, align 4
  %b3.addr = alloca i8*, align 4
  %o0.addr = alloca i8*, align 4
  %o1.addr = alloca i8*, align 4
  %o2.addr = alloca i8*, align 4
  %o3.addr = alloca i8*, align 4
  %overflow.addr = alloca i8*, align 4
  %_zero = alloca i8, align 1
  %zero = alloca i8*, align 4
  %_tc0 = alloca i8, align 1
  %tc0 = alloca i8*, align 4
  %_tc1 = alloca i8, align 1
  %tc1 = alloca i8*, align 4
  %_tc2 = alloca i8, align 1
  %tc2 = alloca i8*, align 4
  store i8* %a0, i8** %a0.addr, align 4
  store i8* %a1, i8** %a1.addr, align 4
  store i8* %a2, i8** %a2.addr, align 4
  store i8* %a3, i8** %a3.addr, align 4
  store i8* %b0, i8** %b0.addr, align 4
  store i8* %b1, i8** %b1.addr, align 4
  store i8* %b2, i8** %b2.addr, align 4
  store i8* %b3, i8** %b3.addr, align 4
  store i8* %o0, i8** %o0.addr, align 4
  store i8* %o1, i8** %o1.addr, align 4
  store i8* %o2, i8** %o2.addr, align 4
  store i8* %o3, i8** %o3.addr, align 4
  store i8* %overflow, i8** %overflow.addr, align 4
  store i8* %_zero, i8** %zero, align 4
  %0 = load i8*, i8** %zero, align 4
  store i8 0, i8* %0, align 1
  store i8* %_tc0, i8** %tc0, align 4
  store i8* %_tc1, i8** %tc1, align 4
  store i8* %_tc2, i8** %tc2, align 4
  %1 = load i8*, i8** %a0.addr, align 4
  %2 = load i8*, i8** %b0.addr, align 4
  %3 = load i8*, i8** %zero, align 4
  %4 = load i8*, i8** %o0.addr, align 4
  %5 = load i8*, i8** %tc0, align 4
  call void @fulladder(i8* %1, i8* %2, i8* %3, i8* %4, i8* %5)
  %6 = load i8*, i8** %a1.addr, align 4
  %7 = load i8*, i8** %b1.addr, align 4
  %8 = load i8*, i8** %tc0, align 4
  %9 = load i8*, i8** %o1.addr, align 4
  %10 = load i8*, i8** %tc1, align 4
  call void @fulladder(i8* %6, i8* %7, i8* %8, i8* %9, i8* %10)
  %11 = load i8*, i8** %a2.addr, align 4
  %12 = load i8*, i8** %b2.addr, align 4
  %13 = load i8*, i8** %tc1, align 4
  %14 = load i8*, i8** %o2.addr, align 4
  %15 = load i8*, i8** %tc2, align 4
  call void @fulladder(i8* %11, i8* %12, i8* %13, i8* %14, i8* %15)
  %16 = load i8*, i8** %a3.addr, align 4
  %17 = load i8*, i8** %b3.addr, align 4
  %18 = load i8*, i8** %tc2, align 4
  %19 = load i8*, i8** %o3.addr, align 4
  %20 = load i8*, i8** %overflow.addr, align 4
  call void @fulladder(i8* %16, i8* %17, i8* %18, i8* %19, i8* %20)
  ret void
}

; Function Attrs: noinline nounwind optnone
define hidden i32 @main() #0 {
entry:
  %retval = alloca i32, align 4
  %_a0 = alloca i8, align 1
  %a0 = alloca i8*, align 4
  %_a1 = alloca i8, align 1
  %a1 = alloca i8*, align 4
  %_a2 = alloca i8, align 1
  %a2 = alloca i8*, align 4
  %_a3 = alloca i8, align 1
  %a3 = alloca i8*, align 4
  %_b0 = alloca i8, align 1
  %b0 = alloca i8*, align 4
  %_b1 = alloca i8, align 1
  %b1 = alloca i8*, align 4
  %_b2 = alloca i8, align 1
  %b2 = alloca i8*, align 4
  %_b3 = alloca i8, align 1
  %b3 = alloca i8*, align 4
  %_s0 = alloca i8, align 1
  %s0 = alloca i8*, align 4
  %_s1 = alloca i8, align 1
  %s1 = alloca i8*, align 4
  %_s2 = alloca i8, align 1
  %s2 = alloca i8*, align 4
  %_s3 = alloca i8, align 1
  %s3 = alloca i8*, align 4
  %_overflow = alloca i8, align 1
  %overflow = alloca i8*, align 4
  store i32 0, i32* %retval, align 4
  store i8* %_a0, i8** %a0, align 4
  store i8* %_a1, i8** %a1, align 4
  store i8* %_a2, i8** %a2, align 4
  store i8* %_a3, i8** %a3, align 4
  store i8* %_b0, i8** %b0, align 4
  store i8* %_b1, i8** %b1, align 4
  store i8* %_b2, i8** %b2, align 4
  store i8* %_b3, i8** %b3, align 4
  store i8* %_s0, i8** %s0, align 4
  store i8* %_s1, i8** %s1, align 4
  store i8* %_s2, i8** %s2, align 4
  store i8* %_s3, i8** %s3, align 4
  store i8* %_overflow, i8** %overflow, align 4
  %0 = load i8*, i8** %a3, align 4
  store i8 0, i8* %0, align 1
  %1 = load i8*, i8** %b3, align 4
  store i8 1, i8* %1, align 1
  %2 = load i8*, i8** %a2, align 4
  store i8 0, i8* %2, align 1
  %3 = load i8*, i8** %b2, align 4
  store i8 1, i8* %3, align 1
  %4 = load i8*, i8** %a1, align 4
  store i8 1, i8* %4, align 1
  %5 = load i8*, i8** %b1, align 4
  store i8 1, i8* %5, align 1
  %6 = load i8*, i8** %a0, align 4
  store i8 0, i8* %6, align 1
  %7 = load i8*, i8** %b0, align 4
  store i8 0, i8* %7, align 1
  %8 = load i8*, i8** %a0, align 4
  %9 = load i8*, i8** %a1, align 4
  %10 = load i8*, i8** %a2, align 4
  %11 = load i8*, i8** %a3, align 4
  %12 = load i8*, i8** %b0, align 4
  %13 = load i8*, i8** %b1, align 4
  %14 = load i8*, i8** %b2, align 4
  %15 = load i8*, i8** %b3, align 4
  %16 = load i8*, i8** %s0, align 4
  %17 = load i8*, i8** %s1, align 4
  %18 = load i8*, i8** %s2, align 4
  %19 = load i8*, i8** %s3, align 4
  %20 = load i8*, i8** %overflow, align 4
  call void @fourbitsadder(i8* %8, i8* %9, i8* %10, i8* %11, i8* %12, i8* %13, i8* %14, i8* %15, i8* %16, i8* %17, i8* %18, i8* %19, i8* %20)
  %21 = load i8*, i8** %a3, align 4
  %22 = load i8, i8* %21, align 1
  %conv = sext i8 %22 to i32
  %23 = load i8*, i8** %a2, align 4
  %24 = load i8, i8* %23, align 1
  %conv1 = sext i8 %24 to i32
  %25 = load i8*, i8** %a1, align 4
  %26 = load i8, i8* %25, align 1
  %conv2 = sext i8 %26 to i32
  %27 = load i8*, i8** %a0, align 4
  %28 = load i8, i8* %27, align 1
  %conv3 = sext i8 %28 to i32
  %29 = load i8*, i8** %b3, align 4
  %30 = load i8, i8* %29, align 1
  %conv4 = sext i8 %30 to i32
  %31 = load i8*, i8** %b2, align 4
  %32 = load i8, i8* %31, align 1
  %conv5 = sext i8 %32 to i32
  %33 = load i8*, i8** %b1, align 4
  %34 = load i8, i8* %33, align 1
  %conv6 = sext i8 %34 to i32
  %35 = load i8*, i8** %b0, align 4
  %36 = load i8, i8* %35, align 1
  %conv7 = sext i8 %36 to i32
  %37 = load i8*, i8** %s3, align 4
  %38 = load i8, i8* %37, align 1
  %conv8 = sext i8 %38 to i32
  %39 = load i8*, i8** %s2, align 4
  %40 = load i8, i8* %39, align 1
  %conv9 = sext i8 %40 to i32
  %41 = load i8*, i8** %s1, align 4
  %42 = load i8, i8* %41, align 1
  %conv10 = sext i8 %42 to i32
  %43 = load i8*, i8** %s0, align 4
  %44 = load i8, i8* %43, align 1
  %conv11 = sext i8 %44 to i32
  %45 = load i8*, i8** %overflow, align 4
  %46 = load i8, i8* %45, align 1
  %conv12 = sext i8 %46 to i32
  %call = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([47 x i8], [47 x i8]* @.str, i32 0, i32 0), i32 %conv, i32 %conv1, i32 %conv2, i32 %conv3, i32 %conv4, i32 %conv5, i32 %conv6, i32 %conv7, i32 %conv8, i32 %conv9, i32 %conv10, i32 %conv11, i32 %conv12)
  ret i32 0
}

declare i32 @printf(i8* %0, ...) #1

attributes #0 = { noinline nounwind optnone "correctly-rounded-divide-sqrt-fp-math"="false" "disable-tail-calls"="false" "frame-pointer"="none" "less-precise-fpmad"="false" "min-legal-vector-width"="0" "no-infs-fp-math"="false" "no-jump-tables"="false" "no-nans-fp-math"="false" "no-signed-zeros-fp-math"="false" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="generic" "unsafe-fp-math"="false" "use-soft-float"="false" }
attributes #1 = { "correctly-rounded-divide-sqrt-fp-math"="false" "disable-tail-calls"="false" "frame-pointer"="none" "less-precise-fpmad"="false" "no-infs-fp-math"="false" "no-nans-fp-math"="false" "no-signed-zeros-fp-math"="false" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="generic" "unsafe-fp-math"="false" "use-soft-float"="false" }

!llvm.module.flags = !{!0}
!llvm.ident = !{!1}

!0 = !{i32 1, !"wchar_size", i32 4}
!1 = !{!"clang version 11.0.0 (https://github.com/Jacarte/llvm-project.git 0f6dea67136cc1e0b3d200eb2bb165628970c44b)"}

; extracted candidates

; *****
; For LLVM instruction:
;  %22 = load i8, i8* %21, align 1
; Looking for a replacement for:
%0:i8 = var
infer %0

; *****
; For LLVM instruction:
;  %conv = sext i8 %22 to i32
; Looking for a replacement for:
%0:i8 = var
%1:i32 = sext %0
infer %1

; *****
; For LLVM instruction:
;  %24 = load i8, i8* %23, align 1
; Looking for a replacement for:
%0:i8 = var
infer %0

; *****
; For LLVM instruction:
;  %conv1 = sext i8 %24 to i32
; Looking for a replacement for:
%0:i8 = var
%1:i32 = sext %0
infer %1

; *****
; For LLVM instruction:
;  %26 = load i8, i8* %25, align 1
; Looking for a replacement for:
%0:i8 = var
infer %0

; *****
; For LLVM instruction:
;  %conv2 = sext i8 %26 to i32
; Looking for a replacement for:
%0:i8 = var
%1:i32 = sext %0
infer %1

; *****
; For LLVM instruction:
;  %28 = load i8, i8* %27, align 1
; Looking for a replacement for:
%0:i8 = var
infer %0

; *****
; For LLVM instruction:
;  %conv3 = sext i8 %28 to i32
; Looking for a replacement for:
%0:i8 = var
%1:i32 = sext %0
infer %1

; *****
; For LLVM instruction:
;  %30 = load i8, i8* %29, align 1
; Looking for a replacement for:
%0:i8 = var
infer %0

; *****
; For LLVM instruction:
;  %conv4 = sext i8 %30 to i32
; Looking for a replacement for:
%0:i8 = var
%1:i32 = sext %0
infer %1

; *****
; For LLVM instruction:
;  %32 = load i8, i8* %31, align 1
; Looking for a replacement for:
%0:i8 = var
infer %0

; *****
; For LLVM instruction:
;  %conv5 = sext i8 %32 to i32
; Looking for a replacement for:
%0:i8 = var
%1:i32 = sext %0
infer %1

; *****
; For LLVM instruction:
;  %34 = load i8, i8* %33, align 1
; Looking for a replacement for:
%0:i8 = var
infer %0

; *****
; For LLVM instruction:
;  %conv6 = sext i8 %34 to i32
; Looking for a replacement for:
%0:i8 = var
%1:i32 = sext %0
infer %1

; *****
; For LLVM instruction:
;  %36 = load i8, i8* %35, align 1
; Looking for a replacement for:
%0:i8 = var
infer %0

; *****
; For LLVM instruction:
;  %conv7 = sext i8 %36 to i32
; Looking for a replacement for:
%0:i8 = var
%1:i32 = sext %0
infer %1

; *****
; For LLVM instruction:
;  %38 = load i8, i8* %37, align 1
; Looking for a replacement for:
%0:i8 = var
infer %0

; *****
; For LLVM instruction:
;  %conv8 = sext i8 %38 to i32
; Looking for a replacement for:
%0:i8 = var
%1:i32 = sext %0
infer %1

; *****
; For LLVM instruction:
;  %40 = load i8, i8* %39, align 1
; Looking for a replacement for:
%0:i8 = var
infer %0

; *****
; For LLVM instruction:
;  %conv9 = sext i8 %40 to i32
; Looking for a replacement for:
%0:i8 = var
%1:i32 = sext %0
infer %1

; *****
; For LLVM instruction:
;  %42 = load i8, i8* %41, align 1
; Looking for a replacement for:
%0:i8 = var
infer %0

; *****
; For LLVM instruction:
;  %conv10 = sext i8 %42 to i32
; Looking for a replacement for:
%0:i8 = var
%1:i32 = sext %0
infer %1

; *****
; For LLVM instruction:
;  %44 = load i8, i8* %43, align 1
; Looking for a replacement for:
%0:i8 = var
infer %0

; *****
; For LLVM instruction:
;  %conv11 = sext i8 %44 to i32
; Looking for a replacement for:
%0:i8 = var
%1:i32 = sext %0
infer %1

; *****
; For LLVM instruction:
;  %46 = load i8, i8* %45, align 1
; Looking for a replacement for:
%0:i8 = var
infer %0

; *****
; For LLVM instruction:
;  %conv12 = sext i8 %46 to i32
; Looking for a replacement for:
%0:i8 = var
%1:i32 = sext %0
infer %1
got 2 candidates from LHS

-------------------------------------------------
%0:i8 = var
%1:i32 = sext %0
infer %1


--------------------------------
guess 0

%0:i32 = var ; reservedconst_1

Cost = 0
first query is SAT, returning the model:
reservedconst_1: 0
0 th attempt: second query is SAT-- constant doesn't work
first query is SAT, returning the model:
reservedconst_1: -1
1 th attempt: second query is SAT-- constant doesn't work
first query is UNSAT-- no more guesses
Dataflow Pruned 0/0
There are 1 Guesses
There are 0 RHSs before deduplication
There are 0 RHSs after deduplication
#########################################################
; exiting Souper's runOnFunction() for main()
Total of 0 replacements done on this module
Total of 0 replacements candidates on this module
