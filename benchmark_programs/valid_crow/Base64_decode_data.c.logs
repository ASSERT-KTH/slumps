
Entering the Souper pass's runOnModule()


; entering Souper's runOnFunction() for findIndex()

; ModuleID = './Base64_decode_data.c.bc'
source_filename = "./Base64_decode_data.c"
target datalayout = "e-m:e-p:32:32-i64:64-n32:64-S128"
target triple = "wasm32-unknown-wasi"

@BASE64 = hidden constant [65 x i8] c"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\00", align 16
@__const.main.data = private unnamed_addr constant [117 x i8] c"VG8gZXJyIGlzIGh1bWFuLCBidXQgdG8gcmVhbGx5IGZvdWwgdGhpbmdzIHVwIHlvdSBuZWVkIGEgY29tcHV0ZXIuCiAgICAtLVBhdWwgUi5FaHJsaWNo\00", align 16
@.str = private unnamed_addr constant [5 x i8] c"%s\0A\0A\00", align 1
@llvm.used = appending global [1 x i8*] [i8* bitcast (i32 ()* @__main_void to i8*)], section "llvm.metadata"

@__main_void = alias i32 (), i32 ()* @main

; Function Attrs: noinline nounwind optnone
define hidden i32 @findIndex(i8 zeroext %val) #0 {
entry:
  %retval = alloca i32, align 4
  %val.addr = alloca i8, align 1
  store i8 %val, i8* %val.addr, align 1
  %0 = load i8, i8* %val.addr, align 1
  %conv = zext i8 %0 to i32
  %cmp = icmp sle i32 65, %conv
  br i1 %cmp, label %land.lhs.true, label %if.end

land.lhs.true:                                    ; preds = %entry
  %1 = load i8, i8* %val.addr, align 1
  %conv2 = zext i8 %1 to i32
  %cmp3 = icmp sle i32 %conv2, 90
  br i1 %cmp3, label %if.then, label %if.end

if.then:                                          ; preds = %land.lhs.true
  %2 = load i8, i8* %val.addr, align 1
  %conv5 = zext i8 %2 to i32
  %sub = sub nsw i32 %conv5, 65
  store i32 %sub, i32* %retval, align 4
  br label %return

if.end:                                           ; preds = %land.lhs.true, %entry
  %3 = load i8, i8* %val.addr, align 1
  %conv6 = zext i8 %3 to i32
  %cmp7 = icmp sle i32 97, %conv6
  br i1 %cmp7, label %land.lhs.true9, label %if.end16

land.lhs.true9:                                   ; preds = %if.end
  %4 = load i8, i8* %val.addr, align 1
  %conv10 = zext i8 %4 to i32
  %cmp11 = icmp sle i32 %conv10, 122
  br i1 %cmp11, label %if.then13, label %if.end16

if.then13:                                        ; preds = %land.lhs.true9
  %5 = load i8, i8* %val.addr, align 1
  %conv14 = zext i8 %5 to i32
  %sub15 = sub nsw i32 %conv14, 97
  %add = add nsw i32 %sub15, 26
  store i32 %add, i32* %retval, align 4
  br label %return

if.end16:                                         ; preds = %land.lhs.true9, %if.end
  %6 = load i8, i8* %val.addr, align 1
  %conv17 = zext i8 %6 to i32
  %cmp18 = icmp sle i32 48, %conv17
  br i1 %cmp18, label %land.lhs.true20, label %if.end28

land.lhs.true20:                                  ; preds = %if.end16
  %7 = load i8, i8* %val.addr, align 1
  %conv21 = zext i8 %7 to i32
  %cmp22 = icmp sle i32 %conv21, 57
  br i1 %cmp22, label %if.then24, label %if.end28

if.then24:                                        ; preds = %land.lhs.true20
  %8 = load i8, i8* %val.addr, align 1
  %conv25 = zext i8 %8 to i32
  %sub26 = sub nsw i32 %conv25, 48
  %add27 = add nsw i32 %sub26, 52
  store i32 %add27, i32* %retval, align 4
  br label %return

if.end28:                                         ; preds = %land.lhs.true20, %if.end16
  %9 = load i8, i8* %val.addr, align 1
  %conv29 = zext i8 %9 to i32
  %cmp30 = icmp eq i32 %conv29, 43
  br i1 %cmp30, label %if.then32, label %if.end33

if.then32:                                        ; preds = %if.end28
  store i32 62, i32* %retval, align 4
  br label %return

if.end33:                                         ; preds = %if.end28
  %10 = load i8, i8* %val.addr, align 1
  %conv34 = zext i8 %10 to i32
  %cmp35 = icmp eq i32 %conv34, 47
  br i1 %cmp35, label %if.then37, label %if.end38

if.then37:                                        ; preds = %if.end33
  store i32 63, i32* %retval, align 4
  br label %return

if.end38:                                         ; preds = %if.end33
  store i32 -1, i32* %retval, align 4
  br label %return

return:                                           ; preds = %if.end38, %if.then37, %if.then32, %if.then24, %if.then13, %if.then
  %11 = load i32, i32* %retval, align 4
  ret i32 %11
}

; Function Attrs: noinline nounwind optnone
define hidden i32 @decode(i8* %source, i8* %sink) #0 {
entry:
  %retval = alloca i32, align 4
  %source.addr = alloca i8*, align 4
  %sink.addr = alloca i8*, align 4
  %length = alloca i32, align 4
  %it = alloca i8*, align 4
  %end = alloca i8*, align 4
  %acc = alloca i32, align 4
  %b1 = alloca i8, align 1
  %b2 = alloca i8, align 1
  %b3 = alloca i8, align 1
  %b4 = alloca i8, align 1
  %i1 = alloca i32, align 4
  %i2 = alloca i32, align 4
  %i3 = alloca i32, align 4
  %i4 = alloca i32, align 4
  store i8* %source, i8** %source.addr, align 4
  store i8* %sink, i8** %sink.addr, align 4
  %0 = load i8*, i8** %source.addr, align 4
  %call = call i32 @strlen(i8* %0)
  store i32 %call, i32* %length, align 4
  %1 = load i8*, i8** %source.addr, align 4
  store i8* %1, i8** %it, align 4
  %2 = load i8*, i8** %source.addr, align 4
  %3 = load i32, i32* %length, align 4
  %add.ptr = getelementptr inbounds i8, i8* %2, i32 %3
  store i8* %add.ptr, i8** %end, align 4
  %4 = load i32, i32* %length, align 4
  %rem = urem i32 %4, 4
  %cmp = icmp ne i32 %rem, 0
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  store i32 1, i32* %retval, align 4
  br label %return

if.end:                                           ; preds = %entry
  br label %while.cond

while.cond:                                       ; preds = %if.end28, %if.end
  %5 = load i8*, i8** %it, align 4
  %6 = load i8*, i8** %end, align 4
  %cmp1 = icmp ne i8* %5, %6
  br i1 %cmp1, label %while.body, label %while.end

while.body:                                       ; preds = %while.cond
  %7 = load i8*, i8** %it, align 4
  %incdec.ptr = getelementptr inbounds i8, i8* %7, i32 1
  store i8* %incdec.ptr, i8** %it, align 4
  %8 = load i8, i8* %7, align 1
  store i8 %8, i8* %b1, align 1
  %9 = load i8*, i8** %it, align 4
  %incdec.ptr2 = getelementptr inbounds i8, i8* %9, i32 1
  store i8* %incdec.ptr2, i8** %it, align 4
  %10 = load i8, i8* %9, align 1
  store i8 %10, i8* %b2, align 1
  %11 = load i8*, i8** %it, align 4
  %incdec.ptr3 = getelementptr inbounds i8, i8* %11, i32 1
  store i8* %incdec.ptr3, i8** %it, align 4
  %12 = load i8, i8* %11, align 1
  store i8 %12, i8* %b3, align 1
  %13 = load i8*, i8** %it, align 4
  %incdec.ptr4 = getelementptr inbounds i8, i8* %13, i32 1
  store i8* %incdec.ptr4, i8** %it, align 4
  %14 = load i8, i8* %13, align 1
  store i8 %14, i8* %b4, align 1
  %15 = load i8, i8* %b1, align 1
  %call5 = call i32 @findIndex(i8 zeroext %15)
  store i32 %call5, i32* %i1, align 4
  %16 = load i8, i8* %b2, align 1
  %call6 = call i32 @findIndex(i8 zeroext %16)
  store i32 %call6, i32* %i2, align 4
  %17 = load i32, i32* %i1, align 4
  %shl = shl i32 %17, 2
  store i32 %shl, i32* %acc, align 4
  %18 = load i32, i32* %i2, align 4
  %shr = ashr i32 %18, 4
  %19 = load i32, i32* %acc, align 4
  %or = or i32 %19, %shr
  store i32 %or, i32* %acc, align 4
  %20 = load i32, i32* %acc, align 4
  %conv = trunc i32 %20 to i8
  %21 = load i8*, i8** %sink.addr, align 4
  %incdec.ptr7 = getelementptr inbounds i8, i8* %21, i32 1
  store i8* %incdec.ptr7, i8** %sink.addr, align 4
  store i8 %conv, i8* %21, align 1
  %22 = load i8, i8* %b3, align 1
  %conv8 = zext i8 %22 to i32
  %cmp9 = icmp ne i32 %conv8, 61
  br i1 %cmp9, label %if.then11, label %if.end28

if.then11:                                        ; preds = %while.body
  %23 = load i8, i8* %b3, align 1
  %call12 = call i32 @findIndex(i8 zeroext %23)
  store i32 %call12, i32* %i3, align 4
  %24 = load i32, i32* %i2, align 4
  %and = and i32 %24, 15
  %shl13 = shl i32 %and, 4
  store i32 %shl13, i32* %acc, align 4
  %25 = load i32, i32* %i3, align 4
  %shr14 = ashr i32 %25, 2
  %26 = load i32, i32* %acc, align 4
  %add = add nsw i32 %26, %shr14
  store i32 %add, i32* %acc, align 4
  %27 = load i32, i32* %acc, align 4
  %conv15 = trunc i32 %27 to i8
  %28 = load i8*, i8** %sink.addr, align 4
  %incdec.ptr16 = getelementptr inbounds i8, i8* %28, i32 1
  store i8* %incdec.ptr16, i8** %sink.addr, align 4
  store i8 %conv15, i8* %28, align 1
  %29 = load i8, i8* %b4, align 1
  %conv17 = zext i8 %29 to i32
  %cmp18 = icmp ne i32 %conv17, 61
  br i1 %cmp18, label %if.then20, label %if.end27

if.then20:                                        ; preds = %if.then11
  %30 = load i8, i8* %b4, align 1
  %call21 = call i32 @findIndex(i8 zeroext %30)
  store i32 %call21, i32* %i4, align 4
  %31 = load i32, i32* %i3, align 4
  %and22 = and i32 %31, 3
  %shl23 = shl i32 %and22, 6
  store i32 %shl23, i32* %acc, align 4
  %32 = load i32, i32* %i4, align 4
  %33 = load i32, i32* %acc, align 4
  %or24 = or i32 %33, %32
  store i32 %or24, i32* %acc, align 4
  %34 = load i32, i32* %acc, align 4
  %conv25 = trunc i32 %34 to i8
  %35 = load i8*, i8** %sink.addr, align 4
  %incdec.ptr26 = getelementptr inbounds i8, i8* %35, i32 1
  store i8* %incdec.ptr26, i8** %sink.addr, align 4
  store i8 %conv25, i8* %35, align 1
  br label %if.end27

if.end27:                                         ; preds = %if.then20, %if.then11
  br label %if.end28

if.end28:                                         ; preds = %if.end27, %while.body
  br label %while.cond

while.end:                                        ; preds = %while.cond
  %36 = load i8*, i8** %sink.addr, align 4
  store i8 0, i8* %36, align 1
  store i32 0, i32* %retval, align 4
  br label %return

return:                                           ; preds = %while.end, %if.then
  %37 = load i32, i32* %retval, align 4
  ret i32 %37
}

declare i32 @strlen(i8* %0) #1

; Function Attrs: noinline nounwind optnone
define hidden i32 @main() #0 {
entry:
  %retval = alloca i32, align 4
  %data = alloca [117 x i8], align 16
  %decoded = alloca [1024 x i8], align 16
  store i32 0, i32* %retval, align 4
  %0 = bitcast [117 x i8]* %data to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 16 %0, i8* align 16 getelementptr inbounds ([117 x i8], [117 x i8]* @__const.main.data, i32 0, i32 0), i32 117, i1 false)
  %arraydecay = getelementptr inbounds [117 x i8], [117 x i8]* %data, i32 0, i32 0
  %call = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str, i32 0, i32 0), i8* %arraydecay)
  %arraydecay1 = getelementptr inbounds [117 x i8], [117 x i8]* %data, i32 0, i32 0
  %arraydecay2 = getelementptr inbounds [1024 x i8], [1024 x i8]* %decoded, i32 0, i32 0
  %call3 = call i32 @decode(i8* %arraydecay1, i8* %arraydecay2)
  %arraydecay4 = getelementptr inbounds [1024 x i8], [1024 x i8]* %decoded, i32 0, i32 0
  %call5 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str, i32 0, i32 0), i8* %arraydecay4)
  ret i32 0
}

; Function Attrs: argmemonly nounwind willreturn
declare void @llvm.memcpy.p0i8.p0i8.i32(i8* noalias nocapture writeonly %0, i8* noalias nocapture readonly %1, i32 %2, i1 immarg %3) #2

declare i32 @printf(i8* %0, ...) #1

attributes #0 = { noinline nounwind optnone "correctly-rounded-divide-sqrt-fp-math"="false" "disable-tail-calls"="false" "frame-pointer"="none" "less-precise-fpmad"="false" "min-legal-vector-width"="0" "no-infs-fp-math"="false" "no-jump-tables"="false" "no-nans-fp-math"="false" "no-signed-zeros-fp-math"="false" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="generic" "unsafe-fp-math"="false" "use-soft-float"="false" }
attributes #1 = { "correctly-rounded-divide-sqrt-fp-math"="false" "disable-tail-calls"="false" "frame-pointer"="none" "less-precise-fpmad"="false" "no-infs-fp-math"="false" "no-nans-fp-math"="false" "no-signed-zeros-fp-math"="false" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="generic" "unsafe-fp-math"="false" "use-soft-float"="false" }
attributes #2 = { argmemonly nounwind willreturn }

!llvm.module.flags = !{!0}
!llvm.ident = !{!1}

!0 = !{i32 1, !"wchar_size", i32 4}
!1 = !{!"clang version 11.0.0 (https://github.com/Jacarte/llvm-project.git 0f6dea67136cc1e0b3d200eb2bb165628970c44b)"}

; extracted candidates

; *****
; For LLVM instruction:
;  %0 = load i8, i8* %val.addr, align 1
; Looking for a replacement for:
%0:i8 = var
infer %0

; *****
; For LLVM instruction:
;  %conv = zext i8 %0 to i32
; Looking for a replacement for:
%0:i8 = var
%1:i32 = zext %0
infer %1

; *****
; For LLVM instruction:
;  %cmp = icmp sle i32 65, %conv
; Looking for a replacement for:
%0:i8 = var
%1:i32 = zext %0
%2:i1 = sle 65:i32, %1
infer %2

; *****
; For LLVM instruction:
;  %1 = load i8, i8* %val.addr, align 1
; Looking for a replacement for:
%0:i8 = var
infer %0

; *****
; For LLVM instruction:
;  %conv2 = zext i8 %1 to i32
; Looking for a replacement for:
%0:i8 = var
%1:i32 = zext %0
infer %1

; *****
; For LLVM instruction:
;  %cmp3 = icmp sle i32 %conv2, 90
; Looking for a replacement for:
%0:i8 = var
%1:i32 = zext %0
%2:i1 = sle %1, 90:i32
infer %2

; *****
; For LLVM instruction:
;  %2 = load i8, i8* %val.addr, align 1
; Looking for a replacement for:
%0:i8 = var
infer %0

; *****
; For LLVM instruction:
;  %conv5 = zext i8 %2 to i32
; Looking for a replacement for:
%0:i8 = var
%1:i32 = zext %0
infer %1

; *****
; For LLVM instruction:
;  %sub = sub nsw i32 %conv5, 65
; Looking for a replacement for:
%0:i8 = var
%1:i32 = zext %0
%2:i32 = subnsw %1, 65:i32
infer %2

; *****
; For LLVM instruction:
;  %3 = load i8, i8* %val.addr, align 1
; Looking for a replacement for:
%0:i8 = var
infer %0

; *****
; For LLVM instruction:
;  %conv6 = zext i8 %3 to i32
; Looking for a replacement for:
%0:i8 = var
%1:i32 = zext %0
infer %1

; *****
; For LLVM instruction:
;  %cmp7 = icmp sle i32 97, %conv6
; Looking for a replacement for:
%0:i8 = var
%1:i32 = zext %0
%2:i1 = sle 97:i32, %1
infer %2

; *****
; For LLVM instruction:
;  %4 = load i8, i8* %val.addr, align 1
; Looking for a replacement for:
%0:i8 = var
infer %0

; *****
; For LLVM instruction:
;  %conv10 = zext i8 %4 to i32
; Looking for a replacement for:
%0:i8 = var
%1:i32 = zext %0
infer %1

; *****
; For LLVM instruction:
;  %cmp11 = icmp sle i32 %conv10, 122
; Looking for a replacement for:
%0:i8 = var
%1:i32 = zext %0
%2:i1 = sle %1, 122:i32
infer %2

; *****
; For LLVM instruction:
;  %5 = load i8, i8* %val.addr, align 1
; Looking for a replacement for:
%0:i8 = var
infer %0

; *****
; For LLVM instruction:
;  %conv14 = zext i8 %5 to i32
; Looking for a replacement for:
%0:i8 = var
%1:i32 = zext %0
infer %1

; *****
; For LLVM instruction:
;  %sub15 = sub nsw i32 %conv14, 97
; Looking for a replacement for:
%0:i8 = var
%1:i32 = zext %0
%2:i32 = subnsw %1, 97:i32
infer %2

; *****
; For LLVM instruction:
;  %add = add nsw i32 %sub15, 26
; Looking for a replacement for:
%0:i8 = var
%1:i32 = zext %0
%2:i32 = subnsw %1, 97:i32
%3:i32 = addnsw 26:i32, %2
infer %3

; *****
; For LLVM instruction:
;  %6 = load i8, i8* %val.addr, align 1
; Looking for a replacement for:
%0:i8 = var
infer %0

; *****
; For LLVM instruction:
;  %conv17 = zext i8 %6 to i32
; Looking for a replacement for:
%0:i8 = var
%1:i32 = zext %0
infer %1

; *****
; For LLVM instruction:
;  %cmp18 = icmp sle i32 48, %conv17
; Looking for a replacement for:
%0:i8 = var
%1:i32 = zext %0
%2:i1 = sle 48:i32, %1
infer %2

; *****
; For LLVM instruction:
;  %7 = load i8, i8* %val.addr, align 1
; Looking for a replacement for:
%0:i8 = var
infer %0

; *****
; For LLVM instruction:
;  %conv21 = zext i8 %7 to i32
; Looking for a replacement for:
%0:i8 = var
%1:i32 = zext %0
infer %1

; *****
; For LLVM instruction:
;  %cmp22 = icmp sle i32 %conv21, 57
; Looking for a replacement for:
%0:i8 = var
%1:i32 = zext %0
%2:i1 = sle %1, 57:i32
infer %2

; *****
; For LLVM instruction:
;  %8 = load i8, i8* %val.addr, align 1
; Looking for a replacement for:
%0:i8 = var
infer %0

; *****
; For LLVM instruction:
;  %conv25 = zext i8 %8 to i32
; Looking for a replacement for:
%0:i8 = var
%1:i32 = zext %0
infer %1

; *****
; For LLVM instruction:
;  %sub26 = sub nsw i32 %conv25, 48
; Looking for a replacement for:
%0:i8 = var
%1:i32 = zext %0
%2:i32 = subnsw %1, 48:i32
infer %2

; *****
; For LLVM instruction:
;  %add27 = add nsw i32 %sub26, 52
; Looking for a replacement for:
%0:i8 = var
%1:i32 = zext %0
%2:i32 = subnsw %1, 48:i32
%3:i32 = addnsw 52:i32, %2
infer %3

; *****
; For LLVM instruction:
;  %9 = load i8, i8* %val.addr, align 1
; Looking for a replacement for:
%0:i8 = var
infer %0

; *****
; For LLVM instruction:
;  %conv29 = zext i8 %9 to i32
; Looking for a replacement for:
%0:i8 = var
%1:i32 = zext %0
infer %1

; *****
; For LLVM instruction:
;  %cmp30 = icmp eq i32 %conv29, 43
; Looking for a replacement for:
%0:i8 = var
%1:i32 = zext %0
%2:i1 = eq 43:i32, %1
infer %2

; *****
; For LLVM instruction:
;  %10 = load i8, i8* %val.addr, align 1
; Looking for a replacement for:
%0:i8 = var
infer %0

; *****
; For LLVM instruction:
;  %conv34 = zext i8 %10 to i32
; Looking for a replacement for:
%0:i8 = var
%1:i32 = zext %0
infer %1

; *****
; For LLVM instruction:
;  %cmp35 = icmp eq i32 %conv34, 47
; Looking for a replacement for:
%0:i8 = var
%1:i32 = zext %0
%2:i1 = eq 47:i32, %1
infer %2

; *****
; For LLVM instruction:
;  %11 = load i32, i32* %retval, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0
got 1 candidates from LHS

-------------------------------------------------
%0:i8 = var
infer %0


--------------------------------
guess 0

%0:i8 = var ; reservedconst_1

Cost = 0
first query is SAT, returning the model:
reservedconst_1: 0
0 th attempt: second query is SAT-- constant doesn't work
first query is SAT, returning the model:
reservedconst_1: -1
1 th attempt: second query is SAT-- constant doesn't work
first query is UNSAT-- no more guesses
Dataflow Pruned 0/0
There are 1 Guesses
There are 0 RHSs before deduplication
There are 0 RHSs after deduplication
got 2 candidates from LHS

-------------------------------------------------
%0:i8 = var
%1:i32 = zext %0
infer %1


--------------------------------
guess 0

%0:i32 = var ; reservedconst_1

Cost = 0
first query is SAT, returning the model:
reservedconst_1: 0
0 th attempt: second query is SAT-- constant doesn't work
first query is SAT, returning the model:
reservedconst_1: 255
1 th attempt: second query is SAT-- constant doesn't work
first query is UNSAT-- no more guesses
Dataflow Pruned 0/0
There are 1 Guesses
There are 0 RHSs before deduplication
There are 0 RHSs after deduplication
got 3 candidates from LHS

-------------------------------------------------
%0:i8 = var
%1:i32 = zext %0
%2:i1 = sle 65:i32, %1
infer %2


--------------------------------
guess 0

%0:i1 = var ; reservedconst_1

Cost = 0
first query is SAT, returning the model:
reservedconst_1: 0
0 th attempt: second query is SAT-- constant doesn't work
first query is SAT, returning the model:
reservedconst_1: -1
1 th attempt: second query is SAT-- constant doesn't work
first query is UNSAT-- no more guesses
Dataflow Pruned 0/0
There are 1 Guesses
There are 0 RHSs before deduplication
There are 0 RHSs after deduplication
got 3 candidates from LHS

-------------------------------------------------
%0:i8 = var
%1:i32 = zext %0
%2:i1 = sle %1, 90:i32
infer %2


--------------------------------
guess 0

%0:i1 = var ; reservedconst_1

Cost = 0
first query is SAT, returning the model:
reservedconst_1: -1
0 th attempt: second query is SAT-- constant doesn't work
first query is SAT, returning the model:
reservedconst_1: 0
1 th attempt: second query is SAT-- constant doesn't work
first query is UNSAT-- no more guesses
Dataflow Pruned 0/0
There are 1 Guesses
There are 0 RHSs before deduplication
There are 0 RHSs after deduplication
got 3 candidates from LHS

-------------------------------------------------
%0:i8 = var
%1:i32 = zext %0
%2:i32 = subnsw %1, 65:i32
infer %2


--------------------------------
guess 0

%0:i32 = var ; reservedconst_1

Cost = 0
first query is SAT, returning the model:
reservedconst_1: -65
0 th attempt: second query is SAT-- constant doesn't work
first query is SAT, returning the model:
reservedconst_1: -1
1 th attempt: second query is SAT-- constant doesn't work
first query is UNSAT-- no more guesses

--------------------------------
guess 1

%0:i8 = var
%1:i32 = zext %0

Cost = 1
second query is SAT-- constant doesn't work
Dataflow Pruned 0/0
There are 2 Guesses
There are 0 RHSs before deduplication
There are 0 RHSs after deduplication
got 3 candidates from LHS

-------------------------------------------------
%0:i8 = var
%1:i32 = zext %0
%2:i1 = sle 97:i32, %1
infer %2


--------------------------------
guess 0

%0:i1 = var ; reservedconst_1

Cost = 0
first query is SAT, returning the model:
reservedconst_1: 0
0 th attempt: second query is SAT-- constant doesn't work
first query is SAT, returning the model:
reservedconst_1: -1
1 th attempt: second query is SAT-- constant doesn't work
first query is UNSAT-- no more guesses
Dataflow Pruned 0/0
There are 1 Guesses
There are 0 RHSs before deduplication
There are 0 RHSs after deduplication
got 3 candidates from LHS

-------------------------------------------------
%0:i8 = var
%1:i32 = zext %0
%2:i1 = sle %1, 122:i32
infer %2


--------------------------------
guess 0

%0:i1 = var ; reservedconst_1

Cost = 0
first query is SAT, returning the model:
reservedconst_1: -1
0 th attempt: second query is SAT-- constant doesn't work
first query is SAT, returning the model:
reservedconst_1: 0
1 th attempt: second query is SAT-- constant doesn't work
first query is UNSAT-- no more guesses
Dataflow Pruned 0/0
There are 1 Guesses
There are 0 RHSs before deduplication
There are 0 RHSs after deduplication
got 3 candidates from LHS

-------------------------------------------------
%0:i8 = var
%1:i32 = zext %0
%2:i32 = subnsw %1, 97:i32
infer %2


--------------------------------
guess 0

%0:i32 = var ; reservedconst_1

Cost = 0
first query is SAT, returning the model:
reservedconst_1: -97
0 th attempt: second query is SAT-- constant doesn't work
first query is SAT, returning the model:
reservedconst_1: -33
1 th attempt: second query is SAT-- constant doesn't work
first query is UNSAT-- no more guesses

--------------------------------
guess 1

%0:i8 = var
%1:i32 = zext %0

Cost = 1
second query is SAT-- constant doesn't work
Dataflow Pruned 0/0
There are 2 Guesses
There are 0 RHSs before deduplication
There are 0 RHSs after deduplication
got 4 candidates from LHS

-------------------------------------------------
%0:i8 = var
%1:i32 = zext %0
%2:i32 = subnsw %1, 97:i32
%3:i32 = addnsw 26:i32, %2
infer %3


--------------------------------
guess 0

%0:i32 = var ; reservedconst_1

Cost = 0
first query is SAT, returning the model:
reservedconst_1: -71
0 th attempt: second query is SAT-- constant doesn't work
first query is SAT, returning the model:
reservedconst_1: -7
1 th attempt: second query is SAT-- constant doesn't work
first query is UNSAT-- no more guesses

--------------------------------
guess 1

%0:i8 = var
%1:i32 = zext %0

Cost = 1
second query is SAT-- constant doesn't work

--------------------------------
guess 2

%0:i8 = var
%1:i32 = zext %0
%2:i32 = subnsw %1, 97:i32

Cost = 2
second query is SAT-- constant doesn't work
Dataflow Pruned 0/0
There are 3 Guesses
There are 0 RHSs before deduplication
There are 0 RHSs after deduplication
got 3 candidates from LHS

-------------------------------------------------
%0:i8 = var
%1:i32 = zext %0
%2:i1 = sle 48:i32, %1
infer %2


--------------------------------
guess 0

%0:i1 = var ; reservedconst_1

Cost = 0
first query is SAT, returning the model:
reservedconst_1: 0
0 th attempt: second query is SAT-- constant doesn't work
first query is SAT, returning the model:
reservedconst_1: -1
1 th attempt: second query is SAT-- constant doesn't work
first query is UNSAT-- no more guesses
Dataflow Pruned 0/0
There are 1 Guesses
There are 0 RHSs before deduplication
There are 0 RHSs after deduplication
got 3 candidates from LHS

-------------------------------------------------
%0:i8 = var
%1:i32 = zext %0
%2:i1 = sle %1, 57:i32
infer %2


--------------------------------
guess 0

%0:i1 = var ; reservedconst_1

Cost = 0
first query is SAT, returning the model:
reservedconst_1: -1
0 th attempt: second query is SAT-- constant doesn't work
first query is SAT, returning the model:
reservedconst_1: 0
1 th attempt: second query is SAT-- constant doesn't work
first query is UNSAT-- no more guesses
Dataflow Pruned 0/0
There are 1 Guesses
There are 0 RHSs before deduplication
There are 0 RHSs after deduplication
got 3 candidates from LHS

-------------------------------------------------
%0:i8 = var
%1:i32 = zext %0
%2:i32 = subnsw %1, 48:i32
infer %2


--------------------------------
guess 0

%0:i32 = var ; reservedconst_1

Cost = 0
first query is SAT, returning the model:
reservedconst_1: -48
0 th attempt: second query is SAT-- constant doesn't work
first query is SAT, returning the model:
reservedconst_1: 16
1 th attempt: second query is SAT-- constant doesn't work
first query is UNSAT-- no more guesses

--------------------------------
guess 1

%0:i8 = var
%1:i32 = zext %0

Cost = 1
second query is SAT-- constant doesn't work
Dataflow Pruned 0/0
There are 2 Guesses
There are 0 RHSs before deduplication
There are 0 RHSs after deduplication
got 4 candidates from LHS

-------------------------------------------------
%0:i8 = var
%1:i32 = zext %0
%2:i32 = subnsw %1, 48:i32
%3:i32 = addnsw 52:i32, %2
infer %3


--------------------------------
guess 0

%0:i32 = var ; reservedconst_1

Cost = 0
first query is SAT, returning the model:
reservedconst_1: 4
0 th attempt: second query is SAT-- constant doesn't work
first query is SAT, returning the model:
reservedconst_1: 68
1 th attempt: second query is SAT-- constant doesn't work
first query is UNSAT-- no more guesses

--------------------------------
guess 1

%0:i8 = var
%1:i32 = zext %0

Cost = 1
second query is SAT-- constant doesn't work

--------------------------------
guess 2

%0:i8 = var
%1:i32 = zext %0
%2:i32 = subnsw %1, 48:i32

Cost = 2
second query is SAT-- constant doesn't work
Dataflow Pruned 0/0
There are 3 Guesses
There are 0 RHSs before deduplication
There are 0 RHSs after deduplication
got 3 candidates from LHS

-------------------------------------------------
%0:i8 = var
%1:i32 = zext %0
%2:i1 = eq 43:i32, %1
infer %2


--------------------------------
guess 0

%0:i1 = var ; reservedconst_1

Cost = 0
first query is SAT, returning the model:
reservedconst_1: 0
0 th attempt: second query is SAT-- constant doesn't work
first query is SAT, returning the model:
reservedconst_1: -1
1 th attempt: second query is SAT-- constant doesn't work
first query is UNSAT-- no more guesses
Dataflow Pruned 0/0
There are 1 Guesses
There are 0 RHSs before deduplication
There are 0 RHSs after deduplication
got 3 candidates from LHS

-------------------------------------------------
%0:i8 = var
%1:i32 = zext %0
%2:i1 = eq 47:i32, %1
infer %2


--------------------------------
guess 0

%0:i1 = var ; reservedconst_1

Cost = 0
first query is SAT, returning the model:
reservedconst_1: 0
0 th attempt: second query is SAT-- constant doesn't work
first query is SAT, returning the model:
reservedconst_1: -1
1 th attempt: second query is SAT-- constant doesn't work
first query is UNSAT-- no more guesses
Dataflow Pruned 0/0
There are 1 Guesses
There are 0 RHSs before deduplication
There are 0 RHSs after deduplication
got 1 candidates from LHS

-------------------------------------------------
%0:i32 = var
infer %0


--------------------------------
guess 0

%0:i32 = var ; reservedconst_1

Cost = 0
first query is SAT, returning the model:
reservedconst_1: 0
0 th attempt: second query is SAT-- constant doesn't work
first query is SAT, returning the model:
reservedconst_1: -1
1 th attempt: second query is SAT-- constant doesn't work
first query is UNSAT-- no more guesses
Dataflow Pruned 0/0
There are 1 Guesses
There are 0 RHSs before deduplication
There are 0 RHSs after deduplication
#########################################################
; exiting Souper's runOnFunction() for findIndex()

; entering Souper's runOnFunction() for decode()

; ModuleID = './Base64_decode_data.c.bc'
source_filename = "./Base64_decode_data.c"
target datalayout = "e-m:e-p:32:32-i64:64-n32:64-S128"
target triple = "wasm32-unknown-wasi"

@BASE64 = hidden constant [65 x i8] c"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\00", align 16
@__const.main.data = private unnamed_addr constant [117 x i8] c"VG8gZXJyIGlzIGh1bWFuLCBidXQgdG8gcmVhbGx5IGZvdWwgdGhpbmdzIHVwIHlvdSBuZWVkIGEgY29tcHV0ZXIuCiAgICAtLVBhdWwgUi5FaHJsaWNo\00", align 16
@.str = private unnamed_addr constant [5 x i8] c"%s\0A\0A\00", align 1
@llvm.used = appending global [1 x i8*] [i8* bitcast (i32 ()* @__main_void to i8*)], section "llvm.metadata"

@__main_void = alias i32 (), i32 ()* @main

; Function Attrs: noinline nounwind optnone
define hidden i32 @findIndex(i8 zeroext %val) #0 {
entry:
  %retval = alloca i32, align 4
  %val.addr = alloca i8, align 1
  store i8 %val, i8* %val.addr, align 1
  %0 = load i8, i8* %val.addr, align 1
  %conv = zext i8 %0 to i32
  %cmp = icmp sle i32 65, %conv
  br i1 %cmp, label %land.lhs.true, label %if.end

land.lhs.true:                                    ; preds = %entry
  %1 = load i8, i8* %val.addr, align 1
  %conv2 = zext i8 %1 to i32
  %cmp3 = icmp sle i32 %conv2, 90
  br i1 %cmp3, label %if.then, label %if.end

if.then:                                          ; preds = %land.lhs.true
  %2 = load i8, i8* %val.addr, align 1
  %conv5 = zext i8 %2 to i32
  %sub = sub nsw i32 %conv5, 65
  store i32 %sub, i32* %retval, align 4
  br label %return

if.end:                                           ; preds = %land.lhs.true, %entry
  %3 = load i8, i8* %val.addr, align 1
  %conv6 = zext i8 %3 to i32
  %cmp7 = icmp sle i32 97, %conv6
  br i1 %cmp7, label %land.lhs.true9, label %if.end16

land.lhs.true9:                                   ; preds = %if.end
  %4 = load i8, i8* %val.addr, align 1
  %conv10 = zext i8 %4 to i32
  %cmp11 = icmp sle i32 %conv10, 122
  br i1 %cmp11, label %if.then13, label %if.end16

if.then13:                                        ; preds = %land.lhs.true9
  %5 = load i8, i8* %val.addr, align 1
  %conv14 = zext i8 %5 to i32
  %sub15 = sub nsw i32 %conv14, 97
  %add = add nsw i32 %sub15, 26
  store i32 %add, i32* %retval, align 4
  br label %return

if.end16:                                         ; preds = %land.lhs.true9, %if.end
  %6 = load i8, i8* %val.addr, align 1
  %conv17 = zext i8 %6 to i32
  %cmp18 = icmp sle i32 48, %conv17
  br i1 %cmp18, label %land.lhs.true20, label %if.end28

land.lhs.true20:                                  ; preds = %if.end16
  %7 = load i8, i8* %val.addr, align 1
  %conv21 = zext i8 %7 to i32
  %cmp22 = icmp sle i32 %conv21, 57
  br i1 %cmp22, label %if.then24, label %if.end28

if.then24:                                        ; preds = %land.lhs.true20
  %8 = load i8, i8* %val.addr, align 1
  %conv25 = zext i8 %8 to i32
  %sub26 = sub nsw i32 %conv25, 48
  %add27 = add nsw i32 %sub26, 52
  store i32 %add27, i32* %retval, align 4
  br label %return

if.end28:                                         ; preds = %land.lhs.true20, %if.end16
  %9 = load i8, i8* %val.addr, align 1
  %conv29 = zext i8 %9 to i32
  %cmp30 = icmp eq i32 %conv29, 43
  br i1 %cmp30, label %if.then32, label %if.end33

if.then32:                                        ; preds = %if.end28
  store i32 62, i32* %retval, align 4
  br label %return

if.end33:                                         ; preds = %if.end28
  %10 = load i8, i8* %val.addr, align 1
  %conv34 = zext i8 %10 to i32
  %cmp35 = icmp eq i32 %conv34, 47
  br i1 %cmp35, label %if.then37, label %if.end38

if.then37:                                        ; preds = %if.end33
  store i32 63, i32* %retval, align 4
  br label %return

if.end38:                                         ; preds = %if.end33
  store i32 -1, i32* %retval, align 4
  br label %return

return:                                           ; preds = %if.end38, %if.then37, %if.then32, %if.then24, %if.then13, %if.then
  %11 = load i32, i32* %retval, align 4
  ret i32 %11
}

; Function Attrs: noinline nounwind optnone
define hidden i32 @decode(i8* %source, i8* %sink) #0 {
entry:
  %retval = alloca i32, align 4
  %source.addr = alloca i8*, align 4
  %sink.addr = alloca i8*, align 4
  %length = alloca i32, align 4
  %it = alloca i8*, align 4
  %end = alloca i8*, align 4
  %acc = alloca i32, align 4
  %b1 = alloca i8, align 1
  %b2 = alloca i8, align 1
  %b3 = alloca i8, align 1
  %b4 = alloca i8, align 1
  %i1 = alloca i32, align 4
  %i2 = alloca i32, align 4
  %i3 = alloca i32, align 4
  %i4 = alloca i32, align 4
  store i8* %source, i8** %source.addr, align 4
  store i8* %sink, i8** %sink.addr, align 4
  %0 = load i8*, i8** %source.addr, align 4
  %call = call i32 @strlen(i8* %0)
  store i32 %call, i32* %length, align 4
  %1 = load i8*, i8** %source.addr, align 4
  store i8* %1, i8** %it, align 4
  %2 = load i8*, i8** %source.addr, align 4
  %3 = load i32, i32* %length, align 4
  %add.ptr = getelementptr inbounds i8, i8* %2, i32 %3
  store i8* %add.ptr, i8** %end, align 4
  %4 = load i32, i32* %length, align 4
  %rem = urem i32 %4, 4
  %cmp = icmp ne i32 %rem, 0
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  store i32 1, i32* %retval, align 4
  br label %return

if.end:                                           ; preds = %entry
  br label %while.cond

while.cond:                                       ; preds = %if.end28, %if.end
  %5 = load i8*, i8** %it, align 4
  %6 = load i8*, i8** %end, align 4
  %cmp1 = icmp ne i8* %5, %6
  br i1 %cmp1, label %while.body, label %while.end

while.body:                                       ; preds = %while.cond
  %7 = load i8*, i8** %it, align 4
  %incdec.ptr = getelementptr inbounds i8, i8* %7, i32 1
  store i8* %incdec.ptr, i8** %it, align 4
  %8 = load i8, i8* %7, align 1
  store i8 %8, i8* %b1, align 1
  %9 = load i8*, i8** %it, align 4
  %incdec.ptr2 = getelementptr inbounds i8, i8* %9, i32 1
  store i8* %incdec.ptr2, i8** %it, align 4
  %10 = load i8, i8* %9, align 1
  store i8 %10, i8* %b2, align 1
  %11 = load i8*, i8** %it, align 4
  %incdec.ptr3 = getelementptr inbounds i8, i8* %11, i32 1
  store i8* %incdec.ptr3, i8** %it, align 4
  %12 = load i8, i8* %11, align 1
  store i8 %12, i8* %b3, align 1
  %13 = load i8*, i8** %it, align 4
  %incdec.ptr4 = getelementptr inbounds i8, i8* %13, i32 1
  store i8* %incdec.ptr4, i8** %it, align 4
  %14 = load i8, i8* %13, align 1
  store i8 %14, i8* %b4, align 1
  %15 = load i8, i8* %b1, align 1
  %call5 = call i32 @findIndex(i8 zeroext %15)
  store i32 %call5, i32* %i1, align 4
  %16 = load i8, i8* %b2, align 1
  %call6 = call i32 @findIndex(i8 zeroext %16)
  store i32 %call6, i32* %i2, align 4
  %17 = load i32, i32* %i1, align 4
  %shl = shl i32 %17, 2
  store i32 %shl, i32* %acc, align 4
  %18 = load i32, i32* %i2, align 4
  %shr = ashr i32 %18, 4
  %19 = load i32, i32* %acc, align 4
  %or = or i32 %19, %shr
  store i32 %or, i32* %acc, align 4
  %20 = load i32, i32* %acc, align 4
  %conv = trunc i32 %20 to i8
  %21 = load i8*, i8** %sink.addr, align 4
  %incdec.ptr7 = getelementptr inbounds i8, i8* %21, i32 1
  store i8* %incdec.ptr7, i8** %sink.addr, align 4
  store i8 %conv, i8* %21, align 1
  %22 = load i8, i8* %b3, align 1
  %conv8 = zext i8 %22 to i32
  %cmp9 = icmp ne i32 %conv8, 61
  br i1 %cmp9, label %if.then11, label %if.end28

if.then11:                                        ; preds = %while.body
  %23 = load i8, i8* %b3, align 1
  %call12 = call i32 @findIndex(i8 zeroext %23)
  store i32 %call12, i32* %i3, align 4
  %24 = load i32, i32* %i2, align 4
  %and = and i32 %24, 15
  %shl13 = shl i32 %and, 4
  store i32 %shl13, i32* %acc, align 4
  %25 = load i32, i32* %i3, align 4
  %shr14 = ashr i32 %25, 2
  %26 = load i32, i32* %acc, align 4
  %add = add nsw i32 %26, %shr14
  store i32 %add, i32* %acc, align 4
  %27 = load i32, i32* %acc, align 4
  %conv15 = trunc i32 %27 to i8
  %28 = load i8*, i8** %sink.addr, align 4
  %incdec.ptr16 = getelementptr inbounds i8, i8* %28, i32 1
  store i8* %incdec.ptr16, i8** %sink.addr, align 4
  store i8 %conv15, i8* %28, align 1
  %29 = load i8, i8* %b4, align 1
  %conv17 = zext i8 %29 to i32
  %cmp18 = icmp ne i32 %conv17, 61
  br i1 %cmp18, label %if.then20, label %if.end27

if.then20:                                        ; preds = %if.then11
  %30 = load i8, i8* %b4, align 1
  %call21 = call i32 @findIndex(i8 zeroext %30)
  store i32 %call21, i32* %i4, align 4
  %31 = load i32, i32* %i3, align 4
  %and22 = and i32 %31, 3
  %shl23 = shl i32 %and22, 6
  store i32 %shl23, i32* %acc, align 4
  %32 = load i32, i32* %i4, align 4
  %33 = load i32, i32* %acc, align 4
  %or24 = or i32 %33, %32
  store i32 %or24, i32* %acc, align 4
  %34 = load i32, i32* %acc, align 4
  %conv25 = trunc i32 %34 to i8
  %35 = load i8*, i8** %sink.addr, align 4
  %incdec.ptr26 = getelementptr inbounds i8, i8* %35, i32 1
  store i8* %incdec.ptr26, i8** %sink.addr, align 4
  store i8 %conv25, i8* %35, align 1
  br label %if.end27

if.end27:                                         ; preds = %if.then20, %if.then11
  br label %if.end28

if.end28:                                         ; preds = %if.end27, %while.body
  br label %while.cond

while.end:                                        ; preds = %while.cond
  %36 = load i8*, i8** %sink.addr, align 4
  store i8 0, i8* %36, align 1
  store i32 0, i32* %retval, align 4
  br label %return

return:                                           ; preds = %while.end, %if.then
  %37 = load i32, i32* %retval, align 4
  ret i32 %37
}

declare i32 @strlen(i8* %0) #1

; Function Attrs: noinline nounwind optnone
define hidden i32 @main() #0 {
entry:
  %retval = alloca i32, align 4
  %data = alloca [117 x i8], align 16
  %decoded = alloca [1024 x i8], align 16
  store i32 0, i32* %retval, align 4
  %0 = bitcast [117 x i8]* %data to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 16 %0, i8* align 16 getelementptr inbounds ([117 x i8], [117 x i8]* @__const.main.data, i32 0, i32 0), i32 117, i1 false)
  %arraydecay = getelementptr inbounds [117 x i8], [117 x i8]* %data, i32 0, i32 0
  %call = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str, i32 0, i32 0), i8* %arraydecay)
  %arraydecay1 = getelementptr inbounds [117 x i8], [117 x i8]* %data, i32 0, i32 0
  %arraydecay2 = getelementptr inbounds [1024 x i8], [1024 x i8]* %decoded, i32 0, i32 0
  %call3 = call i32 @decode(i8* %arraydecay1, i8* %arraydecay2)
  %arraydecay4 = getelementptr inbounds [1024 x i8], [1024 x i8]* %decoded, i32 0, i32 0
  %call5 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str, i32 0, i32 0), i8* %arraydecay4)
  ret i32 0
}

; Function Attrs: argmemonly nounwind willreturn
declare void @llvm.memcpy.p0i8.p0i8.i32(i8* noalias nocapture writeonly %0, i8* noalias nocapture readonly %1, i32 %2, i1 immarg %3) #2

declare i32 @printf(i8* %0, ...) #1

attributes #0 = { noinline nounwind optnone "correctly-rounded-divide-sqrt-fp-math"="false" "disable-tail-calls"="false" "frame-pointer"="none" "less-precise-fpmad"="false" "min-legal-vector-width"="0" "no-infs-fp-math"="false" "no-jump-tables"="false" "no-nans-fp-math"="false" "no-signed-zeros-fp-math"="false" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="generic" "unsafe-fp-math"="false" "use-soft-float"="false" }
attributes #1 = { "correctly-rounded-divide-sqrt-fp-math"="false" "disable-tail-calls"="false" "frame-pointer"="none" "less-precise-fpmad"="false" "no-infs-fp-math"="false" "no-nans-fp-math"="false" "no-signed-zeros-fp-math"="false" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="generic" "unsafe-fp-math"="false" "use-soft-float"="false" }
attributes #2 = { argmemonly nounwind willreturn }

!llvm.module.flags = !{!0}
!llvm.ident = !{!1}

!0 = !{i32 1, !"wchar_size", i32 4}
!1 = !{!"clang version 11.0.0 (https://github.com/Jacarte/llvm-project.git 0f6dea67136cc1e0b3d200eb2bb165628970c44b)"}

; extracted candidates

; *****
; For LLVM instruction:
;  %call = call i32 @strlen(i8* %0)
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %3 = load i32, i32* %length, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %4 = load i32, i32* %length, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %rem = urem i32 %4, 4
; Looking for a replacement for:
%0:i32 = var
%1:i32 = urem %0, 4:i32
infer %1

; *****
; For LLVM instruction:
;  %cmp = icmp ne i32 %rem, 0
; Looking for a replacement for:
%0:i32 = var
%1:i32 = urem %0, 4:i32
%2:i1 = ne 0:i32, %1
infer %2

; *****
; For LLVM instruction:
;  %cmp1 = icmp ne i8* %5, %6
; Looking for a replacement for:
%0:i32 = var
%1:i32 = var
%2:i1 = ne %0, %1
infer %2

; *****
; For LLVM instruction:
;  %8 = load i8, i8* %7, align 1
; Looking for a replacement for:
%0:i8 = var
infer %0

; *****
; For LLVM instruction:
;  %10 = load i8, i8* %9, align 1
; Looking for a replacement for:
%0:i8 = var
infer %0

; *****
; For LLVM instruction:
;  %12 = load i8, i8* %11, align 1
; Looking for a replacement for:
%0:i8 = var
infer %0

; *****
; For LLVM instruction:
;  %14 = load i8, i8* %13, align 1
; Looking for a replacement for:
%0:i8 = var
infer %0

; *****
; For LLVM instruction:
;  %15 = load i8, i8* %b1, align 1
; Looking for a replacement for:
%0:i8 = var
infer %0

; *****
; For LLVM instruction:
;  %call5 = call i32 @findIndex(i8 zeroext %15)
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %16 = load i8, i8* %b2, align 1
; Looking for a replacement for:
%0:i8 = var
infer %0

; *****
; For LLVM instruction:
;  %call6 = call i32 @findIndex(i8 zeroext %16)
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %17 = load i32, i32* %i1, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0 (demandedBits=00111111111111111111111111111111)

; *****
; For LLVM instruction:
;  %shl = shl i32 %17, 2
; Looking for a replacement for:
%0:i32 = var
%1:i32 = shl %0, 2:i32
infer %1

; *****
; For LLVM instruction:
;  %18 = load i32, i32* %i2, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0 (demandedBits=11111111111111111111111111110000)

; *****
; For LLVM instruction:
;  %shr = ashr i32 %18, 4
; Looking for a replacement for:
%0:i32 = var
%1:i32 = ashr %0, 4:i32
infer %1

; *****
; For LLVM instruction:
;  %19 = load i32, i32* %acc, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %or = or i32 %19, %shr
; Looking for a replacement for:
%0:i32 = var
%1:i32 = var
%2:i32 = ashr %1, 4:i32
%3:i32 = or %0, %2
infer %3

; *****
; For LLVM instruction:
;  %20 = load i32, i32* %acc, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0 (demandedBits=00000000000000000000000011111111)

; *****
; For LLVM instruction:
;  %conv = trunc i32 %20 to i8
; Looking for a replacement for:
%0:i32 = var
%1:i8 = trunc %0
infer %1

; *****
; For LLVM instruction:
;  %22 = load i8, i8* %b3, align 1
; Looking for a replacement for:
%0:i8 = var
infer %0

; *****
; For LLVM instruction:
;  %conv8 = zext i8 %22 to i32
; Looking for a replacement for:
%0:i8 = var
%1:i32 = zext %0
infer %1

; *****
; For LLVM instruction:
;  %cmp9 = icmp ne i32 %conv8, 61
; Looking for a replacement for:
%0:i8 = var
%1:i32 = zext %0
%2:i1 = ne 61:i32, %1
infer %2

; *****
; For LLVM instruction:
;  %23 = load i8, i8* %b3, align 1
; Looking for a replacement for:
%0:i8 = var
infer %0

; *****
; For LLVM instruction:
;  %call12 = call i32 @findIndex(i8 zeroext %23)
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %24 = load i32, i32* %i2, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0 (demandedBits=00000000000000000000000000001111)

; *****
; For LLVM instruction:
;  %and = and i32 %24, 15
; Looking for a replacement for:
%0:i32 = var
%1:i32 = and 15:i32, %0
infer %1 (demandedBits=00001111111111111111111111111111)

; *****
; For LLVM instruction:
;  %shl13 = shl i32 %and, 4
; Looking for a replacement for:
%0:i32 = var
%1:i32 = and 15:i32, %0
%2:i32 = shl %1, 4:i32
infer %2

; *****
; For LLVM instruction:
;  %25 = load i32, i32* %i3, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0 (demandedBits=11111111111111111111111111111100)

; *****
; For LLVM instruction:
;  %shr14 = ashr i32 %25, 2
; Looking for a replacement for:
%0:i32 = var
%1:i32 = ashr %0, 2:i32
infer %1

; *****
; For LLVM instruction:
;  %26 = load i32, i32* %acc, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %add = add nsw i32 %26, %shr14
; Looking for a replacement for:
%0:i32 = var
%1:i32 = var
%2:i32 = ashr %1, 2:i32
%3:i32 = addnsw %0, %2
infer %3

; *****
; For LLVM instruction:
;  %27 = load i32, i32* %acc, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0 (demandedBits=00000000000000000000000011111111)

; *****
; For LLVM instruction:
;  %conv15 = trunc i32 %27 to i8
; Looking for a replacement for:
%0:i32 = var
%1:i8 = trunc %0
infer %1

; *****
; For LLVM instruction:
;  %29 = load i8, i8* %b4, align 1
; Looking for a replacement for:
%0:i8 = var
infer %0

; *****
; For LLVM instruction:
;  %conv17 = zext i8 %29 to i32
; Looking for a replacement for:
%0:i8 = var
%1:i32 = zext %0
infer %1

; *****
; For LLVM instruction:
;  %cmp18 = icmp ne i32 %conv17, 61
; Looking for a replacement for:
%0:i8 = var
%1:i32 = zext %0
%2:i1 = ne 61:i32, %1
infer %2

; *****
; For LLVM instruction:
;  %30 = load i8, i8* %b4, align 1
; Looking for a replacement for:
%0:i8 = var
infer %0

; *****
; For LLVM instruction:
;  %call21 = call i32 @findIndex(i8 zeroext %30)
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %31 = load i32, i32* %i3, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0 (demandedBits=00000000000000000000000000000011)

; *****
; For LLVM instruction:
;  %and22 = and i32 %31, 3
; Looking for a replacement for:
%0:i32 = var
%1:i32 = and 3:i32, %0
infer %1 (demandedBits=00000011111111111111111111111111)

; *****
; For LLVM instruction:
;  %shl23 = shl i32 %and22, 6
; Looking for a replacement for:
%0:i32 = var
%1:i32 = and 3:i32, %0
%2:i32 = shl %1, 6:i32
infer %2

; *****
; For LLVM instruction:
;  %32 = load i32, i32* %i4, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %33 = load i32, i32* %acc, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %or24 = or i32 %33, %32
; Looking for a replacement for:
%0:i32 = var
%1:i32 = var
%2:i32 = or %0, %1
infer %2

; *****
; For LLVM instruction:
;  %34 = load i32, i32* %acc, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0 (demandedBits=00000000000000000000000011111111)

; *****
; For LLVM instruction:
;  %conv25 = trunc i32 %34 to i8
; Looking for a replacement for:
%0:i32 = var
%1:i8 = trunc %0
infer %1

; *****
; For LLVM instruction:
;  %37 = load i32, i32* %retval, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0
got 2 candidates from LHS

-------------------------------------------------
%0:i32 = var
%1:i32 = urem %0, 4:i32
infer %1


--------------------------------
guess 0

%0:i32 = var ; reservedconst_1

Cost = 0
first query is SAT, returning the model:
reservedconst_1: 0
0 th attempt: second query is SAT-- constant doesn't work
first query is SAT, returning the model:
reservedconst_1: 3
1 th attempt: second query is SAT-- constant doesn't work
first query is UNSAT-- no more guesses

--------------------------------
guess 1

%0:i32 = var

Cost = 0
second query is SAT-- constant doesn't work
Dataflow Pruned 0/0
There are 2 Guesses
There are 0 RHSs before deduplication
There are 0 RHSs after deduplication
got 3 candidates from LHS

-------------------------------------------------
%0:i32 = var
%1:i32 = urem %0, 4:i32
%2:i1 = ne 0:i32, %1
infer %2


--------------------------------
guess 0

%0:i1 = var ; reservedconst_1

Cost = 0
first query is SAT, returning the model:
reservedconst_1: 0
0 th attempt: second query is SAT-- constant doesn't work
first query is SAT, returning the model:
reservedconst_1: -1
1 th attempt: second query is SAT-- constant doesn't work
first query is UNSAT-- no more guesses
Dataflow Pruned 0/0
There are 1 Guesses
There are 0 RHSs before deduplication
There are 0 RHSs after deduplication
got 3 candidates from LHS

-------------------------------------------------
%0:i32 = var
%1:i32 = var
%2:i1 = ne %0, %1
infer %2


--------------------------------
guess 0

%0:i1 = var ; reservedconst_1

Cost = 0
first query is SAT, returning the model:
reservedconst_1: 0
0 th attempt: second query is SAT-- constant doesn't work
first query is SAT, returning the model:
reservedconst_1: -1
1 th attempt: second query is SAT-- constant doesn't work
first query is UNSAT-- no more guesses
Dataflow Pruned 0/0
There are 1 Guesses
There are 0 RHSs before deduplication
There are 0 RHSs after deduplication
got 1 candidates from LHS

-------------------------------------------------
%0:i32 = var
infer %0 (demandedBits=00111111111111111111111111111111)


--------------------------------
guess 0

%0:i32 = var ; reservedconst_1

Cost = 0
first query is SAT, returning the model:
reservedconst_1: 0
0 th attempt: second query is SAT-- constant doesn't work
first query is SAT, returning the model:
reservedconst_1: 1073741823
1 th attempt: second query is SAT-- constant doesn't work
first query is UNSAT-- no more guesses
Dataflow Pruned 0/0
There are 1 Guesses
There are 0 RHSs before deduplication
There are 0 RHSs after deduplication
got 2 candidates from LHS

-------------------------------------------------
%0:i32 = var
%1:i32 = shl %0, 2:i32
infer %1


--------------------------------
guess 0

%0:i32 = var ; reservedconst_1

Cost = 0
first query is SAT, returning the model:
reservedconst_1: 0
0 th attempt: second query is SAT-- constant doesn't work
first query is SAT, returning the model:
reservedconst_1: -4
1 th attempt: second query is SAT-- constant doesn't work
first query is UNSAT-- no more guesses

--------------------------------
guess 1

%0:i32 = var

Cost = 0
second query is SAT-- constant doesn't work
Dataflow Pruned 0/0
There are 2 Guesses
There are 0 RHSs before deduplication
There are 0 RHSs after deduplication
got 1 candidates from LHS

-------------------------------------------------
%0:i32 = var
infer %0 (demandedBits=11111111111111111111111111110000)


--------------------------------
guess 0

%0:i32 = var ; reservedconst_1

Cost = 0
first query is SAT, returning the model:
reservedconst_1: 0
0 th attempt: second query is SAT-- constant doesn't work
first query is SAT, returning the model:
reservedconst_1: -16
1 th attempt: second query is SAT-- constant doesn't work
first query is UNSAT-- no more guesses
Dataflow Pruned 0/0
There are 1 Guesses
There are 0 RHSs before deduplication
There are 0 RHSs after deduplication
got 2 candidates from LHS

-------------------------------------------------
%0:i32 = var
%1:i32 = ashr %0, 4:i32
infer %1


--------------------------------
guess 0

%0:i32 = var ; reservedconst_1

Cost = 0
first query is SAT, returning the model:
reservedconst_1: 0
0 th attempt: second query is SAT-- constant doesn't work
first query is SAT, returning the model:
reservedconst_1: 67108864
1 th attempt: second query is SAT-- constant doesn't work
first query is UNSAT-- no more guesses

--------------------------------
guess 1

%0:i32 = var

Cost = 0
second query is SAT-- constant doesn't work
Dataflow Pruned 0/0
There are 2 Guesses
There are 0 RHSs before deduplication
There are 0 RHSs after deduplication
got 4 candidates from LHS

-------------------------------------------------
%0:i32 = var
%1:i32 = var
%2:i32 = ashr %1, 4:i32
%3:i32 = or %0, %2
infer %3


--------------------------------
guess 0

%0:i32 = var ; reservedconst_1

Cost = 0
first query is SAT, returning the model:
reservedconst_1: 0
0 th attempt: second query is SAT-- constant doesn't work
first query is SAT, returning the model:
reservedconst_1: 67108864
1 th attempt: second query is SAT-- constant doesn't work
first query is UNSAT-- no more guesses

--------------------------------
guess 1

%0:i32 = var

Cost = 0
second query is SAT-- constant doesn't work

--------------------------------
guess 2

%0:i32 = var

Cost = 0
second query is SAT-- constant doesn't work

--------------------------------
guess 3

%0:i32 = var
%1:i32 = ashr %0, 4:i32

Cost = 1
second query is SAT-- constant doesn't work
Dataflow Pruned 0/0
There are 4 Guesses
There are 0 RHSs before deduplication
There are 0 RHSs after deduplication
got 1 candidates from LHS

-------------------------------------------------
%0:i32 = var
infer %0 (demandedBits=00000000000000000000000011111111)


--------------------------------
guess 0

%0:i32 = var ; reservedconst_1

Cost = 0
first query is SAT, returning the model:
reservedconst_1: 0
0 th attempt: second query is SAT-- constant doesn't work
first query is SAT, returning the model:
reservedconst_1: 255
1 th attempt: second query is SAT-- constant doesn't work
first query is UNSAT-- no more guesses
Dataflow Pruned 0/0
There are 1 Guesses
There are 0 RHSs before deduplication
There are 0 RHSs after deduplication
got 2 candidates from LHS

-------------------------------------------------
%0:i32 = var
%1:i8 = trunc %0
infer %1


--------------------------------
guess 0

%0:i8 = var ; reservedconst_1

Cost = 0
first query is SAT, returning the model:
reservedconst_1: 0
0 th attempt: second query is SAT-- constant doesn't work
first query is SAT, returning the model:
reservedconst_1: -1
1 th attempt: second query is SAT-- constant doesn't work
first query is UNSAT-- no more guesses
Dataflow Pruned 0/0
There are 1 Guesses
There are 0 RHSs before deduplication
There are 0 RHSs after deduplication
got 3 candidates from LHS

-------------------------------------------------
%0:i8 = var
%1:i32 = zext %0
%2:i1 = ne 61:i32, %1
infer %2


--------------------------------
guess 0

%0:i1 = var ; reservedconst_1

Cost = 0
first query is SAT, returning the model:
reservedconst_1: -1
0 th attempt: second query is SAT-- constant doesn't work
first query is SAT, returning the model:
reservedconst_1: 0
1 th attempt: second query is SAT-- constant doesn't work
first query is UNSAT-- no more guesses
Dataflow Pruned 0/0
There are 1 Guesses
There are 0 RHSs before deduplication
There are 0 RHSs after deduplication
got 1 candidates from LHS

-------------------------------------------------
%0:i32 = var
infer %0 (demandedBits=00000000000000000000000000001111)


--------------------------------
guess 0

%0:i32 = var ; reservedconst_1

Cost = 0
first query is SAT, returning the model:
reservedconst_1: 0
0 th attempt: second query is SAT-- constant doesn't work
first query is SAT, returning the model:
reservedconst_1: 15
1 th attempt: second query is SAT-- constant doesn't work
first query is UNSAT-- no more guesses
Dataflow Pruned 0/0
There are 1 Guesses
There are 0 RHSs before deduplication
There are 0 RHSs after deduplication
got 2 candidates from LHS

-------------------------------------------------
%0:i32 = var
%1:i32 = and 15:i32, %0
infer %1 (demandedBits=00001111111111111111111111111111)


--------------------------------
guess 0

%0:i32 = var ; reservedconst_1

Cost = 0
first query is SAT, returning the model:
reservedconst_1: 0
0 th attempt: second query is SAT-- constant doesn't work
first query is SAT, returning the model:
reservedconst_1: 15
1 th attempt: second query is SAT-- constant doesn't work
first query is UNSAT-- no more guesses

--------------------------------
guess 1

%0:i32 = var

Cost = 0
second query is SAT-- constant doesn't work
Dataflow Pruned 0/0
There are 2 Guesses
There are 0 RHSs before deduplication
There are 0 RHSs after deduplication
got 3 candidates from LHS

-------------------------------------------------
%0:i32 = var
%1:i32 = and 15:i32, %0
%2:i32 = shl %1, 4:i32
infer %2


--------------------------------
guess 0

%0:i32 = var ; reservedconst_1

Cost = 0
first query is SAT, returning the model:
reservedconst_1: 0
0 th attempt: second query is SAT-- constant doesn't work
first query is SAT, returning the model:
reservedconst_1: 240
1 th attempt: second query is SAT-- constant doesn't work
first query is UNSAT-- no more guesses

--------------------------------
guess 1

%0:i32 = var

Cost = 0
second query is SAT-- constant doesn't work

--------------------------------
guess 2

%0:i32 = var
%1:i32 = and 15:i32, %0

Cost = 1
second query is SAT-- constant doesn't work
Dataflow Pruned 0/0
There are 3 Guesses
There are 0 RHSs before deduplication
There are 0 RHSs after deduplication
got 1 candidates from LHS

-------------------------------------------------
%0:i32 = var
infer %0 (demandedBits=11111111111111111111111111111100)


--------------------------------
guess 0

%0:i32 = var ; reservedconst_1

Cost = 0
first query is SAT, returning the model:
reservedconst_1: 0
0 th attempt: second query is SAT-- constant doesn't work
first query is SAT, returning the model:
reservedconst_1: -4
1 th attempt: second query is SAT-- constant doesn't work
first query is UNSAT-- no more guesses
Dataflow Pruned 0/0
There are 1 Guesses
There are 0 RHSs before deduplication
There are 0 RHSs after deduplication
got 2 candidates from LHS

-------------------------------------------------
%0:i32 = var
%1:i32 = ashr %0, 2:i32
infer %1


--------------------------------
guess 0

%0:i32 = var ; reservedconst_1

Cost = 0
first query is SAT, returning the model:
reservedconst_1: 0
0 th attempt: second query is SAT-- constant doesn't work
first query is SAT, returning the model:
reservedconst_1: 268435456
1 th attempt: second query is SAT-- constant doesn't work
first query is UNSAT-- no more guesses

--------------------------------
guess 1

%0:i32 = var

Cost = 0
second query is SAT-- constant doesn't work
Dataflow Pruned 0/0
There are 2 Guesses
There are 0 RHSs before deduplication
There are 0 RHSs after deduplication
got 4 candidates from LHS

-------------------------------------------------
%0:i32 = var
%1:i32 = var
%2:i32 = ashr %1, 2:i32
%3:i32 = addnsw %0, %2
infer %3


--------------------------------
guess 0

%0:i32 = var ; reservedconst_1

Cost = 0
first query is SAT, returning the model:
reservedconst_1: 0
0 th attempt: second query is SAT-- constant doesn't work
first query is SAT, returning the model:
reservedconst_1: -2
1 th attempt: second query is SAT-- constant doesn't work
first query is UNSAT-- no more guesses

--------------------------------
guess 1

%0:i32 = var

Cost = 0
second query is SAT-- constant doesn't work

--------------------------------
guess 2

%0:i32 = var

Cost = 0
second query is SAT-- constant doesn't work

--------------------------------
guess 3

%0:i32 = var
%1:i32 = ashr %0, 2:i32

Cost = 1
second query is SAT-- constant doesn't work
Dataflow Pruned 0/0
There are 4 Guesses
There are 0 RHSs before deduplication
There are 0 RHSs after deduplication
got 1 candidates from LHS

-------------------------------------------------
%0:i32 = var
infer %0 (demandedBits=00000000000000000000000000000011)


--------------------------------
guess 0

%0:i32 = var ; reservedconst_1

Cost = 0
first query is SAT, returning the model:
reservedconst_1: 0
0 th attempt: second query is SAT-- constant doesn't work
first query is SAT, returning the model:
reservedconst_1: 3
1 th attempt: second query is SAT-- constant doesn't work
first query is UNSAT-- no more guesses
Dataflow Pruned 0/0
There are 1 Guesses
There are 0 RHSs before deduplication
There are 0 RHSs after deduplication
got 2 candidates from LHS

-------------------------------------------------
%0:i32 = var
%1:i32 = and 3:i32, %0
infer %1 (demandedBits=00000011111111111111111111111111)


--------------------------------
guess 0

%0:i32 = var ; reservedconst_1

Cost = 0
first query is SAT, returning the model:
reservedconst_1: 0
0 th attempt: second query is SAT-- constant doesn't work
first query is SAT, returning the model:
reservedconst_1: 3
1 th attempt: second query is SAT-- constant doesn't work
first query is UNSAT-- no more guesses

--------------------------------
guess 1

%0:i32 = var

Cost = 0
second query is SAT-- constant doesn't work
Dataflow Pruned 0/0
There are 2 Guesses
There are 0 RHSs before deduplication
There are 0 RHSs after deduplication
got 3 candidates from LHS

-------------------------------------------------
%0:i32 = var
%1:i32 = and 3:i32, %0
%2:i32 = shl %1, 6:i32
infer %2


--------------------------------
guess 0

%0:i32 = var ; reservedconst_1

Cost = 0
first query is SAT, returning the model:
reservedconst_1: 0
0 th attempt: second query is SAT-- constant doesn't work
first query is SAT, returning the model:
reservedconst_1: 192
1 th attempt: second query is SAT-- constant doesn't work
first query is UNSAT-- no more guesses

--------------------------------
guess 1

%0:i32 = var

Cost = 0
second query is SAT-- constant doesn't work

--------------------------------
guess 2

%0:i32 = var
%1:i32 = and 3:i32, %0

Cost = 1
second query is SAT-- constant doesn't work
Dataflow Pruned 0/0
There are 3 Guesses
There are 0 RHSs before deduplication
There are 0 RHSs after deduplication
got 3 candidates from LHS

-------------------------------------------------
%0:i32 = var
%1:i32 = var
%2:i32 = or %0, %1
infer %2


--------------------------------
guess 0

%0:i32 = var ; reservedconst_1

Cost = 0
first query is SAT, returning the model:
reservedconst_1: 0
0 th attempt: second query is SAT-- constant doesn't work
first query is SAT, returning the model:
reservedconst_1: -1
1 th attempt: second query is SAT-- constant doesn't work
first query is UNSAT-- no more guesses

--------------------------------
guess 1

%0:i32 = var

Cost = 0
second query is SAT-- constant doesn't work

--------------------------------
guess 2

%0:i32 = var

Cost = 0
second query is SAT-- constant doesn't work
Dataflow Pruned 0/0
There are 3 Guesses
There are 0 RHSs before deduplication
There are 0 RHSs after deduplication
#########################################################
; exiting Souper's runOnFunction() for decode()

; entering Souper's runOnFunction() for main()

; ModuleID = './Base64_decode_data.c.bc'
source_filename = "./Base64_decode_data.c"
target datalayout = "e-m:e-p:32:32-i64:64-n32:64-S128"
target triple = "wasm32-unknown-wasi"

@BASE64 = hidden constant [65 x i8] c"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\00", align 16
@__const.main.data = private unnamed_addr constant [117 x i8] c"VG8gZXJyIGlzIGh1bWFuLCBidXQgdG8gcmVhbGx5IGZvdWwgdGhpbmdzIHVwIHlvdSBuZWVkIGEgY29tcHV0ZXIuCiAgICAtLVBhdWwgUi5FaHJsaWNo\00", align 16
@.str = private unnamed_addr constant [5 x i8] c"%s\0A\0A\00", align 1
@llvm.used = appending global [1 x i8*] [i8* bitcast (i32 ()* @__main_void to i8*)], section "llvm.metadata"

@__main_void = alias i32 (), i32 ()* @main

; Function Attrs: noinline nounwind optnone
define hidden i32 @findIndex(i8 zeroext %val) #0 {
entry:
  %retval = alloca i32, align 4
  %val.addr = alloca i8, align 1
  store i8 %val, i8* %val.addr, align 1
  %0 = load i8, i8* %val.addr, align 1
  %conv = zext i8 %0 to i32
  %cmp = icmp sle i32 65, %conv
  br i1 %cmp, label %land.lhs.true, label %if.end

land.lhs.true:                                    ; preds = %entry
  %1 = load i8, i8* %val.addr, align 1
  %conv2 = zext i8 %1 to i32
  %cmp3 = icmp sle i32 %conv2, 90
  br i1 %cmp3, label %if.then, label %if.end

if.then:                                          ; preds = %land.lhs.true
  %2 = load i8, i8* %val.addr, align 1
  %conv5 = zext i8 %2 to i32
  %sub = sub nsw i32 %conv5, 65
  store i32 %sub, i32* %retval, align 4
  br label %return

if.end:                                           ; preds = %land.lhs.true, %entry
  %3 = load i8, i8* %val.addr, align 1
  %conv6 = zext i8 %3 to i32
  %cmp7 = icmp sle i32 97, %conv6
  br i1 %cmp7, label %land.lhs.true9, label %if.end16

land.lhs.true9:                                   ; preds = %if.end
  %4 = load i8, i8* %val.addr, align 1
  %conv10 = zext i8 %4 to i32
  %cmp11 = icmp sle i32 %conv10, 122
  br i1 %cmp11, label %if.then13, label %if.end16

if.then13:                                        ; preds = %land.lhs.true9
  %5 = load i8, i8* %val.addr, align 1
  %conv14 = zext i8 %5 to i32
  %sub15 = sub nsw i32 %conv14, 97
  %add = add nsw i32 %sub15, 26
  store i32 %add, i32* %retval, align 4
  br label %return

if.end16:                                         ; preds = %land.lhs.true9, %if.end
  %6 = load i8, i8* %val.addr, align 1
  %conv17 = zext i8 %6 to i32
  %cmp18 = icmp sle i32 48, %conv17
  br i1 %cmp18, label %land.lhs.true20, label %if.end28

land.lhs.true20:                                  ; preds = %if.end16
  %7 = load i8, i8* %val.addr, align 1
  %conv21 = zext i8 %7 to i32
  %cmp22 = icmp sle i32 %conv21, 57
  br i1 %cmp22, label %if.then24, label %if.end28

if.then24:                                        ; preds = %land.lhs.true20
  %8 = load i8, i8* %val.addr, align 1
  %conv25 = zext i8 %8 to i32
  %sub26 = sub nsw i32 %conv25, 48
  %add27 = add nsw i32 %sub26, 52
  store i32 %add27, i32* %retval, align 4
  br label %return

if.end28:                                         ; preds = %land.lhs.true20, %if.end16
  %9 = load i8, i8* %val.addr, align 1
  %conv29 = zext i8 %9 to i32
  %cmp30 = icmp eq i32 %conv29, 43
  br i1 %cmp30, label %if.then32, label %if.end33

if.then32:                                        ; preds = %if.end28
  store i32 62, i32* %retval, align 4
  br label %return

if.end33:                                         ; preds = %if.end28
  %10 = load i8, i8* %val.addr, align 1
  %conv34 = zext i8 %10 to i32
  %cmp35 = icmp eq i32 %conv34, 47
  br i1 %cmp35, label %if.then37, label %if.end38

if.then37:                                        ; preds = %if.end33
  store i32 63, i32* %retval, align 4
  br label %return

if.end38:                                         ; preds = %if.end33
  store i32 -1, i32* %retval, align 4
  br label %return

return:                                           ; preds = %if.end38, %if.then37, %if.then32, %if.then24, %if.then13, %if.then
  %11 = load i32, i32* %retval, align 4
  ret i32 %11
}

; Function Attrs: noinline nounwind optnone
define hidden i32 @decode(i8* %source, i8* %sink) #0 {
entry:
  %retval = alloca i32, align 4
  %source.addr = alloca i8*, align 4
  %sink.addr = alloca i8*, align 4
  %length = alloca i32, align 4
  %it = alloca i8*, align 4
  %end = alloca i8*, align 4
  %acc = alloca i32, align 4
  %b1 = alloca i8, align 1
  %b2 = alloca i8, align 1
  %b3 = alloca i8, align 1
  %b4 = alloca i8, align 1
  %i1 = alloca i32, align 4
  %i2 = alloca i32, align 4
  %i3 = alloca i32, align 4
  %i4 = alloca i32, align 4
  store i8* %source, i8** %source.addr, align 4
  store i8* %sink, i8** %sink.addr, align 4
  %0 = load i8*, i8** %source.addr, align 4
  %call = call i32 @strlen(i8* %0)
  store i32 %call, i32* %length, align 4
  %1 = load i8*, i8** %source.addr, align 4
  store i8* %1, i8** %it, align 4
  %2 = load i8*, i8** %source.addr, align 4
  %3 = load i32, i32* %length, align 4
  %add.ptr = getelementptr inbounds i8, i8* %2, i32 %3
  store i8* %add.ptr, i8** %end, align 4
  %4 = load i32, i32* %length, align 4
  %rem = urem i32 %4, 4
  %cmp = icmp ne i32 %rem, 0
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  store i32 1, i32* %retval, align 4
  br label %return

if.end:                                           ; preds = %entry
  br label %while.cond

while.cond:                                       ; preds = %if.end28, %if.end
  %5 = load i8*, i8** %it, align 4
  %6 = load i8*, i8** %end, align 4
  %cmp1 = icmp ne i8* %5, %6
  br i1 %cmp1, label %while.body, label %while.end

while.body:                                       ; preds = %while.cond
  %7 = load i8*, i8** %it, align 4
  %incdec.ptr = getelementptr inbounds i8, i8* %7, i32 1
  store i8* %incdec.ptr, i8** %it, align 4
  %8 = load i8, i8* %7, align 1
  store i8 %8, i8* %b1, align 1
  %9 = load i8*, i8** %it, align 4
  %incdec.ptr2 = getelementptr inbounds i8, i8* %9, i32 1
  store i8* %incdec.ptr2, i8** %it, align 4
  %10 = load i8, i8* %9, align 1
  store i8 %10, i8* %b2, align 1
  %11 = load i8*, i8** %it, align 4
  %incdec.ptr3 = getelementptr inbounds i8, i8* %11, i32 1
  store i8* %incdec.ptr3, i8** %it, align 4
  %12 = load i8, i8* %11, align 1
  store i8 %12, i8* %b3, align 1
  %13 = load i8*, i8** %it, align 4
  %incdec.ptr4 = getelementptr inbounds i8, i8* %13, i32 1
  store i8* %incdec.ptr4, i8** %it, align 4
  %14 = load i8, i8* %13, align 1
  store i8 %14, i8* %b4, align 1
  %15 = load i8, i8* %b1, align 1
  %call5 = call i32 @findIndex(i8 zeroext %15)
  store i32 %call5, i32* %i1, align 4
  %16 = load i8, i8* %b2, align 1
  %call6 = call i32 @findIndex(i8 zeroext %16)
  store i32 %call6, i32* %i2, align 4
  %17 = load i32, i32* %i1, align 4
  %shl = shl i32 %17, 2
  store i32 %shl, i32* %acc, align 4
  %18 = load i32, i32* %i2, align 4
  %shr = ashr i32 %18, 4
  %19 = load i32, i32* %acc, align 4
  %or = or i32 %19, %shr
  store i32 %or, i32* %acc, align 4
  %20 = load i32, i32* %acc, align 4
  %conv = trunc i32 %20 to i8
  %21 = load i8*, i8** %sink.addr, align 4
  %incdec.ptr7 = getelementptr inbounds i8, i8* %21, i32 1
  store i8* %incdec.ptr7, i8** %sink.addr, align 4
  store i8 %conv, i8* %21, align 1
  %22 = load i8, i8* %b3, align 1
  %conv8 = zext i8 %22 to i32
  %cmp9 = icmp ne i32 %conv8, 61
  br i1 %cmp9, label %if.then11, label %if.end28

if.then11:                                        ; preds = %while.body
  %23 = load i8, i8* %b3, align 1
  %call12 = call i32 @findIndex(i8 zeroext %23)
  store i32 %call12, i32* %i3, align 4
  %24 = load i32, i32* %i2, align 4
  %and = and i32 %24, 15
  %shl13 = shl i32 %and, 4
  store i32 %shl13, i32* %acc, align 4
  %25 = load i32, i32* %i3, align 4
  %shr14 = ashr i32 %25, 2
  %26 = load i32, i32* %acc, align 4
  %add = add nsw i32 %26, %shr14
  store i32 %add, i32* %acc, align 4
  %27 = load i32, i32* %acc, align 4
  %conv15 = trunc i32 %27 to i8
  %28 = load i8*, i8** %sink.addr, align 4
  %incdec.ptr16 = getelementptr inbounds i8, i8* %28, i32 1
  store i8* %incdec.ptr16, i8** %sink.addr, align 4
  store i8 %conv15, i8* %28, align 1
  %29 = load i8, i8* %b4, align 1
  %conv17 = zext i8 %29 to i32
  %cmp18 = icmp ne i32 %conv17, 61
  br i1 %cmp18, label %if.then20, label %if.end27

if.then20:                                        ; preds = %if.then11
  %30 = load i8, i8* %b4, align 1
  %call21 = call i32 @findIndex(i8 zeroext %30)
  store i32 %call21, i32* %i4, align 4
  %31 = load i32, i32* %i3, align 4
  %and22 = and i32 %31, 3
  %shl23 = shl i32 %and22, 6
  store i32 %shl23, i32* %acc, align 4
  %32 = load i32, i32* %i4, align 4
  %33 = load i32, i32* %acc, align 4
  %or24 = or i32 %33, %32
  store i32 %or24, i32* %acc, align 4
  %34 = load i32, i32* %acc, align 4
  %conv25 = trunc i32 %34 to i8
  %35 = load i8*, i8** %sink.addr, align 4
  %incdec.ptr26 = getelementptr inbounds i8, i8* %35, i32 1
  store i8* %incdec.ptr26, i8** %sink.addr, align 4
  store i8 %conv25, i8* %35, align 1
  br label %if.end27

if.end27:                                         ; preds = %if.then20, %if.then11
  br label %if.end28

if.end28:                                         ; preds = %if.end27, %while.body
  br label %while.cond

while.end:                                        ; preds = %while.cond
  %36 = load i8*, i8** %sink.addr, align 4
  store i8 0, i8* %36, align 1
  store i32 0, i32* %retval, align 4
  br label %return

return:                                           ; preds = %while.end, %if.then
  %37 = load i32, i32* %retval, align 4
  ret i32 %37
}

declare i32 @strlen(i8* %0) #1

; Function Attrs: noinline nounwind optnone
define hidden i32 @main() #0 {
entry:
  %retval = alloca i32, align 4
  %data = alloca [117 x i8], align 16
  %decoded = alloca [1024 x i8], align 16
  store i32 0, i32* %retval, align 4
  %0 = bitcast [117 x i8]* %data to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 16 %0, i8* align 16 getelementptr inbounds ([117 x i8], [117 x i8]* @__const.main.data, i32 0, i32 0), i32 117, i1 false)
  %arraydecay = getelementptr inbounds [117 x i8], [117 x i8]* %data, i32 0, i32 0
  %call = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str, i32 0, i32 0), i8* %arraydecay)
  %arraydecay1 = getelementptr inbounds [117 x i8], [117 x i8]* %data, i32 0, i32 0
  %arraydecay2 = getelementptr inbounds [1024 x i8], [1024 x i8]* %decoded, i32 0, i32 0
  %call3 = call i32 @decode(i8* %arraydecay1, i8* %arraydecay2)
  %arraydecay4 = getelementptr inbounds [1024 x i8], [1024 x i8]* %decoded, i32 0, i32 0
  %call5 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str, i32 0, i32 0), i8* %arraydecay4)
  ret i32 0
}

; Function Attrs: argmemonly nounwind willreturn
declare void @llvm.memcpy.p0i8.p0i8.i32(i8* noalias nocapture writeonly %0, i8* noalias nocapture readonly %1, i32 %2, i1 immarg %3) #2

declare i32 @printf(i8* %0, ...) #1

attributes #0 = { noinline nounwind optnone "correctly-rounded-divide-sqrt-fp-math"="false" "disable-tail-calls"="false" "frame-pointer"="none" "less-precise-fpmad"="false" "min-legal-vector-width"="0" "no-infs-fp-math"="false" "no-jump-tables"="false" "no-nans-fp-math"="false" "no-signed-zeros-fp-math"="false" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="generic" "unsafe-fp-math"="false" "use-soft-float"="false" }
attributes #1 = { "correctly-rounded-divide-sqrt-fp-math"="false" "disable-tail-calls"="false" "frame-pointer"="none" "less-precise-fpmad"="false" "no-infs-fp-math"="false" "no-nans-fp-math"="false" "no-signed-zeros-fp-math"="false" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="generic" "unsafe-fp-math"="false" "use-soft-float"="false" }
attributes #2 = { argmemonly nounwind willreturn }

!llvm.module.flags = !{!0}
!llvm.ident = !{!1}

!0 = !{i32 1, !"wchar_size", i32 4}
!1 = !{!"clang version 11.0.0 (https://github.com/Jacarte/llvm-project.git 0f6dea67136cc1e0b3d200eb2bb165628970c44b)"}

; extracted candidates
#########################################################
; exiting Souper's runOnFunction() for main()
Total of 0 replacements done on this module
Total of 0 replacements candidates on this module
