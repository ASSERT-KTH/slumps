
Entering the Souper pass's runOnModule()


; entering Souper's runOnFunction() for precedenceCheck()

; ModuleID = './Parsing-RPN_to_infix_conversion.c.bc'
source_filename = "./Parsing-RPN_to_infix_conversion.c"
target datalayout = "e-m:e-p:32:32-i64:64-n32:64-S128"
target triple = "wasm32-unknown-wasi"

%struct.elem = type { [10 x i8], %struct.elem*, %struct.elem* }

@counter = hidden global i32 0, align 4
@.str = private unnamed_addr constant [2 x i8] c"(\00", align 1
@.str.1 = private unnamed_addr constant [2 x i8] c")\00", align 1
@.str.2 = private unnamed_addr constant [5 x i8] c" %s \00", align 1
@.str.3 = private unnamed_addr constant [15 x i8] c"\0AInvalid RPN !\00", align 1
@components = hidden global i8** null, align 4
@.str.4 = private unnamed_addr constant [2 x i8] c"\0A\00", align 1
@.str.5 = private unnamed_addr constant [2 x i8] c" \00", align 1
@.str.6 = private unnamed_addr constant [95 x i8] c"Usage : %s <RPN expression enclosed by quotes> <optional parameter to trace the build process>\00", align 1
@.str.7 = private unnamed_addr constant [27 x i8] c"\0AFinal infix expression : \00", align 1

; Function Attrs: noinline nounwind optnone
define hidden i32 @precedenceCheck(i8 signext %oper1, i8 signext %oper2) #0 {
entry:
  %oper1.addr = alloca i8, align 1
  %oper2.addr = alloca i8, align 1
  store i8 %oper1, i8* %oper1.addr, align 1
  store i8 %oper2, i8* %oper2.addr, align 1
  %0 = load i8, i8* %oper1.addr, align 1
  %conv = sext i8 %0 to i32
  %1 = load i8, i8* %oper2.addr, align 1
  %conv1 = sext i8 %1 to i32
  %cmp = icmp eq i32 %conv, %conv1
  br i1 %cmp, label %cond.true, label %cond.false

cond.true:                                        ; preds = %entry
  br label %cond.end61

cond.false:                                       ; preds = %entry
  %2 = load i8, i8* %oper1.addr, align 1
  %conv3 = sext i8 %2 to i32
  %cmp4 = icmp eq i32 %conv3, 94
  br i1 %cmp4, label %cond.true6, label %cond.false7

cond.true6:                                       ; preds = %cond.false
  br label %cond.end59

cond.false7:                                      ; preds = %cond.false
  %3 = load i8, i8* %oper2.addr, align 1
  %conv8 = sext i8 %3 to i32
  %cmp9 = icmp eq i32 %conv8, 94
  br i1 %cmp9, label %cond.true11, label %cond.false12

cond.true11:                                      ; preds = %cond.false7
  br label %cond.end57

cond.false12:                                     ; preds = %cond.false7
  %4 = load i8, i8* %oper1.addr, align 1
  %conv13 = sext i8 %4 to i32
  %cmp14 = icmp eq i32 %conv13, 47
  br i1 %cmp14, label %cond.true16, label %cond.false17

cond.true16:                                      ; preds = %cond.false12
  br label %cond.end55

cond.false17:                                     ; preds = %cond.false12
  %5 = load i8, i8* %oper2.addr, align 1
  %conv18 = sext i8 %5 to i32
  %cmp19 = icmp eq i32 %conv18, 47
  br i1 %cmp19, label %cond.true21, label %cond.false22

cond.true21:                                      ; preds = %cond.false17
  br label %cond.end53

cond.false22:                                     ; preds = %cond.false17
  %6 = load i8, i8* %oper1.addr, align 1
  %conv23 = sext i8 %6 to i32
  %cmp24 = icmp eq i32 %conv23, 42
  br i1 %cmp24, label %cond.true26, label %cond.false27

cond.true26:                                      ; preds = %cond.false22
  br label %cond.end51

cond.false27:                                     ; preds = %cond.false22
  %7 = load i8, i8* %oper2.addr, align 1
  %conv28 = sext i8 %7 to i32
  %cmp29 = icmp eq i32 %conv28, 42
  br i1 %cmp29, label %cond.true31, label %cond.false32

cond.true31:                                      ; preds = %cond.false27
  br label %cond.end49

cond.false32:                                     ; preds = %cond.false27
  %8 = load i8, i8* %oper1.addr, align 1
  %conv33 = sext i8 %8 to i32
  %cmp34 = icmp eq i32 %conv33, 43
  br i1 %cmp34, label %cond.true36, label %cond.false37

cond.true36:                                      ; preds = %cond.false32
  br label %cond.end47

cond.false37:                                     ; preds = %cond.false32
  %9 = load i8, i8* %oper2.addr, align 1
  %conv38 = sext i8 %9 to i32
  %cmp39 = icmp eq i32 %conv38, 43
  br i1 %cmp39, label %cond.true41, label %cond.false42

cond.true41:                                      ; preds = %cond.false37
  br label %cond.end

cond.false42:                                     ; preds = %cond.false37
  %10 = load i8, i8* %oper1.addr, align 1
  %conv43 = sext i8 %10 to i32
  %cmp44 = icmp eq i32 %conv43, 45
  %11 = zext i1 %cmp44 to i64
  %cond = select i1 %cmp44, i32 1, i32 2
  br label %cond.end

cond.end:                                         ; preds = %cond.false42, %cond.true41
  %cond46 = phi i32 [ 2, %cond.true41 ], [ %cond, %cond.false42 ]
  br label %cond.end47

cond.end47:                                       ; preds = %cond.end, %cond.true36
  %cond48 = phi i32 [ 1, %cond.true36 ], [ %cond46, %cond.end ]
  br label %cond.end49

cond.end49:                                       ; preds = %cond.end47, %cond.true31
  %cond50 = phi i32 [ 2, %cond.true31 ], [ %cond48, %cond.end47 ]
  br label %cond.end51

cond.end51:                                       ; preds = %cond.end49, %cond.true26
  %cond52 = phi i32 [ 1, %cond.true26 ], [ %cond50, %cond.end49 ]
  br label %cond.end53

cond.end53:                                       ; preds = %cond.end51, %cond.true21
  %cond54 = phi i32 [ 2, %cond.true21 ], [ %cond52, %cond.end51 ]
  br label %cond.end55

cond.end55:                                       ; preds = %cond.end53, %cond.true16
  %cond56 = phi i32 [ 1, %cond.true16 ], [ %cond54, %cond.end53 ]
  br label %cond.end57

cond.end57:                                       ; preds = %cond.end55, %cond.true11
  %cond58 = phi i32 [ 2, %cond.true11 ], [ %cond56, %cond.end55 ]
  br label %cond.end59

cond.end59:                                       ; preds = %cond.end57, %cond.true6
  %cond60 = phi i32 [ 1, %cond.true6 ], [ %cond58, %cond.end57 ]
  br label %cond.end61

cond.end61:                                       ; preds = %cond.end59, %cond.true
  %cond62 = phi i32 [ 0, %cond.true ], [ %cond60, %cond.end59 ]
  ret i32 %cond62
}

; Function Attrs: noinline nounwind optnone
define hidden i32 @isOperator(i8 signext %c) #0 {
entry:
  %c.addr = alloca i8, align 1
  store i8 %c, i8* %c.addr, align 1
  %0 = load i8, i8* %c.addr, align 1
  %conv = sext i8 %0 to i32
  %cmp = icmp eq i32 %conv, 43
  br i1 %cmp, label %lor.end, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %entry
  %1 = load i8, i8* %c.addr, align 1
  %conv2 = sext i8 %1 to i32
  %cmp3 = icmp eq i32 %conv2, 45
  br i1 %cmp3, label %lor.end, label %lor.lhs.false5

lor.lhs.false5:                                   ; preds = %lor.lhs.false
  %2 = load i8, i8* %c.addr, align 1
  %conv6 = sext i8 %2 to i32
  %cmp7 = icmp eq i32 %conv6, 42
  br i1 %cmp7, label %lor.end, label %lor.lhs.false9

lor.lhs.false9:                                   ; preds = %lor.lhs.false5
  %3 = load i8, i8* %c.addr, align 1
  %conv10 = sext i8 %3 to i32
  %cmp11 = icmp eq i32 %conv10, 47
  br i1 %cmp11, label %lor.end, label %lor.rhs

lor.rhs:                                          ; preds = %lor.lhs.false9
  %4 = load i8, i8* %c.addr, align 1
  %conv13 = sext i8 %4 to i32
  %cmp14 = icmp eq i32 %conv13, 94
  br label %lor.end

lor.end:                                          ; preds = %lor.rhs, %lor.lhs.false9, %lor.lhs.false5, %lor.lhs.false, %entry
  %5 = phi i1 [ true, %lor.lhs.false9 ], [ true, %lor.lhs.false5 ], [ true, %lor.lhs.false ], [ true, %entry ], [ %cmp14, %lor.rhs ]
  %lor.ext = zext i1 %5 to i32
  ret i32 %lor.ext
}

; Function Attrs: noinline nounwind optnone
define hidden void @inorder(%struct.elem* %t) #0 {
entry:
  %t.addr = alloca %struct.elem*, align 4
  store %struct.elem* %t, %struct.elem** %t.addr, align 4
  %0 = load %struct.elem*, %struct.elem** %t.addr, align 4
  %cmp = icmp ne %struct.elem* %0, null
  br i1 %cmp, label %if.then, label %if.end71

if.then:                                          ; preds = %entry
  %1 = load %struct.elem*, %struct.elem** %t.addr, align 4
  %left = getelementptr inbounds %struct.elem, %struct.elem* %1, i32 0, i32 1
  %2 = load %struct.elem*, %struct.elem** %left, align 4
  %cmp1 = icmp ne %struct.elem* %2, null
  br i1 %cmp1, label %land.lhs.true, label %if.else

land.lhs.true:                                    ; preds = %if.then
  %3 = load %struct.elem*, %struct.elem** %t.addr, align 4
  %left2 = getelementptr inbounds %struct.elem, %struct.elem* %3, i32 0, i32 1
  %4 = load %struct.elem*, %struct.elem** %left2, align 4
  %data = getelementptr inbounds %struct.elem, %struct.elem* %4, i32 0, i32 0
  %arrayidx = getelementptr inbounds [10 x i8], [10 x i8]* %data, i32 0, i32 0
  %5 = load i8, i8* %arrayidx, align 4
  %call = call i32 @isOperator(i8 signext %5)
  %cmp3 = icmp eq i32 %call, 1
  br i1 %cmp3, label %land.lhs.true4, label %if.else

land.lhs.true4:                                   ; preds = %land.lhs.true
  %6 = load %struct.elem*, %struct.elem** %t.addr, align 4
  %data5 = getelementptr inbounds %struct.elem, %struct.elem* %6, i32 0, i32 0
  %arrayidx6 = getelementptr inbounds [10 x i8], [10 x i8]* %data5, i32 0, i32 0
  %7 = load i8, i8* %arrayidx6, align 4
  %8 = load %struct.elem*, %struct.elem** %t.addr, align 4
  %left7 = getelementptr inbounds %struct.elem, %struct.elem* %8, i32 0, i32 1
  %9 = load %struct.elem*, %struct.elem** %left7, align 4
  %data8 = getelementptr inbounds %struct.elem, %struct.elem* %9, i32 0, i32 0
  %arrayidx9 = getelementptr inbounds [10 x i8], [10 x i8]* %data8, i32 0, i32 0
  %10 = load i8, i8* %arrayidx9, align 4
  %call10 = call i32 @precedenceCheck(i8 signext %7, i8 signext %10)
  %cmp11 = icmp eq i32 %call10, 1
  br i1 %cmp11, label %if.then24, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %land.lhs.true4
  %11 = load %struct.elem*, %struct.elem** %t.addr, align 4
  %data12 = getelementptr inbounds %struct.elem, %struct.elem* %11, i32 0, i32 0
  %arrayidx13 = getelementptr inbounds [10 x i8], [10 x i8]* %data12, i32 0, i32 0
  %12 = load i8, i8* %arrayidx13, align 4
  %13 = load %struct.elem*, %struct.elem** %t.addr, align 4
  %left14 = getelementptr inbounds %struct.elem, %struct.elem* %13, i32 0, i32 1
  %14 = load %struct.elem*, %struct.elem** %left14, align 4
  %data15 = getelementptr inbounds %struct.elem, %struct.elem* %14, i32 0, i32 0
  %arrayidx16 = getelementptr inbounds [10 x i8], [10 x i8]* %data15, i32 0, i32 0
  %15 = load i8, i8* %arrayidx16, align 4
  %call17 = call i32 @precedenceCheck(i8 signext %12, i8 signext %15)
  %cmp18 = icmp eq i32 %call17, 0
  br i1 %cmp18, label %land.lhs.true19, label %if.else

land.lhs.true19:                                  ; preds = %lor.lhs.false
  %16 = load %struct.elem*, %struct.elem** %t.addr, align 4
  %data20 = getelementptr inbounds %struct.elem, %struct.elem* %16, i32 0, i32 0
  %arrayidx21 = getelementptr inbounds [10 x i8], [10 x i8]* %data20, i32 0, i32 0
  %17 = load i8, i8* %arrayidx21, align 4
  %conv = sext i8 %17 to i32
  %cmp22 = icmp eq i32 %conv, 94
  br i1 %cmp22, label %if.then24, label %if.else

if.then24:                                        ; preds = %land.lhs.true19, %land.lhs.true4
  %call25 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([2 x i8], [2 x i8]* @.str, i32 0, i32 0))
  %18 = load %struct.elem*, %struct.elem** %t.addr, align 4
  %left26 = getelementptr inbounds %struct.elem, %struct.elem* %18, i32 0, i32 1
  %19 = load %struct.elem*, %struct.elem** %left26, align 4
  call void @inorder(%struct.elem* %19)
  %call27 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([2 x i8], [2 x i8]* @.str.1, i32 0, i32 0))
  br label %if.end

if.else:                                          ; preds = %land.lhs.true19, %lor.lhs.false, %land.lhs.true, %if.then
  %20 = load %struct.elem*, %struct.elem** %t.addr, align 4
  %left28 = getelementptr inbounds %struct.elem, %struct.elem* %20, i32 0, i32 1
  %21 = load %struct.elem*, %struct.elem** %left28, align 4
  call void @inorder(%struct.elem* %21)
  br label %if.end

if.end:                                           ; preds = %if.else, %if.then24
  %22 = load %struct.elem*, %struct.elem** %t.addr, align 4
  %data29 = getelementptr inbounds %struct.elem, %struct.elem* %22, i32 0, i32 0
  %arraydecay = getelementptr inbounds [10 x i8], [10 x i8]* %data29, i32 0, i32 0
  %call30 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.2, i32 0, i32 0), i8* %arraydecay)
  %23 = load %struct.elem*, %struct.elem** %t.addr, align 4
  %right = getelementptr inbounds %struct.elem, %struct.elem* %23, i32 0, i32 2
  %24 = load %struct.elem*, %struct.elem** %right, align 4
  %cmp31 = icmp ne %struct.elem* %24, null
  br i1 %cmp31, label %land.lhs.true33, label %if.else68

land.lhs.true33:                                  ; preds = %if.end
  %25 = load %struct.elem*, %struct.elem** %t.addr, align 4
  %right34 = getelementptr inbounds %struct.elem, %struct.elem* %25, i32 0, i32 2
  %26 = load %struct.elem*, %struct.elem** %right34, align 4
  %data35 = getelementptr inbounds %struct.elem, %struct.elem* %26, i32 0, i32 0
  %arrayidx36 = getelementptr inbounds [10 x i8], [10 x i8]* %data35, i32 0, i32 0
  %27 = load i8, i8* %arrayidx36, align 4
  %call37 = call i32 @isOperator(i8 signext %27)
  %cmp38 = icmp eq i32 %call37, 1
  br i1 %cmp38, label %land.lhs.true40, label %if.else68

land.lhs.true40:                                  ; preds = %land.lhs.true33
  %28 = load %struct.elem*, %struct.elem** %t.addr, align 4
  %data41 = getelementptr inbounds %struct.elem, %struct.elem* %28, i32 0, i32 0
  %arrayidx42 = getelementptr inbounds [10 x i8], [10 x i8]* %data41, i32 0, i32 0
  %29 = load i8, i8* %arrayidx42, align 4
  %30 = load %struct.elem*, %struct.elem** %t.addr, align 4
  %right43 = getelementptr inbounds %struct.elem, %struct.elem* %30, i32 0, i32 2
  %31 = load %struct.elem*, %struct.elem** %right43, align 4
  %data44 = getelementptr inbounds %struct.elem, %struct.elem* %31, i32 0, i32 0
  %arrayidx45 = getelementptr inbounds [10 x i8], [10 x i8]* %data44, i32 0, i32 0
  %32 = load i8, i8* %arrayidx45, align 4
  %call46 = call i32 @precedenceCheck(i8 signext %29, i8 signext %32)
  %cmp47 = icmp eq i32 %call46, 1
  br i1 %cmp47, label %if.then64, label %lor.lhs.false49

lor.lhs.false49:                                  ; preds = %land.lhs.true40
  %33 = load %struct.elem*, %struct.elem** %t.addr, align 4
  %data50 = getelementptr inbounds %struct.elem, %struct.elem* %33, i32 0, i32 0
  %arrayidx51 = getelementptr inbounds [10 x i8], [10 x i8]* %data50, i32 0, i32 0
  %34 = load i8, i8* %arrayidx51, align 4
  %35 = load %struct.elem*, %struct.elem** %t.addr, align 4
  %right52 = getelementptr inbounds %struct.elem, %struct.elem* %35, i32 0, i32 2
  %36 = load %struct.elem*, %struct.elem** %right52, align 4
  %data53 = getelementptr inbounds %struct.elem, %struct.elem* %36, i32 0, i32 0
  %arrayidx54 = getelementptr inbounds [10 x i8], [10 x i8]* %data53, i32 0, i32 0
  %37 = load i8, i8* %arrayidx54, align 4
  %call55 = call i32 @precedenceCheck(i8 signext %34, i8 signext %37)
  %cmp56 = icmp eq i32 %call55, 0
  br i1 %cmp56, label %land.lhs.true58, label %if.else68

land.lhs.true58:                                  ; preds = %lor.lhs.false49
  %38 = load %struct.elem*, %struct.elem** %t.addr, align 4
  %data59 = getelementptr inbounds %struct.elem, %struct.elem* %38, i32 0, i32 0
  %arrayidx60 = getelementptr inbounds [10 x i8], [10 x i8]* %data59, i32 0, i32 0
  %39 = load i8, i8* %arrayidx60, align 4
  %conv61 = sext i8 %39 to i32
  %cmp62 = icmp ne i32 %conv61, 94
  br i1 %cmp62, label %if.then64, label %if.else68

if.then64:                                        ; preds = %land.lhs.true58, %land.lhs.true40
  %call65 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([2 x i8], [2 x i8]* @.str, i32 0, i32 0))
  %40 = load %struct.elem*, %struct.elem** %t.addr, align 4
  %right66 = getelementptr inbounds %struct.elem, %struct.elem* %40, i32 0, i32 2
  %41 = load %struct.elem*, %struct.elem** %right66, align 4
  call void @inorder(%struct.elem* %41)
  %call67 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([2 x i8], [2 x i8]* @.str.1, i32 0, i32 0))
  br label %if.end70

if.else68:                                        ; preds = %land.lhs.true58, %lor.lhs.false49, %land.lhs.true33, %if.end
  %42 = load %struct.elem*, %struct.elem** %t.addr, align 4
  %right69 = getelementptr inbounds %struct.elem, %struct.elem* %42, i32 0, i32 2
  %43 = load %struct.elem*, %struct.elem** %right69, align 4
  call void @inorder(%struct.elem* %43)
  br label %if.end70

if.end70:                                         ; preds = %if.else68, %if.then64
  br label %if.end71

if.end71:                                         ; preds = %if.end70, %entry
  ret void
}

declare i32 @printf(i8* %0, ...) #1

; Function Attrs: noinline nounwind optnone
define hidden i8* @getNextString() #0 {
entry:
  %0 = load i32, i32* @counter, align 4
  %cmp = icmp slt i32 %0, 0
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %call = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([15 x i8], [15 x i8]* @.str.3, i32 0, i32 0))
  call void @exit(i32 0) #4
  unreachable

if.end:                                           ; preds = %entry
  %1 = load i8**, i8*** @components, align 4
  %2 = load i32, i32* @counter, align 4
  %dec = add nsw i32 %2, -1
  store i32 %dec, i32* @counter, align 4
  %arrayidx = getelementptr inbounds i8*, i8** %1, i32 %2
  %3 = load i8*, i8** %arrayidx, align 4
  ret i8* %3
}

; Function Attrs: noreturn
declare void @exit(i32 %0) #2

; Function Attrs: noinline nounwind optnone
define hidden %struct.elem* @buildTree(i8* %obj, i8* %trace) #0 {
entry:
  %obj.addr = alloca i8*, align 4
  %trace.addr = alloca i8*, align 4
  %t = alloca %struct.elem*, align 4
  store i8* %obj, i8** %obj.addr, align 4
  store i8* %trace, i8** %trace.addr, align 4
  %call = call noalias i8* @malloc(i32 20)
  %0 = bitcast i8* %call to %struct.elem*
  store %struct.elem* %0, %struct.elem** %t, align 4
  %1 = load %struct.elem*, %struct.elem** %t, align 4
  %data = getelementptr inbounds %struct.elem, %struct.elem* %1, i32 0, i32 0
  %arraydecay = getelementptr inbounds [10 x i8], [10 x i8]* %data, i32 0, i32 0
  %2 = load i8*, i8** %obj.addr, align 4
  %call1 = call i8* @strcpy(i8* %arraydecay, i8* %2)
  %3 = load i8*, i8** %obj.addr, align 4
  %arrayidx = getelementptr inbounds i8, i8* %3, i32 0
  %4 = load i8, i8* %arrayidx, align 1
  %call2 = call i32 @isOperator(i8 signext %4)
  %cmp = icmp eq i32 %call2, 1
  br i1 %cmp, label %cond.true, label %cond.false

cond.true:                                        ; preds = %entry
  %call3 = call i8* @getNextString()
  %5 = load i8*, i8** %trace.addr, align 4
  %call4 = call %struct.elem* @buildTree(i8* %call3, i8* %5)
  br label %cond.end

cond.false:                                       ; preds = %entry
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi %struct.elem* [ %call4, %cond.true ], [ null, %cond.false ]
  %6 = load %struct.elem*, %struct.elem** %t, align 4
  %right = getelementptr inbounds %struct.elem, %struct.elem* %6, i32 0, i32 2
  store %struct.elem* %cond, %struct.elem** %right, align 4
  %7 = load i8*, i8** %obj.addr, align 4
  %arrayidx5 = getelementptr inbounds i8, i8* %7, i32 0
  %8 = load i8, i8* %arrayidx5, align 1
  %call6 = call i32 @isOperator(i8 signext %8)
  %cmp7 = icmp eq i32 %call6, 1
  br i1 %cmp7, label %cond.true8, label %cond.false11

cond.true8:                                       ; preds = %cond.end
  %call9 = call i8* @getNextString()
  %9 = load i8*, i8** %trace.addr, align 4
  %call10 = call %struct.elem* @buildTree(i8* %call9, i8* %9)
  br label %cond.end12

cond.false11:                                     ; preds = %cond.end
  br label %cond.end12

cond.end12:                                       ; preds = %cond.false11, %cond.true8
  %cond13 = phi %struct.elem* [ %call10, %cond.true8 ], [ null, %cond.false11 ]
  %10 = load %struct.elem*, %struct.elem** %t, align 4
  %left = getelementptr inbounds %struct.elem, %struct.elem* %10, i32 0, i32 1
  store %struct.elem* %cond13, %struct.elem** %left, align 4
  %11 = load i8*, i8** %trace.addr, align 4
  %cmp14 = icmp ne i8* %11, null
  br i1 %cmp14, label %if.then, label %if.end

if.then:                                          ; preds = %cond.end12
  %call15 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([2 x i8], [2 x i8]* @.str.4, i32 0, i32 0))
  %12 = load %struct.elem*, %struct.elem** %t, align 4
  call void @inorder(%struct.elem* %12)
  br label %if.end

if.end:                                           ; preds = %if.then, %cond.end12
  %13 = load %struct.elem*, %struct.elem** %t, align 4
  ret %struct.elem* %13
}

declare noalias i8* @malloc(i32 %0) #1

declare i8* @strcpy(i8* %0, i8* %1) #1

; Function Attrs: noinline nounwind optnone
define hidden i32 @checkRPN() #0 {
entry:
  %retval = alloca i32, align 4
  %i = alloca i32, align 4
  %operSum = alloca i32, align 4
  %numberSum = alloca i32, align 4
  store i32 0, i32* %operSum, align 4
  store i32 0, i32* %numberSum, align 4
  %0 = load i8**, i8*** @components, align 4
  %1 = load i32, i32* @counter, align 4
  %arrayidx = getelementptr inbounds i8*, i8** %0, i32 %1
  %2 = load i8*, i8** %arrayidx, align 4
  %arrayidx1 = getelementptr inbounds i8, i8* %2, i32 0
  %3 = load i8, i8* %arrayidx1, align 1
  %call = call i32 @isOperator(i8 signext %3)
  %cmp = icmp eq i32 %call, 0
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  store i32 0, i32* %retval, align 4
  br label %return

if.end:                                           ; preds = %entry
  store i32 0, i32* %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.end
  %4 = load i32, i32* %i, align 4
  %5 = load i32, i32* @counter, align 4
  %cmp2 = icmp sle i32 %4, %5
  br i1 %cmp2, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %6 = load i8**, i8*** @components, align 4
  %7 = load i32, i32* %i, align 4
  %arrayidx3 = getelementptr inbounds i8*, i8** %6, i32 %7
  %8 = load i8*, i8** %arrayidx3, align 4
  %arrayidx4 = getelementptr inbounds i8, i8* %8, i32 0
  %9 = load i8, i8* %arrayidx4, align 1
  %call5 = call i32 @isOperator(i8 signext %9)
  %cmp6 = icmp eq i32 %call5, 1
  br i1 %cmp6, label %cond.true, label %cond.false

cond.true:                                        ; preds = %for.body
  %10 = load i32, i32* %operSum, align 4
  %inc = add nsw i32 %10, 1
  store i32 %inc, i32* %operSum, align 4
  br label %cond.end

cond.false:                                       ; preds = %for.body
  %11 = load i32, i32* %numberSum, align 4
  %inc7 = add nsw i32 %11, 1
  store i32 %inc7, i32* %numberSum, align 4
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi i32 [ %10, %cond.true ], [ %11, %cond.false ]
  br label %for.inc

for.inc:                                          ; preds = %cond.end
  %12 = load i32, i32* %i, align 4
  %inc8 = add nsw i32 %12, 1
  store i32 %inc8, i32* %i, align 4
  br label %for.cond

for.end:                                          ; preds = %for.cond
  %13 = load i32, i32* %numberSum, align 4
  %14 = load i32, i32* %operSum, align 4
  %sub = sub nsw i32 %13, %14
  %cmp9 = icmp eq i32 %sub, 1
  %conv = zext i1 %cmp9 to i32
  store i32 %conv, i32* %retval, align 4
  br label %return

return:                                           ; preds = %for.end, %if.then
  %15 = load i32, i32* %retval, align 4
  ret i32 %15
}

; Function Attrs: noinline nounwind optnone
define hidden void @buildStack(i8* %str) #0 {
entry:
  %str.addr = alloca i8*, align 4
  %i = alloca i32, align 4
  %token = alloca i8*, align 4
  store i8* %str, i8** %str.addr, align 4
  store i32 0, i32* %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %0 = load i8*, i8** %str.addr, align 4
  %1 = load i32, i32* %i, align 4
  %arrayidx = getelementptr inbounds i8, i8* %0, i32 %1
  %2 = load i8, i8* %arrayidx, align 1
  %conv = sext i8 %2 to i32
  %cmp = icmp ne i32 %conv, 0
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %3 = load i8*, i8** %str.addr, align 4
  %4 = load i32, i32* %i, align 4
  %arrayidx2 = getelementptr inbounds i8, i8* %3, i32 %4
  %5 = load i8, i8* %arrayidx2, align 1
  %conv3 = sext i8 %5 to i32
  %cmp4 = icmp eq i32 %conv3, 32
  br i1 %cmp4, label %if.then, label %if.end

if.then:                                          ; preds = %for.body
  %6 = load i32, i32* @counter, align 4
  %inc = add nsw i32 %6, 1
  store i32 %inc, i32* @counter, align 4
  br label %if.end

if.end:                                           ; preds = %if.then, %for.body
  br label %for.inc

for.inc:                                          ; preds = %if.end
  %7 = load i32, i32* %i, align 4
  %inc6 = add nsw i32 %7, 1
  store i32 %inc6, i32* %i, align 4
  br label %for.cond

for.end:                                          ; preds = %for.cond
  %8 = load i32, i32* @counter, align 4
  %add = add nsw i32 %8, 1
  %mul = mul i32 %add, 4
  %call = call noalias i8* @malloc(i32 %mul)
  %9 = bitcast i8* %call to i8**
  store i8** %9, i8*** @components, align 4
  %10 = load i8*, i8** %str.addr, align 4
  %call7 = call i8* @strtok(i8* %10, i8* getelementptr inbounds ([2 x i8], [2 x i8]* @.str.5, i32 0, i32 0))
  store i8* %call7, i8** %token, align 4
  store i32 0, i32* %i, align 4
  br label %while.cond

while.cond:                                       ; preds = %while.body, %for.end
  %11 = load i8*, i8** %token, align 4
  %cmp8 = icmp ne i8* %11, null
  br i1 %cmp8, label %while.body, label %while.end

while.body:                                       ; preds = %while.cond
  %12 = load i8*, i8** %token, align 4
  %call10 = call i32 @strlen(i8* %12) #5
  %mul11 = mul i32 %call10, 1
  %call12 = call noalias i8* @malloc(i32 %mul11)
  %13 = load i8**, i8*** @components, align 4
  %14 = load i32, i32* %i, align 4
  %arrayidx13 = getelementptr inbounds i8*, i8** %13, i32 %14
  store i8* %call12, i8** %arrayidx13, align 4
  %15 = load i8**, i8*** @components, align 4
  %16 = load i32, i32* %i, align 4
  %arrayidx14 = getelementptr inbounds i8*, i8** %15, i32 %16
  %17 = load i8*, i8** %arrayidx14, align 4
  %18 = load i8*, i8** %token, align 4
  %call15 = call i8* @strcpy(i8* %17, i8* %18)
  %call16 = call i8* @strtok(i8* null, i8* getelementptr inbounds ([2 x i8], [2 x i8]* @.str.5, i32 0, i32 0))
  store i8* %call16, i8** %token, align 4
  %19 = load i32, i32* %i, align 4
  %inc17 = add nsw i32 %19, 1
  store i32 %inc17, i32* %i, align 4
  br label %while.cond

while.end:                                        ; preds = %while.cond
  ret void
}

declare i8* @strtok(i8* %0, i8* %1) #1

; Function Attrs: nounwind readonly
declare i32 @strlen(i8* %0) #3

; Function Attrs: noinline nounwind optnone
define hidden i32 @__main_argc_argv(i32 %argC, i8** %argV) #0 {
entry:
  %retval = alloca i32, align 4
  %argC.addr = alloca i32, align 4
  %argV.addr = alloca i8**, align 4
  %i = alloca i32, align 4
  %t = alloca %struct.elem*, align 4
  store i32 0, i32* %retval, align 4
  store i32 %argC, i32* %argC.addr, align 4
  store i8** %argV, i8*** %argV.addr, align 4
  %0 = load i32, i32* %argC.addr, align 4
  %cmp = icmp eq i32 %0, 1
  br i1 %cmp, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  %1 = load i8**, i8*** %argV.addr, align 4
  %arrayidx = getelementptr inbounds i8*, i8** %1, i32 0
  %2 = load i8*, i8** %arrayidx, align 4
  %call = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([95 x i8], [95 x i8]* @.str.6, i32 0, i32 0), i8* %2)
  br label %if.end10

if.else:                                          ; preds = %entry
  %3 = load i8**, i8*** %argV.addr, align 4
  %arrayidx1 = getelementptr inbounds i8*, i8** %3, i32 1
  %4 = load i8*, i8** %arrayidx1, align 4
  call void @buildStack(i8* %4)
  %call2 = call i32 @checkRPN()
  %cmp3 = icmp eq i32 %call2, 0
  br i1 %cmp3, label %if.then4, label %if.end

if.then4:                                         ; preds = %if.else
  %call5 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([15 x i8], [15 x i8]* @.str.3, i32 0, i32 0))
  store i32 0, i32* %retval, align 4
  br label %return

if.end:                                           ; preds = %if.else
  %call6 = call i8* @getNextString()
  %5 = load i8**, i8*** %argV.addr, align 4
  %arrayidx7 = getelementptr inbounds i8*, i8** %5, i32 2
  %6 = load i8*, i8** %arrayidx7, align 4
  %call8 = call %struct.elem* @buildTree(i8* %call6, i8* %6)
  store %struct.elem* %call8, %struct.elem** %t, align 4
  %call9 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([27 x i8], [27 x i8]* @.str.7, i32 0, i32 0))
  %7 = load %struct.elem*, %struct.elem** %t, align 4
  call void @inorder(%struct.elem* %7)
  br label %if.end10

if.end10:                                         ; preds = %if.end, %if.then
  store i32 0, i32* %retval, align 4
  br label %return

return:                                           ; preds = %if.end10, %if.then4
  %8 = load i32, i32* %retval, align 4
  ret i32 %8
}

attributes #0 = { noinline nounwind optnone "correctly-rounded-divide-sqrt-fp-math"="false" "disable-tail-calls"="false" "frame-pointer"="none" "less-precise-fpmad"="false" "min-legal-vector-width"="0" "no-infs-fp-math"="false" "no-jump-tables"="false" "no-nans-fp-math"="false" "no-signed-zeros-fp-math"="false" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="generic" "unsafe-fp-math"="false" "use-soft-float"="false" }
attributes #1 = { "correctly-rounded-divide-sqrt-fp-math"="false" "disable-tail-calls"="false" "frame-pointer"="none" "less-precise-fpmad"="false" "no-infs-fp-math"="false" "no-nans-fp-math"="false" "no-signed-zeros-fp-math"="false" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="generic" "unsafe-fp-math"="false" "use-soft-float"="false" }
attributes #2 = { noreturn "correctly-rounded-divide-sqrt-fp-math"="false" "disable-tail-calls"="false" "frame-pointer"="none" "less-precise-fpmad"="false" "no-infs-fp-math"="false" "no-nans-fp-math"="false" "no-signed-zeros-fp-math"="false" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="generic" "unsafe-fp-math"="false" "use-soft-float"="false" }
attributes #3 = { nounwind readonly "correctly-rounded-divide-sqrt-fp-math"="false" "disable-tail-calls"="false" "frame-pointer"="none" "less-precise-fpmad"="false" "no-infs-fp-math"="false" "no-nans-fp-math"="false" "no-signed-zeros-fp-math"="false" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="generic" "unsafe-fp-math"="false" "use-soft-float"="false" }
attributes #4 = { noreturn }
attributes #5 = { nounwind readonly }

!llvm.module.flags = !{!0}
!llvm.ident = !{!1}

!0 = !{i32 1, !"wchar_size", i32 4}
!1 = !{!"clang version 11.0.0 (https://github.com/Jacarte/llvm-project.git 0f6dea67136cc1e0b3d200eb2bb165628970c44b)"}

; extracted candidates

; *****
; For LLVM instruction:
;  %0 = load i8, i8* %oper1.addr, align 1
; Looking for a replacement for:
%0:i8 = var
infer %0

; *****
; For LLVM instruction:
;  %conv = sext i8 %0 to i32
; Looking for a replacement for:
%0:i8 = var
%1:i32 = sext %0
infer %1

; *****
; For LLVM instruction:
;  %1 = load i8, i8* %oper2.addr, align 1
; Looking for a replacement for:
%0:i8 = var
infer %0

; *****
; For LLVM instruction:
;  %conv1 = sext i8 %1 to i32
; Looking for a replacement for:
%0:i8 = var
%1:i32 = sext %0
infer %1

; *****
; For LLVM instruction:
;  %cmp = icmp eq i32 %conv, %conv1
; Looking for a replacement for:
%0:i8 = var
%1:i32 = sext %0
%2:i8 = var
%3:i32 = sext %2
%4:i1 = eq %1, %3
infer %4

; *****
; For LLVM instruction:
;  %2 = load i8, i8* %oper1.addr, align 1
; Looking for a replacement for:
%0:i8 = var
infer %0

; *****
; For LLVM instruction:
;  %conv3 = sext i8 %2 to i32
; Looking for a replacement for:
%0:i8 = var
%1:i32 = sext %0
infer %1

; *****
; For LLVM instruction:
;  %cmp4 = icmp eq i32 %conv3, 94
; Looking for a replacement for:
%0:i8 = var
%1:i32 = sext %0
%2:i1 = eq 94:i32, %1
infer %2

; *****
; For LLVM instruction:
;  %3 = load i8, i8* %oper2.addr, align 1
; Looking for a replacement for:
%0:i8 = var
infer %0

; *****
; For LLVM instruction:
;  %conv8 = sext i8 %3 to i32
; Looking for a replacement for:
%0:i8 = var
%1:i32 = sext %0
infer %1

; *****
; For LLVM instruction:
;  %cmp9 = icmp eq i32 %conv8, 94
; Looking for a replacement for:
%0:i8 = var
%1:i32 = sext %0
%2:i1 = eq 94:i32, %1
infer %2

; *****
; For LLVM instruction:
;  %4 = load i8, i8* %oper1.addr, align 1
; Looking for a replacement for:
%0:i8 = var
infer %0

; *****
; For LLVM instruction:
;  %conv13 = sext i8 %4 to i32
; Looking for a replacement for:
%0:i8 = var
%1:i32 = sext %0
infer %1

; *****
; For LLVM instruction:
;  %cmp14 = icmp eq i32 %conv13, 47
; Looking for a replacement for:
%0:i8 = var
%1:i32 = sext %0
%2:i1 = eq 47:i32, %1
infer %2

; *****
; For LLVM instruction:
;  %5 = load i8, i8* %oper2.addr, align 1
; Looking for a replacement for:
%0:i8 = var
infer %0

; *****
; For LLVM instruction:
;  %conv18 = sext i8 %5 to i32
; Looking for a replacement for:
%0:i8 = var
%1:i32 = sext %0
infer %1

; *****
; For LLVM instruction:
;  %cmp19 = icmp eq i32 %conv18, 47
; Looking for a replacement for:
%0:i8 = var
%1:i32 = sext %0
%2:i1 = eq 47:i32, %1
infer %2

; *****
; For LLVM instruction:
;  %6 = load i8, i8* %oper1.addr, align 1
; Looking for a replacement for:
%0:i8 = var
infer %0

; *****
; For LLVM instruction:
;  %conv23 = sext i8 %6 to i32
; Looking for a replacement for:
%0:i8 = var
%1:i32 = sext %0
infer %1

; *****
; For LLVM instruction:
;  %cmp24 = icmp eq i32 %conv23, 42
; Looking for a replacement for:
%0:i8 = var
%1:i32 = sext %0
%2:i1 = eq 42:i32, %1
infer %2

; *****
; For LLVM instruction:
;  %7 = load i8, i8* %oper2.addr, align 1
; Looking for a replacement for:
%0:i8 = var
infer %0

; *****
; For LLVM instruction:
;  %conv28 = sext i8 %7 to i32
; Looking for a replacement for:
%0:i8 = var
%1:i32 = sext %0
infer %1

; *****
; For LLVM instruction:
;  %cmp29 = icmp eq i32 %conv28, 42
; Looking for a replacement for:
%0:i8 = var
%1:i32 = sext %0
%2:i1 = eq 42:i32, %1
infer %2

; *****
; For LLVM instruction:
;  %8 = load i8, i8* %oper1.addr, align 1
; Looking for a replacement for:
%0:i8 = var
infer %0

; *****
; For LLVM instruction:
;  %conv33 = sext i8 %8 to i32
; Looking for a replacement for:
%0:i8 = var
%1:i32 = sext %0
infer %1

; *****
; For LLVM instruction:
;  %cmp34 = icmp eq i32 %conv33, 43
; Looking for a replacement for:
%0:i8 = var
%1:i32 = sext %0
%2:i1 = eq 43:i32, %1
infer %2

; *****
; For LLVM instruction:
;  %9 = load i8, i8* %oper2.addr, align 1
; Looking for a replacement for:
%0:i8 = var
infer %0

; *****
; For LLVM instruction:
;  %conv38 = sext i8 %9 to i32
; Looking for a replacement for:
%0:i8 = var
%1:i32 = sext %0
infer %1

; *****
; For LLVM instruction:
;  %cmp39 = icmp eq i32 %conv38, 43
; Looking for a replacement for:
%0:i8 = var
%1:i32 = sext %0
%2:i1 = eq 43:i32, %1
infer %2

; *****
; For LLVM instruction:
;  %10 = load i8, i8* %oper1.addr, align 1
; Looking for a replacement for:
%0:i8 = var
infer %0

; *****
; For LLVM instruction:
;  %conv43 = sext i8 %10 to i32
; Looking for a replacement for:
%0:i8 = var
%1:i32 = sext %0
infer %1

; *****
; For LLVM instruction:
;  %cmp44 = icmp eq i32 %conv43, 45
; Looking for a replacement for:
%0:i8 = var
%1:i32 = sext %0
%2:i1 = eq 45:i32, %1
infer %2

; *****
; For LLVM instruction:
;  %cond = select i1 %cmp44, i32 1, i32 2
; Looking for a replacement for:
%0:i8 = var
%1:i32 = sext %0
%2:i1 = eq 45:i32, %1 (hasExternalUses)
%3:i32 = select %2, 1:i32, 2:i32
infer %3

; *****
; For LLVM instruction:
;  %cond46 = phi i32 [ 2, %cond.true41 ], [ %cond, %cond.false42 ]
; Looking for a replacement for:
%0 = block 2
%1:i8 = var
%2:i32 = sext %1
%3:i1 = eq 45:i32, %2 (hasExternalUses)
%4:i32 = select %3, 1:i32, 2:i32
%5:i32 = phi %0, 2:i32, %4
infer %5

; *****
; For LLVM instruction:
;  %cond48 = phi i32 [ 1, %cond.true36 ], [ %cond46, %cond.end ]
; Looking for a replacement for:
%0 = block 2
%1 = block 2
%2:i8 = var
%3:i32 = sext %2
%4:i1 = eq 45:i32, %3
%5:i32 = select %4, 1:i32, 2:i32
%6:i32 = phi %1, 2:i32, %5
%7:i32 = phi %0, 1:i32, %6
infer %7

; *****
; For LLVM instruction:
;  %cond50 = phi i32 [ 2, %cond.true31 ], [ %cond48, %cond.end47 ]
; Looking for a replacement for:
%0 = block 2
%1 = block 2
%2 = block 2
%3:i8 = var
%4:i32 = sext %3
%5:i1 = eq 45:i32, %4
%6:i32 = select %5, 1:i32, 2:i32
%7:i32 = phi %2, 2:i32, %6
%8:i32 = phi %1, 1:i32, %7
%9:i32 = phi %0, 2:i32, %8
infer %9

; *****
; For LLVM instruction:
;  %cond52 = phi i32 [ 1, %cond.true26 ], [ %cond50, %cond.end49 ]
; Looking for a replacement for:
%0 = block 2
%1 = block 2
%2 = block 2
%3 = block 2
%4:i8 = var
%5:i32 = sext %4
%6:i1 = eq 45:i32, %5
%7:i32 = select %6, 1:i32, 2:i32
%8:i32 = phi %3, 2:i32, %7
%9:i32 = phi %2, 1:i32, %8
%10:i32 = phi %1, 2:i32, %9
%11:i32 = phi %0, 1:i32, %10
infer %11

; *****
; For LLVM instruction:
;  %cond54 = phi i32 [ 2, %cond.true21 ], [ %cond52, %cond.end51 ]
; Looking for a replacement for:
%0 = block 2
%1 = block 2
%2 = block 2
%3 = block 2
%4 = block 2
%5:i8 = var
%6:i32 = sext %5
%7:i1 = eq 45:i32, %6
%8:i32 = select %7, 1:i32, 2:i32
%9:i32 = phi %4, 2:i32, %8
%10:i32 = phi %3, 1:i32, %9
%11:i32 = phi %2, 2:i32, %10
%12:i32 = phi %1, 1:i32, %11
%13:i32 = phi %0, 2:i32, %12
infer %13

; *****
; For LLVM instruction:
;  %cond56 = phi i32 [ 1, %cond.true16 ], [ %cond54, %cond.end53 ]
; Looking for a replacement for:
%0 = block 2
%1 = block 2
%2 = block 2
%3 = block 2
%4 = block 2
%5 = block 2
%6:i8 = var
%7:i32 = sext %6
%8:i1 = eq 45:i32, %7
%9:i32 = select %8, 1:i32, 2:i32
%10:i32 = phi %5, 2:i32, %9
%11:i32 = phi %4, 1:i32, %10
%12:i32 = phi %3, 2:i32, %11
%13:i32 = phi %2, 1:i32, %12
%14:i32 = phi %1, 2:i32, %13
%15:i32 = phi %0, 1:i32, %14
infer %15

; *****
; For LLVM instruction:
;  %cond58 = phi i32 [ 2, %cond.true11 ], [ %cond56, %cond.end55 ]
; Looking for a replacement for:
%0 = block 2
%1 = block 2
%2 = block 2
%3 = block 2
%4 = block 2
%5 = block 2
%6 = block 2
%7:i8 = var
%8:i32 = sext %7
%9:i1 = eq 45:i32, %8
%10:i32 = select %9, 1:i32, 2:i32
%11:i32 = phi %6, 2:i32, %10
%12:i32 = phi %5, 1:i32, %11
%13:i32 = phi %4, 2:i32, %12
%14:i32 = phi %3, 1:i32, %13
%15:i32 = phi %2, 2:i32, %14
%16:i32 = phi %1, 1:i32, %15
%17:i32 = phi %0, 2:i32, %16
infer %17

; *****
; For LLVM instruction:
;  %cond60 = phi i32 [ 1, %cond.true6 ], [ %cond58, %cond.end57 ]
; Looking for a replacement for:
%0 = block 2
%1 = block 2
%2 = block 2
%3 = block 2
%4 = block 2
%5 = block 2
%6 = block 2
%7 = block 2
%8:i8 = var
%9:i32 = sext %8
%10:i1 = eq 45:i32, %9
%11:i32 = select %10, 1:i32, 2:i32
%12:i32 = phi %7, 2:i32, %11
%13:i32 = phi %6, 1:i32, %12
%14:i32 = phi %5, 2:i32, %13
%15:i32 = phi %4, 1:i32, %14
%16:i32 = phi %3, 2:i32, %15
%17:i32 = phi %2, 1:i32, %16
%18:i32 = phi %1, 2:i32, %17
%19:i32 = phi %0, 1:i32, %18
infer %19

; *****
; For LLVM instruction:
;  %cond62 = phi i32 [ 0, %cond.true ], [ %cond60, %cond.end59 ]
; Looking for a replacement for:
%0 = block 2
%1 = block 2
%2 = block 2
%3 = block 2
%4 = block 2
%5 = block 2
%6 = block 2
%7 = block 2
%8 = block 2
%9:i8 = var
%10:i32 = sext %9
%11:i1 = eq 45:i32, %10
%12:i32 = select %11, 1:i32, 2:i32
%13:i32 = phi %8, 2:i32, %12
%14:i32 = phi %7, 1:i32, %13
%15:i32 = phi %6, 2:i32, %14
%16:i32 = phi %5, 1:i32, %15
%17:i32 = phi %4, 2:i32, %16
%18:i32 = phi %3, 1:i32, %17
%19:i32 = phi %2, 2:i32, %18
%20:i32 = phi %1, 1:i32, %19
%21:i32 = phi %0, 0:i32, %20
infer %21
got 1 candidates from LHS

-------------------------------------------------
%0:i8 = var
infer %0


--------------------------------
guess 0

%0:i8 = var ; reservedconst_1

Cost = 0
first query is SAT, returning the model:
reservedconst_1: 0
0 th attempt: second query is SAT-- constant doesn't work
first query is SAT, returning the model:
reservedconst_1: -1
1 th attempt: second query is SAT-- constant doesn't work
first query is UNSAT-- no more guesses
Dataflow Pruned 0/0
There are 1 Guesses
There are 0 RHSs before deduplication
There are 0 RHSs after deduplication
got 2 candidates from LHS

-------------------------------------------------
%0:i8 = var
%1:i32 = sext %0
infer %1


--------------------------------
guess 0

%0:i32 = var ; reservedconst_1

Cost = 0
first query is SAT, returning the model:
reservedconst_1: 0
0 th attempt: second query is SAT-- constant doesn't work
first query is SAT, returning the model:
reservedconst_1: -1
1 th attempt: second query is SAT-- constant doesn't work
first query is UNSAT-- no more guesses
Dataflow Pruned 0/0
There are 1 Guesses
There are 0 RHSs before deduplication
There are 0 RHSs after deduplication
got 5 candidates from LHS

-------------------------------------------------
%0:i8 = var
%1:i32 = sext %0
%2:i8 = var
%3:i32 = sext %2
%4:i1 = eq %1, %3
infer %4


--------------------------------
guess 0

%0:i1 = var ; reservedconst_1

Cost = 0
first query is SAT, returning the model:
reservedconst_1: -1
0 th attempt: second query is SAT-- constant doesn't work
first query is SAT, returning the model:
reservedconst_1: 0
1 th attempt: second query is SAT-- constant doesn't work
first query is UNSAT-- no more guesses
Dataflow Pruned 0/0
There are 1 Guesses
There are 0 RHSs before deduplication
There are 0 RHSs after deduplication
got 3 candidates from LHS

-------------------------------------------------
%0:i8 = var
%1:i32 = sext %0
%2:i1 = eq 94:i32, %1
infer %2


--------------------------------
guess 0

%0:i1 = var ; reservedconst_1

Cost = 0
first query is SAT, returning the model:
reservedconst_1: 0
0 th attempt: second query is SAT-- constant doesn't work
first query is SAT, returning the model:
reservedconst_1: -1
1 th attempt: second query is SAT-- constant doesn't work
first query is UNSAT-- no more guesses
Dataflow Pruned 0/0
There are 1 Guesses
There are 0 RHSs before deduplication
There are 0 RHSs after deduplication
got 3 candidates from LHS

-------------------------------------------------
%0:i8 = var
%1:i32 = sext %0
%2:i1 = eq 47:i32, %1
infer %2


--------------------------------
guess 0

%0:i1 = var ; reservedconst_1

Cost = 0
first query is SAT, returning the model:
reservedconst_1: 0
0 th attempt: second query is SAT-- constant doesn't work
first query is SAT, returning the model:
reservedconst_1: -1
1 th attempt: second query is SAT-- constant doesn't work
first query is UNSAT-- no more guesses
Dataflow Pruned 0/0
There are 1 Guesses
There are 0 RHSs before deduplication
There are 0 RHSs after deduplication
got 3 candidates from LHS

-------------------------------------------------
%0:i8 = var
%1:i32 = sext %0
%2:i1 = eq 42:i32, %1
infer %2


--------------------------------
guess 0

%0:i1 = var ; reservedconst_1

Cost = 0
first query is SAT, returning the model:
reservedconst_1: 0
0 th attempt: second query is SAT-- constant doesn't work
first query is SAT, returning the model:
reservedconst_1: -1
1 th attempt: second query is SAT-- constant doesn't work
first query is UNSAT-- no more guesses
Dataflow Pruned 0/0
There are 1 Guesses
There are 0 RHSs before deduplication
There are 0 RHSs after deduplication
got 3 candidates from LHS

-------------------------------------------------
%0:i8 = var
%1:i32 = sext %0
%2:i1 = eq 43:i32, %1
infer %2


--------------------------------
guess 0

%0:i1 = var ; reservedconst_1

Cost = 0
first query is SAT, returning the model:
reservedconst_1: 0
0 th attempt: second query is SAT-- constant doesn't work
first query is SAT, returning the model:
reservedconst_1: -1
1 th attempt: second query is SAT-- constant doesn't work
first query is UNSAT-- no more guesses
Dataflow Pruned 0/0
There are 1 Guesses
There are 0 RHSs before deduplication
There are 0 RHSs after deduplication
got 3 candidates from LHS

-------------------------------------------------
%0:i8 = var
%1:i32 = sext %0
%2:i1 = eq 45:i32, %1
infer %2


--------------------------------
guess 0

%0:i1 = var ; reservedconst_1

Cost = 0
first query is SAT, returning the model:
reservedconst_1: 0
0 th attempt: second query is SAT-- constant doesn't work
first query is SAT, returning the model:
reservedconst_1: -1
1 th attempt: second query is SAT-- constant doesn't work
first query is UNSAT-- no more guesses
Dataflow Pruned 0/0
There are 1 Guesses
There are 0 RHSs before deduplication
There are 0 RHSs after deduplication
got 4 candidates from LHS

-------------------------------------------------
%0:i8 = var
%1:i32 = sext %0
%2:i1 = eq 45:i32, %1 (hasExternalUses)
%3:i32 = select %2, 1:i32, 2:i32
infer %3


--------------------------------
guess 0

%0:i32 = var ; reservedconst_1

Cost = 0
first query is SAT, returning the model:
reservedconst_1: 2
0 th attempt: second query is SAT-- constant doesn't work
first query is SAT, returning the model:
reservedconst_1: 1
1 th attempt: second query is SAT-- constant doesn't work
first query is UNSAT-- no more guesses

--------------------------------
guess 1

%0:i8 = var
%1:i32 = sext %0

Cost = 1
second query is SAT-- constant doesn't work
Dataflow Pruned 0/0
There are 2 Guesses
There are 0 RHSs before deduplication
There are 0 RHSs after deduplication
got 5 candidates from LHS

-------------------------------------------------
%0 = block 2
%1:i8 = var
%2:i32 = sext %1
%3:i1 = eq 45:i32, %2 (hasExternalUses)
%4:i32 = select %3, 1:i32, 2:i32
%5:i32 = phi %0, 2:i32, %4
infer %5


--------------------------------
guess 0

%0:i32 = var ; reservedconst_1

Cost = 0
first query is SAT, returning the model:
reservedconst_1: 2
0 th attempt: second query is SAT-- constant doesn't work
first query is SAT, returning the model:
reservedconst_1: 1
1 th attempt: second query is SAT-- constant doesn't work
first query is UNSAT-- no more guesses

--------------------------------
guess 1

%0:i8 = var
%1:i32 = sext %0

Cost = 1
second query is SAT-- constant doesn't work
Dataflow Pruned 0/0
There are 2 Guesses
There are 0 RHSs before deduplication
There are 0 RHSs after deduplication
got 6 candidates from LHS

-------------------------------------------------
%0 = block 2
%1 = block 2
%2:i8 = var
%3:i32 = sext %2
%4:i1 = eq 45:i32, %3
%5:i32 = select %4, 1:i32, 2:i32
%6:i32 = phi %1, 2:i32, %5
%7:i32 = phi %0, 1:i32, %6
infer %7


--------------------------------
guess 0

%0:i32 = var ; reservedconst_1

Cost = 0
first query is SAT, returning the model:
reservedconst_1: 2
0 th attempt: second query is SAT-- constant doesn't work
first query is SAT, returning the model:
reservedconst_1: 1
1 th attempt: second query is SAT-- constant doesn't work
first query is UNSAT-- no more guesses

--------------------------------
guess 1

%0:i8 = var
%1:i32 = sext %0

Cost = 1
second query is SAT-- constant doesn't work

--------------------------------
guess 2

%0:i8 = var
%1:i32 = sext %0
%2:i1 = eq 45:i32, %1 (hasExternalUses)
%3:i32 = select %2, 1:i32, 2:i32

Cost = 3
second query is SAT-- constant doesn't work

--------------------------------
guess 3

%0 = block 2
%1:i8 = var
%2:i32 = sext %1
%3:i1 = eq 45:i32, %2 (hasExternalUses)
%4:i32 = select %3, 1:i32, 2:i32
%5:i32 = phi %0, 2:i32, %4

Cost = 4
second query is SAT-- constant doesn't work
Dataflow Pruned 0/0
There are 4 Guesses
There are 0 RHSs before deduplication
There are 0 RHSs after deduplication
got 7 candidates from LHS

-------------------------------------------------
%0 = block 2
%1 = block 2
%2 = block 2
%3:i8 = var
%4:i32 = sext %3
%5:i1 = eq 45:i32, %4
%6:i32 = select %5, 1:i32, 2:i32
%7:i32 = phi %2, 2:i32, %6
%8:i32 = phi %1, 1:i32, %7
%9:i32 = phi %0, 2:i32, %8
infer %9


--------------------------------
guess 0

%0:i32 = var ; reservedconst_1

Cost = 0
first query is SAT, returning the model:
reservedconst_1: 2
0 th attempt: second query is SAT-- constant doesn't work
first query is SAT, returning the model:
reservedconst_1: 1
1 th attempt: second query is SAT-- constant doesn't work
first query is UNSAT-- no more guesses

--------------------------------
guess 1

%0:i8 = var
%1:i32 = sext %0

Cost = 1
second query is SAT-- constant doesn't work

--------------------------------
guess 2

%0:i8 = var
%1:i32 = sext %0
%2:i1 = eq 45:i32, %1 (hasExternalUses)
%3:i32 = select %2, 1:i32, 2:i32

Cost = 3
second query is SAT-- constant doesn't work

--------------------------------
guess 3

%0 = block 2
%1:i8 = var
%2:i32 = sext %1
%3:i1 = eq 45:i32, %2 (hasExternalUses)
%4:i32 = select %3, 1:i32, 2:i32
%5:i32 = phi %0, 2:i32, %4

Cost = 4
second query is SAT-- constant doesn't work

--------------------------------
guess 4

%0 = block 2
%1 = block 2
%2:i8 = var
%3:i32 = sext %2
%4:i1 = eq 45:i32, %3
%5:i32 = select %4, 1:i32, 2:i32
%6:i32 = phi %1, 2:i32, %5
%7:i32 = phi %0, 1:i32, %6

Cost = 7
second query is SAT-- constant doesn't work
Dataflow Pruned 0/0
There are 5 Guesses
There are 0 RHSs before deduplication
There are 0 RHSs after deduplication
got 8 candidates from LHS

-------------------------------------------------
%0 = block 2
%1 = block 2
%2 = block 2
%3 = block 2
%4:i8 = var
%5:i32 = sext %4
%6:i1 = eq 45:i32, %5
%7:i32 = select %6, 1:i32, 2:i32
%8:i32 = phi %3, 2:i32, %7
%9:i32 = phi %2, 1:i32, %8
%10:i32 = phi %1, 2:i32, %9
%11:i32 = phi %0, 1:i32, %10
infer %11


--------------------------------
guess 0

%0:i32 = var ; reservedconst_1

Cost = 0
first query is SAT, returning the model:
reservedconst_1: 2
0 th attempt: second query is SAT-- constant doesn't work
first query is SAT, returning the model:
reservedconst_1: 1
1 th attempt: second query is SAT-- constant doesn't work
first query is UNSAT-- no more guesses

--------------------------------
guess 1

%0:i8 = var
%1:i32 = sext %0

Cost = 1
second query is SAT-- constant doesn't work

--------------------------------
guess 2

%0:i8 = var
%1:i32 = sext %0
%2:i1 = eq 45:i32, %1 (hasExternalUses)
%3:i32 = select %2, 1:i32, 2:i32

Cost = 3
second query is SAT-- constant doesn't work

--------------------------------
guess 3

%0 = block 2
%1:i8 = var
%2:i32 = sext %1
%3:i1 = eq 45:i32, %2 (hasExternalUses)
%4:i32 = select %3, 1:i32, 2:i32
%5:i32 = phi %0, 2:i32, %4

Cost = 4
second query is SAT-- constant doesn't work

--------------------------------
guess 4

%0 = block 2
%1 = block 2
%2:i8 = var
%3:i32 = sext %2
%4:i1 = eq 45:i32, %3
%5:i32 = select %4, 1:i32, 2:i32
%6:i32 = phi %1, 2:i32, %5
%7:i32 = phi %0, 1:i32, %6

Cost = 7
second query is SAT-- constant doesn't work

--------------------------------
guess 5

%0 = block 2
%1 = block 2
%2 = block 2
%3:i8 = var
%4:i32 = sext %3
%5:i1 = eq 45:i32, %4
%6:i32 = select %5, 1:i32, 2:i32
%7:i32 = phi %2, 2:i32, %6
%8:i32 = phi %1, 1:i32, %7
%9:i32 = phi %0, 2:i32, %8

Cost = 8
second query is SAT-- constant doesn't work
Dataflow Pruned 0/0
There are 6 Guesses
There are 0 RHSs before deduplication
There are 0 RHSs after deduplication
got 8 candidates from LHS

-------------------------------------------------
%0 = block 2
%1 = block 2
%2 = block 2
%3 = block 2
%4 = block 2
%5:i8 = var
%6:i32 = sext %5
%7:i1 = eq 45:i32, %6
%8:i32 = select %7, 1:i32, 2:i32
%9:i32 = phi %4, 2:i32, %8
%10:i32 = phi %3, 1:i32, %9
%11:i32 = phi %2, 2:i32, %10
%12:i32 = phi %1, 1:i32, %11
%13:i32 = phi %0, 2:i32, %12
infer %13


--------------------------------
guess 0

%0:i32 = var ; reservedconst_1

Cost = 0
first query is SAT, returning the model:
reservedconst_1: 2
0 th attempt: second query is SAT-- constant doesn't work
first query is SAT, returning the model:
reservedconst_1: 1
1 th attempt: second query is SAT-- constant doesn't work
first query is UNSAT-- no more guesses

--------------------------------
guess 1

%0:i8 = var
%1:i32 = sext %0

Cost = 1
second query is SAT-- constant doesn't work

--------------------------------
guess 2

%0:i8 = var
%1:i32 = sext %0
%2:i1 = eq 45:i32, %1 (hasExternalUses)
%3:i32 = select %2, 1:i32, 2:i32

Cost = 3
second query is SAT-- constant doesn't work

--------------------------------
guess 3

%0 = block 2
%1:i8 = var
%2:i32 = sext %1
%3:i1 = eq 45:i32, %2 (hasExternalUses)
%4:i32 = select %3, 1:i32, 2:i32
%5:i32 = phi %0, 2:i32, %4

Cost = 4
second query is SAT-- constant doesn't work

--------------------------------
guess 4

%0 = block 2
%1 = block 2
%2:i8 = var
%3:i32 = sext %2
%4:i1 = eq 45:i32, %3
%5:i32 = select %4, 1:i32, 2:i32
%6:i32 = phi %1, 2:i32, %5
%7:i32 = phi %0, 1:i32, %6

Cost = 7
second query is SAT-- constant doesn't work

--------------------------------
guess 5

%0 = block 2
%1 = block 2
%2 = block 2
%3:i8 = var
%4:i32 = sext %3
%5:i1 = eq 45:i32, %4
%6:i32 = select %5, 1:i32, 2:i32
%7:i32 = phi %2, 2:i32, %6
%8:i32 = phi %1, 1:i32, %7
%9:i32 = phi %0, 2:i32, %8

Cost = 8
second query is SAT-- constant doesn't work

--------------------------------
guess 6

%0 = block 2
%1 = block 2
%2 = block 2
%3 = block 2
%4:i8 = var
%5:i32 = sext %4
%6:i1 = eq 45:i32, %5
%7:i32 = select %6, 1:i32, 2:i32
%8:i32 = phi %3, 2:i32, %7
%9:i32 = phi %2, 1:i32, %8
%10:i32 = phi %1, 2:i32, %9
%11:i32 = phi %0, 1:i32, %10

Cost = 9
second query is SAT-- constant doesn't work
Dataflow Pruned 0/0
There are 7 Guesses
There are 0 RHSs before deduplication
There are 0 RHSs after deduplication
got 8 candidates from LHS

-------------------------------------------------
%0 = block 2
%1 = block 2
%2 = block 2
%3 = block 2
%4 = block 2
%5 = block 2
%6:i8 = var
%7:i32 = sext %6
%8:i1 = eq 45:i32, %7
%9:i32 = select %8, 1:i32, 2:i32
%10:i32 = phi %5, 2:i32, %9
%11:i32 = phi %4, 1:i32, %10
%12:i32 = phi %3, 2:i32, %11
%13:i32 = phi %2, 1:i32, %12
%14:i32 = phi %1, 2:i32, %13
%15:i32 = phi %0, 1:i32, %14
infer %15


--------------------------------
guess 0

%0:i32 = var ; reservedconst_1

Cost = 0
first query is SAT, returning the model:
reservedconst_1: 2
0 th attempt: second query is SAT-- constant doesn't work
first query is SAT, returning the model:
reservedconst_1: 1
1 th attempt: second query is SAT-- constant doesn't work
first query is UNSAT-- no more guesses

--------------------------------
guess 1

%0:i8 = var
%1:i32 = sext %0
%2:i1 = eq 45:i32, %1 (hasExternalUses)
%3:i32 = select %2, 1:i32, 2:i32

Cost = 3
second query is SAT-- constant doesn't work

--------------------------------
guess 2

%0 = block 2
%1:i8 = var
%2:i32 = sext %1
%3:i1 = eq 45:i32, %2 (hasExternalUses)
%4:i32 = select %3, 1:i32, 2:i32
%5:i32 = phi %0, 2:i32, %4

Cost = 4
second query is SAT-- constant doesn't work

--------------------------------
guess 3

%0 = block 2
%1 = block 2
%2:i8 = var
%3:i32 = sext %2
%4:i1 = eq 45:i32, %3
%5:i32 = select %4, 1:i32, 2:i32
%6:i32 = phi %1, 2:i32, %5
%7:i32 = phi %0, 1:i32, %6

Cost = 7
second query is SAT-- constant doesn't work

--------------------------------
guess 4

%0 = block 2
%1 = block 2
%2 = block 2
%3:i8 = var
%4:i32 = sext %3
%5:i1 = eq 45:i32, %4
%6:i32 = select %5, 1:i32, 2:i32
%7:i32 = phi %2, 2:i32, %6
%8:i32 = phi %1, 1:i32, %7
%9:i32 = phi %0, 2:i32, %8

Cost = 8
second query is SAT-- constant doesn't work

--------------------------------
guess 5

%0 = block 2
%1 = block 2
%2 = block 2
%3 = block 2
%4:i8 = var
%5:i32 = sext %4
%6:i1 = eq 45:i32, %5
%7:i32 = select %6, 1:i32, 2:i32
%8:i32 = phi %3, 2:i32, %7
%9:i32 = phi %2, 1:i32, %8
%10:i32 = phi %1, 2:i32, %9
%11:i32 = phi %0, 1:i32, %10

Cost = 9
second query is SAT-- constant doesn't work

--------------------------------
guess 6

%0 = block 2
%1 = block 2
%2 = block 2
%3 = block 2
%4 = block 2
%5:i8 = var
%6:i32 = sext %5
%7:i1 = eq 45:i32, %6
%8:i32 = select %7, 1:i32, 2:i32
%9:i32 = phi %4, 2:i32, %8
%10:i32 = phi %3, 1:i32, %9
%11:i32 = phi %2, 2:i32, %10
%12:i32 = phi %1, 1:i32, %11
%13:i32 = phi %0, 2:i32, %12

Cost = 10
second query is SAT-- constant doesn't work
Dataflow Pruned 0/0
There are 7 Guesses
There are 0 RHSs before deduplication
There are 0 RHSs after deduplication
got 8 candidates from LHS

-------------------------------------------------
%0 = block 2
%1 = block 2
%2 = block 2
%3 = block 2
%4 = block 2
%5 = block 2
%6 = block 2
%7:i8 = var
%8:i32 = sext %7
%9:i1 = eq 45:i32, %8
%10:i32 = select %9, 1:i32, 2:i32
%11:i32 = phi %6, 2:i32, %10
%12:i32 = phi %5, 1:i32, %11
%13:i32 = phi %4, 2:i32, %12
%14:i32 = phi %3, 1:i32, %13
%15:i32 = phi %2, 2:i32, %14
%16:i32 = phi %1, 1:i32, %15
%17:i32 = phi %0, 2:i32, %16
infer %17


--------------------------------
guess 0

%0:i32 = var ; reservedconst_1

Cost = 0
first query is SAT, returning the model:
reservedconst_1: 2
0 th attempt: second query is SAT-- constant doesn't work
first query is SAT, returning the model:
reservedconst_1: 1
1 th attempt: second query is SAT-- constant doesn't work
first query is UNSAT-- no more guesses

--------------------------------
guess 1

%0:i8 = var
%1:i32 = sext %0
%2:i1 = eq 45:i32, %1 (hasExternalUses)
%3:i32 = select %2, 1:i32, 2:i32

Cost = 3
second query is SAT-- constant doesn't work

--------------------------------
guess 2

%0 = block 2
%1:i8 = var
%2:i32 = sext %1
%3:i1 = eq 45:i32, %2 (hasExternalUses)
%4:i32 = select %3, 1:i32, 2:i32
%5:i32 = phi %0, 2:i32, %4

Cost = 4
second query is SAT-- constant doesn't work

--------------------------------
guess 3

%0 = block 2
%1 = block 2
%2:i8 = var
%3:i32 = sext %2
%4:i1 = eq 45:i32, %3
%5:i32 = select %4, 1:i32, 2:i32
%6:i32 = phi %1, 2:i32, %5
%7:i32 = phi %0, 1:i32, %6

Cost = 7
second query is SAT-- constant doesn't work

--------------------------------
guess 4

%0 = block 2
%1 = block 2
%2 = block 2
%3:i8 = var
%4:i32 = sext %3
%5:i1 = eq 45:i32, %4
%6:i32 = select %5, 1:i32, 2:i32
%7:i32 = phi %2, 2:i32, %6
%8:i32 = phi %1, 1:i32, %7
%9:i32 = phi %0, 2:i32, %8

Cost = 8
second query is SAT-- constant doesn't work

--------------------------------
guess 5

%0 = block 2
%1 = block 2
%2 = block 2
%3 = block 2
%4:i8 = var
%5:i32 = sext %4
%6:i1 = eq 45:i32, %5
%7:i32 = select %6, 1:i32, 2:i32
%8:i32 = phi %3, 2:i32, %7
%9:i32 = phi %2, 1:i32, %8
%10:i32 = phi %1, 2:i32, %9
%11:i32 = phi %0, 1:i32, %10

Cost = 9
second query is SAT-- constant doesn't work

--------------------------------
guess 6

%0 = block 2
%1 = block 2
%2 = block 2
%3 = block 2
%4 = block 2
%5:i8 = var
%6:i32 = sext %5
%7:i1 = eq 45:i32, %6
%8:i32 = select %7, 1:i32, 2:i32
%9:i32 = phi %4, 2:i32, %8
%10:i32 = phi %3, 1:i32, %9
%11:i32 = phi %2, 2:i32, %10
%12:i32 = phi %1, 1:i32, %11
%13:i32 = phi %0, 2:i32, %12

Cost = 10
second query is SAT-- constant doesn't work

--------------------------------
guess 7

%0 = block 2
%1 = block 2
%2 = block 2
%3 = block 2
%4 = block 2
%5 = block 2
%6:i8 = var
%7:i32 = sext %6
%8:i1 = eq 45:i32, %7
%9:i32 = select %8, 1:i32, 2:i32
%10:i32 = phi %5, 2:i32, %9
%11:i32 = phi %4, 1:i32, %10
%12:i32 = phi %3, 2:i32, %11
%13:i32 = phi %2, 1:i32, %12
%14:i32 = phi %1, 2:i32, %13
%15:i32 = phi %0, 1:i32, %14

Cost = 11
second query is SAT-- constant doesn't work
Dataflow Pruned 0/0
There are 8 Guesses
There are 0 RHSs before deduplication
There are 0 RHSs after deduplication
got 8 candidates from LHS

-------------------------------------------------
%0 = block 2
%1 = block 2
%2 = block 2
%3 = block 2
%4 = block 2
%5 = block 2
%6 = block 2
%7 = block 2
%8:i8 = var
%9:i32 = sext %8
%10:i1 = eq 45:i32, %9
%11:i32 = select %10, 1:i32, 2:i32
%12:i32 = phi %7, 2:i32, %11
%13:i32 = phi %6, 1:i32, %12
%14:i32 = phi %5, 2:i32, %13
%15:i32 = phi %4, 1:i32, %14
%16:i32 = phi %3, 2:i32, %15
%17:i32 = phi %2, 1:i32, %16
%18:i32 = phi %1, 2:i32, %17
%19:i32 = phi %0, 1:i32, %18
infer %19


--------------------------------
guess 0

%0:i32 = var ; reservedconst_1

Cost = 0
first query is SAT, returning the model:
reservedconst_1: 2
0 th attempt: second query is SAT-- constant doesn't work
first query is SAT, returning the model:
reservedconst_1: 1
1 th attempt: second query is SAT-- constant doesn't work
first query is UNSAT-- no more guesses

--------------------------------
guess 1

%0 = block 2
%1:i8 = var
%2:i32 = sext %1
%3:i1 = eq 45:i32, %2 (hasExternalUses)
%4:i32 = select %3, 1:i32, 2:i32
%5:i32 = phi %0, 2:i32, %4

Cost = 4
second query is SAT-- constant doesn't work

--------------------------------
guess 2

%0 = block 2
%1 = block 2
%2:i8 = var
%3:i32 = sext %2
%4:i1 = eq 45:i32, %3
%5:i32 = select %4, 1:i32, 2:i32
%6:i32 = phi %1, 2:i32, %5
%7:i32 = phi %0, 1:i32, %6

Cost = 7
second query is SAT-- constant doesn't work

--------------------------------
guess 3

%0 = block 2
%1 = block 2
%2 = block 2
%3:i8 = var
%4:i32 = sext %3
%5:i1 = eq 45:i32, %4
%6:i32 = select %5, 1:i32, 2:i32
%7:i32 = phi %2, 2:i32, %6
%8:i32 = phi %1, 1:i32, %7
%9:i32 = phi %0, 2:i32, %8

Cost = 8
second query is SAT-- constant doesn't work

--------------------------------
guess 4

%0 = block 2
%1 = block 2
%2 = block 2
%3 = block 2
%4:i8 = var
%5:i32 = sext %4
%6:i1 = eq 45:i32, %5
%7:i32 = select %6, 1:i32, 2:i32
%8:i32 = phi %3, 2:i32, %7
%9:i32 = phi %2, 1:i32, %8
%10:i32 = phi %1, 2:i32, %9
%11:i32 = phi %0, 1:i32, %10

Cost = 9
second query is SAT-- constant doesn't work

--------------------------------
guess 5

%0 = block 2
%1 = block 2
%2 = block 2
%3 = block 2
%4 = block 2
%5:i8 = var
%6:i32 = sext %5
%7:i1 = eq 45:i32, %6
%8:i32 = select %7, 1:i32, 2:i32
%9:i32 = phi %4, 2:i32, %8
%10:i32 = phi %3, 1:i32, %9
%11:i32 = phi %2, 2:i32, %10
%12:i32 = phi %1, 1:i32, %11
%13:i32 = phi %0, 2:i32, %12

Cost = 10
second query is SAT-- constant doesn't work

--------------------------------
guess 6

%0 = block 2
%1 = block 2
%2 = block 2
%3 = block 2
%4 = block 2
%5 = block 2
%6:i8 = var
%7:i32 = sext %6
%8:i1 = eq 45:i32, %7
%9:i32 = select %8, 1:i32, 2:i32
%10:i32 = phi %5, 2:i32, %9
%11:i32 = phi %4, 1:i32, %10
%12:i32 = phi %3, 2:i32, %11
%13:i32 = phi %2, 1:i32, %12
%14:i32 = phi %1, 2:i32, %13
%15:i32 = phi %0, 1:i32, %14

Cost = 11
second query is SAT-- constant doesn't work

--------------------------------
guess 7

%0 = block 2
%1 = block 2
%2 = block 2
%3 = block 2
%4 = block 2
%5 = block 2
%6 = block 2
%7:i8 = var
%8:i32 = sext %7
%9:i1 = eq 45:i32, %8
%10:i32 = select %9, 1:i32, 2:i32
%11:i32 = phi %6, 2:i32, %10
%12:i32 = phi %5, 1:i32, %11
%13:i32 = phi %4, 2:i32, %12
%14:i32 = phi %3, 1:i32, %13
%15:i32 = phi %2, 2:i32, %14
%16:i32 = phi %1, 1:i32, %15
%17:i32 = phi %0, 2:i32, %16

Cost = 12
second query is SAT-- constant doesn't work
Dataflow Pruned 0/0
There are 8 Guesses
There are 0 RHSs before deduplication
There are 0 RHSs after deduplication
got 8 candidates from LHS

-------------------------------------------------
%0 = block 2
%1 = block 2
%2 = block 2
%3 = block 2
%4 = block 2
%5 = block 2
%6 = block 2
%7 = block 2
%8 = block 2
%9:i8 = var
%10:i32 = sext %9
%11:i1 = eq 45:i32, %10
%12:i32 = select %11, 1:i32, 2:i32
%13:i32 = phi %8, 2:i32, %12
%14:i32 = phi %7, 1:i32, %13
%15:i32 = phi %6, 2:i32, %14
%16:i32 = phi %5, 1:i32, %15
%17:i32 = phi %4, 2:i32, %16
%18:i32 = phi %3, 1:i32, %17
%19:i32 = phi %2, 2:i32, %18
%20:i32 = phi %1, 1:i32, %19
%21:i32 = phi %0, 0:i32, %20
infer %21


--------------------------------
guess 0

%0:i32 = var ; reservedconst_1

Cost = 0
first query is SAT, returning the model:
reservedconst_1: 2
0 th attempt: second query is SAT-- constant doesn't work
first query is SAT, returning the model:
reservedconst_1: 0
1 th attempt: second query is SAT-- constant doesn't work
first query is SAT, returning the model:
reservedconst_1: 1
2 th attempt: second query is SAT-- constant doesn't work
first query is UNSAT-- no more guesses

--------------------------------
guess 1

%0 = block 2
%1 = block 2
%2:i8 = var
%3:i32 = sext %2
%4:i1 = eq 45:i32, %3
%5:i32 = select %4, 1:i32, 2:i32
%6:i32 = phi %1, 2:i32, %5
%7:i32 = phi %0, 1:i32, %6

Cost = 7
second query is SAT-- constant doesn't work

--------------------------------
guess 2

%0 = block 2
%1 = block 2
%2 = block 2
%3:i8 = var
%4:i32 = sext %3
%5:i1 = eq 45:i32, %4
%6:i32 = select %5, 1:i32, 2:i32
%7:i32 = phi %2, 2:i32, %6
%8:i32 = phi %1, 1:i32, %7
%9:i32 = phi %0, 2:i32, %8

Cost = 8
second query is SAT-- constant doesn't work

--------------------------------
guess 3

%0 = block 2
%1 = block 2
%2 = block 2
%3 = block 2
%4:i8 = var
%5:i32 = sext %4
%6:i1 = eq 45:i32, %5
%7:i32 = select %6, 1:i32, 2:i32
%8:i32 = phi %3, 2:i32, %7
%9:i32 = phi %2, 1:i32, %8
%10:i32 = phi %1, 2:i32, %9
%11:i32 = phi %0, 1:i32, %10

Cost = 9
second query is SAT-- constant doesn't work

--------------------------------
guess 4

%0 = block 2
%1 = block 2
%2 = block 2
%3 = block 2
%4 = block 2
%5:i8 = var
%6:i32 = sext %5
%7:i1 = eq 45:i32, %6
%8:i32 = select %7, 1:i32, 2:i32
%9:i32 = phi %4, 2:i32, %8
%10:i32 = phi %3, 1:i32, %9
%11:i32 = phi %2, 2:i32, %10
%12:i32 = phi %1, 1:i32, %11
%13:i32 = phi %0, 2:i32, %12

Cost = 10
second query is SAT-- constant doesn't work

--------------------------------
guess 5

%0 = block 2
%1 = block 2
%2 = block 2
%3 = block 2
%4 = block 2
%5 = block 2
%6:i8 = var
%7:i32 = sext %6
%8:i1 = eq 45:i32, %7
%9:i32 = select %8, 1:i32, 2:i32
%10:i32 = phi %5, 2:i32, %9
%11:i32 = phi %4, 1:i32, %10
%12:i32 = phi %3, 2:i32, %11
%13:i32 = phi %2, 1:i32, %12
%14:i32 = phi %1, 2:i32, %13
%15:i32 = phi %0, 1:i32, %14

Cost = 11
second query is SAT-- constant doesn't work

--------------------------------
guess 6

%0 = block 2
%1 = block 2
%2 = block 2
%3 = block 2
%4 = block 2
%5 = block 2
%6 = block 2
%7:i8 = var
%8:i32 = sext %7
%9:i1 = eq 45:i32, %8
%10:i32 = select %9, 1:i32, 2:i32
%11:i32 = phi %6, 2:i32, %10
%12:i32 = phi %5, 1:i32, %11
%13:i32 = phi %4, 2:i32, %12
%14:i32 = phi %3, 1:i32, %13
%15:i32 = phi %2, 2:i32, %14
%16:i32 = phi %1, 1:i32, %15
%17:i32 = phi %0, 2:i32, %16

Cost = 12
second query is SAT-- constant doesn't work

--------------------------------
guess 7

%0 = block 2
%1 = block 2
%2 = block 2
%3 = block 2
%4 = block 2
%5 = block 2
%6 = block 2
%7 = block 2
%8:i8 = var
%9:i32 = sext %8
%10:i1 = eq 45:i32, %9
%11:i32 = select %10, 1:i32, 2:i32
%12:i32 = phi %7, 2:i32, %11
%13:i32 = phi %6, 1:i32, %12
%14:i32 = phi %5, 2:i32, %13
%15:i32 = phi %4, 1:i32, %14
%16:i32 = phi %3, 2:i32, %15
%17:i32 = phi %2, 1:i32, %16
%18:i32 = phi %1, 2:i32, %17
%19:i32 = phi %0, 1:i32, %18

Cost = 13
second query is SAT-- constant doesn't work
Dataflow Pruned 0/0
There are 8 Guesses
There are 0 RHSs before deduplication
There are 0 RHSs after deduplication
#########################################################
; exiting Souper's runOnFunction() for precedenceCheck()

; entering Souper's runOnFunction() for isOperator()

; ModuleID = './Parsing-RPN_to_infix_conversion.c.bc'
source_filename = "./Parsing-RPN_to_infix_conversion.c"
target datalayout = "e-m:e-p:32:32-i64:64-n32:64-S128"
target triple = "wasm32-unknown-wasi"

%struct.elem = type { [10 x i8], %struct.elem*, %struct.elem* }

@counter = hidden global i32 0, align 4
@.str = private unnamed_addr constant [2 x i8] c"(\00", align 1
@.str.1 = private unnamed_addr constant [2 x i8] c")\00", align 1
@.str.2 = private unnamed_addr constant [5 x i8] c" %s \00", align 1
@.str.3 = private unnamed_addr constant [15 x i8] c"\0AInvalid RPN !\00", align 1
@components = hidden global i8** null, align 4
@.str.4 = private unnamed_addr constant [2 x i8] c"\0A\00", align 1
@.str.5 = private unnamed_addr constant [2 x i8] c" \00", align 1
@.str.6 = private unnamed_addr constant [95 x i8] c"Usage : %s <RPN expression enclosed by quotes> <optional parameter to trace the build process>\00", align 1
@.str.7 = private unnamed_addr constant [27 x i8] c"\0AFinal infix expression : \00", align 1

; Function Attrs: noinline nounwind optnone
define hidden i32 @precedenceCheck(i8 signext %oper1, i8 signext %oper2) #0 {
entry:
  %oper1.addr = alloca i8, align 1
  %oper2.addr = alloca i8, align 1
  store i8 %oper1, i8* %oper1.addr, align 1
  store i8 %oper2, i8* %oper2.addr, align 1
  %0 = load i8, i8* %oper1.addr, align 1
  %conv = sext i8 %0 to i32
  %1 = load i8, i8* %oper2.addr, align 1
  %conv1 = sext i8 %1 to i32
  %cmp = icmp eq i32 %conv, %conv1
  br i1 %cmp, label %cond.true, label %cond.false

cond.true:                                        ; preds = %entry
  br label %cond.end61

cond.false:                                       ; preds = %entry
  %2 = load i8, i8* %oper1.addr, align 1
  %conv3 = sext i8 %2 to i32
  %cmp4 = icmp eq i32 %conv3, 94
  br i1 %cmp4, label %cond.true6, label %cond.false7

cond.true6:                                       ; preds = %cond.false
  br label %cond.end59

cond.false7:                                      ; preds = %cond.false
  %3 = load i8, i8* %oper2.addr, align 1
  %conv8 = sext i8 %3 to i32
  %cmp9 = icmp eq i32 %conv8, 94
  br i1 %cmp9, label %cond.true11, label %cond.false12

cond.true11:                                      ; preds = %cond.false7
  br label %cond.end57

cond.false12:                                     ; preds = %cond.false7
  %4 = load i8, i8* %oper1.addr, align 1
  %conv13 = sext i8 %4 to i32
  %cmp14 = icmp eq i32 %conv13, 47
  br i1 %cmp14, label %cond.true16, label %cond.false17

cond.true16:                                      ; preds = %cond.false12
  br label %cond.end55

cond.false17:                                     ; preds = %cond.false12
  %5 = load i8, i8* %oper2.addr, align 1
  %conv18 = sext i8 %5 to i32
  %cmp19 = icmp eq i32 %conv18, 47
  br i1 %cmp19, label %cond.true21, label %cond.false22

cond.true21:                                      ; preds = %cond.false17
  br label %cond.end53

cond.false22:                                     ; preds = %cond.false17
  %6 = load i8, i8* %oper1.addr, align 1
  %conv23 = sext i8 %6 to i32
  %cmp24 = icmp eq i32 %conv23, 42
  br i1 %cmp24, label %cond.true26, label %cond.false27

cond.true26:                                      ; preds = %cond.false22
  br label %cond.end51

cond.false27:                                     ; preds = %cond.false22
  %7 = load i8, i8* %oper2.addr, align 1
  %conv28 = sext i8 %7 to i32
  %cmp29 = icmp eq i32 %conv28, 42
  br i1 %cmp29, label %cond.true31, label %cond.false32

cond.true31:                                      ; preds = %cond.false27
  br label %cond.end49

cond.false32:                                     ; preds = %cond.false27
  %8 = load i8, i8* %oper1.addr, align 1
  %conv33 = sext i8 %8 to i32
  %cmp34 = icmp eq i32 %conv33, 43
  br i1 %cmp34, label %cond.true36, label %cond.false37

cond.true36:                                      ; preds = %cond.false32
  br label %cond.end47

cond.false37:                                     ; preds = %cond.false32
  %9 = load i8, i8* %oper2.addr, align 1
  %conv38 = sext i8 %9 to i32
  %cmp39 = icmp eq i32 %conv38, 43
  br i1 %cmp39, label %cond.true41, label %cond.false42

cond.true41:                                      ; preds = %cond.false37
  br label %cond.end

cond.false42:                                     ; preds = %cond.false37
  %10 = load i8, i8* %oper1.addr, align 1
  %conv43 = sext i8 %10 to i32
  %cmp44 = icmp eq i32 %conv43, 45
  %11 = zext i1 %cmp44 to i64
  %cond = select i1 %cmp44, i32 1, i32 2
  br label %cond.end

cond.end:                                         ; preds = %cond.false42, %cond.true41
  %cond46 = phi i32 [ 2, %cond.true41 ], [ %cond, %cond.false42 ]
  br label %cond.end47

cond.end47:                                       ; preds = %cond.end, %cond.true36
  %cond48 = phi i32 [ 1, %cond.true36 ], [ %cond46, %cond.end ]
  br label %cond.end49

cond.end49:                                       ; preds = %cond.end47, %cond.true31
  %cond50 = phi i32 [ 2, %cond.true31 ], [ %cond48, %cond.end47 ]
  br label %cond.end51

cond.end51:                                       ; preds = %cond.end49, %cond.true26
  %cond52 = phi i32 [ 1, %cond.true26 ], [ %cond50, %cond.end49 ]
  br label %cond.end53

cond.end53:                                       ; preds = %cond.end51, %cond.true21
  %cond54 = phi i32 [ 2, %cond.true21 ], [ %cond52, %cond.end51 ]
  br label %cond.end55

cond.end55:                                       ; preds = %cond.end53, %cond.true16
  %cond56 = phi i32 [ 1, %cond.true16 ], [ %cond54, %cond.end53 ]
  br label %cond.end57

cond.end57:                                       ; preds = %cond.end55, %cond.true11
  %cond58 = phi i32 [ 2, %cond.true11 ], [ %cond56, %cond.end55 ]
  br label %cond.end59

cond.end59:                                       ; preds = %cond.end57, %cond.true6
  %cond60 = phi i32 [ 1, %cond.true6 ], [ %cond58, %cond.end57 ]
  br label %cond.end61

cond.end61:                                       ; preds = %cond.end59, %cond.true
  %cond62 = phi i32 [ 0, %cond.true ], [ %cond60, %cond.end59 ]
  ret i32 %cond62
}

; Function Attrs: noinline nounwind optnone
define hidden i32 @isOperator(i8 signext %c) #0 {
entry:
  %c.addr = alloca i8, align 1
  store i8 %c, i8* %c.addr, align 1
  %0 = load i8, i8* %c.addr, align 1
  %conv = sext i8 %0 to i32
  %cmp = icmp eq i32 %conv, 43
  br i1 %cmp, label %lor.end, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %entry
  %1 = load i8, i8* %c.addr, align 1
  %conv2 = sext i8 %1 to i32
  %cmp3 = icmp eq i32 %conv2, 45
  br i1 %cmp3, label %lor.end, label %lor.lhs.false5

lor.lhs.false5:                                   ; preds = %lor.lhs.false
  %2 = load i8, i8* %c.addr, align 1
  %conv6 = sext i8 %2 to i32
  %cmp7 = icmp eq i32 %conv6, 42
  br i1 %cmp7, label %lor.end, label %lor.lhs.false9

lor.lhs.false9:                                   ; preds = %lor.lhs.false5
  %3 = load i8, i8* %c.addr, align 1
  %conv10 = sext i8 %3 to i32
  %cmp11 = icmp eq i32 %conv10, 47
  br i1 %cmp11, label %lor.end, label %lor.rhs

lor.rhs:                                          ; preds = %lor.lhs.false9
  %4 = load i8, i8* %c.addr, align 1
  %conv13 = sext i8 %4 to i32
  %cmp14 = icmp eq i32 %conv13, 94
  br label %lor.end

lor.end:                                          ; preds = %lor.rhs, %lor.lhs.false9, %lor.lhs.false5, %lor.lhs.false, %entry
  %5 = phi i1 [ true, %lor.lhs.false9 ], [ true, %lor.lhs.false5 ], [ true, %lor.lhs.false ], [ true, %entry ], [ %cmp14, %lor.rhs ]
  %lor.ext = zext i1 %5 to i32
  ret i32 %lor.ext
}

; Function Attrs: noinline nounwind optnone
define hidden void @inorder(%struct.elem* %t) #0 {
entry:
  %t.addr = alloca %struct.elem*, align 4
  store %struct.elem* %t, %struct.elem** %t.addr, align 4
  %0 = load %struct.elem*, %struct.elem** %t.addr, align 4
  %cmp = icmp ne %struct.elem* %0, null
  br i1 %cmp, label %if.then, label %if.end71

if.then:                                          ; preds = %entry
  %1 = load %struct.elem*, %struct.elem** %t.addr, align 4
  %left = getelementptr inbounds %struct.elem, %struct.elem* %1, i32 0, i32 1
  %2 = load %struct.elem*, %struct.elem** %left, align 4
  %cmp1 = icmp ne %struct.elem* %2, null
  br i1 %cmp1, label %land.lhs.true, label %if.else

land.lhs.true:                                    ; preds = %if.then
  %3 = load %struct.elem*, %struct.elem** %t.addr, align 4
  %left2 = getelementptr inbounds %struct.elem, %struct.elem* %3, i32 0, i32 1
  %4 = load %struct.elem*, %struct.elem** %left2, align 4
  %data = getelementptr inbounds %struct.elem, %struct.elem* %4, i32 0, i32 0
  %arrayidx = getelementptr inbounds [10 x i8], [10 x i8]* %data, i32 0, i32 0
  %5 = load i8, i8* %arrayidx, align 4
  %call = call i32 @isOperator(i8 signext %5)
  %cmp3 = icmp eq i32 %call, 1
  br i1 %cmp3, label %land.lhs.true4, label %if.else

land.lhs.true4:                                   ; preds = %land.lhs.true
  %6 = load %struct.elem*, %struct.elem** %t.addr, align 4
  %data5 = getelementptr inbounds %struct.elem, %struct.elem* %6, i32 0, i32 0
  %arrayidx6 = getelementptr inbounds [10 x i8], [10 x i8]* %data5, i32 0, i32 0
  %7 = load i8, i8* %arrayidx6, align 4
  %8 = load %struct.elem*, %struct.elem** %t.addr, align 4
  %left7 = getelementptr inbounds %struct.elem, %struct.elem* %8, i32 0, i32 1
  %9 = load %struct.elem*, %struct.elem** %left7, align 4
  %data8 = getelementptr inbounds %struct.elem, %struct.elem* %9, i32 0, i32 0
  %arrayidx9 = getelementptr inbounds [10 x i8], [10 x i8]* %data8, i32 0, i32 0
  %10 = load i8, i8* %arrayidx9, align 4
  %call10 = call i32 @precedenceCheck(i8 signext %7, i8 signext %10)
  %cmp11 = icmp eq i32 %call10, 1
  br i1 %cmp11, label %if.then24, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %land.lhs.true4
  %11 = load %struct.elem*, %struct.elem** %t.addr, align 4
  %data12 = getelementptr inbounds %struct.elem, %struct.elem* %11, i32 0, i32 0
  %arrayidx13 = getelementptr inbounds [10 x i8], [10 x i8]* %data12, i32 0, i32 0
  %12 = load i8, i8* %arrayidx13, align 4
  %13 = load %struct.elem*, %struct.elem** %t.addr, align 4
  %left14 = getelementptr inbounds %struct.elem, %struct.elem* %13, i32 0, i32 1
  %14 = load %struct.elem*, %struct.elem** %left14, align 4
  %data15 = getelementptr inbounds %struct.elem, %struct.elem* %14, i32 0, i32 0
  %arrayidx16 = getelementptr inbounds [10 x i8], [10 x i8]* %data15, i32 0, i32 0
  %15 = load i8, i8* %arrayidx16, align 4
  %call17 = call i32 @precedenceCheck(i8 signext %12, i8 signext %15)
  %cmp18 = icmp eq i32 %call17, 0
  br i1 %cmp18, label %land.lhs.true19, label %if.else

land.lhs.true19:                                  ; preds = %lor.lhs.false
  %16 = load %struct.elem*, %struct.elem** %t.addr, align 4
  %data20 = getelementptr inbounds %struct.elem, %struct.elem* %16, i32 0, i32 0
  %arrayidx21 = getelementptr inbounds [10 x i8], [10 x i8]* %data20, i32 0, i32 0
  %17 = load i8, i8* %arrayidx21, align 4
  %conv = sext i8 %17 to i32
  %cmp22 = icmp eq i32 %conv, 94
  br i1 %cmp22, label %if.then24, label %if.else

if.then24:                                        ; preds = %land.lhs.true19, %land.lhs.true4
  %call25 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([2 x i8], [2 x i8]* @.str, i32 0, i32 0))
  %18 = load %struct.elem*, %struct.elem** %t.addr, align 4
  %left26 = getelementptr inbounds %struct.elem, %struct.elem* %18, i32 0, i32 1
  %19 = load %struct.elem*, %struct.elem** %left26, align 4
  call void @inorder(%struct.elem* %19)
  %call27 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([2 x i8], [2 x i8]* @.str.1, i32 0, i32 0))
  br label %if.end

if.else:                                          ; preds = %land.lhs.true19, %lor.lhs.false, %land.lhs.true, %if.then
  %20 = load %struct.elem*, %struct.elem** %t.addr, align 4
  %left28 = getelementptr inbounds %struct.elem, %struct.elem* %20, i32 0, i32 1
  %21 = load %struct.elem*, %struct.elem** %left28, align 4
  call void @inorder(%struct.elem* %21)
  br label %if.end

if.end:                                           ; preds = %if.else, %if.then24
  %22 = load %struct.elem*, %struct.elem** %t.addr, align 4
  %data29 = getelementptr inbounds %struct.elem, %struct.elem* %22, i32 0, i32 0
  %arraydecay = getelementptr inbounds [10 x i8], [10 x i8]* %data29, i32 0, i32 0
  %call30 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.2, i32 0, i32 0), i8* %arraydecay)
  %23 = load %struct.elem*, %struct.elem** %t.addr, align 4
  %right = getelementptr inbounds %struct.elem, %struct.elem* %23, i32 0, i32 2
  %24 = load %struct.elem*, %struct.elem** %right, align 4
  %cmp31 = icmp ne %struct.elem* %24, null
  br i1 %cmp31, label %land.lhs.true33, label %if.else68

land.lhs.true33:                                  ; preds = %if.end
  %25 = load %struct.elem*, %struct.elem** %t.addr, align 4
  %right34 = getelementptr inbounds %struct.elem, %struct.elem* %25, i32 0, i32 2
  %26 = load %struct.elem*, %struct.elem** %right34, align 4
  %data35 = getelementptr inbounds %struct.elem, %struct.elem* %26, i32 0, i32 0
  %arrayidx36 = getelementptr inbounds [10 x i8], [10 x i8]* %data35, i32 0, i32 0
  %27 = load i8, i8* %arrayidx36, align 4
  %call37 = call i32 @isOperator(i8 signext %27)
  %cmp38 = icmp eq i32 %call37, 1
  br i1 %cmp38, label %land.lhs.true40, label %if.else68

land.lhs.true40:                                  ; preds = %land.lhs.true33
  %28 = load %struct.elem*, %struct.elem** %t.addr, align 4
  %data41 = getelementptr inbounds %struct.elem, %struct.elem* %28, i32 0, i32 0
  %arrayidx42 = getelementptr inbounds [10 x i8], [10 x i8]* %data41, i32 0, i32 0
  %29 = load i8, i8* %arrayidx42, align 4
  %30 = load %struct.elem*, %struct.elem** %t.addr, align 4
  %right43 = getelementptr inbounds %struct.elem, %struct.elem* %30, i32 0, i32 2
  %31 = load %struct.elem*, %struct.elem** %right43, align 4
  %data44 = getelementptr inbounds %struct.elem, %struct.elem* %31, i32 0, i32 0
  %arrayidx45 = getelementptr inbounds [10 x i8], [10 x i8]* %data44, i32 0, i32 0
  %32 = load i8, i8* %arrayidx45, align 4
  %call46 = call i32 @precedenceCheck(i8 signext %29, i8 signext %32)
  %cmp47 = icmp eq i32 %call46, 1
  br i1 %cmp47, label %if.then64, label %lor.lhs.false49

lor.lhs.false49:                                  ; preds = %land.lhs.true40
  %33 = load %struct.elem*, %struct.elem** %t.addr, align 4
  %data50 = getelementptr inbounds %struct.elem, %struct.elem* %33, i32 0, i32 0
  %arrayidx51 = getelementptr inbounds [10 x i8], [10 x i8]* %data50, i32 0, i32 0
  %34 = load i8, i8* %arrayidx51, align 4
  %35 = load %struct.elem*, %struct.elem** %t.addr, align 4
  %right52 = getelementptr inbounds %struct.elem, %struct.elem* %35, i32 0, i32 2
  %36 = load %struct.elem*, %struct.elem** %right52, align 4
  %data53 = getelementptr inbounds %struct.elem, %struct.elem* %36, i32 0, i32 0
  %arrayidx54 = getelementptr inbounds [10 x i8], [10 x i8]* %data53, i32 0, i32 0
  %37 = load i8, i8* %arrayidx54, align 4
  %call55 = call i32 @precedenceCheck(i8 signext %34, i8 signext %37)
  %cmp56 = icmp eq i32 %call55, 0
  br i1 %cmp56, label %land.lhs.true58, label %if.else68

land.lhs.true58:                                  ; preds = %lor.lhs.false49
  %38 = load %struct.elem*, %struct.elem** %t.addr, align 4
  %data59 = getelementptr inbounds %struct.elem, %struct.elem* %38, i32 0, i32 0
  %arrayidx60 = getelementptr inbounds [10 x i8], [10 x i8]* %data59, i32 0, i32 0
  %39 = load i8, i8* %arrayidx60, align 4
  %conv61 = sext i8 %39 to i32
  %cmp62 = icmp ne i32 %conv61, 94
  br i1 %cmp62, label %if.then64, label %if.else68

if.then64:                                        ; preds = %land.lhs.true58, %land.lhs.true40
  %call65 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([2 x i8], [2 x i8]* @.str, i32 0, i32 0))
  %40 = load %struct.elem*, %struct.elem** %t.addr, align 4
  %right66 = getelementptr inbounds %struct.elem, %struct.elem* %40, i32 0, i32 2
  %41 = load %struct.elem*, %struct.elem** %right66, align 4
  call void @inorder(%struct.elem* %41)
  %call67 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([2 x i8], [2 x i8]* @.str.1, i32 0, i32 0))
  br label %if.end70

if.else68:                                        ; preds = %land.lhs.true58, %lor.lhs.false49, %land.lhs.true33, %if.end
  %42 = load %struct.elem*, %struct.elem** %t.addr, align 4
  %right69 = getelementptr inbounds %struct.elem, %struct.elem* %42, i32 0, i32 2
  %43 = load %struct.elem*, %struct.elem** %right69, align 4
  call void @inorder(%struct.elem* %43)
  br label %if.end70

if.end70:                                         ; preds = %if.else68, %if.then64
  br label %if.end71

if.end71:                                         ; preds = %if.end70, %entry
  ret void
}

declare i32 @printf(i8* %0, ...) #1

; Function Attrs: noinline nounwind optnone
define hidden i8* @getNextString() #0 {
entry:
  %0 = load i32, i32* @counter, align 4
  %cmp = icmp slt i32 %0, 0
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %call = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([15 x i8], [15 x i8]* @.str.3, i32 0, i32 0))
  call void @exit(i32 0) #4
  unreachable

if.end:                                           ; preds = %entry
  %1 = load i8**, i8*** @components, align 4
  %2 = load i32, i32* @counter, align 4
  %dec = add nsw i32 %2, -1
  store i32 %dec, i32* @counter, align 4
  %arrayidx = getelementptr inbounds i8*, i8** %1, i32 %2
  %3 = load i8*, i8** %arrayidx, align 4
  ret i8* %3
}

; Function Attrs: noreturn
declare void @exit(i32 %0) #2

; Function Attrs: noinline nounwind optnone
define hidden %struct.elem* @buildTree(i8* %obj, i8* %trace) #0 {
entry:
  %obj.addr = alloca i8*, align 4
  %trace.addr = alloca i8*, align 4
  %t = alloca %struct.elem*, align 4
  store i8* %obj, i8** %obj.addr, align 4
  store i8* %trace, i8** %trace.addr, align 4
  %call = call noalias i8* @malloc(i32 20)
  %0 = bitcast i8* %call to %struct.elem*
  store %struct.elem* %0, %struct.elem** %t, align 4
  %1 = load %struct.elem*, %struct.elem** %t, align 4
  %data = getelementptr inbounds %struct.elem, %struct.elem* %1, i32 0, i32 0
  %arraydecay = getelementptr inbounds [10 x i8], [10 x i8]* %data, i32 0, i32 0
  %2 = load i8*, i8** %obj.addr, align 4
  %call1 = call i8* @strcpy(i8* %arraydecay, i8* %2)
  %3 = load i8*, i8** %obj.addr, align 4
  %arrayidx = getelementptr inbounds i8, i8* %3, i32 0
  %4 = load i8, i8* %arrayidx, align 1
  %call2 = call i32 @isOperator(i8 signext %4)
  %cmp = icmp eq i32 %call2, 1
  br i1 %cmp, label %cond.true, label %cond.false

cond.true:                                        ; preds = %entry
  %call3 = call i8* @getNextString()
  %5 = load i8*, i8** %trace.addr, align 4
  %call4 = call %struct.elem* @buildTree(i8* %call3, i8* %5)
  br label %cond.end

cond.false:                                       ; preds = %entry
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi %struct.elem* [ %call4, %cond.true ], [ null, %cond.false ]
  %6 = load %struct.elem*, %struct.elem** %t, align 4
  %right = getelementptr inbounds %struct.elem, %struct.elem* %6, i32 0, i32 2
  store %struct.elem* %cond, %struct.elem** %right, align 4
  %7 = load i8*, i8** %obj.addr, align 4
  %arrayidx5 = getelementptr inbounds i8, i8* %7, i32 0
  %8 = load i8, i8* %arrayidx5, align 1
  %call6 = call i32 @isOperator(i8 signext %8)
  %cmp7 = icmp eq i32 %call6, 1
  br i1 %cmp7, label %cond.true8, label %cond.false11

cond.true8:                                       ; preds = %cond.end
  %call9 = call i8* @getNextString()
  %9 = load i8*, i8** %trace.addr, align 4
  %call10 = call %struct.elem* @buildTree(i8* %call9, i8* %9)
  br label %cond.end12

cond.false11:                                     ; preds = %cond.end
  br label %cond.end12

cond.end12:                                       ; preds = %cond.false11, %cond.true8
  %cond13 = phi %struct.elem* [ %call10, %cond.true8 ], [ null, %cond.false11 ]
  %10 = load %struct.elem*, %struct.elem** %t, align 4
  %left = getelementptr inbounds %struct.elem, %struct.elem* %10, i32 0, i32 1
  store %struct.elem* %cond13, %struct.elem** %left, align 4
  %11 = load i8*, i8** %trace.addr, align 4
  %cmp14 = icmp ne i8* %11, null
  br i1 %cmp14, label %if.then, label %if.end

if.then:                                          ; preds = %cond.end12
  %call15 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([2 x i8], [2 x i8]* @.str.4, i32 0, i32 0))
  %12 = load %struct.elem*, %struct.elem** %t, align 4
  call void @inorder(%struct.elem* %12)
  br label %if.end

if.end:                                           ; preds = %if.then, %cond.end12
  %13 = load %struct.elem*, %struct.elem** %t, align 4
  ret %struct.elem* %13
}

declare noalias i8* @malloc(i32 %0) #1

declare i8* @strcpy(i8* %0, i8* %1) #1

; Function Attrs: noinline nounwind optnone
define hidden i32 @checkRPN() #0 {
entry:
  %retval = alloca i32, align 4
  %i = alloca i32, align 4
  %operSum = alloca i32, align 4
  %numberSum = alloca i32, align 4
  store i32 0, i32* %operSum, align 4
  store i32 0, i32* %numberSum, align 4
  %0 = load i8**, i8*** @components, align 4
  %1 = load i32, i32* @counter, align 4
  %arrayidx = getelementptr inbounds i8*, i8** %0, i32 %1
  %2 = load i8*, i8** %arrayidx, align 4
  %arrayidx1 = getelementptr inbounds i8, i8* %2, i32 0
  %3 = load i8, i8* %arrayidx1, align 1
  %call = call i32 @isOperator(i8 signext %3)
  %cmp = icmp eq i32 %call, 0
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  store i32 0, i32* %retval, align 4
  br label %return

if.end:                                           ; preds = %entry
  store i32 0, i32* %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.end
  %4 = load i32, i32* %i, align 4
  %5 = load i32, i32* @counter, align 4
  %cmp2 = icmp sle i32 %4, %5
  br i1 %cmp2, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %6 = load i8**, i8*** @components, align 4
  %7 = load i32, i32* %i, align 4
  %arrayidx3 = getelementptr inbounds i8*, i8** %6, i32 %7
  %8 = load i8*, i8** %arrayidx3, align 4
  %arrayidx4 = getelementptr inbounds i8, i8* %8, i32 0
  %9 = load i8, i8* %arrayidx4, align 1
  %call5 = call i32 @isOperator(i8 signext %9)
  %cmp6 = icmp eq i32 %call5, 1
  br i1 %cmp6, label %cond.true, label %cond.false

cond.true:                                        ; preds = %for.body
  %10 = load i32, i32* %operSum, align 4
  %inc = add nsw i32 %10, 1
  store i32 %inc, i32* %operSum, align 4
  br label %cond.end

cond.false:                                       ; preds = %for.body
  %11 = load i32, i32* %numberSum, align 4
  %inc7 = add nsw i32 %11, 1
  store i32 %inc7, i32* %numberSum, align 4
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi i32 [ %10, %cond.true ], [ %11, %cond.false ]
  br label %for.inc

for.inc:                                          ; preds = %cond.end
  %12 = load i32, i32* %i, align 4
  %inc8 = add nsw i32 %12, 1
  store i32 %inc8, i32* %i, align 4
  br label %for.cond

for.end:                                          ; preds = %for.cond
  %13 = load i32, i32* %numberSum, align 4
  %14 = load i32, i32* %operSum, align 4
  %sub = sub nsw i32 %13, %14
  %cmp9 = icmp eq i32 %sub, 1
  %conv = zext i1 %cmp9 to i32
  store i32 %conv, i32* %retval, align 4
  br label %return

return:                                           ; preds = %for.end, %if.then
  %15 = load i32, i32* %retval, align 4
  ret i32 %15
}

; Function Attrs: noinline nounwind optnone
define hidden void @buildStack(i8* %str) #0 {
entry:
  %str.addr = alloca i8*, align 4
  %i = alloca i32, align 4
  %token = alloca i8*, align 4
  store i8* %str, i8** %str.addr, align 4
  store i32 0, i32* %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %0 = load i8*, i8** %str.addr, align 4
  %1 = load i32, i32* %i, align 4
  %arrayidx = getelementptr inbounds i8, i8* %0, i32 %1
  %2 = load i8, i8* %arrayidx, align 1
  %conv = sext i8 %2 to i32
  %cmp = icmp ne i32 %conv, 0
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %3 = load i8*, i8** %str.addr, align 4
  %4 = load i32, i32* %i, align 4
  %arrayidx2 = getelementptr inbounds i8, i8* %3, i32 %4
  %5 = load i8, i8* %arrayidx2, align 1
  %conv3 = sext i8 %5 to i32
  %cmp4 = icmp eq i32 %conv3, 32
  br i1 %cmp4, label %if.then, label %if.end

if.then:                                          ; preds = %for.body
  %6 = load i32, i32* @counter, align 4
  %inc = add nsw i32 %6, 1
  store i32 %inc, i32* @counter, align 4
  br label %if.end

if.end:                                           ; preds = %if.then, %for.body
  br label %for.inc

for.inc:                                          ; preds = %if.end
  %7 = load i32, i32* %i, align 4
  %inc6 = add nsw i32 %7, 1
  store i32 %inc6, i32* %i, align 4
  br label %for.cond

for.end:                                          ; preds = %for.cond
  %8 = load i32, i32* @counter, align 4
  %add = add nsw i32 %8, 1
  %mul = mul i32 %add, 4
  %call = call noalias i8* @malloc(i32 %mul)
  %9 = bitcast i8* %call to i8**
  store i8** %9, i8*** @components, align 4
  %10 = load i8*, i8** %str.addr, align 4
  %call7 = call i8* @strtok(i8* %10, i8* getelementptr inbounds ([2 x i8], [2 x i8]* @.str.5, i32 0, i32 0))
  store i8* %call7, i8** %token, align 4
  store i32 0, i32* %i, align 4
  br label %while.cond

while.cond:                                       ; preds = %while.body, %for.end
  %11 = load i8*, i8** %token, align 4
  %cmp8 = icmp ne i8* %11, null
  br i1 %cmp8, label %while.body, label %while.end

while.body:                                       ; preds = %while.cond
  %12 = load i8*, i8** %token, align 4
  %call10 = call i32 @strlen(i8* %12) #5
  %mul11 = mul i32 %call10, 1
  %call12 = call noalias i8* @malloc(i32 %mul11)
  %13 = load i8**, i8*** @components, align 4
  %14 = load i32, i32* %i, align 4
  %arrayidx13 = getelementptr inbounds i8*, i8** %13, i32 %14
  store i8* %call12, i8** %arrayidx13, align 4
  %15 = load i8**, i8*** @components, align 4
  %16 = load i32, i32* %i, align 4
  %arrayidx14 = getelementptr inbounds i8*, i8** %15, i32 %16
  %17 = load i8*, i8** %arrayidx14, align 4
  %18 = load i8*, i8** %token, align 4
  %call15 = call i8* @strcpy(i8* %17, i8* %18)
  %call16 = call i8* @strtok(i8* null, i8* getelementptr inbounds ([2 x i8], [2 x i8]* @.str.5, i32 0, i32 0))
  store i8* %call16, i8** %token, align 4
  %19 = load i32, i32* %i, align 4
  %inc17 = add nsw i32 %19, 1
  store i32 %inc17, i32* %i, align 4
  br label %while.cond

while.end:                                        ; preds = %while.cond
  ret void
}

declare i8* @strtok(i8* %0, i8* %1) #1

; Function Attrs: nounwind readonly
declare i32 @strlen(i8* %0) #3

; Function Attrs: noinline nounwind optnone
define hidden i32 @__main_argc_argv(i32 %argC, i8** %argV) #0 {
entry:
  %retval = alloca i32, align 4
  %argC.addr = alloca i32, align 4
  %argV.addr = alloca i8**, align 4
  %i = alloca i32, align 4
  %t = alloca %struct.elem*, align 4
  store i32 0, i32* %retval, align 4
  store i32 %argC, i32* %argC.addr, align 4
  store i8** %argV, i8*** %argV.addr, align 4
  %0 = load i32, i32* %argC.addr, align 4
  %cmp = icmp eq i32 %0, 1
  br i1 %cmp, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  %1 = load i8**, i8*** %argV.addr, align 4
  %arrayidx = getelementptr inbounds i8*, i8** %1, i32 0
  %2 = load i8*, i8** %arrayidx, align 4
  %call = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([95 x i8], [95 x i8]* @.str.6, i32 0, i32 0), i8* %2)
  br label %if.end10

if.else:                                          ; preds = %entry
  %3 = load i8**, i8*** %argV.addr, align 4
  %arrayidx1 = getelementptr inbounds i8*, i8** %3, i32 1
  %4 = load i8*, i8** %arrayidx1, align 4
  call void @buildStack(i8* %4)
  %call2 = call i32 @checkRPN()
  %cmp3 = icmp eq i32 %call2, 0
  br i1 %cmp3, label %if.then4, label %if.end

if.then4:                                         ; preds = %if.else
  %call5 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([15 x i8], [15 x i8]* @.str.3, i32 0, i32 0))
  store i32 0, i32* %retval, align 4
  br label %return

if.end:                                           ; preds = %if.else
  %call6 = call i8* @getNextString()
  %5 = load i8**, i8*** %argV.addr, align 4
  %arrayidx7 = getelementptr inbounds i8*, i8** %5, i32 2
  %6 = load i8*, i8** %arrayidx7, align 4
  %call8 = call %struct.elem* @buildTree(i8* %call6, i8* %6)
  store %struct.elem* %call8, %struct.elem** %t, align 4
  %call9 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([27 x i8], [27 x i8]* @.str.7, i32 0, i32 0))
  %7 = load %struct.elem*, %struct.elem** %t, align 4
  call void @inorder(%struct.elem* %7)
  br label %if.end10

if.end10:                                         ; preds = %if.end, %if.then
  store i32 0, i32* %retval, align 4
  br label %return

return:                                           ; preds = %if.end10, %if.then4
  %8 = load i32, i32* %retval, align 4
  ret i32 %8
}

attributes #0 = { noinline nounwind optnone "correctly-rounded-divide-sqrt-fp-math"="false" "disable-tail-calls"="false" "frame-pointer"="none" "less-precise-fpmad"="false" "min-legal-vector-width"="0" "no-infs-fp-math"="false" "no-jump-tables"="false" "no-nans-fp-math"="false" "no-signed-zeros-fp-math"="false" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="generic" "unsafe-fp-math"="false" "use-soft-float"="false" }
attributes #1 = { "correctly-rounded-divide-sqrt-fp-math"="false" "disable-tail-calls"="false" "frame-pointer"="none" "less-precise-fpmad"="false" "no-infs-fp-math"="false" "no-nans-fp-math"="false" "no-signed-zeros-fp-math"="false" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="generic" "unsafe-fp-math"="false" "use-soft-float"="false" }
attributes #2 = { noreturn "correctly-rounded-divide-sqrt-fp-math"="false" "disable-tail-calls"="false" "frame-pointer"="none" "less-precise-fpmad"="false" "no-infs-fp-math"="false" "no-nans-fp-math"="false" "no-signed-zeros-fp-math"="false" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="generic" "unsafe-fp-math"="false" "use-soft-float"="false" }
attributes #3 = { nounwind readonly "correctly-rounded-divide-sqrt-fp-math"="false" "disable-tail-calls"="false" "frame-pointer"="none" "less-precise-fpmad"="false" "no-infs-fp-math"="false" "no-nans-fp-math"="false" "no-signed-zeros-fp-math"="false" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="generic" "unsafe-fp-math"="false" "use-soft-float"="false" }
attributes #4 = { noreturn }
attributes #5 = { nounwind readonly }

!llvm.module.flags = !{!0}
!llvm.ident = !{!1}

!0 = !{i32 1, !"wchar_size", i32 4}
!1 = !{!"clang version 11.0.0 (https://github.com/Jacarte/llvm-project.git 0f6dea67136cc1e0b3d200eb2bb165628970c44b)"}

; extracted candidates

; *****
; For LLVM instruction:
;  %0 = load i8, i8* %c.addr, align 1
; Looking for a replacement for:
%0:i8 = var
infer %0

; *****
; For LLVM instruction:
;  %conv = sext i8 %0 to i32
; Looking for a replacement for:
%0:i8 = var
%1:i32 = sext %0
infer %1

; *****
; For LLVM instruction:
;  %cmp = icmp eq i32 %conv, 43
; Looking for a replacement for:
%0:i8 = var
%1:i32 = sext %0
%2:i1 = eq 43:i32, %1
infer %2

; *****
; For LLVM instruction:
;  %1 = load i8, i8* %c.addr, align 1
; Looking for a replacement for:
%0:i8 = var
infer %0

; *****
; For LLVM instruction:
;  %conv2 = sext i8 %1 to i32
; Looking for a replacement for:
%0:i8 = var
%1:i32 = sext %0
infer %1

; *****
; For LLVM instruction:
;  %cmp3 = icmp eq i32 %conv2, 45
; Looking for a replacement for:
%0:i8 = var
%1:i32 = sext %0
%2:i1 = eq 45:i32, %1
infer %2

; *****
; For LLVM instruction:
;  %2 = load i8, i8* %c.addr, align 1
; Looking for a replacement for:
%0:i8 = var
infer %0

; *****
; For LLVM instruction:
;  %conv6 = sext i8 %2 to i32
; Looking for a replacement for:
%0:i8 = var
%1:i32 = sext %0
infer %1

; *****
; For LLVM instruction:
;  %cmp7 = icmp eq i32 %conv6, 42
; Looking for a replacement for:
%0:i8 = var
%1:i32 = sext %0
%2:i1 = eq 42:i32, %1
infer %2

; *****
; For LLVM instruction:
;  %3 = load i8, i8* %c.addr, align 1
; Looking for a replacement for:
%0:i8 = var
infer %0

; *****
; For LLVM instruction:
;  %conv10 = sext i8 %3 to i32
; Looking for a replacement for:
%0:i8 = var
%1:i32 = sext %0
infer %1

; *****
; For LLVM instruction:
;  %cmp11 = icmp eq i32 %conv10, 47
; Looking for a replacement for:
%0:i8 = var
%1:i32 = sext %0
%2:i1 = eq 47:i32, %1
infer %2

; *****
; For LLVM instruction:
;  %4 = load i8, i8* %c.addr, align 1
; Looking for a replacement for:
%0:i8 = var
infer %0

; *****
; For LLVM instruction:
;  %conv13 = sext i8 %4 to i32
; Looking for a replacement for:
%0:i8 = var
%1:i32 = sext %0
infer %1

; *****
; For LLVM instruction:
;  %cmp14 = icmp eq i32 %conv13, 94
; Looking for a replacement for:
%0:i8 = var
%1:i32 = sext %0
%2:i1 = eq 94:i32, %1
infer %2

; *****
; For LLVM instruction:
;  %5 = phi i1 [ true, %lor.lhs.false9 ], [ true, %lor.lhs.false5 ], [ true, %lor.lhs.false ], [ true, %entry ], [ %cmp14, %lor.rhs ]
; Looking for a replacement for:
%0 = block 5
%1:i8 = var
%2:i32 = sext %1
%3:i1 = eq 94:i32, %2
%4:i1 = phi %0, 1:i1, 1:i1, 1:i1, 1:i1, %3
infer %4

; *****
; For LLVM instruction:
;  %lor.ext = zext i1 %5 to i32
; Looking for a replacement for:
%0 = block 5
%1:i8 = var
%2:i32 = sext %1
%3:i1 = eq 94:i32, %2
%4:i1 = phi %0, 1:i1, 1:i1, 1:i1, 1:i1, %3
%5:i32 = zext %4
infer %5
got 4 candidates from LHS

-------------------------------------------------
%0 = block 5
%1:i8 = var
%2:i32 = sext %1
%3:i1 = eq 94:i32, %2
%4:i1 = phi %0, 1:i1, 1:i1, 1:i1, 1:i1, %3
infer %4


--------------------------------
guess 0

%0:i1 = var ; reservedconst_1

Cost = 0
first query is SAT, returning the model:
reservedconst_1: 0
0 th attempt: second query is SAT-- constant doesn't work
first query is SAT, returning the model:
reservedconst_1: -1
1 th attempt: second query is SAT-- constant doesn't work
first query is UNSAT-- no more guesses

--------------------------------
guess 1

%0:i8 = var
%1:i32 = sext %0
%2:i1 = eq 94:i32, %1

Cost = 2
second query is SAT-- constant doesn't work
Dataflow Pruned 0/0
There are 2 Guesses
There are 0 RHSs before deduplication
There are 0 RHSs after deduplication
got 5 candidates from LHS

-------------------------------------------------
%0 = block 5
%1:i8 = var
%2:i32 = sext %1
%3:i1 = eq 94:i32, %2
%4:i1 = phi %0, 1:i1, 1:i1, 1:i1, 1:i1, %3
%5:i32 = zext %4
infer %5


--------------------------------
guess 0

%0:i32 = var ; reservedconst_1

Cost = 0
first query is SAT, returning the model:
reservedconst_1: 0
0 th attempt: second query is SAT-- constant doesn't work
first query is SAT, returning the model:
reservedconst_1: 1
1 th attempt: second query is SAT-- constant doesn't work
first query is UNSAT-- no more guesses

--------------------------------
guess 1

%0:i8 = var
%1:i32 = sext %0

Cost = 1
second query is SAT-- constant doesn't work
Dataflow Pruned 0/0
There are 2 Guesses
There are 0 RHSs before deduplication
There are 0 RHSs after deduplication
#########################################################
; exiting Souper's runOnFunction() for isOperator()

; entering Souper's runOnFunction() for inorder()

; ModuleID = './Parsing-RPN_to_infix_conversion.c.bc'
source_filename = "./Parsing-RPN_to_infix_conversion.c"
target datalayout = "e-m:e-p:32:32-i64:64-n32:64-S128"
target triple = "wasm32-unknown-wasi"

%struct.elem = type { [10 x i8], %struct.elem*, %struct.elem* }

@counter = hidden global i32 0, align 4
@.str = private unnamed_addr constant [2 x i8] c"(\00", align 1
@.str.1 = private unnamed_addr constant [2 x i8] c")\00", align 1
@.str.2 = private unnamed_addr constant [5 x i8] c" %s \00", align 1
@.str.3 = private unnamed_addr constant [15 x i8] c"\0AInvalid RPN !\00", align 1
@components = hidden global i8** null, align 4
@.str.4 = private unnamed_addr constant [2 x i8] c"\0A\00", align 1
@.str.5 = private unnamed_addr constant [2 x i8] c" \00", align 1
@.str.6 = private unnamed_addr constant [95 x i8] c"Usage : %s <RPN expression enclosed by quotes> <optional parameter to trace the build process>\00", align 1
@.str.7 = private unnamed_addr constant [27 x i8] c"\0AFinal infix expression : \00", align 1

; Function Attrs: noinline nounwind optnone
define hidden i32 @precedenceCheck(i8 signext %oper1, i8 signext %oper2) #0 {
entry:
  %oper1.addr = alloca i8, align 1
  %oper2.addr = alloca i8, align 1
  store i8 %oper1, i8* %oper1.addr, align 1
  store i8 %oper2, i8* %oper2.addr, align 1
  %0 = load i8, i8* %oper1.addr, align 1
  %conv = sext i8 %0 to i32
  %1 = load i8, i8* %oper2.addr, align 1
  %conv1 = sext i8 %1 to i32
  %cmp = icmp eq i32 %conv, %conv1
  br i1 %cmp, label %cond.true, label %cond.false

cond.true:                                        ; preds = %entry
  br label %cond.end61

cond.false:                                       ; preds = %entry
  %2 = load i8, i8* %oper1.addr, align 1
  %conv3 = sext i8 %2 to i32
  %cmp4 = icmp eq i32 %conv3, 94
  br i1 %cmp4, label %cond.true6, label %cond.false7

cond.true6:                                       ; preds = %cond.false
  br label %cond.end59

cond.false7:                                      ; preds = %cond.false
  %3 = load i8, i8* %oper2.addr, align 1
  %conv8 = sext i8 %3 to i32
  %cmp9 = icmp eq i32 %conv8, 94
  br i1 %cmp9, label %cond.true11, label %cond.false12

cond.true11:                                      ; preds = %cond.false7
  br label %cond.end57

cond.false12:                                     ; preds = %cond.false7
  %4 = load i8, i8* %oper1.addr, align 1
  %conv13 = sext i8 %4 to i32
  %cmp14 = icmp eq i32 %conv13, 47
  br i1 %cmp14, label %cond.true16, label %cond.false17

cond.true16:                                      ; preds = %cond.false12
  br label %cond.end55

cond.false17:                                     ; preds = %cond.false12
  %5 = load i8, i8* %oper2.addr, align 1
  %conv18 = sext i8 %5 to i32
  %cmp19 = icmp eq i32 %conv18, 47
  br i1 %cmp19, label %cond.true21, label %cond.false22

cond.true21:                                      ; preds = %cond.false17
  br label %cond.end53

cond.false22:                                     ; preds = %cond.false17
  %6 = load i8, i8* %oper1.addr, align 1
  %conv23 = sext i8 %6 to i32
  %cmp24 = icmp eq i32 %conv23, 42
  br i1 %cmp24, label %cond.true26, label %cond.false27

cond.true26:                                      ; preds = %cond.false22
  br label %cond.end51

cond.false27:                                     ; preds = %cond.false22
  %7 = load i8, i8* %oper2.addr, align 1
  %conv28 = sext i8 %7 to i32
  %cmp29 = icmp eq i32 %conv28, 42
  br i1 %cmp29, label %cond.true31, label %cond.false32

cond.true31:                                      ; preds = %cond.false27
  br label %cond.end49

cond.false32:                                     ; preds = %cond.false27
  %8 = load i8, i8* %oper1.addr, align 1
  %conv33 = sext i8 %8 to i32
  %cmp34 = icmp eq i32 %conv33, 43
  br i1 %cmp34, label %cond.true36, label %cond.false37

cond.true36:                                      ; preds = %cond.false32
  br label %cond.end47

cond.false37:                                     ; preds = %cond.false32
  %9 = load i8, i8* %oper2.addr, align 1
  %conv38 = sext i8 %9 to i32
  %cmp39 = icmp eq i32 %conv38, 43
  br i1 %cmp39, label %cond.true41, label %cond.false42

cond.true41:                                      ; preds = %cond.false37
  br label %cond.end

cond.false42:                                     ; preds = %cond.false37
  %10 = load i8, i8* %oper1.addr, align 1
  %conv43 = sext i8 %10 to i32
  %cmp44 = icmp eq i32 %conv43, 45
  %11 = zext i1 %cmp44 to i64
  %cond = select i1 %cmp44, i32 1, i32 2
  br label %cond.end

cond.end:                                         ; preds = %cond.false42, %cond.true41
  %cond46 = phi i32 [ 2, %cond.true41 ], [ %cond, %cond.false42 ]
  br label %cond.end47

cond.end47:                                       ; preds = %cond.end, %cond.true36
  %cond48 = phi i32 [ 1, %cond.true36 ], [ %cond46, %cond.end ]
  br label %cond.end49

cond.end49:                                       ; preds = %cond.end47, %cond.true31
  %cond50 = phi i32 [ 2, %cond.true31 ], [ %cond48, %cond.end47 ]
  br label %cond.end51

cond.end51:                                       ; preds = %cond.end49, %cond.true26
  %cond52 = phi i32 [ 1, %cond.true26 ], [ %cond50, %cond.end49 ]
  br label %cond.end53

cond.end53:                                       ; preds = %cond.end51, %cond.true21
  %cond54 = phi i32 [ 2, %cond.true21 ], [ %cond52, %cond.end51 ]
  br label %cond.end55

cond.end55:                                       ; preds = %cond.end53, %cond.true16
  %cond56 = phi i32 [ 1, %cond.true16 ], [ %cond54, %cond.end53 ]
  br label %cond.end57

cond.end57:                                       ; preds = %cond.end55, %cond.true11
  %cond58 = phi i32 [ 2, %cond.true11 ], [ %cond56, %cond.end55 ]
  br label %cond.end59

cond.end59:                                       ; preds = %cond.end57, %cond.true6
  %cond60 = phi i32 [ 1, %cond.true6 ], [ %cond58, %cond.end57 ]
  br label %cond.end61

cond.end61:                                       ; preds = %cond.end59, %cond.true
  %cond62 = phi i32 [ 0, %cond.true ], [ %cond60, %cond.end59 ]
  ret i32 %cond62
}

; Function Attrs: noinline nounwind optnone
define hidden i32 @isOperator(i8 signext %c) #0 {
entry:
  %c.addr = alloca i8, align 1
  store i8 %c, i8* %c.addr, align 1
  %0 = load i8, i8* %c.addr, align 1
  %conv = sext i8 %0 to i32
  %cmp = icmp eq i32 %conv, 43
  br i1 %cmp, label %lor.end, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %entry
  %1 = load i8, i8* %c.addr, align 1
  %conv2 = sext i8 %1 to i32
  %cmp3 = icmp eq i32 %conv2, 45
  br i1 %cmp3, label %lor.end, label %lor.lhs.false5

lor.lhs.false5:                                   ; preds = %lor.lhs.false
  %2 = load i8, i8* %c.addr, align 1
  %conv6 = sext i8 %2 to i32
  %cmp7 = icmp eq i32 %conv6, 42
  br i1 %cmp7, label %lor.end, label %lor.lhs.false9

lor.lhs.false9:                                   ; preds = %lor.lhs.false5
  %3 = load i8, i8* %c.addr, align 1
  %conv10 = sext i8 %3 to i32
  %cmp11 = icmp eq i32 %conv10, 47
  br i1 %cmp11, label %lor.end, label %lor.rhs

lor.rhs:                                          ; preds = %lor.lhs.false9
  %4 = load i8, i8* %c.addr, align 1
  %conv13 = sext i8 %4 to i32
  %cmp14 = icmp eq i32 %conv13, 94
  br label %lor.end

lor.end:                                          ; preds = %lor.rhs, %lor.lhs.false9, %lor.lhs.false5, %lor.lhs.false, %entry
  %5 = phi i1 [ true, %lor.lhs.false9 ], [ true, %lor.lhs.false5 ], [ true, %lor.lhs.false ], [ true, %entry ], [ %cmp14, %lor.rhs ]
  %lor.ext = zext i1 %5 to i32
  ret i32 %lor.ext
}

; Function Attrs: noinline nounwind optnone
define hidden void @inorder(%struct.elem* %t) #0 {
entry:
  %t.addr = alloca %struct.elem*, align 4
  store %struct.elem* %t, %struct.elem** %t.addr, align 4
  %0 = load %struct.elem*, %struct.elem** %t.addr, align 4
  %cmp = icmp ne %struct.elem* %0, null
  br i1 %cmp, label %if.then, label %if.end71

if.then:                                          ; preds = %entry
  %1 = load %struct.elem*, %struct.elem** %t.addr, align 4
  %left = getelementptr inbounds %struct.elem, %struct.elem* %1, i32 0, i32 1
  %2 = load %struct.elem*, %struct.elem** %left, align 4
  %cmp1 = icmp ne %struct.elem* %2, null
  br i1 %cmp1, label %land.lhs.true, label %if.else

land.lhs.true:                                    ; preds = %if.then
  %3 = load %struct.elem*, %struct.elem** %t.addr, align 4
  %left2 = getelementptr inbounds %struct.elem, %struct.elem* %3, i32 0, i32 1
  %4 = load %struct.elem*, %struct.elem** %left2, align 4
  %data = getelementptr inbounds %struct.elem, %struct.elem* %4, i32 0, i32 0
  %arrayidx = getelementptr inbounds [10 x i8], [10 x i8]* %data, i32 0, i32 0
  %5 = load i8, i8* %arrayidx, align 4
  %call = call i32 @isOperator(i8 signext %5)
  %cmp3 = icmp eq i32 %call, 1
  br i1 %cmp3, label %land.lhs.true4, label %if.else

land.lhs.true4:                                   ; preds = %land.lhs.true
  %6 = load %struct.elem*, %struct.elem** %t.addr, align 4
  %data5 = getelementptr inbounds %struct.elem, %struct.elem* %6, i32 0, i32 0
  %arrayidx6 = getelementptr inbounds [10 x i8], [10 x i8]* %data5, i32 0, i32 0
  %7 = load i8, i8* %arrayidx6, align 4
  %8 = load %struct.elem*, %struct.elem** %t.addr, align 4
  %left7 = getelementptr inbounds %struct.elem, %struct.elem* %8, i32 0, i32 1
  %9 = load %struct.elem*, %struct.elem** %left7, align 4
  %data8 = getelementptr inbounds %struct.elem, %struct.elem* %9, i32 0, i32 0
  %arrayidx9 = getelementptr inbounds [10 x i8], [10 x i8]* %data8, i32 0, i32 0
  %10 = load i8, i8* %arrayidx9, align 4
  %call10 = call i32 @precedenceCheck(i8 signext %7, i8 signext %10)
  %cmp11 = icmp eq i32 %call10, 1
  br i1 %cmp11, label %if.then24, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %land.lhs.true4
  %11 = load %struct.elem*, %struct.elem** %t.addr, align 4
  %data12 = getelementptr inbounds %struct.elem, %struct.elem* %11, i32 0, i32 0
  %arrayidx13 = getelementptr inbounds [10 x i8], [10 x i8]* %data12, i32 0, i32 0
  %12 = load i8, i8* %arrayidx13, align 4
  %13 = load %struct.elem*, %struct.elem** %t.addr, align 4
  %left14 = getelementptr inbounds %struct.elem, %struct.elem* %13, i32 0, i32 1
  %14 = load %struct.elem*, %struct.elem** %left14, align 4
  %data15 = getelementptr inbounds %struct.elem, %struct.elem* %14, i32 0, i32 0
  %arrayidx16 = getelementptr inbounds [10 x i8], [10 x i8]* %data15, i32 0, i32 0
  %15 = load i8, i8* %arrayidx16, align 4
  %call17 = call i32 @precedenceCheck(i8 signext %12, i8 signext %15)
  %cmp18 = icmp eq i32 %call17, 0
  br i1 %cmp18, label %land.lhs.true19, label %if.else

land.lhs.true19:                                  ; preds = %lor.lhs.false
  %16 = load %struct.elem*, %struct.elem** %t.addr, align 4
  %data20 = getelementptr inbounds %struct.elem, %struct.elem* %16, i32 0, i32 0
  %arrayidx21 = getelementptr inbounds [10 x i8], [10 x i8]* %data20, i32 0, i32 0
  %17 = load i8, i8* %arrayidx21, align 4
  %conv = sext i8 %17 to i32
  %cmp22 = icmp eq i32 %conv, 94
  br i1 %cmp22, label %if.then24, label %if.else

if.then24:                                        ; preds = %land.lhs.true19, %land.lhs.true4
  %call25 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([2 x i8], [2 x i8]* @.str, i32 0, i32 0))
  %18 = load %struct.elem*, %struct.elem** %t.addr, align 4
  %left26 = getelementptr inbounds %struct.elem, %struct.elem* %18, i32 0, i32 1
  %19 = load %struct.elem*, %struct.elem** %left26, align 4
  call void @inorder(%struct.elem* %19)
  %call27 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([2 x i8], [2 x i8]* @.str.1, i32 0, i32 0))
  br label %if.end

if.else:                                          ; preds = %land.lhs.true19, %lor.lhs.false, %land.lhs.true, %if.then
  %20 = load %struct.elem*, %struct.elem** %t.addr, align 4
  %left28 = getelementptr inbounds %struct.elem, %struct.elem* %20, i32 0, i32 1
  %21 = load %struct.elem*, %struct.elem** %left28, align 4
  call void @inorder(%struct.elem* %21)
  br label %if.end

if.end:                                           ; preds = %if.else, %if.then24
  %22 = load %struct.elem*, %struct.elem** %t.addr, align 4
  %data29 = getelementptr inbounds %struct.elem, %struct.elem* %22, i32 0, i32 0
  %arraydecay = getelementptr inbounds [10 x i8], [10 x i8]* %data29, i32 0, i32 0
  %call30 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.2, i32 0, i32 0), i8* %arraydecay)
  %23 = load %struct.elem*, %struct.elem** %t.addr, align 4
  %right = getelementptr inbounds %struct.elem, %struct.elem* %23, i32 0, i32 2
  %24 = load %struct.elem*, %struct.elem** %right, align 4
  %cmp31 = icmp ne %struct.elem* %24, null
  br i1 %cmp31, label %land.lhs.true33, label %if.else68

land.lhs.true33:                                  ; preds = %if.end
  %25 = load %struct.elem*, %struct.elem** %t.addr, align 4
  %right34 = getelementptr inbounds %struct.elem, %struct.elem* %25, i32 0, i32 2
  %26 = load %struct.elem*, %struct.elem** %right34, align 4
  %data35 = getelementptr inbounds %struct.elem, %struct.elem* %26, i32 0, i32 0
  %arrayidx36 = getelementptr inbounds [10 x i8], [10 x i8]* %data35, i32 0, i32 0
  %27 = load i8, i8* %arrayidx36, align 4
  %call37 = call i32 @isOperator(i8 signext %27)
  %cmp38 = icmp eq i32 %call37, 1
  br i1 %cmp38, label %land.lhs.true40, label %if.else68

land.lhs.true40:                                  ; preds = %land.lhs.true33
  %28 = load %struct.elem*, %struct.elem** %t.addr, align 4
  %data41 = getelementptr inbounds %struct.elem, %struct.elem* %28, i32 0, i32 0
  %arrayidx42 = getelementptr inbounds [10 x i8], [10 x i8]* %data41, i32 0, i32 0
  %29 = load i8, i8* %arrayidx42, align 4
  %30 = load %struct.elem*, %struct.elem** %t.addr, align 4
  %right43 = getelementptr inbounds %struct.elem, %struct.elem* %30, i32 0, i32 2
  %31 = load %struct.elem*, %struct.elem** %right43, align 4
  %data44 = getelementptr inbounds %struct.elem, %struct.elem* %31, i32 0, i32 0
  %arrayidx45 = getelementptr inbounds [10 x i8], [10 x i8]* %data44, i32 0, i32 0
  %32 = load i8, i8* %arrayidx45, align 4
  %call46 = call i32 @precedenceCheck(i8 signext %29, i8 signext %32)
  %cmp47 = icmp eq i32 %call46, 1
  br i1 %cmp47, label %if.then64, label %lor.lhs.false49

lor.lhs.false49:                                  ; preds = %land.lhs.true40
  %33 = load %struct.elem*, %struct.elem** %t.addr, align 4
  %data50 = getelementptr inbounds %struct.elem, %struct.elem* %33, i32 0, i32 0
  %arrayidx51 = getelementptr inbounds [10 x i8], [10 x i8]* %data50, i32 0, i32 0
  %34 = load i8, i8* %arrayidx51, align 4
  %35 = load %struct.elem*, %struct.elem** %t.addr, align 4
  %right52 = getelementptr inbounds %struct.elem, %struct.elem* %35, i32 0, i32 2
  %36 = load %struct.elem*, %struct.elem** %right52, align 4
  %data53 = getelementptr inbounds %struct.elem, %struct.elem* %36, i32 0, i32 0
  %arrayidx54 = getelementptr inbounds [10 x i8], [10 x i8]* %data53, i32 0, i32 0
  %37 = load i8, i8* %arrayidx54, align 4
  %call55 = call i32 @precedenceCheck(i8 signext %34, i8 signext %37)
  %cmp56 = icmp eq i32 %call55, 0
  br i1 %cmp56, label %land.lhs.true58, label %if.else68

land.lhs.true58:                                  ; preds = %lor.lhs.false49
  %38 = load %struct.elem*, %struct.elem** %t.addr, align 4
  %data59 = getelementptr inbounds %struct.elem, %struct.elem* %38, i32 0, i32 0
  %arrayidx60 = getelementptr inbounds [10 x i8], [10 x i8]* %data59, i32 0, i32 0
  %39 = load i8, i8* %arrayidx60, align 4
  %conv61 = sext i8 %39 to i32
  %cmp62 = icmp ne i32 %conv61, 94
  br i1 %cmp62, label %if.then64, label %if.else68

if.then64:                                        ; preds = %land.lhs.true58, %land.lhs.true40
  %call65 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([2 x i8], [2 x i8]* @.str, i32 0, i32 0))
  %40 = load %struct.elem*, %struct.elem** %t.addr, align 4
  %right66 = getelementptr inbounds %struct.elem, %struct.elem* %40, i32 0, i32 2
  %41 = load %struct.elem*, %struct.elem** %right66, align 4
  call void @inorder(%struct.elem* %41)
  %call67 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([2 x i8], [2 x i8]* @.str.1, i32 0, i32 0))
  br label %if.end70

if.else68:                                        ; preds = %land.lhs.true58, %lor.lhs.false49, %land.lhs.true33, %if.end
  %42 = load %struct.elem*, %struct.elem** %t.addr, align 4
  %right69 = getelementptr inbounds %struct.elem, %struct.elem* %42, i32 0, i32 2
  %43 = load %struct.elem*, %struct.elem** %right69, align 4
  call void @inorder(%struct.elem* %43)
  br label %if.end70

if.end70:                                         ; preds = %if.else68, %if.then64
  br label %if.end71

if.end71:                                         ; preds = %if.end70, %entry
  ret void
}

declare i32 @printf(i8* %0, ...) #1

; Function Attrs: noinline nounwind optnone
define hidden i8* @getNextString() #0 {
entry:
  %0 = load i32, i32* @counter, align 4
  %cmp = icmp slt i32 %0, 0
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %call = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([15 x i8], [15 x i8]* @.str.3, i32 0, i32 0))
  call void @exit(i32 0) #4
  unreachable

if.end:                                           ; preds = %entry
  %1 = load i8**, i8*** @components, align 4
  %2 = load i32, i32* @counter, align 4
  %dec = add nsw i32 %2, -1
  store i32 %dec, i32* @counter, align 4
  %arrayidx = getelementptr inbounds i8*, i8** %1, i32 %2
  %3 = load i8*, i8** %arrayidx, align 4
  ret i8* %3
}

; Function Attrs: noreturn
declare void @exit(i32 %0) #2

; Function Attrs: noinline nounwind optnone
define hidden %struct.elem* @buildTree(i8* %obj, i8* %trace) #0 {
entry:
  %obj.addr = alloca i8*, align 4
  %trace.addr = alloca i8*, align 4
  %t = alloca %struct.elem*, align 4
  store i8* %obj, i8** %obj.addr, align 4
  store i8* %trace, i8** %trace.addr, align 4
  %call = call noalias i8* @malloc(i32 20)
  %0 = bitcast i8* %call to %struct.elem*
  store %struct.elem* %0, %struct.elem** %t, align 4
  %1 = load %struct.elem*, %struct.elem** %t, align 4
  %data = getelementptr inbounds %struct.elem, %struct.elem* %1, i32 0, i32 0
  %arraydecay = getelementptr inbounds [10 x i8], [10 x i8]* %data, i32 0, i32 0
  %2 = load i8*, i8** %obj.addr, align 4
  %call1 = call i8* @strcpy(i8* %arraydecay, i8* %2)
  %3 = load i8*, i8** %obj.addr, align 4
  %arrayidx = getelementptr inbounds i8, i8* %3, i32 0
  %4 = load i8, i8* %arrayidx, align 1
  %call2 = call i32 @isOperator(i8 signext %4)
  %cmp = icmp eq i32 %call2, 1
  br i1 %cmp, label %cond.true, label %cond.false

cond.true:                                        ; preds = %entry
  %call3 = call i8* @getNextString()
  %5 = load i8*, i8** %trace.addr, align 4
  %call4 = call %struct.elem* @buildTree(i8* %call3, i8* %5)
  br label %cond.end

cond.false:                                       ; preds = %entry
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi %struct.elem* [ %call4, %cond.true ], [ null, %cond.false ]
  %6 = load %struct.elem*, %struct.elem** %t, align 4
  %right = getelementptr inbounds %struct.elem, %struct.elem* %6, i32 0, i32 2
  store %struct.elem* %cond, %struct.elem** %right, align 4
  %7 = load i8*, i8** %obj.addr, align 4
  %arrayidx5 = getelementptr inbounds i8, i8* %7, i32 0
  %8 = load i8, i8* %arrayidx5, align 1
  %call6 = call i32 @isOperator(i8 signext %8)
  %cmp7 = icmp eq i32 %call6, 1
  br i1 %cmp7, label %cond.true8, label %cond.false11

cond.true8:                                       ; preds = %cond.end
  %call9 = call i8* @getNextString()
  %9 = load i8*, i8** %trace.addr, align 4
  %call10 = call %struct.elem* @buildTree(i8* %call9, i8* %9)
  br label %cond.end12

cond.false11:                                     ; preds = %cond.end
  br label %cond.end12

cond.end12:                                       ; preds = %cond.false11, %cond.true8
  %cond13 = phi %struct.elem* [ %call10, %cond.true8 ], [ null, %cond.false11 ]
  %10 = load %struct.elem*, %struct.elem** %t, align 4
  %left = getelementptr inbounds %struct.elem, %struct.elem* %10, i32 0, i32 1
  store %struct.elem* %cond13, %struct.elem** %left, align 4
  %11 = load i8*, i8** %trace.addr, align 4
  %cmp14 = icmp ne i8* %11, null
  br i1 %cmp14, label %if.then, label %if.end

if.then:                                          ; preds = %cond.end12
  %call15 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([2 x i8], [2 x i8]* @.str.4, i32 0, i32 0))
  %12 = load %struct.elem*, %struct.elem** %t, align 4
  call void @inorder(%struct.elem* %12)
  br label %if.end

if.end:                                           ; preds = %if.then, %cond.end12
  %13 = load %struct.elem*, %struct.elem** %t, align 4
  ret %struct.elem* %13
}

declare noalias i8* @malloc(i32 %0) #1

declare i8* @strcpy(i8* %0, i8* %1) #1

; Function Attrs: noinline nounwind optnone
define hidden i32 @checkRPN() #0 {
entry:
  %retval = alloca i32, align 4
  %i = alloca i32, align 4
  %operSum = alloca i32, align 4
  %numberSum = alloca i32, align 4
  store i32 0, i32* %operSum, align 4
  store i32 0, i32* %numberSum, align 4
  %0 = load i8**, i8*** @components, align 4
  %1 = load i32, i32* @counter, align 4
  %arrayidx = getelementptr inbounds i8*, i8** %0, i32 %1
  %2 = load i8*, i8** %arrayidx, align 4
  %arrayidx1 = getelementptr inbounds i8, i8* %2, i32 0
  %3 = load i8, i8* %arrayidx1, align 1
  %call = call i32 @isOperator(i8 signext %3)
  %cmp = icmp eq i32 %call, 0
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  store i32 0, i32* %retval, align 4
  br label %return

if.end:                                           ; preds = %entry
  store i32 0, i32* %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.end
  %4 = load i32, i32* %i, align 4
  %5 = load i32, i32* @counter, align 4
  %cmp2 = icmp sle i32 %4, %5
  br i1 %cmp2, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %6 = load i8**, i8*** @components, align 4
  %7 = load i32, i32* %i, align 4
  %arrayidx3 = getelementptr inbounds i8*, i8** %6, i32 %7
  %8 = load i8*, i8** %arrayidx3, align 4
  %arrayidx4 = getelementptr inbounds i8, i8* %8, i32 0
  %9 = load i8, i8* %arrayidx4, align 1
  %call5 = call i32 @isOperator(i8 signext %9)
  %cmp6 = icmp eq i32 %call5, 1
  br i1 %cmp6, label %cond.true, label %cond.false

cond.true:                                        ; preds = %for.body
  %10 = load i32, i32* %operSum, align 4
  %inc = add nsw i32 %10, 1
  store i32 %inc, i32* %operSum, align 4
  br label %cond.end

cond.false:                                       ; preds = %for.body
  %11 = load i32, i32* %numberSum, align 4
  %inc7 = add nsw i32 %11, 1
  store i32 %inc7, i32* %numberSum, align 4
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi i32 [ %10, %cond.true ], [ %11, %cond.false ]
  br label %for.inc

for.inc:                                          ; preds = %cond.end
  %12 = load i32, i32* %i, align 4
  %inc8 = add nsw i32 %12, 1
  store i32 %inc8, i32* %i, align 4
  br label %for.cond

for.end:                                          ; preds = %for.cond
  %13 = load i32, i32* %numberSum, align 4
  %14 = load i32, i32* %operSum, align 4
  %sub = sub nsw i32 %13, %14
  %cmp9 = icmp eq i32 %sub, 1
  %conv = zext i1 %cmp9 to i32
  store i32 %conv, i32* %retval, align 4
  br label %return

return:                                           ; preds = %for.end, %if.then
  %15 = load i32, i32* %retval, align 4
  ret i32 %15
}

; Function Attrs: noinline nounwind optnone
define hidden void @buildStack(i8* %str) #0 {
entry:
  %str.addr = alloca i8*, align 4
  %i = alloca i32, align 4
  %token = alloca i8*, align 4
  store i8* %str, i8** %str.addr, align 4
  store i32 0, i32* %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %0 = load i8*, i8** %str.addr, align 4
  %1 = load i32, i32* %i, align 4
  %arrayidx = getelementptr inbounds i8, i8* %0, i32 %1
  %2 = load i8, i8* %arrayidx, align 1
  %conv = sext i8 %2 to i32
  %cmp = icmp ne i32 %conv, 0
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %3 = load i8*, i8** %str.addr, align 4
  %4 = load i32, i32* %i, align 4
  %arrayidx2 = getelementptr inbounds i8, i8* %3, i32 %4
  %5 = load i8, i8* %arrayidx2, align 1
  %conv3 = sext i8 %5 to i32
  %cmp4 = icmp eq i32 %conv3, 32
  br i1 %cmp4, label %if.then, label %if.end

if.then:                                          ; preds = %for.body
  %6 = load i32, i32* @counter, align 4
  %inc = add nsw i32 %6, 1
  store i32 %inc, i32* @counter, align 4
  br label %if.end

if.end:                                           ; preds = %if.then, %for.body
  br label %for.inc

for.inc:                                          ; preds = %if.end
  %7 = load i32, i32* %i, align 4
  %inc6 = add nsw i32 %7, 1
  store i32 %inc6, i32* %i, align 4
  br label %for.cond

for.end:                                          ; preds = %for.cond
  %8 = load i32, i32* @counter, align 4
  %add = add nsw i32 %8, 1
  %mul = mul i32 %add, 4
  %call = call noalias i8* @malloc(i32 %mul)
  %9 = bitcast i8* %call to i8**
  store i8** %9, i8*** @components, align 4
  %10 = load i8*, i8** %str.addr, align 4
  %call7 = call i8* @strtok(i8* %10, i8* getelementptr inbounds ([2 x i8], [2 x i8]* @.str.5, i32 0, i32 0))
  store i8* %call7, i8** %token, align 4
  store i32 0, i32* %i, align 4
  br label %while.cond

while.cond:                                       ; preds = %while.body, %for.end
  %11 = load i8*, i8** %token, align 4
  %cmp8 = icmp ne i8* %11, null
  br i1 %cmp8, label %while.body, label %while.end

while.body:                                       ; preds = %while.cond
  %12 = load i8*, i8** %token, align 4
  %call10 = call i32 @strlen(i8* %12) #5
  %mul11 = mul i32 %call10, 1
  %call12 = call noalias i8* @malloc(i32 %mul11)
  %13 = load i8**, i8*** @components, align 4
  %14 = load i32, i32* %i, align 4
  %arrayidx13 = getelementptr inbounds i8*, i8** %13, i32 %14
  store i8* %call12, i8** %arrayidx13, align 4
  %15 = load i8**, i8*** @components, align 4
  %16 = load i32, i32* %i, align 4
  %arrayidx14 = getelementptr inbounds i8*, i8** %15, i32 %16
  %17 = load i8*, i8** %arrayidx14, align 4
  %18 = load i8*, i8** %token, align 4
  %call15 = call i8* @strcpy(i8* %17, i8* %18)
  %call16 = call i8* @strtok(i8* null, i8* getelementptr inbounds ([2 x i8], [2 x i8]* @.str.5, i32 0, i32 0))
  store i8* %call16, i8** %token, align 4
  %19 = load i32, i32* %i, align 4
  %inc17 = add nsw i32 %19, 1
  store i32 %inc17, i32* %i, align 4
  br label %while.cond

while.end:                                        ; preds = %while.cond
  ret void
}

declare i8* @strtok(i8* %0, i8* %1) #1

; Function Attrs: nounwind readonly
declare i32 @strlen(i8* %0) #3

; Function Attrs: noinline nounwind optnone
define hidden i32 @__main_argc_argv(i32 %argC, i8** %argV) #0 {
entry:
  %retval = alloca i32, align 4
  %argC.addr = alloca i32, align 4
  %argV.addr = alloca i8**, align 4
  %i = alloca i32, align 4
  %t = alloca %struct.elem*, align 4
  store i32 0, i32* %retval, align 4
  store i32 %argC, i32* %argC.addr, align 4
  store i8** %argV, i8*** %argV.addr, align 4
  %0 = load i32, i32* %argC.addr, align 4
  %cmp = icmp eq i32 %0, 1
  br i1 %cmp, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  %1 = load i8**, i8*** %argV.addr, align 4
  %arrayidx = getelementptr inbounds i8*, i8** %1, i32 0
  %2 = load i8*, i8** %arrayidx, align 4
  %call = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([95 x i8], [95 x i8]* @.str.6, i32 0, i32 0), i8* %2)
  br label %if.end10

if.else:                                          ; preds = %entry
  %3 = load i8**, i8*** %argV.addr, align 4
  %arrayidx1 = getelementptr inbounds i8*, i8** %3, i32 1
  %4 = load i8*, i8** %arrayidx1, align 4
  call void @buildStack(i8* %4)
  %call2 = call i32 @checkRPN()
  %cmp3 = icmp eq i32 %call2, 0
  br i1 %cmp3, label %if.then4, label %if.end

if.then4:                                         ; preds = %if.else
  %call5 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([15 x i8], [15 x i8]* @.str.3, i32 0, i32 0))
  store i32 0, i32* %retval, align 4
  br label %return

if.end:                                           ; preds = %if.else
  %call6 = call i8* @getNextString()
  %5 = load i8**, i8*** %argV.addr, align 4
  %arrayidx7 = getelementptr inbounds i8*, i8** %5, i32 2
  %6 = load i8*, i8** %arrayidx7, align 4
  %call8 = call %struct.elem* @buildTree(i8* %call6, i8* %6)
  store %struct.elem* %call8, %struct.elem** %t, align 4
  %call9 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([27 x i8], [27 x i8]* @.str.7, i32 0, i32 0))
  %7 = load %struct.elem*, %struct.elem** %t, align 4
  call void @inorder(%struct.elem* %7)
  br label %if.end10

if.end10:                                         ; preds = %if.end, %if.then
  store i32 0, i32* %retval, align 4
  br label %return

return:                                           ; preds = %if.end10, %if.then4
  %8 = load i32, i32* %retval, align 4
  ret i32 %8
}

attributes #0 = { noinline nounwind optnone "correctly-rounded-divide-sqrt-fp-math"="false" "disable-tail-calls"="false" "frame-pointer"="none" "less-precise-fpmad"="false" "min-legal-vector-width"="0" "no-infs-fp-math"="false" "no-jump-tables"="false" "no-nans-fp-math"="false" "no-signed-zeros-fp-math"="false" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="generic" "unsafe-fp-math"="false" "use-soft-float"="false" }
attributes #1 = { "correctly-rounded-divide-sqrt-fp-math"="false" "disable-tail-calls"="false" "frame-pointer"="none" "less-precise-fpmad"="false" "no-infs-fp-math"="false" "no-nans-fp-math"="false" "no-signed-zeros-fp-math"="false" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="generic" "unsafe-fp-math"="false" "use-soft-float"="false" }
attributes #2 = { noreturn "correctly-rounded-divide-sqrt-fp-math"="false" "disable-tail-calls"="false" "frame-pointer"="none" "less-precise-fpmad"="false" "no-infs-fp-math"="false" "no-nans-fp-math"="false" "no-signed-zeros-fp-math"="false" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="generic" "unsafe-fp-math"="false" "use-soft-float"="false" }
attributes #3 = { nounwind readonly "correctly-rounded-divide-sqrt-fp-math"="false" "disable-tail-calls"="false" "frame-pointer"="none" "less-precise-fpmad"="false" "no-infs-fp-math"="false" "no-nans-fp-math"="false" "no-signed-zeros-fp-math"="false" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="generic" "unsafe-fp-math"="false" "use-soft-float"="false" }
attributes #4 = { noreturn }
attributes #5 = { nounwind readonly }

!llvm.module.flags = !{!0}
!llvm.ident = !{!1}

!0 = !{i32 1, !"wchar_size", i32 4}
!1 = !{!"clang version 11.0.0 (https://github.com/Jacarte/llvm-project.git 0f6dea67136cc1e0b3d200eb2bb165628970c44b)"}

; extracted candidates

; *****
; For LLVM instruction:
;  %cmp = icmp ne %struct.elem* %0, null
; Looking for a replacement for:
%0:i32 = var
%1:i1 = ne 0:i32, %0
infer %1

; *****
; For LLVM instruction:
;  %cmp1 = icmp ne %struct.elem* %2, null
; Looking for a replacement for:
%0:i32 = var
%1:i1 = ne 0:i32, %0
infer %1

; *****
; For LLVM instruction:
;  %5 = load i8, i8* %arrayidx, align 4
; Looking for a replacement for:
%0:i8 = var
infer %0

; *****
; For LLVM instruction:
;  %call = call i32 @isOperator(i8 signext %5)
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %cmp3 = icmp eq i32 %call, 1
; Looking for a replacement for:
%0:i32 = var
%1:i1 = eq 1:i32, %0
infer %1

; *****
; For LLVM instruction:
;  %7 = load i8, i8* %arrayidx6, align 4
; Looking for a replacement for:
%0:i8 = var
infer %0

; *****
; For LLVM instruction:
;  %10 = load i8, i8* %arrayidx9, align 4
; Looking for a replacement for:
%0:i8 = var
infer %0

; *****
; For LLVM instruction:
;  %call10 = call i32 @precedenceCheck(i8 signext %7, i8 signext %10)
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %cmp11 = icmp eq i32 %call10, 1
; Looking for a replacement for:
%0:i32 = var
%1:i1 = eq 1:i32, %0
infer %1

; *****
; For LLVM instruction:
;  %12 = load i8, i8* %arrayidx13, align 4
; Looking for a replacement for:
%0:i8 = var
infer %0

; *****
; For LLVM instruction:
;  %15 = load i8, i8* %arrayidx16, align 4
; Looking for a replacement for:
%0:i8 = var
infer %0

; *****
; For LLVM instruction:
;  %call17 = call i32 @precedenceCheck(i8 signext %12, i8 signext %15)
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %cmp18 = icmp eq i32 %call17, 0
; Looking for a replacement for:
%0:i32 = var
%1:i1 = eq 0:i32, %0
infer %1

; *****
; For LLVM instruction:
;  %17 = load i8, i8* %arrayidx21, align 4
; Looking for a replacement for:
%0:i8 = var
infer %0

; *****
; For LLVM instruction:
;  %conv = sext i8 %17 to i32
; Looking for a replacement for:
%0:i8 = var
%1:i32 = sext %0
infer %1

; *****
; For LLVM instruction:
;  %cmp22 = icmp eq i32 %conv, 94
; Looking for a replacement for:
%0:i8 = var
%1:i32 = sext %0
%2:i1 = eq 94:i32, %1
infer %2

; *****
; For LLVM instruction:
;  %cmp31 = icmp ne %struct.elem* %24, null
; Looking for a replacement for:
%0:i32 = var
%1:i1 = ne 0:i32, %0
infer %1

; *****
; For LLVM instruction:
;  %27 = load i8, i8* %arrayidx36, align 4
; Looking for a replacement for:
%0:i8 = var
infer %0

; *****
; For LLVM instruction:
;  %call37 = call i32 @isOperator(i8 signext %27)
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %cmp38 = icmp eq i32 %call37, 1
; Looking for a replacement for:
%0:i32 = var
%1:i1 = eq 1:i32, %0
infer %1

; *****
; For LLVM instruction:
;  %29 = load i8, i8* %arrayidx42, align 4
; Looking for a replacement for:
%0:i8 = var
infer %0

; *****
; For LLVM instruction:
;  %32 = load i8, i8* %arrayidx45, align 4
; Looking for a replacement for:
%0:i8 = var
infer %0

; *****
; For LLVM instruction:
;  %call46 = call i32 @precedenceCheck(i8 signext %29, i8 signext %32)
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %cmp47 = icmp eq i32 %call46, 1
; Looking for a replacement for:
%0:i32 = var
%1:i1 = eq 1:i32, %0
infer %1

; *****
; For LLVM instruction:
;  %34 = load i8, i8* %arrayidx51, align 4
; Looking for a replacement for:
%0:i8 = var
infer %0

; *****
; For LLVM instruction:
;  %37 = load i8, i8* %arrayidx54, align 4
; Looking for a replacement for:
%0:i8 = var
infer %0

; *****
; For LLVM instruction:
;  %call55 = call i32 @precedenceCheck(i8 signext %34, i8 signext %37)
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %cmp56 = icmp eq i32 %call55, 0
; Looking for a replacement for:
%0:i32 = var
%1:i1 = eq 0:i32, %0
infer %1

; *****
; For LLVM instruction:
;  %39 = load i8, i8* %arrayidx60, align 4
; Looking for a replacement for:
%0:i8 = var
infer %0

; *****
; For LLVM instruction:
;  %conv61 = sext i8 %39 to i32
; Looking for a replacement for:
%0:i8 = var
%1:i32 = sext %0
infer %1

; *****
; For LLVM instruction:
;  %cmp62 = icmp ne i32 %conv61, 94
; Looking for a replacement for:
%0:i8 = var
%1:i32 = sext %0
%2:i1 = ne 94:i32, %1
infer %2
got 2 candidates from LHS

-------------------------------------------------
%0:i32 = var
%1:i1 = ne 0:i32, %0
infer %1


--------------------------------
guess 0

%0:i1 = var ; reservedconst_1

Cost = 0
first query is SAT, returning the model:
reservedconst_1: 0
0 th attempt: second query is SAT-- constant doesn't work
first query is SAT, returning the model:
reservedconst_1: -1
1 th attempt: second query is SAT-- constant doesn't work
first query is UNSAT-- no more guesses
Dataflow Pruned 0/0
There are 1 Guesses
There are 0 RHSs before deduplication
There are 0 RHSs after deduplication
got 1 candidates from LHS

-------------------------------------------------
%0:i32 = var
infer %0


--------------------------------
guess 0

%0:i32 = var ; reservedconst_1

Cost = 0
first query is SAT, returning the model:
reservedconst_1: 0
0 th attempt: second query is SAT-- constant doesn't work
first query is SAT, returning the model:
reservedconst_1: -1
1 th attempt: second query is SAT-- constant doesn't work
first query is UNSAT-- no more guesses
Dataflow Pruned 0/0
There are 1 Guesses
There are 0 RHSs before deduplication
There are 0 RHSs after deduplication
got 2 candidates from LHS

-------------------------------------------------
%0:i32 = var
%1:i1 = eq 1:i32, %0
infer %1


--------------------------------
guess 0

%0:i1 = var ; reservedconst_1

Cost = 0
first query is SAT, returning the model:
reservedconst_1: 0
0 th attempt: second query is SAT-- constant doesn't work
first query is SAT, returning the model:
reservedconst_1: -1
1 th attempt: second query is SAT-- constant doesn't work
first query is UNSAT-- no more guesses
Dataflow Pruned 0/0
There are 1 Guesses
There are 0 RHSs before deduplication
There are 0 RHSs after deduplication
got 2 candidates from LHS

-------------------------------------------------
%0:i32 = var
%1:i1 = eq 0:i32, %0
infer %1


--------------------------------
guess 0

%0:i1 = var ; reservedconst_1

Cost = 0
first query is SAT, returning the model:
reservedconst_1: -1
0 th attempt: second query is SAT-- constant doesn't work
first query is SAT, returning the model:
reservedconst_1: 0
1 th attempt: second query is SAT-- constant doesn't work
first query is UNSAT-- no more guesses
Dataflow Pruned 0/0
There are 1 Guesses
There are 0 RHSs before deduplication
There are 0 RHSs after deduplication
got 3 candidates from LHS

-------------------------------------------------
%0:i8 = var
%1:i32 = sext %0
%2:i1 = ne 94:i32, %1
infer %2


--------------------------------
guess 0

%0:i1 = var ; reservedconst_1

Cost = 0
first query is SAT, returning the model:
reservedconst_1: -1
0 th attempt: second query is SAT-- constant doesn't work
first query is SAT, returning the model:
reservedconst_1: 0
1 th attempt: second query is SAT-- constant doesn't work
first query is UNSAT-- no more guesses
Dataflow Pruned 0/0
There are 1 Guesses
There are 0 RHSs before deduplication
There are 0 RHSs after deduplication
#########################################################
; exiting Souper's runOnFunction() for inorder()

; entering Souper's runOnFunction() for getNextString()

; ModuleID = './Parsing-RPN_to_infix_conversion.c.bc'
source_filename = "./Parsing-RPN_to_infix_conversion.c"
target datalayout = "e-m:e-p:32:32-i64:64-n32:64-S128"
target triple = "wasm32-unknown-wasi"

%struct.elem = type { [10 x i8], %struct.elem*, %struct.elem* }

@counter = hidden global i32 0, align 4
@.str = private unnamed_addr constant [2 x i8] c"(\00", align 1
@.str.1 = private unnamed_addr constant [2 x i8] c")\00", align 1
@.str.2 = private unnamed_addr constant [5 x i8] c" %s \00", align 1
@.str.3 = private unnamed_addr constant [15 x i8] c"\0AInvalid RPN !\00", align 1
@components = hidden global i8** null, align 4
@.str.4 = private unnamed_addr constant [2 x i8] c"\0A\00", align 1
@.str.5 = private unnamed_addr constant [2 x i8] c" \00", align 1
@.str.6 = private unnamed_addr constant [95 x i8] c"Usage : %s <RPN expression enclosed by quotes> <optional parameter to trace the build process>\00", align 1
@.str.7 = private unnamed_addr constant [27 x i8] c"\0AFinal infix expression : \00", align 1

; Function Attrs: noinline nounwind optnone
define hidden i32 @precedenceCheck(i8 signext %oper1, i8 signext %oper2) #0 {
entry:
  %oper1.addr = alloca i8, align 1
  %oper2.addr = alloca i8, align 1
  store i8 %oper1, i8* %oper1.addr, align 1
  store i8 %oper2, i8* %oper2.addr, align 1
  %0 = load i8, i8* %oper1.addr, align 1
  %conv = sext i8 %0 to i32
  %1 = load i8, i8* %oper2.addr, align 1
  %conv1 = sext i8 %1 to i32
  %cmp = icmp eq i32 %conv, %conv1
  br i1 %cmp, label %cond.true, label %cond.false

cond.true:                                        ; preds = %entry
  br label %cond.end61

cond.false:                                       ; preds = %entry
  %2 = load i8, i8* %oper1.addr, align 1
  %conv3 = sext i8 %2 to i32
  %cmp4 = icmp eq i32 %conv3, 94
  br i1 %cmp4, label %cond.true6, label %cond.false7

cond.true6:                                       ; preds = %cond.false
  br label %cond.end59

cond.false7:                                      ; preds = %cond.false
  %3 = load i8, i8* %oper2.addr, align 1
  %conv8 = sext i8 %3 to i32
  %cmp9 = icmp eq i32 %conv8, 94
  br i1 %cmp9, label %cond.true11, label %cond.false12

cond.true11:                                      ; preds = %cond.false7
  br label %cond.end57

cond.false12:                                     ; preds = %cond.false7
  %4 = load i8, i8* %oper1.addr, align 1
  %conv13 = sext i8 %4 to i32
  %cmp14 = icmp eq i32 %conv13, 47
  br i1 %cmp14, label %cond.true16, label %cond.false17

cond.true16:                                      ; preds = %cond.false12
  br label %cond.end55

cond.false17:                                     ; preds = %cond.false12
  %5 = load i8, i8* %oper2.addr, align 1
  %conv18 = sext i8 %5 to i32
  %cmp19 = icmp eq i32 %conv18, 47
  br i1 %cmp19, label %cond.true21, label %cond.false22

cond.true21:                                      ; preds = %cond.false17
  br label %cond.end53

cond.false22:                                     ; preds = %cond.false17
  %6 = load i8, i8* %oper1.addr, align 1
  %conv23 = sext i8 %6 to i32
  %cmp24 = icmp eq i32 %conv23, 42
  br i1 %cmp24, label %cond.true26, label %cond.false27

cond.true26:                                      ; preds = %cond.false22
  br label %cond.end51

cond.false27:                                     ; preds = %cond.false22
  %7 = load i8, i8* %oper2.addr, align 1
  %conv28 = sext i8 %7 to i32
  %cmp29 = icmp eq i32 %conv28, 42
  br i1 %cmp29, label %cond.true31, label %cond.false32

cond.true31:                                      ; preds = %cond.false27
  br label %cond.end49

cond.false32:                                     ; preds = %cond.false27
  %8 = load i8, i8* %oper1.addr, align 1
  %conv33 = sext i8 %8 to i32
  %cmp34 = icmp eq i32 %conv33, 43
  br i1 %cmp34, label %cond.true36, label %cond.false37

cond.true36:                                      ; preds = %cond.false32
  br label %cond.end47

cond.false37:                                     ; preds = %cond.false32
  %9 = load i8, i8* %oper2.addr, align 1
  %conv38 = sext i8 %9 to i32
  %cmp39 = icmp eq i32 %conv38, 43
  br i1 %cmp39, label %cond.true41, label %cond.false42

cond.true41:                                      ; preds = %cond.false37
  br label %cond.end

cond.false42:                                     ; preds = %cond.false37
  %10 = load i8, i8* %oper1.addr, align 1
  %conv43 = sext i8 %10 to i32
  %cmp44 = icmp eq i32 %conv43, 45
  %11 = zext i1 %cmp44 to i64
  %cond = select i1 %cmp44, i32 1, i32 2
  br label %cond.end

cond.end:                                         ; preds = %cond.false42, %cond.true41
  %cond46 = phi i32 [ 2, %cond.true41 ], [ %cond, %cond.false42 ]
  br label %cond.end47

cond.end47:                                       ; preds = %cond.end, %cond.true36
  %cond48 = phi i32 [ 1, %cond.true36 ], [ %cond46, %cond.end ]
  br label %cond.end49

cond.end49:                                       ; preds = %cond.end47, %cond.true31
  %cond50 = phi i32 [ 2, %cond.true31 ], [ %cond48, %cond.end47 ]
  br label %cond.end51

cond.end51:                                       ; preds = %cond.end49, %cond.true26
  %cond52 = phi i32 [ 1, %cond.true26 ], [ %cond50, %cond.end49 ]
  br label %cond.end53

cond.end53:                                       ; preds = %cond.end51, %cond.true21
  %cond54 = phi i32 [ 2, %cond.true21 ], [ %cond52, %cond.end51 ]
  br label %cond.end55

cond.end55:                                       ; preds = %cond.end53, %cond.true16
  %cond56 = phi i32 [ 1, %cond.true16 ], [ %cond54, %cond.end53 ]
  br label %cond.end57

cond.end57:                                       ; preds = %cond.end55, %cond.true11
  %cond58 = phi i32 [ 2, %cond.true11 ], [ %cond56, %cond.end55 ]
  br label %cond.end59

cond.end59:                                       ; preds = %cond.end57, %cond.true6
  %cond60 = phi i32 [ 1, %cond.true6 ], [ %cond58, %cond.end57 ]
  br label %cond.end61

cond.end61:                                       ; preds = %cond.end59, %cond.true
  %cond62 = phi i32 [ 0, %cond.true ], [ %cond60, %cond.end59 ]
  ret i32 %cond62
}

; Function Attrs: noinline nounwind optnone
define hidden i32 @isOperator(i8 signext %c) #0 {
entry:
  %c.addr = alloca i8, align 1
  store i8 %c, i8* %c.addr, align 1
  %0 = load i8, i8* %c.addr, align 1
  %conv = sext i8 %0 to i32
  %cmp = icmp eq i32 %conv, 43
  br i1 %cmp, label %lor.end, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %entry
  %1 = load i8, i8* %c.addr, align 1
  %conv2 = sext i8 %1 to i32
  %cmp3 = icmp eq i32 %conv2, 45
  br i1 %cmp3, label %lor.end, label %lor.lhs.false5

lor.lhs.false5:                                   ; preds = %lor.lhs.false
  %2 = load i8, i8* %c.addr, align 1
  %conv6 = sext i8 %2 to i32
  %cmp7 = icmp eq i32 %conv6, 42
  br i1 %cmp7, label %lor.end, label %lor.lhs.false9

lor.lhs.false9:                                   ; preds = %lor.lhs.false5
  %3 = load i8, i8* %c.addr, align 1
  %conv10 = sext i8 %3 to i32
  %cmp11 = icmp eq i32 %conv10, 47
  br i1 %cmp11, label %lor.end, label %lor.rhs

lor.rhs:                                          ; preds = %lor.lhs.false9
  %4 = load i8, i8* %c.addr, align 1
  %conv13 = sext i8 %4 to i32
  %cmp14 = icmp eq i32 %conv13, 94
  br label %lor.end

lor.end:                                          ; preds = %lor.rhs, %lor.lhs.false9, %lor.lhs.false5, %lor.lhs.false, %entry
  %5 = phi i1 [ true, %lor.lhs.false9 ], [ true, %lor.lhs.false5 ], [ true, %lor.lhs.false ], [ true, %entry ], [ %cmp14, %lor.rhs ]
  %lor.ext = zext i1 %5 to i32
  ret i32 %lor.ext
}

; Function Attrs: noinline nounwind optnone
define hidden void @inorder(%struct.elem* %t) #0 {
entry:
  %t.addr = alloca %struct.elem*, align 4
  store %struct.elem* %t, %struct.elem** %t.addr, align 4
  %0 = load %struct.elem*, %struct.elem** %t.addr, align 4
  %cmp = icmp ne %struct.elem* %0, null
  br i1 %cmp, label %if.then, label %if.end71

if.then:                                          ; preds = %entry
  %1 = load %struct.elem*, %struct.elem** %t.addr, align 4
  %left = getelementptr inbounds %struct.elem, %struct.elem* %1, i32 0, i32 1
  %2 = load %struct.elem*, %struct.elem** %left, align 4
  %cmp1 = icmp ne %struct.elem* %2, null
  br i1 %cmp1, label %land.lhs.true, label %if.else

land.lhs.true:                                    ; preds = %if.then
  %3 = load %struct.elem*, %struct.elem** %t.addr, align 4
  %left2 = getelementptr inbounds %struct.elem, %struct.elem* %3, i32 0, i32 1
  %4 = load %struct.elem*, %struct.elem** %left2, align 4
  %data = getelementptr inbounds %struct.elem, %struct.elem* %4, i32 0, i32 0
  %arrayidx = getelementptr inbounds [10 x i8], [10 x i8]* %data, i32 0, i32 0
  %5 = load i8, i8* %arrayidx, align 4
  %call = call i32 @isOperator(i8 signext %5)
  %cmp3 = icmp eq i32 %call, 1
  br i1 %cmp3, label %land.lhs.true4, label %if.else

land.lhs.true4:                                   ; preds = %land.lhs.true
  %6 = load %struct.elem*, %struct.elem** %t.addr, align 4
  %data5 = getelementptr inbounds %struct.elem, %struct.elem* %6, i32 0, i32 0
  %arrayidx6 = getelementptr inbounds [10 x i8], [10 x i8]* %data5, i32 0, i32 0
  %7 = load i8, i8* %arrayidx6, align 4
  %8 = load %struct.elem*, %struct.elem** %t.addr, align 4
  %left7 = getelementptr inbounds %struct.elem, %struct.elem* %8, i32 0, i32 1
  %9 = load %struct.elem*, %struct.elem** %left7, align 4
  %data8 = getelementptr inbounds %struct.elem, %struct.elem* %9, i32 0, i32 0
  %arrayidx9 = getelementptr inbounds [10 x i8], [10 x i8]* %data8, i32 0, i32 0
  %10 = load i8, i8* %arrayidx9, align 4
  %call10 = call i32 @precedenceCheck(i8 signext %7, i8 signext %10)
  %cmp11 = icmp eq i32 %call10, 1
  br i1 %cmp11, label %if.then24, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %land.lhs.true4
  %11 = load %struct.elem*, %struct.elem** %t.addr, align 4
  %data12 = getelementptr inbounds %struct.elem, %struct.elem* %11, i32 0, i32 0
  %arrayidx13 = getelementptr inbounds [10 x i8], [10 x i8]* %data12, i32 0, i32 0
  %12 = load i8, i8* %arrayidx13, align 4
  %13 = load %struct.elem*, %struct.elem** %t.addr, align 4
  %left14 = getelementptr inbounds %struct.elem, %struct.elem* %13, i32 0, i32 1
  %14 = load %struct.elem*, %struct.elem** %left14, align 4
  %data15 = getelementptr inbounds %struct.elem, %struct.elem* %14, i32 0, i32 0
  %arrayidx16 = getelementptr inbounds [10 x i8], [10 x i8]* %data15, i32 0, i32 0
  %15 = load i8, i8* %arrayidx16, align 4
  %call17 = call i32 @precedenceCheck(i8 signext %12, i8 signext %15)
  %cmp18 = icmp eq i32 %call17, 0
  br i1 %cmp18, label %land.lhs.true19, label %if.else

land.lhs.true19:                                  ; preds = %lor.lhs.false
  %16 = load %struct.elem*, %struct.elem** %t.addr, align 4
  %data20 = getelementptr inbounds %struct.elem, %struct.elem* %16, i32 0, i32 0
  %arrayidx21 = getelementptr inbounds [10 x i8], [10 x i8]* %data20, i32 0, i32 0
  %17 = load i8, i8* %arrayidx21, align 4
  %conv = sext i8 %17 to i32
  %cmp22 = icmp eq i32 %conv, 94
  br i1 %cmp22, label %if.then24, label %if.else

if.then24:                                        ; preds = %land.lhs.true19, %land.lhs.true4
  %call25 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([2 x i8], [2 x i8]* @.str, i32 0, i32 0))
  %18 = load %struct.elem*, %struct.elem** %t.addr, align 4
  %left26 = getelementptr inbounds %struct.elem, %struct.elem* %18, i32 0, i32 1
  %19 = load %struct.elem*, %struct.elem** %left26, align 4
  call void @inorder(%struct.elem* %19)
  %call27 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([2 x i8], [2 x i8]* @.str.1, i32 0, i32 0))
  br label %if.end

if.else:                                          ; preds = %land.lhs.true19, %lor.lhs.false, %land.lhs.true, %if.then
  %20 = load %struct.elem*, %struct.elem** %t.addr, align 4
  %left28 = getelementptr inbounds %struct.elem, %struct.elem* %20, i32 0, i32 1
  %21 = load %struct.elem*, %struct.elem** %left28, align 4
  call void @inorder(%struct.elem* %21)
  br label %if.end

if.end:                                           ; preds = %if.else, %if.then24
  %22 = load %struct.elem*, %struct.elem** %t.addr, align 4
  %data29 = getelementptr inbounds %struct.elem, %struct.elem* %22, i32 0, i32 0
  %arraydecay = getelementptr inbounds [10 x i8], [10 x i8]* %data29, i32 0, i32 0
  %call30 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.2, i32 0, i32 0), i8* %arraydecay)
  %23 = load %struct.elem*, %struct.elem** %t.addr, align 4
  %right = getelementptr inbounds %struct.elem, %struct.elem* %23, i32 0, i32 2
  %24 = load %struct.elem*, %struct.elem** %right, align 4
  %cmp31 = icmp ne %struct.elem* %24, null
  br i1 %cmp31, label %land.lhs.true33, label %if.else68

land.lhs.true33:                                  ; preds = %if.end
  %25 = load %struct.elem*, %struct.elem** %t.addr, align 4
  %right34 = getelementptr inbounds %struct.elem, %struct.elem* %25, i32 0, i32 2
  %26 = load %struct.elem*, %struct.elem** %right34, align 4
  %data35 = getelementptr inbounds %struct.elem, %struct.elem* %26, i32 0, i32 0
  %arrayidx36 = getelementptr inbounds [10 x i8], [10 x i8]* %data35, i32 0, i32 0
  %27 = load i8, i8* %arrayidx36, align 4
  %call37 = call i32 @isOperator(i8 signext %27)
  %cmp38 = icmp eq i32 %call37, 1
  br i1 %cmp38, label %land.lhs.true40, label %if.else68

land.lhs.true40:                                  ; preds = %land.lhs.true33
  %28 = load %struct.elem*, %struct.elem** %t.addr, align 4
  %data41 = getelementptr inbounds %struct.elem, %struct.elem* %28, i32 0, i32 0
  %arrayidx42 = getelementptr inbounds [10 x i8], [10 x i8]* %data41, i32 0, i32 0
  %29 = load i8, i8* %arrayidx42, align 4
  %30 = load %struct.elem*, %struct.elem** %t.addr, align 4
  %right43 = getelementptr inbounds %struct.elem, %struct.elem* %30, i32 0, i32 2
  %31 = load %struct.elem*, %struct.elem** %right43, align 4
  %data44 = getelementptr inbounds %struct.elem, %struct.elem* %31, i32 0, i32 0
  %arrayidx45 = getelementptr inbounds [10 x i8], [10 x i8]* %data44, i32 0, i32 0
  %32 = load i8, i8* %arrayidx45, align 4
  %call46 = call i32 @precedenceCheck(i8 signext %29, i8 signext %32)
  %cmp47 = icmp eq i32 %call46, 1
  br i1 %cmp47, label %if.then64, label %lor.lhs.false49

lor.lhs.false49:                                  ; preds = %land.lhs.true40
  %33 = load %struct.elem*, %struct.elem** %t.addr, align 4
  %data50 = getelementptr inbounds %struct.elem, %struct.elem* %33, i32 0, i32 0
  %arrayidx51 = getelementptr inbounds [10 x i8], [10 x i8]* %data50, i32 0, i32 0
  %34 = load i8, i8* %arrayidx51, align 4
  %35 = load %struct.elem*, %struct.elem** %t.addr, align 4
  %right52 = getelementptr inbounds %struct.elem, %struct.elem* %35, i32 0, i32 2
  %36 = load %struct.elem*, %struct.elem** %right52, align 4
  %data53 = getelementptr inbounds %struct.elem, %struct.elem* %36, i32 0, i32 0
  %arrayidx54 = getelementptr inbounds [10 x i8], [10 x i8]* %data53, i32 0, i32 0
  %37 = load i8, i8* %arrayidx54, align 4
  %call55 = call i32 @precedenceCheck(i8 signext %34, i8 signext %37)
  %cmp56 = icmp eq i32 %call55, 0
  br i1 %cmp56, label %land.lhs.true58, label %if.else68

land.lhs.true58:                                  ; preds = %lor.lhs.false49
  %38 = load %struct.elem*, %struct.elem** %t.addr, align 4
  %data59 = getelementptr inbounds %struct.elem, %struct.elem* %38, i32 0, i32 0
  %arrayidx60 = getelementptr inbounds [10 x i8], [10 x i8]* %data59, i32 0, i32 0
  %39 = load i8, i8* %arrayidx60, align 4
  %conv61 = sext i8 %39 to i32
  %cmp62 = icmp ne i32 %conv61, 94
  br i1 %cmp62, label %if.then64, label %if.else68

if.then64:                                        ; preds = %land.lhs.true58, %land.lhs.true40
  %call65 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([2 x i8], [2 x i8]* @.str, i32 0, i32 0))
  %40 = load %struct.elem*, %struct.elem** %t.addr, align 4
  %right66 = getelementptr inbounds %struct.elem, %struct.elem* %40, i32 0, i32 2
  %41 = load %struct.elem*, %struct.elem** %right66, align 4
  call void @inorder(%struct.elem* %41)
  %call67 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([2 x i8], [2 x i8]* @.str.1, i32 0, i32 0))
  br label %if.end70

if.else68:                                        ; preds = %land.lhs.true58, %lor.lhs.false49, %land.lhs.true33, %if.end
  %42 = load %struct.elem*, %struct.elem** %t.addr, align 4
  %right69 = getelementptr inbounds %struct.elem, %struct.elem* %42, i32 0, i32 2
  %43 = load %struct.elem*, %struct.elem** %right69, align 4
  call void @inorder(%struct.elem* %43)
  br label %if.end70

if.end70:                                         ; preds = %if.else68, %if.then64
  br label %if.end71

if.end71:                                         ; preds = %if.end70, %entry
  ret void
}

declare i32 @printf(i8* %0, ...) #1

; Function Attrs: noinline nounwind optnone
define hidden i8* @getNextString() #0 {
entry:
  %0 = load i32, i32* @counter, align 4
  %cmp = icmp slt i32 %0, 0
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %call = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([15 x i8], [15 x i8]* @.str.3, i32 0, i32 0))
  call void @exit(i32 0) #4
  unreachable

if.end:                                           ; preds = %entry
  %1 = load i8**, i8*** @components, align 4
  %2 = load i32, i32* @counter, align 4
  %dec = add nsw i32 %2, -1
  store i32 %dec, i32* @counter, align 4
  %arrayidx = getelementptr inbounds i8*, i8** %1, i32 %2
  %3 = load i8*, i8** %arrayidx, align 4
  ret i8* %3
}

; Function Attrs: noreturn
declare void @exit(i32 %0) #2

; Function Attrs: noinline nounwind optnone
define hidden %struct.elem* @buildTree(i8* %obj, i8* %trace) #0 {
entry:
  %obj.addr = alloca i8*, align 4
  %trace.addr = alloca i8*, align 4
  %t = alloca %struct.elem*, align 4
  store i8* %obj, i8** %obj.addr, align 4
  store i8* %trace, i8** %trace.addr, align 4
  %call = call noalias i8* @malloc(i32 20)
  %0 = bitcast i8* %call to %struct.elem*
  store %struct.elem* %0, %struct.elem** %t, align 4
  %1 = load %struct.elem*, %struct.elem** %t, align 4
  %data = getelementptr inbounds %struct.elem, %struct.elem* %1, i32 0, i32 0
  %arraydecay = getelementptr inbounds [10 x i8], [10 x i8]* %data, i32 0, i32 0
  %2 = load i8*, i8** %obj.addr, align 4
  %call1 = call i8* @strcpy(i8* %arraydecay, i8* %2)
  %3 = load i8*, i8** %obj.addr, align 4
  %arrayidx = getelementptr inbounds i8, i8* %3, i32 0
  %4 = load i8, i8* %arrayidx, align 1
  %call2 = call i32 @isOperator(i8 signext %4)
  %cmp = icmp eq i32 %call2, 1
  br i1 %cmp, label %cond.true, label %cond.false

cond.true:                                        ; preds = %entry
  %call3 = call i8* @getNextString()
  %5 = load i8*, i8** %trace.addr, align 4
  %call4 = call %struct.elem* @buildTree(i8* %call3, i8* %5)
  br label %cond.end

cond.false:                                       ; preds = %entry
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi %struct.elem* [ %call4, %cond.true ], [ null, %cond.false ]
  %6 = load %struct.elem*, %struct.elem** %t, align 4
  %right = getelementptr inbounds %struct.elem, %struct.elem* %6, i32 0, i32 2
  store %struct.elem* %cond, %struct.elem** %right, align 4
  %7 = load i8*, i8** %obj.addr, align 4
  %arrayidx5 = getelementptr inbounds i8, i8* %7, i32 0
  %8 = load i8, i8* %arrayidx5, align 1
  %call6 = call i32 @isOperator(i8 signext %8)
  %cmp7 = icmp eq i32 %call6, 1
  br i1 %cmp7, label %cond.true8, label %cond.false11

cond.true8:                                       ; preds = %cond.end
  %call9 = call i8* @getNextString()
  %9 = load i8*, i8** %trace.addr, align 4
  %call10 = call %struct.elem* @buildTree(i8* %call9, i8* %9)
  br label %cond.end12

cond.false11:                                     ; preds = %cond.end
  br label %cond.end12

cond.end12:                                       ; preds = %cond.false11, %cond.true8
  %cond13 = phi %struct.elem* [ %call10, %cond.true8 ], [ null, %cond.false11 ]
  %10 = load %struct.elem*, %struct.elem** %t, align 4
  %left = getelementptr inbounds %struct.elem, %struct.elem* %10, i32 0, i32 1
  store %struct.elem* %cond13, %struct.elem** %left, align 4
  %11 = load i8*, i8** %trace.addr, align 4
  %cmp14 = icmp ne i8* %11, null
  br i1 %cmp14, label %if.then, label %if.end

if.then:                                          ; preds = %cond.end12
  %call15 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([2 x i8], [2 x i8]* @.str.4, i32 0, i32 0))
  %12 = load %struct.elem*, %struct.elem** %t, align 4
  call void @inorder(%struct.elem* %12)
  br label %if.end

if.end:                                           ; preds = %if.then, %cond.end12
  %13 = load %struct.elem*, %struct.elem** %t, align 4
  ret %struct.elem* %13
}

declare noalias i8* @malloc(i32 %0) #1

declare i8* @strcpy(i8* %0, i8* %1) #1

; Function Attrs: noinline nounwind optnone
define hidden i32 @checkRPN() #0 {
entry:
  %retval = alloca i32, align 4
  %i = alloca i32, align 4
  %operSum = alloca i32, align 4
  %numberSum = alloca i32, align 4
  store i32 0, i32* %operSum, align 4
  store i32 0, i32* %numberSum, align 4
  %0 = load i8**, i8*** @components, align 4
  %1 = load i32, i32* @counter, align 4
  %arrayidx = getelementptr inbounds i8*, i8** %0, i32 %1
  %2 = load i8*, i8** %arrayidx, align 4
  %arrayidx1 = getelementptr inbounds i8, i8* %2, i32 0
  %3 = load i8, i8* %arrayidx1, align 1
  %call = call i32 @isOperator(i8 signext %3)
  %cmp = icmp eq i32 %call, 0
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  store i32 0, i32* %retval, align 4
  br label %return

if.end:                                           ; preds = %entry
  store i32 0, i32* %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.end
  %4 = load i32, i32* %i, align 4
  %5 = load i32, i32* @counter, align 4
  %cmp2 = icmp sle i32 %4, %5
  br i1 %cmp2, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %6 = load i8**, i8*** @components, align 4
  %7 = load i32, i32* %i, align 4
  %arrayidx3 = getelementptr inbounds i8*, i8** %6, i32 %7
  %8 = load i8*, i8** %arrayidx3, align 4
  %arrayidx4 = getelementptr inbounds i8, i8* %8, i32 0
  %9 = load i8, i8* %arrayidx4, align 1
  %call5 = call i32 @isOperator(i8 signext %9)
  %cmp6 = icmp eq i32 %call5, 1
  br i1 %cmp6, label %cond.true, label %cond.false

cond.true:                                        ; preds = %for.body
  %10 = load i32, i32* %operSum, align 4
  %inc = add nsw i32 %10, 1
  store i32 %inc, i32* %operSum, align 4
  br label %cond.end

cond.false:                                       ; preds = %for.body
  %11 = load i32, i32* %numberSum, align 4
  %inc7 = add nsw i32 %11, 1
  store i32 %inc7, i32* %numberSum, align 4
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi i32 [ %10, %cond.true ], [ %11, %cond.false ]
  br label %for.inc

for.inc:                                          ; preds = %cond.end
  %12 = load i32, i32* %i, align 4
  %inc8 = add nsw i32 %12, 1
  store i32 %inc8, i32* %i, align 4
  br label %for.cond

for.end:                                          ; preds = %for.cond
  %13 = load i32, i32* %numberSum, align 4
  %14 = load i32, i32* %operSum, align 4
  %sub = sub nsw i32 %13, %14
  %cmp9 = icmp eq i32 %sub, 1
  %conv = zext i1 %cmp9 to i32
  store i32 %conv, i32* %retval, align 4
  br label %return

return:                                           ; preds = %for.end, %if.then
  %15 = load i32, i32* %retval, align 4
  ret i32 %15
}

; Function Attrs: noinline nounwind optnone
define hidden void @buildStack(i8* %str) #0 {
entry:
  %str.addr = alloca i8*, align 4
  %i = alloca i32, align 4
  %token = alloca i8*, align 4
  store i8* %str, i8** %str.addr, align 4
  store i32 0, i32* %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %0 = load i8*, i8** %str.addr, align 4
  %1 = load i32, i32* %i, align 4
  %arrayidx = getelementptr inbounds i8, i8* %0, i32 %1
  %2 = load i8, i8* %arrayidx, align 1
  %conv = sext i8 %2 to i32
  %cmp = icmp ne i32 %conv, 0
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %3 = load i8*, i8** %str.addr, align 4
  %4 = load i32, i32* %i, align 4
  %arrayidx2 = getelementptr inbounds i8, i8* %3, i32 %4
  %5 = load i8, i8* %arrayidx2, align 1
  %conv3 = sext i8 %5 to i32
  %cmp4 = icmp eq i32 %conv3, 32
  br i1 %cmp4, label %if.then, label %if.end

if.then:                                          ; preds = %for.body
  %6 = load i32, i32* @counter, align 4
  %inc = add nsw i32 %6, 1
  store i32 %inc, i32* @counter, align 4
  br label %if.end

if.end:                                           ; preds = %if.then, %for.body
  br label %for.inc

for.inc:                                          ; preds = %if.end
  %7 = load i32, i32* %i, align 4
  %inc6 = add nsw i32 %7, 1
  store i32 %inc6, i32* %i, align 4
  br label %for.cond

for.end:                                          ; preds = %for.cond
  %8 = load i32, i32* @counter, align 4
  %add = add nsw i32 %8, 1
  %mul = mul i32 %add, 4
  %call = call noalias i8* @malloc(i32 %mul)
  %9 = bitcast i8* %call to i8**
  store i8** %9, i8*** @components, align 4
  %10 = load i8*, i8** %str.addr, align 4
  %call7 = call i8* @strtok(i8* %10, i8* getelementptr inbounds ([2 x i8], [2 x i8]* @.str.5, i32 0, i32 0))
  store i8* %call7, i8** %token, align 4
  store i32 0, i32* %i, align 4
  br label %while.cond

while.cond:                                       ; preds = %while.body, %for.end
  %11 = load i8*, i8** %token, align 4
  %cmp8 = icmp ne i8* %11, null
  br i1 %cmp8, label %while.body, label %while.end

while.body:                                       ; preds = %while.cond
  %12 = load i8*, i8** %token, align 4
  %call10 = call i32 @strlen(i8* %12) #5
  %mul11 = mul i32 %call10, 1
  %call12 = call noalias i8* @malloc(i32 %mul11)
  %13 = load i8**, i8*** @components, align 4
  %14 = load i32, i32* %i, align 4
  %arrayidx13 = getelementptr inbounds i8*, i8** %13, i32 %14
  store i8* %call12, i8** %arrayidx13, align 4
  %15 = load i8**, i8*** @components, align 4
  %16 = load i32, i32* %i, align 4
  %arrayidx14 = getelementptr inbounds i8*, i8** %15, i32 %16
  %17 = load i8*, i8** %arrayidx14, align 4
  %18 = load i8*, i8** %token, align 4
  %call15 = call i8* @strcpy(i8* %17, i8* %18)
  %call16 = call i8* @strtok(i8* null, i8* getelementptr inbounds ([2 x i8], [2 x i8]* @.str.5, i32 0, i32 0))
  store i8* %call16, i8** %token, align 4
  %19 = load i32, i32* %i, align 4
  %inc17 = add nsw i32 %19, 1
  store i32 %inc17, i32* %i, align 4
  br label %while.cond

while.end:                                        ; preds = %while.cond
  ret void
}

declare i8* @strtok(i8* %0, i8* %1) #1

; Function Attrs: nounwind readonly
declare i32 @strlen(i8* %0) #3

; Function Attrs: noinline nounwind optnone
define hidden i32 @__main_argc_argv(i32 %argC, i8** %argV) #0 {
entry:
  %retval = alloca i32, align 4
  %argC.addr = alloca i32, align 4
  %argV.addr = alloca i8**, align 4
  %i = alloca i32, align 4
  %t = alloca %struct.elem*, align 4
  store i32 0, i32* %retval, align 4
  store i32 %argC, i32* %argC.addr, align 4
  store i8** %argV, i8*** %argV.addr, align 4
  %0 = load i32, i32* %argC.addr, align 4
  %cmp = icmp eq i32 %0, 1
  br i1 %cmp, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  %1 = load i8**, i8*** %argV.addr, align 4
  %arrayidx = getelementptr inbounds i8*, i8** %1, i32 0
  %2 = load i8*, i8** %arrayidx, align 4
  %call = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([95 x i8], [95 x i8]* @.str.6, i32 0, i32 0), i8* %2)
  br label %if.end10

if.else:                                          ; preds = %entry
  %3 = load i8**, i8*** %argV.addr, align 4
  %arrayidx1 = getelementptr inbounds i8*, i8** %3, i32 1
  %4 = load i8*, i8** %arrayidx1, align 4
  call void @buildStack(i8* %4)
  %call2 = call i32 @checkRPN()
  %cmp3 = icmp eq i32 %call2, 0
  br i1 %cmp3, label %if.then4, label %if.end

if.then4:                                         ; preds = %if.else
  %call5 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([15 x i8], [15 x i8]* @.str.3, i32 0, i32 0))
  store i32 0, i32* %retval, align 4
  br label %return

if.end:                                           ; preds = %if.else
  %call6 = call i8* @getNextString()
  %5 = load i8**, i8*** %argV.addr, align 4
  %arrayidx7 = getelementptr inbounds i8*, i8** %5, i32 2
  %6 = load i8*, i8** %arrayidx7, align 4
  %call8 = call %struct.elem* @buildTree(i8* %call6, i8* %6)
  store %struct.elem* %call8, %struct.elem** %t, align 4
  %call9 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([27 x i8], [27 x i8]* @.str.7, i32 0, i32 0))
  %7 = load %struct.elem*, %struct.elem** %t, align 4
  call void @inorder(%struct.elem* %7)
  br label %if.end10

if.end10:                                         ; preds = %if.end, %if.then
  store i32 0, i32* %retval, align 4
  br label %return

return:                                           ; preds = %if.end10, %if.then4
  %8 = load i32, i32* %retval, align 4
  ret i32 %8
}

attributes #0 = { noinline nounwind optnone "correctly-rounded-divide-sqrt-fp-math"="false" "disable-tail-calls"="false" "frame-pointer"="none" "less-precise-fpmad"="false" "min-legal-vector-width"="0" "no-infs-fp-math"="false" "no-jump-tables"="false" "no-nans-fp-math"="false" "no-signed-zeros-fp-math"="false" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="generic" "unsafe-fp-math"="false" "use-soft-float"="false" }
attributes #1 = { "correctly-rounded-divide-sqrt-fp-math"="false" "disable-tail-calls"="false" "frame-pointer"="none" "less-precise-fpmad"="false" "no-infs-fp-math"="false" "no-nans-fp-math"="false" "no-signed-zeros-fp-math"="false" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="generic" "unsafe-fp-math"="false" "use-soft-float"="false" }
attributes #2 = { noreturn "correctly-rounded-divide-sqrt-fp-math"="false" "disable-tail-calls"="false" "frame-pointer"="none" "less-precise-fpmad"="false" "no-infs-fp-math"="false" "no-nans-fp-math"="false" "no-signed-zeros-fp-math"="false" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="generic" "unsafe-fp-math"="false" "use-soft-float"="false" }
attributes #3 = { nounwind readonly "correctly-rounded-divide-sqrt-fp-math"="false" "disable-tail-calls"="false" "frame-pointer"="none" "less-precise-fpmad"="false" "no-infs-fp-math"="false" "no-nans-fp-math"="false" "no-signed-zeros-fp-math"="false" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="generic" "unsafe-fp-math"="false" "use-soft-float"="false" }
attributes #4 = { noreturn }
attributes #5 = { nounwind readonly }

!llvm.module.flags = !{!0}
!llvm.ident = !{!1}

!0 = !{i32 1, !"wchar_size", i32 4}
!1 = !{!"clang version 11.0.0 (https://github.com/Jacarte/llvm-project.git 0f6dea67136cc1e0b3d200eb2bb165628970c44b)"}

; extracted candidates

; *****
; For LLVM instruction:
;  %0 = load i32, i32* @counter, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %cmp = icmp slt i32 %0, 0
; Looking for a replacement for:
%0:i32 = var
%1:i1 = slt %0, 0:i32
infer %1

; *****
; For LLVM instruction:
;  %2 = load i32, i32* @counter, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %dec = add nsw i32 %2, -1
; Looking for a replacement for:
%0:i32 = var
%1:i32 = addnsw 4294967295:i32, %0
infer %1
got 2 candidates from LHS

-------------------------------------------------
%0:i32 = var
%1:i1 = slt %0, 0:i32
infer %1


--------------------------------
guess 0

%0:i1 = var ; reservedconst_1

Cost = 0
first query is SAT, returning the model:
reservedconst_1: 0
0 th attempt: second query is SAT-- constant doesn't work
first query is SAT, returning the model:
reservedconst_1: -1
1 th attempt: second query is SAT-- constant doesn't work
first query is UNSAT-- no more guesses
Dataflow Pruned 0/0
There are 1 Guesses
There are 0 RHSs before deduplication
There are 0 RHSs after deduplication
got 2 candidates from LHS

-------------------------------------------------
%0:i32 = var
%1:i32 = addnsw 4294967295:i32, %0
infer %1


--------------------------------
guess 0

%0:i32 = var ; reservedconst_1

Cost = 0
first query is SAT, returning the model:
reservedconst_1: -1
0 th attempt: second query is SAT-- constant doesn't work
first query is SAT, returning the model:
reservedconst_1: 536870911
1 th attempt: second query is SAT-- constant doesn't work
first query is UNSAT-- no more guesses

--------------------------------
guess 1

%0:i32 = var

Cost = 0
second query is SAT-- constant doesn't work
Dataflow Pruned 0/0
There are 2 Guesses
There are 0 RHSs before deduplication
There are 0 RHSs after deduplication
#########################################################
; exiting Souper's runOnFunction() for getNextString()

; entering Souper's runOnFunction() for buildTree()

; ModuleID = './Parsing-RPN_to_infix_conversion.c.bc'
source_filename = "./Parsing-RPN_to_infix_conversion.c"
target datalayout = "e-m:e-p:32:32-i64:64-n32:64-S128"
target triple = "wasm32-unknown-wasi"

%struct.elem = type { [10 x i8], %struct.elem*, %struct.elem* }

@counter = hidden global i32 0, align 4
@.str = private unnamed_addr constant [2 x i8] c"(\00", align 1
@.str.1 = private unnamed_addr constant [2 x i8] c")\00", align 1
@.str.2 = private unnamed_addr constant [5 x i8] c" %s \00", align 1
@.str.3 = private unnamed_addr constant [15 x i8] c"\0AInvalid RPN !\00", align 1
@components = hidden global i8** null, align 4
@.str.4 = private unnamed_addr constant [2 x i8] c"\0A\00", align 1
@.str.5 = private unnamed_addr constant [2 x i8] c" \00", align 1
@.str.6 = private unnamed_addr constant [95 x i8] c"Usage : %s <RPN expression enclosed by quotes> <optional parameter to trace the build process>\00", align 1
@.str.7 = private unnamed_addr constant [27 x i8] c"\0AFinal infix expression : \00", align 1

; Function Attrs: noinline nounwind optnone
define hidden i32 @precedenceCheck(i8 signext %oper1, i8 signext %oper2) #0 {
entry:
  %oper1.addr = alloca i8, align 1
  %oper2.addr = alloca i8, align 1
  store i8 %oper1, i8* %oper1.addr, align 1
  store i8 %oper2, i8* %oper2.addr, align 1
  %0 = load i8, i8* %oper1.addr, align 1
  %conv = sext i8 %0 to i32
  %1 = load i8, i8* %oper2.addr, align 1
  %conv1 = sext i8 %1 to i32
  %cmp = icmp eq i32 %conv, %conv1
  br i1 %cmp, label %cond.true, label %cond.false

cond.true:                                        ; preds = %entry
  br label %cond.end61

cond.false:                                       ; preds = %entry
  %2 = load i8, i8* %oper1.addr, align 1
  %conv3 = sext i8 %2 to i32
  %cmp4 = icmp eq i32 %conv3, 94
  br i1 %cmp4, label %cond.true6, label %cond.false7

cond.true6:                                       ; preds = %cond.false
  br label %cond.end59

cond.false7:                                      ; preds = %cond.false
  %3 = load i8, i8* %oper2.addr, align 1
  %conv8 = sext i8 %3 to i32
  %cmp9 = icmp eq i32 %conv8, 94
  br i1 %cmp9, label %cond.true11, label %cond.false12

cond.true11:                                      ; preds = %cond.false7
  br label %cond.end57

cond.false12:                                     ; preds = %cond.false7
  %4 = load i8, i8* %oper1.addr, align 1
  %conv13 = sext i8 %4 to i32
  %cmp14 = icmp eq i32 %conv13, 47
  br i1 %cmp14, label %cond.true16, label %cond.false17

cond.true16:                                      ; preds = %cond.false12
  br label %cond.end55

cond.false17:                                     ; preds = %cond.false12
  %5 = load i8, i8* %oper2.addr, align 1
  %conv18 = sext i8 %5 to i32
  %cmp19 = icmp eq i32 %conv18, 47
  br i1 %cmp19, label %cond.true21, label %cond.false22

cond.true21:                                      ; preds = %cond.false17
  br label %cond.end53

cond.false22:                                     ; preds = %cond.false17
  %6 = load i8, i8* %oper1.addr, align 1
  %conv23 = sext i8 %6 to i32
  %cmp24 = icmp eq i32 %conv23, 42
  br i1 %cmp24, label %cond.true26, label %cond.false27

cond.true26:                                      ; preds = %cond.false22
  br label %cond.end51

cond.false27:                                     ; preds = %cond.false22
  %7 = load i8, i8* %oper2.addr, align 1
  %conv28 = sext i8 %7 to i32
  %cmp29 = icmp eq i32 %conv28, 42
  br i1 %cmp29, label %cond.true31, label %cond.false32

cond.true31:                                      ; preds = %cond.false27
  br label %cond.end49

cond.false32:                                     ; preds = %cond.false27
  %8 = load i8, i8* %oper1.addr, align 1
  %conv33 = sext i8 %8 to i32
  %cmp34 = icmp eq i32 %conv33, 43
  br i1 %cmp34, label %cond.true36, label %cond.false37

cond.true36:                                      ; preds = %cond.false32
  br label %cond.end47

cond.false37:                                     ; preds = %cond.false32
  %9 = load i8, i8* %oper2.addr, align 1
  %conv38 = sext i8 %9 to i32
  %cmp39 = icmp eq i32 %conv38, 43
  br i1 %cmp39, label %cond.true41, label %cond.false42

cond.true41:                                      ; preds = %cond.false37
  br label %cond.end

cond.false42:                                     ; preds = %cond.false37
  %10 = load i8, i8* %oper1.addr, align 1
  %conv43 = sext i8 %10 to i32
  %cmp44 = icmp eq i32 %conv43, 45
  %11 = zext i1 %cmp44 to i64
  %cond = select i1 %cmp44, i32 1, i32 2
  br label %cond.end

cond.end:                                         ; preds = %cond.false42, %cond.true41
  %cond46 = phi i32 [ 2, %cond.true41 ], [ %cond, %cond.false42 ]
  br label %cond.end47

cond.end47:                                       ; preds = %cond.end, %cond.true36
  %cond48 = phi i32 [ 1, %cond.true36 ], [ %cond46, %cond.end ]
  br label %cond.end49

cond.end49:                                       ; preds = %cond.end47, %cond.true31
  %cond50 = phi i32 [ 2, %cond.true31 ], [ %cond48, %cond.end47 ]
  br label %cond.end51

cond.end51:                                       ; preds = %cond.end49, %cond.true26
  %cond52 = phi i32 [ 1, %cond.true26 ], [ %cond50, %cond.end49 ]
  br label %cond.end53

cond.end53:                                       ; preds = %cond.end51, %cond.true21
  %cond54 = phi i32 [ 2, %cond.true21 ], [ %cond52, %cond.end51 ]
  br label %cond.end55

cond.end55:                                       ; preds = %cond.end53, %cond.true16
  %cond56 = phi i32 [ 1, %cond.true16 ], [ %cond54, %cond.end53 ]
  br label %cond.end57

cond.end57:                                       ; preds = %cond.end55, %cond.true11
  %cond58 = phi i32 [ 2, %cond.true11 ], [ %cond56, %cond.end55 ]
  br label %cond.end59

cond.end59:                                       ; preds = %cond.end57, %cond.true6
  %cond60 = phi i32 [ 1, %cond.true6 ], [ %cond58, %cond.end57 ]
  br label %cond.end61

cond.end61:                                       ; preds = %cond.end59, %cond.true
  %cond62 = phi i32 [ 0, %cond.true ], [ %cond60, %cond.end59 ]
  ret i32 %cond62
}

; Function Attrs: noinline nounwind optnone
define hidden i32 @isOperator(i8 signext %c) #0 {
entry:
  %c.addr = alloca i8, align 1
  store i8 %c, i8* %c.addr, align 1
  %0 = load i8, i8* %c.addr, align 1
  %conv = sext i8 %0 to i32
  %cmp = icmp eq i32 %conv, 43
  br i1 %cmp, label %lor.end, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %entry
  %1 = load i8, i8* %c.addr, align 1
  %conv2 = sext i8 %1 to i32
  %cmp3 = icmp eq i32 %conv2, 45
  br i1 %cmp3, label %lor.end, label %lor.lhs.false5

lor.lhs.false5:                                   ; preds = %lor.lhs.false
  %2 = load i8, i8* %c.addr, align 1
  %conv6 = sext i8 %2 to i32
  %cmp7 = icmp eq i32 %conv6, 42
  br i1 %cmp7, label %lor.end, label %lor.lhs.false9

lor.lhs.false9:                                   ; preds = %lor.lhs.false5
  %3 = load i8, i8* %c.addr, align 1
  %conv10 = sext i8 %3 to i32
  %cmp11 = icmp eq i32 %conv10, 47
  br i1 %cmp11, label %lor.end, label %lor.rhs

lor.rhs:                                          ; preds = %lor.lhs.false9
  %4 = load i8, i8* %c.addr, align 1
  %conv13 = sext i8 %4 to i32
  %cmp14 = icmp eq i32 %conv13, 94
  br label %lor.end

lor.end:                                          ; preds = %lor.rhs, %lor.lhs.false9, %lor.lhs.false5, %lor.lhs.false, %entry
  %5 = phi i1 [ true, %lor.lhs.false9 ], [ true, %lor.lhs.false5 ], [ true, %lor.lhs.false ], [ true, %entry ], [ %cmp14, %lor.rhs ]
  %lor.ext = zext i1 %5 to i32
  ret i32 %lor.ext
}

; Function Attrs: noinline nounwind optnone
define hidden void @inorder(%struct.elem* %t) #0 {
entry:
  %t.addr = alloca %struct.elem*, align 4
  store %struct.elem* %t, %struct.elem** %t.addr, align 4
  %0 = load %struct.elem*, %struct.elem** %t.addr, align 4
  %cmp = icmp ne %struct.elem* %0, null
  br i1 %cmp, label %if.then, label %if.end71

if.then:                                          ; preds = %entry
  %1 = load %struct.elem*, %struct.elem** %t.addr, align 4
  %left = getelementptr inbounds %struct.elem, %struct.elem* %1, i32 0, i32 1
  %2 = load %struct.elem*, %struct.elem** %left, align 4
  %cmp1 = icmp ne %struct.elem* %2, null
  br i1 %cmp1, label %land.lhs.true, label %if.else

land.lhs.true:                                    ; preds = %if.then
  %3 = load %struct.elem*, %struct.elem** %t.addr, align 4
  %left2 = getelementptr inbounds %struct.elem, %struct.elem* %3, i32 0, i32 1
  %4 = load %struct.elem*, %struct.elem** %left2, align 4
  %data = getelementptr inbounds %struct.elem, %struct.elem* %4, i32 0, i32 0
  %arrayidx = getelementptr inbounds [10 x i8], [10 x i8]* %data, i32 0, i32 0
  %5 = load i8, i8* %arrayidx, align 4
  %call = call i32 @isOperator(i8 signext %5)
  %cmp3 = icmp eq i32 %call, 1
  br i1 %cmp3, label %land.lhs.true4, label %if.else

land.lhs.true4:                                   ; preds = %land.lhs.true
  %6 = load %struct.elem*, %struct.elem** %t.addr, align 4
  %data5 = getelementptr inbounds %struct.elem, %struct.elem* %6, i32 0, i32 0
  %arrayidx6 = getelementptr inbounds [10 x i8], [10 x i8]* %data5, i32 0, i32 0
  %7 = load i8, i8* %arrayidx6, align 4
  %8 = load %struct.elem*, %struct.elem** %t.addr, align 4
  %left7 = getelementptr inbounds %struct.elem, %struct.elem* %8, i32 0, i32 1
  %9 = load %struct.elem*, %struct.elem** %left7, align 4
  %data8 = getelementptr inbounds %struct.elem, %struct.elem* %9, i32 0, i32 0
  %arrayidx9 = getelementptr inbounds [10 x i8], [10 x i8]* %data8, i32 0, i32 0
  %10 = load i8, i8* %arrayidx9, align 4
  %call10 = call i32 @precedenceCheck(i8 signext %7, i8 signext %10)
  %cmp11 = icmp eq i32 %call10, 1
  br i1 %cmp11, label %if.then24, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %land.lhs.true4
  %11 = load %struct.elem*, %struct.elem** %t.addr, align 4
  %data12 = getelementptr inbounds %struct.elem, %struct.elem* %11, i32 0, i32 0
  %arrayidx13 = getelementptr inbounds [10 x i8], [10 x i8]* %data12, i32 0, i32 0
  %12 = load i8, i8* %arrayidx13, align 4
  %13 = load %struct.elem*, %struct.elem** %t.addr, align 4
  %left14 = getelementptr inbounds %struct.elem, %struct.elem* %13, i32 0, i32 1
  %14 = load %struct.elem*, %struct.elem** %left14, align 4
  %data15 = getelementptr inbounds %struct.elem, %struct.elem* %14, i32 0, i32 0
  %arrayidx16 = getelementptr inbounds [10 x i8], [10 x i8]* %data15, i32 0, i32 0
  %15 = load i8, i8* %arrayidx16, align 4
  %call17 = call i32 @precedenceCheck(i8 signext %12, i8 signext %15)
  %cmp18 = icmp eq i32 %call17, 0
  br i1 %cmp18, label %land.lhs.true19, label %if.else

land.lhs.true19:                                  ; preds = %lor.lhs.false
  %16 = load %struct.elem*, %struct.elem** %t.addr, align 4
  %data20 = getelementptr inbounds %struct.elem, %struct.elem* %16, i32 0, i32 0
  %arrayidx21 = getelementptr inbounds [10 x i8], [10 x i8]* %data20, i32 0, i32 0
  %17 = load i8, i8* %arrayidx21, align 4
  %conv = sext i8 %17 to i32
  %cmp22 = icmp eq i32 %conv, 94
  br i1 %cmp22, label %if.then24, label %if.else

if.then24:                                        ; preds = %land.lhs.true19, %land.lhs.true4
  %call25 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([2 x i8], [2 x i8]* @.str, i32 0, i32 0))
  %18 = load %struct.elem*, %struct.elem** %t.addr, align 4
  %left26 = getelementptr inbounds %struct.elem, %struct.elem* %18, i32 0, i32 1
  %19 = load %struct.elem*, %struct.elem** %left26, align 4
  call void @inorder(%struct.elem* %19)
  %call27 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([2 x i8], [2 x i8]* @.str.1, i32 0, i32 0))
  br label %if.end

if.else:                                          ; preds = %land.lhs.true19, %lor.lhs.false, %land.lhs.true, %if.then
  %20 = load %struct.elem*, %struct.elem** %t.addr, align 4
  %left28 = getelementptr inbounds %struct.elem, %struct.elem* %20, i32 0, i32 1
  %21 = load %struct.elem*, %struct.elem** %left28, align 4
  call void @inorder(%struct.elem* %21)
  br label %if.end

if.end:                                           ; preds = %if.else, %if.then24
  %22 = load %struct.elem*, %struct.elem** %t.addr, align 4
  %data29 = getelementptr inbounds %struct.elem, %struct.elem* %22, i32 0, i32 0
  %arraydecay = getelementptr inbounds [10 x i8], [10 x i8]* %data29, i32 0, i32 0
  %call30 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.2, i32 0, i32 0), i8* %arraydecay)
  %23 = load %struct.elem*, %struct.elem** %t.addr, align 4
  %right = getelementptr inbounds %struct.elem, %struct.elem* %23, i32 0, i32 2
  %24 = load %struct.elem*, %struct.elem** %right, align 4
  %cmp31 = icmp ne %struct.elem* %24, null
  br i1 %cmp31, label %land.lhs.true33, label %if.else68

land.lhs.true33:                                  ; preds = %if.end
  %25 = load %struct.elem*, %struct.elem** %t.addr, align 4
  %right34 = getelementptr inbounds %struct.elem, %struct.elem* %25, i32 0, i32 2
  %26 = load %struct.elem*, %struct.elem** %right34, align 4
  %data35 = getelementptr inbounds %struct.elem, %struct.elem* %26, i32 0, i32 0
  %arrayidx36 = getelementptr inbounds [10 x i8], [10 x i8]* %data35, i32 0, i32 0
  %27 = load i8, i8* %arrayidx36, align 4
  %call37 = call i32 @isOperator(i8 signext %27)
  %cmp38 = icmp eq i32 %call37, 1
  br i1 %cmp38, label %land.lhs.true40, label %if.else68

land.lhs.true40:                                  ; preds = %land.lhs.true33
  %28 = load %struct.elem*, %struct.elem** %t.addr, align 4
  %data41 = getelementptr inbounds %struct.elem, %struct.elem* %28, i32 0, i32 0
  %arrayidx42 = getelementptr inbounds [10 x i8], [10 x i8]* %data41, i32 0, i32 0
  %29 = load i8, i8* %arrayidx42, align 4
  %30 = load %struct.elem*, %struct.elem** %t.addr, align 4
  %right43 = getelementptr inbounds %struct.elem, %struct.elem* %30, i32 0, i32 2
  %31 = load %struct.elem*, %struct.elem** %right43, align 4
  %data44 = getelementptr inbounds %struct.elem, %struct.elem* %31, i32 0, i32 0
  %arrayidx45 = getelementptr inbounds [10 x i8], [10 x i8]* %data44, i32 0, i32 0
  %32 = load i8, i8* %arrayidx45, align 4
  %call46 = call i32 @precedenceCheck(i8 signext %29, i8 signext %32)
  %cmp47 = icmp eq i32 %call46, 1
  br i1 %cmp47, label %if.then64, label %lor.lhs.false49

lor.lhs.false49:                                  ; preds = %land.lhs.true40
  %33 = load %struct.elem*, %struct.elem** %t.addr, align 4
  %data50 = getelementptr inbounds %struct.elem, %struct.elem* %33, i32 0, i32 0
  %arrayidx51 = getelementptr inbounds [10 x i8], [10 x i8]* %data50, i32 0, i32 0
  %34 = load i8, i8* %arrayidx51, align 4
  %35 = load %struct.elem*, %struct.elem** %t.addr, align 4
  %right52 = getelementptr inbounds %struct.elem, %struct.elem* %35, i32 0, i32 2
  %36 = load %struct.elem*, %struct.elem** %right52, align 4
  %data53 = getelementptr inbounds %struct.elem, %struct.elem* %36, i32 0, i32 0
  %arrayidx54 = getelementptr inbounds [10 x i8], [10 x i8]* %data53, i32 0, i32 0
  %37 = load i8, i8* %arrayidx54, align 4
  %call55 = call i32 @precedenceCheck(i8 signext %34, i8 signext %37)
  %cmp56 = icmp eq i32 %call55, 0
  br i1 %cmp56, label %land.lhs.true58, label %if.else68

land.lhs.true58:                                  ; preds = %lor.lhs.false49
  %38 = load %struct.elem*, %struct.elem** %t.addr, align 4
  %data59 = getelementptr inbounds %struct.elem, %struct.elem* %38, i32 0, i32 0
  %arrayidx60 = getelementptr inbounds [10 x i8], [10 x i8]* %data59, i32 0, i32 0
  %39 = load i8, i8* %arrayidx60, align 4
  %conv61 = sext i8 %39 to i32
  %cmp62 = icmp ne i32 %conv61, 94
  br i1 %cmp62, label %if.then64, label %if.else68

if.then64:                                        ; preds = %land.lhs.true58, %land.lhs.true40
  %call65 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([2 x i8], [2 x i8]* @.str, i32 0, i32 0))
  %40 = load %struct.elem*, %struct.elem** %t.addr, align 4
  %right66 = getelementptr inbounds %struct.elem, %struct.elem* %40, i32 0, i32 2
  %41 = load %struct.elem*, %struct.elem** %right66, align 4
  call void @inorder(%struct.elem* %41)
  %call67 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([2 x i8], [2 x i8]* @.str.1, i32 0, i32 0))
  br label %if.end70

if.else68:                                        ; preds = %land.lhs.true58, %lor.lhs.false49, %land.lhs.true33, %if.end
  %42 = load %struct.elem*, %struct.elem** %t.addr, align 4
  %right69 = getelementptr inbounds %struct.elem, %struct.elem* %42, i32 0, i32 2
  %43 = load %struct.elem*, %struct.elem** %right69, align 4
  call void @inorder(%struct.elem* %43)
  br label %if.end70

if.end70:                                         ; preds = %if.else68, %if.then64
  br label %if.end71

if.end71:                                         ; preds = %if.end70, %entry
  ret void
}

declare i32 @printf(i8* %0, ...) #1

; Function Attrs: noinline nounwind optnone
define hidden i8* @getNextString() #0 {
entry:
  %0 = load i32, i32* @counter, align 4
  %cmp = icmp slt i32 %0, 0
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %call = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([15 x i8], [15 x i8]* @.str.3, i32 0, i32 0))
  call void @exit(i32 0) #4
  unreachable

if.end:                                           ; preds = %entry
  %1 = load i8**, i8*** @components, align 4
  %2 = load i32, i32* @counter, align 4
  %dec = add nsw i32 %2, -1
  store i32 %dec, i32* @counter, align 4
  %arrayidx = getelementptr inbounds i8*, i8** %1, i32 %2
  %3 = load i8*, i8** %arrayidx, align 4
  ret i8* %3
}

; Function Attrs: noreturn
declare void @exit(i32 %0) #2

; Function Attrs: noinline nounwind optnone
define hidden %struct.elem* @buildTree(i8* %obj, i8* %trace) #0 {
entry:
  %obj.addr = alloca i8*, align 4
  %trace.addr = alloca i8*, align 4
  %t = alloca %struct.elem*, align 4
  store i8* %obj, i8** %obj.addr, align 4
  store i8* %trace, i8** %trace.addr, align 4
  %call = call noalias i8* @malloc(i32 20)
  %0 = bitcast i8* %call to %struct.elem*
  store %struct.elem* %0, %struct.elem** %t, align 4
  %1 = load %struct.elem*, %struct.elem** %t, align 4
  %data = getelementptr inbounds %struct.elem, %struct.elem* %1, i32 0, i32 0
  %arraydecay = getelementptr inbounds [10 x i8], [10 x i8]* %data, i32 0, i32 0
  %2 = load i8*, i8** %obj.addr, align 4
  %call1 = call i8* @strcpy(i8* %arraydecay, i8* %2)
  %3 = load i8*, i8** %obj.addr, align 4
  %arrayidx = getelementptr inbounds i8, i8* %3, i32 0
  %4 = load i8, i8* %arrayidx, align 1
  %call2 = call i32 @isOperator(i8 signext %4)
  %cmp = icmp eq i32 %call2, 1
  br i1 %cmp, label %cond.true, label %cond.false

cond.true:                                        ; preds = %entry
  %call3 = call i8* @getNextString()
  %5 = load i8*, i8** %trace.addr, align 4
  %call4 = call %struct.elem* @buildTree(i8* %call3, i8* %5)
  br label %cond.end

cond.false:                                       ; preds = %entry
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi %struct.elem* [ %call4, %cond.true ], [ null, %cond.false ]
  %6 = load %struct.elem*, %struct.elem** %t, align 4
  %right = getelementptr inbounds %struct.elem, %struct.elem* %6, i32 0, i32 2
  store %struct.elem* %cond, %struct.elem** %right, align 4
  %7 = load i8*, i8** %obj.addr, align 4
  %arrayidx5 = getelementptr inbounds i8, i8* %7, i32 0
  %8 = load i8, i8* %arrayidx5, align 1
  %call6 = call i32 @isOperator(i8 signext %8)
  %cmp7 = icmp eq i32 %call6, 1
  br i1 %cmp7, label %cond.true8, label %cond.false11

cond.true8:                                       ; preds = %cond.end
  %call9 = call i8* @getNextString()
  %9 = load i8*, i8** %trace.addr, align 4
  %call10 = call %struct.elem* @buildTree(i8* %call9, i8* %9)
  br label %cond.end12

cond.false11:                                     ; preds = %cond.end
  br label %cond.end12

cond.end12:                                       ; preds = %cond.false11, %cond.true8
  %cond13 = phi %struct.elem* [ %call10, %cond.true8 ], [ null, %cond.false11 ]
  %10 = load %struct.elem*, %struct.elem** %t, align 4
  %left = getelementptr inbounds %struct.elem, %struct.elem* %10, i32 0, i32 1
  store %struct.elem* %cond13, %struct.elem** %left, align 4
  %11 = load i8*, i8** %trace.addr, align 4
  %cmp14 = icmp ne i8* %11, null
  br i1 %cmp14, label %if.then, label %if.end

if.then:                                          ; preds = %cond.end12
  %call15 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([2 x i8], [2 x i8]* @.str.4, i32 0, i32 0))
  %12 = load %struct.elem*, %struct.elem** %t, align 4
  call void @inorder(%struct.elem* %12)
  br label %if.end

if.end:                                           ; preds = %if.then, %cond.end12
  %13 = load %struct.elem*, %struct.elem** %t, align 4
  ret %struct.elem* %13
}

declare noalias i8* @malloc(i32 %0) #1

declare i8* @strcpy(i8* %0, i8* %1) #1

; Function Attrs: noinline nounwind optnone
define hidden i32 @checkRPN() #0 {
entry:
  %retval = alloca i32, align 4
  %i = alloca i32, align 4
  %operSum = alloca i32, align 4
  %numberSum = alloca i32, align 4
  store i32 0, i32* %operSum, align 4
  store i32 0, i32* %numberSum, align 4
  %0 = load i8**, i8*** @components, align 4
  %1 = load i32, i32* @counter, align 4
  %arrayidx = getelementptr inbounds i8*, i8** %0, i32 %1
  %2 = load i8*, i8** %arrayidx, align 4
  %arrayidx1 = getelementptr inbounds i8, i8* %2, i32 0
  %3 = load i8, i8* %arrayidx1, align 1
  %call = call i32 @isOperator(i8 signext %3)
  %cmp = icmp eq i32 %call, 0
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  store i32 0, i32* %retval, align 4
  br label %return

if.end:                                           ; preds = %entry
  store i32 0, i32* %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.end
  %4 = load i32, i32* %i, align 4
  %5 = load i32, i32* @counter, align 4
  %cmp2 = icmp sle i32 %4, %5
  br i1 %cmp2, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %6 = load i8**, i8*** @components, align 4
  %7 = load i32, i32* %i, align 4
  %arrayidx3 = getelementptr inbounds i8*, i8** %6, i32 %7
  %8 = load i8*, i8** %arrayidx3, align 4
  %arrayidx4 = getelementptr inbounds i8, i8* %8, i32 0
  %9 = load i8, i8* %arrayidx4, align 1
  %call5 = call i32 @isOperator(i8 signext %9)
  %cmp6 = icmp eq i32 %call5, 1
  br i1 %cmp6, label %cond.true, label %cond.false

cond.true:                                        ; preds = %for.body
  %10 = load i32, i32* %operSum, align 4
  %inc = add nsw i32 %10, 1
  store i32 %inc, i32* %operSum, align 4
  br label %cond.end

cond.false:                                       ; preds = %for.body
  %11 = load i32, i32* %numberSum, align 4
  %inc7 = add nsw i32 %11, 1
  store i32 %inc7, i32* %numberSum, align 4
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi i32 [ %10, %cond.true ], [ %11, %cond.false ]
  br label %for.inc

for.inc:                                          ; preds = %cond.end
  %12 = load i32, i32* %i, align 4
  %inc8 = add nsw i32 %12, 1
  store i32 %inc8, i32* %i, align 4
  br label %for.cond

for.end:                                          ; preds = %for.cond
  %13 = load i32, i32* %numberSum, align 4
  %14 = load i32, i32* %operSum, align 4
  %sub = sub nsw i32 %13, %14
  %cmp9 = icmp eq i32 %sub, 1
  %conv = zext i1 %cmp9 to i32
  store i32 %conv, i32* %retval, align 4
  br label %return

return:                                           ; preds = %for.end, %if.then
  %15 = load i32, i32* %retval, align 4
  ret i32 %15
}

; Function Attrs: noinline nounwind optnone
define hidden void @buildStack(i8* %str) #0 {
entry:
  %str.addr = alloca i8*, align 4
  %i = alloca i32, align 4
  %token = alloca i8*, align 4
  store i8* %str, i8** %str.addr, align 4
  store i32 0, i32* %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %0 = load i8*, i8** %str.addr, align 4
  %1 = load i32, i32* %i, align 4
  %arrayidx = getelementptr inbounds i8, i8* %0, i32 %1
  %2 = load i8, i8* %arrayidx, align 1
  %conv = sext i8 %2 to i32
  %cmp = icmp ne i32 %conv, 0
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %3 = load i8*, i8** %str.addr, align 4
  %4 = load i32, i32* %i, align 4
  %arrayidx2 = getelementptr inbounds i8, i8* %3, i32 %4
  %5 = load i8, i8* %arrayidx2, align 1
  %conv3 = sext i8 %5 to i32
  %cmp4 = icmp eq i32 %conv3, 32
  br i1 %cmp4, label %if.then, label %if.end

if.then:                                          ; preds = %for.body
  %6 = load i32, i32* @counter, align 4
  %inc = add nsw i32 %6, 1
  store i32 %inc, i32* @counter, align 4
  br label %if.end

if.end:                                           ; preds = %if.then, %for.body
  br label %for.inc

for.inc:                                          ; preds = %if.end
  %7 = load i32, i32* %i, align 4
  %inc6 = add nsw i32 %7, 1
  store i32 %inc6, i32* %i, align 4
  br label %for.cond

for.end:                                          ; preds = %for.cond
  %8 = load i32, i32* @counter, align 4
  %add = add nsw i32 %8, 1
  %mul = mul i32 %add, 4
  %call = call noalias i8* @malloc(i32 %mul)
  %9 = bitcast i8* %call to i8**
  store i8** %9, i8*** @components, align 4
  %10 = load i8*, i8** %str.addr, align 4
  %call7 = call i8* @strtok(i8* %10, i8* getelementptr inbounds ([2 x i8], [2 x i8]* @.str.5, i32 0, i32 0))
  store i8* %call7, i8** %token, align 4
  store i32 0, i32* %i, align 4
  br label %while.cond

while.cond:                                       ; preds = %while.body, %for.end
  %11 = load i8*, i8** %token, align 4
  %cmp8 = icmp ne i8* %11, null
  br i1 %cmp8, label %while.body, label %while.end

while.body:                                       ; preds = %while.cond
  %12 = load i8*, i8** %token, align 4
  %call10 = call i32 @strlen(i8* %12) #5
  %mul11 = mul i32 %call10, 1
  %call12 = call noalias i8* @malloc(i32 %mul11)
  %13 = load i8**, i8*** @components, align 4
  %14 = load i32, i32* %i, align 4
  %arrayidx13 = getelementptr inbounds i8*, i8** %13, i32 %14
  store i8* %call12, i8** %arrayidx13, align 4
  %15 = load i8**, i8*** @components, align 4
  %16 = load i32, i32* %i, align 4
  %arrayidx14 = getelementptr inbounds i8*, i8** %15, i32 %16
  %17 = load i8*, i8** %arrayidx14, align 4
  %18 = load i8*, i8** %token, align 4
  %call15 = call i8* @strcpy(i8* %17, i8* %18)
  %call16 = call i8* @strtok(i8* null, i8* getelementptr inbounds ([2 x i8], [2 x i8]* @.str.5, i32 0, i32 0))
  store i8* %call16, i8** %token, align 4
  %19 = load i32, i32* %i, align 4
  %inc17 = add nsw i32 %19, 1
  store i32 %inc17, i32* %i, align 4
  br label %while.cond

while.end:                                        ; preds = %while.cond
  ret void
}

declare i8* @strtok(i8* %0, i8* %1) #1

; Function Attrs: nounwind readonly
declare i32 @strlen(i8* %0) #3

; Function Attrs: noinline nounwind optnone
define hidden i32 @__main_argc_argv(i32 %argC, i8** %argV) #0 {
entry:
  %retval = alloca i32, align 4
  %argC.addr = alloca i32, align 4
  %argV.addr = alloca i8**, align 4
  %i = alloca i32, align 4
  %t = alloca %struct.elem*, align 4
  store i32 0, i32* %retval, align 4
  store i32 %argC, i32* %argC.addr, align 4
  store i8** %argV, i8*** %argV.addr, align 4
  %0 = load i32, i32* %argC.addr, align 4
  %cmp = icmp eq i32 %0, 1
  br i1 %cmp, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  %1 = load i8**, i8*** %argV.addr, align 4
  %arrayidx = getelementptr inbounds i8*, i8** %1, i32 0
  %2 = load i8*, i8** %arrayidx, align 4
  %call = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([95 x i8], [95 x i8]* @.str.6, i32 0, i32 0), i8* %2)
  br label %if.end10

if.else:                                          ; preds = %entry
  %3 = load i8**, i8*** %argV.addr, align 4
  %arrayidx1 = getelementptr inbounds i8*, i8** %3, i32 1
  %4 = load i8*, i8** %arrayidx1, align 4
  call void @buildStack(i8* %4)
  %call2 = call i32 @checkRPN()
  %cmp3 = icmp eq i32 %call2, 0
  br i1 %cmp3, label %if.then4, label %if.end

if.then4:                                         ; preds = %if.else
  %call5 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([15 x i8], [15 x i8]* @.str.3, i32 0, i32 0))
  store i32 0, i32* %retval, align 4
  br label %return

if.end:                                           ; preds = %if.else
  %call6 = call i8* @getNextString()
  %5 = load i8**, i8*** %argV.addr, align 4
  %arrayidx7 = getelementptr inbounds i8*, i8** %5, i32 2
  %6 = load i8*, i8** %arrayidx7, align 4
  %call8 = call %struct.elem* @buildTree(i8* %call6, i8* %6)
  store %struct.elem* %call8, %struct.elem** %t, align 4
  %call9 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([27 x i8], [27 x i8]* @.str.7, i32 0, i32 0))
  %7 = load %struct.elem*, %struct.elem** %t, align 4
  call void @inorder(%struct.elem* %7)
  br label %if.end10

if.end10:                                         ; preds = %if.end, %if.then
  store i32 0, i32* %retval, align 4
  br label %return

return:                                           ; preds = %if.end10, %if.then4
  %8 = load i32, i32* %retval, align 4
  ret i32 %8
}

attributes #0 = { noinline nounwind optnone "correctly-rounded-divide-sqrt-fp-math"="false" "disable-tail-calls"="false" "frame-pointer"="none" "less-precise-fpmad"="false" "min-legal-vector-width"="0" "no-infs-fp-math"="false" "no-jump-tables"="false" "no-nans-fp-math"="false" "no-signed-zeros-fp-math"="false" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="generic" "unsafe-fp-math"="false" "use-soft-float"="false" }
attributes #1 = { "correctly-rounded-divide-sqrt-fp-math"="false" "disable-tail-calls"="false" "frame-pointer"="none" "less-precise-fpmad"="false" "no-infs-fp-math"="false" "no-nans-fp-math"="false" "no-signed-zeros-fp-math"="false" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="generic" "unsafe-fp-math"="false" "use-soft-float"="false" }
attributes #2 = { noreturn "correctly-rounded-divide-sqrt-fp-math"="false" "disable-tail-calls"="false" "frame-pointer"="none" "less-precise-fpmad"="false" "no-infs-fp-math"="false" "no-nans-fp-math"="false" "no-signed-zeros-fp-math"="false" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="generic" "unsafe-fp-math"="false" "use-soft-float"="false" }
attributes #3 = { nounwind readonly "correctly-rounded-divide-sqrt-fp-math"="false" "disable-tail-calls"="false" "frame-pointer"="none" "less-precise-fpmad"="false" "no-infs-fp-math"="false" "no-nans-fp-math"="false" "no-signed-zeros-fp-math"="false" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="generic" "unsafe-fp-math"="false" "use-soft-float"="false" }
attributes #4 = { noreturn }
attributes #5 = { nounwind readonly }

!llvm.module.flags = !{!0}
!llvm.ident = !{!1}

!0 = !{i32 1, !"wchar_size", i32 4}
!1 = !{!"clang version 11.0.0 (https://github.com/Jacarte/llvm-project.git 0f6dea67136cc1e0b3d200eb2bb165628970c44b)"}

; extracted candidates

; *****
; For LLVM instruction:
;  %4 = load i8, i8* %arrayidx, align 1
; Looking for a replacement for:
%0:i8 = var
infer %0

; *****
; For LLVM instruction:
;  %call2 = call i32 @isOperator(i8 signext %4)
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %cmp = icmp eq i32 %call2, 1
; Looking for a replacement for:
%0:i32 = var
%1:i1 = eq 1:i32, %0
infer %1

; *****
; For LLVM instruction:
;  %8 = load i8, i8* %arrayidx5, align 1
; Looking for a replacement for:
%0:i8 = var
infer %0

; *****
; For LLVM instruction:
;  %call6 = call i32 @isOperator(i8 signext %8)
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %cmp7 = icmp eq i32 %call6, 1
; Looking for a replacement for:
%0:i32 = var
%1:i1 = eq 1:i32, %0
infer %1

; *****
; For LLVM instruction:
;  %cmp14 = icmp ne i8* %11, null
; Looking for a replacement for:
%0:i32 = var
%1:i1 = ne 0:i32, %0
infer %1
#########################################################
; exiting Souper's runOnFunction() for buildTree()

; entering Souper's runOnFunction() for checkRPN()

; ModuleID = './Parsing-RPN_to_infix_conversion.c.bc'
source_filename = "./Parsing-RPN_to_infix_conversion.c"
target datalayout = "e-m:e-p:32:32-i64:64-n32:64-S128"
target triple = "wasm32-unknown-wasi"

%struct.elem = type { [10 x i8], %struct.elem*, %struct.elem* }

@counter = hidden global i32 0, align 4
@.str = private unnamed_addr constant [2 x i8] c"(\00", align 1
@.str.1 = private unnamed_addr constant [2 x i8] c")\00", align 1
@.str.2 = private unnamed_addr constant [5 x i8] c" %s \00", align 1
@.str.3 = private unnamed_addr constant [15 x i8] c"\0AInvalid RPN !\00", align 1
@components = hidden global i8** null, align 4
@.str.4 = private unnamed_addr constant [2 x i8] c"\0A\00", align 1
@.str.5 = private unnamed_addr constant [2 x i8] c" \00", align 1
@.str.6 = private unnamed_addr constant [95 x i8] c"Usage : %s <RPN expression enclosed by quotes> <optional parameter to trace the build process>\00", align 1
@.str.7 = private unnamed_addr constant [27 x i8] c"\0AFinal infix expression : \00", align 1

; Function Attrs: noinline nounwind optnone
define hidden i32 @precedenceCheck(i8 signext %oper1, i8 signext %oper2) #0 {
entry:
  %oper1.addr = alloca i8, align 1
  %oper2.addr = alloca i8, align 1
  store i8 %oper1, i8* %oper1.addr, align 1
  store i8 %oper2, i8* %oper2.addr, align 1
  %0 = load i8, i8* %oper1.addr, align 1
  %conv = sext i8 %0 to i32
  %1 = load i8, i8* %oper2.addr, align 1
  %conv1 = sext i8 %1 to i32
  %cmp = icmp eq i32 %conv, %conv1
  br i1 %cmp, label %cond.true, label %cond.false

cond.true:                                        ; preds = %entry
  br label %cond.end61

cond.false:                                       ; preds = %entry
  %2 = load i8, i8* %oper1.addr, align 1
  %conv3 = sext i8 %2 to i32
  %cmp4 = icmp eq i32 %conv3, 94
  br i1 %cmp4, label %cond.true6, label %cond.false7

cond.true6:                                       ; preds = %cond.false
  br label %cond.end59

cond.false7:                                      ; preds = %cond.false
  %3 = load i8, i8* %oper2.addr, align 1
  %conv8 = sext i8 %3 to i32
  %cmp9 = icmp eq i32 %conv8, 94
  br i1 %cmp9, label %cond.true11, label %cond.false12

cond.true11:                                      ; preds = %cond.false7
  br label %cond.end57

cond.false12:                                     ; preds = %cond.false7
  %4 = load i8, i8* %oper1.addr, align 1
  %conv13 = sext i8 %4 to i32
  %cmp14 = icmp eq i32 %conv13, 47
  br i1 %cmp14, label %cond.true16, label %cond.false17

cond.true16:                                      ; preds = %cond.false12
  br label %cond.end55

cond.false17:                                     ; preds = %cond.false12
  %5 = load i8, i8* %oper2.addr, align 1
  %conv18 = sext i8 %5 to i32
  %cmp19 = icmp eq i32 %conv18, 47
  br i1 %cmp19, label %cond.true21, label %cond.false22

cond.true21:                                      ; preds = %cond.false17
  br label %cond.end53

cond.false22:                                     ; preds = %cond.false17
  %6 = load i8, i8* %oper1.addr, align 1
  %conv23 = sext i8 %6 to i32
  %cmp24 = icmp eq i32 %conv23, 42
  br i1 %cmp24, label %cond.true26, label %cond.false27

cond.true26:                                      ; preds = %cond.false22
  br label %cond.end51

cond.false27:                                     ; preds = %cond.false22
  %7 = load i8, i8* %oper2.addr, align 1
  %conv28 = sext i8 %7 to i32
  %cmp29 = icmp eq i32 %conv28, 42
  br i1 %cmp29, label %cond.true31, label %cond.false32

cond.true31:                                      ; preds = %cond.false27
  br label %cond.end49

cond.false32:                                     ; preds = %cond.false27
  %8 = load i8, i8* %oper1.addr, align 1
  %conv33 = sext i8 %8 to i32
  %cmp34 = icmp eq i32 %conv33, 43
  br i1 %cmp34, label %cond.true36, label %cond.false37

cond.true36:                                      ; preds = %cond.false32
  br label %cond.end47

cond.false37:                                     ; preds = %cond.false32
  %9 = load i8, i8* %oper2.addr, align 1
  %conv38 = sext i8 %9 to i32
  %cmp39 = icmp eq i32 %conv38, 43
  br i1 %cmp39, label %cond.true41, label %cond.false42

cond.true41:                                      ; preds = %cond.false37
  br label %cond.end

cond.false42:                                     ; preds = %cond.false37
  %10 = load i8, i8* %oper1.addr, align 1
  %conv43 = sext i8 %10 to i32
  %cmp44 = icmp eq i32 %conv43, 45
  %11 = zext i1 %cmp44 to i64
  %cond = select i1 %cmp44, i32 1, i32 2
  br label %cond.end

cond.end:                                         ; preds = %cond.false42, %cond.true41
  %cond46 = phi i32 [ 2, %cond.true41 ], [ %cond, %cond.false42 ]
  br label %cond.end47

cond.end47:                                       ; preds = %cond.end, %cond.true36
  %cond48 = phi i32 [ 1, %cond.true36 ], [ %cond46, %cond.end ]
  br label %cond.end49

cond.end49:                                       ; preds = %cond.end47, %cond.true31
  %cond50 = phi i32 [ 2, %cond.true31 ], [ %cond48, %cond.end47 ]
  br label %cond.end51

cond.end51:                                       ; preds = %cond.end49, %cond.true26
  %cond52 = phi i32 [ 1, %cond.true26 ], [ %cond50, %cond.end49 ]
  br label %cond.end53

cond.end53:                                       ; preds = %cond.end51, %cond.true21
  %cond54 = phi i32 [ 2, %cond.true21 ], [ %cond52, %cond.end51 ]
  br label %cond.end55

cond.end55:                                       ; preds = %cond.end53, %cond.true16
  %cond56 = phi i32 [ 1, %cond.true16 ], [ %cond54, %cond.end53 ]
  br label %cond.end57

cond.end57:                                       ; preds = %cond.end55, %cond.true11
  %cond58 = phi i32 [ 2, %cond.true11 ], [ %cond56, %cond.end55 ]
  br label %cond.end59

cond.end59:                                       ; preds = %cond.end57, %cond.true6
  %cond60 = phi i32 [ 1, %cond.true6 ], [ %cond58, %cond.end57 ]
  br label %cond.end61

cond.end61:                                       ; preds = %cond.end59, %cond.true
  %cond62 = phi i32 [ 0, %cond.true ], [ %cond60, %cond.end59 ]
  ret i32 %cond62
}

; Function Attrs: noinline nounwind optnone
define hidden i32 @isOperator(i8 signext %c) #0 {
entry:
  %c.addr = alloca i8, align 1
  store i8 %c, i8* %c.addr, align 1
  %0 = load i8, i8* %c.addr, align 1
  %conv = sext i8 %0 to i32
  %cmp = icmp eq i32 %conv, 43
  br i1 %cmp, label %lor.end, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %entry
  %1 = load i8, i8* %c.addr, align 1
  %conv2 = sext i8 %1 to i32
  %cmp3 = icmp eq i32 %conv2, 45
  br i1 %cmp3, label %lor.end, label %lor.lhs.false5

lor.lhs.false5:                                   ; preds = %lor.lhs.false
  %2 = load i8, i8* %c.addr, align 1
  %conv6 = sext i8 %2 to i32
  %cmp7 = icmp eq i32 %conv6, 42
  br i1 %cmp7, label %lor.end, label %lor.lhs.false9

lor.lhs.false9:                                   ; preds = %lor.lhs.false5
  %3 = load i8, i8* %c.addr, align 1
  %conv10 = sext i8 %3 to i32
  %cmp11 = icmp eq i32 %conv10, 47
  br i1 %cmp11, label %lor.end, label %lor.rhs

lor.rhs:                                          ; preds = %lor.lhs.false9
  %4 = load i8, i8* %c.addr, align 1
  %conv13 = sext i8 %4 to i32
  %cmp14 = icmp eq i32 %conv13, 94
  br label %lor.end

lor.end:                                          ; preds = %lor.rhs, %lor.lhs.false9, %lor.lhs.false5, %lor.lhs.false, %entry
  %5 = phi i1 [ true, %lor.lhs.false9 ], [ true, %lor.lhs.false5 ], [ true, %lor.lhs.false ], [ true, %entry ], [ %cmp14, %lor.rhs ]
  %lor.ext = zext i1 %5 to i32
  ret i32 %lor.ext
}

; Function Attrs: noinline nounwind optnone
define hidden void @inorder(%struct.elem* %t) #0 {
entry:
  %t.addr = alloca %struct.elem*, align 4
  store %struct.elem* %t, %struct.elem** %t.addr, align 4
  %0 = load %struct.elem*, %struct.elem** %t.addr, align 4
  %cmp = icmp ne %struct.elem* %0, null
  br i1 %cmp, label %if.then, label %if.end71

if.then:                                          ; preds = %entry
  %1 = load %struct.elem*, %struct.elem** %t.addr, align 4
  %left = getelementptr inbounds %struct.elem, %struct.elem* %1, i32 0, i32 1
  %2 = load %struct.elem*, %struct.elem** %left, align 4
  %cmp1 = icmp ne %struct.elem* %2, null
  br i1 %cmp1, label %land.lhs.true, label %if.else

land.lhs.true:                                    ; preds = %if.then
  %3 = load %struct.elem*, %struct.elem** %t.addr, align 4
  %left2 = getelementptr inbounds %struct.elem, %struct.elem* %3, i32 0, i32 1
  %4 = load %struct.elem*, %struct.elem** %left2, align 4
  %data = getelementptr inbounds %struct.elem, %struct.elem* %4, i32 0, i32 0
  %arrayidx = getelementptr inbounds [10 x i8], [10 x i8]* %data, i32 0, i32 0
  %5 = load i8, i8* %arrayidx, align 4
  %call = call i32 @isOperator(i8 signext %5)
  %cmp3 = icmp eq i32 %call, 1
  br i1 %cmp3, label %land.lhs.true4, label %if.else

land.lhs.true4:                                   ; preds = %land.lhs.true
  %6 = load %struct.elem*, %struct.elem** %t.addr, align 4
  %data5 = getelementptr inbounds %struct.elem, %struct.elem* %6, i32 0, i32 0
  %arrayidx6 = getelementptr inbounds [10 x i8], [10 x i8]* %data5, i32 0, i32 0
  %7 = load i8, i8* %arrayidx6, align 4
  %8 = load %struct.elem*, %struct.elem** %t.addr, align 4
  %left7 = getelementptr inbounds %struct.elem, %struct.elem* %8, i32 0, i32 1
  %9 = load %struct.elem*, %struct.elem** %left7, align 4
  %data8 = getelementptr inbounds %struct.elem, %struct.elem* %9, i32 0, i32 0
  %arrayidx9 = getelementptr inbounds [10 x i8], [10 x i8]* %data8, i32 0, i32 0
  %10 = load i8, i8* %arrayidx9, align 4
  %call10 = call i32 @precedenceCheck(i8 signext %7, i8 signext %10)
  %cmp11 = icmp eq i32 %call10, 1
  br i1 %cmp11, label %if.then24, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %land.lhs.true4
  %11 = load %struct.elem*, %struct.elem** %t.addr, align 4
  %data12 = getelementptr inbounds %struct.elem, %struct.elem* %11, i32 0, i32 0
  %arrayidx13 = getelementptr inbounds [10 x i8], [10 x i8]* %data12, i32 0, i32 0
  %12 = load i8, i8* %arrayidx13, align 4
  %13 = load %struct.elem*, %struct.elem** %t.addr, align 4
  %left14 = getelementptr inbounds %struct.elem, %struct.elem* %13, i32 0, i32 1
  %14 = load %struct.elem*, %struct.elem** %left14, align 4
  %data15 = getelementptr inbounds %struct.elem, %struct.elem* %14, i32 0, i32 0
  %arrayidx16 = getelementptr inbounds [10 x i8], [10 x i8]* %data15, i32 0, i32 0
  %15 = load i8, i8* %arrayidx16, align 4
  %call17 = call i32 @precedenceCheck(i8 signext %12, i8 signext %15)
  %cmp18 = icmp eq i32 %call17, 0
  br i1 %cmp18, label %land.lhs.true19, label %if.else

land.lhs.true19:                                  ; preds = %lor.lhs.false
  %16 = load %struct.elem*, %struct.elem** %t.addr, align 4
  %data20 = getelementptr inbounds %struct.elem, %struct.elem* %16, i32 0, i32 0
  %arrayidx21 = getelementptr inbounds [10 x i8], [10 x i8]* %data20, i32 0, i32 0
  %17 = load i8, i8* %arrayidx21, align 4
  %conv = sext i8 %17 to i32
  %cmp22 = icmp eq i32 %conv, 94
  br i1 %cmp22, label %if.then24, label %if.else

if.then24:                                        ; preds = %land.lhs.true19, %land.lhs.true4
  %call25 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([2 x i8], [2 x i8]* @.str, i32 0, i32 0))
  %18 = load %struct.elem*, %struct.elem** %t.addr, align 4
  %left26 = getelementptr inbounds %struct.elem, %struct.elem* %18, i32 0, i32 1
  %19 = load %struct.elem*, %struct.elem** %left26, align 4
  call void @inorder(%struct.elem* %19)
  %call27 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([2 x i8], [2 x i8]* @.str.1, i32 0, i32 0))
  br label %if.end

if.else:                                          ; preds = %land.lhs.true19, %lor.lhs.false, %land.lhs.true, %if.then
  %20 = load %struct.elem*, %struct.elem** %t.addr, align 4
  %left28 = getelementptr inbounds %struct.elem, %struct.elem* %20, i32 0, i32 1
  %21 = load %struct.elem*, %struct.elem** %left28, align 4
  call void @inorder(%struct.elem* %21)
  br label %if.end

if.end:                                           ; preds = %if.else, %if.then24
  %22 = load %struct.elem*, %struct.elem** %t.addr, align 4
  %data29 = getelementptr inbounds %struct.elem, %struct.elem* %22, i32 0, i32 0
  %arraydecay = getelementptr inbounds [10 x i8], [10 x i8]* %data29, i32 0, i32 0
  %call30 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.2, i32 0, i32 0), i8* %arraydecay)
  %23 = load %struct.elem*, %struct.elem** %t.addr, align 4
  %right = getelementptr inbounds %struct.elem, %struct.elem* %23, i32 0, i32 2
  %24 = load %struct.elem*, %struct.elem** %right, align 4
  %cmp31 = icmp ne %struct.elem* %24, null
  br i1 %cmp31, label %land.lhs.true33, label %if.else68

land.lhs.true33:                                  ; preds = %if.end
  %25 = load %struct.elem*, %struct.elem** %t.addr, align 4
  %right34 = getelementptr inbounds %struct.elem, %struct.elem* %25, i32 0, i32 2
  %26 = load %struct.elem*, %struct.elem** %right34, align 4
  %data35 = getelementptr inbounds %struct.elem, %struct.elem* %26, i32 0, i32 0
  %arrayidx36 = getelementptr inbounds [10 x i8], [10 x i8]* %data35, i32 0, i32 0
  %27 = load i8, i8* %arrayidx36, align 4
  %call37 = call i32 @isOperator(i8 signext %27)
  %cmp38 = icmp eq i32 %call37, 1
  br i1 %cmp38, label %land.lhs.true40, label %if.else68

land.lhs.true40:                                  ; preds = %land.lhs.true33
  %28 = load %struct.elem*, %struct.elem** %t.addr, align 4
  %data41 = getelementptr inbounds %struct.elem, %struct.elem* %28, i32 0, i32 0
  %arrayidx42 = getelementptr inbounds [10 x i8], [10 x i8]* %data41, i32 0, i32 0
  %29 = load i8, i8* %arrayidx42, align 4
  %30 = load %struct.elem*, %struct.elem** %t.addr, align 4
  %right43 = getelementptr inbounds %struct.elem, %struct.elem* %30, i32 0, i32 2
  %31 = load %struct.elem*, %struct.elem** %right43, align 4
  %data44 = getelementptr inbounds %struct.elem, %struct.elem* %31, i32 0, i32 0
  %arrayidx45 = getelementptr inbounds [10 x i8], [10 x i8]* %data44, i32 0, i32 0
  %32 = load i8, i8* %arrayidx45, align 4
  %call46 = call i32 @precedenceCheck(i8 signext %29, i8 signext %32)
  %cmp47 = icmp eq i32 %call46, 1
  br i1 %cmp47, label %if.then64, label %lor.lhs.false49

lor.lhs.false49:                                  ; preds = %land.lhs.true40
  %33 = load %struct.elem*, %struct.elem** %t.addr, align 4
  %data50 = getelementptr inbounds %struct.elem, %struct.elem* %33, i32 0, i32 0
  %arrayidx51 = getelementptr inbounds [10 x i8], [10 x i8]* %data50, i32 0, i32 0
  %34 = load i8, i8* %arrayidx51, align 4
  %35 = load %struct.elem*, %struct.elem** %t.addr, align 4
  %right52 = getelementptr inbounds %struct.elem, %struct.elem* %35, i32 0, i32 2
  %36 = load %struct.elem*, %struct.elem** %right52, align 4
  %data53 = getelementptr inbounds %struct.elem, %struct.elem* %36, i32 0, i32 0
  %arrayidx54 = getelementptr inbounds [10 x i8], [10 x i8]* %data53, i32 0, i32 0
  %37 = load i8, i8* %arrayidx54, align 4
  %call55 = call i32 @precedenceCheck(i8 signext %34, i8 signext %37)
  %cmp56 = icmp eq i32 %call55, 0
  br i1 %cmp56, label %land.lhs.true58, label %if.else68

land.lhs.true58:                                  ; preds = %lor.lhs.false49
  %38 = load %struct.elem*, %struct.elem** %t.addr, align 4
  %data59 = getelementptr inbounds %struct.elem, %struct.elem* %38, i32 0, i32 0
  %arrayidx60 = getelementptr inbounds [10 x i8], [10 x i8]* %data59, i32 0, i32 0
  %39 = load i8, i8* %arrayidx60, align 4
  %conv61 = sext i8 %39 to i32
  %cmp62 = icmp ne i32 %conv61, 94
  br i1 %cmp62, label %if.then64, label %if.else68

if.then64:                                        ; preds = %land.lhs.true58, %land.lhs.true40
  %call65 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([2 x i8], [2 x i8]* @.str, i32 0, i32 0))
  %40 = load %struct.elem*, %struct.elem** %t.addr, align 4
  %right66 = getelementptr inbounds %struct.elem, %struct.elem* %40, i32 0, i32 2
  %41 = load %struct.elem*, %struct.elem** %right66, align 4
  call void @inorder(%struct.elem* %41)
  %call67 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([2 x i8], [2 x i8]* @.str.1, i32 0, i32 0))
  br label %if.end70

if.else68:                                        ; preds = %land.lhs.true58, %lor.lhs.false49, %land.lhs.true33, %if.end
  %42 = load %struct.elem*, %struct.elem** %t.addr, align 4
  %right69 = getelementptr inbounds %struct.elem, %struct.elem* %42, i32 0, i32 2
  %43 = load %struct.elem*, %struct.elem** %right69, align 4
  call void @inorder(%struct.elem* %43)
  br label %if.end70

if.end70:                                         ; preds = %if.else68, %if.then64
  br label %if.end71

if.end71:                                         ; preds = %if.end70, %entry
  ret void
}

declare i32 @printf(i8* %0, ...) #1

; Function Attrs: noinline nounwind optnone
define hidden i8* @getNextString() #0 {
entry:
  %0 = load i32, i32* @counter, align 4
  %cmp = icmp slt i32 %0, 0
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %call = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([15 x i8], [15 x i8]* @.str.3, i32 0, i32 0))
  call void @exit(i32 0) #4
  unreachable

if.end:                                           ; preds = %entry
  %1 = load i8**, i8*** @components, align 4
  %2 = load i32, i32* @counter, align 4
  %dec = add nsw i32 %2, -1
  store i32 %dec, i32* @counter, align 4
  %arrayidx = getelementptr inbounds i8*, i8** %1, i32 %2
  %3 = load i8*, i8** %arrayidx, align 4
  ret i8* %3
}

; Function Attrs: noreturn
declare void @exit(i32 %0) #2

; Function Attrs: noinline nounwind optnone
define hidden %struct.elem* @buildTree(i8* %obj, i8* %trace) #0 {
entry:
  %obj.addr = alloca i8*, align 4
  %trace.addr = alloca i8*, align 4
  %t = alloca %struct.elem*, align 4
  store i8* %obj, i8** %obj.addr, align 4
  store i8* %trace, i8** %trace.addr, align 4
  %call = call noalias i8* @malloc(i32 20)
  %0 = bitcast i8* %call to %struct.elem*
  store %struct.elem* %0, %struct.elem** %t, align 4
  %1 = load %struct.elem*, %struct.elem** %t, align 4
  %data = getelementptr inbounds %struct.elem, %struct.elem* %1, i32 0, i32 0
  %arraydecay = getelementptr inbounds [10 x i8], [10 x i8]* %data, i32 0, i32 0
  %2 = load i8*, i8** %obj.addr, align 4
  %call1 = call i8* @strcpy(i8* %arraydecay, i8* %2)
  %3 = load i8*, i8** %obj.addr, align 4
  %arrayidx = getelementptr inbounds i8, i8* %3, i32 0
  %4 = load i8, i8* %arrayidx, align 1
  %call2 = call i32 @isOperator(i8 signext %4)
  %cmp = icmp eq i32 %call2, 1
  br i1 %cmp, label %cond.true, label %cond.false

cond.true:                                        ; preds = %entry
  %call3 = call i8* @getNextString()
  %5 = load i8*, i8** %trace.addr, align 4
  %call4 = call %struct.elem* @buildTree(i8* %call3, i8* %5)
  br label %cond.end

cond.false:                                       ; preds = %entry
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi %struct.elem* [ %call4, %cond.true ], [ null, %cond.false ]
  %6 = load %struct.elem*, %struct.elem** %t, align 4
  %right = getelementptr inbounds %struct.elem, %struct.elem* %6, i32 0, i32 2
  store %struct.elem* %cond, %struct.elem** %right, align 4
  %7 = load i8*, i8** %obj.addr, align 4
  %arrayidx5 = getelementptr inbounds i8, i8* %7, i32 0
  %8 = load i8, i8* %arrayidx5, align 1
  %call6 = call i32 @isOperator(i8 signext %8)
  %cmp7 = icmp eq i32 %call6, 1
  br i1 %cmp7, label %cond.true8, label %cond.false11

cond.true8:                                       ; preds = %cond.end
  %call9 = call i8* @getNextString()
  %9 = load i8*, i8** %trace.addr, align 4
  %call10 = call %struct.elem* @buildTree(i8* %call9, i8* %9)
  br label %cond.end12

cond.false11:                                     ; preds = %cond.end
  br label %cond.end12

cond.end12:                                       ; preds = %cond.false11, %cond.true8
  %cond13 = phi %struct.elem* [ %call10, %cond.true8 ], [ null, %cond.false11 ]
  %10 = load %struct.elem*, %struct.elem** %t, align 4
  %left = getelementptr inbounds %struct.elem, %struct.elem* %10, i32 0, i32 1
  store %struct.elem* %cond13, %struct.elem** %left, align 4
  %11 = load i8*, i8** %trace.addr, align 4
  %cmp14 = icmp ne i8* %11, null
  br i1 %cmp14, label %if.then, label %if.end

if.then:                                          ; preds = %cond.end12
  %call15 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([2 x i8], [2 x i8]* @.str.4, i32 0, i32 0))
  %12 = load %struct.elem*, %struct.elem** %t, align 4
  call void @inorder(%struct.elem* %12)
  br label %if.end

if.end:                                           ; preds = %if.then, %cond.end12
  %13 = load %struct.elem*, %struct.elem** %t, align 4
  ret %struct.elem* %13
}

declare noalias i8* @malloc(i32 %0) #1

declare i8* @strcpy(i8* %0, i8* %1) #1

; Function Attrs: noinline nounwind optnone
define hidden i32 @checkRPN() #0 {
entry:
  %retval = alloca i32, align 4
  %i = alloca i32, align 4
  %operSum = alloca i32, align 4
  %numberSum = alloca i32, align 4
  store i32 0, i32* %operSum, align 4
  store i32 0, i32* %numberSum, align 4
  %0 = load i8**, i8*** @components, align 4
  %1 = load i32, i32* @counter, align 4
  %arrayidx = getelementptr inbounds i8*, i8** %0, i32 %1
  %2 = load i8*, i8** %arrayidx, align 4
  %arrayidx1 = getelementptr inbounds i8, i8* %2, i32 0
  %3 = load i8, i8* %arrayidx1, align 1
  %call = call i32 @isOperator(i8 signext %3)
  %cmp = icmp eq i32 %call, 0
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  store i32 0, i32* %retval, align 4
  br label %return

if.end:                                           ; preds = %entry
  store i32 0, i32* %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.end
  %4 = load i32, i32* %i, align 4
  %5 = load i32, i32* @counter, align 4
  %cmp2 = icmp sle i32 %4, %5
  br i1 %cmp2, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %6 = load i8**, i8*** @components, align 4
  %7 = load i32, i32* %i, align 4
  %arrayidx3 = getelementptr inbounds i8*, i8** %6, i32 %7
  %8 = load i8*, i8** %arrayidx3, align 4
  %arrayidx4 = getelementptr inbounds i8, i8* %8, i32 0
  %9 = load i8, i8* %arrayidx4, align 1
  %call5 = call i32 @isOperator(i8 signext %9)
  %cmp6 = icmp eq i32 %call5, 1
  br i1 %cmp6, label %cond.true, label %cond.false

cond.true:                                        ; preds = %for.body
  %10 = load i32, i32* %operSum, align 4
  %inc = add nsw i32 %10, 1
  store i32 %inc, i32* %operSum, align 4
  br label %cond.end

cond.false:                                       ; preds = %for.body
  %11 = load i32, i32* %numberSum, align 4
  %inc7 = add nsw i32 %11, 1
  store i32 %inc7, i32* %numberSum, align 4
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi i32 [ %10, %cond.true ], [ %11, %cond.false ]
  br label %for.inc

for.inc:                                          ; preds = %cond.end
  %12 = load i32, i32* %i, align 4
  %inc8 = add nsw i32 %12, 1
  store i32 %inc8, i32* %i, align 4
  br label %for.cond

for.end:                                          ; preds = %for.cond
  %13 = load i32, i32* %numberSum, align 4
  %14 = load i32, i32* %operSum, align 4
  %sub = sub nsw i32 %13, %14
  %cmp9 = icmp eq i32 %sub, 1
  %conv = zext i1 %cmp9 to i32
  store i32 %conv, i32* %retval, align 4
  br label %return

return:                                           ; preds = %for.end, %if.then
  %15 = load i32, i32* %retval, align 4
  ret i32 %15
}

; Function Attrs: noinline nounwind optnone
define hidden void @buildStack(i8* %str) #0 {
entry:
  %str.addr = alloca i8*, align 4
  %i = alloca i32, align 4
  %token = alloca i8*, align 4
  store i8* %str, i8** %str.addr, align 4
  store i32 0, i32* %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %0 = load i8*, i8** %str.addr, align 4
  %1 = load i32, i32* %i, align 4
  %arrayidx = getelementptr inbounds i8, i8* %0, i32 %1
  %2 = load i8, i8* %arrayidx, align 1
  %conv = sext i8 %2 to i32
  %cmp = icmp ne i32 %conv, 0
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %3 = load i8*, i8** %str.addr, align 4
  %4 = load i32, i32* %i, align 4
  %arrayidx2 = getelementptr inbounds i8, i8* %3, i32 %4
  %5 = load i8, i8* %arrayidx2, align 1
  %conv3 = sext i8 %5 to i32
  %cmp4 = icmp eq i32 %conv3, 32
  br i1 %cmp4, label %if.then, label %if.end

if.then:                                          ; preds = %for.body
  %6 = load i32, i32* @counter, align 4
  %inc = add nsw i32 %6, 1
  store i32 %inc, i32* @counter, align 4
  br label %if.end

if.end:                                           ; preds = %if.then, %for.body
  br label %for.inc

for.inc:                                          ; preds = %if.end
  %7 = load i32, i32* %i, align 4
  %inc6 = add nsw i32 %7, 1
  store i32 %inc6, i32* %i, align 4
  br label %for.cond

for.end:                                          ; preds = %for.cond
  %8 = load i32, i32* @counter, align 4
  %add = add nsw i32 %8, 1
  %mul = mul i32 %add, 4
  %call = call noalias i8* @malloc(i32 %mul)
  %9 = bitcast i8* %call to i8**
  store i8** %9, i8*** @components, align 4
  %10 = load i8*, i8** %str.addr, align 4
  %call7 = call i8* @strtok(i8* %10, i8* getelementptr inbounds ([2 x i8], [2 x i8]* @.str.5, i32 0, i32 0))
  store i8* %call7, i8** %token, align 4
  store i32 0, i32* %i, align 4
  br label %while.cond

while.cond:                                       ; preds = %while.body, %for.end
  %11 = load i8*, i8** %token, align 4
  %cmp8 = icmp ne i8* %11, null
  br i1 %cmp8, label %while.body, label %while.end

while.body:                                       ; preds = %while.cond
  %12 = load i8*, i8** %token, align 4
  %call10 = call i32 @strlen(i8* %12) #5
  %mul11 = mul i32 %call10, 1
  %call12 = call noalias i8* @malloc(i32 %mul11)
  %13 = load i8**, i8*** @components, align 4
  %14 = load i32, i32* %i, align 4
  %arrayidx13 = getelementptr inbounds i8*, i8** %13, i32 %14
  store i8* %call12, i8** %arrayidx13, align 4
  %15 = load i8**, i8*** @components, align 4
  %16 = load i32, i32* %i, align 4
  %arrayidx14 = getelementptr inbounds i8*, i8** %15, i32 %16
  %17 = load i8*, i8** %arrayidx14, align 4
  %18 = load i8*, i8** %token, align 4
  %call15 = call i8* @strcpy(i8* %17, i8* %18)
  %call16 = call i8* @strtok(i8* null, i8* getelementptr inbounds ([2 x i8], [2 x i8]* @.str.5, i32 0, i32 0))
  store i8* %call16, i8** %token, align 4
  %19 = load i32, i32* %i, align 4
  %inc17 = add nsw i32 %19, 1
  store i32 %inc17, i32* %i, align 4
  br label %while.cond

while.end:                                        ; preds = %while.cond
  ret void
}

declare i8* @strtok(i8* %0, i8* %1) #1

; Function Attrs: nounwind readonly
declare i32 @strlen(i8* %0) #3

; Function Attrs: noinline nounwind optnone
define hidden i32 @__main_argc_argv(i32 %argC, i8** %argV) #0 {
entry:
  %retval = alloca i32, align 4
  %argC.addr = alloca i32, align 4
  %argV.addr = alloca i8**, align 4
  %i = alloca i32, align 4
  %t = alloca %struct.elem*, align 4
  store i32 0, i32* %retval, align 4
  store i32 %argC, i32* %argC.addr, align 4
  store i8** %argV, i8*** %argV.addr, align 4
  %0 = load i32, i32* %argC.addr, align 4
  %cmp = icmp eq i32 %0, 1
  br i1 %cmp, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  %1 = load i8**, i8*** %argV.addr, align 4
  %arrayidx = getelementptr inbounds i8*, i8** %1, i32 0
  %2 = load i8*, i8** %arrayidx, align 4
  %call = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([95 x i8], [95 x i8]* @.str.6, i32 0, i32 0), i8* %2)
  br label %if.end10

if.else:                                          ; preds = %entry
  %3 = load i8**, i8*** %argV.addr, align 4
  %arrayidx1 = getelementptr inbounds i8*, i8** %3, i32 1
  %4 = load i8*, i8** %arrayidx1, align 4
  call void @buildStack(i8* %4)
  %call2 = call i32 @checkRPN()
  %cmp3 = icmp eq i32 %call2, 0
  br i1 %cmp3, label %if.then4, label %if.end

if.then4:                                         ; preds = %if.else
  %call5 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([15 x i8], [15 x i8]* @.str.3, i32 0, i32 0))
  store i32 0, i32* %retval, align 4
  br label %return

if.end:                                           ; preds = %if.else
  %call6 = call i8* @getNextString()
  %5 = load i8**, i8*** %argV.addr, align 4
  %arrayidx7 = getelementptr inbounds i8*, i8** %5, i32 2
  %6 = load i8*, i8** %arrayidx7, align 4
  %call8 = call %struct.elem* @buildTree(i8* %call6, i8* %6)
  store %struct.elem* %call8, %struct.elem** %t, align 4
  %call9 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([27 x i8], [27 x i8]* @.str.7, i32 0, i32 0))
  %7 = load %struct.elem*, %struct.elem** %t, align 4
  call void @inorder(%struct.elem* %7)
  br label %if.end10

if.end10:                                         ; preds = %if.end, %if.then
  store i32 0, i32* %retval, align 4
  br label %return

return:                                           ; preds = %if.end10, %if.then4
  %8 = load i32, i32* %retval, align 4
  ret i32 %8
}

attributes #0 = { noinline nounwind optnone "correctly-rounded-divide-sqrt-fp-math"="false" "disable-tail-calls"="false" "frame-pointer"="none" "less-precise-fpmad"="false" "min-legal-vector-width"="0" "no-infs-fp-math"="false" "no-jump-tables"="false" "no-nans-fp-math"="false" "no-signed-zeros-fp-math"="false" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="generic" "unsafe-fp-math"="false" "use-soft-float"="false" }
attributes #1 = { "correctly-rounded-divide-sqrt-fp-math"="false" "disable-tail-calls"="false" "frame-pointer"="none" "less-precise-fpmad"="false" "no-infs-fp-math"="false" "no-nans-fp-math"="false" "no-signed-zeros-fp-math"="false" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="generic" "unsafe-fp-math"="false" "use-soft-float"="false" }
attributes #2 = { noreturn "correctly-rounded-divide-sqrt-fp-math"="false" "disable-tail-calls"="false" "frame-pointer"="none" "less-precise-fpmad"="false" "no-infs-fp-math"="false" "no-nans-fp-math"="false" "no-signed-zeros-fp-math"="false" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="generic" "unsafe-fp-math"="false" "use-soft-float"="false" }
attributes #3 = { nounwind readonly "correctly-rounded-divide-sqrt-fp-math"="false" "disable-tail-calls"="false" "frame-pointer"="none" "less-precise-fpmad"="false" "no-infs-fp-math"="false" "no-nans-fp-math"="false" "no-signed-zeros-fp-math"="false" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="generic" "unsafe-fp-math"="false" "use-soft-float"="false" }
attributes #4 = { noreturn }
attributes #5 = { nounwind readonly }

!llvm.module.flags = !{!0}
!llvm.ident = !{!1}

!0 = !{i32 1, !"wchar_size", i32 4}
!1 = !{!"clang version 11.0.0 (https://github.com/Jacarte/llvm-project.git 0f6dea67136cc1e0b3d200eb2bb165628970c44b)"}

; extracted candidates

; *****
; For LLVM instruction:
;  %1 = load i32, i32* @counter, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %3 = load i8, i8* %arrayidx1, align 1
; Looking for a replacement for:
%0:i8 = var
infer %0

; *****
; For LLVM instruction:
;  %call = call i32 @isOperator(i8 signext %3)
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %cmp = icmp eq i32 %call, 0
; Looking for a replacement for:
%0:i32 = var
%1:i1 = eq 0:i32, %0
infer %1

; *****
; For LLVM instruction:
;  %4 = load i32, i32* %i, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %5 = load i32, i32* @counter, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %cmp2 = icmp sle i32 %4, %5
; Looking for a replacement for:
%0:i32 = var
%1:i32 = var
%2:i1 = sle %0, %1
infer %2

; *****
; For LLVM instruction:
;  %7 = load i32, i32* %i, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %9 = load i8, i8* %arrayidx4, align 1
; Looking for a replacement for:
%0:i8 = var
infer %0

; *****
; For LLVM instruction:
;  %call5 = call i32 @isOperator(i8 signext %9)
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %cmp6 = icmp eq i32 %call5, 1
; Looking for a replacement for:
%0:i32 = var
%1:i1 = eq 1:i32, %0
infer %1

; *****
; For LLVM instruction:
;  %10 = load i32, i32* %operSum, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %inc = add nsw i32 %10, 1
; Looking for a replacement for:
%0:i32 = var
%1:i32 = addnsw 1:i32, %0
infer %1

; *****
; For LLVM instruction:
;  %11 = load i32, i32* %numberSum, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %inc7 = add nsw i32 %11, 1
; Looking for a replacement for:
%0:i32 = var
%1:i32 = addnsw 1:i32, %0
infer %1

; *****
; For LLVM instruction:
;  %12 = load i32, i32* %i, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %inc8 = add nsw i32 %12, 1
; Looking for a replacement for:
%0:i32 = var
%1:i32 = addnsw 1:i32, %0
infer %1

; *****
; For LLVM instruction:
;  %13 = load i32, i32* %numberSum, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %14 = load i32, i32* %operSum, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %sub = sub nsw i32 %13, %14
; Looking for a replacement for:
%0:i32 = var
%1:i32 = var
%2:i32 = subnsw %0, %1
infer %2

; *****
; For LLVM instruction:
;  %cmp9 = icmp eq i32 %sub, 1
; Looking for a replacement for:
%0:i32 = var
%1:i32 = var
%2:i32 = subnsw %0, %1
%3:i1 = eq 1:i32, %2
infer %3

; *****
; For LLVM instruction:
;  %conv = zext i1 %cmp9 to i32
; Looking for a replacement for:
%0:i32 = var
%1:i32 = var
%2:i32 = subnsw %0, %1
%3:i1 = eq 1:i32, %2
%4:i32 = zext %3
infer %4

; *****
; For LLVM instruction:
;  %15 = load i32, i32* %retval, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0
got 3 candidates from LHS

-------------------------------------------------
%0:i32 = var
%1:i32 = var
%2:i1 = sle %0, %1
infer %2


--------------------------------
guess 0

%0:i1 = var ; reservedconst_1

Cost = 0
first query is SAT, returning the model:
reservedconst_1: -1
0 th attempt: second query is SAT-- constant doesn't work
first query is SAT, returning the model:
reservedconst_1: 0
1 th attempt: second query is SAT-- constant doesn't work
first query is UNSAT-- no more guesses
Dataflow Pruned 0/0
There are 1 Guesses
There are 0 RHSs before deduplication
There are 0 RHSs after deduplication
got 2 candidates from LHS

-------------------------------------------------
%0:i32 = var
%1:i32 = addnsw 1:i32, %0
infer %1


--------------------------------
guess 0

%0:i32 = var ; reservedconst_1

Cost = 0
first query is SAT, returning the model:
reservedconst_1: 1
0 th attempt: second query is SAT-- constant doesn't work
first query is SAT, returning the model:
reservedconst_1: 268435457
1 th attempt: second query is SAT-- constant doesn't work
first query is UNSAT-- no more guesses

--------------------------------
guess 1

%0:i32 = var

Cost = 0
second query is SAT-- constant doesn't work
Dataflow Pruned 0/0
There are 2 Guesses
There are 0 RHSs before deduplication
There are 0 RHSs after deduplication
got 3 candidates from LHS

-------------------------------------------------
%0:i32 = var
%1:i32 = var
%2:i32 = subnsw %0, %1
infer %2


--------------------------------
guess 0

%0:i32 = var ; reservedconst_1

Cost = 0
first query is SAT, returning the model:
reservedconst_1: 0
0 th attempt: second query is SAT-- constant doesn't work
first query is SAT, returning the model:
reservedconst_1: 2147418112
1 th attempt: second query is SAT-- constant doesn't work
first query is UNSAT-- no more guesses

--------------------------------
guess 1

%0:i32 = var

Cost = 0
second query is SAT-- constant doesn't work

--------------------------------
guess 2

%0:i32 = var

Cost = 0
second query is SAT-- constant doesn't work
Dataflow Pruned 0/0
There are 3 Guesses
There are 0 RHSs before deduplication
There are 0 RHSs after deduplication
got 4 candidates from LHS

-------------------------------------------------
%0:i32 = var
%1:i32 = var
%2:i32 = subnsw %0, %1
%3:i1 = eq 1:i32, %2
infer %3


--------------------------------
guess 0

%0:i1 = var ; reservedconst_1

Cost = 0
first query is SAT, returning the model:
reservedconst_1: 0
0 th attempt: second query is SAT-- constant doesn't work
first query is SAT, returning the model:
reservedconst_1: -1
1 th attempt: second query is SAT-- constant doesn't work
first query is UNSAT-- no more guesses
Dataflow Pruned 0/0
There are 1 Guesses
There are 0 RHSs before deduplication
There are 0 RHSs after deduplication
got 5 candidates from LHS

-------------------------------------------------
%0:i32 = var
%1:i32 = var
%2:i32 = subnsw %0, %1
%3:i1 = eq 1:i32, %2
%4:i32 = zext %3
infer %4


--------------------------------
guess 0

%0:i32 = var ; reservedconst_1

Cost = 0
first query is SAT, returning the model:
reservedconst_1: 0
0 th attempt: second query is SAT-- constant doesn't work
first query is SAT, returning the model:
reservedconst_1: 1
1 th attempt: second query is SAT-- constant doesn't work
first query is UNSAT-- no more guesses

--------------------------------
guess 1

%0:i32 = var

Cost = 0
second query is SAT-- constant doesn't work

--------------------------------
guess 2

%0:i32 = var

Cost = 0
second query is SAT-- constant doesn't work

--------------------------------
guess 3

%0:i32 = var
%1:i32 = var
%2:i32 = subnsw %0, %1

Cost = 1
second query is SAT-- constant doesn't work
Dataflow Pruned 0/0
There are 4 Guesses
There are 0 RHSs before deduplication
There are 0 RHSs after deduplication
#########################################################
; exiting Souper's runOnFunction() for checkRPN()

; entering Souper's runOnFunction() for buildStack()

; ModuleID = './Parsing-RPN_to_infix_conversion.c.bc'
source_filename = "./Parsing-RPN_to_infix_conversion.c"
target datalayout = "e-m:e-p:32:32-i64:64-n32:64-S128"
target triple = "wasm32-unknown-wasi"

%struct.elem = type { [10 x i8], %struct.elem*, %struct.elem* }

@counter = hidden global i32 0, align 4
@.str = private unnamed_addr constant [2 x i8] c"(\00", align 1
@.str.1 = private unnamed_addr constant [2 x i8] c")\00", align 1
@.str.2 = private unnamed_addr constant [5 x i8] c" %s \00", align 1
@.str.3 = private unnamed_addr constant [15 x i8] c"\0AInvalid RPN !\00", align 1
@components = hidden global i8** null, align 4
@.str.4 = private unnamed_addr constant [2 x i8] c"\0A\00", align 1
@.str.5 = private unnamed_addr constant [2 x i8] c" \00", align 1
@.str.6 = private unnamed_addr constant [95 x i8] c"Usage : %s <RPN expression enclosed by quotes> <optional parameter to trace the build process>\00", align 1
@.str.7 = private unnamed_addr constant [27 x i8] c"\0AFinal infix expression : \00", align 1

; Function Attrs: noinline nounwind optnone
define hidden i32 @precedenceCheck(i8 signext %oper1, i8 signext %oper2) #0 {
entry:
  %oper1.addr = alloca i8, align 1
  %oper2.addr = alloca i8, align 1
  store i8 %oper1, i8* %oper1.addr, align 1
  store i8 %oper2, i8* %oper2.addr, align 1
  %0 = load i8, i8* %oper1.addr, align 1
  %conv = sext i8 %0 to i32
  %1 = load i8, i8* %oper2.addr, align 1
  %conv1 = sext i8 %1 to i32
  %cmp = icmp eq i32 %conv, %conv1
  br i1 %cmp, label %cond.true, label %cond.false

cond.true:                                        ; preds = %entry
  br label %cond.end61

cond.false:                                       ; preds = %entry
  %2 = load i8, i8* %oper1.addr, align 1
  %conv3 = sext i8 %2 to i32
  %cmp4 = icmp eq i32 %conv3, 94
  br i1 %cmp4, label %cond.true6, label %cond.false7

cond.true6:                                       ; preds = %cond.false
  br label %cond.end59

cond.false7:                                      ; preds = %cond.false
  %3 = load i8, i8* %oper2.addr, align 1
  %conv8 = sext i8 %3 to i32
  %cmp9 = icmp eq i32 %conv8, 94
  br i1 %cmp9, label %cond.true11, label %cond.false12

cond.true11:                                      ; preds = %cond.false7
  br label %cond.end57

cond.false12:                                     ; preds = %cond.false7
  %4 = load i8, i8* %oper1.addr, align 1
  %conv13 = sext i8 %4 to i32
  %cmp14 = icmp eq i32 %conv13, 47
  br i1 %cmp14, label %cond.true16, label %cond.false17

cond.true16:                                      ; preds = %cond.false12
  br label %cond.end55

cond.false17:                                     ; preds = %cond.false12
  %5 = load i8, i8* %oper2.addr, align 1
  %conv18 = sext i8 %5 to i32
  %cmp19 = icmp eq i32 %conv18, 47
  br i1 %cmp19, label %cond.true21, label %cond.false22

cond.true21:                                      ; preds = %cond.false17
  br label %cond.end53

cond.false22:                                     ; preds = %cond.false17
  %6 = load i8, i8* %oper1.addr, align 1
  %conv23 = sext i8 %6 to i32
  %cmp24 = icmp eq i32 %conv23, 42
  br i1 %cmp24, label %cond.true26, label %cond.false27

cond.true26:                                      ; preds = %cond.false22
  br label %cond.end51

cond.false27:                                     ; preds = %cond.false22
  %7 = load i8, i8* %oper2.addr, align 1
  %conv28 = sext i8 %7 to i32
  %cmp29 = icmp eq i32 %conv28, 42
  br i1 %cmp29, label %cond.true31, label %cond.false32

cond.true31:                                      ; preds = %cond.false27
  br label %cond.end49

cond.false32:                                     ; preds = %cond.false27
  %8 = load i8, i8* %oper1.addr, align 1
  %conv33 = sext i8 %8 to i32
  %cmp34 = icmp eq i32 %conv33, 43
  br i1 %cmp34, label %cond.true36, label %cond.false37

cond.true36:                                      ; preds = %cond.false32
  br label %cond.end47

cond.false37:                                     ; preds = %cond.false32
  %9 = load i8, i8* %oper2.addr, align 1
  %conv38 = sext i8 %9 to i32
  %cmp39 = icmp eq i32 %conv38, 43
  br i1 %cmp39, label %cond.true41, label %cond.false42

cond.true41:                                      ; preds = %cond.false37
  br label %cond.end

cond.false42:                                     ; preds = %cond.false37
  %10 = load i8, i8* %oper1.addr, align 1
  %conv43 = sext i8 %10 to i32
  %cmp44 = icmp eq i32 %conv43, 45
  %11 = zext i1 %cmp44 to i64
  %cond = select i1 %cmp44, i32 1, i32 2
  br label %cond.end

cond.end:                                         ; preds = %cond.false42, %cond.true41
  %cond46 = phi i32 [ 2, %cond.true41 ], [ %cond, %cond.false42 ]
  br label %cond.end47

cond.end47:                                       ; preds = %cond.end, %cond.true36
  %cond48 = phi i32 [ 1, %cond.true36 ], [ %cond46, %cond.end ]
  br label %cond.end49

cond.end49:                                       ; preds = %cond.end47, %cond.true31
  %cond50 = phi i32 [ 2, %cond.true31 ], [ %cond48, %cond.end47 ]
  br label %cond.end51

cond.end51:                                       ; preds = %cond.end49, %cond.true26
  %cond52 = phi i32 [ 1, %cond.true26 ], [ %cond50, %cond.end49 ]
  br label %cond.end53

cond.end53:                                       ; preds = %cond.end51, %cond.true21
  %cond54 = phi i32 [ 2, %cond.true21 ], [ %cond52, %cond.end51 ]
  br label %cond.end55

cond.end55:                                       ; preds = %cond.end53, %cond.true16
  %cond56 = phi i32 [ 1, %cond.true16 ], [ %cond54, %cond.end53 ]
  br label %cond.end57

cond.end57:                                       ; preds = %cond.end55, %cond.true11
  %cond58 = phi i32 [ 2, %cond.true11 ], [ %cond56, %cond.end55 ]
  br label %cond.end59

cond.end59:                                       ; preds = %cond.end57, %cond.true6
  %cond60 = phi i32 [ 1, %cond.true6 ], [ %cond58, %cond.end57 ]
  br label %cond.end61

cond.end61:                                       ; preds = %cond.end59, %cond.true
  %cond62 = phi i32 [ 0, %cond.true ], [ %cond60, %cond.end59 ]
  ret i32 %cond62
}

; Function Attrs: noinline nounwind optnone
define hidden i32 @isOperator(i8 signext %c) #0 {
entry:
  %c.addr = alloca i8, align 1
  store i8 %c, i8* %c.addr, align 1
  %0 = load i8, i8* %c.addr, align 1
  %conv = sext i8 %0 to i32
  %cmp = icmp eq i32 %conv, 43
  br i1 %cmp, label %lor.end, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %entry
  %1 = load i8, i8* %c.addr, align 1
  %conv2 = sext i8 %1 to i32
  %cmp3 = icmp eq i32 %conv2, 45
  br i1 %cmp3, label %lor.end, label %lor.lhs.false5

lor.lhs.false5:                                   ; preds = %lor.lhs.false
  %2 = load i8, i8* %c.addr, align 1
  %conv6 = sext i8 %2 to i32
  %cmp7 = icmp eq i32 %conv6, 42
  br i1 %cmp7, label %lor.end, label %lor.lhs.false9

lor.lhs.false9:                                   ; preds = %lor.lhs.false5
  %3 = load i8, i8* %c.addr, align 1
  %conv10 = sext i8 %3 to i32
  %cmp11 = icmp eq i32 %conv10, 47
  br i1 %cmp11, label %lor.end, label %lor.rhs

lor.rhs:                                          ; preds = %lor.lhs.false9
  %4 = load i8, i8* %c.addr, align 1
  %conv13 = sext i8 %4 to i32
  %cmp14 = icmp eq i32 %conv13, 94
  br label %lor.end

lor.end:                                          ; preds = %lor.rhs, %lor.lhs.false9, %lor.lhs.false5, %lor.lhs.false, %entry
  %5 = phi i1 [ true, %lor.lhs.false9 ], [ true, %lor.lhs.false5 ], [ true, %lor.lhs.false ], [ true, %entry ], [ %cmp14, %lor.rhs ]
  %lor.ext = zext i1 %5 to i32
  ret i32 %lor.ext
}

; Function Attrs: noinline nounwind optnone
define hidden void @inorder(%struct.elem* %t) #0 {
entry:
  %t.addr = alloca %struct.elem*, align 4
  store %struct.elem* %t, %struct.elem** %t.addr, align 4
  %0 = load %struct.elem*, %struct.elem** %t.addr, align 4
  %cmp = icmp ne %struct.elem* %0, null
  br i1 %cmp, label %if.then, label %if.end71

if.then:                                          ; preds = %entry
  %1 = load %struct.elem*, %struct.elem** %t.addr, align 4
  %left = getelementptr inbounds %struct.elem, %struct.elem* %1, i32 0, i32 1
  %2 = load %struct.elem*, %struct.elem** %left, align 4
  %cmp1 = icmp ne %struct.elem* %2, null
  br i1 %cmp1, label %land.lhs.true, label %if.else

land.lhs.true:                                    ; preds = %if.then
  %3 = load %struct.elem*, %struct.elem** %t.addr, align 4
  %left2 = getelementptr inbounds %struct.elem, %struct.elem* %3, i32 0, i32 1
  %4 = load %struct.elem*, %struct.elem** %left2, align 4
  %data = getelementptr inbounds %struct.elem, %struct.elem* %4, i32 0, i32 0
  %arrayidx = getelementptr inbounds [10 x i8], [10 x i8]* %data, i32 0, i32 0
  %5 = load i8, i8* %arrayidx, align 4
  %call = call i32 @isOperator(i8 signext %5)
  %cmp3 = icmp eq i32 %call, 1
  br i1 %cmp3, label %land.lhs.true4, label %if.else

land.lhs.true4:                                   ; preds = %land.lhs.true
  %6 = load %struct.elem*, %struct.elem** %t.addr, align 4
  %data5 = getelementptr inbounds %struct.elem, %struct.elem* %6, i32 0, i32 0
  %arrayidx6 = getelementptr inbounds [10 x i8], [10 x i8]* %data5, i32 0, i32 0
  %7 = load i8, i8* %arrayidx6, align 4
  %8 = load %struct.elem*, %struct.elem** %t.addr, align 4
  %left7 = getelementptr inbounds %struct.elem, %struct.elem* %8, i32 0, i32 1
  %9 = load %struct.elem*, %struct.elem** %left7, align 4
  %data8 = getelementptr inbounds %struct.elem, %struct.elem* %9, i32 0, i32 0
  %arrayidx9 = getelementptr inbounds [10 x i8], [10 x i8]* %data8, i32 0, i32 0
  %10 = load i8, i8* %arrayidx9, align 4
  %call10 = call i32 @precedenceCheck(i8 signext %7, i8 signext %10)
  %cmp11 = icmp eq i32 %call10, 1
  br i1 %cmp11, label %if.then24, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %land.lhs.true4
  %11 = load %struct.elem*, %struct.elem** %t.addr, align 4
  %data12 = getelementptr inbounds %struct.elem, %struct.elem* %11, i32 0, i32 0
  %arrayidx13 = getelementptr inbounds [10 x i8], [10 x i8]* %data12, i32 0, i32 0
  %12 = load i8, i8* %arrayidx13, align 4
  %13 = load %struct.elem*, %struct.elem** %t.addr, align 4
  %left14 = getelementptr inbounds %struct.elem, %struct.elem* %13, i32 0, i32 1
  %14 = load %struct.elem*, %struct.elem** %left14, align 4
  %data15 = getelementptr inbounds %struct.elem, %struct.elem* %14, i32 0, i32 0
  %arrayidx16 = getelementptr inbounds [10 x i8], [10 x i8]* %data15, i32 0, i32 0
  %15 = load i8, i8* %arrayidx16, align 4
  %call17 = call i32 @precedenceCheck(i8 signext %12, i8 signext %15)
  %cmp18 = icmp eq i32 %call17, 0
  br i1 %cmp18, label %land.lhs.true19, label %if.else

land.lhs.true19:                                  ; preds = %lor.lhs.false
  %16 = load %struct.elem*, %struct.elem** %t.addr, align 4
  %data20 = getelementptr inbounds %struct.elem, %struct.elem* %16, i32 0, i32 0
  %arrayidx21 = getelementptr inbounds [10 x i8], [10 x i8]* %data20, i32 0, i32 0
  %17 = load i8, i8* %arrayidx21, align 4
  %conv = sext i8 %17 to i32
  %cmp22 = icmp eq i32 %conv, 94
  br i1 %cmp22, label %if.then24, label %if.else

if.then24:                                        ; preds = %land.lhs.true19, %land.lhs.true4
  %call25 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([2 x i8], [2 x i8]* @.str, i32 0, i32 0))
  %18 = load %struct.elem*, %struct.elem** %t.addr, align 4
  %left26 = getelementptr inbounds %struct.elem, %struct.elem* %18, i32 0, i32 1
  %19 = load %struct.elem*, %struct.elem** %left26, align 4
  call void @inorder(%struct.elem* %19)
  %call27 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([2 x i8], [2 x i8]* @.str.1, i32 0, i32 0))
  br label %if.end

if.else:                                          ; preds = %land.lhs.true19, %lor.lhs.false, %land.lhs.true, %if.then
  %20 = load %struct.elem*, %struct.elem** %t.addr, align 4
  %left28 = getelementptr inbounds %struct.elem, %struct.elem* %20, i32 0, i32 1
  %21 = load %struct.elem*, %struct.elem** %left28, align 4
  call void @inorder(%struct.elem* %21)
  br label %if.end

if.end:                                           ; preds = %if.else, %if.then24
  %22 = load %struct.elem*, %struct.elem** %t.addr, align 4
  %data29 = getelementptr inbounds %struct.elem, %struct.elem* %22, i32 0, i32 0
  %arraydecay = getelementptr inbounds [10 x i8], [10 x i8]* %data29, i32 0, i32 0
  %call30 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.2, i32 0, i32 0), i8* %arraydecay)
  %23 = load %struct.elem*, %struct.elem** %t.addr, align 4
  %right = getelementptr inbounds %struct.elem, %struct.elem* %23, i32 0, i32 2
  %24 = load %struct.elem*, %struct.elem** %right, align 4
  %cmp31 = icmp ne %struct.elem* %24, null
  br i1 %cmp31, label %land.lhs.true33, label %if.else68

land.lhs.true33:                                  ; preds = %if.end
  %25 = load %struct.elem*, %struct.elem** %t.addr, align 4
  %right34 = getelementptr inbounds %struct.elem, %struct.elem* %25, i32 0, i32 2
  %26 = load %struct.elem*, %struct.elem** %right34, align 4
  %data35 = getelementptr inbounds %struct.elem, %struct.elem* %26, i32 0, i32 0
  %arrayidx36 = getelementptr inbounds [10 x i8], [10 x i8]* %data35, i32 0, i32 0
  %27 = load i8, i8* %arrayidx36, align 4
  %call37 = call i32 @isOperator(i8 signext %27)
  %cmp38 = icmp eq i32 %call37, 1
  br i1 %cmp38, label %land.lhs.true40, label %if.else68

land.lhs.true40:                                  ; preds = %land.lhs.true33
  %28 = load %struct.elem*, %struct.elem** %t.addr, align 4
  %data41 = getelementptr inbounds %struct.elem, %struct.elem* %28, i32 0, i32 0
  %arrayidx42 = getelementptr inbounds [10 x i8], [10 x i8]* %data41, i32 0, i32 0
  %29 = load i8, i8* %arrayidx42, align 4
  %30 = load %struct.elem*, %struct.elem** %t.addr, align 4
  %right43 = getelementptr inbounds %struct.elem, %struct.elem* %30, i32 0, i32 2
  %31 = load %struct.elem*, %struct.elem** %right43, align 4
  %data44 = getelementptr inbounds %struct.elem, %struct.elem* %31, i32 0, i32 0
  %arrayidx45 = getelementptr inbounds [10 x i8], [10 x i8]* %data44, i32 0, i32 0
  %32 = load i8, i8* %arrayidx45, align 4
  %call46 = call i32 @precedenceCheck(i8 signext %29, i8 signext %32)
  %cmp47 = icmp eq i32 %call46, 1
  br i1 %cmp47, label %if.then64, label %lor.lhs.false49

lor.lhs.false49:                                  ; preds = %land.lhs.true40
  %33 = load %struct.elem*, %struct.elem** %t.addr, align 4
  %data50 = getelementptr inbounds %struct.elem, %struct.elem* %33, i32 0, i32 0
  %arrayidx51 = getelementptr inbounds [10 x i8], [10 x i8]* %data50, i32 0, i32 0
  %34 = load i8, i8* %arrayidx51, align 4
  %35 = load %struct.elem*, %struct.elem** %t.addr, align 4
  %right52 = getelementptr inbounds %struct.elem, %struct.elem* %35, i32 0, i32 2
  %36 = load %struct.elem*, %struct.elem** %right52, align 4
  %data53 = getelementptr inbounds %struct.elem, %struct.elem* %36, i32 0, i32 0
  %arrayidx54 = getelementptr inbounds [10 x i8], [10 x i8]* %data53, i32 0, i32 0
  %37 = load i8, i8* %arrayidx54, align 4
  %call55 = call i32 @precedenceCheck(i8 signext %34, i8 signext %37)
  %cmp56 = icmp eq i32 %call55, 0
  br i1 %cmp56, label %land.lhs.true58, label %if.else68

land.lhs.true58:                                  ; preds = %lor.lhs.false49
  %38 = load %struct.elem*, %struct.elem** %t.addr, align 4
  %data59 = getelementptr inbounds %struct.elem, %struct.elem* %38, i32 0, i32 0
  %arrayidx60 = getelementptr inbounds [10 x i8], [10 x i8]* %data59, i32 0, i32 0
  %39 = load i8, i8* %arrayidx60, align 4
  %conv61 = sext i8 %39 to i32
  %cmp62 = icmp ne i32 %conv61, 94
  br i1 %cmp62, label %if.then64, label %if.else68

if.then64:                                        ; preds = %land.lhs.true58, %land.lhs.true40
  %call65 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([2 x i8], [2 x i8]* @.str, i32 0, i32 0))
  %40 = load %struct.elem*, %struct.elem** %t.addr, align 4
  %right66 = getelementptr inbounds %struct.elem, %struct.elem* %40, i32 0, i32 2
  %41 = load %struct.elem*, %struct.elem** %right66, align 4
  call void @inorder(%struct.elem* %41)
  %call67 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([2 x i8], [2 x i8]* @.str.1, i32 0, i32 0))
  br label %if.end70

if.else68:                                        ; preds = %land.lhs.true58, %lor.lhs.false49, %land.lhs.true33, %if.end
  %42 = load %struct.elem*, %struct.elem** %t.addr, align 4
  %right69 = getelementptr inbounds %struct.elem, %struct.elem* %42, i32 0, i32 2
  %43 = load %struct.elem*, %struct.elem** %right69, align 4
  call void @inorder(%struct.elem* %43)
  br label %if.end70

if.end70:                                         ; preds = %if.else68, %if.then64
  br label %if.end71

if.end71:                                         ; preds = %if.end70, %entry
  ret void
}

declare i32 @printf(i8* %0, ...) #1

; Function Attrs: noinline nounwind optnone
define hidden i8* @getNextString() #0 {
entry:
  %0 = load i32, i32* @counter, align 4
  %cmp = icmp slt i32 %0, 0
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %call = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([15 x i8], [15 x i8]* @.str.3, i32 0, i32 0))
  call void @exit(i32 0) #4
  unreachable

if.end:                                           ; preds = %entry
  %1 = load i8**, i8*** @components, align 4
  %2 = load i32, i32* @counter, align 4
  %dec = add nsw i32 %2, -1
  store i32 %dec, i32* @counter, align 4
  %arrayidx = getelementptr inbounds i8*, i8** %1, i32 %2
  %3 = load i8*, i8** %arrayidx, align 4
  ret i8* %3
}

; Function Attrs: noreturn
declare void @exit(i32 %0) #2

; Function Attrs: noinline nounwind optnone
define hidden %struct.elem* @buildTree(i8* %obj, i8* %trace) #0 {
entry:
  %obj.addr = alloca i8*, align 4
  %trace.addr = alloca i8*, align 4
  %t = alloca %struct.elem*, align 4
  store i8* %obj, i8** %obj.addr, align 4
  store i8* %trace, i8** %trace.addr, align 4
  %call = call noalias i8* @malloc(i32 20)
  %0 = bitcast i8* %call to %struct.elem*
  store %struct.elem* %0, %struct.elem** %t, align 4
  %1 = load %struct.elem*, %struct.elem** %t, align 4
  %data = getelementptr inbounds %struct.elem, %struct.elem* %1, i32 0, i32 0
  %arraydecay = getelementptr inbounds [10 x i8], [10 x i8]* %data, i32 0, i32 0
  %2 = load i8*, i8** %obj.addr, align 4
  %call1 = call i8* @strcpy(i8* %arraydecay, i8* %2)
  %3 = load i8*, i8** %obj.addr, align 4
  %arrayidx = getelementptr inbounds i8, i8* %3, i32 0
  %4 = load i8, i8* %arrayidx, align 1
  %call2 = call i32 @isOperator(i8 signext %4)
  %cmp = icmp eq i32 %call2, 1
  br i1 %cmp, label %cond.true, label %cond.false

cond.true:                                        ; preds = %entry
  %call3 = call i8* @getNextString()
  %5 = load i8*, i8** %trace.addr, align 4
  %call4 = call %struct.elem* @buildTree(i8* %call3, i8* %5)
  br label %cond.end

cond.false:                                       ; preds = %entry
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi %struct.elem* [ %call4, %cond.true ], [ null, %cond.false ]
  %6 = load %struct.elem*, %struct.elem** %t, align 4
  %right = getelementptr inbounds %struct.elem, %struct.elem* %6, i32 0, i32 2
  store %struct.elem* %cond, %struct.elem** %right, align 4
  %7 = load i8*, i8** %obj.addr, align 4
  %arrayidx5 = getelementptr inbounds i8, i8* %7, i32 0
  %8 = load i8, i8* %arrayidx5, align 1
  %call6 = call i32 @isOperator(i8 signext %8)
  %cmp7 = icmp eq i32 %call6, 1
  br i1 %cmp7, label %cond.true8, label %cond.false11

cond.true8:                                       ; preds = %cond.end
  %call9 = call i8* @getNextString()
  %9 = load i8*, i8** %trace.addr, align 4
  %call10 = call %struct.elem* @buildTree(i8* %call9, i8* %9)
  br label %cond.end12

cond.false11:                                     ; preds = %cond.end
  br label %cond.end12

cond.end12:                                       ; preds = %cond.false11, %cond.true8
  %cond13 = phi %struct.elem* [ %call10, %cond.true8 ], [ null, %cond.false11 ]
  %10 = load %struct.elem*, %struct.elem** %t, align 4
  %left = getelementptr inbounds %struct.elem, %struct.elem* %10, i32 0, i32 1
  store %struct.elem* %cond13, %struct.elem** %left, align 4
  %11 = load i8*, i8** %trace.addr, align 4
  %cmp14 = icmp ne i8* %11, null
  br i1 %cmp14, label %if.then, label %if.end

if.then:                                          ; preds = %cond.end12
  %call15 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([2 x i8], [2 x i8]* @.str.4, i32 0, i32 0))
  %12 = load %struct.elem*, %struct.elem** %t, align 4
  call void @inorder(%struct.elem* %12)
  br label %if.end

if.end:                                           ; preds = %if.then, %cond.end12
  %13 = load %struct.elem*, %struct.elem** %t, align 4
  ret %struct.elem* %13
}

declare noalias i8* @malloc(i32 %0) #1

declare i8* @strcpy(i8* %0, i8* %1) #1

; Function Attrs: noinline nounwind optnone
define hidden i32 @checkRPN() #0 {
entry:
  %retval = alloca i32, align 4
  %i = alloca i32, align 4
  %operSum = alloca i32, align 4
  %numberSum = alloca i32, align 4
  store i32 0, i32* %operSum, align 4
  store i32 0, i32* %numberSum, align 4
  %0 = load i8**, i8*** @components, align 4
  %1 = load i32, i32* @counter, align 4
  %arrayidx = getelementptr inbounds i8*, i8** %0, i32 %1
  %2 = load i8*, i8** %arrayidx, align 4
  %arrayidx1 = getelementptr inbounds i8, i8* %2, i32 0
  %3 = load i8, i8* %arrayidx1, align 1
  %call = call i32 @isOperator(i8 signext %3)
  %cmp = icmp eq i32 %call, 0
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  store i32 0, i32* %retval, align 4
  br label %return

if.end:                                           ; preds = %entry
  store i32 0, i32* %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.end
  %4 = load i32, i32* %i, align 4
  %5 = load i32, i32* @counter, align 4
  %cmp2 = icmp sle i32 %4, %5
  br i1 %cmp2, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %6 = load i8**, i8*** @components, align 4
  %7 = load i32, i32* %i, align 4
  %arrayidx3 = getelementptr inbounds i8*, i8** %6, i32 %7
  %8 = load i8*, i8** %arrayidx3, align 4
  %arrayidx4 = getelementptr inbounds i8, i8* %8, i32 0
  %9 = load i8, i8* %arrayidx4, align 1
  %call5 = call i32 @isOperator(i8 signext %9)
  %cmp6 = icmp eq i32 %call5, 1
  br i1 %cmp6, label %cond.true, label %cond.false

cond.true:                                        ; preds = %for.body
  %10 = load i32, i32* %operSum, align 4
  %inc = add nsw i32 %10, 1
  store i32 %inc, i32* %operSum, align 4
  br label %cond.end

cond.false:                                       ; preds = %for.body
  %11 = load i32, i32* %numberSum, align 4
  %inc7 = add nsw i32 %11, 1
  store i32 %inc7, i32* %numberSum, align 4
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi i32 [ %10, %cond.true ], [ %11, %cond.false ]
  br label %for.inc

for.inc:                                          ; preds = %cond.end
  %12 = load i32, i32* %i, align 4
  %inc8 = add nsw i32 %12, 1
  store i32 %inc8, i32* %i, align 4
  br label %for.cond

for.end:                                          ; preds = %for.cond
  %13 = load i32, i32* %numberSum, align 4
  %14 = load i32, i32* %operSum, align 4
  %sub = sub nsw i32 %13, %14
  %cmp9 = icmp eq i32 %sub, 1
  %conv = zext i1 %cmp9 to i32
  store i32 %conv, i32* %retval, align 4
  br label %return

return:                                           ; preds = %for.end, %if.then
  %15 = load i32, i32* %retval, align 4
  ret i32 %15
}

; Function Attrs: noinline nounwind optnone
define hidden void @buildStack(i8* %str) #0 {
entry:
  %str.addr = alloca i8*, align 4
  %i = alloca i32, align 4
  %token = alloca i8*, align 4
  store i8* %str, i8** %str.addr, align 4
  store i32 0, i32* %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %0 = load i8*, i8** %str.addr, align 4
  %1 = load i32, i32* %i, align 4
  %arrayidx = getelementptr inbounds i8, i8* %0, i32 %1
  %2 = load i8, i8* %arrayidx, align 1
  %conv = sext i8 %2 to i32
  %cmp = icmp ne i32 %conv, 0
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %3 = load i8*, i8** %str.addr, align 4
  %4 = load i32, i32* %i, align 4
  %arrayidx2 = getelementptr inbounds i8, i8* %3, i32 %4
  %5 = load i8, i8* %arrayidx2, align 1
  %conv3 = sext i8 %5 to i32
  %cmp4 = icmp eq i32 %conv3, 32
  br i1 %cmp4, label %if.then, label %if.end

if.then:                                          ; preds = %for.body
  %6 = load i32, i32* @counter, align 4
  %inc = add nsw i32 %6, 1
  store i32 %inc, i32* @counter, align 4
  br label %if.end

if.end:                                           ; preds = %if.then, %for.body
  br label %for.inc

for.inc:                                          ; preds = %if.end
  %7 = load i32, i32* %i, align 4
  %inc6 = add nsw i32 %7, 1
  store i32 %inc6, i32* %i, align 4
  br label %for.cond

for.end:                                          ; preds = %for.cond
  %8 = load i32, i32* @counter, align 4
  %add = add nsw i32 %8, 1
  %mul = mul i32 %add, 4
  %call = call noalias i8* @malloc(i32 %mul)
  %9 = bitcast i8* %call to i8**
  store i8** %9, i8*** @components, align 4
  %10 = load i8*, i8** %str.addr, align 4
  %call7 = call i8* @strtok(i8* %10, i8* getelementptr inbounds ([2 x i8], [2 x i8]* @.str.5, i32 0, i32 0))
  store i8* %call7, i8** %token, align 4
  store i32 0, i32* %i, align 4
  br label %while.cond

while.cond:                                       ; preds = %while.body, %for.end
  %11 = load i8*, i8** %token, align 4
  %cmp8 = icmp ne i8* %11, null
  br i1 %cmp8, label %while.body, label %while.end

while.body:                                       ; preds = %while.cond
  %12 = load i8*, i8** %token, align 4
  %call10 = call i32 @strlen(i8* %12) #5
  %mul11 = mul i32 %call10, 1
  %call12 = call noalias i8* @malloc(i32 %mul11)
  %13 = load i8**, i8*** @components, align 4
  %14 = load i32, i32* %i, align 4
  %arrayidx13 = getelementptr inbounds i8*, i8** %13, i32 %14
  store i8* %call12, i8** %arrayidx13, align 4
  %15 = load i8**, i8*** @components, align 4
  %16 = load i32, i32* %i, align 4
  %arrayidx14 = getelementptr inbounds i8*, i8** %15, i32 %16
  %17 = load i8*, i8** %arrayidx14, align 4
  %18 = load i8*, i8** %token, align 4
  %call15 = call i8* @strcpy(i8* %17, i8* %18)
  %call16 = call i8* @strtok(i8* null, i8* getelementptr inbounds ([2 x i8], [2 x i8]* @.str.5, i32 0, i32 0))
  store i8* %call16, i8** %token, align 4
  %19 = load i32, i32* %i, align 4
  %inc17 = add nsw i32 %19, 1
  store i32 %inc17, i32* %i, align 4
  br label %while.cond

while.end:                                        ; preds = %while.cond
  ret void
}

declare i8* @strtok(i8* %0, i8* %1) #1

; Function Attrs: nounwind readonly
declare i32 @strlen(i8* %0) #3

; Function Attrs: noinline nounwind optnone
define hidden i32 @__main_argc_argv(i32 %argC, i8** %argV) #0 {
entry:
  %retval = alloca i32, align 4
  %argC.addr = alloca i32, align 4
  %argV.addr = alloca i8**, align 4
  %i = alloca i32, align 4
  %t = alloca %struct.elem*, align 4
  store i32 0, i32* %retval, align 4
  store i32 %argC, i32* %argC.addr, align 4
  store i8** %argV, i8*** %argV.addr, align 4
  %0 = load i32, i32* %argC.addr, align 4
  %cmp = icmp eq i32 %0, 1
  br i1 %cmp, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  %1 = load i8**, i8*** %argV.addr, align 4
  %arrayidx = getelementptr inbounds i8*, i8** %1, i32 0
  %2 = load i8*, i8** %arrayidx, align 4
  %call = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([95 x i8], [95 x i8]* @.str.6, i32 0, i32 0), i8* %2)
  br label %if.end10

if.else:                                          ; preds = %entry
  %3 = load i8**, i8*** %argV.addr, align 4
  %arrayidx1 = getelementptr inbounds i8*, i8** %3, i32 1
  %4 = load i8*, i8** %arrayidx1, align 4
  call void @buildStack(i8* %4)
  %call2 = call i32 @checkRPN()
  %cmp3 = icmp eq i32 %call2, 0
  br i1 %cmp3, label %if.then4, label %if.end

if.then4:                                         ; preds = %if.else
  %call5 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([15 x i8], [15 x i8]* @.str.3, i32 0, i32 0))
  store i32 0, i32* %retval, align 4
  br label %return

if.end:                                           ; preds = %if.else
  %call6 = call i8* @getNextString()
  %5 = load i8**, i8*** %argV.addr, align 4
  %arrayidx7 = getelementptr inbounds i8*, i8** %5, i32 2
  %6 = load i8*, i8** %arrayidx7, align 4
  %call8 = call %struct.elem* @buildTree(i8* %call6, i8* %6)
  store %struct.elem* %call8, %struct.elem** %t, align 4
  %call9 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([27 x i8], [27 x i8]* @.str.7, i32 0, i32 0))
  %7 = load %struct.elem*, %struct.elem** %t, align 4
  call void @inorder(%struct.elem* %7)
  br label %if.end10

if.end10:                                         ; preds = %if.end, %if.then
  store i32 0, i32* %retval, align 4
  br label %return

return:                                           ; preds = %if.end10, %if.then4
  %8 = load i32, i32* %retval, align 4
  ret i32 %8
}

attributes #0 = { noinline nounwind optnone "correctly-rounded-divide-sqrt-fp-math"="false" "disable-tail-calls"="false" "frame-pointer"="none" "less-precise-fpmad"="false" "min-legal-vector-width"="0" "no-infs-fp-math"="false" "no-jump-tables"="false" "no-nans-fp-math"="false" "no-signed-zeros-fp-math"="false" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="generic" "unsafe-fp-math"="false" "use-soft-float"="false" }
attributes #1 = { "correctly-rounded-divide-sqrt-fp-math"="false" "disable-tail-calls"="false" "frame-pointer"="none" "less-precise-fpmad"="false" "no-infs-fp-math"="false" "no-nans-fp-math"="false" "no-signed-zeros-fp-math"="false" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="generic" "unsafe-fp-math"="false" "use-soft-float"="false" }
attributes #2 = { noreturn "correctly-rounded-divide-sqrt-fp-math"="false" "disable-tail-calls"="false" "frame-pointer"="none" "less-precise-fpmad"="false" "no-infs-fp-math"="false" "no-nans-fp-math"="false" "no-signed-zeros-fp-math"="false" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="generic" "unsafe-fp-math"="false" "use-soft-float"="false" }
attributes #3 = { nounwind readonly "correctly-rounded-divide-sqrt-fp-math"="false" "disable-tail-calls"="false" "frame-pointer"="none" "less-precise-fpmad"="false" "no-infs-fp-math"="false" "no-nans-fp-math"="false" "no-signed-zeros-fp-math"="false" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="generic" "unsafe-fp-math"="false" "use-soft-float"="false" }
attributes #4 = { noreturn }
attributes #5 = { nounwind readonly }

!llvm.module.flags = !{!0}
!llvm.ident = !{!1}

!0 = !{i32 1, !"wchar_size", i32 4}
!1 = !{!"clang version 11.0.0 (https://github.com/Jacarte/llvm-project.git 0f6dea67136cc1e0b3d200eb2bb165628970c44b)"}

; extracted candidates

; *****
; For LLVM instruction:
;  %1 = load i32, i32* %i, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %2 = load i8, i8* %arrayidx, align 1
; Looking for a replacement for:
%0:i8 = var
infer %0

; *****
; For LLVM instruction:
;  %conv = sext i8 %2 to i32
; Looking for a replacement for:
%0:i8 = var
%1:i32 = sext %0
infer %1

; *****
; For LLVM instruction:
;  %cmp = icmp ne i32 %conv, 0
; Looking for a replacement for:
%0:i8 = var
%1:i32 = sext %0
%2:i1 = ne 0:i32, %1
infer %2

; *****
; For LLVM instruction:
;  %4 = load i32, i32* %i, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %5 = load i8, i8* %arrayidx2, align 1
; Looking for a replacement for:
%0:i8 = var
infer %0

; *****
; For LLVM instruction:
;  %conv3 = sext i8 %5 to i32
; Looking for a replacement for:
%0:i8 = var
%1:i32 = sext %0
infer %1

; *****
; For LLVM instruction:
;  %cmp4 = icmp eq i32 %conv3, 32
; Looking for a replacement for:
%0:i8 = var
%1:i32 = sext %0
%2:i1 = eq 32:i32, %1
infer %2

; *****
; For LLVM instruction:
;  %6 = load i32, i32* @counter, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %inc = add nsw i32 %6, 1
; Looking for a replacement for:
%0:i32 = var
%1:i32 = addnsw 1:i32, %0
infer %1

; *****
; For LLVM instruction:
;  %7 = load i32, i32* %i, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %inc6 = add nsw i32 %7, 1
; Looking for a replacement for:
%0:i32 = var
%1:i32 = addnsw 1:i32, %0
infer %1

; *****
; For LLVM instruction:
;  %8 = load i32, i32* @counter, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %add = add nsw i32 %8, 1
; Looking for a replacement for:
%0:i32 = var
%1:i32 = addnsw 1:i32, %0
infer %1

; *****
; For LLVM instruction:
;  %mul = mul i32 %add, 4
; Looking for a replacement for:
%0:i32 = var
%1:i32 = addnsw 1:i32, %0
%2:i32 = mul 4:i32, %1
infer %2

; *****
; For LLVM instruction:
;  %cmp8 = icmp ne i8* %11, null
; Looking for a replacement for:
%0:i32 = var
%1:i1 = ne 0:i32, %0
infer %1

; *****
; For LLVM instruction:
;  %call10 = call i32 @strlen(i8* %12) #4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %mul11 = mul i32 %call10, 1
; Looking for a replacement for:
%0:i32 = var
%1:i32 = mul 1:i32, %0
infer %1

; *****
; For LLVM instruction:
;  %14 = load i32, i32* %i, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %16 = load i32, i32* %i, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %19 = load i32, i32* %i, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %inc17 = add nsw i32 %19, 1
; Looking for a replacement for:
%0:i32 = var
%1:i32 = addnsw 1:i32, %0
infer %1
got 3 candidates from LHS

-------------------------------------------------
%0:i8 = var
%1:i32 = sext %0
%2:i1 = ne 0:i32, %1
infer %2


--------------------------------
guess 0

%0:i1 = var ; reservedconst_1

Cost = 0
first query is SAT, returning the model:
reservedconst_1: 0
0 th attempt: second query is SAT-- constant doesn't work
first query is SAT, returning the model:
reservedconst_1: -1
1 th attempt: second query is SAT-- constant doesn't work
first query is UNSAT-- no more guesses
Dataflow Pruned 0/0
There are 1 Guesses
There are 0 RHSs before deduplication
There are 0 RHSs after deduplication
got 3 candidates from LHS

-------------------------------------------------
%0:i8 = var
%1:i32 = sext %0
%2:i1 = eq 32:i32, %1
infer %2


--------------------------------
guess 0

%0:i1 = var ; reservedconst_1

Cost = 0
first query is SAT, returning the model:
reservedconst_1: 0
0 th attempt: second query is SAT-- constant doesn't work
first query is SAT, returning the model:
reservedconst_1: -1
1 th attempt: second query is SAT-- constant doesn't work
first query is UNSAT-- no more guesses
Dataflow Pruned 0/0
There are 1 Guesses
There are 0 RHSs before deduplication
There are 0 RHSs after deduplication
got 3 candidates from LHS

-------------------------------------------------
%0:i32 = var
%1:i32 = addnsw 1:i32, %0
%2:i32 = mul 4:i32, %1
infer %2


--------------------------------
guess 0

%0:i32 = var ; reservedconst_1

Cost = 0
first query is SAT, returning the model:
reservedconst_1: 4
0 th attempt: second query is SAT-- constant doesn't work
first query is SAT, returning the model:
reservedconst_1: 1073741828
1 th attempt: second query is SAT-- constant doesn't work
first query is UNSAT-- no more guesses

--------------------------------
guess 1

%0:i32 = var

Cost = 0
second query is SAT-- constant doesn't work

--------------------------------
guess 2

%0:i32 = var
%1:i32 = addnsw 1:i32, %0

Cost = 1
second query is SAT-- constant doesn't work
Dataflow Pruned 0/0
There are 3 Guesses
There are 0 RHSs before deduplication
There are 0 RHSs after deduplication
got 2 candidates from LHS

-------------------------------------------------
%0:i32 = var
%1:i32 = mul 1:i32, %0
infer %1


--------------------------------
guess 0

%0:i32 = var ; reservedconst_1

Cost = 0
first query is SAT, returning the model:
reservedconst_1: 0
0 th attempt: second query is SAT-- constant doesn't work
first query is SAT, returning the model:
reservedconst_1: -1
1 th attempt: second query is SAT-- constant doesn't work
first query is UNSAT-- no more guesses

--------------------------------
guess 1

%0:i32 = var

Cost = 0
second query is UNSAT
Dataflow Pruned 0/0
There are 2 Guesses
There are 1 RHSs before deduplication
There are 1 RHSs after deduplication
"
; No valid RHS in the list
#########################################################

Module before replacement:
; ModuleID = './Parsing-RPN_to_infix_conversion.c.bc'
source_filename = "./Parsing-RPN_to_infix_conversion.c"
target datalayout = "e-m:e-p:32:32-i64:64-n32:64-S128"
target triple = "wasm32-unknown-wasi"

%struct.elem = type { [10 x i8], %struct.elem*, %struct.elem* }

@counter = hidden global i32 0, align 4
@.str = private unnamed_addr constant [2 x i8] c"(\00", align 1
@.str.1 = private unnamed_addr constant [2 x i8] c")\00", align 1
@.str.2 = private unnamed_addr constant [5 x i8] c" %s \00", align 1
@.str.3 = private unnamed_addr constant [15 x i8] c"\0AInvalid RPN !\00", align 1
@components = hidden global i8** null, align 4
@.str.4 = private unnamed_addr constant [2 x i8] c"\0A\00", align 1
@.str.5 = private unnamed_addr constant [2 x i8] c" \00", align 1
@.str.6 = private unnamed_addr constant [95 x i8] c"Usage : %s <RPN expression enclosed by quotes> <optional parameter to trace the build process>\00", align 1
@.str.7 = private unnamed_addr constant [27 x i8] c"\0AFinal infix expression : \00", align 1

; Function Attrs: noinline nounwind optnone
define hidden i32 @precedenceCheck(i8 signext %oper1, i8 signext %oper2) #0 {
entry:
  %oper1.addr = alloca i8, align 1
  %oper2.addr = alloca i8, align 1
  store i8 %oper1, i8* %oper1.addr, align 1
  store i8 %oper2, i8* %oper2.addr, align 1
  %0 = load i8, i8* %oper1.addr, align 1
  %conv = sext i8 %0 to i32
  %1 = load i8, i8* %oper2.addr, align 1
  %conv1 = sext i8 %1 to i32
  %cmp = icmp eq i32 %conv, %conv1
  br i1 %cmp, label %cond.true, label %cond.false

cond.true:                                        ; preds = %entry
  br label %cond.end61

cond.false:                                       ; preds = %entry
  %2 = load i8, i8* %oper1.addr, align 1
  %conv3 = sext i8 %2 to i32
  %cmp4 = icmp eq i32 %conv3, 94
  br i1 %cmp4, label %cond.true6, label %cond.false7

cond.true6:                                       ; preds = %cond.false
  br label %cond.end59

cond.false7:                                      ; preds = %cond.false
  %3 = load i8, i8* %oper2.addr, align 1
  %conv8 = sext i8 %3 to i32
  %cmp9 = icmp eq i32 %conv8, 94
  br i1 %cmp9, label %cond.true11, label %cond.false12

cond.true11:                                      ; preds = %cond.false7
  br label %cond.end57

cond.false12:                                     ; preds = %cond.false7
  %4 = load i8, i8* %oper1.addr, align 1
  %conv13 = sext i8 %4 to i32
  %cmp14 = icmp eq i32 %conv13, 47
  br i1 %cmp14, label %cond.true16, label %cond.false17

cond.true16:                                      ; preds = %cond.false12
  br label %cond.end55

cond.false17:                                     ; preds = %cond.false12
  %5 = load i8, i8* %oper2.addr, align 1
  %conv18 = sext i8 %5 to i32
  %cmp19 = icmp eq i32 %conv18, 47
  br i1 %cmp19, label %cond.true21, label %cond.false22

cond.true21:                                      ; preds = %cond.false17
  br label %cond.end53

cond.false22:                                     ; preds = %cond.false17
  %6 = load i8, i8* %oper1.addr, align 1
  %conv23 = sext i8 %6 to i32
  %cmp24 = icmp eq i32 %conv23, 42
  br i1 %cmp24, label %cond.true26, label %cond.false27

cond.true26:                                      ; preds = %cond.false22
  br label %cond.end51

cond.false27:                                     ; preds = %cond.false22
  %7 = load i8, i8* %oper2.addr, align 1
  %conv28 = sext i8 %7 to i32
  %cmp29 = icmp eq i32 %conv28, 42
  br i1 %cmp29, label %cond.true31, label %cond.false32

cond.true31:                                      ; preds = %cond.false27
  br label %cond.end49

cond.false32:                                     ; preds = %cond.false27
  %8 = load i8, i8* %oper1.addr, align 1
  %conv33 = sext i8 %8 to i32
  %cmp34 = icmp eq i32 %conv33, 43
  br i1 %cmp34, label %cond.true36, label %cond.false37

cond.true36:                                      ; preds = %cond.false32
  br label %cond.end47

cond.false37:                                     ; preds = %cond.false32
  %9 = load i8, i8* %oper2.addr, align 1
  %conv38 = sext i8 %9 to i32
  %cmp39 = icmp eq i32 %conv38, 43
  br i1 %cmp39, label %cond.true41, label %cond.false42

cond.true41:                                      ; preds = %cond.false37
  br label %cond.end

cond.false42:                                     ; preds = %cond.false37
  %10 = load i8, i8* %oper1.addr, align 1
  %conv43 = sext i8 %10 to i32
  %cmp44 = icmp eq i32 %conv43, 45
  %11 = zext i1 %cmp44 to i64
  %cond = select i1 %cmp44, i32 1, i32 2
  br label %cond.end

cond.end:                                         ; preds = %cond.false42, %cond.true41
  %cond46 = phi i32 [ 2, %cond.true41 ], [ %cond, %cond.false42 ]
  br label %cond.end47

cond.end47:                                       ; preds = %cond.end, %cond.true36
  %cond48 = phi i32 [ 1, %cond.true36 ], [ %cond46, %cond.end ]
  br label %cond.end49

cond.end49:                                       ; preds = %cond.end47, %cond.true31
  %cond50 = phi i32 [ 2, %cond.true31 ], [ %cond48, %cond.end47 ]
  br label %cond.end51

cond.end51:                                       ; preds = %cond.end49, %cond.true26
  %cond52 = phi i32 [ 1, %cond.true26 ], [ %cond50, %cond.end49 ]
  br label %cond.end53

cond.end53:                                       ; preds = %cond.end51, %cond.true21
  %cond54 = phi i32 [ 2, %cond.true21 ], [ %cond52, %cond.end51 ]
  br label %cond.end55

cond.end55:                                       ; preds = %cond.end53, %cond.true16
  %cond56 = phi i32 [ 1, %cond.true16 ], [ %cond54, %cond.end53 ]
  br label %cond.end57

cond.end57:                                       ; preds = %cond.end55, %cond.true11
  %cond58 = phi i32 [ 2, %cond.true11 ], [ %cond56, %cond.end55 ]
  br label %cond.end59

cond.end59:                                       ; preds = %cond.end57, %cond.true6
  %cond60 = phi i32 [ 1, %cond.true6 ], [ %cond58, %cond.end57 ]
  br label %cond.end61

cond.end61:                                       ; preds = %cond.end59, %cond.true
  %cond62 = phi i32 [ 0, %cond.true ], [ %cond60, %cond.end59 ]
  ret i32 %cond62
}

; Function Attrs: noinline nounwind optnone
define hidden i32 @isOperator(i8 signext %c) #0 {
entry:
  %c.addr = alloca i8, align 1
  store i8 %c, i8* %c.addr, align 1
  %0 = load i8, i8* %c.addr, align 1
  %conv = sext i8 %0 to i32
  %cmp = icmp eq i32 %conv, 43
  br i1 %cmp, label %lor.end, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %entry
  %1 = load i8, i8* %c.addr, align 1
  %conv2 = sext i8 %1 to i32
  %cmp3 = icmp eq i32 %conv2, 45
  br i1 %cmp3, label %lor.end, label %lor.lhs.false5

lor.lhs.false5:                                   ; preds = %lor.lhs.false
  %2 = load i8, i8* %c.addr, align 1
  %conv6 = sext i8 %2 to i32
  %cmp7 = icmp eq i32 %conv6, 42
  br i1 %cmp7, label %lor.end, label %lor.lhs.false9

lor.lhs.false9:                                   ; preds = %lor.lhs.false5
  %3 = load i8, i8* %c.addr, align 1
  %conv10 = sext i8 %3 to i32
  %cmp11 = icmp eq i32 %conv10, 47
  br i1 %cmp11, label %lor.end, label %lor.rhs

lor.rhs:                                          ; preds = %lor.lhs.false9
  %4 = load i8, i8* %c.addr, align 1
  %conv13 = sext i8 %4 to i32
  %cmp14 = icmp eq i32 %conv13, 94
  br label %lor.end

lor.end:                                          ; preds = %lor.rhs, %lor.lhs.false9, %lor.lhs.false5, %lor.lhs.false, %entry
  %5 = phi i1 [ true, %lor.lhs.false9 ], [ true, %lor.lhs.false5 ], [ true, %lor.lhs.false ], [ true, %entry ], [ %cmp14, %lor.rhs ]
  %lor.ext = zext i1 %5 to i32
  ret i32 %lor.ext
}

; Function Attrs: noinline nounwind optnone
define hidden void @inorder(%struct.elem* %t) #0 {
entry:
  %t.addr = alloca %struct.elem*, align 4
  store %struct.elem* %t, %struct.elem** %t.addr, align 4
  %0 = load %struct.elem*, %struct.elem** %t.addr, align 4
  %cmp = icmp ne %struct.elem* %0, null
  br i1 %cmp, label %if.then, label %if.end71

if.then:                                          ; preds = %entry
  %1 = load %struct.elem*, %struct.elem** %t.addr, align 4
  %left = getelementptr inbounds %struct.elem, %struct.elem* %1, i32 0, i32 1
  %2 = load %struct.elem*, %struct.elem** %left, align 4
  %cmp1 = icmp ne %struct.elem* %2, null
  br i1 %cmp1, label %land.lhs.true, label %if.else

land.lhs.true:                                    ; preds = %if.then
  %3 = load %struct.elem*, %struct.elem** %t.addr, align 4
  %left2 = getelementptr inbounds %struct.elem, %struct.elem* %3, i32 0, i32 1
  %4 = load %struct.elem*, %struct.elem** %left2, align 4
  %data = getelementptr inbounds %struct.elem, %struct.elem* %4, i32 0, i32 0
  %arrayidx = getelementptr inbounds [10 x i8], [10 x i8]* %data, i32 0, i32 0
  %5 = load i8, i8* %arrayidx, align 4
  %call = call i32 @isOperator(i8 signext %5)
  %cmp3 = icmp eq i32 %call, 1
  br i1 %cmp3, label %land.lhs.true4, label %if.else

land.lhs.true4:                                   ; preds = %land.lhs.true
  %6 = load %struct.elem*, %struct.elem** %t.addr, align 4
  %data5 = getelementptr inbounds %struct.elem, %struct.elem* %6, i32 0, i32 0
  %arrayidx6 = getelementptr inbounds [10 x i8], [10 x i8]* %data5, i32 0, i32 0
  %7 = load i8, i8* %arrayidx6, align 4
  %8 = load %struct.elem*, %struct.elem** %t.addr, align 4
  %left7 = getelementptr inbounds %struct.elem, %struct.elem* %8, i32 0, i32 1
  %9 = load %struct.elem*, %struct.elem** %left7, align 4
  %data8 = getelementptr inbounds %struct.elem, %struct.elem* %9, i32 0, i32 0
  %arrayidx9 = getelementptr inbounds [10 x i8], [10 x i8]* %data8, i32 0, i32 0
  %10 = load i8, i8* %arrayidx9, align 4
  %call10 = call i32 @precedenceCheck(i8 signext %7, i8 signext %10)
  %cmp11 = icmp eq i32 %call10, 1
  br i1 %cmp11, label %if.then24, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %land.lhs.true4
  %11 = load %struct.elem*, %struct.elem** %t.addr, align 4
  %data12 = getelementptr inbounds %struct.elem, %struct.elem* %11, i32 0, i32 0
  %arrayidx13 = getelementptr inbounds [10 x i8], [10 x i8]* %data12, i32 0, i32 0
  %12 = load i8, i8* %arrayidx13, align 4
  %13 = load %struct.elem*, %struct.elem** %t.addr, align 4
  %left14 = getelementptr inbounds %struct.elem, %struct.elem* %13, i32 0, i32 1
  %14 = load %struct.elem*, %struct.elem** %left14, align 4
  %data15 = getelementptr inbounds %struct.elem, %struct.elem* %14, i32 0, i32 0
  %arrayidx16 = getelementptr inbounds [10 x i8], [10 x i8]* %data15, i32 0, i32 0
  %15 = load i8, i8* %arrayidx16, align 4
  %call17 = call i32 @precedenceCheck(i8 signext %12, i8 signext %15)
  %cmp18 = icmp eq i32 %call17, 0
  br i1 %cmp18, label %land.lhs.true19, label %if.else

land.lhs.true19:                                  ; preds = %lor.lhs.false
  %16 = load %struct.elem*, %struct.elem** %t.addr, align 4
  %data20 = getelementptr inbounds %struct.elem, %struct.elem* %16, i32 0, i32 0
  %arrayidx21 = getelementptr inbounds [10 x i8], [10 x i8]* %data20, i32 0, i32 0
  %17 = load i8, i8* %arrayidx21, align 4
  %conv = sext i8 %17 to i32
  %cmp22 = icmp eq i32 %conv, 94
  br i1 %cmp22, label %if.then24, label %if.else

if.then24:                                        ; preds = %land.lhs.true19, %land.lhs.true4
  %call25 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([2 x i8], [2 x i8]* @.str, i32 0, i32 0))
  %18 = load %struct.elem*, %struct.elem** %t.addr, align 4
  %left26 = getelementptr inbounds %struct.elem, %struct.elem* %18, i32 0, i32 1
  %19 = load %struct.elem*, %struct.elem** %left26, align 4
  call void @inorder(%struct.elem* %19)
  %call27 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([2 x i8], [2 x i8]* @.str.1, i32 0, i32 0))
  br label %if.end

if.else:                                          ; preds = %land.lhs.true19, %lor.lhs.false, %land.lhs.true, %if.then
  %20 = load %struct.elem*, %struct.elem** %t.addr, align 4
  %left28 = getelementptr inbounds %struct.elem, %struct.elem* %20, i32 0, i32 1
  %21 = load %struct.elem*, %struct.elem** %left28, align 4
  call void @inorder(%struct.elem* %21)
  br label %if.end

if.end:                                           ; preds = %if.else, %if.then24
  %22 = load %struct.elem*, %struct.elem** %t.addr, align 4
  %data29 = getelementptr inbounds %struct.elem, %struct.elem* %22, i32 0, i32 0
  %arraydecay = getelementptr inbounds [10 x i8], [10 x i8]* %data29, i32 0, i32 0
  %call30 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.2, i32 0, i32 0), i8* %arraydecay)
  %23 = load %struct.elem*, %struct.elem** %t.addr, align 4
  %right = getelementptr inbounds %struct.elem, %struct.elem* %23, i32 0, i32 2
  %24 = load %struct.elem*, %struct.elem** %right, align 4
  %cmp31 = icmp ne %struct.elem* %24, null
  br i1 %cmp31, label %land.lhs.true33, label %if.else68

land.lhs.true33:                                  ; preds = %if.end
  %25 = load %struct.elem*, %struct.elem** %t.addr, align 4
  %right34 = getelementptr inbounds %struct.elem, %struct.elem* %25, i32 0, i32 2
  %26 = load %struct.elem*, %struct.elem** %right34, align 4
  %data35 = getelementptr inbounds %struct.elem, %struct.elem* %26, i32 0, i32 0
  %arrayidx36 = getelementptr inbounds [10 x i8], [10 x i8]* %data35, i32 0, i32 0
  %27 = load i8, i8* %arrayidx36, align 4
  %call37 = call i32 @isOperator(i8 signext %27)
  %cmp38 = icmp eq i32 %call37, 1
  br i1 %cmp38, label %land.lhs.true40, label %if.else68

land.lhs.true40:                                  ; preds = %land.lhs.true33
  %28 = load %struct.elem*, %struct.elem** %t.addr, align 4
  %data41 = getelementptr inbounds %struct.elem, %struct.elem* %28, i32 0, i32 0
  %arrayidx42 = getelementptr inbounds [10 x i8], [10 x i8]* %data41, i32 0, i32 0
  %29 = load i8, i8* %arrayidx42, align 4
  %30 = load %struct.elem*, %struct.elem** %t.addr, align 4
  %right43 = getelementptr inbounds %struct.elem, %struct.elem* %30, i32 0, i32 2
  %31 = load %struct.elem*, %struct.elem** %right43, align 4
  %data44 = getelementptr inbounds %struct.elem, %struct.elem* %31, i32 0, i32 0
  %arrayidx45 = getelementptr inbounds [10 x i8], [10 x i8]* %data44, i32 0, i32 0
  %32 = load i8, i8* %arrayidx45, align 4
  %call46 = call i32 @precedenceCheck(i8 signext %29, i8 signext %32)
  %cmp47 = icmp eq i32 %call46, 1
  br i1 %cmp47, label %if.then64, label %lor.lhs.false49

lor.lhs.false49:                                  ; preds = %land.lhs.true40
  %33 = load %struct.elem*, %struct.elem** %t.addr, align 4
  %data50 = getelementptr inbounds %struct.elem, %struct.elem* %33, i32 0, i32 0
  %arrayidx51 = getelementptr inbounds [10 x i8], [10 x i8]* %data50, i32 0, i32 0
  %34 = load i8, i8* %arrayidx51, align 4
  %35 = load %struct.elem*, %struct.elem** %t.addr, align 4
  %right52 = getelementptr inbounds %struct.elem, %struct.elem* %35, i32 0, i32 2
  %36 = load %struct.elem*, %struct.elem** %right52, align 4
  %data53 = getelementptr inbounds %struct.elem, %struct.elem* %36, i32 0, i32 0
  %arrayidx54 = getelementptr inbounds [10 x i8], [10 x i8]* %data53, i32 0, i32 0
  %37 = load i8, i8* %arrayidx54, align 4
  %call55 = call i32 @precedenceCheck(i8 signext %34, i8 signext %37)
  %cmp56 = icmp eq i32 %call55, 0
  br i1 %cmp56, label %land.lhs.true58, label %if.else68

land.lhs.true58:                                  ; preds = %lor.lhs.false49
  %38 = load %struct.elem*, %struct.elem** %t.addr, align 4
  %data59 = getelementptr inbounds %struct.elem, %struct.elem* %38, i32 0, i32 0
  %arrayidx60 = getelementptr inbounds [10 x i8], [10 x i8]* %data59, i32 0, i32 0
  %39 = load i8, i8* %arrayidx60, align 4
  %conv61 = sext i8 %39 to i32
  %cmp62 = icmp ne i32 %conv61, 94
  br i1 %cmp62, label %if.then64, label %if.else68

if.then64:                                        ; preds = %land.lhs.true58, %land.lhs.true40
  %call65 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([2 x i8], [2 x i8]* @.str, i32 0, i32 0))
  %40 = load %struct.elem*, %struct.elem** %t.addr, align 4
  %right66 = getelementptr inbounds %struct.elem, %struct.elem* %40, i32 0, i32 2
  %41 = load %struct.elem*, %struct.elem** %right66, align 4
  call void @inorder(%struct.elem* %41)
  %call67 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([2 x i8], [2 x i8]* @.str.1, i32 0, i32 0))
  br label %if.end70

if.else68:                                        ; preds = %land.lhs.true58, %lor.lhs.false49, %land.lhs.true33, %if.end
  %42 = load %struct.elem*, %struct.elem** %t.addr, align 4
  %right69 = getelementptr inbounds %struct.elem, %struct.elem* %42, i32 0, i32 2
  %43 = load %struct.elem*, %struct.elem** %right69, align 4
  call void @inorder(%struct.elem* %43)
  br label %if.end70

if.end70:                                         ; preds = %if.else68, %if.then64
  br label %if.end71

if.end71:                                         ; preds = %if.end70, %entry
  ret void
}

declare i32 @printf(i8* %0, ...) #1

; Function Attrs: noinline nounwind optnone
define hidden i8* @getNextString() #0 {
entry:
  %0 = load i32, i32* @counter, align 4
  %cmp = icmp slt i32 %0, 0
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %call = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([15 x i8], [15 x i8]* @.str.3, i32 0, i32 0))
  call void @exit(i32 0) #4
  unreachable

if.end:                                           ; preds = %entry
  %1 = load i8**, i8*** @components, align 4
  %2 = load i32, i32* @counter, align 4
  %dec = add nsw i32 %2, -1
  store i32 %dec, i32* @counter, align 4
  %arrayidx = getelementptr inbounds i8*, i8** %1, i32 %2
  %3 = load i8*, i8** %arrayidx, align 4
  ret i8* %3
}

; Function Attrs: noreturn
declare void @exit(i32 %0) #2

; Function Attrs: noinline nounwind optnone
define hidden %struct.elem* @buildTree(i8* %obj, i8* %trace) #0 {
entry:
  %obj.addr = alloca i8*, align 4
  %trace.addr = alloca i8*, align 4
  %t = alloca %struct.elem*, align 4
  store i8* %obj, i8** %obj.addr, align 4
  store i8* %trace, i8** %trace.addr, align 4
  %call = call noalias i8* @malloc(i32 20)
  %0 = bitcast i8* %call to %struct.elem*
  store %struct.elem* %0, %struct.elem** %t, align 4
  %1 = load %struct.elem*, %struct.elem** %t, align 4
  %data = getelementptr inbounds %struct.elem, %struct.elem* %1, i32 0, i32 0
  %arraydecay = getelementptr inbounds [10 x i8], [10 x i8]* %data, i32 0, i32 0
  %2 = load i8*, i8** %obj.addr, align 4
  %call1 = call i8* @strcpy(i8* %arraydecay, i8* %2)
  %3 = load i8*, i8** %obj.addr, align 4
  %arrayidx = getelementptr inbounds i8, i8* %3, i32 0
  %4 = load i8, i8* %arrayidx, align 1
  %call2 = call i32 @isOperator(i8 signext %4)
  %cmp = icmp eq i32 %call2, 1
  br i1 %cmp, label %cond.true, label %cond.false

cond.true:                                        ; preds = %entry
  %call3 = call i8* @getNextString()
  %5 = load i8*, i8** %trace.addr, align 4
  %call4 = call %struct.elem* @buildTree(i8* %call3, i8* %5)
  br label %cond.end

cond.false:                                       ; preds = %entry
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi %struct.elem* [ %call4, %cond.true ], [ null, %cond.false ]
  %6 = load %struct.elem*, %struct.elem** %t, align 4
  %right = getelementptr inbounds %struct.elem, %struct.elem* %6, i32 0, i32 2
  store %struct.elem* %cond, %struct.elem** %right, align 4
  %7 = load i8*, i8** %obj.addr, align 4
  %arrayidx5 = getelementptr inbounds i8, i8* %7, i32 0
  %8 = load i8, i8* %arrayidx5, align 1
  %call6 = call i32 @isOperator(i8 signext %8)
  %cmp7 = icmp eq i32 %call6, 1
  br i1 %cmp7, label %cond.true8, label %cond.false11

cond.true8:                                       ; preds = %cond.end
  %call9 = call i8* @getNextString()
  %9 = load i8*, i8** %trace.addr, align 4
  %call10 = call %struct.elem* @buildTree(i8* %call9, i8* %9)
  br label %cond.end12

cond.false11:                                     ; preds = %cond.end
  br label %cond.end12

cond.end12:                                       ; preds = %cond.false11, %cond.true8
  %cond13 = phi %struct.elem* [ %call10, %cond.true8 ], [ null, %cond.false11 ]
  %10 = load %struct.elem*, %struct.elem** %t, align 4
  %left = getelementptr inbounds %struct.elem, %struct.elem* %10, i32 0, i32 1
  store %struct.elem* %cond13, %struct.elem** %left, align 4
  %11 = load i8*, i8** %trace.addr, align 4
  %cmp14 = icmp ne i8* %11, null
  br i1 %cmp14, label %if.then, label %if.end

if.then:                                          ; preds = %cond.end12
  %call15 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([2 x i8], [2 x i8]* @.str.4, i32 0, i32 0))
  %12 = load %struct.elem*, %struct.elem** %t, align 4
  call void @inorder(%struct.elem* %12)
  br label %if.end

if.end:                                           ; preds = %if.then, %cond.end12
  %13 = load %struct.elem*, %struct.elem** %t, align 4
  ret %struct.elem* %13
}

declare noalias i8* @malloc(i32 %0) #1

declare i8* @strcpy(i8* %0, i8* %1) #1

; Function Attrs: noinline nounwind optnone
define hidden i32 @checkRPN() #0 {
entry:
  %retval = alloca i32, align 4
  %i = alloca i32, align 4
  %operSum = alloca i32, align 4
  %numberSum = alloca i32, align 4
  store i32 0, i32* %operSum, align 4
  store i32 0, i32* %numberSum, align 4
  %0 = load i8**, i8*** @components, align 4
  %1 = load i32, i32* @counter, align 4
  %arrayidx = getelementptr inbounds i8*, i8** %0, i32 %1
  %2 = load i8*, i8** %arrayidx, align 4
  %arrayidx1 = getelementptr inbounds i8, i8* %2, i32 0
  %3 = load i8, i8* %arrayidx1, align 1
  %call = call i32 @isOperator(i8 signext %3)
  %cmp = icmp eq i32 %call, 0
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  store i32 0, i32* %retval, align 4
  br label %return

if.end:                                           ; preds = %entry
  store i32 0, i32* %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.end
  %4 = load i32, i32* %i, align 4
  %5 = load i32, i32* @counter, align 4
  %cmp2 = icmp sle i32 %4, %5
  br i1 %cmp2, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %6 = load i8**, i8*** @components, align 4
  %7 = load i32, i32* %i, align 4
  %arrayidx3 = getelementptr inbounds i8*, i8** %6, i32 %7
  %8 = load i8*, i8** %arrayidx3, align 4
  %arrayidx4 = getelementptr inbounds i8, i8* %8, i32 0
  %9 = load i8, i8* %arrayidx4, align 1
  %call5 = call i32 @isOperator(i8 signext %9)
  %cmp6 = icmp eq i32 %call5, 1
  br i1 %cmp6, label %cond.true, label %cond.false

cond.true:                                        ; preds = %for.body
  %10 = load i32, i32* %operSum, align 4
  %inc = add nsw i32 %10, 1
  store i32 %inc, i32* %operSum, align 4
  br label %cond.end

cond.false:                                       ; preds = %for.body
  %11 = load i32, i32* %numberSum, align 4
  %inc7 = add nsw i32 %11, 1
  store i32 %inc7, i32* %numberSum, align 4
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi i32 [ %10, %cond.true ], [ %11, %cond.false ]
  br label %for.inc

for.inc:                                          ; preds = %cond.end
  %12 = load i32, i32* %i, align 4
  %inc8 = add nsw i32 %12, 1
  store i32 %inc8, i32* %i, align 4
  br label %for.cond

for.end:                                          ; preds = %for.cond
  %13 = load i32, i32* %numberSum, align 4
  %14 = load i32, i32* %operSum, align 4
  %sub = sub nsw i32 %13, %14
  %cmp9 = icmp eq i32 %sub, 1
  %conv = zext i1 %cmp9 to i32
  store i32 %conv, i32* %retval, align 4
  br label %return

return:                                           ; preds = %for.end, %if.then
  %15 = load i32, i32* %retval, align 4
  ret i32 %15
}

; Function Attrs: noinline nounwind optnone
define hidden void @buildStack(i8* %str) #0 {
entry:
  %str.addr = alloca i8*, align 4
  %i = alloca i32, align 4
  %token = alloca i8*, align 4
  store i8* %str, i8** %str.addr, align 4
  store i32 0, i32* %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %0 = load i8*, i8** %str.addr, align 4
  %1 = load i32, i32* %i, align 4
  %arrayidx = getelementptr inbounds i8, i8* %0, i32 %1
  %2 = load i8, i8* %arrayidx, align 1
  %conv = sext i8 %2 to i32
  %cmp = icmp ne i32 %conv, 0
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %3 = load i8*, i8** %str.addr, align 4
  %4 = load i32, i32* %i, align 4
  %arrayidx2 = getelementptr inbounds i8, i8* %3, i32 %4
  %5 = load i8, i8* %arrayidx2, align 1
  %conv3 = sext i8 %5 to i32
  %cmp4 = icmp eq i32 %conv3, 32
  br i1 %cmp4, label %if.then, label %if.end

if.then:                                          ; preds = %for.body
  %6 = load i32, i32* @counter, align 4
  %inc = add nsw i32 %6, 1
  store i32 %inc, i32* @counter, align 4
  br label %if.end

if.end:                                           ; preds = %if.then, %for.body
  br label %for.inc

for.inc:                                          ; preds = %if.end
  %7 = load i32, i32* %i, align 4
  %inc6 = add nsw i32 %7, 1
  store i32 %inc6, i32* %i, align 4
  br label %for.cond

for.end:                                          ; preds = %for.cond
  %8 = load i32, i32* @counter, align 4
  %add = add nsw i32 %8, 1
  %mul = mul i32 %add, 4
  %call = call noalias i8* @malloc(i32 %mul)
  %9 = bitcast i8* %call to i8**
  store i8** %9, i8*** @components, align 4
  %10 = load i8*, i8** %str.addr, align 4
  %call7 = call i8* @strtok(i8* %10, i8* getelementptr inbounds ([2 x i8], [2 x i8]* @.str.5, i32 0, i32 0))
  store i8* %call7, i8** %token, align 4
  store i32 0, i32* %i, align 4
  br label %while.cond

while.cond:                                       ; preds = %while.body, %for.end
  %11 = load i8*, i8** %token, align 4
  %cmp8 = icmp ne i8* %11, null
  br i1 %cmp8, label %while.body, label %while.end

while.body:                                       ; preds = %while.cond
  %12 = load i8*, i8** %token, align 4
  %call10 = call i32 @strlen(i8* %12) #5
  %mul11 = mul i32 %call10, 1
  %call12 = call noalias i8* @malloc(i32 %mul11)
  %13 = load i8**, i8*** @components, align 4
  %14 = load i32, i32* %i, align 4
  %arrayidx13 = getelementptr inbounds i8*, i8** %13, i32 %14
  store i8* %call12, i8** %arrayidx13, align 4
  %15 = load i8**, i8*** @components, align 4
  %16 = load i32, i32* %i, align 4
  %arrayidx14 = getelementptr inbounds i8*, i8** %15, i32 %16
  %17 = load i8*, i8** %arrayidx14, align 4
  %18 = load i8*, i8** %token, align 4
  %call15 = call i8* @strcpy(i8* %17, i8* %18)
  %call16 = call i8* @strtok(i8* null, i8* getelementptr inbounds ([2 x i8], [2 x i8]* @.str.5, i32 0, i32 0))
  store i8* %call16, i8** %token, align 4
  %19 = load i32, i32* %i, align 4
  %inc17 = add nsw i32 %19, 1
  store i32 %inc17, i32* %i, align 4
  br label %while.cond

while.end:                                        ; preds = %while.cond
  ret void
}

declare i8* @strtok(i8* %0, i8* %1) #1

; Function Attrs: nounwind readonly
declare i32 @strlen(i8* %0) #3

; Function Attrs: noinline nounwind optnone
define hidden i32 @__main_argc_argv(i32 %argC, i8** %argV) #0 {
entry:
  %retval = alloca i32, align 4
  %argC.addr = alloca i32, align 4
  %argV.addr = alloca i8**, align 4
  %i = alloca i32, align 4
  %t = alloca %struct.elem*, align 4
  store i32 0, i32* %retval, align 4
  store i32 %argC, i32* %argC.addr, align 4
  store i8** %argV, i8*** %argV.addr, align 4
  %0 = load i32, i32* %argC.addr, align 4
  %cmp = icmp eq i32 %0, 1
  br i1 %cmp, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  %1 = load i8**, i8*** %argV.addr, align 4
  %arrayidx = getelementptr inbounds i8*, i8** %1, i32 0
  %2 = load i8*, i8** %arrayidx, align 4
  %call = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([95 x i8], [95 x i8]* @.str.6, i32 0, i32 0), i8* %2)
  br label %if.end10

if.else:                                          ; preds = %entry
  %3 = load i8**, i8*** %argV.addr, align 4
  %arrayidx1 = getelementptr inbounds i8*, i8** %3, i32 1
  %4 = load i8*, i8** %arrayidx1, align 4
  call void @buildStack(i8* %4)
  %call2 = call i32 @checkRPN()
  %cmp3 = icmp eq i32 %call2, 0
  br i1 %cmp3, label %if.then4, label %if.end

if.then4:                                         ; preds = %if.else
  %call5 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([15 x i8], [15 x i8]* @.str.3, i32 0, i32 0))
  store i32 0, i32* %retval, align 4
  br label %return

if.end:                                           ; preds = %if.else
  %call6 = call i8* @getNextString()
  %5 = load i8**, i8*** %argV.addr, align 4
  %arrayidx7 = getelementptr inbounds i8*, i8** %5, i32 2
  %6 = load i8*, i8** %arrayidx7, align 4
  %call8 = call %struct.elem* @buildTree(i8* %call6, i8* %6)
  store %struct.elem* %call8, %struct.elem** %t, align 4
  %call9 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([27 x i8], [27 x i8]* @.str.7, i32 0, i32 0))
  %7 = load %struct.elem*, %struct.elem** %t, align 4
  call void @inorder(%struct.elem* %7)
  br label %if.end10

if.end10:                                         ; preds = %if.end, %if.then
  store i32 0, i32* %retval, align 4
  br label %return

return:                                           ; preds = %if.end10, %if.then4
  %8 = load i32, i32* %retval, align 4
  ret i32 %8
}

attributes #0 = { noinline nounwind optnone "correctly-rounded-divide-sqrt-fp-math"="false" "disable-tail-calls"="false" "frame-pointer"="none" "less-precise-fpmad"="false" "min-legal-vector-width"="0" "no-infs-fp-math"="false" "no-jump-tables"="false" "no-nans-fp-math"="false" "no-signed-zeros-fp-math"="false" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="generic" "unsafe-fp-math"="false" "use-soft-float"="false" }
attributes #1 = { "correctly-rounded-divide-sqrt-fp-math"="false" "disable-tail-calls"="false" "frame-pointer"="none" "less-precise-fpmad"="false" "no-infs-fp-math"="false" "no-nans-fp-math"="false" "no-signed-zeros-fp-math"="false" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="generic" "unsafe-fp-math"="false" "use-soft-float"="false" }
attributes #2 = { noreturn "correctly-rounded-divide-sqrt-fp-math"="false" "disable-tail-calls"="false" "frame-pointer"="none" "less-precise-fpmad"="false" "no-infs-fp-math"="false" "no-nans-fp-math"="false" "no-signed-zeros-fp-math"="false" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="generic" "unsafe-fp-math"="false" "use-soft-float"="false" }
attributes #3 = { nounwind readonly "correctly-rounded-divide-sqrt-fp-math"="false" "disable-tail-calls"="false" "frame-pointer"="none" "less-precise-fpmad"="false" "no-infs-fp-math"="false" "no-nans-fp-math"="false" "no-signed-zeros-fp-math"="false" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="generic" "unsafe-fp-math"="false" "use-soft-float"="false" }
attributes #4 = { noreturn }
attributes #5 = { nounwind readonly }

!llvm.module.flags = !{!0}
!llvm.ident = !{!1}

!0 = !{i32 1, !"wchar_size", i32 4}
!1 = !{!"clang version 11.0.0 (https://github.com/Jacarte/llvm-project.git 0f6dea67136cc1e0b3d200eb2bb165628970c44b)"}

; Replacing "  %mul11 = mul i32 %call10, 1"
; from ""
; with "  %call10 = call i32 @strlen(i8* %12) #4" in:
"%0:i32 = var
%1:i32 = mul 1:i32, %0
cand %1 %0
"
; with "  %call10 = call i32 @strlen(i8* %12) #4"

Module after replacement:
; ModuleID = './Parsing-RPN_to_infix_conversion.c.bc'
source_filename = "./Parsing-RPN_to_infix_conversion.c"
target datalayout = "e-m:e-p:32:32-i64:64-n32:64-S128"
target triple = "wasm32-unknown-wasi"

%struct.elem = type { [10 x i8], %struct.elem*, %struct.elem* }

@counter = hidden global i32 0, align 4
@.str = private unnamed_addr constant [2 x i8] c"(\00", align 1
@.str.1 = private unnamed_addr constant [2 x i8] c")\00", align 1
@.str.2 = private unnamed_addr constant [5 x i8] c" %s \00", align 1
@.str.3 = private unnamed_addr constant [15 x i8] c"\0AInvalid RPN !\00", align 1
@components = hidden global i8** null, align 4
@.str.4 = private unnamed_addr constant [2 x i8] c"\0A\00", align 1
@.str.5 = private unnamed_addr constant [2 x i8] c" \00", align 1
@.str.6 = private unnamed_addr constant [95 x i8] c"Usage : %s <RPN expression enclosed by quotes> <optional parameter to trace the build process>\00", align 1
@.str.7 = private unnamed_addr constant [27 x i8] c"\0AFinal infix expression : \00", align 1

; Function Attrs: noinline nounwind optnone
define hidden i32 @precedenceCheck(i8 signext %oper1, i8 signext %oper2) #0 {
entry:
  %oper1.addr = alloca i8, align 1
  %oper2.addr = alloca i8, align 1
  store i8 %oper1, i8* %oper1.addr, align 1
  store i8 %oper2, i8* %oper2.addr, align 1
  %0 = load i8, i8* %oper1.addr, align 1
  %conv = sext i8 %0 to i32
  %1 = load i8, i8* %oper2.addr, align 1
  %conv1 = sext i8 %1 to i32
  %cmp = icmp eq i32 %conv, %conv1
  br i1 %cmp, label %cond.true, label %cond.false

cond.true:                                        ; preds = %entry
  br label %cond.end61

cond.false:                                       ; preds = %entry
  %2 = load i8, i8* %oper1.addr, align 1
  %conv3 = sext i8 %2 to i32
  %cmp4 = icmp eq i32 %conv3, 94
  br i1 %cmp4, label %cond.true6, label %cond.false7

cond.true6:                                       ; preds = %cond.false
  br label %cond.end59

cond.false7:                                      ; preds = %cond.false
  %3 = load i8, i8* %oper2.addr, align 1
  %conv8 = sext i8 %3 to i32
  %cmp9 = icmp eq i32 %conv8, 94
  br i1 %cmp9, label %cond.true11, label %cond.false12

cond.true11:                                      ; preds = %cond.false7
  br label %cond.end57

cond.false12:                                     ; preds = %cond.false7
  %4 = load i8, i8* %oper1.addr, align 1
  %conv13 = sext i8 %4 to i32
  %cmp14 = icmp eq i32 %conv13, 47
  br i1 %cmp14, label %cond.true16, label %cond.false17

cond.true16:                                      ; preds = %cond.false12
  br label %cond.end55

cond.false17:                                     ; preds = %cond.false12
  %5 = load i8, i8* %oper2.addr, align 1
  %conv18 = sext i8 %5 to i32
  %cmp19 = icmp eq i32 %conv18, 47
  br i1 %cmp19, label %cond.true21, label %cond.false22

cond.true21:                                      ; preds = %cond.false17
  br label %cond.end53

cond.false22:                                     ; preds = %cond.false17
  %6 = load i8, i8* %oper1.addr, align 1
  %conv23 = sext i8 %6 to i32
  %cmp24 = icmp eq i32 %conv23, 42
  br i1 %cmp24, label %cond.true26, label %cond.false27

cond.true26:                                      ; preds = %cond.false22
  br label %cond.end51

cond.false27:                                     ; preds = %cond.false22
  %7 = load i8, i8* %oper2.addr, align 1
  %conv28 = sext i8 %7 to i32
  %cmp29 = icmp eq i32 %conv28, 42
  br i1 %cmp29, label %cond.true31, label %cond.false32

cond.true31:                                      ; preds = %cond.false27
  br label %cond.end49

cond.false32:                                     ; preds = %cond.false27
  %8 = load i8, i8* %oper1.addr, align 1
  %conv33 = sext i8 %8 to i32
  %cmp34 = icmp eq i32 %conv33, 43
  br i1 %cmp34, label %cond.true36, label %cond.false37

cond.true36:                                      ; preds = %cond.false32
  br label %cond.end47

cond.false37:                                     ; preds = %cond.false32
  %9 = load i8, i8* %oper2.addr, align 1
  %conv38 = sext i8 %9 to i32
  %cmp39 = icmp eq i32 %conv38, 43
  br i1 %cmp39, label %cond.true41, label %cond.false42

cond.true41:                                      ; preds = %cond.false37
  br label %cond.end

cond.false42:                                     ; preds = %cond.false37
  %10 = load i8, i8* %oper1.addr, align 1
  %conv43 = sext i8 %10 to i32
  %cmp44 = icmp eq i32 %conv43, 45
  %11 = zext i1 %cmp44 to i64
  %cond = select i1 %cmp44, i32 1, i32 2
  br label %cond.end

cond.end:                                         ; preds = %cond.false42, %cond.true41
  %cond46 = phi i32 [ 2, %cond.true41 ], [ %cond, %cond.false42 ]
  br label %cond.end47

cond.end47:                                       ; preds = %cond.end, %cond.true36
  %cond48 = phi i32 [ 1, %cond.true36 ], [ %cond46, %cond.end ]
  br label %cond.end49

cond.end49:                                       ; preds = %cond.end47, %cond.true31
  %cond50 = phi i32 [ 2, %cond.true31 ], [ %cond48, %cond.end47 ]
  br label %cond.end51

cond.end51:                                       ; preds = %cond.end49, %cond.true26
  %cond52 = phi i32 [ 1, %cond.true26 ], [ %cond50, %cond.end49 ]
  br label %cond.end53

cond.end53:                                       ; preds = %cond.end51, %cond.true21
  %cond54 = phi i32 [ 2, %cond.true21 ], [ %cond52, %cond.end51 ]
  br label %cond.end55

cond.end55:                                       ; preds = %cond.end53, %cond.true16
  %cond56 = phi i32 [ 1, %cond.true16 ], [ %cond54, %cond.end53 ]
  br label %cond.end57

cond.end57:                                       ; preds = %cond.end55, %cond.true11
  %cond58 = phi i32 [ 2, %cond.true11 ], [ %cond56, %cond.end55 ]
  br label %cond.end59

cond.end59:                                       ; preds = %cond.end57, %cond.true6
  %cond60 = phi i32 [ 1, %cond.true6 ], [ %cond58, %cond.end57 ]
  br label %cond.end61

cond.end61:                                       ; preds = %cond.end59, %cond.true
  %cond62 = phi i32 [ 0, %cond.true ], [ %cond60, %cond.end59 ]
  ret i32 %cond62
}

; Function Attrs: noinline nounwind optnone
define hidden i32 @isOperator(i8 signext %c) #0 {
entry:
  %c.addr = alloca i8, align 1
  store i8 %c, i8* %c.addr, align 1
  %0 = load i8, i8* %c.addr, align 1
  %conv = sext i8 %0 to i32
  %cmp = icmp eq i32 %conv, 43
  br i1 %cmp, label %lor.end, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %entry
  %1 = load i8, i8* %c.addr, align 1
  %conv2 = sext i8 %1 to i32
  %cmp3 = icmp eq i32 %conv2, 45
  br i1 %cmp3, label %lor.end, label %lor.lhs.false5

lor.lhs.false5:                                   ; preds = %lor.lhs.false
  %2 = load i8, i8* %c.addr, align 1
  %conv6 = sext i8 %2 to i32
  %cmp7 = icmp eq i32 %conv6, 42
  br i1 %cmp7, label %lor.end, label %lor.lhs.false9

lor.lhs.false9:                                   ; preds = %lor.lhs.false5
  %3 = load i8, i8* %c.addr, align 1
  %conv10 = sext i8 %3 to i32
  %cmp11 = icmp eq i32 %conv10, 47
  br i1 %cmp11, label %lor.end, label %lor.rhs

lor.rhs:                                          ; preds = %lor.lhs.false9
  %4 = load i8, i8* %c.addr, align 1
  %conv13 = sext i8 %4 to i32
  %cmp14 = icmp eq i32 %conv13, 94
  br label %lor.end

lor.end:                                          ; preds = %lor.rhs, %lor.lhs.false9, %lor.lhs.false5, %lor.lhs.false, %entry
  %5 = phi i1 [ true, %lor.lhs.false9 ], [ true, %lor.lhs.false5 ], [ true, %lor.lhs.false ], [ true, %entry ], [ %cmp14, %lor.rhs ]
  %lor.ext = zext i1 %5 to i32
  ret i32 %lor.ext
}

; Function Attrs: noinline nounwind optnone
define hidden void @inorder(%struct.elem* %t) #0 {
entry:
  %t.addr = alloca %struct.elem*, align 4
  store %struct.elem* %t, %struct.elem** %t.addr, align 4
  %0 = load %struct.elem*, %struct.elem** %t.addr, align 4
  %cmp = icmp ne %struct.elem* %0, null
  br i1 %cmp, label %if.then, label %if.end71

if.then:                                          ; preds = %entry
  %1 = load %struct.elem*, %struct.elem** %t.addr, align 4
  %left = getelementptr inbounds %struct.elem, %struct.elem* %1, i32 0, i32 1
  %2 = load %struct.elem*, %struct.elem** %left, align 4
  %cmp1 = icmp ne %struct.elem* %2, null
  br i1 %cmp1, label %land.lhs.true, label %if.else

land.lhs.true:                                    ; preds = %if.then
  %3 = load %struct.elem*, %struct.elem** %t.addr, align 4
  %left2 = getelementptr inbounds %struct.elem, %struct.elem* %3, i32 0, i32 1
  %4 = load %struct.elem*, %struct.elem** %left2, align 4
  %data = getelementptr inbounds %struct.elem, %struct.elem* %4, i32 0, i32 0
  %arrayidx = getelementptr inbounds [10 x i8], [10 x i8]* %data, i32 0, i32 0
  %5 = load i8, i8* %arrayidx, align 4
  %call = call i32 @isOperator(i8 signext %5)
  %cmp3 = icmp eq i32 %call, 1
  br i1 %cmp3, label %land.lhs.true4, label %if.else

land.lhs.true4:                                   ; preds = %land.lhs.true
  %6 = load %struct.elem*, %struct.elem** %t.addr, align 4
  %data5 = getelementptr inbounds %struct.elem, %struct.elem* %6, i32 0, i32 0
  %arrayidx6 = getelementptr inbounds [10 x i8], [10 x i8]* %data5, i32 0, i32 0
  %7 = load i8, i8* %arrayidx6, align 4
  %8 = load %struct.elem*, %struct.elem** %t.addr, align 4
  %left7 = getelementptr inbounds %struct.elem, %struct.elem* %8, i32 0, i32 1
  %9 = load %struct.elem*, %struct.elem** %left7, align 4
  %data8 = getelementptr inbounds %struct.elem, %struct.elem* %9, i32 0, i32 0
  %arrayidx9 = getelementptr inbounds [10 x i8], [10 x i8]* %data8, i32 0, i32 0
  %10 = load i8, i8* %arrayidx9, align 4
  %call10 = call i32 @precedenceCheck(i8 signext %7, i8 signext %10)
  %cmp11 = icmp eq i32 %call10, 1
  br i1 %cmp11, label %if.then24, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %land.lhs.true4
  %11 = load %struct.elem*, %struct.elem** %t.addr, align 4
  %data12 = getelementptr inbounds %struct.elem, %struct.elem* %11, i32 0, i32 0
  %arrayidx13 = getelementptr inbounds [10 x i8], [10 x i8]* %data12, i32 0, i32 0
  %12 = load i8, i8* %arrayidx13, align 4
  %13 = load %struct.elem*, %struct.elem** %t.addr, align 4
  %left14 = getelementptr inbounds %struct.elem, %struct.elem* %13, i32 0, i32 1
  %14 = load %struct.elem*, %struct.elem** %left14, align 4
  %data15 = getelementptr inbounds %struct.elem, %struct.elem* %14, i32 0, i32 0
  %arrayidx16 = getelementptr inbounds [10 x i8], [10 x i8]* %data15, i32 0, i32 0
  %15 = load i8, i8* %arrayidx16, align 4
  %call17 = call i32 @precedenceCheck(i8 signext %12, i8 signext %15)
  %cmp18 = icmp eq i32 %call17, 0
  br i1 %cmp18, label %land.lhs.true19, label %if.else

land.lhs.true19:                                  ; preds = %lor.lhs.false
  %16 = load %struct.elem*, %struct.elem** %t.addr, align 4
  %data20 = getelementptr inbounds %struct.elem, %struct.elem* %16, i32 0, i32 0
  %arrayidx21 = getelementptr inbounds [10 x i8], [10 x i8]* %data20, i32 0, i32 0
  %17 = load i8, i8* %arrayidx21, align 4
  %conv = sext i8 %17 to i32
  %cmp22 = icmp eq i32 %conv, 94
  br i1 %cmp22, label %if.then24, label %if.else

if.then24:                                        ; preds = %land.lhs.true19, %land.lhs.true4
  %call25 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([2 x i8], [2 x i8]* @.str, i32 0, i32 0))
  %18 = load %struct.elem*, %struct.elem** %t.addr, align 4
  %left26 = getelementptr inbounds %struct.elem, %struct.elem* %18, i32 0, i32 1
  %19 = load %struct.elem*, %struct.elem** %left26, align 4
  call void @inorder(%struct.elem* %19)
  %call27 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([2 x i8], [2 x i8]* @.str.1, i32 0, i32 0))
  br label %if.end

if.else:                                          ; preds = %land.lhs.true19, %lor.lhs.false, %land.lhs.true, %if.then
  %20 = load %struct.elem*, %struct.elem** %t.addr, align 4
  %left28 = getelementptr inbounds %struct.elem, %struct.elem* %20, i32 0, i32 1
  %21 = load %struct.elem*, %struct.elem** %left28, align 4
  call void @inorder(%struct.elem* %21)
  br label %if.end

if.end:                                           ; preds = %if.else, %if.then24
  %22 = load %struct.elem*, %struct.elem** %t.addr, align 4
  %data29 = getelementptr inbounds %struct.elem, %struct.elem* %22, i32 0, i32 0
  %arraydecay = getelementptr inbounds [10 x i8], [10 x i8]* %data29, i32 0, i32 0
  %call30 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.2, i32 0, i32 0), i8* %arraydecay)
  %23 = load %struct.elem*, %struct.elem** %t.addr, align 4
  %right = getelementptr inbounds %struct.elem, %struct.elem* %23, i32 0, i32 2
  %24 = load %struct.elem*, %struct.elem** %right, align 4
  %cmp31 = icmp ne %struct.elem* %24, null
  br i1 %cmp31, label %land.lhs.true33, label %if.else68

land.lhs.true33:                                  ; preds = %if.end
  %25 = load %struct.elem*, %struct.elem** %t.addr, align 4
  %right34 = getelementptr inbounds %struct.elem, %struct.elem* %25, i32 0, i32 2
  %26 = load %struct.elem*, %struct.elem** %right34, align 4
  %data35 = getelementptr inbounds %struct.elem, %struct.elem* %26, i32 0, i32 0
  %arrayidx36 = getelementptr inbounds [10 x i8], [10 x i8]* %data35, i32 0, i32 0
  %27 = load i8, i8* %arrayidx36, align 4
  %call37 = call i32 @isOperator(i8 signext %27)
  %cmp38 = icmp eq i32 %call37, 1
  br i1 %cmp38, label %land.lhs.true40, label %if.else68

land.lhs.true40:                                  ; preds = %land.lhs.true33
  %28 = load %struct.elem*, %struct.elem** %t.addr, align 4
  %data41 = getelementptr inbounds %struct.elem, %struct.elem* %28, i32 0, i32 0
  %arrayidx42 = getelementptr inbounds [10 x i8], [10 x i8]* %data41, i32 0, i32 0
  %29 = load i8, i8* %arrayidx42, align 4
  %30 = load %struct.elem*, %struct.elem** %t.addr, align 4
  %right43 = getelementptr inbounds %struct.elem, %struct.elem* %30, i32 0, i32 2
  %31 = load %struct.elem*, %struct.elem** %right43, align 4
  %data44 = getelementptr inbounds %struct.elem, %struct.elem* %31, i32 0, i32 0
  %arrayidx45 = getelementptr inbounds [10 x i8], [10 x i8]* %data44, i32 0, i32 0
  %32 = load i8, i8* %arrayidx45, align 4
  %call46 = call i32 @precedenceCheck(i8 signext %29, i8 signext %32)
  %cmp47 = icmp eq i32 %call46, 1
  br i1 %cmp47, label %if.then64, label %lor.lhs.false49

lor.lhs.false49:                                  ; preds = %land.lhs.true40
  %33 = load %struct.elem*, %struct.elem** %t.addr, align 4
  %data50 = getelementptr inbounds %struct.elem, %struct.elem* %33, i32 0, i32 0
  %arrayidx51 = getelementptr inbounds [10 x i8], [10 x i8]* %data50, i32 0, i32 0
  %34 = load i8, i8* %arrayidx51, align 4
  %35 = load %struct.elem*, %struct.elem** %t.addr, align 4
  %right52 = getelementptr inbounds %struct.elem, %struct.elem* %35, i32 0, i32 2
  %36 = load %struct.elem*, %struct.elem** %right52, align 4
  %data53 = getelementptr inbounds %struct.elem, %struct.elem* %36, i32 0, i32 0
  %arrayidx54 = getelementptr inbounds [10 x i8], [10 x i8]* %data53, i32 0, i32 0
  %37 = load i8, i8* %arrayidx54, align 4
  %call55 = call i32 @precedenceCheck(i8 signext %34, i8 signext %37)
  %cmp56 = icmp eq i32 %call55, 0
  br i1 %cmp56, label %land.lhs.true58, label %if.else68

land.lhs.true58:                                  ; preds = %lor.lhs.false49
  %38 = load %struct.elem*, %struct.elem** %t.addr, align 4
  %data59 = getelementptr inbounds %struct.elem, %struct.elem* %38, i32 0, i32 0
  %arrayidx60 = getelementptr inbounds [10 x i8], [10 x i8]* %data59, i32 0, i32 0
  %39 = load i8, i8* %arrayidx60, align 4
  %conv61 = sext i8 %39 to i32
  %cmp62 = icmp ne i32 %conv61, 94
  br i1 %cmp62, label %if.then64, label %if.else68

if.then64:                                        ; preds = %land.lhs.true58, %land.lhs.true40
  %call65 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([2 x i8], [2 x i8]* @.str, i32 0, i32 0))
  %40 = load %struct.elem*, %struct.elem** %t.addr, align 4
  %right66 = getelementptr inbounds %struct.elem, %struct.elem* %40, i32 0, i32 2
  %41 = load %struct.elem*, %struct.elem** %right66, align 4
  call void @inorder(%struct.elem* %41)
  %call67 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([2 x i8], [2 x i8]* @.str.1, i32 0, i32 0))
  br label %if.end70

if.else68:                                        ; preds = %land.lhs.true58, %lor.lhs.false49, %land.lhs.true33, %if.end
  %42 = load %struct.elem*, %struct.elem** %t.addr, align 4
  %right69 = getelementptr inbounds %struct.elem, %struct.elem* %42, i32 0, i32 2
  %43 = load %struct.elem*, %struct.elem** %right69, align 4
  call void @inorder(%struct.elem* %43)
  br label %if.end70

if.end70:                                         ; preds = %if.else68, %if.then64
  br label %if.end71

if.end71:                                         ; preds = %if.end70, %entry
  ret void
}

declare i32 @printf(i8* %0, ...) #1

; Function Attrs: noinline nounwind optnone
define hidden i8* @getNextString() #0 {
entry:
  %0 = load i32, i32* @counter, align 4
  %cmp = icmp slt i32 %0, 0
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %call = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([15 x i8], [15 x i8]* @.str.3, i32 0, i32 0))
  call void @exit(i32 0) #4
  unreachable

if.end:                                           ; preds = %entry
  %1 = load i8**, i8*** @components, align 4
  %2 = load i32, i32* @counter, align 4
  %dec = add nsw i32 %2, -1
  store i32 %dec, i32* @counter, align 4
  %arrayidx = getelementptr inbounds i8*, i8** %1, i32 %2
  %3 = load i8*, i8** %arrayidx, align 4
  ret i8* %3
}

; Function Attrs: noreturn
declare void @exit(i32 %0) #2

; Function Attrs: noinline nounwind optnone
define hidden %struct.elem* @buildTree(i8* %obj, i8* %trace) #0 {
entry:
  %obj.addr = alloca i8*, align 4
  %trace.addr = alloca i8*, align 4
  %t = alloca %struct.elem*, align 4
  store i8* %obj, i8** %obj.addr, align 4
  store i8* %trace, i8** %trace.addr, align 4
  %call = call noalias i8* @malloc(i32 20)
  %0 = bitcast i8* %call to %struct.elem*
  store %struct.elem* %0, %struct.elem** %t, align 4
  %1 = load %struct.elem*, %struct.elem** %t, align 4
  %data = getelementptr inbounds %struct.elem, %struct.elem* %1, i32 0, i32 0
  %arraydecay = getelementptr inbounds [10 x i8], [10 x i8]* %data, i32 0, i32 0
  %2 = load i8*, i8** %obj.addr, align 4
  %call1 = call i8* @strcpy(i8* %arraydecay, i8* %2)
  %3 = load i8*, i8** %obj.addr, align 4
  %arrayidx = getelementptr inbounds i8, i8* %3, i32 0
  %4 = load i8, i8* %arrayidx, align 1
  %call2 = call i32 @isOperator(i8 signext %4)
  %cmp = icmp eq i32 %call2, 1
  br i1 %cmp, label %cond.true, label %cond.false

cond.true:                                        ; preds = %entry
  %call3 = call i8* @getNextString()
  %5 = load i8*, i8** %trace.addr, align 4
  %call4 = call %struct.elem* @buildTree(i8* %call3, i8* %5)
  br label %cond.end

cond.false:                                       ; preds = %entry
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi %struct.elem* [ %call4, %cond.true ], [ null, %cond.false ]
  %6 = load %struct.elem*, %struct.elem** %t, align 4
  %right = getelementptr inbounds %struct.elem, %struct.elem* %6, i32 0, i32 2
  store %struct.elem* %cond, %struct.elem** %right, align 4
  %7 = load i8*, i8** %obj.addr, align 4
  %arrayidx5 = getelementptr inbounds i8, i8* %7, i32 0
  %8 = load i8, i8* %arrayidx5, align 1
  %call6 = call i32 @isOperator(i8 signext %8)
  %cmp7 = icmp eq i32 %call6, 1
  br i1 %cmp7, label %cond.true8, label %cond.false11

cond.true8:                                       ; preds = %cond.end
  %call9 = call i8* @getNextString()
  %9 = load i8*, i8** %trace.addr, align 4
  %call10 = call %struct.elem* @buildTree(i8* %call9, i8* %9)
  br label %cond.end12

cond.false11:                                     ; preds = %cond.end
  br label %cond.end12

cond.end12:                                       ; preds = %cond.false11, %cond.true8
  %cond13 = phi %struct.elem* [ %call10, %cond.true8 ], [ null, %cond.false11 ]
  %10 = load %struct.elem*, %struct.elem** %t, align 4
  %left = getelementptr inbounds %struct.elem, %struct.elem* %10, i32 0, i32 1
  store %struct.elem* %cond13, %struct.elem** %left, align 4
  %11 = load i8*, i8** %trace.addr, align 4
  %cmp14 = icmp ne i8* %11, null
  br i1 %cmp14, label %if.then, label %if.end

if.then:                                          ; preds = %cond.end12
  %call15 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([2 x i8], [2 x i8]* @.str.4, i32 0, i32 0))
  %12 = load %struct.elem*, %struct.elem** %t, align 4
  call void @inorder(%struct.elem* %12)
  br label %if.end

if.end:                                           ; preds = %if.then, %cond.end12
  %13 = load %struct.elem*, %struct.elem** %t, align 4
  ret %struct.elem* %13
}

declare noalias i8* @malloc(i32 %0) #1

declare i8* @strcpy(i8* %0, i8* %1) #1

; Function Attrs: noinline nounwind optnone
define hidden i32 @checkRPN() #0 {
entry:
  %retval = alloca i32, align 4
  %i = alloca i32, align 4
  %operSum = alloca i32, align 4
  %numberSum = alloca i32, align 4
  store i32 0, i32* %operSum, align 4
  store i32 0, i32* %numberSum, align 4
  %0 = load i8**, i8*** @components, align 4
  %1 = load i32, i32* @counter, align 4
  %arrayidx = getelementptr inbounds i8*, i8** %0, i32 %1
  %2 = load i8*, i8** %arrayidx, align 4
  %arrayidx1 = getelementptr inbounds i8, i8* %2, i32 0
  %3 = load i8, i8* %arrayidx1, align 1
  %call = call i32 @isOperator(i8 signext %3)
  %cmp = icmp eq i32 %call, 0
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  store i32 0, i32* %retval, align 4
  br label %return

if.end:                                           ; preds = %entry
  store i32 0, i32* %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.end
  %4 = load i32, i32* %i, align 4
  %5 = load i32, i32* @counter, align 4
  %cmp2 = icmp sle i32 %4, %5
  br i1 %cmp2, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %6 = load i8**, i8*** @components, align 4
  %7 = load i32, i32* %i, align 4
  %arrayidx3 = getelementptr inbounds i8*, i8** %6, i32 %7
  %8 = load i8*, i8** %arrayidx3, align 4
  %arrayidx4 = getelementptr inbounds i8, i8* %8, i32 0
  %9 = load i8, i8* %arrayidx4, align 1
  %call5 = call i32 @isOperator(i8 signext %9)
  %cmp6 = icmp eq i32 %call5, 1
  br i1 %cmp6, label %cond.true, label %cond.false

cond.true:                                        ; preds = %for.body
  %10 = load i32, i32* %operSum, align 4
  %inc = add nsw i32 %10, 1
  store i32 %inc, i32* %operSum, align 4
  br label %cond.end

cond.false:                                       ; preds = %for.body
  %11 = load i32, i32* %numberSum, align 4
  %inc7 = add nsw i32 %11, 1
  store i32 %inc7, i32* %numberSum, align 4
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi i32 [ %10, %cond.true ], [ %11, %cond.false ]
  br label %for.inc

for.inc:                                          ; preds = %cond.end
  %12 = load i32, i32* %i, align 4
  %inc8 = add nsw i32 %12, 1
  store i32 %inc8, i32* %i, align 4
  br label %for.cond

for.end:                                          ; preds = %for.cond
  %13 = load i32, i32* %numberSum, align 4
  %14 = load i32, i32* %operSum, align 4
  %sub = sub nsw i32 %13, %14
  %cmp9 = icmp eq i32 %sub, 1
  %conv = zext i1 %cmp9 to i32
  store i32 %conv, i32* %retval, align 4
  br label %return

return:                                           ; preds = %for.end, %if.then
  %15 = load i32, i32* %retval, align 4
  ret i32 %15
}

; Function Attrs: noinline nounwind optnone
define hidden void @buildStack(i8* %str) #0 {
entry:
  %str.addr = alloca i8*, align 4
  %i = alloca i32, align 4
  %token = alloca i8*, align 4
  store i8* %str, i8** %str.addr, align 4
  store i32 0, i32* %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %0 = load i8*, i8** %str.addr, align 4
  %1 = load i32, i32* %i, align 4
  %arrayidx = getelementptr inbounds i8, i8* %0, i32 %1
  %2 = load i8, i8* %arrayidx, align 1
  %conv = sext i8 %2 to i32
  %cmp = icmp ne i32 %conv, 0
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %3 = load i8*, i8** %str.addr, align 4
  %4 = load i32, i32* %i, align 4
  %arrayidx2 = getelementptr inbounds i8, i8* %3, i32 %4
  %5 = load i8, i8* %arrayidx2, align 1
  %conv3 = sext i8 %5 to i32
  %cmp4 = icmp eq i32 %conv3, 32
  br i1 %cmp4, label %if.then, label %if.end

if.then:                                          ; preds = %for.body
  %6 = load i32, i32* @counter, align 4
  %inc = add nsw i32 %6, 1
  store i32 %inc, i32* @counter, align 4
  br label %if.end

if.end:                                           ; preds = %if.then, %for.body
  br label %for.inc

for.inc:                                          ; preds = %if.end
  %7 = load i32, i32* %i, align 4
  %inc6 = add nsw i32 %7, 1
  store i32 %inc6, i32* %i, align 4
  br label %for.cond

for.end:                                          ; preds = %for.cond
  %8 = load i32, i32* @counter, align 4
  %add = add nsw i32 %8, 1
  %mul = mul i32 %add, 4
  %call = call noalias i8* @malloc(i32 %mul)
  %9 = bitcast i8* %call to i8**
  store i8** %9, i8*** @components, align 4
  %10 = load i8*, i8** %str.addr, align 4
  %call7 = call i8* @strtok(i8* %10, i8* getelementptr inbounds ([2 x i8], [2 x i8]* @.str.5, i32 0, i32 0))
  store i8* %call7, i8** %token, align 4
  store i32 0, i32* %i, align 4
  br label %while.cond

while.cond:                                       ; preds = %while.body, %for.end
  %11 = load i8*, i8** %token, align 4
  %cmp8 = icmp ne i8* %11, null
  br i1 %cmp8, label %while.body, label %while.end

while.body:                                       ; preds = %while.cond
  %12 = load i8*, i8** %token, align 4
  %call10 = call i32 @strlen(i8* %12) #5
  %call12 = call noalias i8* @malloc(i32 %call10)
  %13 = load i8**, i8*** @components, align 4
  %14 = load i32, i32* %i, align 4
  %arrayidx13 = getelementptr inbounds i8*, i8** %13, i32 %14
  store i8* %call12, i8** %arrayidx13, align 4
  %15 = load i8**, i8*** @components, align 4
  %16 = load i32, i32* %i, align 4
  %arrayidx14 = getelementptr inbounds i8*, i8** %15, i32 %16
  %17 = load i8*, i8** %arrayidx14, align 4
  %18 = load i8*, i8** %token, align 4
  %call15 = call i8* @strcpy(i8* %17, i8* %18)
  %call16 = call i8* @strtok(i8* null, i8* getelementptr inbounds ([2 x i8], [2 x i8]* @.str.5, i32 0, i32 0))
  store i8* %call16, i8** %token, align 4
  %19 = load i32, i32* %i, align 4
  %inc17 = add nsw i32 %19, 1
  store i32 %inc17, i32* %i, align 4
  br label %while.cond

while.end:                                        ; preds = %while.cond
  ret void
}

declare i8* @strtok(i8* %0, i8* %1) #1

; Function Attrs: nounwind readonly
declare i32 @strlen(i8* %0) #3

; Function Attrs: noinline nounwind optnone
define hidden i32 @__main_argc_argv(i32 %argC, i8** %argV) #0 {
entry:
  %retval = alloca i32, align 4
  %argC.addr = alloca i32, align 4
  %argV.addr = alloca i8**, align 4
  %i = alloca i32, align 4
  %t = alloca %struct.elem*, align 4
  store i32 0, i32* %retval, align 4
  store i32 %argC, i32* %argC.addr, align 4
  store i8** %argV, i8*** %argV.addr, align 4
  %0 = load i32, i32* %argC.addr, align 4
  %cmp = icmp eq i32 %0, 1
  br i1 %cmp, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  %1 = load i8**, i8*** %argV.addr, align 4
  %arrayidx = getelementptr inbounds i8*, i8** %1, i32 0
  %2 = load i8*, i8** %arrayidx, align 4
  %call = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([95 x i8], [95 x i8]* @.str.6, i32 0, i32 0), i8* %2)
  br label %if.end10

if.else:                                          ; preds = %entry
  %3 = load i8**, i8*** %argV.addr, align 4
  %arrayidx1 = getelementptr inbounds i8*, i8** %3, i32 1
  %4 = load i8*, i8** %arrayidx1, align 4
  call void @buildStack(i8* %4)
  %call2 = call i32 @checkRPN()
  %cmp3 = icmp eq i32 %call2, 0
  br i1 %cmp3, label %if.then4, label %if.end

if.then4:                                         ; preds = %if.else
  %call5 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([15 x i8], [15 x i8]* @.str.3, i32 0, i32 0))
  store i32 0, i32* %retval, align 4
  br label %return

if.end:                                           ; preds = %if.else
  %call6 = call i8* @getNextString()
  %5 = load i8**, i8*** %argV.addr, align 4
  %arrayidx7 = getelementptr inbounds i8*, i8** %5, i32 2
  %6 = load i8*, i8** %arrayidx7, align 4
  %call8 = call %struct.elem* @buildTree(i8* %call6, i8* %6)
  store %struct.elem* %call8, %struct.elem** %t, align 4
  %call9 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([27 x i8], [27 x i8]* @.str.7, i32 0, i32 0))
  %7 = load %struct.elem*, %struct.elem** %t, align 4
  call void @inorder(%struct.elem* %7)
  br label %if.end10

if.end10:                                         ; preds = %if.end, %if.then
  store i32 0, i32* %retval, align 4
  br label %return

return:                                           ; preds = %if.end10, %if.then4
  %8 = load i32, i32* %retval, align 4
  ret i32 %8
}

attributes #0 = { noinline nounwind optnone "correctly-rounded-divide-sqrt-fp-math"="false" "disable-tail-calls"="false" "frame-pointer"="none" "less-precise-fpmad"="false" "min-legal-vector-width"="0" "no-infs-fp-math"="false" "no-jump-tables"="false" "no-nans-fp-math"="false" "no-signed-zeros-fp-math"="false" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="generic" "unsafe-fp-math"="false" "use-soft-float"="false" }
attributes #1 = { "correctly-rounded-divide-sqrt-fp-math"="false" "disable-tail-calls"="false" "frame-pointer"="none" "less-precise-fpmad"="false" "no-infs-fp-math"="false" "no-nans-fp-math"="false" "no-signed-zeros-fp-math"="false" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="generic" "unsafe-fp-math"="false" "use-soft-float"="false" }
attributes #2 = { noreturn "correctly-rounded-divide-sqrt-fp-math"="false" "disable-tail-calls"="false" "frame-pointer"="none" "less-precise-fpmad"="false" "no-infs-fp-math"="false" "no-nans-fp-math"="false" "no-signed-zeros-fp-math"="false" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="generic" "unsafe-fp-math"="false" "use-soft-float"="false" }
attributes #3 = { nounwind readonly "correctly-rounded-divide-sqrt-fp-math"="false" "disable-tail-calls"="false" "frame-pointer"="none" "less-precise-fpmad"="false" "no-infs-fp-math"="false" "no-nans-fp-math"="false" "no-signed-zeros-fp-math"="false" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="generic" "unsafe-fp-math"="false" "use-soft-float"="false" }
attributes #4 = { noreturn }
attributes #5 = { nounwind readonly }

!llvm.module.flags = !{!0}
!llvm.ident = !{!1}

!0 = !{i32 1, !"wchar_size", i32 4}
!1 = !{!"clang version 11.0.0 (https://github.com/Jacarte/llvm-project.git 0f6dea67136cc1e0b3d200eb2bb165628970c44b)"}

#########################################################
; exiting Souper's runOnFunction() for buildStack()
rescanning function after transformation was applied

; entering Souper's runOnFunction() for buildStack()

; ModuleID = './Parsing-RPN_to_infix_conversion.c.bc'
source_filename = "./Parsing-RPN_to_infix_conversion.c"
target datalayout = "e-m:e-p:32:32-i64:64-n32:64-S128"
target triple = "wasm32-unknown-wasi"

%struct.elem = type { [10 x i8], %struct.elem*, %struct.elem* }

@counter = hidden global i32 0, align 4
@.str = private unnamed_addr constant [2 x i8] c"(\00", align 1
@.str.1 = private unnamed_addr constant [2 x i8] c")\00", align 1
@.str.2 = private unnamed_addr constant [5 x i8] c" %s \00", align 1
@.str.3 = private unnamed_addr constant [15 x i8] c"\0AInvalid RPN !\00", align 1
@components = hidden global i8** null, align 4
@.str.4 = private unnamed_addr constant [2 x i8] c"\0A\00", align 1
@.str.5 = private unnamed_addr constant [2 x i8] c" \00", align 1
@.str.6 = private unnamed_addr constant [95 x i8] c"Usage : %s <RPN expression enclosed by quotes> <optional parameter to trace the build process>\00", align 1
@.str.7 = private unnamed_addr constant [27 x i8] c"\0AFinal infix expression : \00", align 1

; Function Attrs: noinline nounwind optnone
define hidden i32 @precedenceCheck(i8 signext %oper1, i8 signext %oper2) #0 {
entry:
  %oper1.addr = alloca i8, align 1
  %oper2.addr = alloca i8, align 1
  store i8 %oper1, i8* %oper1.addr, align 1
  store i8 %oper2, i8* %oper2.addr, align 1
  %0 = load i8, i8* %oper1.addr, align 1
  %conv = sext i8 %0 to i32
  %1 = load i8, i8* %oper2.addr, align 1
  %conv1 = sext i8 %1 to i32
  %cmp = icmp eq i32 %conv, %conv1
  br i1 %cmp, label %cond.true, label %cond.false

cond.true:                                        ; preds = %entry
  br label %cond.end61

cond.false:                                       ; preds = %entry
  %2 = load i8, i8* %oper1.addr, align 1
  %conv3 = sext i8 %2 to i32
  %cmp4 = icmp eq i32 %conv3, 94
  br i1 %cmp4, label %cond.true6, label %cond.false7

cond.true6:                                       ; preds = %cond.false
  br label %cond.end59

cond.false7:                                      ; preds = %cond.false
  %3 = load i8, i8* %oper2.addr, align 1
  %conv8 = sext i8 %3 to i32
  %cmp9 = icmp eq i32 %conv8, 94
  br i1 %cmp9, label %cond.true11, label %cond.false12

cond.true11:                                      ; preds = %cond.false7
  br label %cond.end57

cond.false12:                                     ; preds = %cond.false7
  %4 = load i8, i8* %oper1.addr, align 1
  %conv13 = sext i8 %4 to i32
  %cmp14 = icmp eq i32 %conv13, 47
  br i1 %cmp14, label %cond.true16, label %cond.false17

cond.true16:                                      ; preds = %cond.false12
  br label %cond.end55

cond.false17:                                     ; preds = %cond.false12
  %5 = load i8, i8* %oper2.addr, align 1
  %conv18 = sext i8 %5 to i32
  %cmp19 = icmp eq i32 %conv18, 47
  br i1 %cmp19, label %cond.true21, label %cond.false22

cond.true21:                                      ; preds = %cond.false17
  br label %cond.end53

cond.false22:                                     ; preds = %cond.false17
  %6 = load i8, i8* %oper1.addr, align 1
  %conv23 = sext i8 %6 to i32
  %cmp24 = icmp eq i32 %conv23, 42
  br i1 %cmp24, label %cond.true26, label %cond.false27

cond.true26:                                      ; preds = %cond.false22
  br label %cond.end51

cond.false27:                                     ; preds = %cond.false22
  %7 = load i8, i8* %oper2.addr, align 1
  %conv28 = sext i8 %7 to i32
  %cmp29 = icmp eq i32 %conv28, 42
  br i1 %cmp29, label %cond.true31, label %cond.false32

cond.true31:                                      ; preds = %cond.false27
  br label %cond.end49

cond.false32:                                     ; preds = %cond.false27
  %8 = load i8, i8* %oper1.addr, align 1
  %conv33 = sext i8 %8 to i32
  %cmp34 = icmp eq i32 %conv33, 43
  br i1 %cmp34, label %cond.true36, label %cond.false37

cond.true36:                                      ; preds = %cond.false32
  br label %cond.end47

cond.false37:                                     ; preds = %cond.false32
  %9 = load i8, i8* %oper2.addr, align 1
  %conv38 = sext i8 %9 to i32
  %cmp39 = icmp eq i32 %conv38, 43
  br i1 %cmp39, label %cond.true41, label %cond.false42

cond.true41:                                      ; preds = %cond.false37
  br label %cond.end

cond.false42:                                     ; preds = %cond.false37
  %10 = load i8, i8* %oper1.addr, align 1
  %conv43 = sext i8 %10 to i32
  %cmp44 = icmp eq i32 %conv43, 45
  %11 = zext i1 %cmp44 to i64
  %cond = select i1 %cmp44, i32 1, i32 2
  br label %cond.end

cond.end:                                         ; preds = %cond.false42, %cond.true41
  %cond46 = phi i32 [ 2, %cond.true41 ], [ %cond, %cond.false42 ]
  br label %cond.end47

cond.end47:                                       ; preds = %cond.end, %cond.true36
  %cond48 = phi i32 [ 1, %cond.true36 ], [ %cond46, %cond.end ]
  br label %cond.end49

cond.end49:                                       ; preds = %cond.end47, %cond.true31
  %cond50 = phi i32 [ 2, %cond.true31 ], [ %cond48, %cond.end47 ]
  br label %cond.end51

cond.end51:                                       ; preds = %cond.end49, %cond.true26
  %cond52 = phi i32 [ 1, %cond.true26 ], [ %cond50, %cond.end49 ]
  br label %cond.end53

cond.end53:                                       ; preds = %cond.end51, %cond.true21
  %cond54 = phi i32 [ 2, %cond.true21 ], [ %cond52, %cond.end51 ]
  br label %cond.end55

cond.end55:                                       ; preds = %cond.end53, %cond.true16
  %cond56 = phi i32 [ 1, %cond.true16 ], [ %cond54, %cond.end53 ]
  br label %cond.end57

cond.end57:                                       ; preds = %cond.end55, %cond.true11
  %cond58 = phi i32 [ 2, %cond.true11 ], [ %cond56, %cond.end55 ]
  br label %cond.end59

cond.end59:                                       ; preds = %cond.end57, %cond.true6
  %cond60 = phi i32 [ 1, %cond.true6 ], [ %cond58, %cond.end57 ]
  br label %cond.end61

cond.end61:                                       ; preds = %cond.end59, %cond.true
  %cond62 = phi i32 [ 0, %cond.true ], [ %cond60, %cond.end59 ]
  ret i32 %cond62
}

; Function Attrs: noinline nounwind optnone
define hidden i32 @isOperator(i8 signext %c) #0 {
entry:
  %c.addr = alloca i8, align 1
  store i8 %c, i8* %c.addr, align 1
  %0 = load i8, i8* %c.addr, align 1
  %conv = sext i8 %0 to i32
  %cmp = icmp eq i32 %conv, 43
  br i1 %cmp, label %lor.end, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %entry
  %1 = load i8, i8* %c.addr, align 1
  %conv2 = sext i8 %1 to i32
  %cmp3 = icmp eq i32 %conv2, 45
  br i1 %cmp3, label %lor.end, label %lor.lhs.false5

lor.lhs.false5:                                   ; preds = %lor.lhs.false
  %2 = load i8, i8* %c.addr, align 1
  %conv6 = sext i8 %2 to i32
  %cmp7 = icmp eq i32 %conv6, 42
  br i1 %cmp7, label %lor.end, label %lor.lhs.false9

lor.lhs.false9:                                   ; preds = %lor.lhs.false5
  %3 = load i8, i8* %c.addr, align 1
  %conv10 = sext i8 %3 to i32
  %cmp11 = icmp eq i32 %conv10, 47
  br i1 %cmp11, label %lor.end, label %lor.rhs

lor.rhs:                                          ; preds = %lor.lhs.false9
  %4 = load i8, i8* %c.addr, align 1
  %conv13 = sext i8 %4 to i32
  %cmp14 = icmp eq i32 %conv13, 94
  br label %lor.end

lor.end:                                          ; preds = %lor.rhs, %lor.lhs.false9, %lor.lhs.false5, %lor.lhs.false, %entry
  %5 = phi i1 [ true, %lor.lhs.false9 ], [ true, %lor.lhs.false5 ], [ true, %lor.lhs.false ], [ true, %entry ], [ %cmp14, %lor.rhs ]
  %lor.ext = zext i1 %5 to i32
  ret i32 %lor.ext
}

; Function Attrs: noinline nounwind optnone
define hidden void @inorder(%struct.elem* %t) #0 {
entry:
  %t.addr = alloca %struct.elem*, align 4
  store %struct.elem* %t, %struct.elem** %t.addr, align 4
  %0 = load %struct.elem*, %struct.elem** %t.addr, align 4
  %cmp = icmp ne %struct.elem* %0, null
  br i1 %cmp, label %if.then, label %if.end71

if.then:                                          ; preds = %entry
  %1 = load %struct.elem*, %struct.elem** %t.addr, align 4
  %left = getelementptr inbounds %struct.elem, %struct.elem* %1, i32 0, i32 1
  %2 = load %struct.elem*, %struct.elem** %left, align 4
  %cmp1 = icmp ne %struct.elem* %2, null
  br i1 %cmp1, label %land.lhs.true, label %if.else

land.lhs.true:                                    ; preds = %if.then
  %3 = load %struct.elem*, %struct.elem** %t.addr, align 4
  %left2 = getelementptr inbounds %struct.elem, %struct.elem* %3, i32 0, i32 1
  %4 = load %struct.elem*, %struct.elem** %left2, align 4
  %data = getelementptr inbounds %struct.elem, %struct.elem* %4, i32 0, i32 0
  %arrayidx = getelementptr inbounds [10 x i8], [10 x i8]* %data, i32 0, i32 0
  %5 = load i8, i8* %arrayidx, align 4
  %call = call i32 @isOperator(i8 signext %5)
  %cmp3 = icmp eq i32 %call, 1
  br i1 %cmp3, label %land.lhs.true4, label %if.else

land.lhs.true4:                                   ; preds = %land.lhs.true
  %6 = load %struct.elem*, %struct.elem** %t.addr, align 4
  %data5 = getelementptr inbounds %struct.elem, %struct.elem* %6, i32 0, i32 0
  %arrayidx6 = getelementptr inbounds [10 x i8], [10 x i8]* %data5, i32 0, i32 0
  %7 = load i8, i8* %arrayidx6, align 4
  %8 = load %struct.elem*, %struct.elem** %t.addr, align 4
  %left7 = getelementptr inbounds %struct.elem, %struct.elem* %8, i32 0, i32 1
  %9 = load %struct.elem*, %struct.elem** %left7, align 4
  %data8 = getelementptr inbounds %struct.elem, %struct.elem* %9, i32 0, i32 0
  %arrayidx9 = getelementptr inbounds [10 x i8], [10 x i8]* %data8, i32 0, i32 0
  %10 = load i8, i8* %arrayidx9, align 4
  %call10 = call i32 @precedenceCheck(i8 signext %7, i8 signext %10)
  %cmp11 = icmp eq i32 %call10, 1
  br i1 %cmp11, label %if.then24, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %land.lhs.true4
  %11 = load %struct.elem*, %struct.elem** %t.addr, align 4
  %data12 = getelementptr inbounds %struct.elem, %struct.elem* %11, i32 0, i32 0
  %arrayidx13 = getelementptr inbounds [10 x i8], [10 x i8]* %data12, i32 0, i32 0
  %12 = load i8, i8* %arrayidx13, align 4
  %13 = load %struct.elem*, %struct.elem** %t.addr, align 4
  %left14 = getelementptr inbounds %struct.elem, %struct.elem* %13, i32 0, i32 1
  %14 = load %struct.elem*, %struct.elem** %left14, align 4
  %data15 = getelementptr inbounds %struct.elem, %struct.elem* %14, i32 0, i32 0
  %arrayidx16 = getelementptr inbounds [10 x i8], [10 x i8]* %data15, i32 0, i32 0
  %15 = load i8, i8* %arrayidx16, align 4
  %call17 = call i32 @precedenceCheck(i8 signext %12, i8 signext %15)
  %cmp18 = icmp eq i32 %call17, 0
  br i1 %cmp18, label %land.lhs.true19, label %if.else

land.lhs.true19:                                  ; preds = %lor.lhs.false
  %16 = load %struct.elem*, %struct.elem** %t.addr, align 4
  %data20 = getelementptr inbounds %struct.elem, %struct.elem* %16, i32 0, i32 0
  %arrayidx21 = getelementptr inbounds [10 x i8], [10 x i8]* %data20, i32 0, i32 0
  %17 = load i8, i8* %arrayidx21, align 4
  %conv = sext i8 %17 to i32
  %cmp22 = icmp eq i32 %conv, 94
  br i1 %cmp22, label %if.then24, label %if.else

if.then24:                                        ; preds = %land.lhs.true19, %land.lhs.true4
  %call25 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([2 x i8], [2 x i8]* @.str, i32 0, i32 0))
  %18 = load %struct.elem*, %struct.elem** %t.addr, align 4
  %left26 = getelementptr inbounds %struct.elem, %struct.elem* %18, i32 0, i32 1
  %19 = load %struct.elem*, %struct.elem** %left26, align 4
  call void @inorder(%struct.elem* %19)
  %call27 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([2 x i8], [2 x i8]* @.str.1, i32 0, i32 0))
  br label %if.end

if.else:                                          ; preds = %land.lhs.true19, %lor.lhs.false, %land.lhs.true, %if.then
  %20 = load %struct.elem*, %struct.elem** %t.addr, align 4
  %left28 = getelementptr inbounds %struct.elem, %struct.elem* %20, i32 0, i32 1
  %21 = load %struct.elem*, %struct.elem** %left28, align 4
  call void @inorder(%struct.elem* %21)
  br label %if.end

if.end:                                           ; preds = %if.else, %if.then24
  %22 = load %struct.elem*, %struct.elem** %t.addr, align 4
  %data29 = getelementptr inbounds %struct.elem, %struct.elem* %22, i32 0, i32 0
  %arraydecay = getelementptr inbounds [10 x i8], [10 x i8]* %data29, i32 0, i32 0
  %call30 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.2, i32 0, i32 0), i8* %arraydecay)
  %23 = load %struct.elem*, %struct.elem** %t.addr, align 4
  %right = getelementptr inbounds %struct.elem, %struct.elem* %23, i32 0, i32 2
  %24 = load %struct.elem*, %struct.elem** %right, align 4
  %cmp31 = icmp ne %struct.elem* %24, null
  br i1 %cmp31, label %land.lhs.true33, label %if.else68

land.lhs.true33:                                  ; preds = %if.end
  %25 = load %struct.elem*, %struct.elem** %t.addr, align 4
  %right34 = getelementptr inbounds %struct.elem, %struct.elem* %25, i32 0, i32 2
  %26 = load %struct.elem*, %struct.elem** %right34, align 4
  %data35 = getelementptr inbounds %struct.elem, %struct.elem* %26, i32 0, i32 0
  %arrayidx36 = getelementptr inbounds [10 x i8], [10 x i8]* %data35, i32 0, i32 0
  %27 = load i8, i8* %arrayidx36, align 4
  %call37 = call i32 @isOperator(i8 signext %27)
  %cmp38 = icmp eq i32 %call37, 1
  br i1 %cmp38, label %land.lhs.true40, label %if.else68

land.lhs.true40:                                  ; preds = %land.lhs.true33
  %28 = load %struct.elem*, %struct.elem** %t.addr, align 4
  %data41 = getelementptr inbounds %struct.elem, %struct.elem* %28, i32 0, i32 0
  %arrayidx42 = getelementptr inbounds [10 x i8], [10 x i8]* %data41, i32 0, i32 0
  %29 = load i8, i8* %arrayidx42, align 4
  %30 = load %struct.elem*, %struct.elem** %t.addr, align 4
  %right43 = getelementptr inbounds %struct.elem, %struct.elem* %30, i32 0, i32 2
  %31 = load %struct.elem*, %struct.elem** %right43, align 4
  %data44 = getelementptr inbounds %struct.elem, %struct.elem* %31, i32 0, i32 0
  %arrayidx45 = getelementptr inbounds [10 x i8], [10 x i8]* %data44, i32 0, i32 0
  %32 = load i8, i8* %arrayidx45, align 4
  %call46 = call i32 @precedenceCheck(i8 signext %29, i8 signext %32)
  %cmp47 = icmp eq i32 %call46, 1
  br i1 %cmp47, label %if.then64, label %lor.lhs.false49

lor.lhs.false49:                                  ; preds = %land.lhs.true40
  %33 = load %struct.elem*, %struct.elem** %t.addr, align 4
  %data50 = getelementptr inbounds %struct.elem, %struct.elem* %33, i32 0, i32 0
  %arrayidx51 = getelementptr inbounds [10 x i8], [10 x i8]* %data50, i32 0, i32 0
  %34 = load i8, i8* %arrayidx51, align 4
  %35 = load %struct.elem*, %struct.elem** %t.addr, align 4
  %right52 = getelementptr inbounds %struct.elem, %struct.elem* %35, i32 0, i32 2
  %36 = load %struct.elem*, %struct.elem** %right52, align 4
  %data53 = getelementptr inbounds %struct.elem, %struct.elem* %36, i32 0, i32 0
  %arrayidx54 = getelementptr inbounds [10 x i8], [10 x i8]* %data53, i32 0, i32 0
  %37 = load i8, i8* %arrayidx54, align 4
  %call55 = call i32 @precedenceCheck(i8 signext %34, i8 signext %37)
  %cmp56 = icmp eq i32 %call55, 0
  br i1 %cmp56, label %land.lhs.true58, label %if.else68

land.lhs.true58:                                  ; preds = %lor.lhs.false49
  %38 = load %struct.elem*, %struct.elem** %t.addr, align 4
  %data59 = getelementptr inbounds %struct.elem, %struct.elem* %38, i32 0, i32 0
  %arrayidx60 = getelementptr inbounds [10 x i8], [10 x i8]* %data59, i32 0, i32 0
  %39 = load i8, i8* %arrayidx60, align 4
  %conv61 = sext i8 %39 to i32
  %cmp62 = icmp ne i32 %conv61, 94
  br i1 %cmp62, label %if.then64, label %if.else68

if.then64:                                        ; preds = %land.lhs.true58, %land.lhs.true40
  %call65 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([2 x i8], [2 x i8]* @.str, i32 0, i32 0))
  %40 = load %struct.elem*, %struct.elem** %t.addr, align 4
  %right66 = getelementptr inbounds %struct.elem, %struct.elem* %40, i32 0, i32 2
  %41 = load %struct.elem*, %struct.elem** %right66, align 4
  call void @inorder(%struct.elem* %41)
  %call67 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([2 x i8], [2 x i8]* @.str.1, i32 0, i32 0))
  br label %if.end70

if.else68:                                        ; preds = %land.lhs.true58, %lor.lhs.false49, %land.lhs.true33, %if.end
  %42 = load %struct.elem*, %struct.elem** %t.addr, align 4
  %right69 = getelementptr inbounds %struct.elem, %struct.elem* %42, i32 0, i32 2
  %43 = load %struct.elem*, %struct.elem** %right69, align 4
  call void @inorder(%struct.elem* %43)
  br label %if.end70

if.end70:                                         ; preds = %if.else68, %if.then64
  br label %if.end71

if.end71:                                         ; preds = %if.end70, %entry
  ret void
}

declare i32 @printf(i8* %0, ...) #1

; Function Attrs: noinline nounwind optnone
define hidden i8* @getNextString() #0 {
entry:
  %0 = load i32, i32* @counter, align 4
  %cmp = icmp slt i32 %0, 0
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %call = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([15 x i8], [15 x i8]* @.str.3, i32 0, i32 0))
  call void @exit(i32 0) #4
  unreachable

if.end:                                           ; preds = %entry
  %1 = load i8**, i8*** @components, align 4
  %2 = load i32, i32* @counter, align 4
  %dec = add nsw i32 %2, -1
  store i32 %dec, i32* @counter, align 4
  %arrayidx = getelementptr inbounds i8*, i8** %1, i32 %2
  %3 = load i8*, i8** %arrayidx, align 4
  ret i8* %3
}

; Function Attrs: noreturn
declare void @exit(i32 %0) #2

; Function Attrs: noinline nounwind optnone
define hidden %struct.elem* @buildTree(i8* %obj, i8* %trace) #0 {
entry:
  %obj.addr = alloca i8*, align 4
  %trace.addr = alloca i8*, align 4
  %t = alloca %struct.elem*, align 4
  store i8* %obj, i8** %obj.addr, align 4
  store i8* %trace, i8** %trace.addr, align 4
  %call = call noalias i8* @malloc(i32 20)
  %0 = bitcast i8* %call to %struct.elem*
  store %struct.elem* %0, %struct.elem** %t, align 4
  %1 = load %struct.elem*, %struct.elem** %t, align 4
  %data = getelementptr inbounds %struct.elem, %struct.elem* %1, i32 0, i32 0
  %arraydecay = getelementptr inbounds [10 x i8], [10 x i8]* %data, i32 0, i32 0
  %2 = load i8*, i8** %obj.addr, align 4
  %call1 = call i8* @strcpy(i8* %arraydecay, i8* %2)
  %3 = load i8*, i8** %obj.addr, align 4
  %arrayidx = getelementptr inbounds i8, i8* %3, i32 0
  %4 = load i8, i8* %arrayidx, align 1
  %call2 = call i32 @isOperator(i8 signext %4)
  %cmp = icmp eq i32 %call2, 1
  br i1 %cmp, label %cond.true, label %cond.false

cond.true:                                        ; preds = %entry
  %call3 = call i8* @getNextString()
  %5 = load i8*, i8** %trace.addr, align 4
  %call4 = call %struct.elem* @buildTree(i8* %call3, i8* %5)
  br label %cond.end

cond.false:                                       ; preds = %entry
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi %struct.elem* [ %call4, %cond.true ], [ null, %cond.false ]
  %6 = load %struct.elem*, %struct.elem** %t, align 4
  %right = getelementptr inbounds %struct.elem, %struct.elem* %6, i32 0, i32 2
  store %struct.elem* %cond, %struct.elem** %right, align 4
  %7 = load i8*, i8** %obj.addr, align 4
  %arrayidx5 = getelementptr inbounds i8, i8* %7, i32 0
  %8 = load i8, i8* %arrayidx5, align 1
  %call6 = call i32 @isOperator(i8 signext %8)
  %cmp7 = icmp eq i32 %call6, 1
  br i1 %cmp7, label %cond.true8, label %cond.false11

cond.true8:                                       ; preds = %cond.end
  %call9 = call i8* @getNextString()
  %9 = load i8*, i8** %trace.addr, align 4
  %call10 = call %struct.elem* @buildTree(i8* %call9, i8* %9)
  br label %cond.end12

cond.false11:                                     ; preds = %cond.end
  br label %cond.end12

cond.end12:                                       ; preds = %cond.false11, %cond.true8
  %cond13 = phi %struct.elem* [ %call10, %cond.true8 ], [ null, %cond.false11 ]
  %10 = load %struct.elem*, %struct.elem** %t, align 4
  %left = getelementptr inbounds %struct.elem, %struct.elem* %10, i32 0, i32 1
  store %struct.elem* %cond13, %struct.elem** %left, align 4
  %11 = load i8*, i8** %trace.addr, align 4
  %cmp14 = icmp ne i8* %11, null
  br i1 %cmp14, label %if.then, label %if.end

if.then:                                          ; preds = %cond.end12
  %call15 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([2 x i8], [2 x i8]* @.str.4, i32 0, i32 0))
  %12 = load %struct.elem*, %struct.elem** %t, align 4
  call void @inorder(%struct.elem* %12)
  br label %if.end

if.end:                                           ; preds = %if.then, %cond.end12
  %13 = load %struct.elem*, %struct.elem** %t, align 4
  ret %struct.elem* %13
}

declare noalias i8* @malloc(i32 %0) #1

declare i8* @strcpy(i8* %0, i8* %1) #1

; Function Attrs: noinline nounwind optnone
define hidden i32 @checkRPN() #0 {
entry:
  %retval = alloca i32, align 4
  %i = alloca i32, align 4
  %operSum = alloca i32, align 4
  %numberSum = alloca i32, align 4
  store i32 0, i32* %operSum, align 4
  store i32 0, i32* %numberSum, align 4
  %0 = load i8**, i8*** @components, align 4
  %1 = load i32, i32* @counter, align 4
  %arrayidx = getelementptr inbounds i8*, i8** %0, i32 %1
  %2 = load i8*, i8** %arrayidx, align 4
  %arrayidx1 = getelementptr inbounds i8, i8* %2, i32 0
  %3 = load i8, i8* %arrayidx1, align 1
  %call = call i32 @isOperator(i8 signext %3)
  %cmp = icmp eq i32 %call, 0
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  store i32 0, i32* %retval, align 4
  br label %return

if.end:                                           ; preds = %entry
  store i32 0, i32* %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.end
  %4 = load i32, i32* %i, align 4
  %5 = load i32, i32* @counter, align 4
  %cmp2 = icmp sle i32 %4, %5
  br i1 %cmp2, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %6 = load i8**, i8*** @components, align 4
  %7 = load i32, i32* %i, align 4
  %arrayidx3 = getelementptr inbounds i8*, i8** %6, i32 %7
  %8 = load i8*, i8** %arrayidx3, align 4
  %arrayidx4 = getelementptr inbounds i8, i8* %8, i32 0
  %9 = load i8, i8* %arrayidx4, align 1
  %call5 = call i32 @isOperator(i8 signext %9)
  %cmp6 = icmp eq i32 %call5, 1
  br i1 %cmp6, label %cond.true, label %cond.false

cond.true:                                        ; preds = %for.body
  %10 = load i32, i32* %operSum, align 4
  %inc = add nsw i32 %10, 1
  store i32 %inc, i32* %operSum, align 4
  br label %cond.end

cond.false:                                       ; preds = %for.body
  %11 = load i32, i32* %numberSum, align 4
  %inc7 = add nsw i32 %11, 1
  store i32 %inc7, i32* %numberSum, align 4
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi i32 [ %10, %cond.true ], [ %11, %cond.false ]
  br label %for.inc

for.inc:                                          ; preds = %cond.end
  %12 = load i32, i32* %i, align 4
  %inc8 = add nsw i32 %12, 1
  store i32 %inc8, i32* %i, align 4
  br label %for.cond

for.end:                                          ; preds = %for.cond
  %13 = load i32, i32* %numberSum, align 4
  %14 = load i32, i32* %operSum, align 4
  %sub = sub nsw i32 %13, %14
  %cmp9 = icmp eq i32 %sub, 1
  %conv = zext i1 %cmp9 to i32
  store i32 %conv, i32* %retval, align 4
  br label %return

return:                                           ; preds = %for.end, %if.then
  %15 = load i32, i32* %retval, align 4
  ret i32 %15
}

; Function Attrs: noinline nounwind optnone
define hidden void @buildStack(i8* %str) #0 {
entry:
  %str.addr = alloca i8*, align 4
  %i = alloca i32, align 4
  %token = alloca i8*, align 4
  store i8* %str, i8** %str.addr, align 4
  store i32 0, i32* %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %0 = load i8*, i8** %str.addr, align 4
  %1 = load i32, i32* %i, align 4
  %arrayidx = getelementptr inbounds i8, i8* %0, i32 %1
  %2 = load i8, i8* %arrayidx, align 1
  %conv = sext i8 %2 to i32
  %cmp = icmp ne i32 %conv, 0
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %3 = load i8*, i8** %str.addr, align 4
  %4 = load i32, i32* %i, align 4
  %arrayidx2 = getelementptr inbounds i8, i8* %3, i32 %4
  %5 = load i8, i8* %arrayidx2, align 1
  %conv3 = sext i8 %5 to i32
  %cmp4 = icmp eq i32 %conv3, 32
  br i1 %cmp4, label %if.then, label %if.end

if.then:                                          ; preds = %for.body
  %6 = load i32, i32* @counter, align 4
  %inc = add nsw i32 %6, 1
  store i32 %inc, i32* @counter, align 4
  br label %if.end

if.end:                                           ; preds = %if.then, %for.body
  br label %for.inc

for.inc:                                          ; preds = %if.end
  %7 = load i32, i32* %i, align 4
  %inc6 = add nsw i32 %7, 1
  store i32 %inc6, i32* %i, align 4
  br label %for.cond

for.end:                                          ; preds = %for.cond
  %8 = load i32, i32* @counter, align 4
  %add = add nsw i32 %8, 1
  %mul = mul i32 %add, 4
  %call = call noalias i8* @malloc(i32 %mul)
  %9 = bitcast i8* %call to i8**
  store i8** %9, i8*** @components, align 4
  %10 = load i8*, i8** %str.addr, align 4
  %call7 = call i8* @strtok(i8* %10, i8* getelementptr inbounds ([2 x i8], [2 x i8]* @.str.5, i32 0, i32 0))
  store i8* %call7, i8** %token, align 4
  store i32 0, i32* %i, align 4
  br label %while.cond

while.cond:                                       ; preds = %while.body, %for.end
  %11 = load i8*, i8** %token, align 4
  %cmp8 = icmp ne i8* %11, null
  br i1 %cmp8, label %while.body, label %while.end

while.body:                                       ; preds = %while.cond
  %12 = load i8*, i8** %token, align 4
  %call10 = call i32 @strlen(i8* %12) #5
  %call12 = call noalias i8* @malloc(i32 %call10)
  %13 = load i8**, i8*** @components, align 4
  %14 = load i32, i32* %i, align 4
  %arrayidx13 = getelementptr inbounds i8*, i8** %13, i32 %14
  store i8* %call12, i8** %arrayidx13, align 4
  %15 = load i8**, i8*** @components, align 4
  %16 = load i32, i32* %i, align 4
  %arrayidx14 = getelementptr inbounds i8*, i8** %15, i32 %16
  %17 = load i8*, i8** %arrayidx14, align 4
  %18 = load i8*, i8** %token, align 4
  %call15 = call i8* @strcpy(i8* %17, i8* %18)
  %call16 = call i8* @strtok(i8* null, i8* getelementptr inbounds ([2 x i8], [2 x i8]* @.str.5, i32 0, i32 0))
  store i8* %call16, i8** %token, align 4
  %19 = load i32, i32* %i, align 4
  %inc17 = add nsw i32 %19, 1
  store i32 %inc17, i32* %i, align 4
  br label %while.cond

while.end:                                        ; preds = %while.cond
  ret void
}

declare i8* @strtok(i8* %0, i8* %1) #1

; Function Attrs: nounwind readonly
declare i32 @strlen(i8* %0) #3

; Function Attrs: noinline nounwind optnone
define hidden i32 @__main_argc_argv(i32 %argC, i8** %argV) #0 {
entry:
  %retval = alloca i32, align 4
  %argC.addr = alloca i32, align 4
  %argV.addr = alloca i8**, align 4
  %i = alloca i32, align 4
  %t = alloca %struct.elem*, align 4
  store i32 0, i32* %retval, align 4
  store i32 %argC, i32* %argC.addr, align 4
  store i8** %argV, i8*** %argV.addr, align 4
  %0 = load i32, i32* %argC.addr, align 4
  %cmp = icmp eq i32 %0, 1
  br i1 %cmp, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  %1 = load i8**, i8*** %argV.addr, align 4
  %arrayidx = getelementptr inbounds i8*, i8** %1, i32 0
  %2 = load i8*, i8** %arrayidx, align 4
  %call = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([95 x i8], [95 x i8]* @.str.6, i32 0, i32 0), i8* %2)
  br label %if.end10

if.else:                                          ; preds = %entry
  %3 = load i8**, i8*** %argV.addr, align 4
  %arrayidx1 = getelementptr inbounds i8*, i8** %3, i32 1
  %4 = load i8*, i8** %arrayidx1, align 4
  call void @buildStack(i8* %4)
  %call2 = call i32 @checkRPN()
  %cmp3 = icmp eq i32 %call2, 0
  br i1 %cmp3, label %if.then4, label %if.end

if.then4:                                         ; preds = %if.else
  %call5 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([15 x i8], [15 x i8]* @.str.3, i32 0, i32 0))
  store i32 0, i32* %retval, align 4
  br label %return

if.end:                                           ; preds = %if.else
  %call6 = call i8* @getNextString()
  %5 = load i8**, i8*** %argV.addr, align 4
  %arrayidx7 = getelementptr inbounds i8*, i8** %5, i32 2
  %6 = load i8*, i8** %arrayidx7, align 4
  %call8 = call %struct.elem* @buildTree(i8* %call6, i8* %6)
  store %struct.elem* %call8, %struct.elem** %t, align 4
  %call9 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([27 x i8], [27 x i8]* @.str.7, i32 0, i32 0))
  %7 = load %struct.elem*, %struct.elem** %t, align 4
  call void @inorder(%struct.elem* %7)
  br label %if.end10

if.end10:                                         ; preds = %if.end, %if.then
  store i32 0, i32* %retval, align 4
  br label %return

return:                                           ; preds = %if.end10, %if.then4
  %8 = load i32, i32* %retval, align 4
  ret i32 %8
}

attributes #0 = { noinline nounwind optnone "correctly-rounded-divide-sqrt-fp-math"="false" "disable-tail-calls"="false" "frame-pointer"="none" "less-precise-fpmad"="false" "min-legal-vector-width"="0" "no-infs-fp-math"="false" "no-jump-tables"="false" "no-nans-fp-math"="false" "no-signed-zeros-fp-math"="false" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="generic" "unsafe-fp-math"="false" "use-soft-float"="false" }
attributes #1 = { "correctly-rounded-divide-sqrt-fp-math"="false" "disable-tail-calls"="false" "frame-pointer"="none" "less-precise-fpmad"="false" "no-infs-fp-math"="false" "no-nans-fp-math"="false" "no-signed-zeros-fp-math"="false" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="generic" "unsafe-fp-math"="false" "use-soft-float"="false" }
attributes #2 = { noreturn "correctly-rounded-divide-sqrt-fp-math"="false" "disable-tail-calls"="false" "frame-pointer"="none" "less-precise-fpmad"="false" "no-infs-fp-math"="false" "no-nans-fp-math"="false" "no-signed-zeros-fp-math"="false" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="generic" "unsafe-fp-math"="false" "use-soft-float"="false" }
attributes #3 = { nounwind readonly "correctly-rounded-divide-sqrt-fp-math"="false" "disable-tail-calls"="false" "frame-pointer"="none" "less-precise-fpmad"="false" "no-infs-fp-math"="false" "no-nans-fp-math"="false" "no-signed-zeros-fp-math"="false" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="generic" "unsafe-fp-math"="false" "use-soft-float"="false" }
attributes #4 = { noreturn }
attributes #5 = { nounwind readonly }

!llvm.module.flags = !{!0}
!llvm.ident = !{!1}

!0 = !{i32 1, !"wchar_size", i32 4}
!1 = !{!"clang version 11.0.0 (https://github.com/Jacarte/llvm-project.git 0f6dea67136cc1e0b3d200eb2bb165628970c44b)"}

; extracted candidates

; *****
; For LLVM instruction:
;  %1 = load i32, i32* %i, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %2 = load i8, i8* %arrayidx, align 1
; Looking for a replacement for:
%0:i8 = var
infer %0

; *****
; For LLVM instruction:
;  %conv = sext i8 %2 to i32
; Looking for a replacement for:
%0:i8 = var
%1:i32 = sext %0
infer %1

; *****
; For LLVM instruction:
;  %cmp = icmp ne i32 %conv, 0
; Looking for a replacement for:
%0:i8 = var
%1:i32 = sext %0
%2:i1 = ne 0:i32, %1
infer %2

; *****
; For LLVM instruction:
;  %4 = load i32, i32* %i, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %5 = load i8, i8* %arrayidx2, align 1
; Looking for a replacement for:
%0:i8 = var
infer %0

; *****
; For LLVM instruction:
;  %conv3 = sext i8 %5 to i32
; Looking for a replacement for:
%0:i8 = var
%1:i32 = sext %0
infer %1

; *****
; For LLVM instruction:
;  %cmp4 = icmp eq i32 %conv3, 32
; Looking for a replacement for:
%0:i8 = var
%1:i32 = sext %0
%2:i1 = eq 32:i32, %1
infer %2

; *****
; For LLVM instruction:
;  %6 = load i32, i32* @counter, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %inc = add nsw i32 %6, 1
; Looking for a replacement for:
%0:i32 = var
%1:i32 = addnsw 1:i32, %0
infer %1

; *****
; For LLVM instruction:
;  %7 = load i32, i32* %i, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %inc6 = add nsw i32 %7, 1
; Looking for a replacement for:
%0:i32 = var
%1:i32 = addnsw 1:i32, %0
infer %1

; *****
; For LLVM instruction:
;  %8 = load i32, i32* @counter, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %add = add nsw i32 %8, 1
; Looking for a replacement for:
%0:i32 = var
%1:i32 = addnsw 1:i32, %0
infer %1

; *****
; For LLVM instruction:
;  %mul = mul i32 %add, 4
; Looking for a replacement for:
%0:i32 = var
%1:i32 = addnsw 1:i32, %0
%2:i32 = mul 4:i32, %1
infer %2

; *****
; For LLVM instruction:
;  %cmp8 = icmp ne i8* %11, null
; Looking for a replacement for:
%0:i32 = var
%1:i1 = ne 0:i32, %0
infer %1

; *****
; For LLVM instruction:
;  %call10 = call i32 @strlen(i8* %12) #4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %14 = load i32, i32* %i, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %16 = load i32, i32* %i, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %19 = load i32, i32* %i, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %inc17 = add nsw i32 %19, 1
; Looking for a replacement for:
%0:i32 = var
%1:i32 = addnsw 1:i32, %0
infer %1
#########################################################
; exiting Souper's runOnFunction() for buildStack()

; entering Souper's runOnFunction() for __main_argc_argv()

; ModuleID = './Parsing-RPN_to_infix_conversion.c.bc'
source_filename = "./Parsing-RPN_to_infix_conversion.c"
target datalayout = "e-m:e-p:32:32-i64:64-n32:64-S128"
target triple = "wasm32-unknown-wasi"

%struct.elem = type { [10 x i8], %struct.elem*, %struct.elem* }

@counter = hidden global i32 0, align 4
@.str = private unnamed_addr constant [2 x i8] c"(\00", align 1
@.str.1 = private unnamed_addr constant [2 x i8] c")\00", align 1
@.str.2 = private unnamed_addr constant [5 x i8] c" %s \00", align 1
@.str.3 = private unnamed_addr constant [15 x i8] c"\0AInvalid RPN !\00", align 1
@components = hidden global i8** null, align 4
@.str.4 = private unnamed_addr constant [2 x i8] c"\0A\00", align 1
@.str.5 = private unnamed_addr constant [2 x i8] c" \00", align 1
@.str.6 = private unnamed_addr constant [95 x i8] c"Usage : %s <RPN expression enclosed by quotes> <optional parameter to trace the build process>\00", align 1
@.str.7 = private unnamed_addr constant [27 x i8] c"\0AFinal infix expression : \00", align 1

; Function Attrs: noinline nounwind optnone
define hidden i32 @precedenceCheck(i8 signext %oper1, i8 signext %oper2) #0 {
entry:
  %oper1.addr = alloca i8, align 1
  %oper2.addr = alloca i8, align 1
  store i8 %oper1, i8* %oper1.addr, align 1
  store i8 %oper2, i8* %oper2.addr, align 1
  %0 = load i8, i8* %oper1.addr, align 1
  %conv = sext i8 %0 to i32
  %1 = load i8, i8* %oper2.addr, align 1
  %conv1 = sext i8 %1 to i32
  %cmp = icmp eq i32 %conv, %conv1
  br i1 %cmp, label %cond.true, label %cond.false

cond.true:                                        ; preds = %entry
  br label %cond.end61

cond.false:                                       ; preds = %entry
  %2 = load i8, i8* %oper1.addr, align 1
  %conv3 = sext i8 %2 to i32
  %cmp4 = icmp eq i32 %conv3, 94
  br i1 %cmp4, label %cond.true6, label %cond.false7

cond.true6:                                       ; preds = %cond.false
  br label %cond.end59

cond.false7:                                      ; preds = %cond.false
  %3 = load i8, i8* %oper2.addr, align 1
  %conv8 = sext i8 %3 to i32
  %cmp9 = icmp eq i32 %conv8, 94
  br i1 %cmp9, label %cond.true11, label %cond.false12

cond.true11:                                      ; preds = %cond.false7
  br label %cond.end57

cond.false12:                                     ; preds = %cond.false7
  %4 = load i8, i8* %oper1.addr, align 1
  %conv13 = sext i8 %4 to i32
  %cmp14 = icmp eq i32 %conv13, 47
  br i1 %cmp14, label %cond.true16, label %cond.false17

cond.true16:                                      ; preds = %cond.false12
  br label %cond.end55

cond.false17:                                     ; preds = %cond.false12
  %5 = load i8, i8* %oper2.addr, align 1
  %conv18 = sext i8 %5 to i32
  %cmp19 = icmp eq i32 %conv18, 47
  br i1 %cmp19, label %cond.true21, label %cond.false22

cond.true21:                                      ; preds = %cond.false17
  br label %cond.end53

cond.false22:                                     ; preds = %cond.false17
  %6 = load i8, i8* %oper1.addr, align 1
  %conv23 = sext i8 %6 to i32
  %cmp24 = icmp eq i32 %conv23, 42
  br i1 %cmp24, label %cond.true26, label %cond.false27

cond.true26:                                      ; preds = %cond.false22
  br label %cond.end51

cond.false27:                                     ; preds = %cond.false22
  %7 = load i8, i8* %oper2.addr, align 1
  %conv28 = sext i8 %7 to i32
  %cmp29 = icmp eq i32 %conv28, 42
  br i1 %cmp29, label %cond.true31, label %cond.false32

cond.true31:                                      ; preds = %cond.false27
  br label %cond.end49

cond.false32:                                     ; preds = %cond.false27
  %8 = load i8, i8* %oper1.addr, align 1
  %conv33 = sext i8 %8 to i32
  %cmp34 = icmp eq i32 %conv33, 43
  br i1 %cmp34, label %cond.true36, label %cond.false37

cond.true36:                                      ; preds = %cond.false32
  br label %cond.end47

cond.false37:                                     ; preds = %cond.false32
  %9 = load i8, i8* %oper2.addr, align 1
  %conv38 = sext i8 %9 to i32
  %cmp39 = icmp eq i32 %conv38, 43
  br i1 %cmp39, label %cond.true41, label %cond.false42

cond.true41:                                      ; preds = %cond.false37
  br label %cond.end

cond.false42:                                     ; preds = %cond.false37
  %10 = load i8, i8* %oper1.addr, align 1
  %conv43 = sext i8 %10 to i32
  %cmp44 = icmp eq i32 %conv43, 45
  %11 = zext i1 %cmp44 to i64
  %cond = select i1 %cmp44, i32 1, i32 2
  br label %cond.end

cond.end:                                         ; preds = %cond.false42, %cond.true41
  %cond46 = phi i32 [ 2, %cond.true41 ], [ %cond, %cond.false42 ]
  br label %cond.end47

cond.end47:                                       ; preds = %cond.end, %cond.true36
  %cond48 = phi i32 [ 1, %cond.true36 ], [ %cond46, %cond.end ]
  br label %cond.end49

cond.end49:                                       ; preds = %cond.end47, %cond.true31
  %cond50 = phi i32 [ 2, %cond.true31 ], [ %cond48, %cond.end47 ]
  br label %cond.end51

cond.end51:                                       ; preds = %cond.end49, %cond.true26
  %cond52 = phi i32 [ 1, %cond.true26 ], [ %cond50, %cond.end49 ]
  br label %cond.end53

cond.end53:                                       ; preds = %cond.end51, %cond.true21
  %cond54 = phi i32 [ 2, %cond.true21 ], [ %cond52, %cond.end51 ]
  br label %cond.end55

cond.end55:                                       ; preds = %cond.end53, %cond.true16
  %cond56 = phi i32 [ 1, %cond.true16 ], [ %cond54, %cond.end53 ]
  br label %cond.end57

cond.end57:                                       ; preds = %cond.end55, %cond.true11
  %cond58 = phi i32 [ 2, %cond.true11 ], [ %cond56, %cond.end55 ]
  br label %cond.end59

cond.end59:                                       ; preds = %cond.end57, %cond.true6
  %cond60 = phi i32 [ 1, %cond.true6 ], [ %cond58, %cond.end57 ]
  br label %cond.end61

cond.end61:                                       ; preds = %cond.end59, %cond.true
  %cond62 = phi i32 [ 0, %cond.true ], [ %cond60, %cond.end59 ]
  ret i32 %cond62
}

; Function Attrs: noinline nounwind optnone
define hidden i32 @isOperator(i8 signext %c) #0 {
entry:
  %c.addr = alloca i8, align 1
  store i8 %c, i8* %c.addr, align 1
  %0 = load i8, i8* %c.addr, align 1
  %conv = sext i8 %0 to i32
  %cmp = icmp eq i32 %conv, 43
  br i1 %cmp, label %lor.end, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %entry
  %1 = load i8, i8* %c.addr, align 1
  %conv2 = sext i8 %1 to i32
  %cmp3 = icmp eq i32 %conv2, 45
  br i1 %cmp3, label %lor.end, label %lor.lhs.false5

lor.lhs.false5:                                   ; preds = %lor.lhs.false
  %2 = load i8, i8* %c.addr, align 1
  %conv6 = sext i8 %2 to i32
  %cmp7 = icmp eq i32 %conv6, 42
  br i1 %cmp7, label %lor.end, label %lor.lhs.false9

lor.lhs.false9:                                   ; preds = %lor.lhs.false5
  %3 = load i8, i8* %c.addr, align 1
  %conv10 = sext i8 %3 to i32
  %cmp11 = icmp eq i32 %conv10, 47
  br i1 %cmp11, label %lor.end, label %lor.rhs

lor.rhs:                                          ; preds = %lor.lhs.false9
  %4 = load i8, i8* %c.addr, align 1
  %conv13 = sext i8 %4 to i32
  %cmp14 = icmp eq i32 %conv13, 94
  br label %lor.end

lor.end:                                          ; preds = %lor.rhs, %lor.lhs.false9, %lor.lhs.false5, %lor.lhs.false, %entry
  %5 = phi i1 [ true, %lor.lhs.false9 ], [ true, %lor.lhs.false5 ], [ true, %lor.lhs.false ], [ true, %entry ], [ %cmp14, %lor.rhs ]
  %lor.ext = zext i1 %5 to i32
  ret i32 %lor.ext
}

; Function Attrs: noinline nounwind optnone
define hidden void @inorder(%struct.elem* %t) #0 {
entry:
  %t.addr = alloca %struct.elem*, align 4
  store %struct.elem* %t, %struct.elem** %t.addr, align 4
  %0 = load %struct.elem*, %struct.elem** %t.addr, align 4
  %cmp = icmp ne %struct.elem* %0, null
  br i1 %cmp, label %if.then, label %if.end71

if.then:                                          ; preds = %entry
  %1 = load %struct.elem*, %struct.elem** %t.addr, align 4
  %left = getelementptr inbounds %struct.elem, %struct.elem* %1, i32 0, i32 1
  %2 = load %struct.elem*, %struct.elem** %left, align 4
  %cmp1 = icmp ne %struct.elem* %2, null
  br i1 %cmp1, label %land.lhs.true, label %if.else

land.lhs.true:                                    ; preds = %if.then
  %3 = load %struct.elem*, %struct.elem** %t.addr, align 4
  %left2 = getelementptr inbounds %struct.elem, %struct.elem* %3, i32 0, i32 1
  %4 = load %struct.elem*, %struct.elem** %left2, align 4
  %data = getelementptr inbounds %struct.elem, %struct.elem* %4, i32 0, i32 0
  %arrayidx = getelementptr inbounds [10 x i8], [10 x i8]* %data, i32 0, i32 0
  %5 = load i8, i8* %arrayidx, align 4
  %call = call i32 @isOperator(i8 signext %5)
  %cmp3 = icmp eq i32 %call, 1
  br i1 %cmp3, label %land.lhs.true4, label %if.else

land.lhs.true4:                                   ; preds = %land.lhs.true
  %6 = load %struct.elem*, %struct.elem** %t.addr, align 4
  %data5 = getelementptr inbounds %struct.elem, %struct.elem* %6, i32 0, i32 0
  %arrayidx6 = getelementptr inbounds [10 x i8], [10 x i8]* %data5, i32 0, i32 0
  %7 = load i8, i8* %arrayidx6, align 4
  %8 = load %struct.elem*, %struct.elem** %t.addr, align 4
  %left7 = getelementptr inbounds %struct.elem, %struct.elem* %8, i32 0, i32 1
  %9 = load %struct.elem*, %struct.elem** %left7, align 4
  %data8 = getelementptr inbounds %struct.elem, %struct.elem* %9, i32 0, i32 0
  %arrayidx9 = getelementptr inbounds [10 x i8], [10 x i8]* %data8, i32 0, i32 0
  %10 = load i8, i8* %arrayidx9, align 4
  %call10 = call i32 @precedenceCheck(i8 signext %7, i8 signext %10)
  %cmp11 = icmp eq i32 %call10, 1
  br i1 %cmp11, label %if.then24, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %land.lhs.true4
  %11 = load %struct.elem*, %struct.elem** %t.addr, align 4
  %data12 = getelementptr inbounds %struct.elem, %struct.elem* %11, i32 0, i32 0
  %arrayidx13 = getelementptr inbounds [10 x i8], [10 x i8]* %data12, i32 0, i32 0
  %12 = load i8, i8* %arrayidx13, align 4
  %13 = load %struct.elem*, %struct.elem** %t.addr, align 4
  %left14 = getelementptr inbounds %struct.elem, %struct.elem* %13, i32 0, i32 1
  %14 = load %struct.elem*, %struct.elem** %left14, align 4
  %data15 = getelementptr inbounds %struct.elem, %struct.elem* %14, i32 0, i32 0
  %arrayidx16 = getelementptr inbounds [10 x i8], [10 x i8]* %data15, i32 0, i32 0
  %15 = load i8, i8* %arrayidx16, align 4
  %call17 = call i32 @precedenceCheck(i8 signext %12, i8 signext %15)
  %cmp18 = icmp eq i32 %call17, 0
  br i1 %cmp18, label %land.lhs.true19, label %if.else

land.lhs.true19:                                  ; preds = %lor.lhs.false
  %16 = load %struct.elem*, %struct.elem** %t.addr, align 4
  %data20 = getelementptr inbounds %struct.elem, %struct.elem* %16, i32 0, i32 0
  %arrayidx21 = getelementptr inbounds [10 x i8], [10 x i8]* %data20, i32 0, i32 0
  %17 = load i8, i8* %arrayidx21, align 4
  %conv = sext i8 %17 to i32
  %cmp22 = icmp eq i32 %conv, 94
  br i1 %cmp22, label %if.then24, label %if.else

if.then24:                                        ; preds = %land.lhs.true19, %land.lhs.true4
  %call25 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([2 x i8], [2 x i8]* @.str, i32 0, i32 0))
  %18 = load %struct.elem*, %struct.elem** %t.addr, align 4
  %left26 = getelementptr inbounds %struct.elem, %struct.elem* %18, i32 0, i32 1
  %19 = load %struct.elem*, %struct.elem** %left26, align 4
  call void @inorder(%struct.elem* %19)
  %call27 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([2 x i8], [2 x i8]* @.str.1, i32 0, i32 0))
  br label %if.end

if.else:                                          ; preds = %land.lhs.true19, %lor.lhs.false, %land.lhs.true, %if.then
  %20 = load %struct.elem*, %struct.elem** %t.addr, align 4
  %left28 = getelementptr inbounds %struct.elem, %struct.elem* %20, i32 0, i32 1
  %21 = load %struct.elem*, %struct.elem** %left28, align 4
  call void @inorder(%struct.elem* %21)
  br label %if.end

if.end:                                           ; preds = %if.else, %if.then24
  %22 = load %struct.elem*, %struct.elem** %t.addr, align 4
  %data29 = getelementptr inbounds %struct.elem, %struct.elem* %22, i32 0, i32 0
  %arraydecay = getelementptr inbounds [10 x i8], [10 x i8]* %data29, i32 0, i32 0
  %call30 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.2, i32 0, i32 0), i8* %arraydecay)
  %23 = load %struct.elem*, %struct.elem** %t.addr, align 4
  %right = getelementptr inbounds %struct.elem, %struct.elem* %23, i32 0, i32 2
  %24 = load %struct.elem*, %struct.elem** %right, align 4
  %cmp31 = icmp ne %struct.elem* %24, null
  br i1 %cmp31, label %land.lhs.true33, label %if.else68

land.lhs.true33:                                  ; preds = %if.end
  %25 = load %struct.elem*, %struct.elem** %t.addr, align 4
  %right34 = getelementptr inbounds %struct.elem, %struct.elem* %25, i32 0, i32 2
  %26 = load %struct.elem*, %struct.elem** %right34, align 4
  %data35 = getelementptr inbounds %struct.elem, %struct.elem* %26, i32 0, i32 0
  %arrayidx36 = getelementptr inbounds [10 x i8], [10 x i8]* %data35, i32 0, i32 0
  %27 = load i8, i8* %arrayidx36, align 4
  %call37 = call i32 @isOperator(i8 signext %27)
  %cmp38 = icmp eq i32 %call37, 1
  br i1 %cmp38, label %land.lhs.true40, label %if.else68

land.lhs.true40:                                  ; preds = %land.lhs.true33
  %28 = load %struct.elem*, %struct.elem** %t.addr, align 4
  %data41 = getelementptr inbounds %struct.elem, %struct.elem* %28, i32 0, i32 0
  %arrayidx42 = getelementptr inbounds [10 x i8], [10 x i8]* %data41, i32 0, i32 0
  %29 = load i8, i8* %arrayidx42, align 4
  %30 = load %struct.elem*, %struct.elem** %t.addr, align 4
  %right43 = getelementptr inbounds %struct.elem, %struct.elem* %30, i32 0, i32 2
  %31 = load %struct.elem*, %struct.elem** %right43, align 4
  %data44 = getelementptr inbounds %struct.elem, %struct.elem* %31, i32 0, i32 0
  %arrayidx45 = getelementptr inbounds [10 x i8], [10 x i8]* %data44, i32 0, i32 0
  %32 = load i8, i8* %arrayidx45, align 4
  %call46 = call i32 @precedenceCheck(i8 signext %29, i8 signext %32)
  %cmp47 = icmp eq i32 %call46, 1
  br i1 %cmp47, label %if.then64, label %lor.lhs.false49

lor.lhs.false49:                                  ; preds = %land.lhs.true40
  %33 = load %struct.elem*, %struct.elem** %t.addr, align 4
  %data50 = getelementptr inbounds %struct.elem, %struct.elem* %33, i32 0, i32 0
  %arrayidx51 = getelementptr inbounds [10 x i8], [10 x i8]* %data50, i32 0, i32 0
  %34 = load i8, i8* %arrayidx51, align 4
  %35 = load %struct.elem*, %struct.elem** %t.addr, align 4
  %right52 = getelementptr inbounds %struct.elem, %struct.elem* %35, i32 0, i32 2
  %36 = load %struct.elem*, %struct.elem** %right52, align 4
  %data53 = getelementptr inbounds %struct.elem, %struct.elem* %36, i32 0, i32 0
  %arrayidx54 = getelementptr inbounds [10 x i8], [10 x i8]* %data53, i32 0, i32 0
  %37 = load i8, i8* %arrayidx54, align 4
  %call55 = call i32 @precedenceCheck(i8 signext %34, i8 signext %37)
  %cmp56 = icmp eq i32 %call55, 0
  br i1 %cmp56, label %land.lhs.true58, label %if.else68

land.lhs.true58:                                  ; preds = %lor.lhs.false49
  %38 = load %struct.elem*, %struct.elem** %t.addr, align 4
  %data59 = getelementptr inbounds %struct.elem, %struct.elem* %38, i32 0, i32 0
  %arrayidx60 = getelementptr inbounds [10 x i8], [10 x i8]* %data59, i32 0, i32 0
  %39 = load i8, i8* %arrayidx60, align 4
  %conv61 = sext i8 %39 to i32
  %cmp62 = icmp ne i32 %conv61, 94
  br i1 %cmp62, label %if.then64, label %if.else68

if.then64:                                        ; preds = %land.lhs.true58, %land.lhs.true40
  %call65 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([2 x i8], [2 x i8]* @.str, i32 0, i32 0))
  %40 = load %struct.elem*, %struct.elem** %t.addr, align 4
  %right66 = getelementptr inbounds %struct.elem, %struct.elem* %40, i32 0, i32 2
  %41 = load %struct.elem*, %struct.elem** %right66, align 4
  call void @inorder(%struct.elem* %41)
  %call67 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([2 x i8], [2 x i8]* @.str.1, i32 0, i32 0))
  br label %if.end70

if.else68:                                        ; preds = %land.lhs.true58, %lor.lhs.false49, %land.lhs.true33, %if.end
  %42 = load %struct.elem*, %struct.elem** %t.addr, align 4
  %right69 = getelementptr inbounds %struct.elem, %struct.elem* %42, i32 0, i32 2
  %43 = load %struct.elem*, %struct.elem** %right69, align 4
  call void @inorder(%struct.elem* %43)
  br label %if.end70

if.end70:                                         ; preds = %if.else68, %if.then64
  br label %if.end71

if.end71:                                         ; preds = %if.end70, %entry
  ret void
}

declare i32 @printf(i8* %0, ...) #1

; Function Attrs: noinline nounwind optnone
define hidden i8* @getNextString() #0 {
entry:
  %0 = load i32, i32* @counter, align 4
  %cmp = icmp slt i32 %0, 0
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %call = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([15 x i8], [15 x i8]* @.str.3, i32 0, i32 0))
  call void @exit(i32 0) #4
  unreachable

if.end:                                           ; preds = %entry
  %1 = load i8**, i8*** @components, align 4
  %2 = load i32, i32* @counter, align 4
  %dec = add nsw i32 %2, -1
  store i32 %dec, i32* @counter, align 4
  %arrayidx = getelementptr inbounds i8*, i8** %1, i32 %2
  %3 = load i8*, i8** %arrayidx, align 4
  ret i8* %3
}

; Function Attrs: noreturn
declare void @exit(i32 %0) #2

; Function Attrs: noinline nounwind optnone
define hidden %struct.elem* @buildTree(i8* %obj, i8* %trace) #0 {
entry:
  %obj.addr = alloca i8*, align 4
  %trace.addr = alloca i8*, align 4
  %t = alloca %struct.elem*, align 4
  store i8* %obj, i8** %obj.addr, align 4
  store i8* %trace, i8** %trace.addr, align 4
  %call = call noalias i8* @malloc(i32 20)
  %0 = bitcast i8* %call to %struct.elem*
  store %struct.elem* %0, %struct.elem** %t, align 4
  %1 = load %struct.elem*, %struct.elem** %t, align 4
  %data = getelementptr inbounds %struct.elem, %struct.elem* %1, i32 0, i32 0
  %arraydecay = getelementptr inbounds [10 x i8], [10 x i8]* %data, i32 0, i32 0
  %2 = load i8*, i8** %obj.addr, align 4
  %call1 = call i8* @strcpy(i8* %arraydecay, i8* %2)
  %3 = load i8*, i8** %obj.addr, align 4
  %arrayidx = getelementptr inbounds i8, i8* %3, i32 0
  %4 = load i8, i8* %arrayidx, align 1
  %call2 = call i32 @isOperator(i8 signext %4)
  %cmp = icmp eq i32 %call2, 1
  br i1 %cmp, label %cond.true, label %cond.false

cond.true:                                        ; preds = %entry
  %call3 = call i8* @getNextString()
  %5 = load i8*, i8** %trace.addr, align 4
  %call4 = call %struct.elem* @buildTree(i8* %call3, i8* %5)
  br label %cond.end

cond.false:                                       ; preds = %entry
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi %struct.elem* [ %call4, %cond.true ], [ null, %cond.false ]
  %6 = load %struct.elem*, %struct.elem** %t, align 4
  %right = getelementptr inbounds %struct.elem, %struct.elem* %6, i32 0, i32 2
  store %struct.elem* %cond, %struct.elem** %right, align 4
  %7 = load i8*, i8** %obj.addr, align 4
  %arrayidx5 = getelementptr inbounds i8, i8* %7, i32 0
  %8 = load i8, i8* %arrayidx5, align 1
  %call6 = call i32 @isOperator(i8 signext %8)
  %cmp7 = icmp eq i32 %call6, 1
  br i1 %cmp7, label %cond.true8, label %cond.false11

cond.true8:                                       ; preds = %cond.end
  %call9 = call i8* @getNextString()
  %9 = load i8*, i8** %trace.addr, align 4
  %call10 = call %struct.elem* @buildTree(i8* %call9, i8* %9)
  br label %cond.end12

cond.false11:                                     ; preds = %cond.end
  br label %cond.end12

cond.end12:                                       ; preds = %cond.false11, %cond.true8
  %cond13 = phi %struct.elem* [ %call10, %cond.true8 ], [ null, %cond.false11 ]
  %10 = load %struct.elem*, %struct.elem** %t, align 4
  %left = getelementptr inbounds %struct.elem, %struct.elem* %10, i32 0, i32 1
  store %struct.elem* %cond13, %struct.elem** %left, align 4
  %11 = load i8*, i8** %trace.addr, align 4
  %cmp14 = icmp ne i8* %11, null
  br i1 %cmp14, label %if.then, label %if.end

if.then:                                          ; preds = %cond.end12
  %call15 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([2 x i8], [2 x i8]* @.str.4, i32 0, i32 0))
  %12 = load %struct.elem*, %struct.elem** %t, align 4
  call void @inorder(%struct.elem* %12)
  br label %if.end

if.end:                                           ; preds = %if.then, %cond.end12
  %13 = load %struct.elem*, %struct.elem** %t, align 4
  ret %struct.elem* %13
}

declare noalias i8* @malloc(i32 %0) #1

declare i8* @strcpy(i8* %0, i8* %1) #1

; Function Attrs: noinline nounwind optnone
define hidden i32 @checkRPN() #0 {
entry:
  %retval = alloca i32, align 4
  %i = alloca i32, align 4
  %operSum = alloca i32, align 4
  %numberSum = alloca i32, align 4
  store i32 0, i32* %operSum, align 4
  store i32 0, i32* %numberSum, align 4
  %0 = load i8**, i8*** @components, align 4
  %1 = load i32, i32* @counter, align 4
  %arrayidx = getelementptr inbounds i8*, i8** %0, i32 %1
  %2 = load i8*, i8** %arrayidx, align 4
  %arrayidx1 = getelementptr inbounds i8, i8* %2, i32 0
  %3 = load i8, i8* %arrayidx1, align 1
  %call = call i32 @isOperator(i8 signext %3)
  %cmp = icmp eq i32 %call, 0
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  store i32 0, i32* %retval, align 4
  br label %return

if.end:                                           ; preds = %entry
  store i32 0, i32* %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.end
  %4 = load i32, i32* %i, align 4
  %5 = load i32, i32* @counter, align 4
  %cmp2 = icmp sle i32 %4, %5
  br i1 %cmp2, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %6 = load i8**, i8*** @components, align 4
  %7 = load i32, i32* %i, align 4
  %arrayidx3 = getelementptr inbounds i8*, i8** %6, i32 %7
  %8 = load i8*, i8** %arrayidx3, align 4
  %arrayidx4 = getelementptr inbounds i8, i8* %8, i32 0
  %9 = load i8, i8* %arrayidx4, align 1
  %call5 = call i32 @isOperator(i8 signext %9)
  %cmp6 = icmp eq i32 %call5, 1
  br i1 %cmp6, label %cond.true, label %cond.false

cond.true:                                        ; preds = %for.body
  %10 = load i32, i32* %operSum, align 4
  %inc = add nsw i32 %10, 1
  store i32 %inc, i32* %operSum, align 4
  br label %cond.end

cond.false:                                       ; preds = %for.body
  %11 = load i32, i32* %numberSum, align 4
  %inc7 = add nsw i32 %11, 1
  store i32 %inc7, i32* %numberSum, align 4
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi i32 [ %10, %cond.true ], [ %11, %cond.false ]
  br label %for.inc

for.inc:                                          ; preds = %cond.end
  %12 = load i32, i32* %i, align 4
  %inc8 = add nsw i32 %12, 1
  store i32 %inc8, i32* %i, align 4
  br label %for.cond

for.end:                                          ; preds = %for.cond
  %13 = load i32, i32* %numberSum, align 4
  %14 = load i32, i32* %operSum, align 4
  %sub = sub nsw i32 %13, %14
  %cmp9 = icmp eq i32 %sub, 1
  %conv = zext i1 %cmp9 to i32
  store i32 %conv, i32* %retval, align 4
  br label %return

return:                                           ; preds = %for.end, %if.then
  %15 = load i32, i32* %retval, align 4
  ret i32 %15
}

; Function Attrs: noinline nounwind optnone
define hidden void @buildStack(i8* %str) #0 {
entry:
  %str.addr = alloca i8*, align 4
  %i = alloca i32, align 4
  %token = alloca i8*, align 4
  store i8* %str, i8** %str.addr, align 4
  store i32 0, i32* %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %0 = load i8*, i8** %str.addr, align 4
  %1 = load i32, i32* %i, align 4
  %arrayidx = getelementptr inbounds i8, i8* %0, i32 %1
  %2 = load i8, i8* %arrayidx, align 1
  %conv = sext i8 %2 to i32
  %cmp = icmp ne i32 %conv, 0
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %3 = load i8*, i8** %str.addr, align 4
  %4 = load i32, i32* %i, align 4
  %arrayidx2 = getelementptr inbounds i8, i8* %3, i32 %4
  %5 = load i8, i8* %arrayidx2, align 1
  %conv3 = sext i8 %5 to i32
  %cmp4 = icmp eq i32 %conv3, 32
  br i1 %cmp4, label %if.then, label %if.end

if.then:                                          ; preds = %for.body
  %6 = load i32, i32* @counter, align 4
  %inc = add nsw i32 %6, 1
  store i32 %inc, i32* @counter, align 4
  br label %if.end

if.end:                                           ; preds = %if.then, %for.body
  br label %for.inc

for.inc:                                          ; preds = %if.end
  %7 = load i32, i32* %i, align 4
  %inc6 = add nsw i32 %7, 1
  store i32 %inc6, i32* %i, align 4
  br label %for.cond

for.end:                                          ; preds = %for.cond
  %8 = load i32, i32* @counter, align 4
  %add = add nsw i32 %8, 1
  %mul = mul i32 %add, 4
  %call = call noalias i8* @malloc(i32 %mul)
  %9 = bitcast i8* %call to i8**
  store i8** %9, i8*** @components, align 4
  %10 = load i8*, i8** %str.addr, align 4
  %call7 = call i8* @strtok(i8* %10, i8* getelementptr inbounds ([2 x i8], [2 x i8]* @.str.5, i32 0, i32 0))
  store i8* %call7, i8** %token, align 4
  store i32 0, i32* %i, align 4
  br label %while.cond

while.cond:                                       ; preds = %while.body, %for.end
  %11 = load i8*, i8** %token, align 4
  %cmp8 = icmp ne i8* %11, null
  br i1 %cmp8, label %while.body, label %while.end

while.body:                                       ; preds = %while.cond
  %12 = load i8*, i8** %token, align 4
  %call10 = call i32 @strlen(i8* %12) #5
  %call12 = call noalias i8* @malloc(i32 %call10)
  %13 = load i8**, i8*** @components, align 4
  %14 = load i32, i32* %i, align 4
  %arrayidx13 = getelementptr inbounds i8*, i8** %13, i32 %14
  store i8* %call12, i8** %arrayidx13, align 4
  %15 = load i8**, i8*** @components, align 4
  %16 = load i32, i32* %i, align 4
  %arrayidx14 = getelementptr inbounds i8*, i8** %15, i32 %16
  %17 = load i8*, i8** %arrayidx14, align 4
  %18 = load i8*, i8** %token, align 4
  %call15 = call i8* @strcpy(i8* %17, i8* %18)
  %call16 = call i8* @strtok(i8* null, i8* getelementptr inbounds ([2 x i8], [2 x i8]* @.str.5, i32 0, i32 0))
  store i8* %call16, i8** %token, align 4
  %19 = load i32, i32* %i, align 4
  %inc17 = add nsw i32 %19, 1
  store i32 %inc17, i32* %i, align 4
  br label %while.cond

while.end:                                        ; preds = %while.cond
  ret void
}

declare i8* @strtok(i8* %0, i8* %1) #1

; Function Attrs: nounwind readonly
declare i32 @strlen(i8* %0) #3

; Function Attrs: noinline nounwind optnone
define hidden i32 @__main_argc_argv(i32 %argC, i8** %argV) #0 {
entry:
  %retval = alloca i32, align 4
  %argC.addr = alloca i32, align 4
  %argV.addr = alloca i8**, align 4
  %i = alloca i32, align 4
  %t = alloca %struct.elem*, align 4
  store i32 0, i32* %retval, align 4
  store i32 %argC, i32* %argC.addr, align 4
  store i8** %argV, i8*** %argV.addr, align 4
  %0 = load i32, i32* %argC.addr, align 4
  %cmp = icmp eq i32 %0, 1
  br i1 %cmp, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  %1 = load i8**, i8*** %argV.addr, align 4
  %arrayidx = getelementptr inbounds i8*, i8** %1, i32 0
  %2 = load i8*, i8** %arrayidx, align 4
  %call = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([95 x i8], [95 x i8]* @.str.6, i32 0, i32 0), i8* %2)
  br label %if.end10

if.else:                                          ; preds = %entry
  %3 = load i8**, i8*** %argV.addr, align 4
  %arrayidx1 = getelementptr inbounds i8*, i8** %3, i32 1
  %4 = load i8*, i8** %arrayidx1, align 4
  call void @buildStack(i8* %4)
  %call2 = call i32 @checkRPN()
  %cmp3 = icmp eq i32 %call2, 0
  br i1 %cmp3, label %if.then4, label %if.end

if.then4:                                         ; preds = %if.else
  %call5 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([15 x i8], [15 x i8]* @.str.3, i32 0, i32 0))
  store i32 0, i32* %retval, align 4
  br label %return

if.end:                                           ; preds = %if.else
  %call6 = call i8* @getNextString()
  %5 = load i8**, i8*** %argV.addr, align 4
  %arrayidx7 = getelementptr inbounds i8*, i8** %5, i32 2
  %6 = load i8*, i8** %arrayidx7, align 4
  %call8 = call %struct.elem* @buildTree(i8* %call6, i8* %6)
  store %struct.elem* %call8, %struct.elem** %t, align 4
  %call9 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([27 x i8], [27 x i8]* @.str.7, i32 0, i32 0))
  %7 = load %struct.elem*, %struct.elem** %t, align 4
  call void @inorder(%struct.elem* %7)
  br label %if.end10

if.end10:                                         ; preds = %if.end, %if.then
  store i32 0, i32* %retval, align 4
  br label %return

return:                                           ; preds = %if.end10, %if.then4
  %8 = load i32, i32* %retval, align 4
  ret i32 %8
}

attributes #0 = { noinline nounwind optnone "correctly-rounded-divide-sqrt-fp-math"="false" "disable-tail-calls"="false" "frame-pointer"="none" "less-precise-fpmad"="false" "min-legal-vector-width"="0" "no-infs-fp-math"="false" "no-jump-tables"="false" "no-nans-fp-math"="false" "no-signed-zeros-fp-math"="false" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="generic" "unsafe-fp-math"="false" "use-soft-float"="false" }
attributes #1 = { "correctly-rounded-divide-sqrt-fp-math"="false" "disable-tail-calls"="false" "frame-pointer"="none" "less-precise-fpmad"="false" "no-infs-fp-math"="false" "no-nans-fp-math"="false" "no-signed-zeros-fp-math"="false" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="generic" "unsafe-fp-math"="false" "use-soft-float"="false" }
attributes #2 = { noreturn "correctly-rounded-divide-sqrt-fp-math"="false" "disable-tail-calls"="false" "frame-pointer"="none" "less-precise-fpmad"="false" "no-infs-fp-math"="false" "no-nans-fp-math"="false" "no-signed-zeros-fp-math"="false" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="generic" "unsafe-fp-math"="false" "use-soft-float"="false" }
attributes #3 = { nounwind readonly "correctly-rounded-divide-sqrt-fp-math"="false" "disable-tail-calls"="false" "frame-pointer"="none" "less-precise-fpmad"="false" "no-infs-fp-math"="false" "no-nans-fp-math"="false" "no-signed-zeros-fp-math"="false" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="generic" "unsafe-fp-math"="false" "use-soft-float"="false" }
attributes #4 = { noreturn }
attributes #5 = { nounwind readonly }

!llvm.module.flags = !{!0}
!llvm.ident = !{!1}

!0 = !{i32 1, !"wchar_size", i32 4}
!1 = !{!"clang version 11.0.0 (https://github.com/Jacarte/llvm-project.git 0f6dea67136cc1e0b3d200eb2bb165628970c44b)"}

; extracted candidates

; *****
; For LLVM instruction:
;  %0 = load i32, i32* %argC.addr, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %cmp = icmp eq i32 %0, 1
; Looking for a replacement for:
%0:i32 = var
%1:i1 = eq 1:i32, %0
infer %1

; *****
; For LLVM instruction:
;  %call2 = call i32 @checkRPN()
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %cmp3 = icmp eq i32 %call2, 0
; Looking for a replacement for:
%0:i32 = var
%1:i1 = eq 0:i32, %0
infer %1

; *****
; For LLVM instruction:
;  %8 = load i32, i32* %retval, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0
#########################################################
; exiting Souper's runOnFunction() for __main_argc_argv()
Total of 1 replacements done on this module
Total of 1 replacements candidates on this module
