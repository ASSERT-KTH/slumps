
Entering the Souper pass's runOnModule()


; entering Souper's runOnFunction() for best_match()

; ModuleID = './Vigenère_cipher-Cryptanalysis.c.bc'
source_filename = "./Vigene\CC\80re_cipher-Cryptanalysis.c"
target datalayout = "e-m:e-p:32:32-i64:64-n32:64-S128"
target triple = "wasm32-unknown-wasi"

@.str = private unnamed_addr constant [978 x i8] c"MOMUD EKAPV TQEFM OEVHP AJMII CDCTI FGYAG JSPXY ALUYM NSMYHVUXJE LEPXJ FXGCM JHKDZ RYICU HYPUS PGIGM OIYHF WHTCQ KMLRDITLXZ LJFVQ GHOLW CUHLO MDSOE KTALU VYLNZ RFGBX PHVGA LWQISFGRPH JOOFW GUBYI LAPLA LCAFA AMKLG CETDW VOELJ IKGJB XPHVGALWQC SNWBU BYHCU HKOCE XJEYK BQKVY KIIEH GRLGH XEOLW AWFOJILOVV RHPKD WIHKN ATUHN VRYAQ DIVHX FHRZV QWMWV LGSHN NLVZSJLAKI FHXUF XJLXM TBLQV RXXHR FZXGV LRAJI EXPRV OSMNP KEPDTLPRWM JAZPK LQUZA ALGZX GVLKL GJTUI ITDSU REZXJ ERXZS HMPSTMTEOE PAPJH SMFNB YVQUZ AALGA YDNMP AQOWT UHDBV TSMUE UIMVHQGVRW AEFSP EMPVE PKXZY WLKJA GWALT VYYOB YIXOK IHPDS EVLEVRVSGB JOGYW FHKBL GLXYA MVKIS KIEHY IMAPX UOISK PVAGN MZHPWTTZPV XFCCD TUHJH WLAPF YULTB UXJLN SIJVV YOVDJ SOLXG TGRVOSFRII CTMKO JFCQF KTINQ BWVHG TENLH HOGCS PSFPV GJOKM SIFPRZPAAS ATPTZ FTPPD PORRF TAXZP KALQA WMIUD BWNCT LEFKO ZQDLXBUXJL ASIMR PNMBF ZCYLV WAPVF QRHZV ZGZEF KBYIO OFXYE VOWGBBXVCB XBAWG LQKCM ICRRX MACUO IKHQU AJEGL OIJHH XPVZW JEWBAFWAML ZZRXJ EKAHV FASMU LVVUT TGK\00", align 1
@encoded = hidden global i8* getelementptr inbounds ([978 x i8], [978 x i8]* @.str, i32 0, i32 0), align 4
@freq = hidden constant [26 x double] [double 8.167000e-02, double 1.492000e-02, double 2.782000e-02, double 4.253000e-02, double 1.270200e-01, double 2.228000e-02, double 2.015000e-02, double 6.094000e-02, double 6.966000e-02, double 1.530000e-03, double 7.720000e-03, double 4.025000e-02, double 2.406000e-02, double 6.749000e-02, double 7.507000e-02, double 1.929000e-02, double 0x3F4F212D77318FC5, double 5.987000e-02, double 6.327000e-02, double 9.056000e-02, double 2.758000e-02, double 9.780000e-03, double 2.360000e-02, double 1.500000e-03, double 1.974000e-02, double 7.400000e-04], align 16
@.str.1 = private unnamed_addr constant [24 x i8] c"%f, key length: %2d, %s\00", align 1
@.str.2 = private unnamed_addr constant [18 x i8] c" <--- best so far\00", align 1
@.str.3 = private unnamed_addr constant [2 x i8] c"\0A\00", align 1
@llvm.used = appending global [1 x i8*] [i8* bitcast (i32 ()* @__main_void to i8*)], section "llvm.metadata"

@__main_void = alias i32 (), i32 ()* @main

; Function Attrs: noinline nounwind optnone
define hidden i32 @best_match(double* %a, double* %b) #0 {
entry:
  %a.addr = alloca double*, align 4
  %b.addr = alloca double*, align 4
  %sum = alloca double, align 8
  %fit = alloca double, align 8
  %d = alloca double, align 8
  %best_fit = alloca double, align 8
  %i = alloca i32, align 4
  %rotate = alloca i32, align 4
  %best_rotate = alloca i32, align 4
  store double* %a, double** %a.addr, align 4
  store double* %b, double** %b.addr, align 4
  store double 0.000000e+00, double* %sum, align 8
  store double 1.000000e+100, double* %best_fit, align 8
  store i32 0, i32* %best_rotate, align 4
  store i32 0, i32* %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %0 = load i32, i32* %i, align 4
  %cmp = icmp slt i32 %0, 26
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %1 = load double*, double** %a.addr, align 4
  %2 = load i32, i32* %i, align 4
  %arrayidx = getelementptr inbounds double, double* %1, i32 %2
  %3 = load double, double* %arrayidx, align 8
  %4 = load double, double* %sum, align 8
  %add = fadd double %4, %3
  store double %add, double* %sum, align 8
  br label %for.inc

for.inc:                                          ; preds = %for.body
  %5 = load i32, i32* %i, align 4
  %inc = add nsw i32 %5, 1
  store i32 %inc, i32* %i, align 4
  br label %for.cond

for.end:                                          ; preds = %for.cond
  store i32 0, i32* %rotate, align 4
  br label %for.cond1

for.cond1:                                        ; preds = %for.inc17, %for.end
  %6 = load i32, i32* %rotate, align 4
  %cmp2 = icmp slt i32 %6, 26
  br i1 %cmp2, label %for.body3, label %for.end19

for.body3:                                        ; preds = %for.cond1
  store double 0.000000e+00, double* %fit, align 8
  store i32 0, i32* %i, align 4
  br label %for.cond4

for.cond4:                                        ; preds = %for.inc13, %for.body3
  %7 = load i32, i32* %i, align 4
  %cmp5 = icmp slt i32 %7, 26
  br i1 %cmp5, label %for.body6, label %for.end15

for.body6:                                        ; preds = %for.cond4
  %8 = load double*, double** %a.addr, align 4
  %9 = load i32, i32* %i, align 4
  %10 = load i32, i32* %rotate, align 4
  %add7 = add nsw i32 %9, %10
  %rem = srem i32 %add7, 26
  %arrayidx8 = getelementptr inbounds double, double* %8, i32 %rem
  %11 = load double, double* %arrayidx8, align 8
  %12 = load double, double* %sum, align 8
  %div = fdiv double %11, %12
  %13 = load double*, double** %b.addr, align 4
  %14 = load i32, i32* %i, align 4
  %arrayidx9 = getelementptr inbounds double, double* %13, i32 %14
  %15 = load double, double* %arrayidx9, align 8
  %sub = fsub double %div, %15
  store double %sub, double* %d, align 8
  %16 = load double, double* %d, align 8
  %17 = load double, double* %d, align 8
  %mul = fmul double %16, %17
  %18 = load double*, double** %b.addr, align 4
  %19 = load i32, i32* %i, align 4
  %arrayidx10 = getelementptr inbounds double, double* %18, i32 %19
  %20 = load double, double* %arrayidx10, align 8
  %div11 = fdiv double %mul, %20
  %21 = load double, double* %fit, align 8
  %add12 = fadd double %21, %div11
  store double %add12, double* %fit, align 8
  br label %for.inc13

for.inc13:                                        ; preds = %for.body6
  %22 = load i32, i32* %i, align 4
  %inc14 = add nsw i32 %22, 1
  store i32 %inc14, i32* %i, align 4
  br label %for.cond4

for.end15:                                        ; preds = %for.cond4
  %23 = load double, double* %fit, align 8
  %24 = load double, double* %best_fit, align 8
  %cmp16 = fcmp olt double %23, %24
  br i1 %cmp16, label %if.then, label %if.end

if.then:                                          ; preds = %for.end15
  %25 = load double, double* %fit, align 8
  store double %25, double* %best_fit, align 8
  %26 = load i32, i32* %rotate, align 4
  store i32 %26, i32* %best_rotate, align 4
  br label %if.end

if.end:                                           ; preds = %if.then, %for.end15
  br label %for.inc17

for.inc17:                                        ; preds = %if.end
  %27 = load i32, i32* %rotate, align 4
  %inc18 = add nsw i32 %27, 1
  store i32 %inc18, i32* %rotate, align 4
  br label %for.cond1

for.end19:                                        ; preds = %for.cond1
  %28 = load i32, i32* %best_rotate, align 4
  ret i32 %28
}

; Function Attrs: noinline nounwind optnone
define hidden double @freq_every_nth(i32* %msg, i32 %len, i32 %interval, i8* %key) #0 {
entry:
  %msg.addr = alloca i32*, align 4
  %len.addr = alloca i32, align 4
  %interval.addr = alloca i32, align 4
  %key.addr = alloca i8*, align 4
  %sum = alloca double, align 8
  %d = alloca double, align 8
  %ret = alloca double, align 8
  %out = alloca [26 x double], align 16
  %accu = alloca [26 x double], align 16
  %i = alloca i32, align 4
  %j = alloca i32, align 4
  %rot = alloca i32, align 4
  store i32* %msg, i32** %msg.addr, align 4
  store i32 %len, i32* %len.addr, align 4
  store i32 %interval, i32* %interval.addr, align 4
  store i8* %key, i8** %key.addr, align 4
  %0 = bitcast [26 x double]* %accu to i8*
  call void @llvm.memset.p0i8.i32(i8* align 16 %0, i8 0, i32 208, i1 false)
  store i32 0, i32* %j, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc28, %entry
  %1 = load i32, i32* %j, align 4
  %2 = load i32, i32* %interval.addr, align 4
  %cmp = icmp slt i32 %1, %2
  br i1 %cmp, label %for.body, label %for.end30

for.body:                                         ; preds = %for.cond
  store i32 0, i32* %i, align 4
  br label %for.cond1

for.cond1:                                        ; preds = %for.inc, %for.body
  %3 = load i32, i32* %i, align 4
  %cmp2 = icmp slt i32 %3, 26
  br i1 %cmp2, label %for.body3, label %for.end

for.body3:                                        ; preds = %for.cond1
  %4 = load i32, i32* %i, align 4
  %arrayidx = getelementptr inbounds [26 x double], [26 x double]* %out, i32 0, i32 %4
  store double 0.000000e+00, double* %arrayidx, align 8
  br label %for.inc

for.inc:                                          ; preds = %for.body3
  %5 = load i32, i32* %i, align 4
  %inc = add nsw i32 %5, 1
  store i32 %inc, i32* %i, align 4
  br label %for.cond1

for.end:                                          ; preds = %for.cond1
  %6 = load i32, i32* %j, align 4
  store i32 %6, i32* %i, align 4
  br label %for.cond4

for.cond4:                                        ; preds = %for.inc10, %for.end
  %7 = load i32, i32* %i, align 4
  %8 = load i32, i32* %len.addr, align 4
  %cmp5 = icmp slt i32 %7, %8
  br i1 %cmp5, label %for.body6, label %for.end11

for.body6:                                        ; preds = %for.cond4
  %9 = load i32*, i32** %msg.addr, align 4
  %10 = load i32, i32* %i, align 4
  %arrayidx7 = getelementptr inbounds i32, i32* %9, i32 %10
  %11 = load i32, i32* %arrayidx7, align 4
  %arrayidx8 = getelementptr inbounds [26 x double], [26 x double]* %out, i32 0, i32 %11
  %12 = load double, double* %arrayidx8, align 8
  %inc9 = fadd double %12, 1.000000e+00
  store double %inc9, double* %arrayidx8, align 8
  br label %for.inc10

for.inc10:                                        ; preds = %for.body6
  %13 = load i32, i32* %interval.addr, align 4
  %14 = load i32, i32* %i, align 4
  %add = add nsw i32 %14, %13
  store i32 %add, i32* %i, align 4
  br label %for.cond4

for.end11:                                        ; preds = %for.cond4
  %arraydecay = getelementptr inbounds [26 x double], [26 x double]* %out, i32 0, i32 0
  %call = call i32 @best_match(double* %arraydecay, double* getelementptr inbounds ([26 x double], [26 x double]* @freq, i32 0, i32 0))
  store i32 %call, i32* %rot, align 4
  %conv = trunc i32 %call to i8
  %15 = load i8*, i8** %key.addr, align 4
  %16 = load i32, i32* %j, align 4
  %arrayidx12 = getelementptr inbounds i8, i8* %15, i32 %16
  store i8 %conv, i8* %arrayidx12, align 1
  %17 = load i8*, i8** %key.addr, align 4
  %18 = load i32, i32* %j, align 4
  %arrayidx13 = getelementptr inbounds i8, i8* %17, i32 %18
  %19 = load i8, i8* %arrayidx13, align 1
  %conv14 = sext i8 %19 to i32
  %add15 = add nsw i32 %conv14, 65
  %conv16 = trunc i32 %add15 to i8
  store i8 %conv16, i8* %arrayidx13, align 1
  store i32 0, i32* %i, align 4
  br label %for.cond17

for.cond17:                                       ; preds = %for.inc25, %for.end11
  %20 = load i32, i32* %i, align 4
  %cmp18 = icmp slt i32 %20, 26
  br i1 %cmp18, label %for.body20, label %for.end27

for.body20:                                       ; preds = %for.cond17
  %21 = load i32, i32* %i, align 4
  %22 = load i32, i32* %rot, align 4
  %add21 = add nsw i32 %21, %22
  %rem = srem i32 %add21, 26
  %arrayidx22 = getelementptr inbounds [26 x double], [26 x double]* %out, i32 0, i32 %rem
  %23 = load double, double* %arrayidx22, align 8
  %24 = load i32, i32* %i, align 4
  %arrayidx23 = getelementptr inbounds [26 x double], [26 x double]* %accu, i32 0, i32 %24
  %25 = load double, double* %arrayidx23, align 8
  %add24 = fadd double %25, %23
  store double %add24, double* %arrayidx23, align 8
  br label %for.inc25

for.inc25:                                        ; preds = %for.body20
  %26 = load i32, i32* %i, align 4
  %inc26 = add nsw i32 %26, 1
  store i32 %inc26, i32* %i, align 4
  br label %for.cond17

for.end27:                                        ; preds = %for.cond17
  br label %for.inc28

for.inc28:                                        ; preds = %for.end27
  %27 = load i32, i32* %j, align 4
  %inc29 = add nsw i32 %27, 1
  store i32 %inc29, i32* %j, align 4
  br label %for.cond

for.end30:                                        ; preds = %for.cond
  store i32 0, i32* %i, align 4
  store double 0.000000e+00, double* %sum, align 8
  br label %for.cond31

for.cond31:                                       ; preds = %for.inc37, %for.end30
  %28 = load i32, i32* %i, align 4
  %cmp32 = icmp slt i32 %28, 26
  br i1 %cmp32, label %for.body34, label %for.end39

for.body34:                                       ; preds = %for.cond31
  %29 = load i32, i32* %i, align 4
  %arrayidx35 = getelementptr inbounds [26 x double], [26 x double]* %accu, i32 0, i32 %29
  %30 = load double, double* %arrayidx35, align 8
  %31 = load double, double* %sum, align 8
  %add36 = fadd double %31, %30
  store double %add36, double* %sum, align 8
  br label %for.inc37

for.inc37:                                        ; preds = %for.body34
  %32 = load i32, i32* %i, align 4
  %inc38 = add nsw i32 %32, 1
  store i32 %inc38, i32* %i, align 4
  br label %for.cond31

for.end39:                                        ; preds = %for.cond31
  store i32 0, i32* %i, align 4
  store double 0.000000e+00, double* %ret, align 8
  br label %for.cond40

for.cond40:                                       ; preds = %for.inc49, %for.end39
  %33 = load i32, i32* %i, align 4
  %cmp41 = icmp slt i32 %33, 26
  br i1 %cmp41, label %for.body43, label %for.end51

for.body43:                                       ; preds = %for.cond40
  %34 = load i32, i32* %i, align 4
  %arrayidx44 = getelementptr inbounds [26 x double], [26 x double]* %accu, i32 0, i32 %34
  %35 = load double, double* %arrayidx44, align 8
  %36 = load double, double* %sum, align 8
  %div = fdiv double %35, %36
  %37 = load i32, i32* %i, align 4
  %arrayidx45 = getelementptr inbounds [26 x double], [26 x double]* @freq, i32 0, i32 %37
  %38 = load double, double* %arrayidx45, align 8
  %sub = fsub double %div, %38
  store double %sub, double* %d, align 8
  %39 = load double, double* %d, align 8
  %40 = load double, double* %d, align 8
  %mul = fmul double %39, %40
  %41 = load i32, i32* %i, align 4
  %arrayidx46 = getelementptr inbounds [26 x double], [26 x double]* @freq, i32 0, i32 %41
  %42 = load double, double* %arrayidx46, align 8
  %div47 = fdiv double %mul, %42
  %43 = load double, double* %ret, align 8
  %add48 = fadd double %43, %div47
  store double %add48, double* %ret, align 8
  br label %for.inc49

for.inc49:                                        ; preds = %for.body43
  %44 = load i32, i32* %i, align 4
  %inc50 = add nsw i32 %44, 1
  store i32 %inc50, i32* %i, align 4
  br label %for.cond40

for.end51:                                        ; preds = %for.cond40
  %45 = load i8*, i8** %key.addr, align 4
  %46 = load i32, i32* %interval.addr, align 4
  %arrayidx52 = getelementptr inbounds i8, i8* %45, i32 %46
  store i8 0, i8* %arrayidx52, align 1
  %47 = load double, double* %ret, align 8
  ret double %47
}

; Function Attrs: argmemonly nounwind willreturn writeonly
declare void @llvm.memset.p0i8.i32(i8* nocapture writeonly %0, i8 %1, i32 %2, i1 immarg %3) #1

; Function Attrs: noinline nounwind optnone
define hidden i32 @main() #0 {
entry:
  %retval = alloca i32, align 4
  %saved_stack = alloca i8*, align 4
  %__vla_expr0 = alloca i32, align 4
  %len = alloca i32, align 4
  %j = alloca i32, align 4
  %key = alloca [100 x i8], align 16
  %fit = alloca double, align 8
  %best_fit = alloca double, align 8
  store i32 0, i32* %retval, align 4
  %0 = load i8*, i8** @encoded, align 4
  %call = call i32 @strlen(i8* %0) #5
  %1 = call i8* @llvm.stacksave()
  store i8* %1, i8** %saved_stack, align 4
  %vla = alloca i32, i32 %call, align 16
  store i32 %call, i32* %__vla_expr0, align 4
  store i32 0, i32* %len, align 4
  store double 1.000000e+100, double* %best_fit, align 8
  store i32 0, i32* %j, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %2 = load i8*, i8** @encoded, align 4
  %3 = load i32, i32* %j, align 4
  %arrayidx = getelementptr inbounds i8, i8* %2, i32 %3
  %4 = load i8, i8* %arrayidx, align 1
  %conv = sext i8 %4 to i32
  %cmp = icmp ne i32 %conv, 0
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  br i1 false, label %cond.true, label %cond.false

cond.true:                                        ; preds = %for.body
  %5 = load i8*, i8** @encoded, align 4
  %6 = load i32, i32* %j, align 4
  %arrayidx2 = getelementptr inbounds i8, i8* %5, i32 %6
  %7 = load i8, i8* %arrayidx2, align 1
  %conv3 = sext i8 %7 to i32
  %call4 = call i32 @isupper(i32 %conv3) #5
  %tobool = icmp ne i32 %call4, 0
  br i1 %tobool, label %if.then, label %if.end

cond.false:                                       ; preds = %for.body
  %8 = load i8*, i8** @encoded, align 4
  %9 = load i32, i32* %j, align 4
  %arrayidx5 = getelementptr inbounds i8, i8* %8, i32 %9
  %10 = load i8, i8* %arrayidx5, align 1
  %conv6 = sext i8 %10 to i32
  %sub = sub i32 %conv6, 65
  %cmp7 = icmp ult i32 %sub, 26
  br i1 %cmp7, label %if.then, label %if.end

if.then:                                          ; preds = %cond.false, %cond.true
  %11 = load i8*, i8** @encoded, align 4
  %12 = load i32, i32* %j, align 4
  %arrayidx9 = getelementptr inbounds i8, i8* %11, i32 %12
  %13 = load i8, i8* %arrayidx9, align 1
  %conv10 = sext i8 %13 to i32
  %sub11 = sub nsw i32 %conv10, 65
  %14 = load i32, i32* %len, align 4
  %inc = add nsw i32 %14, 1
  store i32 %inc, i32* %len, align 4
  %arrayidx12 = getelementptr inbounds i32, i32* %vla, i32 %14
  store i32 %sub11, i32* %arrayidx12, align 4
  br label %if.end

if.end:                                           ; preds = %if.then, %cond.false, %cond.true
  br label %for.inc

for.inc:                                          ; preds = %if.end
  %15 = load i32, i32* %j, align 4
  %inc13 = add nsw i32 %15, 1
  store i32 %inc13, i32* %j, align 4
  br label %for.cond

for.end:                                          ; preds = %for.cond
  store i32 1, i32* %j, align 4
  br label %for.cond14

for.cond14:                                       ; preds = %for.inc27, %for.end
  %16 = load i32, i32* %j, align 4
  %cmp15 = icmp slt i32 %16, 30
  br i1 %cmp15, label %for.body17, label %for.end29

for.body17:                                       ; preds = %for.cond14
  %17 = load i32, i32* %len, align 4
  %18 = load i32, i32* %j, align 4
  %arraydecay = getelementptr inbounds [100 x i8], [100 x i8]* %key, i32 0, i32 0
  %call18 = call double @freq_every_nth(i32* %vla, i32 %17, i32 %18, i8* %arraydecay)
  store double %call18, double* %fit, align 8
  %19 = load double, double* %fit, align 8
  %20 = load i32, i32* %j, align 4
  %arraydecay19 = getelementptr inbounds [100 x i8], [100 x i8]* %key, i32 0, i32 0
  %call20 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([24 x i8], [24 x i8]* @.str.1, i32 0, i32 0), double %19, i32 %20, i8* %arraydecay19)
  %21 = load double, double* %fit, align 8
  %22 = load double, double* %best_fit, align 8
  %cmp21 = fcmp olt double %21, %22
  br i1 %cmp21, label %if.then23, label %if.end25

if.then23:                                        ; preds = %for.body17
  %23 = load double, double* %fit, align 8
  store double %23, double* %best_fit, align 8
  %call24 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([18 x i8], [18 x i8]* @.str.2, i32 0, i32 0))
  br label %if.end25

if.end25:                                         ; preds = %if.then23, %for.body17
  %call26 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([2 x i8], [2 x i8]* @.str.3, i32 0, i32 0))
  br label %for.inc27

for.inc27:                                        ; preds = %if.end25
  %24 = load i32, i32* %j, align 4
  %inc28 = add nsw i32 %24, 1
  store i32 %inc28, i32* %j, align 4
  br label %for.cond14

for.end29:                                        ; preds = %for.cond14
  store i32 0, i32* %retval, align 4
  %25 = load i8*, i8** %saved_stack, align 4
  call void @llvm.stackrestore(i8* %25)
  %26 = load i32, i32* %retval, align 4
  ret i32 %26
}

; Function Attrs: nounwind readonly
declare i32 @strlen(i8* %0) #2

; Function Attrs: nounwind
declare i8* @llvm.stacksave() #3

; Function Attrs: nounwind readonly
declare i32 @isupper(i32 %0) #2

declare i32 @printf(i8* %0, ...) #4

; Function Attrs: nounwind
declare void @llvm.stackrestore(i8* %0) #3

attributes #0 = { noinline nounwind optnone "correctly-rounded-divide-sqrt-fp-math"="false" "disable-tail-calls"="false" "frame-pointer"="none" "less-precise-fpmad"="false" "min-legal-vector-width"="0" "no-infs-fp-math"="false" "no-jump-tables"="false" "no-nans-fp-math"="false" "no-signed-zeros-fp-math"="false" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="generic" "unsafe-fp-math"="false" "use-soft-float"="false" }
attributes #1 = { argmemonly nounwind willreturn writeonly }
attributes #2 = { nounwind readonly "correctly-rounded-divide-sqrt-fp-math"="false" "disable-tail-calls"="false" "frame-pointer"="none" "less-precise-fpmad"="false" "no-infs-fp-math"="false" "no-nans-fp-math"="false" "no-signed-zeros-fp-math"="false" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="generic" "unsafe-fp-math"="false" "use-soft-float"="false" }
attributes #3 = { nounwind }
attributes #4 = { "correctly-rounded-divide-sqrt-fp-math"="false" "disable-tail-calls"="false" "frame-pointer"="none" "less-precise-fpmad"="false" "no-infs-fp-math"="false" "no-nans-fp-math"="false" "no-signed-zeros-fp-math"="false" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="generic" "unsafe-fp-math"="false" "use-soft-float"="false" }
attributes #5 = { nounwind readonly }

!llvm.module.flags = !{!0}
!llvm.ident = !{!1}

!0 = !{i32 1, !"wchar_size", i32 4}
!1 = !{!"clang version 11.0.0 (https://github.com/Jacarte/llvm-project.git 0f6dea67136cc1e0b3d200eb2bb165628970c44b)"}

; extracted candidates

; *****
; For LLVM instruction:
;  %0 = load i32, i32* %i, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %cmp = icmp slt i32 %0, 26
; Looking for a replacement for:
%0:i32 = var
%1:i1 = slt %0, 26:i32
infer %1

; *****
; For LLVM instruction:
;  %2 = load i32, i32* %i, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %5 = load i32, i32* %i, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %inc = add nsw i32 %5, 1
; Looking for a replacement for:
%0:i32 = var
%1:i32 = addnsw 1:i32, %0
infer %1

; *****
; For LLVM instruction:
;  %6 = load i32, i32* %rotate, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %cmp2 = icmp slt i32 %6, 26
; Looking for a replacement for:
%0:i32 = var
%1:i1 = slt %0, 26:i32
infer %1

; *****
; For LLVM instruction:
;  %7 = load i32, i32* %i, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %cmp5 = icmp slt i32 %7, 26
; Looking for a replacement for:
%0:i32 = var
%1:i1 = slt %0, 26:i32
infer %1

; *****
; For LLVM instruction:
;  %9 = load i32, i32* %i, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %10 = load i32, i32* %rotate, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %add7 = add nsw i32 %9, %10
; Looking for a replacement for:
%0:i32 = var
%1:i32 = var
%2:i32 = addnsw %0, %1
infer %2

; *****
; For LLVM instruction:
;  %rem = srem i32 %add7, 26
; Looking for a replacement for:
%0:i32 = var
%1:i32 = var
%2:i32 = addnsw %0, %1
%3:i32 = srem %2, 26:i32
infer %3

; *****
; For LLVM instruction:
;  %14 = load i32, i32* %i, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %19 = load i32, i32* %i, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %22 = load i32, i32* %i, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %inc14 = add nsw i32 %22, 1
; Looking for a replacement for:
%0:i32 = var
%1:i32 = addnsw 1:i32, %0
infer %1

; *****
; For LLVM instruction:
;  %cmp16 = fcmp olt double %23, %24
; Looking for a replacement for:
%0:i1 = var
infer %0

; *****
; For LLVM instruction:
;  %26 = load i32, i32* %rotate, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %27 = load i32, i32* %rotate, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %inc18 = add nsw i32 %27, 1
; Looking for a replacement for:
%0:i32 = var
%1:i32 = addnsw 1:i32, %0
infer %1

; *****
; For LLVM instruction:
;  %28 = load i32, i32* %best_rotate, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0
got 1 candidates from LHS

-------------------------------------------------
%0:i32 = var
infer %0


--------------------------------
guess 0

%0:i32 = var ; reservedconst_1

Cost = 0
first query is SAT, returning the model:
reservedconst_1: 0
0 th attempt: second query is SAT-- constant doesn't work
first query is SAT, returning the model:
reservedconst_1: -1
1 th attempt: second query is SAT-- constant doesn't work
first query is UNSAT-- no more guesses
Dataflow Pruned 0/0
There are 1 Guesses
There are 0 RHSs before deduplication
There are 0 RHSs after deduplication
got 2 candidates from LHS

-------------------------------------------------
%0:i32 = var
%1:i1 = slt %0, 26:i32
infer %1


--------------------------------
guess 0

%0:i1 = var ; reservedconst_1

Cost = 0
first query is SAT, returning the model:
reservedconst_1: -1
0 th attempt: second query is SAT-- constant doesn't work
first query is SAT, returning the model:
reservedconst_1: 0
1 th attempt: second query is SAT-- constant doesn't work
first query is UNSAT-- no more guesses
Dataflow Pruned 0/0
There are 1 Guesses
There are 0 RHSs before deduplication
There are 0 RHSs after deduplication
got 2 candidates from LHS

-------------------------------------------------
%0:i32 = var
%1:i32 = addnsw 1:i32, %0
infer %1


--------------------------------
guess 0

%0:i32 = var ; reservedconst_1

Cost = 0
first query is SAT, returning the model:
reservedconst_1: 1
0 th attempt: second query is SAT-- constant doesn't work
first query is SAT, returning the model:
reservedconst_1: 268435457
1 th attempt: second query is SAT-- constant doesn't work
first query is UNSAT-- no more guesses

--------------------------------
guess 1

%0:i32 = var

Cost = 0
second query is SAT-- constant doesn't work
Dataflow Pruned 0/0
There are 2 Guesses
There are 0 RHSs before deduplication
There are 0 RHSs after deduplication
got 3 candidates from LHS

-------------------------------------------------
%0:i32 = var
%1:i32 = var
%2:i32 = addnsw %0, %1
infer %2


--------------------------------
guess 0

%0:i32 = var ; reservedconst_1

Cost = 0
first query is SAT, returning the model:
reservedconst_1: 0
0 th attempt: second query is SAT-- constant doesn't work
first query is SAT, returning the model:
reservedconst_1: -2
1 th attempt: second query is SAT-- constant doesn't work
first query is UNSAT-- no more guesses

--------------------------------
guess 1

%0:i32 = var

Cost = 0
second query is SAT-- constant doesn't work

--------------------------------
guess 2

%0:i32 = var

Cost = 0
second query is SAT-- constant doesn't work
Dataflow Pruned 0/0
There are 3 Guesses
There are 0 RHSs before deduplication
There are 0 RHSs after deduplication
got 4 candidates from LHS

-------------------------------------------------
%0:i32 = var
%1:i32 = var
%2:i32 = addnsw %0, %1
%3:i32 = srem %2, 26:i32
infer %3


--------------------------------
guess 0

%0:i32 = var ; reservedconst_1

Cost = 0
first query is SAT, returning the model:
reservedconst_1: 0
0 th attempt: second query is SAT-- constant doesn't work
first query is SAT, returning the model:
reservedconst_1: 10
1 th attempt: second query is SAT-- constant doesn't work
first query is UNSAT-- no more guesses

--------------------------------
guess 1

%0:i32 = var

Cost = 0
second query is SAT-- constant doesn't work

--------------------------------
guess 2

%0:i32 = var

Cost = 0
second query is SAT-- constant doesn't work

--------------------------------
guess 3

%0:i32 = var
%1:i32 = var
%2:i32 = addnsw %0, %1

Cost = 1
second query is SAT-- constant doesn't work
Dataflow Pruned 0/0
There are 4 Guesses
There are 0 RHSs before deduplication
There are 0 RHSs after deduplication
got 1 candidates from LHS

-------------------------------------------------
%0:i1 = var
infer %0


--------------------------------
guess 0

%0:i1 = var ; reservedconst_1

Cost = 0
first query is SAT, returning the model:
reservedconst_1: 0
0 th attempt: second query is SAT-- constant doesn't work
first query is SAT, returning the model:
reservedconst_1: -1
1 th attempt: second query is SAT-- constant doesn't work
first query is UNSAT-- no more guesses
Dataflow Pruned 0/0
There are 1 Guesses
There are 0 RHSs before deduplication
There are 0 RHSs after deduplication
#########################################################
; exiting Souper's runOnFunction() for best_match()

; entering Souper's runOnFunction() for freq_every_nth()

; ModuleID = './Vigenère_cipher-Cryptanalysis.c.bc'
source_filename = "./Vigene\CC\80re_cipher-Cryptanalysis.c"
target datalayout = "e-m:e-p:32:32-i64:64-n32:64-S128"
target triple = "wasm32-unknown-wasi"

@.str = private unnamed_addr constant [978 x i8] c"MOMUD EKAPV TQEFM OEVHP AJMII CDCTI FGYAG JSPXY ALUYM NSMYHVUXJE LEPXJ FXGCM JHKDZ RYICU HYPUS PGIGM OIYHF WHTCQ KMLRDITLXZ LJFVQ GHOLW CUHLO MDSOE KTALU VYLNZ RFGBX PHVGA LWQISFGRPH JOOFW GUBYI LAPLA LCAFA AMKLG CETDW VOELJ IKGJB XPHVGALWQC SNWBU BYHCU HKOCE XJEYK BQKVY KIIEH GRLGH XEOLW AWFOJILOVV RHPKD WIHKN ATUHN VRYAQ DIVHX FHRZV QWMWV LGSHN NLVZSJLAKI FHXUF XJLXM TBLQV RXXHR FZXGV LRAJI EXPRV OSMNP KEPDTLPRWM JAZPK LQUZA ALGZX GVLKL GJTUI ITDSU REZXJ ERXZS HMPSTMTEOE PAPJH SMFNB YVQUZ AALGA YDNMP AQOWT UHDBV TSMUE UIMVHQGVRW AEFSP EMPVE PKXZY WLKJA GWALT VYYOB YIXOK IHPDS EVLEVRVSGB JOGYW FHKBL GLXYA MVKIS KIEHY IMAPX UOISK PVAGN MZHPWTTZPV XFCCD TUHJH WLAPF YULTB UXJLN SIJVV YOVDJ SOLXG TGRVOSFRII CTMKO JFCQF KTINQ BWVHG TENLH HOGCS PSFPV GJOKM SIFPRZPAAS ATPTZ FTPPD PORRF TAXZP KALQA WMIUD BWNCT LEFKO ZQDLXBUXJL ASIMR PNMBF ZCYLV WAPVF QRHZV ZGZEF KBYIO OFXYE VOWGBBXVCB XBAWG LQKCM ICRRX MACUO IKHQU AJEGL OIJHH XPVZW JEWBAFWAML ZZRXJ EKAHV FASMU LVVUT TGK\00", align 1
@encoded = hidden global i8* getelementptr inbounds ([978 x i8], [978 x i8]* @.str, i32 0, i32 0), align 4
@freq = hidden constant [26 x double] [double 8.167000e-02, double 1.492000e-02, double 2.782000e-02, double 4.253000e-02, double 1.270200e-01, double 2.228000e-02, double 2.015000e-02, double 6.094000e-02, double 6.966000e-02, double 1.530000e-03, double 7.720000e-03, double 4.025000e-02, double 2.406000e-02, double 6.749000e-02, double 7.507000e-02, double 1.929000e-02, double 0x3F4F212D77318FC5, double 5.987000e-02, double 6.327000e-02, double 9.056000e-02, double 2.758000e-02, double 9.780000e-03, double 2.360000e-02, double 1.500000e-03, double 1.974000e-02, double 7.400000e-04], align 16
@.str.1 = private unnamed_addr constant [24 x i8] c"%f, key length: %2d, %s\00", align 1
@.str.2 = private unnamed_addr constant [18 x i8] c" <--- best so far\00", align 1
@.str.3 = private unnamed_addr constant [2 x i8] c"\0A\00", align 1
@llvm.used = appending global [1 x i8*] [i8* bitcast (i32 ()* @__main_void to i8*)], section "llvm.metadata"

@__main_void = alias i32 (), i32 ()* @main

; Function Attrs: noinline nounwind optnone
define hidden i32 @best_match(double* %a, double* %b) #0 {
entry:
  %a.addr = alloca double*, align 4
  %b.addr = alloca double*, align 4
  %sum = alloca double, align 8
  %fit = alloca double, align 8
  %d = alloca double, align 8
  %best_fit = alloca double, align 8
  %i = alloca i32, align 4
  %rotate = alloca i32, align 4
  %best_rotate = alloca i32, align 4
  store double* %a, double** %a.addr, align 4
  store double* %b, double** %b.addr, align 4
  store double 0.000000e+00, double* %sum, align 8
  store double 1.000000e+100, double* %best_fit, align 8
  store i32 0, i32* %best_rotate, align 4
  store i32 0, i32* %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %0 = load i32, i32* %i, align 4
  %cmp = icmp slt i32 %0, 26
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %1 = load double*, double** %a.addr, align 4
  %2 = load i32, i32* %i, align 4
  %arrayidx = getelementptr inbounds double, double* %1, i32 %2
  %3 = load double, double* %arrayidx, align 8
  %4 = load double, double* %sum, align 8
  %add = fadd double %4, %3
  store double %add, double* %sum, align 8
  br label %for.inc

for.inc:                                          ; preds = %for.body
  %5 = load i32, i32* %i, align 4
  %inc = add nsw i32 %5, 1
  store i32 %inc, i32* %i, align 4
  br label %for.cond

for.end:                                          ; preds = %for.cond
  store i32 0, i32* %rotate, align 4
  br label %for.cond1

for.cond1:                                        ; preds = %for.inc17, %for.end
  %6 = load i32, i32* %rotate, align 4
  %cmp2 = icmp slt i32 %6, 26
  br i1 %cmp2, label %for.body3, label %for.end19

for.body3:                                        ; preds = %for.cond1
  store double 0.000000e+00, double* %fit, align 8
  store i32 0, i32* %i, align 4
  br label %for.cond4

for.cond4:                                        ; preds = %for.inc13, %for.body3
  %7 = load i32, i32* %i, align 4
  %cmp5 = icmp slt i32 %7, 26
  br i1 %cmp5, label %for.body6, label %for.end15

for.body6:                                        ; preds = %for.cond4
  %8 = load double*, double** %a.addr, align 4
  %9 = load i32, i32* %i, align 4
  %10 = load i32, i32* %rotate, align 4
  %add7 = add nsw i32 %9, %10
  %rem = srem i32 %add7, 26
  %arrayidx8 = getelementptr inbounds double, double* %8, i32 %rem
  %11 = load double, double* %arrayidx8, align 8
  %12 = load double, double* %sum, align 8
  %div = fdiv double %11, %12
  %13 = load double*, double** %b.addr, align 4
  %14 = load i32, i32* %i, align 4
  %arrayidx9 = getelementptr inbounds double, double* %13, i32 %14
  %15 = load double, double* %arrayidx9, align 8
  %sub = fsub double %div, %15
  store double %sub, double* %d, align 8
  %16 = load double, double* %d, align 8
  %17 = load double, double* %d, align 8
  %mul = fmul double %16, %17
  %18 = load double*, double** %b.addr, align 4
  %19 = load i32, i32* %i, align 4
  %arrayidx10 = getelementptr inbounds double, double* %18, i32 %19
  %20 = load double, double* %arrayidx10, align 8
  %div11 = fdiv double %mul, %20
  %21 = load double, double* %fit, align 8
  %add12 = fadd double %21, %div11
  store double %add12, double* %fit, align 8
  br label %for.inc13

for.inc13:                                        ; preds = %for.body6
  %22 = load i32, i32* %i, align 4
  %inc14 = add nsw i32 %22, 1
  store i32 %inc14, i32* %i, align 4
  br label %for.cond4

for.end15:                                        ; preds = %for.cond4
  %23 = load double, double* %fit, align 8
  %24 = load double, double* %best_fit, align 8
  %cmp16 = fcmp olt double %23, %24
  br i1 %cmp16, label %if.then, label %if.end

if.then:                                          ; preds = %for.end15
  %25 = load double, double* %fit, align 8
  store double %25, double* %best_fit, align 8
  %26 = load i32, i32* %rotate, align 4
  store i32 %26, i32* %best_rotate, align 4
  br label %if.end

if.end:                                           ; preds = %if.then, %for.end15
  br label %for.inc17

for.inc17:                                        ; preds = %if.end
  %27 = load i32, i32* %rotate, align 4
  %inc18 = add nsw i32 %27, 1
  store i32 %inc18, i32* %rotate, align 4
  br label %for.cond1

for.end19:                                        ; preds = %for.cond1
  %28 = load i32, i32* %best_rotate, align 4
  ret i32 %28
}

; Function Attrs: noinline nounwind optnone
define hidden double @freq_every_nth(i32* %msg, i32 %len, i32 %interval, i8* %key) #0 {
entry:
  %msg.addr = alloca i32*, align 4
  %len.addr = alloca i32, align 4
  %interval.addr = alloca i32, align 4
  %key.addr = alloca i8*, align 4
  %sum = alloca double, align 8
  %d = alloca double, align 8
  %ret = alloca double, align 8
  %out = alloca [26 x double], align 16
  %accu = alloca [26 x double], align 16
  %i = alloca i32, align 4
  %j = alloca i32, align 4
  %rot = alloca i32, align 4
  store i32* %msg, i32** %msg.addr, align 4
  store i32 %len, i32* %len.addr, align 4
  store i32 %interval, i32* %interval.addr, align 4
  store i8* %key, i8** %key.addr, align 4
  %0 = bitcast [26 x double]* %accu to i8*
  call void @llvm.memset.p0i8.i32(i8* align 16 %0, i8 0, i32 208, i1 false)
  store i32 0, i32* %j, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc28, %entry
  %1 = load i32, i32* %j, align 4
  %2 = load i32, i32* %interval.addr, align 4
  %cmp = icmp slt i32 %1, %2
  br i1 %cmp, label %for.body, label %for.end30

for.body:                                         ; preds = %for.cond
  store i32 0, i32* %i, align 4
  br label %for.cond1

for.cond1:                                        ; preds = %for.inc, %for.body
  %3 = load i32, i32* %i, align 4
  %cmp2 = icmp slt i32 %3, 26
  br i1 %cmp2, label %for.body3, label %for.end

for.body3:                                        ; preds = %for.cond1
  %4 = load i32, i32* %i, align 4
  %arrayidx = getelementptr inbounds [26 x double], [26 x double]* %out, i32 0, i32 %4
  store double 0.000000e+00, double* %arrayidx, align 8
  br label %for.inc

for.inc:                                          ; preds = %for.body3
  %5 = load i32, i32* %i, align 4
  %inc = add nsw i32 %5, 1
  store i32 %inc, i32* %i, align 4
  br label %for.cond1

for.end:                                          ; preds = %for.cond1
  %6 = load i32, i32* %j, align 4
  store i32 %6, i32* %i, align 4
  br label %for.cond4

for.cond4:                                        ; preds = %for.inc10, %for.end
  %7 = load i32, i32* %i, align 4
  %8 = load i32, i32* %len.addr, align 4
  %cmp5 = icmp slt i32 %7, %8
  br i1 %cmp5, label %for.body6, label %for.end11

for.body6:                                        ; preds = %for.cond4
  %9 = load i32*, i32** %msg.addr, align 4
  %10 = load i32, i32* %i, align 4
  %arrayidx7 = getelementptr inbounds i32, i32* %9, i32 %10
  %11 = load i32, i32* %arrayidx7, align 4
  %arrayidx8 = getelementptr inbounds [26 x double], [26 x double]* %out, i32 0, i32 %11
  %12 = load double, double* %arrayidx8, align 8
  %inc9 = fadd double %12, 1.000000e+00
  store double %inc9, double* %arrayidx8, align 8
  br label %for.inc10

for.inc10:                                        ; preds = %for.body6
  %13 = load i32, i32* %interval.addr, align 4
  %14 = load i32, i32* %i, align 4
  %add = add nsw i32 %14, %13
  store i32 %add, i32* %i, align 4
  br label %for.cond4

for.end11:                                        ; preds = %for.cond4
  %arraydecay = getelementptr inbounds [26 x double], [26 x double]* %out, i32 0, i32 0
  %call = call i32 @best_match(double* %arraydecay, double* getelementptr inbounds ([26 x double], [26 x double]* @freq, i32 0, i32 0))
  store i32 %call, i32* %rot, align 4
  %conv = trunc i32 %call to i8
  %15 = load i8*, i8** %key.addr, align 4
  %16 = load i32, i32* %j, align 4
  %arrayidx12 = getelementptr inbounds i8, i8* %15, i32 %16
  store i8 %conv, i8* %arrayidx12, align 1
  %17 = load i8*, i8** %key.addr, align 4
  %18 = load i32, i32* %j, align 4
  %arrayidx13 = getelementptr inbounds i8, i8* %17, i32 %18
  %19 = load i8, i8* %arrayidx13, align 1
  %conv14 = sext i8 %19 to i32
  %add15 = add nsw i32 %conv14, 65
  %conv16 = trunc i32 %add15 to i8
  store i8 %conv16, i8* %arrayidx13, align 1
  store i32 0, i32* %i, align 4
  br label %for.cond17

for.cond17:                                       ; preds = %for.inc25, %for.end11
  %20 = load i32, i32* %i, align 4
  %cmp18 = icmp slt i32 %20, 26
  br i1 %cmp18, label %for.body20, label %for.end27

for.body20:                                       ; preds = %for.cond17
  %21 = load i32, i32* %i, align 4
  %22 = load i32, i32* %rot, align 4
  %add21 = add nsw i32 %21, %22
  %rem = srem i32 %add21, 26
  %arrayidx22 = getelementptr inbounds [26 x double], [26 x double]* %out, i32 0, i32 %rem
  %23 = load double, double* %arrayidx22, align 8
  %24 = load i32, i32* %i, align 4
  %arrayidx23 = getelementptr inbounds [26 x double], [26 x double]* %accu, i32 0, i32 %24
  %25 = load double, double* %arrayidx23, align 8
  %add24 = fadd double %25, %23
  store double %add24, double* %arrayidx23, align 8
  br label %for.inc25

for.inc25:                                        ; preds = %for.body20
  %26 = load i32, i32* %i, align 4
  %inc26 = add nsw i32 %26, 1
  store i32 %inc26, i32* %i, align 4
  br label %for.cond17

for.end27:                                        ; preds = %for.cond17
  br label %for.inc28

for.inc28:                                        ; preds = %for.end27
  %27 = load i32, i32* %j, align 4
  %inc29 = add nsw i32 %27, 1
  store i32 %inc29, i32* %j, align 4
  br label %for.cond

for.end30:                                        ; preds = %for.cond
  store i32 0, i32* %i, align 4
  store double 0.000000e+00, double* %sum, align 8
  br label %for.cond31

for.cond31:                                       ; preds = %for.inc37, %for.end30
  %28 = load i32, i32* %i, align 4
  %cmp32 = icmp slt i32 %28, 26
  br i1 %cmp32, label %for.body34, label %for.end39

for.body34:                                       ; preds = %for.cond31
  %29 = load i32, i32* %i, align 4
  %arrayidx35 = getelementptr inbounds [26 x double], [26 x double]* %accu, i32 0, i32 %29
  %30 = load double, double* %arrayidx35, align 8
  %31 = load double, double* %sum, align 8
  %add36 = fadd double %31, %30
  store double %add36, double* %sum, align 8
  br label %for.inc37

for.inc37:                                        ; preds = %for.body34
  %32 = load i32, i32* %i, align 4
  %inc38 = add nsw i32 %32, 1
  store i32 %inc38, i32* %i, align 4
  br label %for.cond31

for.end39:                                        ; preds = %for.cond31
  store i32 0, i32* %i, align 4
  store double 0.000000e+00, double* %ret, align 8
  br label %for.cond40

for.cond40:                                       ; preds = %for.inc49, %for.end39
  %33 = load i32, i32* %i, align 4
  %cmp41 = icmp slt i32 %33, 26
  br i1 %cmp41, label %for.body43, label %for.end51

for.body43:                                       ; preds = %for.cond40
  %34 = load i32, i32* %i, align 4
  %arrayidx44 = getelementptr inbounds [26 x double], [26 x double]* %accu, i32 0, i32 %34
  %35 = load double, double* %arrayidx44, align 8
  %36 = load double, double* %sum, align 8
  %div = fdiv double %35, %36
  %37 = load i32, i32* %i, align 4
  %arrayidx45 = getelementptr inbounds [26 x double], [26 x double]* @freq, i32 0, i32 %37
  %38 = load double, double* %arrayidx45, align 8
  %sub = fsub double %div, %38
  store double %sub, double* %d, align 8
  %39 = load double, double* %d, align 8
  %40 = load double, double* %d, align 8
  %mul = fmul double %39, %40
  %41 = load i32, i32* %i, align 4
  %arrayidx46 = getelementptr inbounds [26 x double], [26 x double]* @freq, i32 0, i32 %41
  %42 = load double, double* %arrayidx46, align 8
  %div47 = fdiv double %mul, %42
  %43 = load double, double* %ret, align 8
  %add48 = fadd double %43, %div47
  store double %add48, double* %ret, align 8
  br label %for.inc49

for.inc49:                                        ; preds = %for.body43
  %44 = load i32, i32* %i, align 4
  %inc50 = add nsw i32 %44, 1
  store i32 %inc50, i32* %i, align 4
  br label %for.cond40

for.end51:                                        ; preds = %for.cond40
  %45 = load i8*, i8** %key.addr, align 4
  %46 = load i32, i32* %interval.addr, align 4
  %arrayidx52 = getelementptr inbounds i8, i8* %45, i32 %46
  store i8 0, i8* %arrayidx52, align 1
  %47 = load double, double* %ret, align 8
  ret double %47
}

; Function Attrs: argmemonly nounwind willreturn writeonly
declare void @llvm.memset.p0i8.i32(i8* nocapture writeonly %0, i8 %1, i32 %2, i1 immarg %3) #1

; Function Attrs: noinline nounwind optnone
define hidden i32 @main() #0 {
entry:
  %retval = alloca i32, align 4
  %saved_stack = alloca i8*, align 4
  %__vla_expr0 = alloca i32, align 4
  %len = alloca i32, align 4
  %j = alloca i32, align 4
  %key = alloca [100 x i8], align 16
  %fit = alloca double, align 8
  %best_fit = alloca double, align 8
  store i32 0, i32* %retval, align 4
  %0 = load i8*, i8** @encoded, align 4
  %call = call i32 @strlen(i8* %0) #5
  %1 = call i8* @llvm.stacksave()
  store i8* %1, i8** %saved_stack, align 4
  %vla = alloca i32, i32 %call, align 16
  store i32 %call, i32* %__vla_expr0, align 4
  store i32 0, i32* %len, align 4
  store double 1.000000e+100, double* %best_fit, align 8
  store i32 0, i32* %j, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %2 = load i8*, i8** @encoded, align 4
  %3 = load i32, i32* %j, align 4
  %arrayidx = getelementptr inbounds i8, i8* %2, i32 %3
  %4 = load i8, i8* %arrayidx, align 1
  %conv = sext i8 %4 to i32
  %cmp = icmp ne i32 %conv, 0
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  br i1 false, label %cond.true, label %cond.false

cond.true:                                        ; preds = %for.body
  %5 = load i8*, i8** @encoded, align 4
  %6 = load i32, i32* %j, align 4
  %arrayidx2 = getelementptr inbounds i8, i8* %5, i32 %6
  %7 = load i8, i8* %arrayidx2, align 1
  %conv3 = sext i8 %7 to i32
  %call4 = call i32 @isupper(i32 %conv3) #5
  %tobool = icmp ne i32 %call4, 0
  br i1 %tobool, label %if.then, label %if.end

cond.false:                                       ; preds = %for.body
  %8 = load i8*, i8** @encoded, align 4
  %9 = load i32, i32* %j, align 4
  %arrayidx5 = getelementptr inbounds i8, i8* %8, i32 %9
  %10 = load i8, i8* %arrayidx5, align 1
  %conv6 = sext i8 %10 to i32
  %sub = sub i32 %conv6, 65
  %cmp7 = icmp ult i32 %sub, 26
  br i1 %cmp7, label %if.then, label %if.end

if.then:                                          ; preds = %cond.false, %cond.true
  %11 = load i8*, i8** @encoded, align 4
  %12 = load i32, i32* %j, align 4
  %arrayidx9 = getelementptr inbounds i8, i8* %11, i32 %12
  %13 = load i8, i8* %arrayidx9, align 1
  %conv10 = sext i8 %13 to i32
  %sub11 = sub nsw i32 %conv10, 65
  %14 = load i32, i32* %len, align 4
  %inc = add nsw i32 %14, 1
  store i32 %inc, i32* %len, align 4
  %arrayidx12 = getelementptr inbounds i32, i32* %vla, i32 %14
  store i32 %sub11, i32* %arrayidx12, align 4
  br label %if.end

if.end:                                           ; preds = %if.then, %cond.false, %cond.true
  br label %for.inc

for.inc:                                          ; preds = %if.end
  %15 = load i32, i32* %j, align 4
  %inc13 = add nsw i32 %15, 1
  store i32 %inc13, i32* %j, align 4
  br label %for.cond

for.end:                                          ; preds = %for.cond
  store i32 1, i32* %j, align 4
  br label %for.cond14

for.cond14:                                       ; preds = %for.inc27, %for.end
  %16 = load i32, i32* %j, align 4
  %cmp15 = icmp slt i32 %16, 30
  br i1 %cmp15, label %for.body17, label %for.end29

for.body17:                                       ; preds = %for.cond14
  %17 = load i32, i32* %len, align 4
  %18 = load i32, i32* %j, align 4
  %arraydecay = getelementptr inbounds [100 x i8], [100 x i8]* %key, i32 0, i32 0
  %call18 = call double @freq_every_nth(i32* %vla, i32 %17, i32 %18, i8* %arraydecay)
  store double %call18, double* %fit, align 8
  %19 = load double, double* %fit, align 8
  %20 = load i32, i32* %j, align 4
  %arraydecay19 = getelementptr inbounds [100 x i8], [100 x i8]* %key, i32 0, i32 0
  %call20 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([24 x i8], [24 x i8]* @.str.1, i32 0, i32 0), double %19, i32 %20, i8* %arraydecay19)
  %21 = load double, double* %fit, align 8
  %22 = load double, double* %best_fit, align 8
  %cmp21 = fcmp olt double %21, %22
  br i1 %cmp21, label %if.then23, label %if.end25

if.then23:                                        ; preds = %for.body17
  %23 = load double, double* %fit, align 8
  store double %23, double* %best_fit, align 8
  %call24 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([18 x i8], [18 x i8]* @.str.2, i32 0, i32 0))
  br label %if.end25

if.end25:                                         ; preds = %if.then23, %for.body17
  %call26 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([2 x i8], [2 x i8]* @.str.3, i32 0, i32 0))
  br label %for.inc27

for.inc27:                                        ; preds = %if.end25
  %24 = load i32, i32* %j, align 4
  %inc28 = add nsw i32 %24, 1
  store i32 %inc28, i32* %j, align 4
  br label %for.cond14

for.end29:                                        ; preds = %for.cond14
  store i32 0, i32* %retval, align 4
  %25 = load i8*, i8** %saved_stack, align 4
  call void @llvm.stackrestore(i8* %25)
  %26 = load i32, i32* %retval, align 4
  ret i32 %26
}

; Function Attrs: nounwind readonly
declare i32 @strlen(i8* %0) #2

; Function Attrs: nounwind
declare i8* @llvm.stacksave() #3

; Function Attrs: nounwind readonly
declare i32 @isupper(i32 %0) #2

declare i32 @printf(i8* %0, ...) #4

; Function Attrs: nounwind
declare void @llvm.stackrestore(i8* %0) #3

attributes #0 = { noinline nounwind optnone "correctly-rounded-divide-sqrt-fp-math"="false" "disable-tail-calls"="false" "frame-pointer"="none" "less-precise-fpmad"="false" "min-legal-vector-width"="0" "no-infs-fp-math"="false" "no-jump-tables"="false" "no-nans-fp-math"="false" "no-signed-zeros-fp-math"="false" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="generic" "unsafe-fp-math"="false" "use-soft-float"="false" }
attributes #1 = { argmemonly nounwind willreturn writeonly }
attributes #2 = { nounwind readonly "correctly-rounded-divide-sqrt-fp-math"="false" "disable-tail-calls"="false" "frame-pointer"="none" "less-precise-fpmad"="false" "no-infs-fp-math"="false" "no-nans-fp-math"="false" "no-signed-zeros-fp-math"="false" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="generic" "unsafe-fp-math"="false" "use-soft-float"="false" }
attributes #3 = { nounwind }
attributes #4 = { "correctly-rounded-divide-sqrt-fp-math"="false" "disable-tail-calls"="false" "frame-pointer"="none" "less-precise-fpmad"="false" "no-infs-fp-math"="false" "no-nans-fp-math"="false" "no-signed-zeros-fp-math"="false" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="generic" "unsafe-fp-math"="false" "use-soft-float"="false" }
attributes #5 = { nounwind readonly }

!llvm.module.flags = !{!0}
!llvm.ident = !{!1}

!0 = !{i32 1, !"wchar_size", i32 4}
!1 = !{!"clang version 11.0.0 (https://github.com/Jacarte/llvm-project.git 0f6dea67136cc1e0b3d200eb2bb165628970c44b)"}

; extracted candidates

; *****
; For LLVM instruction:
;  %1 = load i32, i32* %j, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %2 = load i32, i32* %interval.addr, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %cmp = icmp slt i32 %1, %2
; Looking for a replacement for:
%0:i32 = var
%1:i32 = var
%2:i1 = slt %0, %1
infer %2

; *****
; For LLVM instruction:
;  %3 = load i32, i32* %i, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %cmp2 = icmp slt i32 %3, 26
; Looking for a replacement for:
%0:i32 = var
%1:i1 = slt %0, 26:i32
infer %1

; *****
; For LLVM instruction:
;  %4 = load i32, i32* %i, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %5 = load i32, i32* %i, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %inc = add nsw i32 %5, 1
; Looking for a replacement for:
%0:i32 = var
%1:i32 = addnsw 1:i32, %0
infer %1

; *****
; For LLVM instruction:
;  %6 = load i32, i32* %j, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %7 = load i32, i32* %i, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %8 = load i32, i32* %len.addr, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %cmp5 = icmp slt i32 %7, %8
; Looking for a replacement for:
%0:i32 = var
%1:i32 = var
%2:i1 = slt %0, %1
infer %2

; *****
; For LLVM instruction:
;  %10 = load i32, i32* %i, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %11 = load i32, i32* %arrayidx7, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %13 = load i32, i32* %interval.addr, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %14 = load i32, i32* %i, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %add = add nsw i32 %14, %13
; Looking for a replacement for:
%0:i32 = var
%1:i32 = var
%2:i32 = addnsw %0, %1
infer %2

; *****
; For LLVM instruction:
;  %call = call i32 @best_match(double* %arraydecay, double* getelementptr inbounds ([26 x double], [26 x double]* @freq, i32 0, i32 0))
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %conv = trunc i32 %call to i8
; Looking for a replacement for:
%0:i32 = var
%1:i8 = trunc %0
infer %1

; *****
; For LLVM instruction:
;  %16 = load i32, i32* %j, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %18 = load i32, i32* %j, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %19 = load i8, i8* %arrayidx13, align 1
; Looking for a replacement for:
%0:i8 = var
infer %0

; *****
; For LLVM instruction:
;  %conv14 = sext i8 %19 to i32
; Looking for a replacement for:
%0:i8 = var
%1:i32 = sext %0
infer %1 (demandedBits=00000000000000000000000011111111)

; *****
; For LLVM instruction:
;  %add15 = add nsw i32 %conv14, 65
; Looking for a replacement for:
%0:i8 = var
%1:i32 = sext %0
%2:i32 = addnsw 65:i32, %1
infer %2 (demandedBits=00000000000000000000000011111111)

; *****
; For LLVM instruction:
;  %conv16 = trunc i32 %add15 to i8
; Looking for a replacement for:
%0:i8 = var
%1:i32 = sext %0
%2:i32 = addnsw 65:i32, %1
%3:i8 = trunc %2
infer %3

; *****
; For LLVM instruction:
;  %20 = load i32, i32* %i, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %cmp18 = icmp slt i32 %20, 26
; Looking for a replacement for:
%0:i32 = var
%1:i1 = slt %0, 26:i32
infer %1

; *****
; For LLVM instruction:
;  %21 = load i32, i32* %i, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %22 = load i32, i32* %rot, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %add21 = add nsw i32 %21, %22
; Looking for a replacement for:
%0:i32 = var
%1:i32 = var
%2:i32 = addnsw %0, %1
infer %2

; *****
; For LLVM instruction:
;  %rem = srem i32 %add21, 26
; Looking for a replacement for:
%0:i32 = var
%1:i32 = var
%2:i32 = addnsw %0, %1
%3:i32 = srem %2, 26:i32
infer %3

; *****
; For LLVM instruction:
;  %24 = load i32, i32* %i, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %26 = load i32, i32* %i, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %inc26 = add nsw i32 %26, 1
; Looking for a replacement for:
%0:i32 = var
%1:i32 = addnsw 1:i32, %0
infer %1

; *****
; For LLVM instruction:
;  %27 = load i32, i32* %j, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %inc29 = add nsw i32 %27, 1
; Looking for a replacement for:
%0:i32 = var
%1:i32 = addnsw 1:i32, %0
infer %1

; *****
; For LLVM instruction:
;  %28 = load i32, i32* %i, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %cmp32 = icmp slt i32 %28, 26
; Looking for a replacement for:
%0:i32 = var
%1:i1 = slt %0, 26:i32
infer %1

; *****
; For LLVM instruction:
;  %29 = load i32, i32* %i, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %32 = load i32, i32* %i, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %inc38 = add nsw i32 %32, 1
; Looking for a replacement for:
%0:i32 = var
%1:i32 = addnsw 1:i32, %0
infer %1

; *****
; For LLVM instruction:
;  %33 = load i32, i32* %i, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %cmp41 = icmp slt i32 %33, 26
; Looking for a replacement for:
%0:i32 = var
%1:i1 = slt %0, 26:i32
infer %1

; *****
; For LLVM instruction:
;  %34 = load i32, i32* %i, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %37 = load i32, i32* %i, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %41 = load i32, i32* %i, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %44 = load i32, i32* %i, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %inc50 = add nsw i32 %44, 1
; Looking for a replacement for:
%0:i32 = var
%1:i32 = addnsw 1:i32, %0
infer %1

; *****
; For LLVM instruction:
;  %46 = load i32, i32* %interval.addr, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0
got 3 candidates from LHS

-------------------------------------------------
%0:i32 = var
%1:i32 = var
%2:i1 = slt %0, %1
infer %2


--------------------------------
guess 0

%0:i1 = var ; reservedconst_1

Cost = 0
first query is SAT, returning the model:
reservedconst_1: 0
0 th attempt: second query is SAT-- constant doesn't work
first query is SAT, returning the model:
reservedconst_1: -1
1 th attempt: second query is SAT-- constant doesn't work
first query is UNSAT-- no more guesses
Dataflow Pruned 0/0
There are 1 Guesses
There are 0 RHSs before deduplication
There are 0 RHSs after deduplication
got 2 candidates from LHS

-------------------------------------------------
%0:i32 = var
%1:i8 = trunc %0
infer %1


--------------------------------
guess 0

%0:i8 = var ; reservedconst_1

Cost = 0
first query is SAT, returning the model:
reservedconst_1: 0
0 th attempt: second query is SAT-- constant doesn't work
first query is SAT, returning the model:
reservedconst_1: -1
1 th attempt: second query is SAT-- constant doesn't work
first query is UNSAT-- no more guesses
Dataflow Pruned 0/0
There are 1 Guesses
There are 0 RHSs before deduplication
There are 0 RHSs after deduplication
got 1 candidates from LHS

-------------------------------------------------
%0:i8 = var
infer %0


--------------------------------
guess 0

%0:i8 = var ; reservedconst_1

Cost = 0
first query is SAT, returning the model:
reservedconst_1: 0
0 th attempt: second query is SAT-- constant doesn't work
first query is SAT, returning the model:
reservedconst_1: -1
1 th attempt: second query is SAT-- constant doesn't work
first query is UNSAT-- no more guesses
Dataflow Pruned 0/0
There are 1 Guesses
There are 0 RHSs before deduplication
There are 0 RHSs after deduplication
got 2 candidates from LHS

-------------------------------------------------
%0:i8 = var
%1:i32 = sext %0
infer %1 (demandedBits=00000000000000000000000011111111)


--------------------------------
guess 0

%0:i32 = var ; reservedconst_1

Cost = 0
first query is SAT, returning the model:
reservedconst_1: 0
0 th attempt: second query is SAT-- constant doesn't work
first query is SAT, returning the model:
reservedconst_1: -1
1 th attempt: second query is SAT-- constant doesn't work
first query is UNSAT-- no more guesses
Dataflow Pruned 0/0
There are 1 Guesses
There are 0 RHSs before deduplication
There are 0 RHSs after deduplication
got 3 candidates from LHS

-------------------------------------------------
%0:i8 = var
%1:i32 = sext %0
%2:i32 = addnsw 65:i32, %1
infer %2 (demandedBits=00000000000000000000000011111111)


--------------------------------
guess 0

%0:i32 = var ; reservedconst_1

Cost = 0
first query is SAT, returning the model:
reservedconst_1: 0
0 th attempt: second query is SAT-- constant doesn't work
first query is SAT, returning the model:
reservedconst_1: 65
1 th attempt: second query is SAT-- constant doesn't work
first query is UNSAT-- no more guesses

--------------------------------
guess 1

%0:i8 = var
%1:i32 = sext %0

Cost = 1
second query is SAT-- constant doesn't work
Dataflow Pruned 0/0
There are 2 Guesses
There are 0 RHSs before deduplication
There are 0 RHSs after deduplication
got 4 candidates from LHS

-------------------------------------------------
%0:i8 = var
%1:i32 = sext %0
%2:i32 = addnsw 65:i32, %1
%3:i8 = trunc %2
infer %3


--------------------------------
guess 0

%0:i8 = var ; reservedconst_1

Cost = 0
first query is SAT, returning the model:
reservedconst_1: 65
0 th attempt: second query is SAT-- constant doesn't work
first query is SAT, returning the model:
reservedconst_1: -127
1 th attempt: second query is SAT-- constant doesn't work
first query is UNSAT-- no more guesses

--------------------------------
guess 1

%0:i8 = var

Cost = 0
second query is SAT-- constant doesn't work
Dataflow Pruned 0/0
There are 2 Guesses
There are 0 RHSs before deduplication
There are 0 RHSs after deduplication
#########################################################
; exiting Souper's runOnFunction() for freq_every_nth()

; entering Souper's runOnFunction() for main()

; ModuleID = './Vigenère_cipher-Cryptanalysis.c.bc'
source_filename = "./Vigene\CC\80re_cipher-Cryptanalysis.c"
target datalayout = "e-m:e-p:32:32-i64:64-n32:64-S128"
target triple = "wasm32-unknown-wasi"

@.str = private unnamed_addr constant [978 x i8] c"MOMUD EKAPV TQEFM OEVHP AJMII CDCTI FGYAG JSPXY ALUYM NSMYHVUXJE LEPXJ FXGCM JHKDZ RYICU HYPUS PGIGM OIYHF WHTCQ KMLRDITLXZ LJFVQ GHOLW CUHLO MDSOE KTALU VYLNZ RFGBX PHVGA LWQISFGRPH JOOFW GUBYI LAPLA LCAFA AMKLG CETDW VOELJ IKGJB XPHVGALWQC SNWBU BYHCU HKOCE XJEYK BQKVY KIIEH GRLGH XEOLW AWFOJILOVV RHPKD WIHKN ATUHN VRYAQ DIVHX FHRZV QWMWV LGSHN NLVZSJLAKI FHXUF XJLXM TBLQV RXXHR FZXGV LRAJI EXPRV OSMNP KEPDTLPRWM JAZPK LQUZA ALGZX GVLKL GJTUI ITDSU REZXJ ERXZS HMPSTMTEOE PAPJH SMFNB YVQUZ AALGA YDNMP AQOWT UHDBV TSMUE UIMVHQGVRW AEFSP EMPVE PKXZY WLKJA GWALT VYYOB YIXOK IHPDS EVLEVRVSGB JOGYW FHKBL GLXYA MVKIS KIEHY IMAPX UOISK PVAGN MZHPWTTZPV XFCCD TUHJH WLAPF YULTB UXJLN SIJVV YOVDJ SOLXG TGRVOSFRII CTMKO JFCQF KTINQ BWVHG TENLH HOGCS PSFPV GJOKM SIFPRZPAAS ATPTZ FTPPD PORRF TAXZP KALQA WMIUD BWNCT LEFKO ZQDLXBUXJL ASIMR PNMBF ZCYLV WAPVF QRHZV ZGZEF KBYIO OFXYE VOWGBBXVCB XBAWG LQKCM ICRRX MACUO IKHQU AJEGL OIJHH XPVZW JEWBAFWAML ZZRXJ EKAHV FASMU LVVUT TGK\00", align 1
@encoded = hidden global i8* getelementptr inbounds ([978 x i8], [978 x i8]* @.str, i32 0, i32 0), align 4
@freq = hidden constant [26 x double] [double 8.167000e-02, double 1.492000e-02, double 2.782000e-02, double 4.253000e-02, double 1.270200e-01, double 2.228000e-02, double 2.015000e-02, double 6.094000e-02, double 6.966000e-02, double 1.530000e-03, double 7.720000e-03, double 4.025000e-02, double 2.406000e-02, double 6.749000e-02, double 7.507000e-02, double 1.929000e-02, double 0x3F4F212D77318FC5, double 5.987000e-02, double 6.327000e-02, double 9.056000e-02, double 2.758000e-02, double 9.780000e-03, double 2.360000e-02, double 1.500000e-03, double 1.974000e-02, double 7.400000e-04], align 16
@.str.1 = private unnamed_addr constant [24 x i8] c"%f, key length: %2d, %s\00", align 1
@.str.2 = private unnamed_addr constant [18 x i8] c" <--- best so far\00", align 1
@.str.3 = private unnamed_addr constant [2 x i8] c"\0A\00", align 1
@llvm.used = appending global [1 x i8*] [i8* bitcast (i32 ()* @__main_void to i8*)], section "llvm.metadata"

@__main_void = alias i32 (), i32 ()* @main

; Function Attrs: noinline nounwind optnone
define hidden i32 @best_match(double* %a, double* %b) #0 {
entry:
  %a.addr = alloca double*, align 4
  %b.addr = alloca double*, align 4
  %sum = alloca double, align 8
  %fit = alloca double, align 8
  %d = alloca double, align 8
  %best_fit = alloca double, align 8
  %i = alloca i32, align 4
  %rotate = alloca i32, align 4
  %best_rotate = alloca i32, align 4
  store double* %a, double** %a.addr, align 4
  store double* %b, double** %b.addr, align 4
  store double 0.000000e+00, double* %sum, align 8
  store double 1.000000e+100, double* %best_fit, align 8
  store i32 0, i32* %best_rotate, align 4
  store i32 0, i32* %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %0 = load i32, i32* %i, align 4
  %cmp = icmp slt i32 %0, 26
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %1 = load double*, double** %a.addr, align 4
  %2 = load i32, i32* %i, align 4
  %arrayidx = getelementptr inbounds double, double* %1, i32 %2
  %3 = load double, double* %arrayidx, align 8
  %4 = load double, double* %sum, align 8
  %add = fadd double %4, %3
  store double %add, double* %sum, align 8
  br label %for.inc

for.inc:                                          ; preds = %for.body
  %5 = load i32, i32* %i, align 4
  %inc = add nsw i32 %5, 1
  store i32 %inc, i32* %i, align 4
  br label %for.cond

for.end:                                          ; preds = %for.cond
  store i32 0, i32* %rotate, align 4
  br label %for.cond1

for.cond1:                                        ; preds = %for.inc17, %for.end
  %6 = load i32, i32* %rotate, align 4
  %cmp2 = icmp slt i32 %6, 26
  br i1 %cmp2, label %for.body3, label %for.end19

for.body3:                                        ; preds = %for.cond1
  store double 0.000000e+00, double* %fit, align 8
  store i32 0, i32* %i, align 4
  br label %for.cond4

for.cond4:                                        ; preds = %for.inc13, %for.body3
  %7 = load i32, i32* %i, align 4
  %cmp5 = icmp slt i32 %7, 26
  br i1 %cmp5, label %for.body6, label %for.end15

for.body6:                                        ; preds = %for.cond4
  %8 = load double*, double** %a.addr, align 4
  %9 = load i32, i32* %i, align 4
  %10 = load i32, i32* %rotate, align 4
  %add7 = add nsw i32 %9, %10
  %rem = srem i32 %add7, 26
  %arrayidx8 = getelementptr inbounds double, double* %8, i32 %rem
  %11 = load double, double* %arrayidx8, align 8
  %12 = load double, double* %sum, align 8
  %div = fdiv double %11, %12
  %13 = load double*, double** %b.addr, align 4
  %14 = load i32, i32* %i, align 4
  %arrayidx9 = getelementptr inbounds double, double* %13, i32 %14
  %15 = load double, double* %arrayidx9, align 8
  %sub = fsub double %div, %15
  store double %sub, double* %d, align 8
  %16 = load double, double* %d, align 8
  %17 = load double, double* %d, align 8
  %mul = fmul double %16, %17
  %18 = load double*, double** %b.addr, align 4
  %19 = load i32, i32* %i, align 4
  %arrayidx10 = getelementptr inbounds double, double* %18, i32 %19
  %20 = load double, double* %arrayidx10, align 8
  %div11 = fdiv double %mul, %20
  %21 = load double, double* %fit, align 8
  %add12 = fadd double %21, %div11
  store double %add12, double* %fit, align 8
  br label %for.inc13

for.inc13:                                        ; preds = %for.body6
  %22 = load i32, i32* %i, align 4
  %inc14 = add nsw i32 %22, 1
  store i32 %inc14, i32* %i, align 4
  br label %for.cond4

for.end15:                                        ; preds = %for.cond4
  %23 = load double, double* %fit, align 8
  %24 = load double, double* %best_fit, align 8
  %cmp16 = fcmp olt double %23, %24
  br i1 %cmp16, label %if.then, label %if.end

if.then:                                          ; preds = %for.end15
  %25 = load double, double* %fit, align 8
  store double %25, double* %best_fit, align 8
  %26 = load i32, i32* %rotate, align 4
  store i32 %26, i32* %best_rotate, align 4
  br label %if.end

if.end:                                           ; preds = %if.then, %for.end15
  br label %for.inc17

for.inc17:                                        ; preds = %if.end
  %27 = load i32, i32* %rotate, align 4
  %inc18 = add nsw i32 %27, 1
  store i32 %inc18, i32* %rotate, align 4
  br label %for.cond1

for.end19:                                        ; preds = %for.cond1
  %28 = load i32, i32* %best_rotate, align 4
  ret i32 %28
}

; Function Attrs: noinline nounwind optnone
define hidden double @freq_every_nth(i32* %msg, i32 %len, i32 %interval, i8* %key) #0 {
entry:
  %msg.addr = alloca i32*, align 4
  %len.addr = alloca i32, align 4
  %interval.addr = alloca i32, align 4
  %key.addr = alloca i8*, align 4
  %sum = alloca double, align 8
  %d = alloca double, align 8
  %ret = alloca double, align 8
  %out = alloca [26 x double], align 16
  %accu = alloca [26 x double], align 16
  %i = alloca i32, align 4
  %j = alloca i32, align 4
  %rot = alloca i32, align 4
  store i32* %msg, i32** %msg.addr, align 4
  store i32 %len, i32* %len.addr, align 4
  store i32 %interval, i32* %interval.addr, align 4
  store i8* %key, i8** %key.addr, align 4
  %0 = bitcast [26 x double]* %accu to i8*
  call void @llvm.memset.p0i8.i32(i8* align 16 %0, i8 0, i32 208, i1 false)
  store i32 0, i32* %j, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc28, %entry
  %1 = load i32, i32* %j, align 4
  %2 = load i32, i32* %interval.addr, align 4
  %cmp = icmp slt i32 %1, %2
  br i1 %cmp, label %for.body, label %for.end30

for.body:                                         ; preds = %for.cond
  store i32 0, i32* %i, align 4
  br label %for.cond1

for.cond1:                                        ; preds = %for.inc, %for.body
  %3 = load i32, i32* %i, align 4
  %cmp2 = icmp slt i32 %3, 26
  br i1 %cmp2, label %for.body3, label %for.end

for.body3:                                        ; preds = %for.cond1
  %4 = load i32, i32* %i, align 4
  %arrayidx = getelementptr inbounds [26 x double], [26 x double]* %out, i32 0, i32 %4
  store double 0.000000e+00, double* %arrayidx, align 8
  br label %for.inc

for.inc:                                          ; preds = %for.body3
  %5 = load i32, i32* %i, align 4
  %inc = add nsw i32 %5, 1
  store i32 %inc, i32* %i, align 4
  br label %for.cond1

for.end:                                          ; preds = %for.cond1
  %6 = load i32, i32* %j, align 4
  store i32 %6, i32* %i, align 4
  br label %for.cond4

for.cond4:                                        ; preds = %for.inc10, %for.end
  %7 = load i32, i32* %i, align 4
  %8 = load i32, i32* %len.addr, align 4
  %cmp5 = icmp slt i32 %7, %8
  br i1 %cmp5, label %for.body6, label %for.end11

for.body6:                                        ; preds = %for.cond4
  %9 = load i32*, i32** %msg.addr, align 4
  %10 = load i32, i32* %i, align 4
  %arrayidx7 = getelementptr inbounds i32, i32* %9, i32 %10
  %11 = load i32, i32* %arrayidx7, align 4
  %arrayidx8 = getelementptr inbounds [26 x double], [26 x double]* %out, i32 0, i32 %11
  %12 = load double, double* %arrayidx8, align 8
  %inc9 = fadd double %12, 1.000000e+00
  store double %inc9, double* %arrayidx8, align 8
  br label %for.inc10

for.inc10:                                        ; preds = %for.body6
  %13 = load i32, i32* %interval.addr, align 4
  %14 = load i32, i32* %i, align 4
  %add = add nsw i32 %14, %13
  store i32 %add, i32* %i, align 4
  br label %for.cond4

for.end11:                                        ; preds = %for.cond4
  %arraydecay = getelementptr inbounds [26 x double], [26 x double]* %out, i32 0, i32 0
  %call = call i32 @best_match(double* %arraydecay, double* getelementptr inbounds ([26 x double], [26 x double]* @freq, i32 0, i32 0))
  store i32 %call, i32* %rot, align 4
  %conv = trunc i32 %call to i8
  %15 = load i8*, i8** %key.addr, align 4
  %16 = load i32, i32* %j, align 4
  %arrayidx12 = getelementptr inbounds i8, i8* %15, i32 %16
  store i8 %conv, i8* %arrayidx12, align 1
  %17 = load i8*, i8** %key.addr, align 4
  %18 = load i32, i32* %j, align 4
  %arrayidx13 = getelementptr inbounds i8, i8* %17, i32 %18
  %19 = load i8, i8* %arrayidx13, align 1
  %conv14 = sext i8 %19 to i32
  %add15 = add nsw i32 %conv14, 65
  %conv16 = trunc i32 %add15 to i8
  store i8 %conv16, i8* %arrayidx13, align 1
  store i32 0, i32* %i, align 4
  br label %for.cond17

for.cond17:                                       ; preds = %for.inc25, %for.end11
  %20 = load i32, i32* %i, align 4
  %cmp18 = icmp slt i32 %20, 26
  br i1 %cmp18, label %for.body20, label %for.end27

for.body20:                                       ; preds = %for.cond17
  %21 = load i32, i32* %i, align 4
  %22 = load i32, i32* %rot, align 4
  %add21 = add nsw i32 %21, %22
  %rem = srem i32 %add21, 26
  %arrayidx22 = getelementptr inbounds [26 x double], [26 x double]* %out, i32 0, i32 %rem
  %23 = load double, double* %arrayidx22, align 8
  %24 = load i32, i32* %i, align 4
  %arrayidx23 = getelementptr inbounds [26 x double], [26 x double]* %accu, i32 0, i32 %24
  %25 = load double, double* %arrayidx23, align 8
  %add24 = fadd double %25, %23
  store double %add24, double* %arrayidx23, align 8
  br label %for.inc25

for.inc25:                                        ; preds = %for.body20
  %26 = load i32, i32* %i, align 4
  %inc26 = add nsw i32 %26, 1
  store i32 %inc26, i32* %i, align 4
  br label %for.cond17

for.end27:                                        ; preds = %for.cond17
  br label %for.inc28

for.inc28:                                        ; preds = %for.end27
  %27 = load i32, i32* %j, align 4
  %inc29 = add nsw i32 %27, 1
  store i32 %inc29, i32* %j, align 4
  br label %for.cond

for.end30:                                        ; preds = %for.cond
  store i32 0, i32* %i, align 4
  store double 0.000000e+00, double* %sum, align 8
  br label %for.cond31

for.cond31:                                       ; preds = %for.inc37, %for.end30
  %28 = load i32, i32* %i, align 4
  %cmp32 = icmp slt i32 %28, 26
  br i1 %cmp32, label %for.body34, label %for.end39

for.body34:                                       ; preds = %for.cond31
  %29 = load i32, i32* %i, align 4
  %arrayidx35 = getelementptr inbounds [26 x double], [26 x double]* %accu, i32 0, i32 %29
  %30 = load double, double* %arrayidx35, align 8
  %31 = load double, double* %sum, align 8
  %add36 = fadd double %31, %30
  store double %add36, double* %sum, align 8
  br label %for.inc37

for.inc37:                                        ; preds = %for.body34
  %32 = load i32, i32* %i, align 4
  %inc38 = add nsw i32 %32, 1
  store i32 %inc38, i32* %i, align 4
  br label %for.cond31

for.end39:                                        ; preds = %for.cond31
  store i32 0, i32* %i, align 4
  store double 0.000000e+00, double* %ret, align 8
  br label %for.cond40

for.cond40:                                       ; preds = %for.inc49, %for.end39
  %33 = load i32, i32* %i, align 4
  %cmp41 = icmp slt i32 %33, 26
  br i1 %cmp41, label %for.body43, label %for.end51

for.body43:                                       ; preds = %for.cond40
  %34 = load i32, i32* %i, align 4
  %arrayidx44 = getelementptr inbounds [26 x double], [26 x double]* %accu, i32 0, i32 %34
  %35 = load double, double* %arrayidx44, align 8
  %36 = load double, double* %sum, align 8
  %div = fdiv double %35, %36
  %37 = load i32, i32* %i, align 4
  %arrayidx45 = getelementptr inbounds [26 x double], [26 x double]* @freq, i32 0, i32 %37
  %38 = load double, double* %arrayidx45, align 8
  %sub = fsub double %div, %38
  store double %sub, double* %d, align 8
  %39 = load double, double* %d, align 8
  %40 = load double, double* %d, align 8
  %mul = fmul double %39, %40
  %41 = load i32, i32* %i, align 4
  %arrayidx46 = getelementptr inbounds [26 x double], [26 x double]* @freq, i32 0, i32 %41
  %42 = load double, double* %arrayidx46, align 8
  %div47 = fdiv double %mul, %42
  %43 = load double, double* %ret, align 8
  %add48 = fadd double %43, %div47
  store double %add48, double* %ret, align 8
  br label %for.inc49

for.inc49:                                        ; preds = %for.body43
  %44 = load i32, i32* %i, align 4
  %inc50 = add nsw i32 %44, 1
  store i32 %inc50, i32* %i, align 4
  br label %for.cond40

for.end51:                                        ; preds = %for.cond40
  %45 = load i8*, i8** %key.addr, align 4
  %46 = load i32, i32* %interval.addr, align 4
  %arrayidx52 = getelementptr inbounds i8, i8* %45, i32 %46
  store i8 0, i8* %arrayidx52, align 1
  %47 = load double, double* %ret, align 8
  ret double %47
}

; Function Attrs: argmemonly nounwind willreturn writeonly
declare void @llvm.memset.p0i8.i32(i8* nocapture writeonly %0, i8 %1, i32 %2, i1 immarg %3) #1

; Function Attrs: noinline nounwind optnone
define hidden i32 @main() #0 {
entry:
  %retval = alloca i32, align 4
  %saved_stack = alloca i8*, align 4
  %__vla_expr0 = alloca i32, align 4
  %len = alloca i32, align 4
  %j = alloca i32, align 4
  %key = alloca [100 x i8], align 16
  %fit = alloca double, align 8
  %best_fit = alloca double, align 8
  store i32 0, i32* %retval, align 4
  %0 = load i8*, i8** @encoded, align 4
  %call = call i32 @strlen(i8* %0) #5
  %1 = call i8* @llvm.stacksave()
  store i8* %1, i8** %saved_stack, align 4
  %vla = alloca i32, i32 %call, align 16
  store i32 %call, i32* %__vla_expr0, align 4
  store i32 0, i32* %len, align 4
  store double 1.000000e+100, double* %best_fit, align 8
  store i32 0, i32* %j, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %2 = load i8*, i8** @encoded, align 4
  %3 = load i32, i32* %j, align 4
  %arrayidx = getelementptr inbounds i8, i8* %2, i32 %3
  %4 = load i8, i8* %arrayidx, align 1
  %conv = sext i8 %4 to i32
  %cmp = icmp ne i32 %conv, 0
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  br i1 false, label %cond.true, label %cond.false

cond.true:                                        ; preds = %for.body
  %5 = load i8*, i8** @encoded, align 4
  %6 = load i32, i32* %j, align 4
  %arrayidx2 = getelementptr inbounds i8, i8* %5, i32 %6
  %7 = load i8, i8* %arrayidx2, align 1
  %conv3 = sext i8 %7 to i32
  %call4 = call i32 @isupper(i32 %conv3) #5
  %tobool = icmp ne i32 %call4, 0
  br i1 %tobool, label %if.then, label %if.end

cond.false:                                       ; preds = %for.body
  %8 = load i8*, i8** @encoded, align 4
  %9 = load i32, i32* %j, align 4
  %arrayidx5 = getelementptr inbounds i8, i8* %8, i32 %9
  %10 = load i8, i8* %arrayidx5, align 1
  %conv6 = sext i8 %10 to i32
  %sub = sub i32 %conv6, 65
  %cmp7 = icmp ult i32 %sub, 26
  br i1 %cmp7, label %if.then, label %if.end

if.then:                                          ; preds = %cond.false, %cond.true
  %11 = load i8*, i8** @encoded, align 4
  %12 = load i32, i32* %j, align 4
  %arrayidx9 = getelementptr inbounds i8, i8* %11, i32 %12
  %13 = load i8, i8* %arrayidx9, align 1
  %conv10 = sext i8 %13 to i32
  %sub11 = sub nsw i32 %conv10, 65
  %14 = load i32, i32* %len, align 4
  %inc = add nsw i32 %14, 1
  store i32 %inc, i32* %len, align 4
  %arrayidx12 = getelementptr inbounds i32, i32* %vla, i32 %14
  store i32 %sub11, i32* %arrayidx12, align 4
  br label %if.end

if.end:                                           ; preds = %if.then, %cond.false, %cond.true
  br label %for.inc

for.inc:                                          ; preds = %if.end
  %15 = load i32, i32* %j, align 4
  %inc13 = add nsw i32 %15, 1
  store i32 %inc13, i32* %j, align 4
  br label %for.cond

for.end:                                          ; preds = %for.cond
  store i32 1, i32* %j, align 4
  br label %for.cond14

for.cond14:                                       ; preds = %for.inc27, %for.end
  %16 = load i32, i32* %j, align 4
  %cmp15 = icmp slt i32 %16, 30
  br i1 %cmp15, label %for.body17, label %for.end29

for.body17:                                       ; preds = %for.cond14
  %17 = load i32, i32* %len, align 4
  %18 = load i32, i32* %j, align 4
  %arraydecay = getelementptr inbounds [100 x i8], [100 x i8]* %key, i32 0, i32 0
  %call18 = call double @freq_every_nth(i32* %vla, i32 %17, i32 %18, i8* %arraydecay)
  store double %call18, double* %fit, align 8
  %19 = load double, double* %fit, align 8
  %20 = load i32, i32* %j, align 4
  %arraydecay19 = getelementptr inbounds [100 x i8], [100 x i8]* %key, i32 0, i32 0
  %call20 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([24 x i8], [24 x i8]* @.str.1, i32 0, i32 0), double %19, i32 %20, i8* %arraydecay19)
  %21 = load double, double* %fit, align 8
  %22 = load double, double* %best_fit, align 8
  %cmp21 = fcmp olt double %21, %22
  br i1 %cmp21, label %if.then23, label %if.end25

if.then23:                                        ; preds = %for.body17
  %23 = load double, double* %fit, align 8
  store double %23, double* %best_fit, align 8
  %call24 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([18 x i8], [18 x i8]* @.str.2, i32 0, i32 0))
  br label %if.end25

if.end25:                                         ; preds = %if.then23, %for.body17
  %call26 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([2 x i8], [2 x i8]* @.str.3, i32 0, i32 0))
  br label %for.inc27

for.inc27:                                        ; preds = %if.end25
  %24 = load i32, i32* %j, align 4
  %inc28 = add nsw i32 %24, 1
  store i32 %inc28, i32* %j, align 4
  br label %for.cond14

for.end29:                                        ; preds = %for.cond14
  store i32 0, i32* %retval, align 4
  %25 = load i8*, i8** %saved_stack, align 4
  call void @llvm.stackrestore(i8* %25)
  %26 = load i32, i32* %retval, align 4
  ret i32 %26
}

; Function Attrs: nounwind readonly
declare i32 @strlen(i8* %0) #2

; Function Attrs: nounwind
declare i8* @llvm.stacksave() #3

; Function Attrs: nounwind readonly
declare i32 @isupper(i32 %0) #2

declare i32 @printf(i8* %0, ...) #4

; Function Attrs: nounwind
declare void @llvm.stackrestore(i8* %0) #3

attributes #0 = { noinline nounwind optnone "correctly-rounded-divide-sqrt-fp-math"="false" "disable-tail-calls"="false" "frame-pointer"="none" "less-precise-fpmad"="false" "min-legal-vector-width"="0" "no-infs-fp-math"="false" "no-jump-tables"="false" "no-nans-fp-math"="false" "no-signed-zeros-fp-math"="false" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="generic" "unsafe-fp-math"="false" "use-soft-float"="false" }
attributes #1 = { argmemonly nounwind willreturn writeonly }
attributes #2 = { nounwind readonly "correctly-rounded-divide-sqrt-fp-math"="false" "disable-tail-calls"="false" "frame-pointer"="none" "less-precise-fpmad"="false" "no-infs-fp-math"="false" "no-nans-fp-math"="false" "no-signed-zeros-fp-math"="false" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="generic" "unsafe-fp-math"="false" "use-soft-float"="false" }
attributes #3 = { nounwind }
attributes #4 = { "correctly-rounded-divide-sqrt-fp-math"="false" "disable-tail-calls"="false" "frame-pointer"="none" "less-precise-fpmad"="false" "no-infs-fp-math"="false" "no-nans-fp-math"="false" "no-signed-zeros-fp-math"="false" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="generic" "unsafe-fp-math"="false" "use-soft-float"="false" }
attributes #5 = { nounwind readonly }

!llvm.module.flags = !{!0}
!llvm.ident = !{!1}

!0 = !{i32 1, !"wchar_size", i32 4}
!1 = !{!"clang version 11.0.0 (https://github.com/Jacarte/llvm-project.git 0f6dea67136cc1e0b3d200eb2bb165628970c44b)"}

; extracted candidates

; *****
; For LLVM instruction:
;  %call = call i32 @strlen(i8* %0) #5
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %3 = load i32, i32* %j, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %4 = load i8, i8* %arrayidx, align 1
; Looking for a replacement for:
%0:i8 = var
infer %0

; *****
; For LLVM instruction:
;  %conv = sext i8 %4 to i32
; Looking for a replacement for:
%0:i8 = var
%1:i32 = sext %0
infer %1

; *****
; For LLVM instruction:
;  %cmp = icmp ne i32 %conv, 0
; Looking for a replacement for:
%0:i8 = var
%1:i32 = sext %0
%2:i1 = ne 0:i32, %1
infer %2

; *****
; For LLVM instruction:
;  %6 = load i32, i32* %j, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %7 = load i8, i8* %arrayidx2, align 1
; Looking for a replacement for:
%0:i8 = var
infer %0

; *****
; For LLVM instruction:
;  %conv3 = sext i8 %7 to i32
; Looking for a replacement for:
%0:i8 = var
%1:i32 = sext %0
infer %1

; *****
; For LLVM instruction:
;  %call4 = call i32 @isupper(i32 %conv3) #5
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %tobool = icmp ne i32 %call4, 0
; Looking for a replacement for:
%0:i32 = var
%1:i1 = ne 0:i32, %0
infer %1

; *****
; For LLVM instruction:
;  %9 = load i32, i32* %j, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %10 = load i8, i8* %arrayidx5, align 1
; Looking for a replacement for:
%0:i8 = var
infer %0

; *****
; For LLVM instruction:
;  %conv6 = sext i8 %10 to i32
; Looking for a replacement for:
%0:i8 = var
%1:i32 = sext %0
infer %1

; *****
; For LLVM instruction:
;  %sub = sub i32 %conv6, 65
; Looking for a replacement for:
%0:i8 = var
%1:i32 = sext %0
%2:i32 = sub %1, 65:i32
infer %2

; *****
; For LLVM instruction:
;  %cmp7 = icmp ult i32 %sub, 26
; Looking for a replacement for:
%0:i8 = var
%1:i32 = sext %0
%2:i32 = sub %1, 65:i32
%3:i1 = ult %2, 26:i32
infer %3

; *****
; For LLVM instruction:
;  %12 = load i32, i32* %j, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %13 = load i8, i8* %arrayidx9, align 1
; Looking for a replacement for:
%0:i8 = var
infer %0

; *****
; For LLVM instruction:
;  %conv10 = sext i8 %13 to i32
; Looking for a replacement for:
%0:i8 = var
%1:i32 = sext %0
infer %1

; *****
; For LLVM instruction:
;  %sub11 = sub nsw i32 %conv10, 65
; Looking for a replacement for:
%0:i8 = var
%1:i32 = sext %0
%2:i32 = subnsw %1, 65:i32
infer %2

; *****
; For LLVM instruction:
;  %14 = load i32, i32* %len, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %inc = add nsw i32 %14, 1
; Looking for a replacement for:
%0:i32 = var
%1:i32 = addnsw 1:i32, %0
infer %1

; *****
; For LLVM instruction:
;  %15 = load i32, i32* %j, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %inc13 = add nsw i32 %15, 1
; Looking for a replacement for:
%0:i32 = var
%1:i32 = addnsw 1:i32, %0
infer %1

; *****
; For LLVM instruction:
;  %16 = load i32, i32* %j, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %cmp15 = icmp slt i32 %16, 30
; Looking for a replacement for:
%0:i32 = var
%1:i1 = slt %0, 30:i32
infer %1

; *****
; For LLVM instruction:
;  %17 = load i32, i32* %len, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %18 = load i32, i32* %j, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %20 = load i32, i32* %j, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %cmp21 = fcmp olt double %21, %22
; Looking for a replacement for:
%0:i1 = var
infer %0

; *****
; For LLVM instruction:
;  %24 = load i32, i32* %j, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %inc28 = add nsw i32 %24, 1
; Looking for a replacement for:
%0:i32 = var
%1:i32 = addnsw 1:i32, %0
infer %1

; *****
; For LLVM instruction:
;  %26 = load i32, i32* %retval, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0
got 2 candidates from LHS

-------------------------------------------------
%0:i8 = var
%1:i32 = sext %0
infer %1


--------------------------------
guess 0

%0:i32 = var ; reservedconst_1

Cost = 0
first query is SAT, returning the model:
reservedconst_1: 0
0 th attempt: second query is SAT-- constant doesn't work
first query is SAT, returning the model:
reservedconst_1: -1
1 th attempt: second query is SAT-- constant doesn't work
first query is UNSAT-- no more guesses
Dataflow Pruned 0/0
There are 1 Guesses
There are 0 RHSs before deduplication
There are 0 RHSs after deduplication
got 3 candidates from LHS

-------------------------------------------------
%0:i8 = var
%1:i32 = sext %0
%2:i1 = ne 0:i32, %1
infer %2


--------------------------------
guess 0

%0:i1 = var ; reservedconst_1

Cost = 0
first query is SAT, returning the model:
reservedconst_1: 0
0 th attempt: second query is SAT-- constant doesn't work
first query is SAT, returning the model:
reservedconst_1: -1
1 th attempt: second query is SAT-- constant doesn't work
first query is UNSAT-- no more guesses
Dataflow Pruned 0/0
There are 1 Guesses
There are 0 RHSs before deduplication
There are 0 RHSs after deduplication
got 2 candidates from LHS

-------------------------------------------------
%0:i32 = var
%1:i1 = ne 0:i32, %0
infer %1


--------------------------------
guess 0

%0:i1 = var ; reservedconst_1

Cost = 0
first query is SAT, returning the model:
reservedconst_1: 0
0 th attempt: second query is SAT-- constant doesn't work
first query is SAT, returning the model:
reservedconst_1: -1
1 th attempt: second query is SAT-- constant doesn't work
first query is UNSAT-- no more guesses
Dataflow Pruned 0/0
There are 1 Guesses
There are 0 RHSs before deduplication
There are 0 RHSs after deduplication
got 3 candidates from LHS

-------------------------------------------------
%0:i8 = var
%1:i32 = sext %0
%2:i32 = sub %1, 65:i32
infer %2


--------------------------------
guess 0

%0:i32 = var ; reservedconst_1

Cost = 0
first query is SAT, returning the model:
reservedconst_1: -65
0 th attempt: second query is SAT-- constant doesn't work
first query is SAT, returning the model:
reservedconst_1: -66
1 th attempt: second query is SAT-- constant doesn't work
first query is UNSAT-- no more guesses

--------------------------------
guess 1

%0:i8 = var
%1:i32 = sext %0

Cost = 1
second query is SAT-- constant doesn't work
Dataflow Pruned 0/0
There are 2 Guesses
There are 0 RHSs before deduplication
There are 0 RHSs after deduplication
got 4 candidates from LHS

-------------------------------------------------
%0:i8 = var
%1:i32 = sext %0
%2:i32 = sub %1, 65:i32
%3:i1 = ult %2, 26:i32
infer %3


--------------------------------
guess 0

%0:i1 = var ; reservedconst_1

Cost = 0
first query is SAT, returning the model:
reservedconst_1: 0
0 th attempt: second query is SAT-- constant doesn't work
first query is SAT, returning the model:
reservedconst_1: -1
1 th attempt: second query is SAT-- constant doesn't work
first query is UNSAT-- no more guesses
Dataflow Pruned 0/0
There are 1 Guesses
There are 0 RHSs before deduplication
There are 0 RHSs after deduplication
got 3 candidates from LHS

-------------------------------------------------
%0:i8 = var
%1:i32 = sext %0
%2:i32 = subnsw %1, 65:i32
infer %2


--------------------------------
guess 0

%0:i32 = var ; reservedconst_1

Cost = 0
first query is SAT, returning the model:
reservedconst_1: -65
0 th attempt: second query is SAT-- constant doesn't work
first query is SAT, returning the model:
reservedconst_1: -1
1 th attempt: second query is SAT-- constant doesn't work
first query is UNSAT-- no more guesses

--------------------------------
guess 1

%0:i8 = var
%1:i32 = sext %0

Cost = 1
second query is SAT-- constant doesn't work
Dataflow Pruned 0/0
There are 2 Guesses
There are 0 RHSs before deduplication
There are 0 RHSs after deduplication
got 2 candidates from LHS

-------------------------------------------------
%0:i32 = var
%1:i1 = slt %0, 30:i32
infer %1


--------------------------------
guess 0

%0:i1 = var ; reservedconst_1

Cost = 0
first query is SAT, returning the model:
reservedconst_1: -1
0 th attempt: second query is SAT-- constant doesn't work
first query is SAT, returning the model:
reservedconst_1: 0
1 th attempt: second query is SAT-- constant doesn't work
first query is UNSAT-- no more guesses
Dataflow Pruned 0/0
There are 1 Guesses
There are 0 RHSs before deduplication
There are 0 RHSs after deduplication
#########################################################
; exiting Souper's runOnFunction() for main()
Total of 0 replacements done on this module
Total of 0 replacements candidates on this module
