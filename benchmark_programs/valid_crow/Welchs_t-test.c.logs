
Entering the Souper pass's runOnModule()


; entering Souper's runOnFunction() for Pvalue()

; ModuleID = './Welchs_t-test.c.bc'
source_filename = "./Welchs_t-test.c"
target datalayout = "e-m:e-p:32:32-i64:64-n32:64-S128"
target triple = "wasm32-unknown-wasi"

@.str = private unnamed_addr constant [63 x i8] c"Got a non-finite number in 1st array, can't calculate P-value.\00", align 1
@.str.1 = private unnamed_addr constant [63 x i8] c"Got a non-finite number in 2nd array, can't calculate P-value.\00", align 1
@__const.main.d1 = private unnamed_addr constant [15 x double] [double 2.750000e+01, double 2.100000e+01, double 1.900000e+01, double 2.360000e+01, double 1.700000e+01, double 1.790000e+01, double 1.690000e+01, double 2.010000e+01, double 2.190000e+01, double 2.260000e+01, double 2.310000e+01, double 1.960000e+01, double 1.900000e+01, double 2.170000e+01, double 2.140000e+01], align 16
@__const.main.d2 = private unnamed_addr constant [15 x double] [double 2.710000e+01, double 2.200000e+01, double 2.080000e+01, double 2.340000e+01, double 2.340000e+01, double 2.350000e+01, double 2.580000e+01, double 2.200000e+01, double 2.480000e+01, double 2.020000e+01, double 2.190000e+01, double 2.210000e+01, double 2.290000e+01, double 2.050000e+01, double 2.440000e+01], align 16
@__const.main.d3 = private unnamed_addr constant [10 x double] [double 1.720000e+01, double 2.090000e+01, double 2.260000e+01, double 1.810000e+01, double 2.170000e+01, double 2.140000e+01, double 2.350000e+01, double 2.420000e+01, double 1.470000e+01, double 2.180000e+01], align 16
@__const.main.d4 = private unnamed_addr constant [20 x double] [double 2.150000e+01, double 2.280000e+01, double 2.100000e+01, double 2.300000e+01, double 2.160000e+01, double 2.360000e+01, double 2.250000e+01, double 2.070000e+01, double 2.340000e+01, double 2.180000e+01, double 2.070000e+01, double 2.170000e+01, double 2.150000e+01, double 2.250000e+01, double 2.360000e+01, double 2.150000e+01, double 2.250000e+01, double 2.350000e+01, double 2.150000e+01, double 2.180000e+01], align 16
@__const.main.d5 = private unnamed_addr constant [10 x double] [double 1.980000e+01, double 2.040000e+01, double 1.960000e+01, double 1.780000e+01, double 1.850000e+01, double 1.890000e+01, double 1.830000e+01, double 1.890000e+01, double 1.950000e+01, double 2.200000e+01], align 16
@__const.main.d6 = private unnamed_addr constant [20 x double] [double 2.820000e+01, double 2.660000e+01, double 2.010000e+01, double 2.330000e+01, double 2.520000e+01, double 2.210000e+01, double 1.770000e+01, double 2.760000e+01, double 2.060000e+01, double 1.370000e+01, double 2.320000e+01, double 1.750000e+01, double 2.060000e+01, double 1.800000e+01, double 2.390000e+01, double 2.160000e+01, double 2.430000e+01, double 2.040000e+01, double 2.400000e+01, double 1.320000e+01], align 16
@__const.main.x = private unnamed_addr constant [4 x double] [double 3.000000e+00, double 4.000000e+00, double 1.000000e+00, double 2.100000e+00], align 16
@__const.main.y = private unnamed_addr constant [3 x double] [double 4.902000e+02, double 3.400000e+02, double 4.339000e+02], align 16
@__const.main.v1 = private unnamed_addr constant [3 x double] [double 1.026800e-02, double 1.670000e-04, double 1.670000e-04], align 16
@__const.main.v2 = private unnamed_addr constant [3 x double] [double 1.592580e-01, double 1.362780e-01, double 1.223890e-01], align 16
@__const.main.s1 = private unnamed_addr constant [2 x double] [double 0x3FB1111111111111, double 0x3FC4A5294A5294A5], align 16
@__const.main.s2 = private unnamed_addr constant [2 x double] [double 1.000000e-01, double 4.000000e-02], align 16
@__const.main.z1 = private unnamed_addr constant [3 x double] [double 0x3FD90B21642C8591, double 0x3FDDDDDDDDDDDDDE, double 0.000000e+00], align 16
@__const.main.z2 = private unnamed_addr constant [3 x double] [double 0.000000e+00, double 0x3FDC9882B9310572, double 0.000000e+00], align 16
@__const.main.CORRECT_ANSWERS = private unnamed_addr constant [8 x double] [double 0x3F95E41D648C236F, double 0x3FC30D3EA599BB79, double 0x3FA26AF51F458AEB, double 0x3FB73CEBAB27FA12, double 0x3F8604EA1C27764A, double 0x3F6BD85EAF35CBC8, double 0x3FE0DF5C6BE20DA6, double 0x3FE172D38028625E], align 16
@.str.2 = private unnamed_addr constant [26 x i8] c"Test sets 1 p-value = %g\0A\00", align 1
@.str.3 = private unnamed_addr constant [26 x i8] c"Test sets 2 p-value = %g\0A\00", align 1
@.str.4 = private unnamed_addr constant [26 x i8] c"Test sets 3 p-value = %g\0A\00", align 1
@.str.5 = private unnamed_addr constant [26 x i8] c"Test sets 4 p-value = %g\0A\00", align 1
@.str.6 = private unnamed_addr constant [26 x i8] c"Test sets 5 p-value = %g\0A\00", align 1
@.str.7 = private unnamed_addr constant [26 x i8] c"Test sets 6 p-value = %g\0A\00", align 1
@.str.8 = private unnamed_addr constant [26 x i8] c"Test sets 7 p-value = %g\0A\00", align 1
@.str.9 = private unnamed_addr constant [26 x i8] c"Test sets z p-value = %g\0A\00", align 1
@.str.10 = private unnamed_addr constant [28 x i8] c"the cumulative error is %g\0A\00", align 1
@llvm.used = appending global [1 x i8*] [i8* bitcast (i32 ()* @__main_void to i8*)], section "llvm.metadata"

@__main_void = alias i32 (), i32 ()* @main

; Function Attrs: noinline nounwind optnone
define hidden double @Pvalue(double* noalias %ARRAY1, i32 %ARRAY1_SIZE, double* noalias %ARRAY2, i32 %ARRAY2_SIZE) #0 {
entry:
  %retval = alloca double, align 8
  %ARRAY1.addr = alloca double*, align 4
  %ARRAY1_SIZE.addr = alloca i32, align 4
  %ARRAY2.addr = alloca double*, align 4
  %ARRAY2_SIZE.addr = alloca i32, align 4
  %fmean1 = alloca double, align 8
  %fmean2 = alloca double, align 8
  %x = alloca i32, align 4
  %x9 = alloca i32, align 4
  %unbiased_sample_variance1 = alloca double, align 8
  %unbiased_sample_variance2 = alloca double, align 8
  %x32 = alloca i32, align 4
  %x44 = alloca i32, align 4
  %WELCH_T_STATISTIC = alloca double, align 8
  %DEGREES_OF_FREEDOM = alloca double, align 8
  %a = alloca double, align 8
  %value = alloca double, align 8
  %beta = alloca double, align 8
  %acu = alloca double, align 8
  %ai = alloca double, align 8
  %cx = alloca double, align 8
  %indx = alloca i32, align 4
  %ns = alloca i32, align 4
  %pp = alloca double, align 8
  %psq = alloca double, align 8
  %qq = alloca double, align 8
  %rx = alloca double, align 8
  %temp = alloca double, align 8
  %term = alloca double, align 8
  %xx = alloca double, align 8
  store double* %ARRAY1, double** %ARRAY1.addr, align 4
  store i32 %ARRAY1_SIZE, i32* %ARRAY1_SIZE.addr, align 4
  store double* %ARRAY2, double** %ARRAY2.addr, align 4
  store i32 %ARRAY2_SIZE, i32* %ARRAY2_SIZE.addr, align 4
  %0 = load i32, i32* %ARRAY1_SIZE.addr, align 4
  %cmp = icmp ule i32 %0, 1
  br i1 %cmp, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  store double 1.000000e+00, double* %retval, align 8
  br label %return

if.else:                                          ; preds = %entry
  %1 = load i32, i32* %ARRAY2_SIZE.addr, align 4
  %cmp1 = icmp ule i32 %1, 1
  br i1 %cmp1, label %if.then2, label %if.end

if.then2:                                         ; preds = %if.else
  store double 1.000000e+00, double* %retval, align 8
  br label %return

if.end:                                           ; preds = %if.else
  br label %if.end3

if.end3:                                          ; preds = %if.end
  store double 0.000000e+00, double* %fmean1, align 8
  store double 0.000000e+00, double* %fmean2, align 8
  store i32 0, i32* %x, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.end3
  %2 = load i32, i32* %x, align 4
  %3 = load i32, i32* %ARRAY1_SIZE.addr, align 4
  %cmp4 = icmp ult i32 %2, %3
  br i1 %cmp4, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %4 = load double*, double** %ARRAY1.addr, align 4
  %5 = load i32, i32* %x, align 4
  %arrayidx = getelementptr inbounds double, double* %4, i32 %5
  %6 = load double, double* %arrayidx, align 8
  %7 = call double @llvm.fabs.f64(double %6) #7
  %cmpinf = fcmp one double %7, 0x7FF0000000000000
  %8 = zext i1 %cmpinf to i32
  %cmp5 = icmp eq i32 %8, 0
  br i1 %cmp5, label %if.then6, label %if.end7

if.then6:                                         ; preds = %for.body
  %call = call i32 @puts(i8* getelementptr inbounds ([63 x i8], [63 x i8]* @.str, i32 0, i32 0))
  call void @exit(i32 1) #8
  unreachable

if.end7:                                          ; preds = %for.body
  %9 = load double*, double** %ARRAY1.addr, align 4
  %10 = load i32, i32* %x, align 4
  %arrayidx8 = getelementptr inbounds double, double* %9, i32 %10
  %11 = load double, double* %arrayidx8, align 8
  %12 = load double, double* %fmean1, align 8
  %add = fadd double %12, %11
  store double %add, double* %fmean1, align 8
  br label %for.inc

for.inc:                                          ; preds = %if.end7
  %13 = load i32, i32* %x, align 4
  %inc = add i32 %13, 1
  store i32 %inc, i32* %x, align 4
  br label %for.cond

for.end:                                          ; preds = %for.cond
  %14 = load i32, i32* %ARRAY1_SIZE.addr, align 4
  %conv = uitofp i32 %14 to double
  %15 = load double, double* %fmean1, align 8
  %div = fdiv double %15, %conv
  store double %div, double* %fmean1, align 8
  store i32 0, i32* %x9, align 4
  br label %for.cond10

for.cond10:                                       ; preds = %for.inc23, %for.end
  %16 = load i32, i32* %x9, align 4
  %17 = load i32, i32* %ARRAY2_SIZE.addr, align 4
  %cmp11 = icmp ult i32 %16, %17
  br i1 %cmp11, label %for.body13, label %for.end25

for.body13:                                       ; preds = %for.cond10
  %18 = load double*, double** %ARRAY2.addr, align 4
  %19 = load i32, i32* %x9, align 4
  %arrayidx14 = getelementptr inbounds double, double* %18, i32 %19
  %20 = load double, double* %arrayidx14, align 8
  %21 = call double @llvm.fabs.f64(double %20) #7
  %cmpinf15 = fcmp one double %21, 0x7FF0000000000000
  %22 = zext i1 %cmpinf15 to i32
  %cmp16 = icmp eq i32 %22, 0
  br i1 %cmp16, label %if.then18, label %if.end20

if.then18:                                        ; preds = %for.body13
  %call19 = call i32 @puts(i8* getelementptr inbounds ([63 x i8], [63 x i8]* @.str.1, i32 0, i32 0))
  call void @exit(i32 1) #8
  unreachable

if.end20:                                         ; preds = %for.body13
  %23 = load double*, double** %ARRAY2.addr, align 4
  %24 = load i32, i32* %x9, align 4
  %arrayidx21 = getelementptr inbounds double, double* %23, i32 %24
  %25 = load double, double* %arrayidx21, align 8
  %26 = load double, double* %fmean2, align 8
  %add22 = fadd double %26, %25
  store double %add22, double* %fmean2, align 8
  br label %for.inc23

for.inc23:                                        ; preds = %if.end20
  %27 = load i32, i32* %x9, align 4
  %inc24 = add i32 %27, 1
  store i32 %inc24, i32* %x9, align 4
  br label %for.cond10

for.end25:                                        ; preds = %for.cond10
  %28 = load i32, i32* %ARRAY2_SIZE.addr, align 4
  %conv26 = uitofp i32 %28 to double
  %29 = load double, double* %fmean2, align 8
  %div27 = fdiv double %29, %conv26
  store double %div27, double* %fmean2, align 8
  %30 = load double, double* %fmean1, align 8
  %31 = load double, double* %fmean2, align 8
  %cmp28 = fcmp oeq double %30, %31
  br i1 %cmp28, label %if.then30, label %if.end31

if.then30:                                        ; preds = %for.end25
  store double 1.000000e+00, double* %retval, align 8
  br label %return

if.end31:                                         ; preds = %for.end25
  store double 0.000000e+00, double* %unbiased_sample_variance1, align 8
  store double 0.000000e+00, double* %unbiased_sample_variance2, align 8
  store i32 0, i32* %x32, align 4
  br label %for.cond33

for.cond33:                                       ; preds = %for.inc41, %if.end31
  %32 = load i32, i32* %x32, align 4
  %33 = load i32, i32* %ARRAY1_SIZE.addr, align 4
  %cmp34 = icmp ult i32 %32, %33
  br i1 %cmp34, label %for.body36, label %for.end43

for.body36:                                       ; preds = %for.cond33
  %34 = load double*, double** %ARRAY1.addr, align 4
  %35 = load i32, i32* %x32, align 4
  %arrayidx37 = getelementptr inbounds double, double* %34, i32 %35
  %36 = load double, double* %arrayidx37, align 8
  %37 = load double, double* %fmean1, align 8
  %sub = fsub double %36, %37
  %38 = load double*, double** %ARRAY1.addr, align 4
  %39 = load i32, i32* %x32, align 4
  %arrayidx38 = getelementptr inbounds double, double* %38, i32 %39
  %40 = load double, double* %arrayidx38, align 8
  %41 = load double, double* %fmean1, align 8
  %sub39 = fsub double %40, %41
  %mul = fmul double %sub, %sub39
  %42 = load double, double* %unbiased_sample_variance1, align 8
  %add40 = fadd double %42, %mul
  store double %add40, double* %unbiased_sample_variance1, align 8
  br label %for.inc41

for.inc41:                                        ; preds = %for.body36
  %43 = load i32, i32* %x32, align 4
  %inc42 = add i32 %43, 1
  store i32 %inc42, i32* %x32, align 4
  br label %for.cond33

for.end43:                                        ; preds = %for.cond33
  store i32 0, i32* %x44, align 4
  br label %for.cond45

for.cond45:                                       ; preds = %for.inc55, %for.end43
  %44 = load i32, i32* %x44, align 4
  %45 = load i32, i32* %ARRAY2_SIZE.addr, align 4
  %cmp46 = icmp ult i32 %44, %45
  br i1 %cmp46, label %for.body48, label %for.end57

for.body48:                                       ; preds = %for.cond45
  %46 = load double*, double** %ARRAY2.addr, align 4
  %47 = load i32, i32* %x44, align 4
  %arrayidx49 = getelementptr inbounds double, double* %46, i32 %47
  %48 = load double, double* %arrayidx49, align 8
  %49 = load double, double* %fmean2, align 8
  %sub50 = fsub double %48, %49
  %50 = load double*, double** %ARRAY2.addr, align 4
  %51 = load i32, i32* %x44, align 4
  %arrayidx51 = getelementptr inbounds double, double* %50, i32 %51
  %52 = load double, double* %arrayidx51, align 8
  %53 = load double, double* %fmean2, align 8
  %sub52 = fsub double %52, %53
  %mul53 = fmul double %sub50, %sub52
  %54 = load double, double* %unbiased_sample_variance2, align 8
  %add54 = fadd double %54, %mul53
  store double %add54, double* %unbiased_sample_variance2, align 8
  br label %for.inc55

for.inc55:                                        ; preds = %for.body48
  %55 = load i32, i32* %x44, align 4
  %inc56 = add i32 %55, 1
  store i32 %inc56, i32* %x44, align 4
  br label %for.cond45

for.end57:                                        ; preds = %for.cond45
  %56 = load double, double* %unbiased_sample_variance1, align 8
  %57 = load i32, i32* %ARRAY1_SIZE.addr, align 4
  %sub58 = sub i32 %57, 1
  %conv59 = uitofp i32 %sub58 to double
  %div60 = fdiv double %56, %conv59
  store double %div60, double* %unbiased_sample_variance1, align 8
  %58 = load double, double* %unbiased_sample_variance2, align 8
  %59 = load i32, i32* %ARRAY2_SIZE.addr, align 4
  %sub61 = sub i32 %59, 1
  %conv62 = uitofp i32 %sub61 to double
  %div63 = fdiv double %58, %conv62
  store double %div63, double* %unbiased_sample_variance2, align 8
  %60 = load double, double* %fmean1, align 8
  %61 = load double, double* %fmean2, align 8
  %sub64 = fsub double %60, %61
  %62 = load double, double* %unbiased_sample_variance1, align 8
  %63 = load i32, i32* %ARRAY1_SIZE.addr, align 4
  %conv65 = uitofp i32 %63 to double
  %div66 = fdiv double %62, %conv65
  %64 = load double, double* %unbiased_sample_variance2, align 8
  %65 = load i32, i32* %ARRAY2_SIZE.addr, align 4
  %conv67 = uitofp i32 %65 to double
  %div68 = fdiv double %64, %conv67
  %add69 = fadd double %div66, %div68
  %66 = call double @llvm.sqrt.f64(double %add69)
  %div70 = fdiv double %sub64, %66
  store double %div70, double* %WELCH_T_STATISTIC, align 8
  %67 = load double, double* %unbiased_sample_variance1, align 8
  %68 = load i32, i32* %ARRAY1_SIZE.addr, align 4
  %conv71 = uitofp i32 %68 to double
  %div72 = fdiv double %67, %conv71
  %69 = load double, double* %unbiased_sample_variance2, align 8
  %70 = load i32, i32* %ARRAY2_SIZE.addr, align 4
  %conv73 = uitofp i32 %70 to double
  %div74 = fdiv double %69, %conv73
  %add75 = fadd double %div72, %div74
  %71 = call double @llvm.pow.f64(double %add75, double 2.000000e+00)
  %72 = load double, double* %unbiased_sample_variance1, align 8
  %73 = load double, double* %unbiased_sample_variance1, align 8
  %mul76 = fmul double %72, %73
  %74 = load i32, i32* %ARRAY1_SIZE.addr, align 4
  %75 = load i32, i32* %ARRAY1_SIZE.addr, align 4
  %mul77 = mul i32 %74, %75
  %76 = load i32, i32* %ARRAY1_SIZE.addr, align 4
  %sub78 = sub i32 %76, 1
  %mul79 = mul i32 %mul77, %sub78
  %conv80 = uitofp i32 %mul79 to double
  %div81 = fdiv double %mul76, %conv80
  %77 = load double, double* %unbiased_sample_variance2, align 8
  %78 = load double, double* %unbiased_sample_variance2, align 8
  %mul82 = fmul double %77, %78
  %79 = load i32, i32* %ARRAY2_SIZE.addr, align 4
  %80 = load i32, i32* %ARRAY2_SIZE.addr, align 4
  %mul83 = mul i32 %79, %80
  %81 = load i32, i32* %ARRAY2_SIZE.addr, align 4
  %sub84 = sub i32 %81, 1
  %mul85 = mul i32 %mul83, %sub84
  %conv86 = uitofp i32 %mul85 to double
  %div87 = fdiv double %mul82, %conv86
  %add88 = fadd double %div81, %div87
  %div89 = fdiv double %71, %add88
  store double %div89, double* %DEGREES_OF_FREEDOM, align 8
  %82 = load double, double* %DEGREES_OF_FREEDOM, align 8
  %div90 = fdiv double %82, 2.000000e+00
  store double %div90, double* %a, align 8
  %83 = load double, double* %DEGREES_OF_FREEDOM, align 8
  %84 = load double, double* %WELCH_T_STATISTIC, align 8
  %85 = load double, double* %WELCH_T_STATISTIC, align 8
  %mul91 = fmul double %84, %85
  %86 = load double, double* %DEGREES_OF_FREEDOM, align 8
  %add92 = fadd double %mul91, %86
  %div93 = fdiv double %83, %add92
  store double %div93, double* %value, align 8
  %87 = load double, double* %value, align 8
  %88 = call double @llvm.fabs.f64(double %87) #7
  %cmpinf94 = fcmp oeq double %88, 0x7FF0000000000000
  %89 = zext i1 %cmpinf94 to i32
  %cmp95 = icmp ne i32 %89, 0
  br i1 %cmp95, label %if.then100, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %for.end57
  %90 = load double, double* %value, align 8
  %cmp97 = fcmp uno double %90, %90
  %91 = zext i1 %cmp97 to i32
  %cmp98 = icmp ne i32 %91, 0
  br i1 %cmp98, label %if.then100, label %if.end101

if.then100:                                       ; preds = %lor.lhs.false, %for.end57
  store double 1.000000e+00, double* %retval, align 8
  br label %return

if.end101:                                        ; preds = %lor.lhs.false
  %92 = load double, double* %value, align 8
  %93 = call double @llvm.fabs.f64(double %92) #7
  %cmpinf102 = fcmp oeq double %93, 0x7FF0000000000000
  %94 = zext i1 %cmpinf102 to i32
  %cmp103 = icmp ne i32 %94, 0
  br i1 %cmp103, label %if.then109, label %lor.lhs.false105

lor.lhs.false105:                                 ; preds = %if.end101
  %95 = load double, double* %value, align 8
  %cmp106 = fcmp uno double %95, %95
  %96 = zext i1 %cmp106 to i32
  %cmp107 = icmp ne i32 %96, 0
  br i1 %cmp107, label %if.then109, label %if.end110

if.then109:                                       ; preds = %lor.lhs.false105, %if.end101
  store double 1.000000e+00, double* %retval, align 8
  br label %return

if.end110:                                        ; preds = %lor.lhs.false105
  %97 = load double, double* %a, align 8
  %conv111 = fpext double %97 to fp128
  %call112 = call fp128 @lgammal(fp128 %conv111) #9
  %add113 = fadd fp128 %call112, 0xLD0000000000000003FFE250D048E7A1B
  %98 = load double, double* %a, align 8
  %add114 = fadd double %98, 5.000000e-01
  %conv115 = fpext double %add114 to fp128
  %call116 = call fp128 @lgammal(fp128 %conv115) #9
  %sub117 = fsub fp128 %add113, %call116
  %conv118 = fptrunc fp128 %sub117 to double
  store double %conv118, double* %beta, align 8
  store double 1.000000e-15, double* %acu, align 8
  %99 = load double, double* %a, align 8
  %cmp119 = fcmp ole double %99, 0.000000e+00
  br i1 %cmp119, label %if.then121, label %if.end122

if.then121:                                       ; preds = %if.end110
  br label %if.end122

if.end122:                                        ; preds = %if.then121, %if.end110
  %100 = load double, double* %value, align 8
  %cmp123 = fcmp olt double %100, 0.000000e+00
  br i1 %cmp123, label %if.then128, label %lor.lhs.false125

lor.lhs.false125:                                 ; preds = %if.end122
  %101 = load double, double* %value, align 8
  %cmp126 = fcmp olt double 1.000000e+00, %101
  br i1 %cmp126, label %if.then128, label %if.end129

if.then128:                                       ; preds = %lor.lhs.false125, %if.end122
  %102 = load double, double* %value, align 8
  store double %102, double* %retval, align 8
  br label %return

if.end129:                                        ; preds = %lor.lhs.false125
  %103 = load double, double* %value, align 8
  %cmp130 = fcmp oeq double %103, 0.000000e+00
  br i1 %cmp130, label %if.then135, label %lor.lhs.false132

lor.lhs.false132:                                 ; preds = %if.end129
  %104 = load double, double* %value, align 8
  %cmp133 = fcmp oeq double %104, 1.000000e+00
  br i1 %cmp133, label %if.then135, label %if.end136

if.then135:                                       ; preds = %lor.lhs.false132, %if.end129
  %105 = load double, double* %value, align 8
  store double %105, double* %retval, align 8
  br label %return

if.end136:                                        ; preds = %lor.lhs.false132
  %106 = load double, double* %a, align 8
  %add137 = fadd double %106, 5.000000e-01
  store double %add137, double* %psq, align 8
  %107 = load double, double* %value, align 8
  %sub138 = fsub double 1.000000e+00, %107
  store double %sub138, double* %cx, align 8
  %108 = load double, double* %a, align 8
  %109 = load double, double* %psq, align 8
  %110 = load double, double* %value, align 8
  %mul139 = fmul double %109, %110
  %cmp140 = fcmp olt double %108, %mul139
  br i1 %cmp140, label %if.then142, label %if.else143

if.then142:                                       ; preds = %if.end136
  %111 = load double, double* %cx, align 8
  store double %111, double* %xx, align 8
  %112 = load double, double* %value, align 8
  store double %112, double* %cx, align 8
  store double 5.000000e-01, double* %pp, align 8
  %113 = load double, double* %a, align 8
  store double %113, double* %qq, align 8
  store i32 1, i32* %indx, align 4
  br label %if.end144

if.else143:                                       ; preds = %if.end136
  %114 = load double, double* %value, align 8
  store double %114, double* %xx, align 8
  %115 = load double, double* %a, align 8
  store double %115, double* %pp, align 8
  store double 5.000000e-01, double* %qq, align 8
  store i32 0, i32* %indx, align 4
  br label %if.end144

if.end144:                                        ; preds = %if.else143, %if.then142
  store double 1.000000e+00, double* %term, align 8
  store double 1.000000e+00, double* %ai, align 8
  store double 1.000000e+00, double* %value, align 8
  %116 = load double, double* %qq, align 8
  %117 = load double, double* %cx, align 8
  %118 = load double, double* %psq, align 8
  %mul145 = fmul double %117, %118
  %add146 = fadd double %116, %mul145
  %conv147 = fptosi double %add146 to i32
  store i32 %conv147, i32* %ns, align 4
  %119 = load double, double* %xx, align 8
  %120 = load double, double* %cx, align 8
  %div148 = fdiv double %119, %120
  store double %div148, double* %rx, align 8
  %121 = load double, double* %qq, align 8
  %122 = load double, double* %ai, align 8
  %sub149 = fsub double %121, %122
  store double %sub149, double* %temp, align 8
  %123 = load i32, i32* %ns, align 4
  %cmp150 = icmp eq i32 %123, 0
  br i1 %cmp150, label %if.then152, label %if.end153

if.then152:                                       ; preds = %if.end144
  %124 = load double, double* %xx, align 8
  store double %124, double* %rx, align 8
  br label %if.end153

if.end153:                                        ; preds = %if.then152, %if.end144
  br label %for.cond154

for.cond154:                                      ; preds = %if.end189, %if.end153
  %125 = load double, double* %term, align 8
  %126 = load double, double* %temp, align 8
  %mul155 = fmul double %125, %126
  %127 = load double, double* %rx, align 8
  %mul156 = fmul double %mul155, %127
  %128 = load double, double* %pp, align 8
  %129 = load double, double* %ai, align 8
  %add157 = fadd double %128, %129
  %div158 = fdiv double %mul156, %add157
  store double %div158, double* %term, align 8
  %130 = load double, double* %value, align 8
  %131 = load double, double* %term, align 8
  %add159 = fadd double %130, %131
  store double %add159, double* %value, align 8
  %132 = load double, double* %term, align 8
  %133 = call double @llvm.fabs.f64(double %132)
  store double %133, double* %temp, align 8
  %134 = load double, double* %temp, align 8
  %cmp160 = fcmp ole double %134, 1.000000e-15
  br i1 %cmp160, label %land.lhs.true, label %if.end176

land.lhs.true:                                    ; preds = %for.cond154
  %135 = load double, double* %temp, align 8
  %136 = load double, double* %value, align 8
  %mul162 = fmul double 1.000000e-15, %136
  %cmp163 = fcmp ole double %135, %mul162
  br i1 %cmp163, label %if.then165, label %if.end176

if.then165:                                       ; preds = %land.lhs.true
  %137 = load double, double* %value, align 8
  %138 = load double, double* %pp, align 8
  %139 = load double, double* %xx, align 8
  %140 = call double @llvm.log.f64(double %139)
  %mul166 = fmul double %138, %140
  %141 = load double, double* %qq, align 8
  %sub167 = fsub double %141, 1.000000e+00
  %142 = load double, double* %cx, align 8
  %143 = call double @llvm.log.f64(double %142)
  %mul168 = fmul double %sub167, %143
  %add169 = fadd double %mul166, %mul168
  %144 = load double, double* %beta, align 8
  %sub170 = fsub double %add169, %144
  %145 = call double @llvm.exp.f64(double %sub170)
  %mul171 = fmul double %137, %145
  %146 = load double, double* %pp, align 8
  %div172 = fdiv double %mul171, %146
  store double %div172, double* %value, align 8
  %147 = load i32, i32* %indx, align 4
  %tobool = icmp ne i32 %147, 0
  br i1 %tobool, label %if.then173, label %if.end175

if.then173:                                       ; preds = %if.then165
  %148 = load double, double* %value, align 8
  %sub174 = fsub double 1.000000e+00, %148
  store double %sub174, double* %value, align 8
  br label %if.end175

if.end175:                                        ; preds = %if.then173, %if.then165
  br label %for.end190

if.end176:                                        ; preds = %land.lhs.true, %for.cond154
  %149 = load double, double* %ai, align 8
  %add177 = fadd double %149, 1.000000e+00
  store double %add177, double* %ai, align 8
  %150 = load i32, i32* %ns, align 4
  %sub178 = sub nsw i32 %150, 1
  store i32 %sub178, i32* %ns, align 4
  %151 = load i32, i32* %ns, align 4
  %cmp179 = icmp sle i32 0, %151
  br i1 %cmp179, label %if.then181, label %if.else187

if.then181:                                       ; preds = %if.end176
  %152 = load double, double* %qq, align 8
  %153 = load double, double* %ai, align 8
  %sub182 = fsub double %152, %153
  store double %sub182, double* %temp, align 8
  %154 = load i32, i32* %ns, align 4
  %cmp183 = icmp eq i32 %154, 0
  br i1 %cmp183, label %if.then185, label %if.end186

if.then185:                                       ; preds = %if.then181
  %155 = load double, double* %xx, align 8
  store double %155, double* %rx, align 8
  br label %if.end186

if.end186:                                        ; preds = %if.then185, %if.then181
  br label %if.end189

if.else187:                                       ; preds = %if.end176
  %156 = load double, double* %psq, align 8
  store double %156, double* %temp, align 8
  %157 = load double, double* %psq, align 8
  %add188 = fadd double %157, 1.000000e+00
  store double %add188, double* %psq, align 8
  br label %if.end189

if.end189:                                        ; preds = %if.else187, %if.end186
  br label %for.cond154

for.end190:                                       ; preds = %if.end175
  %158 = load double, double* %value, align 8
  store double %158, double* %retval, align 8
  br label %return

return:                                           ; preds = %for.end190, %if.then135, %if.then128, %if.then109, %if.then100, %if.then30, %if.then2, %if.then
  %159 = load double, double* %retval, align 8
  ret double %159
}

; Function Attrs: nounwind readnone speculatable willreturn
declare double @llvm.fabs.f64(double %0) #1

declare i32 @puts(i8* %0) #2

; Function Attrs: noreturn
declare void @exit(i32 %0) #3

; Function Attrs: nounwind readnone speculatable willreturn
declare double @llvm.sqrt.f64(double %0) #1

; Function Attrs: nounwind readnone speculatable willreturn
declare double @llvm.pow.f64(double %0, double %1) #1

; Function Attrs: nounwind
declare fp128 @lgammal(fp128 %0) #4

; Function Attrs: nounwind readnone speculatable willreturn
declare double @llvm.log.f64(double %0) #1

; Function Attrs: nounwind readnone speculatable willreturn
declare double @llvm.exp.f64(double %0) #1

; Function Attrs: noinline nounwind optnone
define hidden i32 @main() #0 {
entry:
  %retval = alloca i32, align 4
  %d1 = alloca [15 x double], align 16
  %d2 = alloca [15 x double], align 16
  %d3 = alloca [10 x double], align 16
  %d4 = alloca [20 x double], align 16
  %d5 = alloca [10 x double], align 16
  %d6 = alloca [20 x double], align 16
  %d7 = alloca [6 x double], align 16
  %d8 = alloca [6 x double], align 16
  %x = alloca [4 x double], align 16
  %y = alloca [3 x double], align 16
  %v1 = alloca [3 x double], align 16
  %v2 = alloca [3 x double], align 16
  %s1 = alloca [2 x double], align 16
  %s2 = alloca [2 x double], align 16
  %z1 = alloca [3 x double], align 16
  %z2 = alloca [3 x double], align 16
  %CORRECT_ANSWERS = alloca [8 x double], align 16
  %pvalue = alloca double, align 8
  %error = alloca double, align 8
  store i32 0, i32* %retval, align 4
  %0 = bitcast [15 x double]* %d1 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 16 %0, i8* align 16 bitcast ([15 x double]* @__const.main.d1 to i8*), i32 120, i1 false)
  %1 = bitcast [15 x double]* %d2 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 16 %1, i8* align 16 bitcast ([15 x double]* @__const.main.d2 to i8*), i32 120, i1 false)
  %2 = bitcast [10 x double]* %d3 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 16 %2, i8* align 16 bitcast ([10 x double]* @__const.main.d3 to i8*), i32 80, i1 false)
  %3 = bitcast [20 x double]* %d4 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 16 %3, i8* align 16 bitcast ([20 x double]* @__const.main.d4 to i8*), i32 160, i1 false)
  %4 = bitcast [10 x double]* %d5 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 16 %4, i8* align 16 bitcast ([10 x double]* @__const.main.d5 to i8*), i32 80, i1 false)
  %5 = bitcast [20 x double]* %d6 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 16 %5, i8* align 16 bitcast ([20 x double]* @__const.main.d6 to i8*), i32 160, i1 false)
  %6 = bitcast [6 x double]* %d7 to i8*
  call void @llvm.memset.p0i8.i32(i8* align 16 %6, i8 0, i32 48, i1 false)
  %7 = bitcast i8* %6 to [6 x double]*
  %8 = getelementptr inbounds [6 x double], [6 x double]* %7, i32 0, i32 0
  store double 3.002000e+01, double* %8, align 16
  %9 = getelementptr inbounds [6 x double], [6 x double]* %7, i32 0, i32 1
  store double 2.999000e+01, double* %9, align 8
  %10 = getelementptr inbounds [6 x double], [6 x double]* %7, i32 0, i32 2
  store double 3.011000e+01, double* %10, align 16
  %11 = getelementptr inbounds [6 x double], [6 x double]* %7, i32 0, i32 3
  store double 2.997000e+01, double* %11, align 8
  %12 = getelementptr inbounds [6 x double], [6 x double]* %7, i32 0, i32 4
  store double 3.001000e+01, double* %12, align 16
  %13 = getelementptr inbounds [6 x double], [6 x double]* %7, i32 0, i32 5
  store double 2.999000e+01, double* %13, align 8
  %14 = bitcast [6 x double]* %d8 to i8*
  call void @llvm.memset.p0i8.i32(i8* align 16 %14, i8 0, i32 48, i1 false)
  %15 = bitcast i8* %14 to [6 x double]*
  %16 = getelementptr inbounds [6 x double], [6 x double]* %15, i32 0, i32 0
  store double 2.989000e+01, double* %16, align 16
  %17 = getelementptr inbounds [6 x double], [6 x double]* %15, i32 0, i32 1
  store double 2.993000e+01, double* %17, align 8
  %18 = getelementptr inbounds [6 x double], [6 x double]* %15, i32 0, i32 2
  store double 2.972000e+01, double* %18, align 16
  %19 = getelementptr inbounds [6 x double], [6 x double]* %15, i32 0, i32 3
  store double 2.998000e+01, double* %19, align 8
  %20 = getelementptr inbounds [6 x double], [6 x double]* %15, i32 0, i32 4
  store double 3.002000e+01, double* %20, align 16
  %21 = getelementptr inbounds [6 x double], [6 x double]* %15, i32 0, i32 5
  store double 2.998000e+01, double* %21, align 8
  %22 = bitcast [4 x double]* %x to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 16 %22, i8* align 16 bitcast ([4 x double]* @__const.main.x to i8*), i32 32, i1 false)
  %23 = bitcast [3 x double]* %y to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 16 %23, i8* align 16 bitcast ([3 x double]* @__const.main.y to i8*), i32 24, i1 false)
  %24 = bitcast [3 x double]* %v1 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 16 %24, i8* align 16 bitcast ([3 x double]* @__const.main.v1 to i8*), i32 24, i1 false)
  %25 = bitcast [3 x double]* %v2 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 16 %25, i8* align 16 bitcast ([3 x double]* @__const.main.v2 to i8*), i32 24, i1 false)
  %26 = bitcast [2 x double]* %s1 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 16 %26, i8* align 16 bitcast ([2 x double]* @__const.main.s1 to i8*), i32 16, i1 false)
  %27 = bitcast [2 x double]* %s2 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 16 %27, i8* align 16 bitcast ([2 x double]* @__const.main.s2 to i8*), i32 16, i1 false)
  %28 = bitcast [3 x double]* %z1 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 16 %28, i8* align 16 bitcast ([3 x double]* @__const.main.z1 to i8*), i32 24, i1 false)
  %29 = bitcast [3 x double]* %z2 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 16 %29, i8* align 16 bitcast ([3 x double]* @__const.main.z2 to i8*), i32 24, i1 false)
  %30 = bitcast [8 x double]* %CORRECT_ANSWERS to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 16 %30, i8* align 16 bitcast ([8 x double]* @__const.main.CORRECT_ANSWERS to i8*), i32 64, i1 false)
  %arraydecay = getelementptr inbounds [15 x double], [15 x double]* %d1, i32 0, i32 0
  %arraydecay1 = getelementptr inbounds [15 x double], [15 x double]* %d2, i32 0, i32 0
  %call = call double @Pvalue(double* %arraydecay, i32 15, double* %arraydecay1, i32 15)
  store double %call, double* %pvalue, align 8
  %31 = load double, double* %pvalue, align 8
  %arrayidx = getelementptr inbounds [8 x double], [8 x double]* %CORRECT_ANSWERS, i32 0, i32 0
  %32 = load double, double* %arrayidx, align 16
  %sub = fsub double %31, %32
  %33 = call double @llvm.fabs.f64(double %sub)
  store double %33, double* %error, align 8
  %34 = load double, double* %pvalue, align 8
  %call2 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([26 x i8], [26 x i8]* @.str.2, i32 0, i32 0), double %34)
  %arraydecay3 = getelementptr inbounds [10 x double], [10 x double]* %d3, i32 0, i32 0
  %arraydecay4 = getelementptr inbounds [20 x double], [20 x double]* %d4, i32 0, i32 0
  %call5 = call double @Pvalue(double* %arraydecay3, i32 10, double* %arraydecay4, i32 20)
  store double %call5, double* %pvalue, align 8
  %35 = load double, double* %pvalue, align 8
  %arrayidx6 = getelementptr inbounds [8 x double], [8 x double]* %CORRECT_ANSWERS, i32 0, i32 1
  %36 = load double, double* %arrayidx6, align 8
  %sub7 = fsub double %35, %36
  %37 = call double @llvm.fabs.f64(double %sub7)
  %38 = load double, double* %error, align 8
  %add = fadd double %38, %37
  store double %add, double* %error, align 8
  %39 = load double, double* %pvalue, align 8
  %call8 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([26 x i8], [26 x i8]* @.str.3, i32 0, i32 0), double %39)
  %arraydecay9 = getelementptr inbounds [10 x double], [10 x double]* %d5, i32 0, i32 0
  %arraydecay10 = getelementptr inbounds [20 x double], [20 x double]* %d6, i32 0, i32 0
  %call11 = call double @Pvalue(double* %arraydecay9, i32 10, double* %arraydecay10, i32 20)
  store double %call11, double* %pvalue, align 8
  %40 = load double, double* %pvalue, align 8
  %arrayidx12 = getelementptr inbounds [8 x double], [8 x double]* %CORRECT_ANSWERS, i32 0, i32 2
  %41 = load double, double* %arrayidx12, align 16
  %sub13 = fsub double %40, %41
  %42 = call double @llvm.fabs.f64(double %sub13)
  %43 = load double, double* %error, align 8
  %add14 = fadd double %43, %42
  store double %add14, double* %error, align 8
  %44 = load double, double* %pvalue, align 8
  %call15 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([26 x i8], [26 x i8]* @.str.4, i32 0, i32 0), double %44)
  %arraydecay16 = getelementptr inbounds [6 x double], [6 x double]* %d7, i32 0, i32 0
  %arraydecay17 = getelementptr inbounds [6 x double], [6 x double]* %d8, i32 0, i32 0
  %call18 = call double @Pvalue(double* %arraydecay16, i32 6, double* %arraydecay17, i32 6)
  store double %call18, double* %pvalue, align 8
  %45 = load double, double* %pvalue, align 8
  %call19 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([26 x i8], [26 x i8]* @.str.5, i32 0, i32 0), double %45)
  %46 = load double, double* %pvalue, align 8
  %arrayidx20 = getelementptr inbounds [8 x double], [8 x double]* %CORRECT_ANSWERS, i32 0, i32 3
  %47 = load double, double* %arrayidx20, align 8
  %sub21 = fsub double %46, %47
  %48 = call double @llvm.fabs.f64(double %sub21)
  %49 = load double, double* %error, align 8
  %add22 = fadd double %49, %48
  store double %add22, double* %error, align 8
  %arraydecay23 = getelementptr inbounds [4 x double], [4 x double]* %x, i32 0, i32 0
  %arraydecay24 = getelementptr inbounds [3 x double], [3 x double]* %y, i32 0, i32 0
  %call25 = call double @Pvalue(double* %arraydecay23, i32 4, double* %arraydecay24, i32 3)
  store double %call25, double* %pvalue, align 8
  %50 = load double, double* %pvalue, align 8
  %arrayidx26 = getelementptr inbounds [8 x double], [8 x double]* %CORRECT_ANSWERS, i32 0, i32 4
  %51 = load double, double* %arrayidx26, align 16
  %sub27 = fsub double %50, %51
  %52 = call double @llvm.fabs.f64(double %sub27)
  %53 = load double, double* %error, align 8
  %add28 = fadd double %53, %52
  store double %add28, double* %error, align 8
  %54 = load double, double* %pvalue, align 8
  %call29 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([26 x i8], [26 x i8]* @.str.6, i32 0, i32 0), double %54)
  %arraydecay30 = getelementptr inbounds [3 x double], [3 x double]* %v1, i32 0, i32 0
  %arraydecay31 = getelementptr inbounds [3 x double], [3 x double]* %v2, i32 0, i32 0
  %call32 = call double @Pvalue(double* %arraydecay30, i32 3, double* %arraydecay31, i32 3)
  store double %call32, double* %pvalue, align 8
  %55 = load double, double* %pvalue, align 8
  %arrayidx33 = getelementptr inbounds [8 x double], [8 x double]* %CORRECT_ANSWERS, i32 0, i32 5
  %56 = load double, double* %arrayidx33, align 8
  %sub34 = fsub double %55, %56
  %57 = call double @llvm.fabs.f64(double %sub34)
  %58 = load double, double* %error, align 8
  %add35 = fadd double %58, %57
  store double %add35, double* %error, align 8
  %59 = load double, double* %pvalue, align 8
  %call36 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([26 x i8], [26 x i8]* @.str.7, i32 0, i32 0), double %59)
  %arraydecay37 = getelementptr inbounds [2 x double], [2 x double]* %s1, i32 0, i32 0
  %arraydecay38 = getelementptr inbounds [2 x double], [2 x double]* %s2, i32 0, i32 0
  %call39 = call double @Pvalue(double* %arraydecay37, i32 2, double* %arraydecay38, i32 2)
  store double %call39, double* %pvalue, align 8
  %60 = load double, double* %pvalue, align 8
  %arrayidx40 = getelementptr inbounds [8 x double], [8 x double]* %CORRECT_ANSWERS, i32 0, i32 6
  %61 = load double, double* %arrayidx40, align 16
  %sub41 = fsub double %60, %61
  %62 = call double @llvm.fabs.f64(double %sub41)
  %63 = load double, double* %error, align 8
  %add42 = fadd double %63, %62
  store double %add42, double* %error, align 8
  %64 = load double, double* %pvalue, align 8
  %call43 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([26 x i8], [26 x i8]* @.str.8, i32 0, i32 0), double %64)
  %arraydecay44 = getelementptr inbounds [3 x double], [3 x double]* %z1, i32 0, i32 0
  %arraydecay45 = getelementptr inbounds [3 x double], [3 x double]* %z2, i32 0, i32 0
  %call46 = call double @Pvalue(double* %arraydecay44, i32 3, double* %arraydecay45, i32 3)
  store double %call46, double* %pvalue, align 8
  %65 = load double, double* %pvalue, align 8
  %arrayidx47 = getelementptr inbounds [8 x double], [8 x double]* %CORRECT_ANSWERS, i32 0, i32 7
  %66 = load double, double* %arrayidx47, align 8
  %sub48 = fsub double %65, %66
  %67 = call double @llvm.fabs.f64(double %sub48)
  %68 = load double, double* %error, align 8
  %add49 = fadd double %68, %67
  store double %add49, double* %error, align 8
  %69 = load double, double* %pvalue, align 8
  %call50 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([26 x i8], [26 x i8]* @.str.9, i32 0, i32 0), double %69)
  %70 = load double, double* %error, align 8
  %call51 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([28 x i8], [28 x i8]* @.str.10, i32 0, i32 0), double %70)
  ret i32 0
}

; Function Attrs: argmemonly nounwind willreturn
declare void @llvm.memcpy.p0i8.p0i8.i32(i8* noalias nocapture writeonly %0, i8* noalias nocapture readonly %1, i32 %2, i1 immarg %3) #5

; Function Attrs: argmemonly nounwind willreturn writeonly
declare void @llvm.memset.p0i8.i32(i8* nocapture writeonly %0, i8 %1, i32 %2, i1 immarg %3) #6

declare i32 @printf(i8* %0, ...) #2

attributes #0 = { noinline nounwind optnone "correctly-rounded-divide-sqrt-fp-math"="false" "disable-tail-calls"="false" "frame-pointer"="none" "less-precise-fpmad"="false" "min-legal-vector-width"="0" "no-infs-fp-math"="false" "no-jump-tables"="false" "no-nans-fp-math"="false" "no-signed-zeros-fp-math"="false" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="generic" "unsafe-fp-math"="false" "use-soft-float"="false" }
attributes #1 = { nounwind readnone speculatable willreturn }
attributes #2 = { "correctly-rounded-divide-sqrt-fp-math"="false" "disable-tail-calls"="false" "frame-pointer"="none" "less-precise-fpmad"="false" "no-infs-fp-math"="false" "no-nans-fp-math"="false" "no-signed-zeros-fp-math"="false" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="generic" "unsafe-fp-math"="false" "use-soft-float"="false" }
attributes #3 = { noreturn "correctly-rounded-divide-sqrt-fp-math"="false" "disable-tail-calls"="false" "frame-pointer"="none" "less-precise-fpmad"="false" "no-infs-fp-math"="false" "no-nans-fp-math"="false" "no-signed-zeros-fp-math"="false" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="generic" "unsafe-fp-math"="false" "use-soft-float"="false" }
attributes #4 = { nounwind "correctly-rounded-divide-sqrt-fp-math"="false" "disable-tail-calls"="false" "frame-pointer"="none" "less-precise-fpmad"="false" "no-infs-fp-math"="false" "no-nans-fp-math"="false" "no-signed-zeros-fp-math"="false" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="generic" "unsafe-fp-math"="false" "use-soft-float"="false" }
attributes #5 = { argmemonly nounwind willreturn }
attributes #6 = { argmemonly nounwind willreturn writeonly }
attributes #7 = { readnone }
attributes #8 = { noreturn }
attributes #9 = { nounwind }

!llvm.module.flags = !{!0}
!llvm.ident = !{!1}

!0 = !{i32 1, !"wchar_size", i32 4}
!1 = !{!"clang version 11.0.0 (https://github.com/Jacarte/llvm-project.git 0f6dea67136cc1e0b3d200eb2bb165628970c44b)"}

; extracted candidates

; *****
; For LLVM instruction:
;  %0 = load i32, i32* %ARRAY1_SIZE.addr, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %cmp = icmp ule i32 %0, 1
; Looking for a replacement for:
%0:i32 = var
%1:i1 = ule %0, 1:i32
infer %1

; *****
; For LLVM instruction:
;  %1 = load i32, i32* %ARRAY2_SIZE.addr, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %cmp1 = icmp ule i32 %1, 1
; Looking for a replacement for:
%0:i32 = var
%1:i1 = ule %0, 1:i32
infer %1

; *****
; For LLVM instruction:
;  %2 = load i32, i32* %x, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %3 = load i32, i32* %ARRAY1_SIZE.addr, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %cmp4 = icmp ult i32 %2, %3
; Looking for a replacement for:
%0:i32 = var
%1:i32 = var
%2:i1 = ult %0, %1
infer %2

; *****
; For LLVM instruction:
;  %5 = load i32, i32* %x, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %cmpinf = fcmp one double %7, 0x7FF0000000000000
; Looking for a replacement for:
%0:i1 = var
infer %0

; *****
; For LLVM instruction:
;  %8 = zext i1 %cmpinf to i32
; Looking for a replacement for:
%0:i1 = var
%1:i32 = zext %0
infer %1

; *****
; For LLVM instruction:
;  %cmp5 = icmp eq i32 %8, 0
; Looking for a replacement for:
%0:i1 = var
%1:i32 = zext %0
%2:i1 = eq 0:i32, %1
infer %2

; *****
; For LLVM instruction:
;  %10 = load i32, i32* %x, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %13 = load i32, i32* %x, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %inc = add i32 %13, 1
; Looking for a replacement for:
%0:i32 = var
%1:i32 = add 1:i32, %0
infer %1

; *****
; For LLVM instruction:
;  %14 = load i32, i32* %ARRAY1_SIZE.addr, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %16 = load i32, i32* %x9, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %17 = load i32, i32* %ARRAY2_SIZE.addr, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %cmp11 = icmp ult i32 %16, %17
; Looking for a replacement for:
%0:i32 = var
%1:i32 = var
%2:i1 = ult %0, %1
infer %2

; *****
; For LLVM instruction:
;  %19 = load i32, i32* %x9, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %cmpinf15 = fcmp one double %21, 0x7FF0000000000000
; Looking for a replacement for:
%0:i1 = var
infer %0

; *****
; For LLVM instruction:
;  %22 = zext i1 %cmpinf15 to i32
; Looking for a replacement for:
%0:i1 = var
%1:i32 = zext %0
infer %1

; *****
; For LLVM instruction:
;  %cmp16 = icmp eq i32 %22, 0
; Looking for a replacement for:
%0:i1 = var
%1:i32 = zext %0
%2:i1 = eq 0:i32, %1
infer %2

; *****
; For LLVM instruction:
;  %24 = load i32, i32* %x9, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %27 = load i32, i32* %x9, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %inc24 = add i32 %27, 1
; Looking for a replacement for:
%0:i32 = var
%1:i32 = add 1:i32, %0
infer %1

; *****
; For LLVM instruction:
;  %28 = load i32, i32* %ARRAY2_SIZE.addr, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %cmp28 = fcmp oeq double %30, %31
; Looking for a replacement for:
%0:i1 = var
infer %0

; *****
; For LLVM instruction:
;  %32 = load i32, i32* %x32, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %33 = load i32, i32* %ARRAY1_SIZE.addr, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %cmp34 = icmp ult i32 %32, %33
; Looking for a replacement for:
%0:i32 = var
%1:i32 = var
%2:i1 = ult %0, %1
infer %2

; *****
; For LLVM instruction:
;  %35 = load i32, i32* %x32, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %39 = load i32, i32* %x32, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %43 = load i32, i32* %x32, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %inc42 = add i32 %43, 1
; Looking for a replacement for:
%0:i32 = var
%1:i32 = add 1:i32, %0
infer %1

; *****
; For LLVM instruction:
;  %44 = load i32, i32* %x44, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %45 = load i32, i32* %ARRAY2_SIZE.addr, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %cmp46 = icmp ult i32 %44, %45
; Looking for a replacement for:
%0:i32 = var
%1:i32 = var
%2:i1 = ult %0, %1
infer %2

; *****
; For LLVM instruction:
;  %47 = load i32, i32* %x44, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %51 = load i32, i32* %x44, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %55 = load i32, i32* %x44, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %inc56 = add i32 %55, 1
; Looking for a replacement for:
%0:i32 = var
%1:i32 = add 1:i32, %0
infer %1

; *****
; For LLVM instruction:
;  %57 = load i32, i32* %ARRAY1_SIZE.addr, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %sub58 = sub i32 %57, 1
; Looking for a replacement for:
%0:i32 = var
%1:i32 = sub %0, 1:i32
infer %1

; *****
; For LLVM instruction:
;  %59 = load i32, i32* %ARRAY2_SIZE.addr, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %sub61 = sub i32 %59, 1
; Looking for a replacement for:
%0:i32 = var
%1:i32 = sub %0, 1:i32
infer %1

; *****
; For LLVM instruction:
;  %63 = load i32, i32* %ARRAY1_SIZE.addr, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %65 = load i32, i32* %ARRAY2_SIZE.addr, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %68 = load i32, i32* %ARRAY1_SIZE.addr, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %70 = load i32, i32* %ARRAY2_SIZE.addr, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %74 = load i32, i32* %ARRAY1_SIZE.addr, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %75 = load i32, i32* %ARRAY1_SIZE.addr, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %mul77 = mul i32 %74, %75
; Looking for a replacement for:
%0:i32 = var
%1:i32 = var
%2:i32 = mul %0, %1
infer %2

; *****
; For LLVM instruction:
;  %76 = load i32, i32* %ARRAY1_SIZE.addr, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %sub78 = sub i32 %76, 1
; Looking for a replacement for:
%0:i32 = var
%1:i32 = sub %0, 1:i32
infer %1

; *****
; For LLVM instruction:
;  %mul79 = mul i32 %mul77, %sub78
; Looking for a replacement for:
%0:i32 = var
%1:i32 = sub %0, 1:i32
%2:i32 = var
%3:i32 = var
%4:i32 = mul %2, %3
%5:i32 = mul %1, %4
infer %5

; *****
; For LLVM instruction:
;  %79 = load i32, i32* %ARRAY2_SIZE.addr, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %80 = load i32, i32* %ARRAY2_SIZE.addr, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %mul83 = mul i32 %79, %80
; Looking for a replacement for:
%0:i32 = var
%1:i32 = var
%2:i32 = mul %0, %1
infer %2

; *****
; For LLVM instruction:
;  %81 = load i32, i32* %ARRAY2_SIZE.addr, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %sub84 = sub i32 %81, 1
; Looking for a replacement for:
%0:i32 = var
%1:i32 = sub %0, 1:i32
infer %1

; *****
; For LLVM instruction:
;  %mul85 = mul i32 %mul83, %sub84
; Looking for a replacement for:
%0:i32 = var
%1:i32 = sub %0, 1:i32
%2:i32 = var
%3:i32 = var
%4:i32 = mul %2, %3
%5:i32 = mul %1, %4
infer %5

; *****
; For LLVM instruction:
;  %cmpinf94 = fcmp oeq double %88, 0x7FF0000000000000
; Looking for a replacement for:
%0:i1 = var
infer %0

; *****
; For LLVM instruction:
;  %89 = zext i1 %cmpinf94 to i32
; Looking for a replacement for:
%0:i1 = var
%1:i32 = zext %0
infer %1

; *****
; For LLVM instruction:
;  %cmp95 = icmp ne i32 %89, 0
; Looking for a replacement for:
%0:i1 = var
%1:i32 = zext %0
%2:i1 = ne 0:i32, %1
infer %2

; *****
; For LLVM instruction:
;  %cmp97 = fcmp uno double %90, %90
; Looking for a replacement for:
%0:i1 = var
infer %0

; *****
; For LLVM instruction:
;  %91 = zext i1 %cmp97 to i32
; Looking for a replacement for:
%0:i1 = var
%1:i32 = zext %0
infer %1

; *****
; For LLVM instruction:
;  %cmp98 = icmp ne i32 %91, 0
; Looking for a replacement for:
%0:i1 = var
%1:i32 = zext %0
%2:i1 = ne 0:i32, %1
infer %2

; *****
; For LLVM instruction:
;  %cmpinf102 = fcmp oeq double %93, 0x7FF0000000000000
; Looking for a replacement for:
%0:i1 = var
infer %0

; *****
; For LLVM instruction:
;  %94 = zext i1 %cmpinf102 to i32
; Looking for a replacement for:
%0:i1 = var
%1:i32 = zext %0
infer %1

; *****
; For LLVM instruction:
;  %cmp103 = icmp ne i32 %94, 0
; Looking for a replacement for:
%0:i1 = var
%1:i32 = zext %0
%2:i1 = ne 0:i32, %1
infer %2

; *****
; For LLVM instruction:
;  %cmp106 = fcmp uno double %95, %95
; Looking for a replacement for:
%0:i1 = var
infer %0

; *****
; For LLVM instruction:
;  %96 = zext i1 %cmp106 to i32
; Looking for a replacement for:
%0:i1 = var
%1:i32 = zext %0
infer %1

; *****
; For LLVM instruction:
;  %cmp107 = icmp ne i32 %96, 0
; Looking for a replacement for:
%0:i1 = var
%1:i32 = zext %0
%2:i1 = ne 0:i32, %1
infer %2

; *****
; For LLVM instruction:
;  %cmp119 = fcmp ole double %99, 0.000000e+00
; Looking for a replacement for:
%0:i1 = var
infer %0

; *****
; For LLVM instruction:
;  %cmp123 = fcmp olt double %100, 0.000000e+00
; Looking for a replacement for:
%0:i1 = var
infer %0

; *****
; For LLVM instruction:
;  %cmp126 = fcmp olt double 1.000000e+00, %101
; Looking for a replacement for:
%0:i1 = var
infer %0

; *****
; For LLVM instruction:
;  %cmp130 = fcmp oeq double %103, 0.000000e+00
; Looking for a replacement for:
%0:i1 = var
infer %0

; *****
; For LLVM instruction:
;  %cmp133 = fcmp oeq double %104, 1.000000e+00
; Looking for a replacement for:
%0:i1 = var
infer %0

; *****
; For LLVM instruction:
;  %cmp140 = fcmp olt double %108, %mul139
; Looking for a replacement for:
%0:i1 = var
infer %0

; *****
; For LLVM instruction:
;  %conv147 = fptosi double %add146 to i32
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %123 = load i32, i32* %ns, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %cmp150 = icmp eq i32 %123, 0
; Looking for a replacement for:
%0:i32 = var
%1:i1 = eq 0:i32, %0
infer %1

; *****
; For LLVM instruction:
;  %cmp160 = fcmp ole double %134, 1.000000e-15
; Looking for a replacement for:
%0:i1 = var
infer %0

; *****
; For LLVM instruction:
;  %cmp163 = fcmp ole double %135, %mul162
; Looking for a replacement for:
%0:i1 = var
infer %0

; *****
; For LLVM instruction:
;  %147 = load i32, i32* %indx, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %tobool = icmp ne i32 %147, 0
; Looking for a replacement for:
%0:i32 = var
%1:i1 = ne 0:i32, %0
infer %1

; *****
; For LLVM instruction:
;  %150 = load i32, i32* %ns, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %sub178 = sub nsw i32 %150, 1
; Looking for a replacement for:
%0:i32 = var
%1:i32 = subnsw %0, 1:i32
infer %1

; *****
; For LLVM instruction:
;  %151 = load i32, i32* %ns, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %cmp179 = icmp sle i32 0, %151
; Looking for a replacement for:
%0:i32 = var
%1:i1 = sle 0:i32, %0
infer %1

; *****
; For LLVM instruction:
;  %154 = load i32, i32* %ns, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %cmp183 = icmp eq i32 %154, 0
; Looking for a replacement for:
%0:i32 = var
%1:i1 = eq 0:i32, %0
infer %1
got 1 candidates from LHS

-------------------------------------------------
%0:i32 = var
infer %0


--------------------------------
guess 0

%0:i32 = var ; reservedconst_1

Cost = 0
first query is SAT, returning the model:
reservedconst_1: 0
0 th attempt: second query is SAT-- constant doesn't work
first query is SAT, returning the model:
reservedconst_1: -1
1 th attempt: second query is SAT-- constant doesn't work
first query is UNSAT-- no more guesses
Dataflow Pruned 0/0
There are 1 Guesses
There are 0 RHSs before deduplication
There are 0 RHSs after deduplication
got 2 candidates from LHS

-------------------------------------------------
%0:i32 = var
%1:i1 = ule %0, 1:i32
infer %1


--------------------------------
guess 0

%0:i1 = var ; reservedconst_1

Cost = 0
first query is SAT, returning the model:
reservedconst_1: -1
0 th attempt: second query is SAT-- constant doesn't work
first query is SAT, returning the model:
reservedconst_1: 0
1 th attempt: second query is SAT-- constant doesn't work
first query is UNSAT-- no more guesses
Dataflow Pruned 0/0
There are 1 Guesses
There are 0 RHSs before deduplication
There are 0 RHSs after deduplication
got 3 candidates from LHS

-------------------------------------------------
%0:i32 = var
%1:i32 = var
%2:i1 = ult %0, %1
infer %2


--------------------------------
guess 0

%0:i1 = var ; reservedconst_1

Cost = 0
first query is SAT, returning the model:
reservedconst_1: 0
0 th attempt: second query is SAT-- constant doesn't work
first query is SAT, returning the model:
reservedconst_1: -1
1 th attempt: second query is SAT-- constant doesn't work
first query is UNSAT-- no more guesses
Dataflow Pruned 0/0
There are 1 Guesses
There are 0 RHSs before deduplication
There are 0 RHSs after deduplication
got 1 candidates from LHS

-------------------------------------------------
%0:i1 = var
infer %0


--------------------------------
guess 0

%0:i1 = var ; reservedconst_1

Cost = 0
first query is SAT, returning the model:
reservedconst_1: 0
0 th attempt: second query is SAT-- constant doesn't work
first query is SAT, returning the model:
reservedconst_1: -1
1 th attempt: second query is SAT-- constant doesn't work
first query is UNSAT-- no more guesses
Dataflow Pruned 0/0
There are 1 Guesses
There are 0 RHSs before deduplication
There are 0 RHSs after deduplication
got 2 candidates from LHS

-------------------------------------------------
%0:i1 = var
%1:i32 = zext %0
infer %1


--------------------------------
guess 0

%0:i32 = var ; reservedconst_1

Cost = 0
first query is SAT, returning the model:
reservedconst_1: 0
0 th attempt: second query is SAT-- constant doesn't work
first query is SAT, returning the model:
reservedconst_1: 1
1 th attempt: second query is SAT-- constant doesn't work
first query is UNSAT-- no more guesses
Dataflow Pruned 0/0
There are 1 Guesses
There are 0 RHSs before deduplication
There are 0 RHSs after deduplication
got 3 candidates from LHS

-------------------------------------------------
%0:i1 = var
%1:i32 = zext %0
%2:i1 = eq 0:i32, %1
infer %2


--------------------------------
guess 0

%0:i1 = var ; reservedconst_1

Cost = 0
first query is SAT, returning the model:
reservedconst_1: -1
0 th attempt: second query is SAT-- constant doesn't work
first query is SAT, returning the model:
reservedconst_1: 0
1 th attempt: second query is SAT-- constant doesn't work
first query is UNSAT-- no more guesses

--------------------------------
guess 1

%0:i1 = var

Cost = 0
second query is SAT-- constant doesn't work
Dataflow Pruned 0/0
There are 2 Guesses
There are 0 RHSs before deduplication
There are 0 RHSs after deduplication
got 2 candidates from LHS

-------------------------------------------------
%0:i32 = var
%1:i32 = add 1:i32, %0
infer %1


--------------------------------
guess 0

%0:i32 = var ; reservedconst_1

Cost = 0
first query is SAT, returning the model:
reservedconst_1: 1
0 th attempt: second query is SAT-- constant doesn't work
first query is SAT, returning the model:
reservedconst_1: 0
1 th attempt: second query is SAT-- constant doesn't work
first query is UNSAT-- no more guesses

--------------------------------
guess 1

%0:i32 = var

Cost = 0
second query is SAT-- constant doesn't work
Dataflow Pruned 0/0
There are 2 Guesses
There are 0 RHSs before deduplication
There are 0 RHSs after deduplication
got 2 candidates from LHS

-------------------------------------------------
%0:i32 = var
%1:i32 = sub %0, 1:i32
infer %1


--------------------------------
guess 0

%0:i32 = var ; reservedconst_1

Cost = 0
first query is SAT, returning the model:
reservedconst_1: -1
0 th attempt: second query is SAT-- constant doesn't work
first query is SAT, returning the model:
reservedconst_1: -2
1 th attempt: second query is SAT-- constant doesn't work
first query is UNSAT-- no more guesses

--------------------------------
guess 1

%0:i32 = var

Cost = 0
second query is SAT-- constant doesn't work
Dataflow Pruned 0/0
There are 2 Guesses
There are 0 RHSs before deduplication
There are 0 RHSs after deduplication
got 3 candidates from LHS

-------------------------------------------------
%0:i32 = var
%1:i32 = var
%2:i32 = mul %0, %1
infer %2


--------------------------------
guess 0

%0:i32 = var ; reservedconst_1

Cost = 0
first query is SAT, returning the model:
reservedconst_1: 0
0 th attempt: second query is SAT-- constant doesn't work
first query is SAT, returning the model:
reservedconst_1: -1
1 th attempt: second query is SAT-- constant doesn't work
first query is UNSAT-- no more guesses

--------------------------------
guess 1

%0:i32 = var

Cost = 0
second query is SAT-- constant doesn't work

--------------------------------
guess 2

%0:i32 = var

Cost = 0
second query is SAT-- constant doesn't work
Dataflow Pruned 0/0
There are 3 Guesses
There are 0 RHSs before deduplication
There are 0 RHSs after deduplication
got 6 candidates from LHS

-------------------------------------------------
%0:i32 = var
%1:i32 = sub %0, 1:i32
%2:i32 = var
%3:i32 = var
%4:i32 = mul %2, %3
%5:i32 = mul %1, %4
infer %5


--------------------------------
guess 0

%0:i32 = var ; reservedconst_1

Cost = 0
first query is SAT, returning the model:
reservedconst_1: 0
0 th attempt: second query is SAT-- constant doesn't work
first query is SAT, returning the model:
reservedconst_1: -1
1 th attempt: second query is SAT-- constant doesn't work
first query is UNSAT-- no more guesses

--------------------------------
guess 1

%0:i32 = var

Cost = 0
second query is SAT-- constant doesn't work

--------------------------------
guess 2

%0:i32 = var

Cost = 0
second query is SAT-- constant doesn't work

--------------------------------
guess 3

%0:i32 = var

Cost = 0
second query is SAT-- constant doesn't work

--------------------------------
guess 4

%0:i32 = var
%1:i32 = var
%2:i32 = mul %0, %1

Cost = 1
second query is SAT-- constant doesn't work

--------------------------------
guess 5

%0:i32 = var
%1:i32 = sub %0, 1:i32

Cost = 1
second query is SAT-- constant doesn't work
Dataflow Pruned 0/0
There are 6 Guesses
There are 0 RHSs before deduplication
There are 0 RHSs after deduplication
got 3 candidates from LHS

-------------------------------------------------
%0:i1 = var
%1:i32 = zext %0
%2:i1 = ne 0:i32, %1
infer %2


--------------------------------
guess 0

%0:i1 = var ; reservedconst_1

Cost = 0
first query is SAT, returning the model:
reservedconst_1: 0
0 th attempt: second query is SAT-- constant doesn't work
first query is SAT, returning the model:
reservedconst_1: -1
1 th attempt: second query is SAT-- constant doesn't work
first query is UNSAT-- no more guesses

--------------------------------
guess 1

%0:i1 = var

Cost = 0
second query is UNSAT
Dataflow Pruned 0/0
There are 2 Guesses
There are 1 RHSs before deduplication
There are 1 RHSs after deduplication
"
; No valid RHS in the list
#########################################################

Module before replacement:
; ModuleID = './Welchs_t-test.c.bc'
source_filename = "./Welchs_t-test.c"
target datalayout = "e-m:e-p:32:32-i64:64-n32:64-S128"
target triple = "wasm32-unknown-wasi"

@.str = private unnamed_addr constant [63 x i8] c"Got a non-finite number in 1st array, can't calculate P-value.\00", align 1
@.str.1 = private unnamed_addr constant [63 x i8] c"Got a non-finite number in 2nd array, can't calculate P-value.\00", align 1
@__const.main.d1 = private unnamed_addr constant [15 x double] [double 2.750000e+01, double 2.100000e+01, double 1.900000e+01, double 2.360000e+01, double 1.700000e+01, double 1.790000e+01, double 1.690000e+01, double 2.010000e+01, double 2.190000e+01, double 2.260000e+01, double 2.310000e+01, double 1.960000e+01, double 1.900000e+01, double 2.170000e+01, double 2.140000e+01], align 16
@__const.main.d2 = private unnamed_addr constant [15 x double] [double 2.710000e+01, double 2.200000e+01, double 2.080000e+01, double 2.340000e+01, double 2.340000e+01, double 2.350000e+01, double 2.580000e+01, double 2.200000e+01, double 2.480000e+01, double 2.020000e+01, double 2.190000e+01, double 2.210000e+01, double 2.290000e+01, double 2.050000e+01, double 2.440000e+01], align 16
@__const.main.d3 = private unnamed_addr constant [10 x double] [double 1.720000e+01, double 2.090000e+01, double 2.260000e+01, double 1.810000e+01, double 2.170000e+01, double 2.140000e+01, double 2.350000e+01, double 2.420000e+01, double 1.470000e+01, double 2.180000e+01], align 16
@__const.main.d4 = private unnamed_addr constant [20 x double] [double 2.150000e+01, double 2.280000e+01, double 2.100000e+01, double 2.300000e+01, double 2.160000e+01, double 2.360000e+01, double 2.250000e+01, double 2.070000e+01, double 2.340000e+01, double 2.180000e+01, double 2.070000e+01, double 2.170000e+01, double 2.150000e+01, double 2.250000e+01, double 2.360000e+01, double 2.150000e+01, double 2.250000e+01, double 2.350000e+01, double 2.150000e+01, double 2.180000e+01], align 16
@__const.main.d5 = private unnamed_addr constant [10 x double] [double 1.980000e+01, double 2.040000e+01, double 1.960000e+01, double 1.780000e+01, double 1.850000e+01, double 1.890000e+01, double 1.830000e+01, double 1.890000e+01, double 1.950000e+01, double 2.200000e+01], align 16
@__const.main.d6 = private unnamed_addr constant [20 x double] [double 2.820000e+01, double 2.660000e+01, double 2.010000e+01, double 2.330000e+01, double 2.520000e+01, double 2.210000e+01, double 1.770000e+01, double 2.760000e+01, double 2.060000e+01, double 1.370000e+01, double 2.320000e+01, double 1.750000e+01, double 2.060000e+01, double 1.800000e+01, double 2.390000e+01, double 2.160000e+01, double 2.430000e+01, double 2.040000e+01, double 2.400000e+01, double 1.320000e+01], align 16
@__const.main.x = private unnamed_addr constant [4 x double] [double 3.000000e+00, double 4.000000e+00, double 1.000000e+00, double 2.100000e+00], align 16
@__const.main.y = private unnamed_addr constant [3 x double] [double 4.902000e+02, double 3.400000e+02, double 4.339000e+02], align 16
@__const.main.v1 = private unnamed_addr constant [3 x double] [double 1.026800e-02, double 1.670000e-04, double 1.670000e-04], align 16
@__const.main.v2 = private unnamed_addr constant [3 x double] [double 1.592580e-01, double 1.362780e-01, double 1.223890e-01], align 16
@__const.main.s1 = private unnamed_addr constant [2 x double] [double 0x3FB1111111111111, double 0x3FC4A5294A5294A5], align 16
@__const.main.s2 = private unnamed_addr constant [2 x double] [double 1.000000e-01, double 4.000000e-02], align 16
@__const.main.z1 = private unnamed_addr constant [3 x double] [double 0x3FD90B21642C8591, double 0x3FDDDDDDDDDDDDDE, double 0.000000e+00], align 16
@__const.main.z2 = private unnamed_addr constant [3 x double] [double 0.000000e+00, double 0x3FDC9882B9310572, double 0.000000e+00], align 16
@__const.main.CORRECT_ANSWERS = private unnamed_addr constant [8 x double] [double 0x3F95E41D648C236F, double 0x3FC30D3EA599BB79, double 0x3FA26AF51F458AEB, double 0x3FB73CEBAB27FA12, double 0x3F8604EA1C27764A, double 0x3F6BD85EAF35CBC8, double 0x3FE0DF5C6BE20DA6, double 0x3FE172D38028625E], align 16
@.str.2 = private unnamed_addr constant [26 x i8] c"Test sets 1 p-value = %g\0A\00", align 1
@.str.3 = private unnamed_addr constant [26 x i8] c"Test sets 2 p-value = %g\0A\00", align 1
@.str.4 = private unnamed_addr constant [26 x i8] c"Test sets 3 p-value = %g\0A\00", align 1
@.str.5 = private unnamed_addr constant [26 x i8] c"Test sets 4 p-value = %g\0A\00", align 1
@.str.6 = private unnamed_addr constant [26 x i8] c"Test sets 5 p-value = %g\0A\00", align 1
@.str.7 = private unnamed_addr constant [26 x i8] c"Test sets 6 p-value = %g\0A\00", align 1
@.str.8 = private unnamed_addr constant [26 x i8] c"Test sets 7 p-value = %g\0A\00", align 1
@.str.9 = private unnamed_addr constant [26 x i8] c"Test sets z p-value = %g\0A\00", align 1
@.str.10 = private unnamed_addr constant [28 x i8] c"the cumulative error is %g\0A\00", align 1
@llvm.used = appending global [1 x i8*] [i8* bitcast (i32 ()* @__main_void to i8*)], section "llvm.metadata"

@__main_void = alias i32 (), i32 ()* @main

; Function Attrs: noinline nounwind optnone
define hidden double @Pvalue(double* noalias %ARRAY1, i32 %ARRAY1_SIZE, double* noalias %ARRAY2, i32 %ARRAY2_SIZE) #0 {
entry:
  %retval = alloca double, align 8
  %ARRAY1.addr = alloca double*, align 4
  %ARRAY1_SIZE.addr = alloca i32, align 4
  %ARRAY2.addr = alloca double*, align 4
  %ARRAY2_SIZE.addr = alloca i32, align 4
  %fmean1 = alloca double, align 8
  %fmean2 = alloca double, align 8
  %x = alloca i32, align 4
  %x9 = alloca i32, align 4
  %unbiased_sample_variance1 = alloca double, align 8
  %unbiased_sample_variance2 = alloca double, align 8
  %x32 = alloca i32, align 4
  %x44 = alloca i32, align 4
  %WELCH_T_STATISTIC = alloca double, align 8
  %DEGREES_OF_FREEDOM = alloca double, align 8
  %a = alloca double, align 8
  %value = alloca double, align 8
  %beta = alloca double, align 8
  %acu = alloca double, align 8
  %ai = alloca double, align 8
  %cx = alloca double, align 8
  %indx = alloca i32, align 4
  %ns = alloca i32, align 4
  %pp = alloca double, align 8
  %psq = alloca double, align 8
  %qq = alloca double, align 8
  %rx = alloca double, align 8
  %temp = alloca double, align 8
  %term = alloca double, align 8
  %xx = alloca double, align 8
  store double* %ARRAY1, double** %ARRAY1.addr, align 4
  store i32 %ARRAY1_SIZE, i32* %ARRAY1_SIZE.addr, align 4
  store double* %ARRAY2, double** %ARRAY2.addr, align 4
  store i32 %ARRAY2_SIZE, i32* %ARRAY2_SIZE.addr, align 4
  %0 = load i32, i32* %ARRAY1_SIZE.addr, align 4
  %cmp = icmp ule i32 %0, 1
  br i1 %cmp, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  store double 1.000000e+00, double* %retval, align 8
  br label %return

if.else:                                          ; preds = %entry
  %1 = load i32, i32* %ARRAY2_SIZE.addr, align 4
  %cmp1 = icmp ule i32 %1, 1
  br i1 %cmp1, label %if.then2, label %if.end

if.then2:                                         ; preds = %if.else
  store double 1.000000e+00, double* %retval, align 8
  br label %return

if.end:                                           ; preds = %if.else
  br label %if.end3

if.end3:                                          ; preds = %if.end
  store double 0.000000e+00, double* %fmean1, align 8
  store double 0.000000e+00, double* %fmean2, align 8
  store i32 0, i32* %x, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.end3
  %2 = load i32, i32* %x, align 4
  %3 = load i32, i32* %ARRAY1_SIZE.addr, align 4
  %cmp4 = icmp ult i32 %2, %3
  br i1 %cmp4, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %4 = load double*, double** %ARRAY1.addr, align 4
  %5 = load i32, i32* %x, align 4
  %arrayidx = getelementptr inbounds double, double* %4, i32 %5
  %6 = load double, double* %arrayidx, align 8
  %7 = call double @llvm.fabs.f64(double %6) #7
  %cmpinf = fcmp one double %7, 0x7FF0000000000000
  %8 = zext i1 %cmpinf to i32
  %cmp5 = icmp eq i32 %8, 0
  br i1 %cmp5, label %if.then6, label %if.end7

if.then6:                                         ; preds = %for.body
  %call = call i32 @puts(i8* getelementptr inbounds ([63 x i8], [63 x i8]* @.str, i32 0, i32 0))
  call void @exit(i32 1) #8
  unreachable

if.end7:                                          ; preds = %for.body
  %9 = load double*, double** %ARRAY1.addr, align 4
  %10 = load i32, i32* %x, align 4
  %arrayidx8 = getelementptr inbounds double, double* %9, i32 %10
  %11 = load double, double* %arrayidx8, align 8
  %12 = load double, double* %fmean1, align 8
  %add = fadd double %12, %11
  store double %add, double* %fmean1, align 8
  br label %for.inc

for.inc:                                          ; preds = %if.end7
  %13 = load i32, i32* %x, align 4
  %inc = add i32 %13, 1
  store i32 %inc, i32* %x, align 4
  br label %for.cond

for.end:                                          ; preds = %for.cond
  %14 = load i32, i32* %ARRAY1_SIZE.addr, align 4
  %conv = uitofp i32 %14 to double
  %15 = load double, double* %fmean1, align 8
  %div = fdiv double %15, %conv
  store double %div, double* %fmean1, align 8
  store i32 0, i32* %x9, align 4
  br label %for.cond10

for.cond10:                                       ; preds = %for.inc23, %for.end
  %16 = load i32, i32* %x9, align 4
  %17 = load i32, i32* %ARRAY2_SIZE.addr, align 4
  %cmp11 = icmp ult i32 %16, %17
  br i1 %cmp11, label %for.body13, label %for.end25

for.body13:                                       ; preds = %for.cond10
  %18 = load double*, double** %ARRAY2.addr, align 4
  %19 = load i32, i32* %x9, align 4
  %arrayidx14 = getelementptr inbounds double, double* %18, i32 %19
  %20 = load double, double* %arrayidx14, align 8
  %21 = call double @llvm.fabs.f64(double %20) #7
  %cmpinf15 = fcmp one double %21, 0x7FF0000000000000
  %22 = zext i1 %cmpinf15 to i32
  %cmp16 = icmp eq i32 %22, 0
  br i1 %cmp16, label %if.then18, label %if.end20

if.then18:                                        ; preds = %for.body13
  %call19 = call i32 @puts(i8* getelementptr inbounds ([63 x i8], [63 x i8]* @.str.1, i32 0, i32 0))
  call void @exit(i32 1) #8
  unreachable

if.end20:                                         ; preds = %for.body13
  %23 = load double*, double** %ARRAY2.addr, align 4
  %24 = load i32, i32* %x9, align 4
  %arrayidx21 = getelementptr inbounds double, double* %23, i32 %24
  %25 = load double, double* %arrayidx21, align 8
  %26 = load double, double* %fmean2, align 8
  %add22 = fadd double %26, %25
  store double %add22, double* %fmean2, align 8
  br label %for.inc23

for.inc23:                                        ; preds = %if.end20
  %27 = load i32, i32* %x9, align 4
  %inc24 = add i32 %27, 1
  store i32 %inc24, i32* %x9, align 4
  br label %for.cond10

for.end25:                                        ; preds = %for.cond10
  %28 = load i32, i32* %ARRAY2_SIZE.addr, align 4
  %conv26 = uitofp i32 %28 to double
  %29 = load double, double* %fmean2, align 8
  %div27 = fdiv double %29, %conv26
  store double %div27, double* %fmean2, align 8
  %30 = load double, double* %fmean1, align 8
  %31 = load double, double* %fmean2, align 8
  %cmp28 = fcmp oeq double %30, %31
  br i1 %cmp28, label %if.then30, label %if.end31

if.then30:                                        ; preds = %for.end25
  store double 1.000000e+00, double* %retval, align 8
  br label %return

if.end31:                                         ; preds = %for.end25
  store double 0.000000e+00, double* %unbiased_sample_variance1, align 8
  store double 0.000000e+00, double* %unbiased_sample_variance2, align 8
  store i32 0, i32* %x32, align 4
  br label %for.cond33

for.cond33:                                       ; preds = %for.inc41, %if.end31
  %32 = load i32, i32* %x32, align 4
  %33 = load i32, i32* %ARRAY1_SIZE.addr, align 4
  %cmp34 = icmp ult i32 %32, %33
  br i1 %cmp34, label %for.body36, label %for.end43

for.body36:                                       ; preds = %for.cond33
  %34 = load double*, double** %ARRAY1.addr, align 4
  %35 = load i32, i32* %x32, align 4
  %arrayidx37 = getelementptr inbounds double, double* %34, i32 %35
  %36 = load double, double* %arrayidx37, align 8
  %37 = load double, double* %fmean1, align 8
  %sub = fsub double %36, %37
  %38 = load double*, double** %ARRAY1.addr, align 4
  %39 = load i32, i32* %x32, align 4
  %arrayidx38 = getelementptr inbounds double, double* %38, i32 %39
  %40 = load double, double* %arrayidx38, align 8
  %41 = load double, double* %fmean1, align 8
  %sub39 = fsub double %40, %41
  %mul = fmul double %sub, %sub39
  %42 = load double, double* %unbiased_sample_variance1, align 8
  %add40 = fadd double %42, %mul
  store double %add40, double* %unbiased_sample_variance1, align 8
  br label %for.inc41

for.inc41:                                        ; preds = %for.body36
  %43 = load i32, i32* %x32, align 4
  %inc42 = add i32 %43, 1
  store i32 %inc42, i32* %x32, align 4
  br label %for.cond33

for.end43:                                        ; preds = %for.cond33
  store i32 0, i32* %x44, align 4
  br label %for.cond45

for.cond45:                                       ; preds = %for.inc55, %for.end43
  %44 = load i32, i32* %x44, align 4
  %45 = load i32, i32* %ARRAY2_SIZE.addr, align 4
  %cmp46 = icmp ult i32 %44, %45
  br i1 %cmp46, label %for.body48, label %for.end57

for.body48:                                       ; preds = %for.cond45
  %46 = load double*, double** %ARRAY2.addr, align 4
  %47 = load i32, i32* %x44, align 4
  %arrayidx49 = getelementptr inbounds double, double* %46, i32 %47
  %48 = load double, double* %arrayidx49, align 8
  %49 = load double, double* %fmean2, align 8
  %sub50 = fsub double %48, %49
  %50 = load double*, double** %ARRAY2.addr, align 4
  %51 = load i32, i32* %x44, align 4
  %arrayidx51 = getelementptr inbounds double, double* %50, i32 %51
  %52 = load double, double* %arrayidx51, align 8
  %53 = load double, double* %fmean2, align 8
  %sub52 = fsub double %52, %53
  %mul53 = fmul double %sub50, %sub52
  %54 = load double, double* %unbiased_sample_variance2, align 8
  %add54 = fadd double %54, %mul53
  store double %add54, double* %unbiased_sample_variance2, align 8
  br label %for.inc55

for.inc55:                                        ; preds = %for.body48
  %55 = load i32, i32* %x44, align 4
  %inc56 = add i32 %55, 1
  store i32 %inc56, i32* %x44, align 4
  br label %for.cond45

for.end57:                                        ; preds = %for.cond45
  %56 = load double, double* %unbiased_sample_variance1, align 8
  %57 = load i32, i32* %ARRAY1_SIZE.addr, align 4
  %sub58 = sub i32 %57, 1
  %conv59 = uitofp i32 %sub58 to double
  %div60 = fdiv double %56, %conv59
  store double %div60, double* %unbiased_sample_variance1, align 8
  %58 = load double, double* %unbiased_sample_variance2, align 8
  %59 = load i32, i32* %ARRAY2_SIZE.addr, align 4
  %sub61 = sub i32 %59, 1
  %conv62 = uitofp i32 %sub61 to double
  %div63 = fdiv double %58, %conv62
  store double %div63, double* %unbiased_sample_variance2, align 8
  %60 = load double, double* %fmean1, align 8
  %61 = load double, double* %fmean2, align 8
  %sub64 = fsub double %60, %61
  %62 = load double, double* %unbiased_sample_variance1, align 8
  %63 = load i32, i32* %ARRAY1_SIZE.addr, align 4
  %conv65 = uitofp i32 %63 to double
  %div66 = fdiv double %62, %conv65
  %64 = load double, double* %unbiased_sample_variance2, align 8
  %65 = load i32, i32* %ARRAY2_SIZE.addr, align 4
  %conv67 = uitofp i32 %65 to double
  %div68 = fdiv double %64, %conv67
  %add69 = fadd double %div66, %div68
  %66 = call double @llvm.sqrt.f64(double %add69)
  %div70 = fdiv double %sub64, %66
  store double %div70, double* %WELCH_T_STATISTIC, align 8
  %67 = load double, double* %unbiased_sample_variance1, align 8
  %68 = load i32, i32* %ARRAY1_SIZE.addr, align 4
  %conv71 = uitofp i32 %68 to double
  %div72 = fdiv double %67, %conv71
  %69 = load double, double* %unbiased_sample_variance2, align 8
  %70 = load i32, i32* %ARRAY2_SIZE.addr, align 4
  %conv73 = uitofp i32 %70 to double
  %div74 = fdiv double %69, %conv73
  %add75 = fadd double %div72, %div74
  %71 = call double @llvm.pow.f64(double %add75, double 2.000000e+00)
  %72 = load double, double* %unbiased_sample_variance1, align 8
  %73 = load double, double* %unbiased_sample_variance1, align 8
  %mul76 = fmul double %72, %73
  %74 = load i32, i32* %ARRAY1_SIZE.addr, align 4
  %75 = load i32, i32* %ARRAY1_SIZE.addr, align 4
  %mul77 = mul i32 %74, %75
  %76 = load i32, i32* %ARRAY1_SIZE.addr, align 4
  %sub78 = sub i32 %76, 1
  %mul79 = mul i32 %mul77, %sub78
  %conv80 = uitofp i32 %mul79 to double
  %div81 = fdiv double %mul76, %conv80
  %77 = load double, double* %unbiased_sample_variance2, align 8
  %78 = load double, double* %unbiased_sample_variance2, align 8
  %mul82 = fmul double %77, %78
  %79 = load i32, i32* %ARRAY2_SIZE.addr, align 4
  %80 = load i32, i32* %ARRAY2_SIZE.addr, align 4
  %mul83 = mul i32 %79, %80
  %81 = load i32, i32* %ARRAY2_SIZE.addr, align 4
  %sub84 = sub i32 %81, 1
  %mul85 = mul i32 %mul83, %sub84
  %conv86 = uitofp i32 %mul85 to double
  %div87 = fdiv double %mul82, %conv86
  %add88 = fadd double %div81, %div87
  %div89 = fdiv double %71, %add88
  store double %div89, double* %DEGREES_OF_FREEDOM, align 8
  %82 = load double, double* %DEGREES_OF_FREEDOM, align 8
  %div90 = fdiv double %82, 2.000000e+00
  store double %div90, double* %a, align 8
  %83 = load double, double* %DEGREES_OF_FREEDOM, align 8
  %84 = load double, double* %WELCH_T_STATISTIC, align 8
  %85 = load double, double* %WELCH_T_STATISTIC, align 8
  %mul91 = fmul double %84, %85
  %86 = load double, double* %DEGREES_OF_FREEDOM, align 8
  %add92 = fadd double %mul91, %86
  %div93 = fdiv double %83, %add92
  store double %div93, double* %value, align 8
  %87 = load double, double* %value, align 8
  %88 = call double @llvm.fabs.f64(double %87) #7
  %cmpinf94 = fcmp oeq double %88, 0x7FF0000000000000
  %89 = zext i1 %cmpinf94 to i32
  %cmp95 = icmp ne i32 %89, 0
  br i1 %cmp95, label %if.then100, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %for.end57
  %90 = load double, double* %value, align 8
  %cmp97 = fcmp uno double %90, %90
  %91 = zext i1 %cmp97 to i32
  %cmp98 = icmp ne i32 %91, 0
  br i1 %cmp98, label %if.then100, label %if.end101

if.then100:                                       ; preds = %lor.lhs.false, %for.end57
  store double 1.000000e+00, double* %retval, align 8
  br label %return

if.end101:                                        ; preds = %lor.lhs.false
  %92 = load double, double* %value, align 8
  %93 = call double @llvm.fabs.f64(double %92) #7
  %cmpinf102 = fcmp oeq double %93, 0x7FF0000000000000
  %94 = zext i1 %cmpinf102 to i32
  %cmp103 = icmp ne i32 %94, 0
  br i1 %cmp103, label %if.then109, label %lor.lhs.false105

lor.lhs.false105:                                 ; preds = %if.end101
  %95 = load double, double* %value, align 8
  %cmp106 = fcmp uno double %95, %95
  %96 = zext i1 %cmp106 to i32
  %cmp107 = icmp ne i32 %96, 0
  br i1 %cmp107, label %if.then109, label %if.end110

if.then109:                                       ; preds = %lor.lhs.false105, %if.end101
  store double 1.000000e+00, double* %retval, align 8
  br label %return

if.end110:                                        ; preds = %lor.lhs.false105
  %97 = load double, double* %a, align 8
  %conv111 = fpext double %97 to fp128
  %call112 = call fp128 @lgammal(fp128 %conv111) #9
  %add113 = fadd fp128 %call112, 0xLD0000000000000003FFE250D048E7A1B
  %98 = load double, double* %a, align 8
  %add114 = fadd double %98, 5.000000e-01
  %conv115 = fpext double %add114 to fp128
  %call116 = call fp128 @lgammal(fp128 %conv115) #9
  %sub117 = fsub fp128 %add113, %call116
  %conv118 = fptrunc fp128 %sub117 to double
  store double %conv118, double* %beta, align 8
  store double 1.000000e-15, double* %acu, align 8
  %99 = load double, double* %a, align 8
  %cmp119 = fcmp ole double %99, 0.000000e+00
  br i1 %cmp119, label %if.then121, label %if.end122

if.then121:                                       ; preds = %if.end110
  br label %if.end122

if.end122:                                        ; preds = %if.then121, %if.end110
  %100 = load double, double* %value, align 8
  %cmp123 = fcmp olt double %100, 0.000000e+00
  br i1 %cmp123, label %if.then128, label %lor.lhs.false125

lor.lhs.false125:                                 ; preds = %if.end122
  %101 = load double, double* %value, align 8
  %cmp126 = fcmp olt double 1.000000e+00, %101
  br i1 %cmp126, label %if.then128, label %if.end129

if.then128:                                       ; preds = %lor.lhs.false125, %if.end122
  %102 = load double, double* %value, align 8
  store double %102, double* %retval, align 8
  br label %return

if.end129:                                        ; preds = %lor.lhs.false125
  %103 = load double, double* %value, align 8
  %cmp130 = fcmp oeq double %103, 0.000000e+00
  br i1 %cmp130, label %if.then135, label %lor.lhs.false132

lor.lhs.false132:                                 ; preds = %if.end129
  %104 = load double, double* %value, align 8
  %cmp133 = fcmp oeq double %104, 1.000000e+00
  br i1 %cmp133, label %if.then135, label %if.end136

if.then135:                                       ; preds = %lor.lhs.false132, %if.end129
  %105 = load double, double* %value, align 8
  store double %105, double* %retval, align 8
  br label %return

if.end136:                                        ; preds = %lor.lhs.false132
  %106 = load double, double* %a, align 8
  %add137 = fadd double %106, 5.000000e-01
  store double %add137, double* %psq, align 8
  %107 = load double, double* %value, align 8
  %sub138 = fsub double 1.000000e+00, %107
  store double %sub138, double* %cx, align 8
  %108 = load double, double* %a, align 8
  %109 = load double, double* %psq, align 8
  %110 = load double, double* %value, align 8
  %mul139 = fmul double %109, %110
  %cmp140 = fcmp olt double %108, %mul139
  br i1 %cmp140, label %if.then142, label %if.else143

if.then142:                                       ; preds = %if.end136
  %111 = load double, double* %cx, align 8
  store double %111, double* %xx, align 8
  %112 = load double, double* %value, align 8
  store double %112, double* %cx, align 8
  store double 5.000000e-01, double* %pp, align 8
  %113 = load double, double* %a, align 8
  store double %113, double* %qq, align 8
  store i32 1, i32* %indx, align 4
  br label %if.end144

if.else143:                                       ; preds = %if.end136
  %114 = load double, double* %value, align 8
  store double %114, double* %xx, align 8
  %115 = load double, double* %a, align 8
  store double %115, double* %pp, align 8
  store double 5.000000e-01, double* %qq, align 8
  store i32 0, i32* %indx, align 4
  br label %if.end144

if.end144:                                        ; preds = %if.else143, %if.then142
  store double 1.000000e+00, double* %term, align 8
  store double 1.000000e+00, double* %ai, align 8
  store double 1.000000e+00, double* %value, align 8
  %116 = load double, double* %qq, align 8
  %117 = load double, double* %cx, align 8
  %118 = load double, double* %psq, align 8
  %mul145 = fmul double %117, %118
  %add146 = fadd double %116, %mul145
  %conv147 = fptosi double %add146 to i32
  store i32 %conv147, i32* %ns, align 4
  %119 = load double, double* %xx, align 8
  %120 = load double, double* %cx, align 8
  %div148 = fdiv double %119, %120
  store double %div148, double* %rx, align 8
  %121 = load double, double* %qq, align 8
  %122 = load double, double* %ai, align 8
  %sub149 = fsub double %121, %122
  store double %sub149, double* %temp, align 8
  %123 = load i32, i32* %ns, align 4
  %cmp150 = icmp eq i32 %123, 0
  br i1 %cmp150, label %if.then152, label %if.end153

if.then152:                                       ; preds = %if.end144
  %124 = load double, double* %xx, align 8
  store double %124, double* %rx, align 8
  br label %if.end153

if.end153:                                        ; preds = %if.then152, %if.end144
  br label %for.cond154

for.cond154:                                      ; preds = %if.end189, %if.end153
  %125 = load double, double* %term, align 8
  %126 = load double, double* %temp, align 8
  %mul155 = fmul double %125, %126
  %127 = load double, double* %rx, align 8
  %mul156 = fmul double %mul155, %127
  %128 = load double, double* %pp, align 8
  %129 = load double, double* %ai, align 8
  %add157 = fadd double %128, %129
  %div158 = fdiv double %mul156, %add157
  store double %div158, double* %term, align 8
  %130 = load double, double* %value, align 8
  %131 = load double, double* %term, align 8
  %add159 = fadd double %130, %131
  store double %add159, double* %value, align 8
  %132 = load double, double* %term, align 8
  %133 = call double @llvm.fabs.f64(double %132)
  store double %133, double* %temp, align 8
  %134 = load double, double* %temp, align 8
  %cmp160 = fcmp ole double %134, 1.000000e-15
  br i1 %cmp160, label %land.lhs.true, label %if.end176

land.lhs.true:                                    ; preds = %for.cond154
  %135 = load double, double* %temp, align 8
  %136 = load double, double* %value, align 8
  %mul162 = fmul double 1.000000e-15, %136
  %cmp163 = fcmp ole double %135, %mul162
  br i1 %cmp163, label %if.then165, label %if.end176

if.then165:                                       ; preds = %land.lhs.true
  %137 = load double, double* %value, align 8
  %138 = load double, double* %pp, align 8
  %139 = load double, double* %xx, align 8
  %140 = call double @llvm.log.f64(double %139)
  %mul166 = fmul double %138, %140
  %141 = load double, double* %qq, align 8
  %sub167 = fsub double %141, 1.000000e+00
  %142 = load double, double* %cx, align 8
  %143 = call double @llvm.log.f64(double %142)
  %mul168 = fmul double %sub167, %143
  %add169 = fadd double %mul166, %mul168
  %144 = load double, double* %beta, align 8
  %sub170 = fsub double %add169, %144
  %145 = call double @llvm.exp.f64(double %sub170)
  %mul171 = fmul double %137, %145
  %146 = load double, double* %pp, align 8
  %div172 = fdiv double %mul171, %146
  store double %div172, double* %value, align 8
  %147 = load i32, i32* %indx, align 4
  %tobool = icmp ne i32 %147, 0
  br i1 %tobool, label %if.then173, label %if.end175

if.then173:                                       ; preds = %if.then165
  %148 = load double, double* %value, align 8
  %sub174 = fsub double 1.000000e+00, %148
  store double %sub174, double* %value, align 8
  br label %if.end175

if.end175:                                        ; preds = %if.then173, %if.then165
  br label %for.end190

if.end176:                                        ; preds = %land.lhs.true, %for.cond154
  %149 = load double, double* %ai, align 8
  %add177 = fadd double %149, 1.000000e+00
  store double %add177, double* %ai, align 8
  %150 = load i32, i32* %ns, align 4
  %sub178 = sub nsw i32 %150, 1
  store i32 %sub178, i32* %ns, align 4
  %151 = load i32, i32* %ns, align 4
  %cmp179 = icmp sle i32 0, %151
  br i1 %cmp179, label %if.then181, label %if.else187

if.then181:                                       ; preds = %if.end176
  %152 = load double, double* %qq, align 8
  %153 = load double, double* %ai, align 8
  %sub182 = fsub double %152, %153
  store double %sub182, double* %temp, align 8
  %154 = load i32, i32* %ns, align 4
  %cmp183 = icmp eq i32 %154, 0
  br i1 %cmp183, label %if.then185, label %if.end186

if.then185:                                       ; preds = %if.then181
  %155 = load double, double* %xx, align 8
  store double %155, double* %rx, align 8
  br label %if.end186

if.end186:                                        ; preds = %if.then185, %if.then181
  br label %if.end189

if.else187:                                       ; preds = %if.end176
  %156 = load double, double* %psq, align 8
  store double %156, double* %temp, align 8
  %157 = load double, double* %psq, align 8
  %add188 = fadd double %157, 1.000000e+00
  store double %add188, double* %psq, align 8
  br label %if.end189

if.end189:                                        ; preds = %if.else187, %if.end186
  br label %for.cond154

for.end190:                                       ; preds = %if.end175
  %158 = load double, double* %value, align 8
  store double %158, double* %retval, align 8
  br label %return

return:                                           ; preds = %for.end190, %if.then135, %if.then128, %if.then109, %if.then100, %if.then30, %if.then2, %if.then
  %159 = load double, double* %retval, align 8
  ret double %159
}

; Function Attrs: nounwind readnone speculatable willreturn
declare double @llvm.fabs.f64(double %0) #1

declare i32 @puts(i8* %0) #2

; Function Attrs: noreturn
declare void @exit(i32 %0) #3

; Function Attrs: nounwind readnone speculatable willreturn
declare double @llvm.sqrt.f64(double %0) #1

; Function Attrs: nounwind readnone speculatable willreturn
declare double @llvm.pow.f64(double %0, double %1) #1

; Function Attrs: nounwind
declare fp128 @lgammal(fp128 %0) #4

; Function Attrs: nounwind readnone speculatable willreturn
declare double @llvm.log.f64(double %0) #1

; Function Attrs: nounwind readnone speculatable willreturn
declare double @llvm.exp.f64(double %0) #1

; Function Attrs: noinline nounwind optnone
define hidden i32 @main() #0 {
entry:
  %retval = alloca i32, align 4
  %d1 = alloca [15 x double], align 16
  %d2 = alloca [15 x double], align 16
  %d3 = alloca [10 x double], align 16
  %d4 = alloca [20 x double], align 16
  %d5 = alloca [10 x double], align 16
  %d6 = alloca [20 x double], align 16
  %d7 = alloca [6 x double], align 16
  %d8 = alloca [6 x double], align 16
  %x = alloca [4 x double], align 16
  %y = alloca [3 x double], align 16
  %v1 = alloca [3 x double], align 16
  %v2 = alloca [3 x double], align 16
  %s1 = alloca [2 x double], align 16
  %s2 = alloca [2 x double], align 16
  %z1 = alloca [3 x double], align 16
  %z2 = alloca [3 x double], align 16
  %CORRECT_ANSWERS = alloca [8 x double], align 16
  %pvalue = alloca double, align 8
  %error = alloca double, align 8
  store i32 0, i32* %retval, align 4
  %0 = bitcast [15 x double]* %d1 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 16 %0, i8* align 16 bitcast ([15 x double]* @__const.main.d1 to i8*), i32 120, i1 false)
  %1 = bitcast [15 x double]* %d2 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 16 %1, i8* align 16 bitcast ([15 x double]* @__const.main.d2 to i8*), i32 120, i1 false)
  %2 = bitcast [10 x double]* %d3 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 16 %2, i8* align 16 bitcast ([10 x double]* @__const.main.d3 to i8*), i32 80, i1 false)
  %3 = bitcast [20 x double]* %d4 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 16 %3, i8* align 16 bitcast ([20 x double]* @__const.main.d4 to i8*), i32 160, i1 false)
  %4 = bitcast [10 x double]* %d5 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 16 %4, i8* align 16 bitcast ([10 x double]* @__const.main.d5 to i8*), i32 80, i1 false)
  %5 = bitcast [20 x double]* %d6 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 16 %5, i8* align 16 bitcast ([20 x double]* @__const.main.d6 to i8*), i32 160, i1 false)
  %6 = bitcast [6 x double]* %d7 to i8*
  call void @llvm.memset.p0i8.i32(i8* align 16 %6, i8 0, i32 48, i1 false)
  %7 = bitcast i8* %6 to [6 x double]*
  %8 = getelementptr inbounds [6 x double], [6 x double]* %7, i32 0, i32 0
  store double 3.002000e+01, double* %8, align 16
  %9 = getelementptr inbounds [6 x double], [6 x double]* %7, i32 0, i32 1
  store double 2.999000e+01, double* %9, align 8
  %10 = getelementptr inbounds [6 x double], [6 x double]* %7, i32 0, i32 2
  store double 3.011000e+01, double* %10, align 16
  %11 = getelementptr inbounds [6 x double], [6 x double]* %7, i32 0, i32 3
  store double 2.997000e+01, double* %11, align 8
  %12 = getelementptr inbounds [6 x double], [6 x double]* %7, i32 0, i32 4
  store double 3.001000e+01, double* %12, align 16
  %13 = getelementptr inbounds [6 x double], [6 x double]* %7, i32 0, i32 5
  store double 2.999000e+01, double* %13, align 8
  %14 = bitcast [6 x double]* %d8 to i8*
  call void @llvm.memset.p0i8.i32(i8* align 16 %14, i8 0, i32 48, i1 false)
  %15 = bitcast i8* %14 to [6 x double]*
  %16 = getelementptr inbounds [6 x double], [6 x double]* %15, i32 0, i32 0
  store double 2.989000e+01, double* %16, align 16
  %17 = getelementptr inbounds [6 x double], [6 x double]* %15, i32 0, i32 1
  store double 2.993000e+01, double* %17, align 8
  %18 = getelementptr inbounds [6 x double], [6 x double]* %15, i32 0, i32 2
  store double 2.972000e+01, double* %18, align 16
  %19 = getelementptr inbounds [6 x double], [6 x double]* %15, i32 0, i32 3
  store double 2.998000e+01, double* %19, align 8
  %20 = getelementptr inbounds [6 x double], [6 x double]* %15, i32 0, i32 4
  store double 3.002000e+01, double* %20, align 16
  %21 = getelementptr inbounds [6 x double], [6 x double]* %15, i32 0, i32 5
  store double 2.998000e+01, double* %21, align 8
  %22 = bitcast [4 x double]* %x to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 16 %22, i8* align 16 bitcast ([4 x double]* @__const.main.x to i8*), i32 32, i1 false)
  %23 = bitcast [3 x double]* %y to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 16 %23, i8* align 16 bitcast ([3 x double]* @__const.main.y to i8*), i32 24, i1 false)
  %24 = bitcast [3 x double]* %v1 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 16 %24, i8* align 16 bitcast ([3 x double]* @__const.main.v1 to i8*), i32 24, i1 false)
  %25 = bitcast [3 x double]* %v2 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 16 %25, i8* align 16 bitcast ([3 x double]* @__const.main.v2 to i8*), i32 24, i1 false)
  %26 = bitcast [2 x double]* %s1 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 16 %26, i8* align 16 bitcast ([2 x double]* @__const.main.s1 to i8*), i32 16, i1 false)
  %27 = bitcast [2 x double]* %s2 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 16 %27, i8* align 16 bitcast ([2 x double]* @__const.main.s2 to i8*), i32 16, i1 false)
  %28 = bitcast [3 x double]* %z1 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 16 %28, i8* align 16 bitcast ([3 x double]* @__const.main.z1 to i8*), i32 24, i1 false)
  %29 = bitcast [3 x double]* %z2 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 16 %29, i8* align 16 bitcast ([3 x double]* @__const.main.z2 to i8*), i32 24, i1 false)
  %30 = bitcast [8 x double]* %CORRECT_ANSWERS to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 16 %30, i8* align 16 bitcast ([8 x double]* @__const.main.CORRECT_ANSWERS to i8*), i32 64, i1 false)
  %arraydecay = getelementptr inbounds [15 x double], [15 x double]* %d1, i32 0, i32 0
  %arraydecay1 = getelementptr inbounds [15 x double], [15 x double]* %d2, i32 0, i32 0
  %call = call double @Pvalue(double* %arraydecay, i32 15, double* %arraydecay1, i32 15)
  store double %call, double* %pvalue, align 8
  %31 = load double, double* %pvalue, align 8
  %arrayidx = getelementptr inbounds [8 x double], [8 x double]* %CORRECT_ANSWERS, i32 0, i32 0
  %32 = load double, double* %arrayidx, align 16
  %sub = fsub double %31, %32
  %33 = call double @llvm.fabs.f64(double %sub)
  store double %33, double* %error, align 8
  %34 = load double, double* %pvalue, align 8
  %call2 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([26 x i8], [26 x i8]* @.str.2, i32 0, i32 0), double %34)
  %arraydecay3 = getelementptr inbounds [10 x double], [10 x double]* %d3, i32 0, i32 0
  %arraydecay4 = getelementptr inbounds [20 x double], [20 x double]* %d4, i32 0, i32 0
  %call5 = call double @Pvalue(double* %arraydecay3, i32 10, double* %arraydecay4, i32 20)
  store double %call5, double* %pvalue, align 8
  %35 = load double, double* %pvalue, align 8
  %arrayidx6 = getelementptr inbounds [8 x double], [8 x double]* %CORRECT_ANSWERS, i32 0, i32 1
  %36 = load double, double* %arrayidx6, align 8
  %sub7 = fsub double %35, %36
  %37 = call double @llvm.fabs.f64(double %sub7)
  %38 = load double, double* %error, align 8
  %add = fadd double %38, %37
  store double %add, double* %error, align 8
  %39 = load double, double* %pvalue, align 8
  %call8 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([26 x i8], [26 x i8]* @.str.3, i32 0, i32 0), double %39)
  %arraydecay9 = getelementptr inbounds [10 x double], [10 x double]* %d5, i32 0, i32 0
  %arraydecay10 = getelementptr inbounds [20 x double], [20 x double]* %d6, i32 0, i32 0
  %call11 = call double @Pvalue(double* %arraydecay9, i32 10, double* %arraydecay10, i32 20)
  store double %call11, double* %pvalue, align 8
  %40 = load double, double* %pvalue, align 8
  %arrayidx12 = getelementptr inbounds [8 x double], [8 x double]* %CORRECT_ANSWERS, i32 0, i32 2
  %41 = load double, double* %arrayidx12, align 16
  %sub13 = fsub double %40, %41
  %42 = call double @llvm.fabs.f64(double %sub13)
  %43 = load double, double* %error, align 8
  %add14 = fadd double %43, %42
  store double %add14, double* %error, align 8
  %44 = load double, double* %pvalue, align 8
  %call15 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([26 x i8], [26 x i8]* @.str.4, i32 0, i32 0), double %44)
  %arraydecay16 = getelementptr inbounds [6 x double], [6 x double]* %d7, i32 0, i32 0
  %arraydecay17 = getelementptr inbounds [6 x double], [6 x double]* %d8, i32 0, i32 0
  %call18 = call double @Pvalue(double* %arraydecay16, i32 6, double* %arraydecay17, i32 6)
  store double %call18, double* %pvalue, align 8
  %45 = load double, double* %pvalue, align 8
  %call19 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([26 x i8], [26 x i8]* @.str.5, i32 0, i32 0), double %45)
  %46 = load double, double* %pvalue, align 8
  %arrayidx20 = getelementptr inbounds [8 x double], [8 x double]* %CORRECT_ANSWERS, i32 0, i32 3
  %47 = load double, double* %arrayidx20, align 8
  %sub21 = fsub double %46, %47
  %48 = call double @llvm.fabs.f64(double %sub21)
  %49 = load double, double* %error, align 8
  %add22 = fadd double %49, %48
  store double %add22, double* %error, align 8
  %arraydecay23 = getelementptr inbounds [4 x double], [4 x double]* %x, i32 0, i32 0
  %arraydecay24 = getelementptr inbounds [3 x double], [3 x double]* %y, i32 0, i32 0
  %call25 = call double @Pvalue(double* %arraydecay23, i32 4, double* %arraydecay24, i32 3)
  store double %call25, double* %pvalue, align 8
  %50 = load double, double* %pvalue, align 8
  %arrayidx26 = getelementptr inbounds [8 x double], [8 x double]* %CORRECT_ANSWERS, i32 0, i32 4
  %51 = load double, double* %arrayidx26, align 16
  %sub27 = fsub double %50, %51
  %52 = call double @llvm.fabs.f64(double %sub27)
  %53 = load double, double* %error, align 8
  %add28 = fadd double %53, %52
  store double %add28, double* %error, align 8
  %54 = load double, double* %pvalue, align 8
  %call29 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([26 x i8], [26 x i8]* @.str.6, i32 0, i32 0), double %54)
  %arraydecay30 = getelementptr inbounds [3 x double], [3 x double]* %v1, i32 0, i32 0
  %arraydecay31 = getelementptr inbounds [3 x double], [3 x double]* %v2, i32 0, i32 0
  %call32 = call double @Pvalue(double* %arraydecay30, i32 3, double* %arraydecay31, i32 3)
  store double %call32, double* %pvalue, align 8
  %55 = load double, double* %pvalue, align 8
  %arrayidx33 = getelementptr inbounds [8 x double], [8 x double]* %CORRECT_ANSWERS, i32 0, i32 5
  %56 = load double, double* %arrayidx33, align 8
  %sub34 = fsub double %55, %56
  %57 = call double @llvm.fabs.f64(double %sub34)
  %58 = load double, double* %error, align 8
  %add35 = fadd double %58, %57
  store double %add35, double* %error, align 8
  %59 = load double, double* %pvalue, align 8
  %call36 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([26 x i8], [26 x i8]* @.str.7, i32 0, i32 0), double %59)
  %arraydecay37 = getelementptr inbounds [2 x double], [2 x double]* %s1, i32 0, i32 0
  %arraydecay38 = getelementptr inbounds [2 x double], [2 x double]* %s2, i32 0, i32 0
  %call39 = call double @Pvalue(double* %arraydecay37, i32 2, double* %arraydecay38, i32 2)
  store double %call39, double* %pvalue, align 8
  %60 = load double, double* %pvalue, align 8
  %arrayidx40 = getelementptr inbounds [8 x double], [8 x double]* %CORRECT_ANSWERS, i32 0, i32 6
  %61 = load double, double* %arrayidx40, align 16
  %sub41 = fsub double %60, %61
  %62 = call double @llvm.fabs.f64(double %sub41)
  %63 = load double, double* %error, align 8
  %add42 = fadd double %63, %62
  store double %add42, double* %error, align 8
  %64 = load double, double* %pvalue, align 8
  %call43 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([26 x i8], [26 x i8]* @.str.8, i32 0, i32 0), double %64)
  %arraydecay44 = getelementptr inbounds [3 x double], [3 x double]* %z1, i32 0, i32 0
  %arraydecay45 = getelementptr inbounds [3 x double], [3 x double]* %z2, i32 0, i32 0
  %call46 = call double @Pvalue(double* %arraydecay44, i32 3, double* %arraydecay45, i32 3)
  store double %call46, double* %pvalue, align 8
  %65 = load double, double* %pvalue, align 8
  %arrayidx47 = getelementptr inbounds [8 x double], [8 x double]* %CORRECT_ANSWERS, i32 0, i32 7
  %66 = load double, double* %arrayidx47, align 8
  %sub48 = fsub double %65, %66
  %67 = call double @llvm.fabs.f64(double %sub48)
  %68 = load double, double* %error, align 8
  %add49 = fadd double %68, %67
  store double %add49, double* %error, align 8
  %69 = load double, double* %pvalue, align 8
  %call50 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([26 x i8], [26 x i8]* @.str.9, i32 0, i32 0), double %69)
  %70 = load double, double* %error, align 8
  %call51 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([28 x i8], [28 x i8]* @.str.10, i32 0, i32 0), double %70)
  ret i32 0
}

; Function Attrs: argmemonly nounwind willreturn
declare void @llvm.memcpy.p0i8.p0i8.i32(i8* noalias nocapture writeonly %0, i8* noalias nocapture readonly %1, i32 %2, i1 immarg %3) #5

; Function Attrs: argmemonly nounwind willreturn writeonly
declare void @llvm.memset.p0i8.i32(i8* nocapture writeonly %0, i8 %1, i32 %2, i1 immarg %3) #6

declare i32 @printf(i8* %0, ...) #2

attributes #0 = { noinline nounwind optnone "correctly-rounded-divide-sqrt-fp-math"="false" "disable-tail-calls"="false" "frame-pointer"="none" "less-precise-fpmad"="false" "min-legal-vector-width"="0" "no-infs-fp-math"="false" "no-jump-tables"="false" "no-nans-fp-math"="false" "no-signed-zeros-fp-math"="false" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="generic" "unsafe-fp-math"="false" "use-soft-float"="false" }
attributes #1 = { nounwind readnone speculatable willreturn }
attributes #2 = { "correctly-rounded-divide-sqrt-fp-math"="false" "disable-tail-calls"="false" "frame-pointer"="none" "less-precise-fpmad"="false" "no-infs-fp-math"="false" "no-nans-fp-math"="false" "no-signed-zeros-fp-math"="false" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="generic" "unsafe-fp-math"="false" "use-soft-float"="false" }
attributes #3 = { noreturn "correctly-rounded-divide-sqrt-fp-math"="false" "disable-tail-calls"="false" "frame-pointer"="none" "less-precise-fpmad"="false" "no-infs-fp-math"="false" "no-nans-fp-math"="false" "no-signed-zeros-fp-math"="false" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="generic" "unsafe-fp-math"="false" "use-soft-float"="false" }
attributes #4 = { nounwind "correctly-rounded-divide-sqrt-fp-math"="false" "disable-tail-calls"="false" "frame-pointer"="none" "less-precise-fpmad"="false" "no-infs-fp-math"="false" "no-nans-fp-math"="false" "no-signed-zeros-fp-math"="false" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="generic" "unsafe-fp-math"="false" "use-soft-float"="false" }
attributes #5 = { argmemonly nounwind willreturn }
attributes #6 = { argmemonly nounwind willreturn writeonly }
attributes #7 = { readnone }
attributes #8 = { noreturn }
attributes #9 = { nounwind }

!llvm.module.flags = !{!0}
!llvm.ident = !{!1}

!0 = !{i32 1, !"wchar_size", i32 4}
!1 = !{!"clang version 11.0.0 (https://github.com/Jacarte/llvm-project.git 0f6dea67136cc1e0b3d200eb2bb165628970c44b)"}

; Replacing "  %cmp95 = icmp ne i32 %89, 0"
; from ""
; with "  %cmpinf94 = fcmp oeq double %88, 0x7FF0000000000000" in:
"%0:i1 = var
%1:i32 = zext %0
%2:i1 = ne 0:i32, %1
cand %2 %0
"
; with "  %cmpinf94 = fcmp oeq double %88, 0x7FF0000000000000"

Module after replacement:
; ModuleID = './Welchs_t-test.c.bc'
source_filename = "./Welchs_t-test.c"
target datalayout = "e-m:e-p:32:32-i64:64-n32:64-S128"
target triple = "wasm32-unknown-wasi"

@.str = private unnamed_addr constant [63 x i8] c"Got a non-finite number in 1st array, can't calculate P-value.\00", align 1
@.str.1 = private unnamed_addr constant [63 x i8] c"Got a non-finite number in 2nd array, can't calculate P-value.\00", align 1
@__const.main.d1 = private unnamed_addr constant [15 x double] [double 2.750000e+01, double 2.100000e+01, double 1.900000e+01, double 2.360000e+01, double 1.700000e+01, double 1.790000e+01, double 1.690000e+01, double 2.010000e+01, double 2.190000e+01, double 2.260000e+01, double 2.310000e+01, double 1.960000e+01, double 1.900000e+01, double 2.170000e+01, double 2.140000e+01], align 16
@__const.main.d2 = private unnamed_addr constant [15 x double] [double 2.710000e+01, double 2.200000e+01, double 2.080000e+01, double 2.340000e+01, double 2.340000e+01, double 2.350000e+01, double 2.580000e+01, double 2.200000e+01, double 2.480000e+01, double 2.020000e+01, double 2.190000e+01, double 2.210000e+01, double 2.290000e+01, double 2.050000e+01, double 2.440000e+01], align 16
@__const.main.d3 = private unnamed_addr constant [10 x double] [double 1.720000e+01, double 2.090000e+01, double 2.260000e+01, double 1.810000e+01, double 2.170000e+01, double 2.140000e+01, double 2.350000e+01, double 2.420000e+01, double 1.470000e+01, double 2.180000e+01], align 16
@__const.main.d4 = private unnamed_addr constant [20 x double] [double 2.150000e+01, double 2.280000e+01, double 2.100000e+01, double 2.300000e+01, double 2.160000e+01, double 2.360000e+01, double 2.250000e+01, double 2.070000e+01, double 2.340000e+01, double 2.180000e+01, double 2.070000e+01, double 2.170000e+01, double 2.150000e+01, double 2.250000e+01, double 2.360000e+01, double 2.150000e+01, double 2.250000e+01, double 2.350000e+01, double 2.150000e+01, double 2.180000e+01], align 16
@__const.main.d5 = private unnamed_addr constant [10 x double] [double 1.980000e+01, double 2.040000e+01, double 1.960000e+01, double 1.780000e+01, double 1.850000e+01, double 1.890000e+01, double 1.830000e+01, double 1.890000e+01, double 1.950000e+01, double 2.200000e+01], align 16
@__const.main.d6 = private unnamed_addr constant [20 x double] [double 2.820000e+01, double 2.660000e+01, double 2.010000e+01, double 2.330000e+01, double 2.520000e+01, double 2.210000e+01, double 1.770000e+01, double 2.760000e+01, double 2.060000e+01, double 1.370000e+01, double 2.320000e+01, double 1.750000e+01, double 2.060000e+01, double 1.800000e+01, double 2.390000e+01, double 2.160000e+01, double 2.430000e+01, double 2.040000e+01, double 2.400000e+01, double 1.320000e+01], align 16
@__const.main.x = private unnamed_addr constant [4 x double] [double 3.000000e+00, double 4.000000e+00, double 1.000000e+00, double 2.100000e+00], align 16
@__const.main.y = private unnamed_addr constant [3 x double] [double 4.902000e+02, double 3.400000e+02, double 4.339000e+02], align 16
@__const.main.v1 = private unnamed_addr constant [3 x double] [double 1.026800e-02, double 1.670000e-04, double 1.670000e-04], align 16
@__const.main.v2 = private unnamed_addr constant [3 x double] [double 1.592580e-01, double 1.362780e-01, double 1.223890e-01], align 16
@__const.main.s1 = private unnamed_addr constant [2 x double] [double 0x3FB1111111111111, double 0x3FC4A5294A5294A5], align 16
@__const.main.s2 = private unnamed_addr constant [2 x double] [double 1.000000e-01, double 4.000000e-02], align 16
@__const.main.z1 = private unnamed_addr constant [3 x double] [double 0x3FD90B21642C8591, double 0x3FDDDDDDDDDDDDDE, double 0.000000e+00], align 16
@__const.main.z2 = private unnamed_addr constant [3 x double] [double 0.000000e+00, double 0x3FDC9882B9310572, double 0.000000e+00], align 16
@__const.main.CORRECT_ANSWERS = private unnamed_addr constant [8 x double] [double 0x3F95E41D648C236F, double 0x3FC30D3EA599BB79, double 0x3FA26AF51F458AEB, double 0x3FB73CEBAB27FA12, double 0x3F8604EA1C27764A, double 0x3F6BD85EAF35CBC8, double 0x3FE0DF5C6BE20DA6, double 0x3FE172D38028625E], align 16
@.str.2 = private unnamed_addr constant [26 x i8] c"Test sets 1 p-value = %g\0A\00", align 1
@.str.3 = private unnamed_addr constant [26 x i8] c"Test sets 2 p-value = %g\0A\00", align 1
@.str.4 = private unnamed_addr constant [26 x i8] c"Test sets 3 p-value = %g\0A\00", align 1
@.str.5 = private unnamed_addr constant [26 x i8] c"Test sets 4 p-value = %g\0A\00", align 1
@.str.6 = private unnamed_addr constant [26 x i8] c"Test sets 5 p-value = %g\0A\00", align 1
@.str.7 = private unnamed_addr constant [26 x i8] c"Test sets 6 p-value = %g\0A\00", align 1
@.str.8 = private unnamed_addr constant [26 x i8] c"Test sets 7 p-value = %g\0A\00", align 1
@.str.9 = private unnamed_addr constant [26 x i8] c"Test sets z p-value = %g\0A\00", align 1
@.str.10 = private unnamed_addr constant [28 x i8] c"the cumulative error is %g\0A\00", align 1
@llvm.used = appending global [1 x i8*] [i8* bitcast (i32 ()* @__main_void to i8*)], section "llvm.metadata"

@__main_void = alias i32 (), i32 ()* @main

; Function Attrs: noinline nounwind optnone
define hidden double @Pvalue(double* noalias %ARRAY1, i32 %ARRAY1_SIZE, double* noalias %ARRAY2, i32 %ARRAY2_SIZE) #0 {
entry:
  %retval = alloca double, align 8
  %ARRAY1.addr = alloca double*, align 4
  %ARRAY1_SIZE.addr = alloca i32, align 4
  %ARRAY2.addr = alloca double*, align 4
  %ARRAY2_SIZE.addr = alloca i32, align 4
  %fmean1 = alloca double, align 8
  %fmean2 = alloca double, align 8
  %x = alloca i32, align 4
  %x9 = alloca i32, align 4
  %unbiased_sample_variance1 = alloca double, align 8
  %unbiased_sample_variance2 = alloca double, align 8
  %x32 = alloca i32, align 4
  %x44 = alloca i32, align 4
  %WELCH_T_STATISTIC = alloca double, align 8
  %DEGREES_OF_FREEDOM = alloca double, align 8
  %a = alloca double, align 8
  %value = alloca double, align 8
  %beta = alloca double, align 8
  %acu = alloca double, align 8
  %ai = alloca double, align 8
  %cx = alloca double, align 8
  %indx = alloca i32, align 4
  %ns = alloca i32, align 4
  %pp = alloca double, align 8
  %psq = alloca double, align 8
  %qq = alloca double, align 8
  %rx = alloca double, align 8
  %temp = alloca double, align 8
  %term = alloca double, align 8
  %xx = alloca double, align 8
  store double* %ARRAY1, double** %ARRAY1.addr, align 4
  store i32 %ARRAY1_SIZE, i32* %ARRAY1_SIZE.addr, align 4
  store double* %ARRAY2, double** %ARRAY2.addr, align 4
  store i32 %ARRAY2_SIZE, i32* %ARRAY2_SIZE.addr, align 4
  %0 = load i32, i32* %ARRAY1_SIZE.addr, align 4
  %cmp = icmp ule i32 %0, 1
  br i1 %cmp, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  store double 1.000000e+00, double* %retval, align 8
  br label %return

if.else:                                          ; preds = %entry
  %1 = load i32, i32* %ARRAY2_SIZE.addr, align 4
  %cmp1 = icmp ule i32 %1, 1
  br i1 %cmp1, label %if.then2, label %if.end

if.then2:                                         ; preds = %if.else
  store double 1.000000e+00, double* %retval, align 8
  br label %return

if.end:                                           ; preds = %if.else
  br label %if.end3

if.end3:                                          ; preds = %if.end
  store double 0.000000e+00, double* %fmean1, align 8
  store double 0.000000e+00, double* %fmean2, align 8
  store i32 0, i32* %x, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.end3
  %2 = load i32, i32* %x, align 4
  %3 = load i32, i32* %ARRAY1_SIZE.addr, align 4
  %cmp4 = icmp ult i32 %2, %3
  br i1 %cmp4, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %4 = load double*, double** %ARRAY1.addr, align 4
  %5 = load i32, i32* %x, align 4
  %arrayidx = getelementptr inbounds double, double* %4, i32 %5
  %6 = load double, double* %arrayidx, align 8
  %7 = call double @llvm.fabs.f64(double %6) #7
  %cmpinf = fcmp one double %7, 0x7FF0000000000000
  %8 = zext i1 %cmpinf to i32
  %cmp5 = icmp eq i32 %8, 0
  br i1 %cmp5, label %if.then6, label %if.end7

if.then6:                                         ; preds = %for.body
  %call = call i32 @puts(i8* getelementptr inbounds ([63 x i8], [63 x i8]* @.str, i32 0, i32 0))
  call void @exit(i32 1) #8
  unreachable

if.end7:                                          ; preds = %for.body
  %9 = load double*, double** %ARRAY1.addr, align 4
  %10 = load i32, i32* %x, align 4
  %arrayidx8 = getelementptr inbounds double, double* %9, i32 %10
  %11 = load double, double* %arrayidx8, align 8
  %12 = load double, double* %fmean1, align 8
  %add = fadd double %12, %11
  store double %add, double* %fmean1, align 8
  br label %for.inc

for.inc:                                          ; preds = %if.end7
  %13 = load i32, i32* %x, align 4
  %inc = add i32 %13, 1
  store i32 %inc, i32* %x, align 4
  br label %for.cond

for.end:                                          ; preds = %for.cond
  %14 = load i32, i32* %ARRAY1_SIZE.addr, align 4
  %conv = uitofp i32 %14 to double
  %15 = load double, double* %fmean1, align 8
  %div = fdiv double %15, %conv
  store double %div, double* %fmean1, align 8
  store i32 0, i32* %x9, align 4
  br label %for.cond10

for.cond10:                                       ; preds = %for.inc23, %for.end
  %16 = load i32, i32* %x9, align 4
  %17 = load i32, i32* %ARRAY2_SIZE.addr, align 4
  %cmp11 = icmp ult i32 %16, %17
  br i1 %cmp11, label %for.body13, label %for.end25

for.body13:                                       ; preds = %for.cond10
  %18 = load double*, double** %ARRAY2.addr, align 4
  %19 = load i32, i32* %x9, align 4
  %arrayidx14 = getelementptr inbounds double, double* %18, i32 %19
  %20 = load double, double* %arrayidx14, align 8
  %21 = call double @llvm.fabs.f64(double %20) #7
  %cmpinf15 = fcmp one double %21, 0x7FF0000000000000
  %22 = zext i1 %cmpinf15 to i32
  %cmp16 = icmp eq i32 %22, 0
  br i1 %cmp16, label %if.then18, label %if.end20

if.then18:                                        ; preds = %for.body13
  %call19 = call i32 @puts(i8* getelementptr inbounds ([63 x i8], [63 x i8]* @.str.1, i32 0, i32 0))
  call void @exit(i32 1) #8
  unreachable

if.end20:                                         ; preds = %for.body13
  %23 = load double*, double** %ARRAY2.addr, align 4
  %24 = load i32, i32* %x9, align 4
  %arrayidx21 = getelementptr inbounds double, double* %23, i32 %24
  %25 = load double, double* %arrayidx21, align 8
  %26 = load double, double* %fmean2, align 8
  %add22 = fadd double %26, %25
  store double %add22, double* %fmean2, align 8
  br label %for.inc23

for.inc23:                                        ; preds = %if.end20
  %27 = load i32, i32* %x9, align 4
  %inc24 = add i32 %27, 1
  store i32 %inc24, i32* %x9, align 4
  br label %for.cond10

for.end25:                                        ; preds = %for.cond10
  %28 = load i32, i32* %ARRAY2_SIZE.addr, align 4
  %conv26 = uitofp i32 %28 to double
  %29 = load double, double* %fmean2, align 8
  %div27 = fdiv double %29, %conv26
  store double %div27, double* %fmean2, align 8
  %30 = load double, double* %fmean1, align 8
  %31 = load double, double* %fmean2, align 8
  %cmp28 = fcmp oeq double %30, %31
  br i1 %cmp28, label %if.then30, label %if.end31

if.then30:                                        ; preds = %for.end25
  store double 1.000000e+00, double* %retval, align 8
  br label %return

if.end31:                                         ; preds = %for.end25
  store double 0.000000e+00, double* %unbiased_sample_variance1, align 8
  store double 0.000000e+00, double* %unbiased_sample_variance2, align 8
  store i32 0, i32* %x32, align 4
  br label %for.cond33

for.cond33:                                       ; preds = %for.inc41, %if.end31
  %32 = load i32, i32* %x32, align 4
  %33 = load i32, i32* %ARRAY1_SIZE.addr, align 4
  %cmp34 = icmp ult i32 %32, %33
  br i1 %cmp34, label %for.body36, label %for.end43

for.body36:                                       ; preds = %for.cond33
  %34 = load double*, double** %ARRAY1.addr, align 4
  %35 = load i32, i32* %x32, align 4
  %arrayidx37 = getelementptr inbounds double, double* %34, i32 %35
  %36 = load double, double* %arrayidx37, align 8
  %37 = load double, double* %fmean1, align 8
  %sub = fsub double %36, %37
  %38 = load double*, double** %ARRAY1.addr, align 4
  %39 = load i32, i32* %x32, align 4
  %arrayidx38 = getelementptr inbounds double, double* %38, i32 %39
  %40 = load double, double* %arrayidx38, align 8
  %41 = load double, double* %fmean1, align 8
  %sub39 = fsub double %40, %41
  %mul = fmul double %sub, %sub39
  %42 = load double, double* %unbiased_sample_variance1, align 8
  %add40 = fadd double %42, %mul
  store double %add40, double* %unbiased_sample_variance1, align 8
  br label %for.inc41

for.inc41:                                        ; preds = %for.body36
  %43 = load i32, i32* %x32, align 4
  %inc42 = add i32 %43, 1
  store i32 %inc42, i32* %x32, align 4
  br label %for.cond33

for.end43:                                        ; preds = %for.cond33
  store i32 0, i32* %x44, align 4
  br label %for.cond45

for.cond45:                                       ; preds = %for.inc55, %for.end43
  %44 = load i32, i32* %x44, align 4
  %45 = load i32, i32* %ARRAY2_SIZE.addr, align 4
  %cmp46 = icmp ult i32 %44, %45
  br i1 %cmp46, label %for.body48, label %for.end57

for.body48:                                       ; preds = %for.cond45
  %46 = load double*, double** %ARRAY2.addr, align 4
  %47 = load i32, i32* %x44, align 4
  %arrayidx49 = getelementptr inbounds double, double* %46, i32 %47
  %48 = load double, double* %arrayidx49, align 8
  %49 = load double, double* %fmean2, align 8
  %sub50 = fsub double %48, %49
  %50 = load double*, double** %ARRAY2.addr, align 4
  %51 = load i32, i32* %x44, align 4
  %arrayidx51 = getelementptr inbounds double, double* %50, i32 %51
  %52 = load double, double* %arrayidx51, align 8
  %53 = load double, double* %fmean2, align 8
  %sub52 = fsub double %52, %53
  %mul53 = fmul double %sub50, %sub52
  %54 = load double, double* %unbiased_sample_variance2, align 8
  %add54 = fadd double %54, %mul53
  store double %add54, double* %unbiased_sample_variance2, align 8
  br label %for.inc55

for.inc55:                                        ; preds = %for.body48
  %55 = load i32, i32* %x44, align 4
  %inc56 = add i32 %55, 1
  store i32 %inc56, i32* %x44, align 4
  br label %for.cond45

for.end57:                                        ; preds = %for.cond45
  %56 = load double, double* %unbiased_sample_variance1, align 8
  %57 = load i32, i32* %ARRAY1_SIZE.addr, align 4
  %sub58 = sub i32 %57, 1
  %conv59 = uitofp i32 %sub58 to double
  %div60 = fdiv double %56, %conv59
  store double %div60, double* %unbiased_sample_variance1, align 8
  %58 = load double, double* %unbiased_sample_variance2, align 8
  %59 = load i32, i32* %ARRAY2_SIZE.addr, align 4
  %sub61 = sub i32 %59, 1
  %conv62 = uitofp i32 %sub61 to double
  %div63 = fdiv double %58, %conv62
  store double %div63, double* %unbiased_sample_variance2, align 8
  %60 = load double, double* %fmean1, align 8
  %61 = load double, double* %fmean2, align 8
  %sub64 = fsub double %60, %61
  %62 = load double, double* %unbiased_sample_variance1, align 8
  %63 = load i32, i32* %ARRAY1_SIZE.addr, align 4
  %conv65 = uitofp i32 %63 to double
  %div66 = fdiv double %62, %conv65
  %64 = load double, double* %unbiased_sample_variance2, align 8
  %65 = load i32, i32* %ARRAY2_SIZE.addr, align 4
  %conv67 = uitofp i32 %65 to double
  %div68 = fdiv double %64, %conv67
  %add69 = fadd double %div66, %div68
  %66 = call double @llvm.sqrt.f64(double %add69)
  %div70 = fdiv double %sub64, %66
  store double %div70, double* %WELCH_T_STATISTIC, align 8
  %67 = load double, double* %unbiased_sample_variance1, align 8
  %68 = load i32, i32* %ARRAY1_SIZE.addr, align 4
  %conv71 = uitofp i32 %68 to double
  %div72 = fdiv double %67, %conv71
  %69 = load double, double* %unbiased_sample_variance2, align 8
  %70 = load i32, i32* %ARRAY2_SIZE.addr, align 4
  %conv73 = uitofp i32 %70 to double
  %div74 = fdiv double %69, %conv73
  %add75 = fadd double %div72, %div74
  %71 = call double @llvm.pow.f64(double %add75, double 2.000000e+00)
  %72 = load double, double* %unbiased_sample_variance1, align 8
  %73 = load double, double* %unbiased_sample_variance1, align 8
  %mul76 = fmul double %72, %73
  %74 = load i32, i32* %ARRAY1_SIZE.addr, align 4
  %75 = load i32, i32* %ARRAY1_SIZE.addr, align 4
  %mul77 = mul i32 %74, %75
  %76 = load i32, i32* %ARRAY1_SIZE.addr, align 4
  %sub78 = sub i32 %76, 1
  %mul79 = mul i32 %mul77, %sub78
  %conv80 = uitofp i32 %mul79 to double
  %div81 = fdiv double %mul76, %conv80
  %77 = load double, double* %unbiased_sample_variance2, align 8
  %78 = load double, double* %unbiased_sample_variance2, align 8
  %mul82 = fmul double %77, %78
  %79 = load i32, i32* %ARRAY2_SIZE.addr, align 4
  %80 = load i32, i32* %ARRAY2_SIZE.addr, align 4
  %mul83 = mul i32 %79, %80
  %81 = load i32, i32* %ARRAY2_SIZE.addr, align 4
  %sub84 = sub i32 %81, 1
  %mul85 = mul i32 %mul83, %sub84
  %conv86 = uitofp i32 %mul85 to double
  %div87 = fdiv double %mul82, %conv86
  %add88 = fadd double %div81, %div87
  %div89 = fdiv double %71, %add88
  store double %div89, double* %DEGREES_OF_FREEDOM, align 8
  %82 = load double, double* %DEGREES_OF_FREEDOM, align 8
  %div90 = fdiv double %82, 2.000000e+00
  store double %div90, double* %a, align 8
  %83 = load double, double* %DEGREES_OF_FREEDOM, align 8
  %84 = load double, double* %WELCH_T_STATISTIC, align 8
  %85 = load double, double* %WELCH_T_STATISTIC, align 8
  %mul91 = fmul double %84, %85
  %86 = load double, double* %DEGREES_OF_FREEDOM, align 8
  %add92 = fadd double %mul91, %86
  %div93 = fdiv double %83, %add92
  store double %div93, double* %value, align 8
  %87 = load double, double* %value, align 8
  %88 = call double @llvm.fabs.f64(double %87) #7
  %cmpinf94 = fcmp oeq double %88, 0x7FF0000000000000
  br i1 %cmpinf94, label %if.then100, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %for.end57
  %89 = load double, double* %value, align 8
  %cmp97 = fcmp uno double %89, %89
  %90 = zext i1 %cmp97 to i32
  %cmp98 = icmp ne i32 %90, 0
  br i1 %cmp98, label %if.then100, label %if.end101

if.then100:                                       ; preds = %lor.lhs.false, %for.end57
  store double 1.000000e+00, double* %retval, align 8
  br label %return

if.end101:                                        ; preds = %lor.lhs.false
  %91 = load double, double* %value, align 8
  %92 = call double @llvm.fabs.f64(double %91) #7
  %cmpinf102 = fcmp oeq double %92, 0x7FF0000000000000
  %93 = zext i1 %cmpinf102 to i32
  %cmp103 = icmp ne i32 %93, 0
  br i1 %cmp103, label %if.then109, label %lor.lhs.false105

lor.lhs.false105:                                 ; preds = %if.end101
  %94 = load double, double* %value, align 8
  %cmp106 = fcmp uno double %94, %94
  %95 = zext i1 %cmp106 to i32
  %cmp107 = icmp ne i32 %95, 0
  br i1 %cmp107, label %if.then109, label %if.end110

if.then109:                                       ; preds = %lor.lhs.false105, %if.end101
  store double 1.000000e+00, double* %retval, align 8
  br label %return

if.end110:                                        ; preds = %lor.lhs.false105
  %96 = load double, double* %a, align 8
  %conv111 = fpext double %96 to fp128
  %call112 = call fp128 @lgammal(fp128 %conv111) #9
  %add113 = fadd fp128 %call112, 0xLD0000000000000003FFE250D048E7A1B
  %97 = load double, double* %a, align 8
  %add114 = fadd double %97, 5.000000e-01
  %conv115 = fpext double %add114 to fp128
  %call116 = call fp128 @lgammal(fp128 %conv115) #9
  %sub117 = fsub fp128 %add113, %call116
  %conv118 = fptrunc fp128 %sub117 to double
  store double %conv118, double* %beta, align 8
  store double 1.000000e-15, double* %acu, align 8
  %98 = load double, double* %a, align 8
  %cmp119 = fcmp ole double %98, 0.000000e+00
  br i1 %cmp119, label %if.then121, label %if.end122

if.then121:                                       ; preds = %if.end110
  br label %if.end122

if.end122:                                        ; preds = %if.then121, %if.end110
  %99 = load double, double* %value, align 8
  %cmp123 = fcmp olt double %99, 0.000000e+00
  br i1 %cmp123, label %if.then128, label %lor.lhs.false125

lor.lhs.false125:                                 ; preds = %if.end122
  %100 = load double, double* %value, align 8
  %cmp126 = fcmp olt double 1.000000e+00, %100
  br i1 %cmp126, label %if.then128, label %if.end129

if.then128:                                       ; preds = %lor.lhs.false125, %if.end122
  %101 = load double, double* %value, align 8
  store double %101, double* %retval, align 8
  br label %return

if.end129:                                        ; preds = %lor.lhs.false125
  %102 = load double, double* %value, align 8
  %cmp130 = fcmp oeq double %102, 0.000000e+00
  br i1 %cmp130, label %if.then135, label %lor.lhs.false132

lor.lhs.false132:                                 ; preds = %if.end129
  %103 = load double, double* %value, align 8
  %cmp133 = fcmp oeq double %103, 1.000000e+00
  br i1 %cmp133, label %if.then135, label %if.end136

if.then135:                                       ; preds = %lor.lhs.false132, %if.end129
  %104 = load double, double* %value, align 8
  store double %104, double* %retval, align 8
  br label %return

if.end136:                                        ; preds = %lor.lhs.false132
  %105 = load double, double* %a, align 8
  %add137 = fadd double %105, 5.000000e-01
  store double %add137, double* %psq, align 8
  %106 = load double, double* %value, align 8
  %sub138 = fsub double 1.000000e+00, %106
  store double %sub138, double* %cx, align 8
  %107 = load double, double* %a, align 8
  %108 = load double, double* %psq, align 8
  %109 = load double, double* %value, align 8
  %mul139 = fmul double %108, %109
  %cmp140 = fcmp olt double %107, %mul139
  br i1 %cmp140, label %if.then142, label %if.else143

if.then142:                                       ; preds = %if.end136
  %110 = load double, double* %cx, align 8
  store double %110, double* %xx, align 8
  %111 = load double, double* %value, align 8
  store double %111, double* %cx, align 8
  store double 5.000000e-01, double* %pp, align 8
  %112 = load double, double* %a, align 8
  store double %112, double* %qq, align 8
  store i32 1, i32* %indx, align 4
  br label %if.end144

if.else143:                                       ; preds = %if.end136
  %113 = load double, double* %value, align 8
  store double %113, double* %xx, align 8
  %114 = load double, double* %a, align 8
  store double %114, double* %pp, align 8
  store double 5.000000e-01, double* %qq, align 8
  store i32 0, i32* %indx, align 4
  br label %if.end144

if.end144:                                        ; preds = %if.else143, %if.then142
  store double 1.000000e+00, double* %term, align 8
  store double 1.000000e+00, double* %ai, align 8
  store double 1.000000e+00, double* %value, align 8
  %115 = load double, double* %qq, align 8
  %116 = load double, double* %cx, align 8
  %117 = load double, double* %psq, align 8
  %mul145 = fmul double %116, %117
  %add146 = fadd double %115, %mul145
  %conv147 = fptosi double %add146 to i32
  store i32 %conv147, i32* %ns, align 4
  %118 = load double, double* %xx, align 8
  %119 = load double, double* %cx, align 8
  %div148 = fdiv double %118, %119
  store double %div148, double* %rx, align 8
  %120 = load double, double* %qq, align 8
  %121 = load double, double* %ai, align 8
  %sub149 = fsub double %120, %121
  store double %sub149, double* %temp, align 8
  %122 = load i32, i32* %ns, align 4
  %cmp150 = icmp eq i32 %122, 0
  br i1 %cmp150, label %if.then152, label %if.end153

if.then152:                                       ; preds = %if.end144
  %123 = load double, double* %xx, align 8
  store double %123, double* %rx, align 8
  br label %if.end153

if.end153:                                        ; preds = %if.then152, %if.end144
  br label %for.cond154

for.cond154:                                      ; preds = %if.end189, %if.end153
  %124 = load double, double* %term, align 8
  %125 = load double, double* %temp, align 8
  %mul155 = fmul double %124, %125
  %126 = load double, double* %rx, align 8
  %mul156 = fmul double %mul155, %126
  %127 = load double, double* %pp, align 8
  %128 = load double, double* %ai, align 8
  %add157 = fadd double %127, %128
  %div158 = fdiv double %mul156, %add157
  store double %div158, double* %term, align 8
  %129 = load double, double* %value, align 8
  %130 = load double, double* %term, align 8
  %add159 = fadd double %129, %130
  store double %add159, double* %value, align 8
  %131 = load double, double* %term, align 8
  %132 = call double @llvm.fabs.f64(double %131)
  store double %132, double* %temp, align 8
  %133 = load double, double* %temp, align 8
  %cmp160 = fcmp ole double %133, 1.000000e-15
  br i1 %cmp160, label %land.lhs.true, label %if.end176

land.lhs.true:                                    ; preds = %for.cond154
  %134 = load double, double* %temp, align 8
  %135 = load double, double* %value, align 8
  %mul162 = fmul double 1.000000e-15, %135
  %cmp163 = fcmp ole double %134, %mul162
  br i1 %cmp163, label %if.then165, label %if.end176

if.then165:                                       ; preds = %land.lhs.true
  %136 = load double, double* %value, align 8
  %137 = load double, double* %pp, align 8
  %138 = load double, double* %xx, align 8
  %139 = call double @llvm.log.f64(double %138)
  %mul166 = fmul double %137, %139
  %140 = load double, double* %qq, align 8
  %sub167 = fsub double %140, 1.000000e+00
  %141 = load double, double* %cx, align 8
  %142 = call double @llvm.log.f64(double %141)
  %mul168 = fmul double %sub167, %142
  %add169 = fadd double %mul166, %mul168
  %143 = load double, double* %beta, align 8
  %sub170 = fsub double %add169, %143
  %144 = call double @llvm.exp.f64(double %sub170)
  %mul171 = fmul double %136, %144
  %145 = load double, double* %pp, align 8
  %div172 = fdiv double %mul171, %145
  store double %div172, double* %value, align 8
  %146 = load i32, i32* %indx, align 4
  %tobool = icmp ne i32 %146, 0
  br i1 %tobool, label %if.then173, label %if.end175

if.then173:                                       ; preds = %if.then165
  %147 = load double, double* %value, align 8
  %sub174 = fsub double 1.000000e+00, %147
  store double %sub174, double* %value, align 8
  br label %if.end175

if.end175:                                        ; preds = %if.then173, %if.then165
  br label %for.end190

if.end176:                                        ; preds = %land.lhs.true, %for.cond154
  %148 = load double, double* %ai, align 8
  %add177 = fadd double %148, 1.000000e+00
  store double %add177, double* %ai, align 8
  %149 = load i32, i32* %ns, align 4
  %sub178 = sub nsw i32 %149, 1
  store i32 %sub178, i32* %ns, align 4
  %150 = load i32, i32* %ns, align 4
  %cmp179 = icmp sle i32 0, %150
  br i1 %cmp179, label %if.then181, label %if.else187

if.then181:                                       ; preds = %if.end176
  %151 = load double, double* %qq, align 8
  %152 = load double, double* %ai, align 8
  %sub182 = fsub double %151, %152
  store double %sub182, double* %temp, align 8
  %153 = load i32, i32* %ns, align 4
  %cmp183 = icmp eq i32 %153, 0
  br i1 %cmp183, label %if.then185, label %if.end186

if.then185:                                       ; preds = %if.then181
  %154 = load double, double* %xx, align 8
  store double %154, double* %rx, align 8
  br label %if.end186

if.end186:                                        ; preds = %if.then185, %if.then181
  br label %if.end189

if.else187:                                       ; preds = %if.end176
  %155 = load double, double* %psq, align 8
  store double %155, double* %temp, align 8
  %156 = load double, double* %psq, align 8
  %add188 = fadd double %156, 1.000000e+00
  store double %add188, double* %psq, align 8
  br label %if.end189

if.end189:                                        ; preds = %if.else187, %if.end186
  br label %for.cond154

for.end190:                                       ; preds = %if.end175
  %157 = load double, double* %value, align 8
  store double %157, double* %retval, align 8
  br label %return

return:                                           ; preds = %for.end190, %if.then135, %if.then128, %if.then109, %if.then100, %if.then30, %if.then2, %if.then
  %158 = load double, double* %retval, align 8
  ret double %158
}

; Function Attrs: nounwind readnone speculatable willreturn
declare double @llvm.fabs.f64(double %0) #1

declare i32 @puts(i8* %0) #2

; Function Attrs: noreturn
declare void @exit(i32 %0) #3

; Function Attrs: nounwind readnone speculatable willreturn
declare double @llvm.sqrt.f64(double %0) #1

; Function Attrs: nounwind readnone speculatable willreturn
declare double @llvm.pow.f64(double %0, double %1) #1

; Function Attrs: nounwind
declare fp128 @lgammal(fp128 %0) #4

; Function Attrs: nounwind readnone speculatable willreturn
declare double @llvm.log.f64(double %0) #1

; Function Attrs: nounwind readnone speculatable willreturn
declare double @llvm.exp.f64(double %0) #1

; Function Attrs: noinline nounwind optnone
define hidden i32 @main() #0 {
entry:
  %retval = alloca i32, align 4
  %d1 = alloca [15 x double], align 16
  %d2 = alloca [15 x double], align 16
  %d3 = alloca [10 x double], align 16
  %d4 = alloca [20 x double], align 16
  %d5 = alloca [10 x double], align 16
  %d6 = alloca [20 x double], align 16
  %d7 = alloca [6 x double], align 16
  %d8 = alloca [6 x double], align 16
  %x = alloca [4 x double], align 16
  %y = alloca [3 x double], align 16
  %v1 = alloca [3 x double], align 16
  %v2 = alloca [3 x double], align 16
  %s1 = alloca [2 x double], align 16
  %s2 = alloca [2 x double], align 16
  %z1 = alloca [3 x double], align 16
  %z2 = alloca [3 x double], align 16
  %CORRECT_ANSWERS = alloca [8 x double], align 16
  %pvalue = alloca double, align 8
  %error = alloca double, align 8
  store i32 0, i32* %retval, align 4
  %0 = bitcast [15 x double]* %d1 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 16 %0, i8* align 16 bitcast ([15 x double]* @__const.main.d1 to i8*), i32 120, i1 false)
  %1 = bitcast [15 x double]* %d2 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 16 %1, i8* align 16 bitcast ([15 x double]* @__const.main.d2 to i8*), i32 120, i1 false)
  %2 = bitcast [10 x double]* %d3 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 16 %2, i8* align 16 bitcast ([10 x double]* @__const.main.d3 to i8*), i32 80, i1 false)
  %3 = bitcast [20 x double]* %d4 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 16 %3, i8* align 16 bitcast ([20 x double]* @__const.main.d4 to i8*), i32 160, i1 false)
  %4 = bitcast [10 x double]* %d5 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 16 %4, i8* align 16 bitcast ([10 x double]* @__const.main.d5 to i8*), i32 80, i1 false)
  %5 = bitcast [20 x double]* %d6 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 16 %5, i8* align 16 bitcast ([20 x double]* @__const.main.d6 to i8*), i32 160, i1 false)
  %6 = bitcast [6 x double]* %d7 to i8*
  call void @llvm.memset.p0i8.i32(i8* align 16 %6, i8 0, i32 48, i1 false)
  %7 = bitcast i8* %6 to [6 x double]*
  %8 = getelementptr inbounds [6 x double], [6 x double]* %7, i32 0, i32 0
  store double 3.002000e+01, double* %8, align 16
  %9 = getelementptr inbounds [6 x double], [6 x double]* %7, i32 0, i32 1
  store double 2.999000e+01, double* %9, align 8
  %10 = getelementptr inbounds [6 x double], [6 x double]* %7, i32 0, i32 2
  store double 3.011000e+01, double* %10, align 16
  %11 = getelementptr inbounds [6 x double], [6 x double]* %7, i32 0, i32 3
  store double 2.997000e+01, double* %11, align 8
  %12 = getelementptr inbounds [6 x double], [6 x double]* %7, i32 0, i32 4
  store double 3.001000e+01, double* %12, align 16
  %13 = getelementptr inbounds [6 x double], [6 x double]* %7, i32 0, i32 5
  store double 2.999000e+01, double* %13, align 8
  %14 = bitcast [6 x double]* %d8 to i8*
  call void @llvm.memset.p0i8.i32(i8* align 16 %14, i8 0, i32 48, i1 false)
  %15 = bitcast i8* %14 to [6 x double]*
  %16 = getelementptr inbounds [6 x double], [6 x double]* %15, i32 0, i32 0
  store double 2.989000e+01, double* %16, align 16
  %17 = getelementptr inbounds [6 x double], [6 x double]* %15, i32 0, i32 1
  store double 2.993000e+01, double* %17, align 8
  %18 = getelementptr inbounds [6 x double], [6 x double]* %15, i32 0, i32 2
  store double 2.972000e+01, double* %18, align 16
  %19 = getelementptr inbounds [6 x double], [6 x double]* %15, i32 0, i32 3
  store double 2.998000e+01, double* %19, align 8
  %20 = getelementptr inbounds [6 x double], [6 x double]* %15, i32 0, i32 4
  store double 3.002000e+01, double* %20, align 16
  %21 = getelementptr inbounds [6 x double], [6 x double]* %15, i32 0, i32 5
  store double 2.998000e+01, double* %21, align 8
  %22 = bitcast [4 x double]* %x to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 16 %22, i8* align 16 bitcast ([4 x double]* @__const.main.x to i8*), i32 32, i1 false)
  %23 = bitcast [3 x double]* %y to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 16 %23, i8* align 16 bitcast ([3 x double]* @__const.main.y to i8*), i32 24, i1 false)
  %24 = bitcast [3 x double]* %v1 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 16 %24, i8* align 16 bitcast ([3 x double]* @__const.main.v1 to i8*), i32 24, i1 false)
  %25 = bitcast [3 x double]* %v2 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 16 %25, i8* align 16 bitcast ([3 x double]* @__const.main.v2 to i8*), i32 24, i1 false)
  %26 = bitcast [2 x double]* %s1 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 16 %26, i8* align 16 bitcast ([2 x double]* @__const.main.s1 to i8*), i32 16, i1 false)
  %27 = bitcast [2 x double]* %s2 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 16 %27, i8* align 16 bitcast ([2 x double]* @__const.main.s2 to i8*), i32 16, i1 false)
  %28 = bitcast [3 x double]* %z1 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 16 %28, i8* align 16 bitcast ([3 x double]* @__const.main.z1 to i8*), i32 24, i1 false)
  %29 = bitcast [3 x double]* %z2 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 16 %29, i8* align 16 bitcast ([3 x double]* @__const.main.z2 to i8*), i32 24, i1 false)
  %30 = bitcast [8 x double]* %CORRECT_ANSWERS to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 16 %30, i8* align 16 bitcast ([8 x double]* @__const.main.CORRECT_ANSWERS to i8*), i32 64, i1 false)
  %arraydecay = getelementptr inbounds [15 x double], [15 x double]* %d1, i32 0, i32 0
  %arraydecay1 = getelementptr inbounds [15 x double], [15 x double]* %d2, i32 0, i32 0
  %call = call double @Pvalue(double* %arraydecay, i32 15, double* %arraydecay1, i32 15)
  store double %call, double* %pvalue, align 8
  %31 = load double, double* %pvalue, align 8
  %arrayidx = getelementptr inbounds [8 x double], [8 x double]* %CORRECT_ANSWERS, i32 0, i32 0
  %32 = load double, double* %arrayidx, align 16
  %sub = fsub double %31, %32
  %33 = call double @llvm.fabs.f64(double %sub)
  store double %33, double* %error, align 8
  %34 = load double, double* %pvalue, align 8
  %call2 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([26 x i8], [26 x i8]* @.str.2, i32 0, i32 0), double %34)
  %arraydecay3 = getelementptr inbounds [10 x double], [10 x double]* %d3, i32 0, i32 0
  %arraydecay4 = getelementptr inbounds [20 x double], [20 x double]* %d4, i32 0, i32 0
  %call5 = call double @Pvalue(double* %arraydecay3, i32 10, double* %arraydecay4, i32 20)
  store double %call5, double* %pvalue, align 8
  %35 = load double, double* %pvalue, align 8
  %arrayidx6 = getelementptr inbounds [8 x double], [8 x double]* %CORRECT_ANSWERS, i32 0, i32 1
  %36 = load double, double* %arrayidx6, align 8
  %sub7 = fsub double %35, %36
  %37 = call double @llvm.fabs.f64(double %sub7)
  %38 = load double, double* %error, align 8
  %add = fadd double %38, %37
  store double %add, double* %error, align 8
  %39 = load double, double* %pvalue, align 8
  %call8 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([26 x i8], [26 x i8]* @.str.3, i32 0, i32 0), double %39)
  %arraydecay9 = getelementptr inbounds [10 x double], [10 x double]* %d5, i32 0, i32 0
  %arraydecay10 = getelementptr inbounds [20 x double], [20 x double]* %d6, i32 0, i32 0
  %call11 = call double @Pvalue(double* %arraydecay9, i32 10, double* %arraydecay10, i32 20)
  store double %call11, double* %pvalue, align 8
  %40 = load double, double* %pvalue, align 8
  %arrayidx12 = getelementptr inbounds [8 x double], [8 x double]* %CORRECT_ANSWERS, i32 0, i32 2
  %41 = load double, double* %arrayidx12, align 16
  %sub13 = fsub double %40, %41
  %42 = call double @llvm.fabs.f64(double %sub13)
  %43 = load double, double* %error, align 8
  %add14 = fadd double %43, %42
  store double %add14, double* %error, align 8
  %44 = load double, double* %pvalue, align 8
  %call15 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([26 x i8], [26 x i8]* @.str.4, i32 0, i32 0), double %44)
  %arraydecay16 = getelementptr inbounds [6 x double], [6 x double]* %d7, i32 0, i32 0
  %arraydecay17 = getelementptr inbounds [6 x double], [6 x double]* %d8, i32 0, i32 0
  %call18 = call double @Pvalue(double* %arraydecay16, i32 6, double* %arraydecay17, i32 6)
  store double %call18, double* %pvalue, align 8
  %45 = load double, double* %pvalue, align 8
  %call19 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([26 x i8], [26 x i8]* @.str.5, i32 0, i32 0), double %45)
  %46 = load double, double* %pvalue, align 8
  %arrayidx20 = getelementptr inbounds [8 x double], [8 x double]* %CORRECT_ANSWERS, i32 0, i32 3
  %47 = load double, double* %arrayidx20, align 8
  %sub21 = fsub double %46, %47
  %48 = call double @llvm.fabs.f64(double %sub21)
  %49 = load double, double* %error, align 8
  %add22 = fadd double %49, %48
  store double %add22, double* %error, align 8
  %arraydecay23 = getelementptr inbounds [4 x double], [4 x double]* %x, i32 0, i32 0
  %arraydecay24 = getelementptr inbounds [3 x double], [3 x double]* %y, i32 0, i32 0
  %call25 = call double @Pvalue(double* %arraydecay23, i32 4, double* %arraydecay24, i32 3)
  store double %call25, double* %pvalue, align 8
  %50 = load double, double* %pvalue, align 8
  %arrayidx26 = getelementptr inbounds [8 x double], [8 x double]* %CORRECT_ANSWERS, i32 0, i32 4
  %51 = load double, double* %arrayidx26, align 16
  %sub27 = fsub double %50, %51
  %52 = call double @llvm.fabs.f64(double %sub27)
  %53 = load double, double* %error, align 8
  %add28 = fadd double %53, %52
  store double %add28, double* %error, align 8
  %54 = load double, double* %pvalue, align 8
  %call29 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([26 x i8], [26 x i8]* @.str.6, i32 0, i32 0), double %54)
  %arraydecay30 = getelementptr inbounds [3 x double], [3 x double]* %v1, i32 0, i32 0
  %arraydecay31 = getelementptr inbounds [3 x double], [3 x double]* %v2, i32 0, i32 0
  %call32 = call double @Pvalue(double* %arraydecay30, i32 3, double* %arraydecay31, i32 3)
  store double %call32, double* %pvalue, align 8
  %55 = load double, double* %pvalue, align 8
  %arrayidx33 = getelementptr inbounds [8 x double], [8 x double]* %CORRECT_ANSWERS, i32 0, i32 5
  %56 = load double, double* %arrayidx33, align 8
  %sub34 = fsub double %55, %56
  %57 = call double @llvm.fabs.f64(double %sub34)
  %58 = load double, double* %error, align 8
  %add35 = fadd double %58, %57
  store double %add35, double* %error, align 8
  %59 = load double, double* %pvalue, align 8
  %call36 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([26 x i8], [26 x i8]* @.str.7, i32 0, i32 0), double %59)
  %arraydecay37 = getelementptr inbounds [2 x double], [2 x double]* %s1, i32 0, i32 0
  %arraydecay38 = getelementptr inbounds [2 x double], [2 x double]* %s2, i32 0, i32 0
  %call39 = call double @Pvalue(double* %arraydecay37, i32 2, double* %arraydecay38, i32 2)
  store double %call39, double* %pvalue, align 8
  %60 = load double, double* %pvalue, align 8
  %arrayidx40 = getelementptr inbounds [8 x double], [8 x double]* %CORRECT_ANSWERS, i32 0, i32 6
  %61 = load double, double* %arrayidx40, align 16
  %sub41 = fsub double %60, %61
  %62 = call double @llvm.fabs.f64(double %sub41)
  %63 = load double, double* %error, align 8
  %add42 = fadd double %63, %62
  store double %add42, double* %error, align 8
  %64 = load double, double* %pvalue, align 8
  %call43 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([26 x i8], [26 x i8]* @.str.8, i32 0, i32 0), double %64)
  %arraydecay44 = getelementptr inbounds [3 x double], [3 x double]* %z1, i32 0, i32 0
  %arraydecay45 = getelementptr inbounds [3 x double], [3 x double]* %z2, i32 0, i32 0
  %call46 = call double @Pvalue(double* %arraydecay44, i32 3, double* %arraydecay45, i32 3)
  store double %call46, double* %pvalue, align 8
  %65 = load double, double* %pvalue, align 8
  %arrayidx47 = getelementptr inbounds [8 x double], [8 x double]* %CORRECT_ANSWERS, i32 0, i32 7
  %66 = load double, double* %arrayidx47, align 8
  %sub48 = fsub double %65, %66
  %67 = call double @llvm.fabs.f64(double %sub48)
  %68 = load double, double* %error, align 8
  %add49 = fadd double %68, %67
  store double %add49, double* %error, align 8
  %69 = load double, double* %pvalue, align 8
  %call50 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([26 x i8], [26 x i8]* @.str.9, i32 0, i32 0), double %69)
  %70 = load double, double* %error, align 8
  %call51 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([28 x i8], [28 x i8]* @.str.10, i32 0, i32 0), double %70)
  ret i32 0
}

; Function Attrs: argmemonly nounwind willreturn
declare void @llvm.memcpy.p0i8.p0i8.i32(i8* noalias nocapture writeonly %0, i8* noalias nocapture readonly %1, i32 %2, i1 immarg %3) #5

; Function Attrs: argmemonly nounwind willreturn writeonly
declare void @llvm.memset.p0i8.i32(i8* nocapture writeonly %0, i8 %1, i32 %2, i1 immarg %3) #6

declare i32 @printf(i8* %0, ...) #2

attributes #0 = { noinline nounwind optnone "correctly-rounded-divide-sqrt-fp-math"="false" "disable-tail-calls"="false" "frame-pointer"="none" "less-precise-fpmad"="false" "min-legal-vector-width"="0" "no-infs-fp-math"="false" "no-jump-tables"="false" "no-nans-fp-math"="false" "no-signed-zeros-fp-math"="false" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="generic" "unsafe-fp-math"="false" "use-soft-float"="false" }
attributes #1 = { nounwind readnone speculatable willreturn }
attributes #2 = { "correctly-rounded-divide-sqrt-fp-math"="false" "disable-tail-calls"="false" "frame-pointer"="none" "less-precise-fpmad"="false" "no-infs-fp-math"="false" "no-nans-fp-math"="false" "no-signed-zeros-fp-math"="false" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="generic" "unsafe-fp-math"="false" "use-soft-float"="false" }
attributes #3 = { noreturn "correctly-rounded-divide-sqrt-fp-math"="false" "disable-tail-calls"="false" "frame-pointer"="none" "less-precise-fpmad"="false" "no-infs-fp-math"="false" "no-nans-fp-math"="false" "no-signed-zeros-fp-math"="false" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="generic" "unsafe-fp-math"="false" "use-soft-float"="false" }
attributes #4 = { nounwind "correctly-rounded-divide-sqrt-fp-math"="false" "disable-tail-calls"="false" "frame-pointer"="none" "less-precise-fpmad"="false" "no-infs-fp-math"="false" "no-nans-fp-math"="false" "no-signed-zeros-fp-math"="false" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="generic" "unsafe-fp-math"="false" "use-soft-float"="false" }
attributes #5 = { argmemonly nounwind willreturn }
attributes #6 = { argmemonly nounwind willreturn writeonly }
attributes #7 = { readnone }
attributes #8 = { noreturn }
attributes #9 = { nounwind }

!llvm.module.flags = !{!0}
!llvm.ident = !{!1}

!0 = !{i32 1, !"wchar_size", i32 4}
!1 = !{!"clang version 11.0.0 (https://github.com/Jacarte/llvm-project.git 0f6dea67136cc1e0b3d200eb2bb165628970c44b)"}

#########################################################
; exiting Souper's runOnFunction() for Pvalue()
rescanning function after transformation was applied

; entering Souper's runOnFunction() for Pvalue()

; ModuleID = './Welchs_t-test.c.bc'
source_filename = "./Welchs_t-test.c"
target datalayout = "e-m:e-p:32:32-i64:64-n32:64-S128"
target triple = "wasm32-unknown-wasi"

@.str = private unnamed_addr constant [63 x i8] c"Got a non-finite number in 1st array, can't calculate P-value.\00", align 1
@.str.1 = private unnamed_addr constant [63 x i8] c"Got a non-finite number in 2nd array, can't calculate P-value.\00", align 1
@__const.main.d1 = private unnamed_addr constant [15 x double] [double 2.750000e+01, double 2.100000e+01, double 1.900000e+01, double 2.360000e+01, double 1.700000e+01, double 1.790000e+01, double 1.690000e+01, double 2.010000e+01, double 2.190000e+01, double 2.260000e+01, double 2.310000e+01, double 1.960000e+01, double 1.900000e+01, double 2.170000e+01, double 2.140000e+01], align 16
@__const.main.d2 = private unnamed_addr constant [15 x double] [double 2.710000e+01, double 2.200000e+01, double 2.080000e+01, double 2.340000e+01, double 2.340000e+01, double 2.350000e+01, double 2.580000e+01, double 2.200000e+01, double 2.480000e+01, double 2.020000e+01, double 2.190000e+01, double 2.210000e+01, double 2.290000e+01, double 2.050000e+01, double 2.440000e+01], align 16
@__const.main.d3 = private unnamed_addr constant [10 x double] [double 1.720000e+01, double 2.090000e+01, double 2.260000e+01, double 1.810000e+01, double 2.170000e+01, double 2.140000e+01, double 2.350000e+01, double 2.420000e+01, double 1.470000e+01, double 2.180000e+01], align 16
@__const.main.d4 = private unnamed_addr constant [20 x double] [double 2.150000e+01, double 2.280000e+01, double 2.100000e+01, double 2.300000e+01, double 2.160000e+01, double 2.360000e+01, double 2.250000e+01, double 2.070000e+01, double 2.340000e+01, double 2.180000e+01, double 2.070000e+01, double 2.170000e+01, double 2.150000e+01, double 2.250000e+01, double 2.360000e+01, double 2.150000e+01, double 2.250000e+01, double 2.350000e+01, double 2.150000e+01, double 2.180000e+01], align 16
@__const.main.d5 = private unnamed_addr constant [10 x double] [double 1.980000e+01, double 2.040000e+01, double 1.960000e+01, double 1.780000e+01, double 1.850000e+01, double 1.890000e+01, double 1.830000e+01, double 1.890000e+01, double 1.950000e+01, double 2.200000e+01], align 16
@__const.main.d6 = private unnamed_addr constant [20 x double] [double 2.820000e+01, double 2.660000e+01, double 2.010000e+01, double 2.330000e+01, double 2.520000e+01, double 2.210000e+01, double 1.770000e+01, double 2.760000e+01, double 2.060000e+01, double 1.370000e+01, double 2.320000e+01, double 1.750000e+01, double 2.060000e+01, double 1.800000e+01, double 2.390000e+01, double 2.160000e+01, double 2.430000e+01, double 2.040000e+01, double 2.400000e+01, double 1.320000e+01], align 16
@__const.main.x = private unnamed_addr constant [4 x double] [double 3.000000e+00, double 4.000000e+00, double 1.000000e+00, double 2.100000e+00], align 16
@__const.main.y = private unnamed_addr constant [3 x double] [double 4.902000e+02, double 3.400000e+02, double 4.339000e+02], align 16
@__const.main.v1 = private unnamed_addr constant [3 x double] [double 1.026800e-02, double 1.670000e-04, double 1.670000e-04], align 16
@__const.main.v2 = private unnamed_addr constant [3 x double] [double 1.592580e-01, double 1.362780e-01, double 1.223890e-01], align 16
@__const.main.s1 = private unnamed_addr constant [2 x double] [double 0x3FB1111111111111, double 0x3FC4A5294A5294A5], align 16
@__const.main.s2 = private unnamed_addr constant [2 x double] [double 1.000000e-01, double 4.000000e-02], align 16
@__const.main.z1 = private unnamed_addr constant [3 x double] [double 0x3FD90B21642C8591, double 0x3FDDDDDDDDDDDDDE, double 0.000000e+00], align 16
@__const.main.z2 = private unnamed_addr constant [3 x double] [double 0.000000e+00, double 0x3FDC9882B9310572, double 0.000000e+00], align 16
@__const.main.CORRECT_ANSWERS = private unnamed_addr constant [8 x double] [double 0x3F95E41D648C236F, double 0x3FC30D3EA599BB79, double 0x3FA26AF51F458AEB, double 0x3FB73CEBAB27FA12, double 0x3F8604EA1C27764A, double 0x3F6BD85EAF35CBC8, double 0x3FE0DF5C6BE20DA6, double 0x3FE172D38028625E], align 16
@.str.2 = private unnamed_addr constant [26 x i8] c"Test sets 1 p-value = %g\0A\00", align 1
@.str.3 = private unnamed_addr constant [26 x i8] c"Test sets 2 p-value = %g\0A\00", align 1
@.str.4 = private unnamed_addr constant [26 x i8] c"Test sets 3 p-value = %g\0A\00", align 1
@.str.5 = private unnamed_addr constant [26 x i8] c"Test sets 4 p-value = %g\0A\00", align 1
@.str.6 = private unnamed_addr constant [26 x i8] c"Test sets 5 p-value = %g\0A\00", align 1
@.str.7 = private unnamed_addr constant [26 x i8] c"Test sets 6 p-value = %g\0A\00", align 1
@.str.8 = private unnamed_addr constant [26 x i8] c"Test sets 7 p-value = %g\0A\00", align 1
@.str.9 = private unnamed_addr constant [26 x i8] c"Test sets z p-value = %g\0A\00", align 1
@.str.10 = private unnamed_addr constant [28 x i8] c"the cumulative error is %g\0A\00", align 1
@llvm.used = appending global [1 x i8*] [i8* bitcast (i32 ()* @__main_void to i8*)], section "llvm.metadata"

@__main_void = alias i32 (), i32 ()* @main

; Function Attrs: noinline nounwind optnone
define hidden double @Pvalue(double* noalias %ARRAY1, i32 %ARRAY1_SIZE, double* noalias %ARRAY2, i32 %ARRAY2_SIZE) #0 {
entry:
  %retval = alloca double, align 8
  %ARRAY1.addr = alloca double*, align 4
  %ARRAY1_SIZE.addr = alloca i32, align 4
  %ARRAY2.addr = alloca double*, align 4
  %ARRAY2_SIZE.addr = alloca i32, align 4
  %fmean1 = alloca double, align 8
  %fmean2 = alloca double, align 8
  %x = alloca i32, align 4
  %x9 = alloca i32, align 4
  %unbiased_sample_variance1 = alloca double, align 8
  %unbiased_sample_variance2 = alloca double, align 8
  %x32 = alloca i32, align 4
  %x44 = alloca i32, align 4
  %WELCH_T_STATISTIC = alloca double, align 8
  %DEGREES_OF_FREEDOM = alloca double, align 8
  %a = alloca double, align 8
  %value = alloca double, align 8
  %beta = alloca double, align 8
  %acu = alloca double, align 8
  %ai = alloca double, align 8
  %cx = alloca double, align 8
  %indx = alloca i32, align 4
  %ns = alloca i32, align 4
  %pp = alloca double, align 8
  %psq = alloca double, align 8
  %qq = alloca double, align 8
  %rx = alloca double, align 8
  %temp = alloca double, align 8
  %term = alloca double, align 8
  %xx = alloca double, align 8
  store double* %ARRAY1, double** %ARRAY1.addr, align 4
  store i32 %ARRAY1_SIZE, i32* %ARRAY1_SIZE.addr, align 4
  store double* %ARRAY2, double** %ARRAY2.addr, align 4
  store i32 %ARRAY2_SIZE, i32* %ARRAY2_SIZE.addr, align 4
  %0 = load i32, i32* %ARRAY1_SIZE.addr, align 4
  %cmp = icmp ule i32 %0, 1
  br i1 %cmp, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  store double 1.000000e+00, double* %retval, align 8
  br label %return

if.else:                                          ; preds = %entry
  %1 = load i32, i32* %ARRAY2_SIZE.addr, align 4
  %cmp1 = icmp ule i32 %1, 1
  br i1 %cmp1, label %if.then2, label %if.end

if.then2:                                         ; preds = %if.else
  store double 1.000000e+00, double* %retval, align 8
  br label %return

if.end:                                           ; preds = %if.else
  br label %if.end3

if.end3:                                          ; preds = %if.end
  store double 0.000000e+00, double* %fmean1, align 8
  store double 0.000000e+00, double* %fmean2, align 8
  store i32 0, i32* %x, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.end3
  %2 = load i32, i32* %x, align 4
  %3 = load i32, i32* %ARRAY1_SIZE.addr, align 4
  %cmp4 = icmp ult i32 %2, %3
  br i1 %cmp4, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %4 = load double*, double** %ARRAY1.addr, align 4
  %5 = load i32, i32* %x, align 4
  %arrayidx = getelementptr inbounds double, double* %4, i32 %5
  %6 = load double, double* %arrayidx, align 8
  %7 = call double @llvm.fabs.f64(double %6) #7
  %cmpinf = fcmp one double %7, 0x7FF0000000000000
  %8 = zext i1 %cmpinf to i32
  %cmp5 = icmp eq i32 %8, 0
  br i1 %cmp5, label %if.then6, label %if.end7

if.then6:                                         ; preds = %for.body
  %call = call i32 @puts(i8* getelementptr inbounds ([63 x i8], [63 x i8]* @.str, i32 0, i32 0))
  call void @exit(i32 1) #8
  unreachable

if.end7:                                          ; preds = %for.body
  %9 = load double*, double** %ARRAY1.addr, align 4
  %10 = load i32, i32* %x, align 4
  %arrayidx8 = getelementptr inbounds double, double* %9, i32 %10
  %11 = load double, double* %arrayidx8, align 8
  %12 = load double, double* %fmean1, align 8
  %add = fadd double %12, %11
  store double %add, double* %fmean1, align 8
  br label %for.inc

for.inc:                                          ; preds = %if.end7
  %13 = load i32, i32* %x, align 4
  %inc = add i32 %13, 1
  store i32 %inc, i32* %x, align 4
  br label %for.cond

for.end:                                          ; preds = %for.cond
  %14 = load i32, i32* %ARRAY1_SIZE.addr, align 4
  %conv = uitofp i32 %14 to double
  %15 = load double, double* %fmean1, align 8
  %div = fdiv double %15, %conv
  store double %div, double* %fmean1, align 8
  store i32 0, i32* %x9, align 4
  br label %for.cond10

for.cond10:                                       ; preds = %for.inc23, %for.end
  %16 = load i32, i32* %x9, align 4
  %17 = load i32, i32* %ARRAY2_SIZE.addr, align 4
  %cmp11 = icmp ult i32 %16, %17
  br i1 %cmp11, label %for.body13, label %for.end25

for.body13:                                       ; preds = %for.cond10
  %18 = load double*, double** %ARRAY2.addr, align 4
  %19 = load i32, i32* %x9, align 4
  %arrayidx14 = getelementptr inbounds double, double* %18, i32 %19
  %20 = load double, double* %arrayidx14, align 8
  %21 = call double @llvm.fabs.f64(double %20) #7
  %cmpinf15 = fcmp one double %21, 0x7FF0000000000000
  %22 = zext i1 %cmpinf15 to i32
  %cmp16 = icmp eq i32 %22, 0
  br i1 %cmp16, label %if.then18, label %if.end20

if.then18:                                        ; preds = %for.body13
  %call19 = call i32 @puts(i8* getelementptr inbounds ([63 x i8], [63 x i8]* @.str.1, i32 0, i32 0))
  call void @exit(i32 1) #8
  unreachable

if.end20:                                         ; preds = %for.body13
  %23 = load double*, double** %ARRAY2.addr, align 4
  %24 = load i32, i32* %x9, align 4
  %arrayidx21 = getelementptr inbounds double, double* %23, i32 %24
  %25 = load double, double* %arrayidx21, align 8
  %26 = load double, double* %fmean2, align 8
  %add22 = fadd double %26, %25
  store double %add22, double* %fmean2, align 8
  br label %for.inc23

for.inc23:                                        ; preds = %if.end20
  %27 = load i32, i32* %x9, align 4
  %inc24 = add i32 %27, 1
  store i32 %inc24, i32* %x9, align 4
  br label %for.cond10

for.end25:                                        ; preds = %for.cond10
  %28 = load i32, i32* %ARRAY2_SIZE.addr, align 4
  %conv26 = uitofp i32 %28 to double
  %29 = load double, double* %fmean2, align 8
  %div27 = fdiv double %29, %conv26
  store double %div27, double* %fmean2, align 8
  %30 = load double, double* %fmean1, align 8
  %31 = load double, double* %fmean2, align 8
  %cmp28 = fcmp oeq double %30, %31
  br i1 %cmp28, label %if.then30, label %if.end31

if.then30:                                        ; preds = %for.end25
  store double 1.000000e+00, double* %retval, align 8
  br label %return

if.end31:                                         ; preds = %for.end25
  store double 0.000000e+00, double* %unbiased_sample_variance1, align 8
  store double 0.000000e+00, double* %unbiased_sample_variance2, align 8
  store i32 0, i32* %x32, align 4
  br label %for.cond33

for.cond33:                                       ; preds = %for.inc41, %if.end31
  %32 = load i32, i32* %x32, align 4
  %33 = load i32, i32* %ARRAY1_SIZE.addr, align 4
  %cmp34 = icmp ult i32 %32, %33
  br i1 %cmp34, label %for.body36, label %for.end43

for.body36:                                       ; preds = %for.cond33
  %34 = load double*, double** %ARRAY1.addr, align 4
  %35 = load i32, i32* %x32, align 4
  %arrayidx37 = getelementptr inbounds double, double* %34, i32 %35
  %36 = load double, double* %arrayidx37, align 8
  %37 = load double, double* %fmean1, align 8
  %sub = fsub double %36, %37
  %38 = load double*, double** %ARRAY1.addr, align 4
  %39 = load i32, i32* %x32, align 4
  %arrayidx38 = getelementptr inbounds double, double* %38, i32 %39
  %40 = load double, double* %arrayidx38, align 8
  %41 = load double, double* %fmean1, align 8
  %sub39 = fsub double %40, %41
  %mul = fmul double %sub, %sub39
  %42 = load double, double* %unbiased_sample_variance1, align 8
  %add40 = fadd double %42, %mul
  store double %add40, double* %unbiased_sample_variance1, align 8
  br label %for.inc41

for.inc41:                                        ; preds = %for.body36
  %43 = load i32, i32* %x32, align 4
  %inc42 = add i32 %43, 1
  store i32 %inc42, i32* %x32, align 4
  br label %for.cond33

for.end43:                                        ; preds = %for.cond33
  store i32 0, i32* %x44, align 4
  br label %for.cond45

for.cond45:                                       ; preds = %for.inc55, %for.end43
  %44 = load i32, i32* %x44, align 4
  %45 = load i32, i32* %ARRAY2_SIZE.addr, align 4
  %cmp46 = icmp ult i32 %44, %45
  br i1 %cmp46, label %for.body48, label %for.end57

for.body48:                                       ; preds = %for.cond45
  %46 = load double*, double** %ARRAY2.addr, align 4
  %47 = load i32, i32* %x44, align 4
  %arrayidx49 = getelementptr inbounds double, double* %46, i32 %47
  %48 = load double, double* %arrayidx49, align 8
  %49 = load double, double* %fmean2, align 8
  %sub50 = fsub double %48, %49
  %50 = load double*, double** %ARRAY2.addr, align 4
  %51 = load i32, i32* %x44, align 4
  %arrayidx51 = getelementptr inbounds double, double* %50, i32 %51
  %52 = load double, double* %arrayidx51, align 8
  %53 = load double, double* %fmean2, align 8
  %sub52 = fsub double %52, %53
  %mul53 = fmul double %sub50, %sub52
  %54 = load double, double* %unbiased_sample_variance2, align 8
  %add54 = fadd double %54, %mul53
  store double %add54, double* %unbiased_sample_variance2, align 8
  br label %for.inc55

for.inc55:                                        ; preds = %for.body48
  %55 = load i32, i32* %x44, align 4
  %inc56 = add i32 %55, 1
  store i32 %inc56, i32* %x44, align 4
  br label %for.cond45

for.end57:                                        ; preds = %for.cond45
  %56 = load double, double* %unbiased_sample_variance1, align 8
  %57 = load i32, i32* %ARRAY1_SIZE.addr, align 4
  %sub58 = sub i32 %57, 1
  %conv59 = uitofp i32 %sub58 to double
  %div60 = fdiv double %56, %conv59
  store double %div60, double* %unbiased_sample_variance1, align 8
  %58 = load double, double* %unbiased_sample_variance2, align 8
  %59 = load i32, i32* %ARRAY2_SIZE.addr, align 4
  %sub61 = sub i32 %59, 1
  %conv62 = uitofp i32 %sub61 to double
  %div63 = fdiv double %58, %conv62
  store double %div63, double* %unbiased_sample_variance2, align 8
  %60 = load double, double* %fmean1, align 8
  %61 = load double, double* %fmean2, align 8
  %sub64 = fsub double %60, %61
  %62 = load double, double* %unbiased_sample_variance1, align 8
  %63 = load i32, i32* %ARRAY1_SIZE.addr, align 4
  %conv65 = uitofp i32 %63 to double
  %div66 = fdiv double %62, %conv65
  %64 = load double, double* %unbiased_sample_variance2, align 8
  %65 = load i32, i32* %ARRAY2_SIZE.addr, align 4
  %conv67 = uitofp i32 %65 to double
  %div68 = fdiv double %64, %conv67
  %add69 = fadd double %div66, %div68
  %66 = call double @llvm.sqrt.f64(double %add69)
  %div70 = fdiv double %sub64, %66
  store double %div70, double* %WELCH_T_STATISTIC, align 8
  %67 = load double, double* %unbiased_sample_variance1, align 8
  %68 = load i32, i32* %ARRAY1_SIZE.addr, align 4
  %conv71 = uitofp i32 %68 to double
  %div72 = fdiv double %67, %conv71
  %69 = load double, double* %unbiased_sample_variance2, align 8
  %70 = load i32, i32* %ARRAY2_SIZE.addr, align 4
  %conv73 = uitofp i32 %70 to double
  %div74 = fdiv double %69, %conv73
  %add75 = fadd double %div72, %div74
  %71 = call double @llvm.pow.f64(double %add75, double 2.000000e+00)
  %72 = load double, double* %unbiased_sample_variance1, align 8
  %73 = load double, double* %unbiased_sample_variance1, align 8
  %mul76 = fmul double %72, %73
  %74 = load i32, i32* %ARRAY1_SIZE.addr, align 4
  %75 = load i32, i32* %ARRAY1_SIZE.addr, align 4
  %mul77 = mul i32 %74, %75
  %76 = load i32, i32* %ARRAY1_SIZE.addr, align 4
  %sub78 = sub i32 %76, 1
  %mul79 = mul i32 %mul77, %sub78
  %conv80 = uitofp i32 %mul79 to double
  %div81 = fdiv double %mul76, %conv80
  %77 = load double, double* %unbiased_sample_variance2, align 8
  %78 = load double, double* %unbiased_sample_variance2, align 8
  %mul82 = fmul double %77, %78
  %79 = load i32, i32* %ARRAY2_SIZE.addr, align 4
  %80 = load i32, i32* %ARRAY2_SIZE.addr, align 4
  %mul83 = mul i32 %79, %80
  %81 = load i32, i32* %ARRAY2_SIZE.addr, align 4
  %sub84 = sub i32 %81, 1
  %mul85 = mul i32 %mul83, %sub84
  %conv86 = uitofp i32 %mul85 to double
  %div87 = fdiv double %mul82, %conv86
  %add88 = fadd double %div81, %div87
  %div89 = fdiv double %71, %add88
  store double %div89, double* %DEGREES_OF_FREEDOM, align 8
  %82 = load double, double* %DEGREES_OF_FREEDOM, align 8
  %div90 = fdiv double %82, 2.000000e+00
  store double %div90, double* %a, align 8
  %83 = load double, double* %DEGREES_OF_FREEDOM, align 8
  %84 = load double, double* %WELCH_T_STATISTIC, align 8
  %85 = load double, double* %WELCH_T_STATISTIC, align 8
  %mul91 = fmul double %84, %85
  %86 = load double, double* %DEGREES_OF_FREEDOM, align 8
  %add92 = fadd double %mul91, %86
  %div93 = fdiv double %83, %add92
  store double %div93, double* %value, align 8
  %87 = load double, double* %value, align 8
  %88 = call double @llvm.fabs.f64(double %87) #7
  %cmpinf94 = fcmp oeq double %88, 0x7FF0000000000000
  br i1 %cmpinf94, label %if.then100, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %for.end57
  %89 = load double, double* %value, align 8
  %cmp97 = fcmp uno double %89, %89
  %90 = zext i1 %cmp97 to i32
  %cmp98 = icmp ne i32 %90, 0
  br i1 %cmp98, label %if.then100, label %if.end101

if.then100:                                       ; preds = %lor.lhs.false, %for.end57
  store double 1.000000e+00, double* %retval, align 8
  br label %return

if.end101:                                        ; preds = %lor.lhs.false
  %91 = load double, double* %value, align 8
  %92 = call double @llvm.fabs.f64(double %91) #7
  %cmpinf102 = fcmp oeq double %92, 0x7FF0000000000000
  %93 = zext i1 %cmpinf102 to i32
  %cmp103 = icmp ne i32 %93, 0
  br i1 %cmp103, label %if.then109, label %lor.lhs.false105

lor.lhs.false105:                                 ; preds = %if.end101
  %94 = load double, double* %value, align 8
  %cmp106 = fcmp uno double %94, %94
  %95 = zext i1 %cmp106 to i32
  %cmp107 = icmp ne i32 %95, 0
  br i1 %cmp107, label %if.then109, label %if.end110

if.then109:                                       ; preds = %lor.lhs.false105, %if.end101
  store double 1.000000e+00, double* %retval, align 8
  br label %return

if.end110:                                        ; preds = %lor.lhs.false105
  %96 = load double, double* %a, align 8
  %conv111 = fpext double %96 to fp128
  %call112 = call fp128 @lgammal(fp128 %conv111) #9
  %add113 = fadd fp128 %call112, 0xLD0000000000000003FFE250D048E7A1B
  %97 = load double, double* %a, align 8
  %add114 = fadd double %97, 5.000000e-01
  %conv115 = fpext double %add114 to fp128
  %call116 = call fp128 @lgammal(fp128 %conv115) #9
  %sub117 = fsub fp128 %add113, %call116
  %conv118 = fptrunc fp128 %sub117 to double
  store double %conv118, double* %beta, align 8
  store double 1.000000e-15, double* %acu, align 8
  %98 = load double, double* %a, align 8
  %cmp119 = fcmp ole double %98, 0.000000e+00
  br i1 %cmp119, label %if.then121, label %if.end122

if.then121:                                       ; preds = %if.end110
  br label %if.end122

if.end122:                                        ; preds = %if.then121, %if.end110
  %99 = load double, double* %value, align 8
  %cmp123 = fcmp olt double %99, 0.000000e+00
  br i1 %cmp123, label %if.then128, label %lor.lhs.false125

lor.lhs.false125:                                 ; preds = %if.end122
  %100 = load double, double* %value, align 8
  %cmp126 = fcmp olt double 1.000000e+00, %100
  br i1 %cmp126, label %if.then128, label %if.end129

if.then128:                                       ; preds = %lor.lhs.false125, %if.end122
  %101 = load double, double* %value, align 8
  store double %101, double* %retval, align 8
  br label %return

if.end129:                                        ; preds = %lor.lhs.false125
  %102 = load double, double* %value, align 8
  %cmp130 = fcmp oeq double %102, 0.000000e+00
  br i1 %cmp130, label %if.then135, label %lor.lhs.false132

lor.lhs.false132:                                 ; preds = %if.end129
  %103 = load double, double* %value, align 8
  %cmp133 = fcmp oeq double %103, 1.000000e+00
  br i1 %cmp133, label %if.then135, label %if.end136

if.then135:                                       ; preds = %lor.lhs.false132, %if.end129
  %104 = load double, double* %value, align 8
  store double %104, double* %retval, align 8
  br label %return

if.end136:                                        ; preds = %lor.lhs.false132
  %105 = load double, double* %a, align 8
  %add137 = fadd double %105, 5.000000e-01
  store double %add137, double* %psq, align 8
  %106 = load double, double* %value, align 8
  %sub138 = fsub double 1.000000e+00, %106
  store double %sub138, double* %cx, align 8
  %107 = load double, double* %a, align 8
  %108 = load double, double* %psq, align 8
  %109 = load double, double* %value, align 8
  %mul139 = fmul double %108, %109
  %cmp140 = fcmp olt double %107, %mul139
  br i1 %cmp140, label %if.then142, label %if.else143

if.then142:                                       ; preds = %if.end136
  %110 = load double, double* %cx, align 8
  store double %110, double* %xx, align 8
  %111 = load double, double* %value, align 8
  store double %111, double* %cx, align 8
  store double 5.000000e-01, double* %pp, align 8
  %112 = load double, double* %a, align 8
  store double %112, double* %qq, align 8
  store i32 1, i32* %indx, align 4
  br label %if.end144

if.else143:                                       ; preds = %if.end136
  %113 = load double, double* %value, align 8
  store double %113, double* %xx, align 8
  %114 = load double, double* %a, align 8
  store double %114, double* %pp, align 8
  store double 5.000000e-01, double* %qq, align 8
  store i32 0, i32* %indx, align 4
  br label %if.end144

if.end144:                                        ; preds = %if.else143, %if.then142
  store double 1.000000e+00, double* %term, align 8
  store double 1.000000e+00, double* %ai, align 8
  store double 1.000000e+00, double* %value, align 8
  %115 = load double, double* %qq, align 8
  %116 = load double, double* %cx, align 8
  %117 = load double, double* %psq, align 8
  %mul145 = fmul double %116, %117
  %add146 = fadd double %115, %mul145
  %conv147 = fptosi double %add146 to i32
  store i32 %conv147, i32* %ns, align 4
  %118 = load double, double* %xx, align 8
  %119 = load double, double* %cx, align 8
  %div148 = fdiv double %118, %119
  store double %div148, double* %rx, align 8
  %120 = load double, double* %qq, align 8
  %121 = load double, double* %ai, align 8
  %sub149 = fsub double %120, %121
  store double %sub149, double* %temp, align 8
  %122 = load i32, i32* %ns, align 4
  %cmp150 = icmp eq i32 %122, 0
  br i1 %cmp150, label %if.then152, label %if.end153

if.then152:                                       ; preds = %if.end144
  %123 = load double, double* %xx, align 8
  store double %123, double* %rx, align 8
  br label %if.end153

if.end153:                                        ; preds = %if.then152, %if.end144
  br label %for.cond154

for.cond154:                                      ; preds = %if.end189, %if.end153
  %124 = load double, double* %term, align 8
  %125 = load double, double* %temp, align 8
  %mul155 = fmul double %124, %125
  %126 = load double, double* %rx, align 8
  %mul156 = fmul double %mul155, %126
  %127 = load double, double* %pp, align 8
  %128 = load double, double* %ai, align 8
  %add157 = fadd double %127, %128
  %div158 = fdiv double %mul156, %add157
  store double %div158, double* %term, align 8
  %129 = load double, double* %value, align 8
  %130 = load double, double* %term, align 8
  %add159 = fadd double %129, %130
  store double %add159, double* %value, align 8
  %131 = load double, double* %term, align 8
  %132 = call double @llvm.fabs.f64(double %131)
  store double %132, double* %temp, align 8
  %133 = load double, double* %temp, align 8
  %cmp160 = fcmp ole double %133, 1.000000e-15
  br i1 %cmp160, label %land.lhs.true, label %if.end176

land.lhs.true:                                    ; preds = %for.cond154
  %134 = load double, double* %temp, align 8
  %135 = load double, double* %value, align 8
  %mul162 = fmul double 1.000000e-15, %135
  %cmp163 = fcmp ole double %134, %mul162
  br i1 %cmp163, label %if.then165, label %if.end176

if.then165:                                       ; preds = %land.lhs.true
  %136 = load double, double* %value, align 8
  %137 = load double, double* %pp, align 8
  %138 = load double, double* %xx, align 8
  %139 = call double @llvm.log.f64(double %138)
  %mul166 = fmul double %137, %139
  %140 = load double, double* %qq, align 8
  %sub167 = fsub double %140, 1.000000e+00
  %141 = load double, double* %cx, align 8
  %142 = call double @llvm.log.f64(double %141)
  %mul168 = fmul double %sub167, %142
  %add169 = fadd double %mul166, %mul168
  %143 = load double, double* %beta, align 8
  %sub170 = fsub double %add169, %143
  %144 = call double @llvm.exp.f64(double %sub170)
  %mul171 = fmul double %136, %144
  %145 = load double, double* %pp, align 8
  %div172 = fdiv double %mul171, %145
  store double %div172, double* %value, align 8
  %146 = load i32, i32* %indx, align 4
  %tobool = icmp ne i32 %146, 0
  br i1 %tobool, label %if.then173, label %if.end175

if.then173:                                       ; preds = %if.then165
  %147 = load double, double* %value, align 8
  %sub174 = fsub double 1.000000e+00, %147
  store double %sub174, double* %value, align 8
  br label %if.end175

if.end175:                                        ; preds = %if.then173, %if.then165
  br label %for.end190

if.end176:                                        ; preds = %land.lhs.true, %for.cond154
  %148 = load double, double* %ai, align 8
  %add177 = fadd double %148, 1.000000e+00
  store double %add177, double* %ai, align 8
  %149 = load i32, i32* %ns, align 4
  %sub178 = sub nsw i32 %149, 1
  store i32 %sub178, i32* %ns, align 4
  %150 = load i32, i32* %ns, align 4
  %cmp179 = icmp sle i32 0, %150
  br i1 %cmp179, label %if.then181, label %if.else187

if.then181:                                       ; preds = %if.end176
  %151 = load double, double* %qq, align 8
  %152 = load double, double* %ai, align 8
  %sub182 = fsub double %151, %152
  store double %sub182, double* %temp, align 8
  %153 = load i32, i32* %ns, align 4
  %cmp183 = icmp eq i32 %153, 0
  br i1 %cmp183, label %if.then185, label %if.end186

if.then185:                                       ; preds = %if.then181
  %154 = load double, double* %xx, align 8
  store double %154, double* %rx, align 8
  br label %if.end186

if.end186:                                        ; preds = %if.then185, %if.then181
  br label %if.end189

if.else187:                                       ; preds = %if.end176
  %155 = load double, double* %psq, align 8
  store double %155, double* %temp, align 8
  %156 = load double, double* %psq, align 8
  %add188 = fadd double %156, 1.000000e+00
  store double %add188, double* %psq, align 8
  br label %if.end189

if.end189:                                        ; preds = %if.else187, %if.end186
  br label %for.cond154

for.end190:                                       ; preds = %if.end175
  %157 = load double, double* %value, align 8
  store double %157, double* %retval, align 8
  br label %return

return:                                           ; preds = %for.end190, %if.then135, %if.then128, %if.then109, %if.then100, %if.then30, %if.then2, %if.then
  %158 = load double, double* %retval, align 8
  ret double %158
}

; Function Attrs: nounwind readnone speculatable willreturn
declare double @llvm.fabs.f64(double %0) #1

declare i32 @puts(i8* %0) #2

; Function Attrs: noreturn
declare void @exit(i32 %0) #3

; Function Attrs: nounwind readnone speculatable willreturn
declare double @llvm.sqrt.f64(double %0) #1

; Function Attrs: nounwind readnone speculatable willreturn
declare double @llvm.pow.f64(double %0, double %1) #1

; Function Attrs: nounwind
declare fp128 @lgammal(fp128 %0) #4

; Function Attrs: nounwind readnone speculatable willreturn
declare double @llvm.log.f64(double %0) #1

; Function Attrs: nounwind readnone speculatable willreturn
declare double @llvm.exp.f64(double %0) #1

; Function Attrs: noinline nounwind optnone
define hidden i32 @main() #0 {
entry:
  %retval = alloca i32, align 4
  %d1 = alloca [15 x double], align 16
  %d2 = alloca [15 x double], align 16
  %d3 = alloca [10 x double], align 16
  %d4 = alloca [20 x double], align 16
  %d5 = alloca [10 x double], align 16
  %d6 = alloca [20 x double], align 16
  %d7 = alloca [6 x double], align 16
  %d8 = alloca [6 x double], align 16
  %x = alloca [4 x double], align 16
  %y = alloca [3 x double], align 16
  %v1 = alloca [3 x double], align 16
  %v2 = alloca [3 x double], align 16
  %s1 = alloca [2 x double], align 16
  %s2 = alloca [2 x double], align 16
  %z1 = alloca [3 x double], align 16
  %z2 = alloca [3 x double], align 16
  %CORRECT_ANSWERS = alloca [8 x double], align 16
  %pvalue = alloca double, align 8
  %error = alloca double, align 8
  store i32 0, i32* %retval, align 4
  %0 = bitcast [15 x double]* %d1 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 16 %0, i8* align 16 bitcast ([15 x double]* @__const.main.d1 to i8*), i32 120, i1 false)
  %1 = bitcast [15 x double]* %d2 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 16 %1, i8* align 16 bitcast ([15 x double]* @__const.main.d2 to i8*), i32 120, i1 false)
  %2 = bitcast [10 x double]* %d3 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 16 %2, i8* align 16 bitcast ([10 x double]* @__const.main.d3 to i8*), i32 80, i1 false)
  %3 = bitcast [20 x double]* %d4 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 16 %3, i8* align 16 bitcast ([20 x double]* @__const.main.d4 to i8*), i32 160, i1 false)
  %4 = bitcast [10 x double]* %d5 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 16 %4, i8* align 16 bitcast ([10 x double]* @__const.main.d5 to i8*), i32 80, i1 false)
  %5 = bitcast [20 x double]* %d6 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 16 %5, i8* align 16 bitcast ([20 x double]* @__const.main.d6 to i8*), i32 160, i1 false)
  %6 = bitcast [6 x double]* %d7 to i8*
  call void @llvm.memset.p0i8.i32(i8* align 16 %6, i8 0, i32 48, i1 false)
  %7 = bitcast i8* %6 to [6 x double]*
  %8 = getelementptr inbounds [6 x double], [6 x double]* %7, i32 0, i32 0
  store double 3.002000e+01, double* %8, align 16
  %9 = getelementptr inbounds [6 x double], [6 x double]* %7, i32 0, i32 1
  store double 2.999000e+01, double* %9, align 8
  %10 = getelementptr inbounds [6 x double], [6 x double]* %7, i32 0, i32 2
  store double 3.011000e+01, double* %10, align 16
  %11 = getelementptr inbounds [6 x double], [6 x double]* %7, i32 0, i32 3
  store double 2.997000e+01, double* %11, align 8
  %12 = getelementptr inbounds [6 x double], [6 x double]* %7, i32 0, i32 4
  store double 3.001000e+01, double* %12, align 16
  %13 = getelementptr inbounds [6 x double], [6 x double]* %7, i32 0, i32 5
  store double 2.999000e+01, double* %13, align 8
  %14 = bitcast [6 x double]* %d8 to i8*
  call void @llvm.memset.p0i8.i32(i8* align 16 %14, i8 0, i32 48, i1 false)
  %15 = bitcast i8* %14 to [6 x double]*
  %16 = getelementptr inbounds [6 x double], [6 x double]* %15, i32 0, i32 0
  store double 2.989000e+01, double* %16, align 16
  %17 = getelementptr inbounds [6 x double], [6 x double]* %15, i32 0, i32 1
  store double 2.993000e+01, double* %17, align 8
  %18 = getelementptr inbounds [6 x double], [6 x double]* %15, i32 0, i32 2
  store double 2.972000e+01, double* %18, align 16
  %19 = getelementptr inbounds [6 x double], [6 x double]* %15, i32 0, i32 3
  store double 2.998000e+01, double* %19, align 8
  %20 = getelementptr inbounds [6 x double], [6 x double]* %15, i32 0, i32 4
  store double 3.002000e+01, double* %20, align 16
  %21 = getelementptr inbounds [6 x double], [6 x double]* %15, i32 0, i32 5
  store double 2.998000e+01, double* %21, align 8
  %22 = bitcast [4 x double]* %x to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 16 %22, i8* align 16 bitcast ([4 x double]* @__const.main.x to i8*), i32 32, i1 false)
  %23 = bitcast [3 x double]* %y to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 16 %23, i8* align 16 bitcast ([3 x double]* @__const.main.y to i8*), i32 24, i1 false)
  %24 = bitcast [3 x double]* %v1 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 16 %24, i8* align 16 bitcast ([3 x double]* @__const.main.v1 to i8*), i32 24, i1 false)
  %25 = bitcast [3 x double]* %v2 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 16 %25, i8* align 16 bitcast ([3 x double]* @__const.main.v2 to i8*), i32 24, i1 false)
  %26 = bitcast [2 x double]* %s1 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 16 %26, i8* align 16 bitcast ([2 x double]* @__const.main.s1 to i8*), i32 16, i1 false)
  %27 = bitcast [2 x double]* %s2 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 16 %27, i8* align 16 bitcast ([2 x double]* @__const.main.s2 to i8*), i32 16, i1 false)
  %28 = bitcast [3 x double]* %z1 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 16 %28, i8* align 16 bitcast ([3 x double]* @__const.main.z1 to i8*), i32 24, i1 false)
  %29 = bitcast [3 x double]* %z2 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 16 %29, i8* align 16 bitcast ([3 x double]* @__const.main.z2 to i8*), i32 24, i1 false)
  %30 = bitcast [8 x double]* %CORRECT_ANSWERS to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 16 %30, i8* align 16 bitcast ([8 x double]* @__const.main.CORRECT_ANSWERS to i8*), i32 64, i1 false)
  %arraydecay = getelementptr inbounds [15 x double], [15 x double]* %d1, i32 0, i32 0
  %arraydecay1 = getelementptr inbounds [15 x double], [15 x double]* %d2, i32 0, i32 0
  %call = call double @Pvalue(double* %arraydecay, i32 15, double* %arraydecay1, i32 15)
  store double %call, double* %pvalue, align 8
  %31 = load double, double* %pvalue, align 8
  %arrayidx = getelementptr inbounds [8 x double], [8 x double]* %CORRECT_ANSWERS, i32 0, i32 0
  %32 = load double, double* %arrayidx, align 16
  %sub = fsub double %31, %32
  %33 = call double @llvm.fabs.f64(double %sub)
  store double %33, double* %error, align 8
  %34 = load double, double* %pvalue, align 8
  %call2 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([26 x i8], [26 x i8]* @.str.2, i32 0, i32 0), double %34)
  %arraydecay3 = getelementptr inbounds [10 x double], [10 x double]* %d3, i32 0, i32 0
  %arraydecay4 = getelementptr inbounds [20 x double], [20 x double]* %d4, i32 0, i32 0
  %call5 = call double @Pvalue(double* %arraydecay3, i32 10, double* %arraydecay4, i32 20)
  store double %call5, double* %pvalue, align 8
  %35 = load double, double* %pvalue, align 8
  %arrayidx6 = getelementptr inbounds [8 x double], [8 x double]* %CORRECT_ANSWERS, i32 0, i32 1
  %36 = load double, double* %arrayidx6, align 8
  %sub7 = fsub double %35, %36
  %37 = call double @llvm.fabs.f64(double %sub7)
  %38 = load double, double* %error, align 8
  %add = fadd double %38, %37
  store double %add, double* %error, align 8
  %39 = load double, double* %pvalue, align 8
  %call8 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([26 x i8], [26 x i8]* @.str.3, i32 0, i32 0), double %39)
  %arraydecay9 = getelementptr inbounds [10 x double], [10 x double]* %d5, i32 0, i32 0
  %arraydecay10 = getelementptr inbounds [20 x double], [20 x double]* %d6, i32 0, i32 0
  %call11 = call double @Pvalue(double* %arraydecay9, i32 10, double* %arraydecay10, i32 20)
  store double %call11, double* %pvalue, align 8
  %40 = load double, double* %pvalue, align 8
  %arrayidx12 = getelementptr inbounds [8 x double], [8 x double]* %CORRECT_ANSWERS, i32 0, i32 2
  %41 = load double, double* %arrayidx12, align 16
  %sub13 = fsub double %40, %41
  %42 = call double @llvm.fabs.f64(double %sub13)
  %43 = load double, double* %error, align 8
  %add14 = fadd double %43, %42
  store double %add14, double* %error, align 8
  %44 = load double, double* %pvalue, align 8
  %call15 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([26 x i8], [26 x i8]* @.str.4, i32 0, i32 0), double %44)
  %arraydecay16 = getelementptr inbounds [6 x double], [6 x double]* %d7, i32 0, i32 0
  %arraydecay17 = getelementptr inbounds [6 x double], [6 x double]* %d8, i32 0, i32 0
  %call18 = call double @Pvalue(double* %arraydecay16, i32 6, double* %arraydecay17, i32 6)
  store double %call18, double* %pvalue, align 8
  %45 = load double, double* %pvalue, align 8
  %call19 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([26 x i8], [26 x i8]* @.str.5, i32 0, i32 0), double %45)
  %46 = load double, double* %pvalue, align 8
  %arrayidx20 = getelementptr inbounds [8 x double], [8 x double]* %CORRECT_ANSWERS, i32 0, i32 3
  %47 = load double, double* %arrayidx20, align 8
  %sub21 = fsub double %46, %47
  %48 = call double @llvm.fabs.f64(double %sub21)
  %49 = load double, double* %error, align 8
  %add22 = fadd double %49, %48
  store double %add22, double* %error, align 8
  %arraydecay23 = getelementptr inbounds [4 x double], [4 x double]* %x, i32 0, i32 0
  %arraydecay24 = getelementptr inbounds [3 x double], [3 x double]* %y, i32 0, i32 0
  %call25 = call double @Pvalue(double* %arraydecay23, i32 4, double* %arraydecay24, i32 3)
  store double %call25, double* %pvalue, align 8
  %50 = load double, double* %pvalue, align 8
  %arrayidx26 = getelementptr inbounds [8 x double], [8 x double]* %CORRECT_ANSWERS, i32 0, i32 4
  %51 = load double, double* %arrayidx26, align 16
  %sub27 = fsub double %50, %51
  %52 = call double @llvm.fabs.f64(double %sub27)
  %53 = load double, double* %error, align 8
  %add28 = fadd double %53, %52
  store double %add28, double* %error, align 8
  %54 = load double, double* %pvalue, align 8
  %call29 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([26 x i8], [26 x i8]* @.str.6, i32 0, i32 0), double %54)
  %arraydecay30 = getelementptr inbounds [3 x double], [3 x double]* %v1, i32 0, i32 0
  %arraydecay31 = getelementptr inbounds [3 x double], [3 x double]* %v2, i32 0, i32 0
  %call32 = call double @Pvalue(double* %arraydecay30, i32 3, double* %arraydecay31, i32 3)
  store double %call32, double* %pvalue, align 8
  %55 = load double, double* %pvalue, align 8
  %arrayidx33 = getelementptr inbounds [8 x double], [8 x double]* %CORRECT_ANSWERS, i32 0, i32 5
  %56 = load double, double* %arrayidx33, align 8
  %sub34 = fsub double %55, %56
  %57 = call double @llvm.fabs.f64(double %sub34)
  %58 = load double, double* %error, align 8
  %add35 = fadd double %58, %57
  store double %add35, double* %error, align 8
  %59 = load double, double* %pvalue, align 8
  %call36 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([26 x i8], [26 x i8]* @.str.7, i32 0, i32 0), double %59)
  %arraydecay37 = getelementptr inbounds [2 x double], [2 x double]* %s1, i32 0, i32 0
  %arraydecay38 = getelementptr inbounds [2 x double], [2 x double]* %s2, i32 0, i32 0
  %call39 = call double @Pvalue(double* %arraydecay37, i32 2, double* %arraydecay38, i32 2)
  store double %call39, double* %pvalue, align 8
  %60 = load double, double* %pvalue, align 8
  %arrayidx40 = getelementptr inbounds [8 x double], [8 x double]* %CORRECT_ANSWERS, i32 0, i32 6
  %61 = load double, double* %arrayidx40, align 16
  %sub41 = fsub double %60, %61
  %62 = call double @llvm.fabs.f64(double %sub41)
  %63 = load double, double* %error, align 8
  %add42 = fadd double %63, %62
  store double %add42, double* %error, align 8
  %64 = load double, double* %pvalue, align 8
  %call43 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([26 x i8], [26 x i8]* @.str.8, i32 0, i32 0), double %64)
  %arraydecay44 = getelementptr inbounds [3 x double], [3 x double]* %z1, i32 0, i32 0
  %arraydecay45 = getelementptr inbounds [3 x double], [3 x double]* %z2, i32 0, i32 0
  %call46 = call double @Pvalue(double* %arraydecay44, i32 3, double* %arraydecay45, i32 3)
  store double %call46, double* %pvalue, align 8
  %65 = load double, double* %pvalue, align 8
  %arrayidx47 = getelementptr inbounds [8 x double], [8 x double]* %CORRECT_ANSWERS, i32 0, i32 7
  %66 = load double, double* %arrayidx47, align 8
  %sub48 = fsub double %65, %66
  %67 = call double @llvm.fabs.f64(double %sub48)
  %68 = load double, double* %error, align 8
  %add49 = fadd double %68, %67
  store double %add49, double* %error, align 8
  %69 = load double, double* %pvalue, align 8
  %call50 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([26 x i8], [26 x i8]* @.str.9, i32 0, i32 0), double %69)
  %70 = load double, double* %error, align 8
  %call51 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([28 x i8], [28 x i8]* @.str.10, i32 0, i32 0), double %70)
  ret i32 0
}

; Function Attrs: argmemonly nounwind willreturn
declare void @llvm.memcpy.p0i8.p0i8.i32(i8* noalias nocapture writeonly %0, i8* noalias nocapture readonly %1, i32 %2, i1 immarg %3) #5

; Function Attrs: argmemonly nounwind willreturn writeonly
declare void @llvm.memset.p0i8.i32(i8* nocapture writeonly %0, i8 %1, i32 %2, i1 immarg %3) #6

declare i32 @printf(i8* %0, ...) #2

attributes #0 = { noinline nounwind optnone "correctly-rounded-divide-sqrt-fp-math"="false" "disable-tail-calls"="false" "frame-pointer"="none" "less-precise-fpmad"="false" "min-legal-vector-width"="0" "no-infs-fp-math"="false" "no-jump-tables"="false" "no-nans-fp-math"="false" "no-signed-zeros-fp-math"="false" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="generic" "unsafe-fp-math"="false" "use-soft-float"="false" }
attributes #1 = { nounwind readnone speculatable willreturn }
attributes #2 = { "correctly-rounded-divide-sqrt-fp-math"="false" "disable-tail-calls"="false" "frame-pointer"="none" "less-precise-fpmad"="false" "no-infs-fp-math"="false" "no-nans-fp-math"="false" "no-signed-zeros-fp-math"="false" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="generic" "unsafe-fp-math"="false" "use-soft-float"="false" }
attributes #3 = { noreturn "correctly-rounded-divide-sqrt-fp-math"="false" "disable-tail-calls"="false" "frame-pointer"="none" "less-precise-fpmad"="false" "no-infs-fp-math"="false" "no-nans-fp-math"="false" "no-signed-zeros-fp-math"="false" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="generic" "unsafe-fp-math"="false" "use-soft-float"="false" }
attributes #4 = { nounwind "correctly-rounded-divide-sqrt-fp-math"="false" "disable-tail-calls"="false" "frame-pointer"="none" "less-precise-fpmad"="false" "no-infs-fp-math"="false" "no-nans-fp-math"="false" "no-signed-zeros-fp-math"="false" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="generic" "unsafe-fp-math"="false" "use-soft-float"="false" }
attributes #5 = { argmemonly nounwind willreturn }
attributes #6 = { argmemonly nounwind willreturn writeonly }
attributes #7 = { readnone }
attributes #8 = { noreturn }
attributes #9 = { nounwind }

!llvm.module.flags = !{!0}
!llvm.ident = !{!1}

!0 = !{i32 1, !"wchar_size", i32 4}
!1 = !{!"clang version 11.0.0 (https://github.com/Jacarte/llvm-project.git 0f6dea67136cc1e0b3d200eb2bb165628970c44b)"}

; extracted candidates

; *****
; For LLVM instruction:
;  %0 = load i32, i32* %ARRAY1_SIZE.addr, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %cmp = icmp ule i32 %0, 1
; Looking for a replacement for:
%0:i32 = var
%1:i1 = ule %0, 1:i32
infer %1

; *****
; For LLVM instruction:
;  %1 = load i32, i32* %ARRAY2_SIZE.addr, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %cmp1 = icmp ule i32 %1, 1
; Looking for a replacement for:
%0:i32 = var
%1:i1 = ule %0, 1:i32
infer %1

; *****
; For LLVM instruction:
;  %2 = load i32, i32* %x, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %3 = load i32, i32* %ARRAY1_SIZE.addr, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %cmp4 = icmp ult i32 %2, %3
; Looking for a replacement for:
%0:i32 = var
%1:i32 = var
%2:i1 = ult %0, %1
infer %2

; *****
; For LLVM instruction:
;  %5 = load i32, i32* %x, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %cmpinf = fcmp one double %7, 0x7FF0000000000000
; Looking for a replacement for:
%0:i1 = var
infer %0

; *****
; For LLVM instruction:
;  %8 = zext i1 %cmpinf to i32
; Looking for a replacement for:
%0:i1 = var
%1:i32 = zext %0
infer %1

; *****
; For LLVM instruction:
;  %cmp5 = icmp eq i32 %8, 0
; Looking for a replacement for:
%0:i1 = var
%1:i32 = zext %0
%2:i1 = eq 0:i32, %1
infer %2

; *****
; For LLVM instruction:
;  %10 = load i32, i32* %x, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %13 = load i32, i32* %x, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %inc = add i32 %13, 1
; Looking for a replacement for:
%0:i32 = var
%1:i32 = add 1:i32, %0
infer %1

; *****
; For LLVM instruction:
;  %14 = load i32, i32* %ARRAY1_SIZE.addr, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %16 = load i32, i32* %x9, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %17 = load i32, i32* %ARRAY2_SIZE.addr, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %cmp11 = icmp ult i32 %16, %17
; Looking for a replacement for:
%0:i32 = var
%1:i32 = var
%2:i1 = ult %0, %1
infer %2

; *****
; For LLVM instruction:
;  %19 = load i32, i32* %x9, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %cmpinf15 = fcmp one double %21, 0x7FF0000000000000
; Looking for a replacement for:
%0:i1 = var
infer %0

; *****
; For LLVM instruction:
;  %22 = zext i1 %cmpinf15 to i32
; Looking for a replacement for:
%0:i1 = var
%1:i32 = zext %0
infer %1

; *****
; For LLVM instruction:
;  %cmp16 = icmp eq i32 %22, 0
; Looking for a replacement for:
%0:i1 = var
%1:i32 = zext %0
%2:i1 = eq 0:i32, %1
infer %2

; *****
; For LLVM instruction:
;  %24 = load i32, i32* %x9, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %27 = load i32, i32* %x9, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %inc24 = add i32 %27, 1
; Looking for a replacement for:
%0:i32 = var
%1:i32 = add 1:i32, %0
infer %1

; *****
; For LLVM instruction:
;  %28 = load i32, i32* %ARRAY2_SIZE.addr, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %cmp28 = fcmp oeq double %30, %31
; Looking for a replacement for:
%0:i1 = var
infer %0

; *****
; For LLVM instruction:
;  %32 = load i32, i32* %x32, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %33 = load i32, i32* %ARRAY1_SIZE.addr, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %cmp34 = icmp ult i32 %32, %33
; Looking for a replacement for:
%0:i32 = var
%1:i32 = var
%2:i1 = ult %0, %1
infer %2

; *****
; For LLVM instruction:
;  %35 = load i32, i32* %x32, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %39 = load i32, i32* %x32, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %43 = load i32, i32* %x32, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %inc42 = add i32 %43, 1
; Looking for a replacement for:
%0:i32 = var
%1:i32 = add 1:i32, %0
infer %1

; *****
; For LLVM instruction:
;  %44 = load i32, i32* %x44, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %45 = load i32, i32* %ARRAY2_SIZE.addr, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %cmp46 = icmp ult i32 %44, %45
; Looking for a replacement for:
%0:i32 = var
%1:i32 = var
%2:i1 = ult %0, %1
infer %2

; *****
; For LLVM instruction:
;  %47 = load i32, i32* %x44, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %51 = load i32, i32* %x44, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %55 = load i32, i32* %x44, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %inc56 = add i32 %55, 1
; Looking for a replacement for:
%0:i32 = var
%1:i32 = add 1:i32, %0
infer %1

; *****
; For LLVM instruction:
;  %57 = load i32, i32* %ARRAY1_SIZE.addr, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %sub58 = sub i32 %57, 1
; Looking for a replacement for:
%0:i32 = var
%1:i32 = sub %0, 1:i32
infer %1

; *****
; For LLVM instruction:
;  %59 = load i32, i32* %ARRAY2_SIZE.addr, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %sub61 = sub i32 %59, 1
; Looking for a replacement for:
%0:i32 = var
%1:i32 = sub %0, 1:i32
infer %1

; *****
; For LLVM instruction:
;  %63 = load i32, i32* %ARRAY1_SIZE.addr, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %65 = load i32, i32* %ARRAY2_SIZE.addr, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %68 = load i32, i32* %ARRAY1_SIZE.addr, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %70 = load i32, i32* %ARRAY2_SIZE.addr, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %74 = load i32, i32* %ARRAY1_SIZE.addr, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %75 = load i32, i32* %ARRAY1_SIZE.addr, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %mul77 = mul i32 %74, %75
; Looking for a replacement for:
%0:i32 = var
%1:i32 = var
%2:i32 = mul %0, %1
infer %2

; *****
; For LLVM instruction:
;  %76 = load i32, i32* %ARRAY1_SIZE.addr, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %sub78 = sub i32 %76, 1
; Looking for a replacement for:
%0:i32 = var
%1:i32 = sub %0, 1:i32
infer %1

; *****
; For LLVM instruction:
;  %mul79 = mul i32 %mul77, %sub78
; Looking for a replacement for:
%0:i32 = var
%1:i32 = sub %0, 1:i32
%2:i32 = var
%3:i32 = var
%4:i32 = mul %2, %3
%5:i32 = mul %1, %4
infer %5

; *****
; For LLVM instruction:
;  %79 = load i32, i32* %ARRAY2_SIZE.addr, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %80 = load i32, i32* %ARRAY2_SIZE.addr, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %mul83 = mul i32 %79, %80
; Looking for a replacement for:
%0:i32 = var
%1:i32 = var
%2:i32 = mul %0, %1
infer %2

; *****
; For LLVM instruction:
;  %81 = load i32, i32* %ARRAY2_SIZE.addr, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %sub84 = sub i32 %81, 1
; Looking for a replacement for:
%0:i32 = var
%1:i32 = sub %0, 1:i32
infer %1

; *****
; For LLVM instruction:
;  %mul85 = mul i32 %mul83, %sub84
; Looking for a replacement for:
%0:i32 = var
%1:i32 = sub %0, 1:i32
%2:i32 = var
%3:i32 = var
%4:i32 = mul %2, %3
%5:i32 = mul %1, %4
infer %5

; *****
; For LLVM instruction:
;  %cmpinf94 = fcmp oeq double %88, 0x7FF0000000000000
; Looking for a replacement for:
%0:i1 = var
infer %0

; *****
; For LLVM instruction:
;  %cmp97 = fcmp uno double %89, %89
; Looking for a replacement for:
%0:i1 = var
infer %0

; *****
; For LLVM instruction:
;  %90 = zext i1 %cmp97 to i32
; Looking for a replacement for:
%0:i1 = var
%1:i32 = zext %0
infer %1

; *****
; For LLVM instruction:
;  %cmp98 = icmp ne i32 %90, 0
; Looking for a replacement for:
%0:i1 = var
%1:i32 = zext %0
%2:i1 = ne 0:i32, %1
infer %2

; *****
; For LLVM instruction:
;  %cmpinf102 = fcmp oeq double %92, 0x7FF0000000000000
; Looking for a replacement for:
%0:i1 = var
infer %0

; *****
; For LLVM instruction:
;  %93 = zext i1 %cmpinf102 to i32
; Looking for a replacement for:
%0:i1 = var
%1:i32 = zext %0
infer %1

; *****
; For LLVM instruction:
;  %cmp103 = icmp ne i32 %93, 0
; Looking for a replacement for:
%0:i1 = var
%1:i32 = zext %0
%2:i1 = ne 0:i32, %1
infer %2

; *****
; For LLVM instruction:
;  %cmp106 = fcmp uno double %94, %94
; Looking for a replacement for:
%0:i1 = var
infer %0

; *****
; For LLVM instruction:
;  %95 = zext i1 %cmp106 to i32
; Looking for a replacement for:
%0:i1 = var
%1:i32 = zext %0
infer %1

; *****
; For LLVM instruction:
;  %cmp107 = icmp ne i32 %95, 0
; Looking for a replacement for:
%0:i1 = var
%1:i32 = zext %0
%2:i1 = ne 0:i32, %1
infer %2

; *****
; For LLVM instruction:
;  %cmp119 = fcmp ole double %98, 0.000000e+00
; Looking for a replacement for:
%0:i1 = var
infer %0

; *****
; For LLVM instruction:
;  %cmp123 = fcmp olt double %99, 0.000000e+00
; Looking for a replacement for:
%0:i1 = var
infer %0

; *****
; For LLVM instruction:
;  %cmp126 = fcmp olt double 1.000000e+00, %100
; Looking for a replacement for:
%0:i1 = var
infer %0

; *****
; For LLVM instruction:
;  %cmp130 = fcmp oeq double %102, 0.000000e+00
; Looking for a replacement for:
%0:i1 = var
infer %0

; *****
; For LLVM instruction:
;  %cmp133 = fcmp oeq double %103, 1.000000e+00
; Looking for a replacement for:
%0:i1 = var
infer %0

; *****
; For LLVM instruction:
;  %cmp140 = fcmp olt double %107, %mul139
; Looking for a replacement for:
%0:i1 = var
infer %0

; *****
; For LLVM instruction:
;  %conv147 = fptosi double %add146 to i32
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %122 = load i32, i32* %ns, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %cmp150 = icmp eq i32 %122, 0
; Looking for a replacement for:
%0:i32 = var
%1:i1 = eq 0:i32, %0
infer %1

; *****
; For LLVM instruction:
;  %cmp160 = fcmp ole double %133, 1.000000e-15
; Looking for a replacement for:
%0:i1 = var
infer %0

; *****
; For LLVM instruction:
;  %cmp163 = fcmp ole double %134, %mul162
; Looking for a replacement for:
%0:i1 = var
infer %0

; *****
; For LLVM instruction:
;  %146 = load i32, i32* %indx, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %tobool = icmp ne i32 %146, 0
; Looking for a replacement for:
%0:i32 = var
%1:i1 = ne 0:i32, %0
infer %1

; *****
; For LLVM instruction:
;  %149 = load i32, i32* %ns, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %sub178 = sub nsw i32 %149, 1
; Looking for a replacement for:
%0:i32 = var
%1:i32 = subnsw %0, 1:i32
infer %1

; *****
; For LLVM instruction:
;  %150 = load i32, i32* %ns, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %cmp179 = icmp sle i32 0, %150
; Looking for a replacement for:
%0:i32 = var
%1:i1 = sle 0:i32, %0
infer %1

; *****
; For LLVM instruction:
;  %153 = load i32, i32* %ns, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %cmp183 = icmp eq i32 %153, 0
; Looking for a replacement for:
%0:i32 = var
%1:i1 = eq 0:i32, %0
infer %1
"
; No valid RHS in the list
#########################################################

Module before replacement:
; ModuleID = './Welchs_t-test.c.bc'
source_filename = "./Welchs_t-test.c"
target datalayout = "e-m:e-p:32:32-i64:64-n32:64-S128"
target triple = "wasm32-unknown-wasi"

@.str = private unnamed_addr constant [63 x i8] c"Got a non-finite number in 1st array, can't calculate P-value.\00", align 1
@.str.1 = private unnamed_addr constant [63 x i8] c"Got a non-finite number in 2nd array, can't calculate P-value.\00", align 1
@__const.main.d1 = private unnamed_addr constant [15 x double] [double 2.750000e+01, double 2.100000e+01, double 1.900000e+01, double 2.360000e+01, double 1.700000e+01, double 1.790000e+01, double 1.690000e+01, double 2.010000e+01, double 2.190000e+01, double 2.260000e+01, double 2.310000e+01, double 1.960000e+01, double 1.900000e+01, double 2.170000e+01, double 2.140000e+01], align 16
@__const.main.d2 = private unnamed_addr constant [15 x double] [double 2.710000e+01, double 2.200000e+01, double 2.080000e+01, double 2.340000e+01, double 2.340000e+01, double 2.350000e+01, double 2.580000e+01, double 2.200000e+01, double 2.480000e+01, double 2.020000e+01, double 2.190000e+01, double 2.210000e+01, double 2.290000e+01, double 2.050000e+01, double 2.440000e+01], align 16
@__const.main.d3 = private unnamed_addr constant [10 x double] [double 1.720000e+01, double 2.090000e+01, double 2.260000e+01, double 1.810000e+01, double 2.170000e+01, double 2.140000e+01, double 2.350000e+01, double 2.420000e+01, double 1.470000e+01, double 2.180000e+01], align 16
@__const.main.d4 = private unnamed_addr constant [20 x double] [double 2.150000e+01, double 2.280000e+01, double 2.100000e+01, double 2.300000e+01, double 2.160000e+01, double 2.360000e+01, double 2.250000e+01, double 2.070000e+01, double 2.340000e+01, double 2.180000e+01, double 2.070000e+01, double 2.170000e+01, double 2.150000e+01, double 2.250000e+01, double 2.360000e+01, double 2.150000e+01, double 2.250000e+01, double 2.350000e+01, double 2.150000e+01, double 2.180000e+01], align 16
@__const.main.d5 = private unnamed_addr constant [10 x double] [double 1.980000e+01, double 2.040000e+01, double 1.960000e+01, double 1.780000e+01, double 1.850000e+01, double 1.890000e+01, double 1.830000e+01, double 1.890000e+01, double 1.950000e+01, double 2.200000e+01], align 16
@__const.main.d6 = private unnamed_addr constant [20 x double] [double 2.820000e+01, double 2.660000e+01, double 2.010000e+01, double 2.330000e+01, double 2.520000e+01, double 2.210000e+01, double 1.770000e+01, double 2.760000e+01, double 2.060000e+01, double 1.370000e+01, double 2.320000e+01, double 1.750000e+01, double 2.060000e+01, double 1.800000e+01, double 2.390000e+01, double 2.160000e+01, double 2.430000e+01, double 2.040000e+01, double 2.400000e+01, double 1.320000e+01], align 16
@__const.main.x = private unnamed_addr constant [4 x double] [double 3.000000e+00, double 4.000000e+00, double 1.000000e+00, double 2.100000e+00], align 16
@__const.main.y = private unnamed_addr constant [3 x double] [double 4.902000e+02, double 3.400000e+02, double 4.339000e+02], align 16
@__const.main.v1 = private unnamed_addr constant [3 x double] [double 1.026800e-02, double 1.670000e-04, double 1.670000e-04], align 16
@__const.main.v2 = private unnamed_addr constant [3 x double] [double 1.592580e-01, double 1.362780e-01, double 1.223890e-01], align 16
@__const.main.s1 = private unnamed_addr constant [2 x double] [double 0x3FB1111111111111, double 0x3FC4A5294A5294A5], align 16
@__const.main.s2 = private unnamed_addr constant [2 x double] [double 1.000000e-01, double 4.000000e-02], align 16
@__const.main.z1 = private unnamed_addr constant [3 x double] [double 0x3FD90B21642C8591, double 0x3FDDDDDDDDDDDDDE, double 0.000000e+00], align 16
@__const.main.z2 = private unnamed_addr constant [3 x double] [double 0.000000e+00, double 0x3FDC9882B9310572, double 0.000000e+00], align 16
@__const.main.CORRECT_ANSWERS = private unnamed_addr constant [8 x double] [double 0x3F95E41D648C236F, double 0x3FC30D3EA599BB79, double 0x3FA26AF51F458AEB, double 0x3FB73CEBAB27FA12, double 0x3F8604EA1C27764A, double 0x3F6BD85EAF35CBC8, double 0x3FE0DF5C6BE20DA6, double 0x3FE172D38028625E], align 16
@.str.2 = private unnamed_addr constant [26 x i8] c"Test sets 1 p-value = %g\0A\00", align 1
@.str.3 = private unnamed_addr constant [26 x i8] c"Test sets 2 p-value = %g\0A\00", align 1
@.str.4 = private unnamed_addr constant [26 x i8] c"Test sets 3 p-value = %g\0A\00", align 1
@.str.5 = private unnamed_addr constant [26 x i8] c"Test sets 4 p-value = %g\0A\00", align 1
@.str.6 = private unnamed_addr constant [26 x i8] c"Test sets 5 p-value = %g\0A\00", align 1
@.str.7 = private unnamed_addr constant [26 x i8] c"Test sets 6 p-value = %g\0A\00", align 1
@.str.8 = private unnamed_addr constant [26 x i8] c"Test sets 7 p-value = %g\0A\00", align 1
@.str.9 = private unnamed_addr constant [26 x i8] c"Test sets z p-value = %g\0A\00", align 1
@.str.10 = private unnamed_addr constant [28 x i8] c"the cumulative error is %g\0A\00", align 1
@llvm.used = appending global [1 x i8*] [i8* bitcast (i32 ()* @__main_void to i8*)], section "llvm.metadata"

@__main_void = alias i32 (), i32 ()* @main

; Function Attrs: noinline nounwind optnone
define hidden double @Pvalue(double* noalias %ARRAY1, i32 %ARRAY1_SIZE, double* noalias %ARRAY2, i32 %ARRAY2_SIZE) #0 {
entry:
  %retval = alloca double, align 8
  %ARRAY1.addr = alloca double*, align 4
  %ARRAY1_SIZE.addr = alloca i32, align 4
  %ARRAY2.addr = alloca double*, align 4
  %ARRAY2_SIZE.addr = alloca i32, align 4
  %fmean1 = alloca double, align 8
  %fmean2 = alloca double, align 8
  %x = alloca i32, align 4
  %x9 = alloca i32, align 4
  %unbiased_sample_variance1 = alloca double, align 8
  %unbiased_sample_variance2 = alloca double, align 8
  %x32 = alloca i32, align 4
  %x44 = alloca i32, align 4
  %WELCH_T_STATISTIC = alloca double, align 8
  %DEGREES_OF_FREEDOM = alloca double, align 8
  %a = alloca double, align 8
  %value = alloca double, align 8
  %beta = alloca double, align 8
  %acu = alloca double, align 8
  %ai = alloca double, align 8
  %cx = alloca double, align 8
  %indx = alloca i32, align 4
  %ns = alloca i32, align 4
  %pp = alloca double, align 8
  %psq = alloca double, align 8
  %qq = alloca double, align 8
  %rx = alloca double, align 8
  %temp = alloca double, align 8
  %term = alloca double, align 8
  %xx = alloca double, align 8
  store double* %ARRAY1, double** %ARRAY1.addr, align 4
  store i32 %ARRAY1_SIZE, i32* %ARRAY1_SIZE.addr, align 4
  store double* %ARRAY2, double** %ARRAY2.addr, align 4
  store i32 %ARRAY2_SIZE, i32* %ARRAY2_SIZE.addr, align 4
  %0 = load i32, i32* %ARRAY1_SIZE.addr, align 4
  %cmp = icmp ule i32 %0, 1
  br i1 %cmp, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  store double 1.000000e+00, double* %retval, align 8
  br label %return

if.else:                                          ; preds = %entry
  %1 = load i32, i32* %ARRAY2_SIZE.addr, align 4
  %cmp1 = icmp ule i32 %1, 1
  br i1 %cmp1, label %if.then2, label %if.end

if.then2:                                         ; preds = %if.else
  store double 1.000000e+00, double* %retval, align 8
  br label %return

if.end:                                           ; preds = %if.else
  br label %if.end3

if.end3:                                          ; preds = %if.end
  store double 0.000000e+00, double* %fmean1, align 8
  store double 0.000000e+00, double* %fmean2, align 8
  store i32 0, i32* %x, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.end3
  %2 = load i32, i32* %x, align 4
  %3 = load i32, i32* %ARRAY1_SIZE.addr, align 4
  %cmp4 = icmp ult i32 %2, %3
  br i1 %cmp4, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %4 = load double*, double** %ARRAY1.addr, align 4
  %5 = load i32, i32* %x, align 4
  %arrayidx = getelementptr inbounds double, double* %4, i32 %5
  %6 = load double, double* %arrayidx, align 8
  %7 = call double @llvm.fabs.f64(double %6) #7
  %cmpinf = fcmp one double %7, 0x7FF0000000000000
  %8 = zext i1 %cmpinf to i32
  %cmp5 = icmp eq i32 %8, 0
  br i1 %cmp5, label %if.then6, label %if.end7

if.then6:                                         ; preds = %for.body
  %call = call i32 @puts(i8* getelementptr inbounds ([63 x i8], [63 x i8]* @.str, i32 0, i32 0))
  call void @exit(i32 1) #8
  unreachable

if.end7:                                          ; preds = %for.body
  %9 = load double*, double** %ARRAY1.addr, align 4
  %10 = load i32, i32* %x, align 4
  %arrayidx8 = getelementptr inbounds double, double* %9, i32 %10
  %11 = load double, double* %arrayidx8, align 8
  %12 = load double, double* %fmean1, align 8
  %add = fadd double %12, %11
  store double %add, double* %fmean1, align 8
  br label %for.inc

for.inc:                                          ; preds = %if.end7
  %13 = load i32, i32* %x, align 4
  %inc = add i32 %13, 1
  store i32 %inc, i32* %x, align 4
  br label %for.cond

for.end:                                          ; preds = %for.cond
  %14 = load i32, i32* %ARRAY1_SIZE.addr, align 4
  %conv = uitofp i32 %14 to double
  %15 = load double, double* %fmean1, align 8
  %div = fdiv double %15, %conv
  store double %div, double* %fmean1, align 8
  store i32 0, i32* %x9, align 4
  br label %for.cond10

for.cond10:                                       ; preds = %for.inc23, %for.end
  %16 = load i32, i32* %x9, align 4
  %17 = load i32, i32* %ARRAY2_SIZE.addr, align 4
  %cmp11 = icmp ult i32 %16, %17
  br i1 %cmp11, label %for.body13, label %for.end25

for.body13:                                       ; preds = %for.cond10
  %18 = load double*, double** %ARRAY2.addr, align 4
  %19 = load i32, i32* %x9, align 4
  %arrayidx14 = getelementptr inbounds double, double* %18, i32 %19
  %20 = load double, double* %arrayidx14, align 8
  %21 = call double @llvm.fabs.f64(double %20) #7
  %cmpinf15 = fcmp one double %21, 0x7FF0000000000000
  %22 = zext i1 %cmpinf15 to i32
  %cmp16 = icmp eq i32 %22, 0
  br i1 %cmp16, label %if.then18, label %if.end20

if.then18:                                        ; preds = %for.body13
  %call19 = call i32 @puts(i8* getelementptr inbounds ([63 x i8], [63 x i8]* @.str.1, i32 0, i32 0))
  call void @exit(i32 1) #8
  unreachable

if.end20:                                         ; preds = %for.body13
  %23 = load double*, double** %ARRAY2.addr, align 4
  %24 = load i32, i32* %x9, align 4
  %arrayidx21 = getelementptr inbounds double, double* %23, i32 %24
  %25 = load double, double* %arrayidx21, align 8
  %26 = load double, double* %fmean2, align 8
  %add22 = fadd double %26, %25
  store double %add22, double* %fmean2, align 8
  br label %for.inc23

for.inc23:                                        ; preds = %if.end20
  %27 = load i32, i32* %x9, align 4
  %inc24 = add i32 %27, 1
  store i32 %inc24, i32* %x9, align 4
  br label %for.cond10

for.end25:                                        ; preds = %for.cond10
  %28 = load i32, i32* %ARRAY2_SIZE.addr, align 4
  %conv26 = uitofp i32 %28 to double
  %29 = load double, double* %fmean2, align 8
  %div27 = fdiv double %29, %conv26
  store double %div27, double* %fmean2, align 8
  %30 = load double, double* %fmean1, align 8
  %31 = load double, double* %fmean2, align 8
  %cmp28 = fcmp oeq double %30, %31
  br i1 %cmp28, label %if.then30, label %if.end31

if.then30:                                        ; preds = %for.end25
  store double 1.000000e+00, double* %retval, align 8
  br label %return

if.end31:                                         ; preds = %for.end25
  store double 0.000000e+00, double* %unbiased_sample_variance1, align 8
  store double 0.000000e+00, double* %unbiased_sample_variance2, align 8
  store i32 0, i32* %x32, align 4
  br label %for.cond33

for.cond33:                                       ; preds = %for.inc41, %if.end31
  %32 = load i32, i32* %x32, align 4
  %33 = load i32, i32* %ARRAY1_SIZE.addr, align 4
  %cmp34 = icmp ult i32 %32, %33
  br i1 %cmp34, label %for.body36, label %for.end43

for.body36:                                       ; preds = %for.cond33
  %34 = load double*, double** %ARRAY1.addr, align 4
  %35 = load i32, i32* %x32, align 4
  %arrayidx37 = getelementptr inbounds double, double* %34, i32 %35
  %36 = load double, double* %arrayidx37, align 8
  %37 = load double, double* %fmean1, align 8
  %sub = fsub double %36, %37
  %38 = load double*, double** %ARRAY1.addr, align 4
  %39 = load i32, i32* %x32, align 4
  %arrayidx38 = getelementptr inbounds double, double* %38, i32 %39
  %40 = load double, double* %arrayidx38, align 8
  %41 = load double, double* %fmean1, align 8
  %sub39 = fsub double %40, %41
  %mul = fmul double %sub, %sub39
  %42 = load double, double* %unbiased_sample_variance1, align 8
  %add40 = fadd double %42, %mul
  store double %add40, double* %unbiased_sample_variance1, align 8
  br label %for.inc41

for.inc41:                                        ; preds = %for.body36
  %43 = load i32, i32* %x32, align 4
  %inc42 = add i32 %43, 1
  store i32 %inc42, i32* %x32, align 4
  br label %for.cond33

for.end43:                                        ; preds = %for.cond33
  store i32 0, i32* %x44, align 4
  br label %for.cond45

for.cond45:                                       ; preds = %for.inc55, %for.end43
  %44 = load i32, i32* %x44, align 4
  %45 = load i32, i32* %ARRAY2_SIZE.addr, align 4
  %cmp46 = icmp ult i32 %44, %45
  br i1 %cmp46, label %for.body48, label %for.end57

for.body48:                                       ; preds = %for.cond45
  %46 = load double*, double** %ARRAY2.addr, align 4
  %47 = load i32, i32* %x44, align 4
  %arrayidx49 = getelementptr inbounds double, double* %46, i32 %47
  %48 = load double, double* %arrayidx49, align 8
  %49 = load double, double* %fmean2, align 8
  %sub50 = fsub double %48, %49
  %50 = load double*, double** %ARRAY2.addr, align 4
  %51 = load i32, i32* %x44, align 4
  %arrayidx51 = getelementptr inbounds double, double* %50, i32 %51
  %52 = load double, double* %arrayidx51, align 8
  %53 = load double, double* %fmean2, align 8
  %sub52 = fsub double %52, %53
  %mul53 = fmul double %sub50, %sub52
  %54 = load double, double* %unbiased_sample_variance2, align 8
  %add54 = fadd double %54, %mul53
  store double %add54, double* %unbiased_sample_variance2, align 8
  br label %for.inc55

for.inc55:                                        ; preds = %for.body48
  %55 = load i32, i32* %x44, align 4
  %inc56 = add i32 %55, 1
  store i32 %inc56, i32* %x44, align 4
  br label %for.cond45

for.end57:                                        ; preds = %for.cond45
  %56 = load double, double* %unbiased_sample_variance1, align 8
  %57 = load i32, i32* %ARRAY1_SIZE.addr, align 4
  %sub58 = sub i32 %57, 1
  %conv59 = uitofp i32 %sub58 to double
  %div60 = fdiv double %56, %conv59
  store double %div60, double* %unbiased_sample_variance1, align 8
  %58 = load double, double* %unbiased_sample_variance2, align 8
  %59 = load i32, i32* %ARRAY2_SIZE.addr, align 4
  %sub61 = sub i32 %59, 1
  %conv62 = uitofp i32 %sub61 to double
  %div63 = fdiv double %58, %conv62
  store double %div63, double* %unbiased_sample_variance2, align 8
  %60 = load double, double* %fmean1, align 8
  %61 = load double, double* %fmean2, align 8
  %sub64 = fsub double %60, %61
  %62 = load double, double* %unbiased_sample_variance1, align 8
  %63 = load i32, i32* %ARRAY1_SIZE.addr, align 4
  %conv65 = uitofp i32 %63 to double
  %div66 = fdiv double %62, %conv65
  %64 = load double, double* %unbiased_sample_variance2, align 8
  %65 = load i32, i32* %ARRAY2_SIZE.addr, align 4
  %conv67 = uitofp i32 %65 to double
  %div68 = fdiv double %64, %conv67
  %add69 = fadd double %div66, %div68
  %66 = call double @llvm.sqrt.f64(double %add69)
  %div70 = fdiv double %sub64, %66
  store double %div70, double* %WELCH_T_STATISTIC, align 8
  %67 = load double, double* %unbiased_sample_variance1, align 8
  %68 = load i32, i32* %ARRAY1_SIZE.addr, align 4
  %conv71 = uitofp i32 %68 to double
  %div72 = fdiv double %67, %conv71
  %69 = load double, double* %unbiased_sample_variance2, align 8
  %70 = load i32, i32* %ARRAY2_SIZE.addr, align 4
  %conv73 = uitofp i32 %70 to double
  %div74 = fdiv double %69, %conv73
  %add75 = fadd double %div72, %div74
  %71 = call double @llvm.pow.f64(double %add75, double 2.000000e+00)
  %72 = load double, double* %unbiased_sample_variance1, align 8
  %73 = load double, double* %unbiased_sample_variance1, align 8
  %mul76 = fmul double %72, %73
  %74 = load i32, i32* %ARRAY1_SIZE.addr, align 4
  %75 = load i32, i32* %ARRAY1_SIZE.addr, align 4
  %mul77 = mul i32 %74, %75
  %76 = load i32, i32* %ARRAY1_SIZE.addr, align 4
  %sub78 = sub i32 %76, 1
  %mul79 = mul i32 %mul77, %sub78
  %conv80 = uitofp i32 %mul79 to double
  %div81 = fdiv double %mul76, %conv80
  %77 = load double, double* %unbiased_sample_variance2, align 8
  %78 = load double, double* %unbiased_sample_variance2, align 8
  %mul82 = fmul double %77, %78
  %79 = load i32, i32* %ARRAY2_SIZE.addr, align 4
  %80 = load i32, i32* %ARRAY2_SIZE.addr, align 4
  %mul83 = mul i32 %79, %80
  %81 = load i32, i32* %ARRAY2_SIZE.addr, align 4
  %sub84 = sub i32 %81, 1
  %mul85 = mul i32 %mul83, %sub84
  %conv86 = uitofp i32 %mul85 to double
  %div87 = fdiv double %mul82, %conv86
  %add88 = fadd double %div81, %div87
  %div89 = fdiv double %71, %add88
  store double %div89, double* %DEGREES_OF_FREEDOM, align 8
  %82 = load double, double* %DEGREES_OF_FREEDOM, align 8
  %div90 = fdiv double %82, 2.000000e+00
  store double %div90, double* %a, align 8
  %83 = load double, double* %DEGREES_OF_FREEDOM, align 8
  %84 = load double, double* %WELCH_T_STATISTIC, align 8
  %85 = load double, double* %WELCH_T_STATISTIC, align 8
  %mul91 = fmul double %84, %85
  %86 = load double, double* %DEGREES_OF_FREEDOM, align 8
  %add92 = fadd double %mul91, %86
  %div93 = fdiv double %83, %add92
  store double %div93, double* %value, align 8
  %87 = load double, double* %value, align 8
  %88 = call double @llvm.fabs.f64(double %87) #7
  %cmpinf94 = fcmp oeq double %88, 0x7FF0000000000000
  br i1 %cmpinf94, label %if.then100, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %for.end57
  %89 = load double, double* %value, align 8
  %cmp97 = fcmp uno double %89, %89
  %90 = zext i1 %cmp97 to i32
  %cmp98 = icmp ne i32 %90, 0
  br i1 %cmp98, label %if.then100, label %if.end101

if.then100:                                       ; preds = %lor.lhs.false, %for.end57
  store double 1.000000e+00, double* %retval, align 8
  br label %return

if.end101:                                        ; preds = %lor.lhs.false
  %91 = load double, double* %value, align 8
  %92 = call double @llvm.fabs.f64(double %91) #7
  %cmpinf102 = fcmp oeq double %92, 0x7FF0000000000000
  %93 = zext i1 %cmpinf102 to i32
  %cmp103 = icmp ne i32 %93, 0
  br i1 %cmp103, label %if.then109, label %lor.lhs.false105

lor.lhs.false105:                                 ; preds = %if.end101
  %94 = load double, double* %value, align 8
  %cmp106 = fcmp uno double %94, %94
  %95 = zext i1 %cmp106 to i32
  %cmp107 = icmp ne i32 %95, 0
  br i1 %cmp107, label %if.then109, label %if.end110

if.then109:                                       ; preds = %lor.lhs.false105, %if.end101
  store double 1.000000e+00, double* %retval, align 8
  br label %return

if.end110:                                        ; preds = %lor.lhs.false105
  %96 = load double, double* %a, align 8
  %conv111 = fpext double %96 to fp128
  %call112 = call fp128 @lgammal(fp128 %conv111) #9
  %add113 = fadd fp128 %call112, 0xLD0000000000000003FFE250D048E7A1B
  %97 = load double, double* %a, align 8
  %add114 = fadd double %97, 5.000000e-01
  %conv115 = fpext double %add114 to fp128
  %call116 = call fp128 @lgammal(fp128 %conv115) #9
  %sub117 = fsub fp128 %add113, %call116
  %conv118 = fptrunc fp128 %sub117 to double
  store double %conv118, double* %beta, align 8
  store double 1.000000e-15, double* %acu, align 8
  %98 = load double, double* %a, align 8
  %cmp119 = fcmp ole double %98, 0.000000e+00
  br i1 %cmp119, label %if.then121, label %if.end122

if.then121:                                       ; preds = %if.end110
  br label %if.end122

if.end122:                                        ; preds = %if.then121, %if.end110
  %99 = load double, double* %value, align 8
  %cmp123 = fcmp olt double %99, 0.000000e+00
  br i1 %cmp123, label %if.then128, label %lor.lhs.false125

lor.lhs.false125:                                 ; preds = %if.end122
  %100 = load double, double* %value, align 8
  %cmp126 = fcmp olt double 1.000000e+00, %100
  br i1 %cmp126, label %if.then128, label %if.end129

if.then128:                                       ; preds = %lor.lhs.false125, %if.end122
  %101 = load double, double* %value, align 8
  store double %101, double* %retval, align 8
  br label %return

if.end129:                                        ; preds = %lor.lhs.false125
  %102 = load double, double* %value, align 8
  %cmp130 = fcmp oeq double %102, 0.000000e+00
  br i1 %cmp130, label %if.then135, label %lor.lhs.false132

lor.lhs.false132:                                 ; preds = %if.end129
  %103 = load double, double* %value, align 8
  %cmp133 = fcmp oeq double %103, 1.000000e+00
  br i1 %cmp133, label %if.then135, label %if.end136

if.then135:                                       ; preds = %lor.lhs.false132, %if.end129
  %104 = load double, double* %value, align 8
  store double %104, double* %retval, align 8
  br label %return

if.end136:                                        ; preds = %lor.lhs.false132
  %105 = load double, double* %a, align 8
  %add137 = fadd double %105, 5.000000e-01
  store double %add137, double* %psq, align 8
  %106 = load double, double* %value, align 8
  %sub138 = fsub double 1.000000e+00, %106
  store double %sub138, double* %cx, align 8
  %107 = load double, double* %a, align 8
  %108 = load double, double* %psq, align 8
  %109 = load double, double* %value, align 8
  %mul139 = fmul double %108, %109
  %cmp140 = fcmp olt double %107, %mul139
  br i1 %cmp140, label %if.then142, label %if.else143

if.then142:                                       ; preds = %if.end136
  %110 = load double, double* %cx, align 8
  store double %110, double* %xx, align 8
  %111 = load double, double* %value, align 8
  store double %111, double* %cx, align 8
  store double 5.000000e-01, double* %pp, align 8
  %112 = load double, double* %a, align 8
  store double %112, double* %qq, align 8
  store i32 1, i32* %indx, align 4
  br label %if.end144

if.else143:                                       ; preds = %if.end136
  %113 = load double, double* %value, align 8
  store double %113, double* %xx, align 8
  %114 = load double, double* %a, align 8
  store double %114, double* %pp, align 8
  store double 5.000000e-01, double* %qq, align 8
  store i32 0, i32* %indx, align 4
  br label %if.end144

if.end144:                                        ; preds = %if.else143, %if.then142
  store double 1.000000e+00, double* %term, align 8
  store double 1.000000e+00, double* %ai, align 8
  store double 1.000000e+00, double* %value, align 8
  %115 = load double, double* %qq, align 8
  %116 = load double, double* %cx, align 8
  %117 = load double, double* %psq, align 8
  %mul145 = fmul double %116, %117
  %add146 = fadd double %115, %mul145
  %conv147 = fptosi double %add146 to i32
  store i32 %conv147, i32* %ns, align 4
  %118 = load double, double* %xx, align 8
  %119 = load double, double* %cx, align 8
  %div148 = fdiv double %118, %119
  store double %div148, double* %rx, align 8
  %120 = load double, double* %qq, align 8
  %121 = load double, double* %ai, align 8
  %sub149 = fsub double %120, %121
  store double %sub149, double* %temp, align 8
  %122 = load i32, i32* %ns, align 4
  %cmp150 = icmp eq i32 %122, 0
  br i1 %cmp150, label %if.then152, label %if.end153

if.then152:                                       ; preds = %if.end144
  %123 = load double, double* %xx, align 8
  store double %123, double* %rx, align 8
  br label %if.end153

if.end153:                                        ; preds = %if.then152, %if.end144
  br label %for.cond154

for.cond154:                                      ; preds = %if.end189, %if.end153
  %124 = load double, double* %term, align 8
  %125 = load double, double* %temp, align 8
  %mul155 = fmul double %124, %125
  %126 = load double, double* %rx, align 8
  %mul156 = fmul double %mul155, %126
  %127 = load double, double* %pp, align 8
  %128 = load double, double* %ai, align 8
  %add157 = fadd double %127, %128
  %div158 = fdiv double %mul156, %add157
  store double %div158, double* %term, align 8
  %129 = load double, double* %value, align 8
  %130 = load double, double* %term, align 8
  %add159 = fadd double %129, %130
  store double %add159, double* %value, align 8
  %131 = load double, double* %term, align 8
  %132 = call double @llvm.fabs.f64(double %131)
  store double %132, double* %temp, align 8
  %133 = load double, double* %temp, align 8
  %cmp160 = fcmp ole double %133, 1.000000e-15
  br i1 %cmp160, label %land.lhs.true, label %if.end176

land.lhs.true:                                    ; preds = %for.cond154
  %134 = load double, double* %temp, align 8
  %135 = load double, double* %value, align 8
  %mul162 = fmul double 1.000000e-15, %135
  %cmp163 = fcmp ole double %134, %mul162
  br i1 %cmp163, label %if.then165, label %if.end176

if.then165:                                       ; preds = %land.lhs.true
  %136 = load double, double* %value, align 8
  %137 = load double, double* %pp, align 8
  %138 = load double, double* %xx, align 8
  %139 = call double @llvm.log.f64(double %138)
  %mul166 = fmul double %137, %139
  %140 = load double, double* %qq, align 8
  %sub167 = fsub double %140, 1.000000e+00
  %141 = load double, double* %cx, align 8
  %142 = call double @llvm.log.f64(double %141)
  %mul168 = fmul double %sub167, %142
  %add169 = fadd double %mul166, %mul168
  %143 = load double, double* %beta, align 8
  %sub170 = fsub double %add169, %143
  %144 = call double @llvm.exp.f64(double %sub170)
  %mul171 = fmul double %136, %144
  %145 = load double, double* %pp, align 8
  %div172 = fdiv double %mul171, %145
  store double %div172, double* %value, align 8
  %146 = load i32, i32* %indx, align 4
  %tobool = icmp ne i32 %146, 0
  br i1 %tobool, label %if.then173, label %if.end175

if.then173:                                       ; preds = %if.then165
  %147 = load double, double* %value, align 8
  %sub174 = fsub double 1.000000e+00, %147
  store double %sub174, double* %value, align 8
  br label %if.end175

if.end175:                                        ; preds = %if.then173, %if.then165
  br label %for.end190

if.end176:                                        ; preds = %land.lhs.true, %for.cond154
  %148 = load double, double* %ai, align 8
  %add177 = fadd double %148, 1.000000e+00
  store double %add177, double* %ai, align 8
  %149 = load i32, i32* %ns, align 4
  %sub178 = sub nsw i32 %149, 1
  store i32 %sub178, i32* %ns, align 4
  %150 = load i32, i32* %ns, align 4
  %cmp179 = icmp sle i32 0, %150
  br i1 %cmp179, label %if.then181, label %if.else187

if.then181:                                       ; preds = %if.end176
  %151 = load double, double* %qq, align 8
  %152 = load double, double* %ai, align 8
  %sub182 = fsub double %151, %152
  store double %sub182, double* %temp, align 8
  %153 = load i32, i32* %ns, align 4
  %cmp183 = icmp eq i32 %153, 0
  br i1 %cmp183, label %if.then185, label %if.end186

if.then185:                                       ; preds = %if.then181
  %154 = load double, double* %xx, align 8
  store double %154, double* %rx, align 8
  br label %if.end186

if.end186:                                        ; preds = %if.then185, %if.then181
  br label %if.end189

if.else187:                                       ; preds = %if.end176
  %155 = load double, double* %psq, align 8
  store double %155, double* %temp, align 8
  %156 = load double, double* %psq, align 8
  %add188 = fadd double %156, 1.000000e+00
  store double %add188, double* %psq, align 8
  br label %if.end189

if.end189:                                        ; preds = %if.else187, %if.end186
  br label %for.cond154

for.end190:                                       ; preds = %if.end175
  %157 = load double, double* %value, align 8
  store double %157, double* %retval, align 8
  br label %return

return:                                           ; preds = %for.end190, %if.then135, %if.then128, %if.then109, %if.then100, %if.then30, %if.then2, %if.then
  %158 = load double, double* %retval, align 8
  ret double %158
}

; Function Attrs: nounwind readnone speculatable willreturn
declare double @llvm.fabs.f64(double %0) #1

declare i32 @puts(i8* %0) #2

; Function Attrs: noreturn
declare void @exit(i32 %0) #3

; Function Attrs: nounwind readnone speculatable willreturn
declare double @llvm.sqrt.f64(double %0) #1

; Function Attrs: nounwind readnone speculatable willreturn
declare double @llvm.pow.f64(double %0, double %1) #1

; Function Attrs: nounwind
declare fp128 @lgammal(fp128 %0) #4

; Function Attrs: nounwind readnone speculatable willreturn
declare double @llvm.log.f64(double %0) #1

; Function Attrs: nounwind readnone speculatable willreturn
declare double @llvm.exp.f64(double %0) #1

; Function Attrs: noinline nounwind optnone
define hidden i32 @main() #0 {
entry:
  %retval = alloca i32, align 4
  %d1 = alloca [15 x double], align 16
  %d2 = alloca [15 x double], align 16
  %d3 = alloca [10 x double], align 16
  %d4 = alloca [20 x double], align 16
  %d5 = alloca [10 x double], align 16
  %d6 = alloca [20 x double], align 16
  %d7 = alloca [6 x double], align 16
  %d8 = alloca [6 x double], align 16
  %x = alloca [4 x double], align 16
  %y = alloca [3 x double], align 16
  %v1 = alloca [3 x double], align 16
  %v2 = alloca [3 x double], align 16
  %s1 = alloca [2 x double], align 16
  %s2 = alloca [2 x double], align 16
  %z1 = alloca [3 x double], align 16
  %z2 = alloca [3 x double], align 16
  %CORRECT_ANSWERS = alloca [8 x double], align 16
  %pvalue = alloca double, align 8
  %error = alloca double, align 8
  store i32 0, i32* %retval, align 4
  %0 = bitcast [15 x double]* %d1 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 16 %0, i8* align 16 bitcast ([15 x double]* @__const.main.d1 to i8*), i32 120, i1 false)
  %1 = bitcast [15 x double]* %d2 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 16 %1, i8* align 16 bitcast ([15 x double]* @__const.main.d2 to i8*), i32 120, i1 false)
  %2 = bitcast [10 x double]* %d3 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 16 %2, i8* align 16 bitcast ([10 x double]* @__const.main.d3 to i8*), i32 80, i1 false)
  %3 = bitcast [20 x double]* %d4 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 16 %3, i8* align 16 bitcast ([20 x double]* @__const.main.d4 to i8*), i32 160, i1 false)
  %4 = bitcast [10 x double]* %d5 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 16 %4, i8* align 16 bitcast ([10 x double]* @__const.main.d5 to i8*), i32 80, i1 false)
  %5 = bitcast [20 x double]* %d6 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 16 %5, i8* align 16 bitcast ([20 x double]* @__const.main.d6 to i8*), i32 160, i1 false)
  %6 = bitcast [6 x double]* %d7 to i8*
  call void @llvm.memset.p0i8.i32(i8* align 16 %6, i8 0, i32 48, i1 false)
  %7 = bitcast i8* %6 to [6 x double]*
  %8 = getelementptr inbounds [6 x double], [6 x double]* %7, i32 0, i32 0
  store double 3.002000e+01, double* %8, align 16
  %9 = getelementptr inbounds [6 x double], [6 x double]* %7, i32 0, i32 1
  store double 2.999000e+01, double* %9, align 8
  %10 = getelementptr inbounds [6 x double], [6 x double]* %7, i32 0, i32 2
  store double 3.011000e+01, double* %10, align 16
  %11 = getelementptr inbounds [6 x double], [6 x double]* %7, i32 0, i32 3
  store double 2.997000e+01, double* %11, align 8
  %12 = getelementptr inbounds [6 x double], [6 x double]* %7, i32 0, i32 4
  store double 3.001000e+01, double* %12, align 16
  %13 = getelementptr inbounds [6 x double], [6 x double]* %7, i32 0, i32 5
  store double 2.999000e+01, double* %13, align 8
  %14 = bitcast [6 x double]* %d8 to i8*
  call void @llvm.memset.p0i8.i32(i8* align 16 %14, i8 0, i32 48, i1 false)
  %15 = bitcast i8* %14 to [6 x double]*
  %16 = getelementptr inbounds [6 x double], [6 x double]* %15, i32 0, i32 0
  store double 2.989000e+01, double* %16, align 16
  %17 = getelementptr inbounds [6 x double], [6 x double]* %15, i32 0, i32 1
  store double 2.993000e+01, double* %17, align 8
  %18 = getelementptr inbounds [6 x double], [6 x double]* %15, i32 0, i32 2
  store double 2.972000e+01, double* %18, align 16
  %19 = getelementptr inbounds [6 x double], [6 x double]* %15, i32 0, i32 3
  store double 2.998000e+01, double* %19, align 8
  %20 = getelementptr inbounds [6 x double], [6 x double]* %15, i32 0, i32 4
  store double 3.002000e+01, double* %20, align 16
  %21 = getelementptr inbounds [6 x double], [6 x double]* %15, i32 0, i32 5
  store double 2.998000e+01, double* %21, align 8
  %22 = bitcast [4 x double]* %x to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 16 %22, i8* align 16 bitcast ([4 x double]* @__const.main.x to i8*), i32 32, i1 false)
  %23 = bitcast [3 x double]* %y to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 16 %23, i8* align 16 bitcast ([3 x double]* @__const.main.y to i8*), i32 24, i1 false)
  %24 = bitcast [3 x double]* %v1 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 16 %24, i8* align 16 bitcast ([3 x double]* @__const.main.v1 to i8*), i32 24, i1 false)
  %25 = bitcast [3 x double]* %v2 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 16 %25, i8* align 16 bitcast ([3 x double]* @__const.main.v2 to i8*), i32 24, i1 false)
  %26 = bitcast [2 x double]* %s1 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 16 %26, i8* align 16 bitcast ([2 x double]* @__const.main.s1 to i8*), i32 16, i1 false)
  %27 = bitcast [2 x double]* %s2 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 16 %27, i8* align 16 bitcast ([2 x double]* @__const.main.s2 to i8*), i32 16, i1 false)
  %28 = bitcast [3 x double]* %z1 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 16 %28, i8* align 16 bitcast ([3 x double]* @__const.main.z1 to i8*), i32 24, i1 false)
  %29 = bitcast [3 x double]* %z2 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 16 %29, i8* align 16 bitcast ([3 x double]* @__const.main.z2 to i8*), i32 24, i1 false)
  %30 = bitcast [8 x double]* %CORRECT_ANSWERS to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 16 %30, i8* align 16 bitcast ([8 x double]* @__const.main.CORRECT_ANSWERS to i8*), i32 64, i1 false)
  %arraydecay = getelementptr inbounds [15 x double], [15 x double]* %d1, i32 0, i32 0
  %arraydecay1 = getelementptr inbounds [15 x double], [15 x double]* %d2, i32 0, i32 0
  %call = call double @Pvalue(double* %arraydecay, i32 15, double* %arraydecay1, i32 15)
  store double %call, double* %pvalue, align 8
  %31 = load double, double* %pvalue, align 8
  %arrayidx = getelementptr inbounds [8 x double], [8 x double]* %CORRECT_ANSWERS, i32 0, i32 0
  %32 = load double, double* %arrayidx, align 16
  %sub = fsub double %31, %32
  %33 = call double @llvm.fabs.f64(double %sub)
  store double %33, double* %error, align 8
  %34 = load double, double* %pvalue, align 8
  %call2 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([26 x i8], [26 x i8]* @.str.2, i32 0, i32 0), double %34)
  %arraydecay3 = getelementptr inbounds [10 x double], [10 x double]* %d3, i32 0, i32 0
  %arraydecay4 = getelementptr inbounds [20 x double], [20 x double]* %d4, i32 0, i32 0
  %call5 = call double @Pvalue(double* %arraydecay3, i32 10, double* %arraydecay4, i32 20)
  store double %call5, double* %pvalue, align 8
  %35 = load double, double* %pvalue, align 8
  %arrayidx6 = getelementptr inbounds [8 x double], [8 x double]* %CORRECT_ANSWERS, i32 0, i32 1
  %36 = load double, double* %arrayidx6, align 8
  %sub7 = fsub double %35, %36
  %37 = call double @llvm.fabs.f64(double %sub7)
  %38 = load double, double* %error, align 8
  %add = fadd double %38, %37
  store double %add, double* %error, align 8
  %39 = load double, double* %pvalue, align 8
  %call8 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([26 x i8], [26 x i8]* @.str.3, i32 0, i32 0), double %39)
  %arraydecay9 = getelementptr inbounds [10 x double], [10 x double]* %d5, i32 0, i32 0
  %arraydecay10 = getelementptr inbounds [20 x double], [20 x double]* %d6, i32 0, i32 0
  %call11 = call double @Pvalue(double* %arraydecay9, i32 10, double* %arraydecay10, i32 20)
  store double %call11, double* %pvalue, align 8
  %40 = load double, double* %pvalue, align 8
  %arrayidx12 = getelementptr inbounds [8 x double], [8 x double]* %CORRECT_ANSWERS, i32 0, i32 2
  %41 = load double, double* %arrayidx12, align 16
  %sub13 = fsub double %40, %41
  %42 = call double @llvm.fabs.f64(double %sub13)
  %43 = load double, double* %error, align 8
  %add14 = fadd double %43, %42
  store double %add14, double* %error, align 8
  %44 = load double, double* %pvalue, align 8
  %call15 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([26 x i8], [26 x i8]* @.str.4, i32 0, i32 0), double %44)
  %arraydecay16 = getelementptr inbounds [6 x double], [6 x double]* %d7, i32 0, i32 0
  %arraydecay17 = getelementptr inbounds [6 x double], [6 x double]* %d8, i32 0, i32 0
  %call18 = call double @Pvalue(double* %arraydecay16, i32 6, double* %arraydecay17, i32 6)
  store double %call18, double* %pvalue, align 8
  %45 = load double, double* %pvalue, align 8
  %call19 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([26 x i8], [26 x i8]* @.str.5, i32 0, i32 0), double %45)
  %46 = load double, double* %pvalue, align 8
  %arrayidx20 = getelementptr inbounds [8 x double], [8 x double]* %CORRECT_ANSWERS, i32 0, i32 3
  %47 = load double, double* %arrayidx20, align 8
  %sub21 = fsub double %46, %47
  %48 = call double @llvm.fabs.f64(double %sub21)
  %49 = load double, double* %error, align 8
  %add22 = fadd double %49, %48
  store double %add22, double* %error, align 8
  %arraydecay23 = getelementptr inbounds [4 x double], [4 x double]* %x, i32 0, i32 0
  %arraydecay24 = getelementptr inbounds [3 x double], [3 x double]* %y, i32 0, i32 0
  %call25 = call double @Pvalue(double* %arraydecay23, i32 4, double* %arraydecay24, i32 3)
  store double %call25, double* %pvalue, align 8
  %50 = load double, double* %pvalue, align 8
  %arrayidx26 = getelementptr inbounds [8 x double], [8 x double]* %CORRECT_ANSWERS, i32 0, i32 4
  %51 = load double, double* %arrayidx26, align 16
  %sub27 = fsub double %50, %51
  %52 = call double @llvm.fabs.f64(double %sub27)
  %53 = load double, double* %error, align 8
  %add28 = fadd double %53, %52
  store double %add28, double* %error, align 8
  %54 = load double, double* %pvalue, align 8
  %call29 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([26 x i8], [26 x i8]* @.str.6, i32 0, i32 0), double %54)
  %arraydecay30 = getelementptr inbounds [3 x double], [3 x double]* %v1, i32 0, i32 0
  %arraydecay31 = getelementptr inbounds [3 x double], [3 x double]* %v2, i32 0, i32 0
  %call32 = call double @Pvalue(double* %arraydecay30, i32 3, double* %arraydecay31, i32 3)
  store double %call32, double* %pvalue, align 8
  %55 = load double, double* %pvalue, align 8
  %arrayidx33 = getelementptr inbounds [8 x double], [8 x double]* %CORRECT_ANSWERS, i32 0, i32 5
  %56 = load double, double* %arrayidx33, align 8
  %sub34 = fsub double %55, %56
  %57 = call double @llvm.fabs.f64(double %sub34)
  %58 = load double, double* %error, align 8
  %add35 = fadd double %58, %57
  store double %add35, double* %error, align 8
  %59 = load double, double* %pvalue, align 8
  %call36 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([26 x i8], [26 x i8]* @.str.7, i32 0, i32 0), double %59)
  %arraydecay37 = getelementptr inbounds [2 x double], [2 x double]* %s1, i32 0, i32 0
  %arraydecay38 = getelementptr inbounds [2 x double], [2 x double]* %s2, i32 0, i32 0
  %call39 = call double @Pvalue(double* %arraydecay37, i32 2, double* %arraydecay38, i32 2)
  store double %call39, double* %pvalue, align 8
  %60 = load double, double* %pvalue, align 8
  %arrayidx40 = getelementptr inbounds [8 x double], [8 x double]* %CORRECT_ANSWERS, i32 0, i32 6
  %61 = load double, double* %arrayidx40, align 16
  %sub41 = fsub double %60, %61
  %62 = call double @llvm.fabs.f64(double %sub41)
  %63 = load double, double* %error, align 8
  %add42 = fadd double %63, %62
  store double %add42, double* %error, align 8
  %64 = load double, double* %pvalue, align 8
  %call43 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([26 x i8], [26 x i8]* @.str.8, i32 0, i32 0), double %64)
  %arraydecay44 = getelementptr inbounds [3 x double], [3 x double]* %z1, i32 0, i32 0
  %arraydecay45 = getelementptr inbounds [3 x double], [3 x double]* %z2, i32 0, i32 0
  %call46 = call double @Pvalue(double* %arraydecay44, i32 3, double* %arraydecay45, i32 3)
  store double %call46, double* %pvalue, align 8
  %65 = load double, double* %pvalue, align 8
  %arrayidx47 = getelementptr inbounds [8 x double], [8 x double]* %CORRECT_ANSWERS, i32 0, i32 7
  %66 = load double, double* %arrayidx47, align 8
  %sub48 = fsub double %65, %66
  %67 = call double @llvm.fabs.f64(double %sub48)
  %68 = load double, double* %error, align 8
  %add49 = fadd double %68, %67
  store double %add49, double* %error, align 8
  %69 = load double, double* %pvalue, align 8
  %call50 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([26 x i8], [26 x i8]* @.str.9, i32 0, i32 0), double %69)
  %70 = load double, double* %error, align 8
  %call51 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([28 x i8], [28 x i8]* @.str.10, i32 0, i32 0), double %70)
  ret i32 0
}

; Function Attrs: argmemonly nounwind willreturn
declare void @llvm.memcpy.p0i8.p0i8.i32(i8* noalias nocapture writeonly %0, i8* noalias nocapture readonly %1, i32 %2, i1 immarg %3) #5

; Function Attrs: argmemonly nounwind willreturn writeonly
declare void @llvm.memset.p0i8.i32(i8* nocapture writeonly %0, i8 %1, i32 %2, i1 immarg %3) #6

declare i32 @printf(i8* %0, ...) #2

attributes #0 = { noinline nounwind optnone "correctly-rounded-divide-sqrt-fp-math"="false" "disable-tail-calls"="false" "frame-pointer"="none" "less-precise-fpmad"="false" "min-legal-vector-width"="0" "no-infs-fp-math"="false" "no-jump-tables"="false" "no-nans-fp-math"="false" "no-signed-zeros-fp-math"="false" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="generic" "unsafe-fp-math"="false" "use-soft-float"="false" }
attributes #1 = { nounwind readnone speculatable willreturn }
attributes #2 = { "correctly-rounded-divide-sqrt-fp-math"="false" "disable-tail-calls"="false" "frame-pointer"="none" "less-precise-fpmad"="false" "no-infs-fp-math"="false" "no-nans-fp-math"="false" "no-signed-zeros-fp-math"="false" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="generic" "unsafe-fp-math"="false" "use-soft-float"="false" }
attributes #3 = { noreturn "correctly-rounded-divide-sqrt-fp-math"="false" "disable-tail-calls"="false" "frame-pointer"="none" "less-precise-fpmad"="false" "no-infs-fp-math"="false" "no-nans-fp-math"="false" "no-signed-zeros-fp-math"="false" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="generic" "unsafe-fp-math"="false" "use-soft-float"="false" }
attributes #4 = { nounwind "correctly-rounded-divide-sqrt-fp-math"="false" "disable-tail-calls"="false" "frame-pointer"="none" "less-precise-fpmad"="false" "no-infs-fp-math"="false" "no-nans-fp-math"="false" "no-signed-zeros-fp-math"="false" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="generic" "unsafe-fp-math"="false" "use-soft-float"="false" }
attributes #5 = { argmemonly nounwind willreturn }
attributes #6 = { argmemonly nounwind willreturn writeonly }
attributes #7 = { readnone }
attributes #8 = { noreturn }
attributes #9 = { nounwind }

!llvm.module.flags = !{!0}
!llvm.ident = !{!1}

!0 = !{i32 1, !"wchar_size", i32 4}
!1 = !{!"clang version 11.0.0 (https://github.com/Jacarte/llvm-project.git 0f6dea67136cc1e0b3d200eb2bb165628970c44b)"}

; Replacing "  %cmp98 = icmp ne i32 %90, 0"
; from ""
; with "  %cmp97 = fcmp uno double %89, %89" in:
"%0:i1 = var
%1:i32 = zext %0
%2:i1 = ne 0:i32, %1
cand %2 %0
"
; with "  %cmp97 = fcmp uno double %89, %89"

Module after replacement:
; ModuleID = './Welchs_t-test.c.bc'
source_filename = "./Welchs_t-test.c"
target datalayout = "e-m:e-p:32:32-i64:64-n32:64-S128"
target triple = "wasm32-unknown-wasi"

@.str = private unnamed_addr constant [63 x i8] c"Got a non-finite number in 1st array, can't calculate P-value.\00", align 1
@.str.1 = private unnamed_addr constant [63 x i8] c"Got a non-finite number in 2nd array, can't calculate P-value.\00", align 1
@__const.main.d1 = private unnamed_addr constant [15 x double] [double 2.750000e+01, double 2.100000e+01, double 1.900000e+01, double 2.360000e+01, double 1.700000e+01, double 1.790000e+01, double 1.690000e+01, double 2.010000e+01, double 2.190000e+01, double 2.260000e+01, double 2.310000e+01, double 1.960000e+01, double 1.900000e+01, double 2.170000e+01, double 2.140000e+01], align 16
@__const.main.d2 = private unnamed_addr constant [15 x double] [double 2.710000e+01, double 2.200000e+01, double 2.080000e+01, double 2.340000e+01, double 2.340000e+01, double 2.350000e+01, double 2.580000e+01, double 2.200000e+01, double 2.480000e+01, double 2.020000e+01, double 2.190000e+01, double 2.210000e+01, double 2.290000e+01, double 2.050000e+01, double 2.440000e+01], align 16
@__const.main.d3 = private unnamed_addr constant [10 x double] [double 1.720000e+01, double 2.090000e+01, double 2.260000e+01, double 1.810000e+01, double 2.170000e+01, double 2.140000e+01, double 2.350000e+01, double 2.420000e+01, double 1.470000e+01, double 2.180000e+01], align 16
@__const.main.d4 = private unnamed_addr constant [20 x double] [double 2.150000e+01, double 2.280000e+01, double 2.100000e+01, double 2.300000e+01, double 2.160000e+01, double 2.360000e+01, double 2.250000e+01, double 2.070000e+01, double 2.340000e+01, double 2.180000e+01, double 2.070000e+01, double 2.170000e+01, double 2.150000e+01, double 2.250000e+01, double 2.360000e+01, double 2.150000e+01, double 2.250000e+01, double 2.350000e+01, double 2.150000e+01, double 2.180000e+01], align 16
@__const.main.d5 = private unnamed_addr constant [10 x double] [double 1.980000e+01, double 2.040000e+01, double 1.960000e+01, double 1.780000e+01, double 1.850000e+01, double 1.890000e+01, double 1.830000e+01, double 1.890000e+01, double 1.950000e+01, double 2.200000e+01], align 16
@__const.main.d6 = private unnamed_addr constant [20 x double] [double 2.820000e+01, double 2.660000e+01, double 2.010000e+01, double 2.330000e+01, double 2.520000e+01, double 2.210000e+01, double 1.770000e+01, double 2.760000e+01, double 2.060000e+01, double 1.370000e+01, double 2.320000e+01, double 1.750000e+01, double 2.060000e+01, double 1.800000e+01, double 2.390000e+01, double 2.160000e+01, double 2.430000e+01, double 2.040000e+01, double 2.400000e+01, double 1.320000e+01], align 16
@__const.main.x = private unnamed_addr constant [4 x double] [double 3.000000e+00, double 4.000000e+00, double 1.000000e+00, double 2.100000e+00], align 16
@__const.main.y = private unnamed_addr constant [3 x double] [double 4.902000e+02, double 3.400000e+02, double 4.339000e+02], align 16
@__const.main.v1 = private unnamed_addr constant [3 x double] [double 1.026800e-02, double 1.670000e-04, double 1.670000e-04], align 16
@__const.main.v2 = private unnamed_addr constant [3 x double] [double 1.592580e-01, double 1.362780e-01, double 1.223890e-01], align 16
@__const.main.s1 = private unnamed_addr constant [2 x double] [double 0x3FB1111111111111, double 0x3FC4A5294A5294A5], align 16
@__const.main.s2 = private unnamed_addr constant [2 x double] [double 1.000000e-01, double 4.000000e-02], align 16
@__const.main.z1 = private unnamed_addr constant [3 x double] [double 0x3FD90B21642C8591, double 0x3FDDDDDDDDDDDDDE, double 0.000000e+00], align 16
@__const.main.z2 = private unnamed_addr constant [3 x double] [double 0.000000e+00, double 0x3FDC9882B9310572, double 0.000000e+00], align 16
@__const.main.CORRECT_ANSWERS = private unnamed_addr constant [8 x double] [double 0x3F95E41D648C236F, double 0x3FC30D3EA599BB79, double 0x3FA26AF51F458AEB, double 0x3FB73CEBAB27FA12, double 0x3F8604EA1C27764A, double 0x3F6BD85EAF35CBC8, double 0x3FE0DF5C6BE20DA6, double 0x3FE172D38028625E], align 16
@.str.2 = private unnamed_addr constant [26 x i8] c"Test sets 1 p-value = %g\0A\00", align 1
@.str.3 = private unnamed_addr constant [26 x i8] c"Test sets 2 p-value = %g\0A\00", align 1
@.str.4 = private unnamed_addr constant [26 x i8] c"Test sets 3 p-value = %g\0A\00", align 1
@.str.5 = private unnamed_addr constant [26 x i8] c"Test sets 4 p-value = %g\0A\00", align 1
@.str.6 = private unnamed_addr constant [26 x i8] c"Test sets 5 p-value = %g\0A\00", align 1
@.str.7 = private unnamed_addr constant [26 x i8] c"Test sets 6 p-value = %g\0A\00", align 1
@.str.8 = private unnamed_addr constant [26 x i8] c"Test sets 7 p-value = %g\0A\00", align 1
@.str.9 = private unnamed_addr constant [26 x i8] c"Test sets z p-value = %g\0A\00", align 1
@.str.10 = private unnamed_addr constant [28 x i8] c"the cumulative error is %g\0A\00", align 1
@llvm.used = appending global [1 x i8*] [i8* bitcast (i32 ()* @__main_void to i8*)], section "llvm.metadata"

@__main_void = alias i32 (), i32 ()* @main

; Function Attrs: noinline nounwind optnone
define hidden double @Pvalue(double* noalias %ARRAY1, i32 %ARRAY1_SIZE, double* noalias %ARRAY2, i32 %ARRAY2_SIZE) #0 {
entry:
  %retval = alloca double, align 8
  %ARRAY1.addr = alloca double*, align 4
  %ARRAY1_SIZE.addr = alloca i32, align 4
  %ARRAY2.addr = alloca double*, align 4
  %ARRAY2_SIZE.addr = alloca i32, align 4
  %fmean1 = alloca double, align 8
  %fmean2 = alloca double, align 8
  %x = alloca i32, align 4
  %x9 = alloca i32, align 4
  %unbiased_sample_variance1 = alloca double, align 8
  %unbiased_sample_variance2 = alloca double, align 8
  %x32 = alloca i32, align 4
  %x44 = alloca i32, align 4
  %WELCH_T_STATISTIC = alloca double, align 8
  %DEGREES_OF_FREEDOM = alloca double, align 8
  %a = alloca double, align 8
  %value = alloca double, align 8
  %beta = alloca double, align 8
  %acu = alloca double, align 8
  %ai = alloca double, align 8
  %cx = alloca double, align 8
  %indx = alloca i32, align 4
  %ns = alloca i32, align 4
  %pp = alloca double, align 8
  %psq = alloca double, align 8
  %qq = alloca double, align 8
  %rx = alloca double, align 8
  %temp = alloca double, align 8
  %term = alloca double, align 8
  %xx = alloca double, align 8
  store double* %ARRAY1, double** %ARRAY1.addr, align 4
  store i32 %ARRAY1_SIZE, i32* %ARRAY1_SIZE.addr, align 4
  store double* %ARRAY2, double** %ARRAY2.addr, align 4
  store i32 %ARRAY2_SIZE, i32* %ARRAY2_SIZE.addr, align 4
  %0 = load i32, i32* %ARRAY1_SIZE.addr, align 4
  %cmp = icmp ule i32 %0, 1
  br i1 %cmp, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  store double 1.000000e+00, double* %retval, align 8
  br label %return

if.else:                                          ; preds = %entry
  %1 = load i32, i32* %ARRAY2_SIZE.addr, align 4
  %cmp1 = icmp ule i32 %1, 1
  br i1 %cmp1, label %if.then2, label %if.end

if.then2:                                         ; preds = %if.else
  store double 1.000000e+00, double* %retval, align 8
  br label %return

if.end:                                           ; preds = %if.else
  br label %if.end3

if.end3:                                          ; preds = %if.end
  store double 0.000000e+00, double* %fmean1, align 8
  store double 0.000000e+00, double* %fmean2, align 8
  store i32 0, i32* %x, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.end3
  %2 = load i32, i32* %x, align 4
  %3 = load i32, i32* %ARRAY1_SIZE.addr, align 4
  %cmp4 = icmp ult i32 %2, %3
  br i1 %cmp4, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %4 = load double*, double** %ARRAY1.addr, align 4
  %5 = load i32, i32* %x, align 4
  %arrayidx = getelementptr inbounds double, double* %4, i32 %5
  %6 = load double, double* %arrayidx, align 8
  %7 = call double @llvm.fabs.f64(double %6) #7
  %cmpinf = fcmp one double %7, 0x7FF0000000000000
  %8 = zext i1 %cmpinf to i32
  %cmp5 = icmp eq i32 %8, 0
  br i1 %cmp5, label %if.then6, label %if.end7

if.then6:                                         ; preds = %for.body
  %call = call i32 @puts(i8* getelementptr inbounds ([63 x i8], [63 x i8]* @.str, i32 0, i32 0))
  call void @exit(i32 1) #8
  unreachable

if.end7:                                          ; preds = %for.body
  %9 = load double*, double** %ARRAY1.addr, align 4
  %10 = load i32, i32* %x, align 4
  %arrayidx8 = getelementptr inbounds double, double* %9, i32 %10
  %11 = load double, double* %arrayidx8, align 8
  %12 = load double, double* %fmean1, align 8
  %add = fadd double %12, %11
  store double %add, double* %fmean1, align 8
  br label %for.inc

for.inc:                                          ; preds = %if.end7
  %13 = load i32, i32* %x, align 4
  %inc = add i32 %13, 1
  store i32 %inc, i32* %x, align 4
  br label %for.cond

for.end:                                          ; preds = %for.cond
  %14 = load i32, i32* %ARRAY1_SIZE.addr, align 4
  %conv = uitofp i32 %14 to double
  %15 = load double, double* %fmean1, align 8
  %div = fdiv double %15, %conv
  store double %div, double* %fmean1, align 8
  store i32 0, i32* %x9, align 4
  br label %for.cond10

for.cond10:                                       ; preds = %for.inc23, %for.end
  %16 = load i32, i32* %x9, align 4
  %17 = load i32, i32* %ARRAY2_SIZE.addr, align 4
  %cmp11 = icmp ult i32 %16, %17
  br i1 %cmp11, label %for.body13, label %for.end25

for.body13:                                       ; preds = %for.cond10
  %18 = load double*, double** %ARRAY2.addr, align 4
  %19 = load i32, i32* %x9, align 4
  %arrayidx14 = getelementptr inbounds double, double* %18, i32 %19
  %20 = load double, double* %arrayidx14, align 8
  %21 = call double @llvm.fabs.f64(double %20) #7
  %cmpinf15 = fcmp one double %21, 0x7FF0000000000000
  %22 = zext i1 %cmpinf15 to i32
  %cmp16 = icmp eq i32 %22, 0
  br i1 %cmp16, label %if.then18, label %if.end20

if.then18:                                        ; preds = %for.body13
  %call19 = call i32 @puts(i8* getelementptr inbounds ([63 x i8], [63 x i8]* @.str.1, i32 0, i32 0))
  call void @exit(i32 1) #8
  unreachable

if.end20:                                         ; preds = %for.body13
  %23 = load double*, double** %ARRAY2.addr, align 4
  %24 = load i32, i32* %x9, align 4
  %arrayidx21 = getelementptr inbounds double, double* %23, i32 %24
  %25 = load double, double* %arrayidx21, align 8
  %26 = load double, double* %fmean2, align 8
  %add22 = fadd double %26, %25
  store double %add22, double* %fmean2, align 8
  br label %for.inc23

for.inc23:                                        ; preds = %if.end20
  %27 = load i32, i32* %x9, align 4
  %inc24 = add i32 %27, 1
  store i32 %inc24, i32* %x9, align 4
  br label %for.cond10

for.end25:                                        ; preds = %for.cond10
  %28 = load i32, i32* %ARRAY2_SIZE.addr, align 4
  %conv26 = uitofp i32 %28 to double
  %29 = load double, double* %fmean2, align 8
  %div27 = fdiv double %29, %conv26
  store double %div27, double* %fmean2, align 8
  %30 = load double, double* %fmean1, align 8
  %31 = load double, double* %fmean2, align 8
  %cmp28 = fcmp oeq double %30, %31
  br i1 %cmp28, label %if.then30, label %if.end31

if.then30:                                        ; preds = %for.end25
  store double 1.000000e+00, double* %retval, align 8
  br label %return

if.end31:                                         ; preds = %for.end25
  store double 0.000000e+00, double* %unbiased_sample_variance1, align 8
  store double 0.000000e+00, double* %unbiased_sample_variance2, align 8
  store i32 0, i32* %x32, align 4
  br label %for.cond33

for.cond33:                                       ; preds = %for.inc41, %if.end31
  %32 = load i32, i32* %x32, align 4
  %33 = load i32, i32* %ARRAY1_SIZE.addr, align 4
  %cmp34 = icmp ult i32 %32, %33
  br i1 %cmp34, label %for.body36, label %for.end43

for.body36:                                       ; preds = %for.cond33
  %34 = load double*, double** %ARRAY1.addr, align 4
  %35 = load i32, i32* %x32, align 4
  %arrayidx37 = getelementptr inbounds double, double* %34, i32 %35
  %36 = load double, double* %arrayidx37, align 8
  %37 = load double, double* %fmean1, align 8
  %sub = fsub double %36, %37
  %38 = load double*, double** %ARRAY1.addr, align 4
  %39 = load i32, i32* %x32, align 4
  %arrayidx38 = getelementptr inbounds double, double* %38, i32 %39
  %40 = load double, double* %arrayidx38, align 8
  %41 = load double, double* %fmean1, align 8
  %sub39 = fsub double %40, %41
  %mul = fmul double %sub, %sub39
  %42 = load double, double* %unbiased_sample_variance1, align 8
  %add40 = fadd double %42, %mul
  store double %add40, double* %unbiased_sample_variance1, align 8
  br label %for.inc41

for.inc41:                                        ; preds = %for.body36
  %43 = load i32, i32* %x32, align 4
  %inc42 = add i32 %43, 1
  store i32 %inc42, i32* %x32, align 4
  br label %for.cond33

for.end43:                                        ; preds = %for.cond33
  store i32 0, i32* %x44, align 4
  br label %for.cond45

for.cond45:                                       ; preds = %for.inc55, %for.end43
  %44 = load i32, i32* %x44, align 4
  %45 = load i32, i32* %ARRAY2_SIZE.addr, align 4
  %cmp46 = icmp ult i32 %44, %45
  br i1 %cmp46, label %for.body48, label %for.end57

for.body48:                                       ; preds = %for.cond45
  %46 = load double*, double** %ARRAY2.addr, align 4
  %47 = load i32, i32* %x44, align 4
  %arrayidx49 = getelementptr inbounds double, double* %46, i32 %47
  %48 = load double, double* %arrayidx49, align 8
  %49 = load double, double* %fmean2, align 8
  %sub50 = fsub double %48, %49
  %50 = load double*, double** %ARRAY2.addr, align 4
  %51 = load i32, i32* %x44, align 4
  %arrayidx51 = getelementptr inbounds double, double* %50, i32 %51
  %52 = load double, double* %arrayidx51, align 8
  %53 = load double, double* %fmean2, align 8
  %sub52 = fsub double %52, %53
  %mul53 = fmul double %sub50, %sub52
  %54 = load double, double* %unbiased_sample_variance2, align 8
  %add54 = fadd double %54, %mul53
  store double %add54, double* %unbiased_sample_variance2, align 8
  br label %for.inc55

for.inc55:                                        ; preds = %for.body48
  %55 = load i32, i32* %x44, align 4
  %inc56 = add i32 %55, 1
  store i32 %inc56, i32* %x44, align 4
  br label %for.cond45

for.end57:                                        ; preds = %for.cond45
  %56 = load double, double* %unbiased_sample_variance1, align 8
  %57 = load i32, i32* %ARRAY1_SIZE.addr, align 4
  %sub58 = sub i32 %57, 1
  %conv59 = uitofp i32 %sub58 to double
  %div60 = fdiv double %56, %conv59
  store double %div60, double* %unbiased_sample_variance1, align 8
  %58 = load double, double* %unbiased_sample_variance2, align 8
  %59 = load i32, i32* %ARRAY2_SIZE.addr, align 4
  %sub61 = sub i32 %59, 1
  %conv62 = uitofp i32 %sub61 to double
  %div63 = fdiv double %58, %conv62
  store double %div63, double* %unbiased_sample_variance2, align 8
  %60 = load double, double* %fmean1, align 8
  %61 = load double, double* %fmean2, align 8
  %sub64 = fsub double %60, %61
  %62 = load double, double* %unbiased_sample_variance1, align 8
  %63 = load i32, i32* %ARRAY1_SIZE.addr, align 4
  %conv65 = uitofp i32 %63 to double
  %div66 = fdiv double %62, %conv65
  %64 = load double, double* %unbiased_sample_variance2, align 8
  %65 = load i32, i32* %ARRAY2_SIZE.addr, align 4
  %conv67 = uitofp i32 %65 to double
  %div68 = fdiv double %64, %conv67
  %add69 = fadd double %div66, %div68
  %66 = call double @llvm.sqrt.f64(double %add69)
  %div70 = fdiv double %sub64, %66
  store double %div70, double* %WELCH_T_STATISTIC, align 8
  %67 = load double, double* %unbiased_sample_variance1, align 8
  %68 = load i32, i32* %ARRAY1_SIZE.addr, align 4
  %conv71 = uitofp i32 %68 to double
  %div72 = fdiv double %67, %conv71
  %69 = load double, double* %unbiased_sample_variance2, align 8
  %70 = load i32, i32* %ARRAY2_SIZE.addr, align 4
  %conv73 = uitofp i32 %70 to double
  %div74 = fdiv double %69, %conv73
  %add75 = fadd double %div72, %div74
  %71 = call double @llvm.pow.f64(double %add75, double 2.000000e+00)
  %72 = load double, double* %unbiased_sample_variance1, align 8
  %73 = load double, double* %unbiased_sample_variance1, align 8
  %mul76 = fmul double %72, %73
  %74 = load i32, i32* %ARRAY1_SIZE.addr, align 4
  %75 = load i32, i32* %ARRAY1_SIZE.addr, align 4
  %mul77 = mul i32 %74, %75
  %76 = load i32, i32* %ARRAY1_SIZE.addr, align 4
  %sub78 = sub i32 %76, 1
  %mul79 = mul i32 %mul77, %sub78
  %conv80 = uitofp i32 %mul79 to double
  %div81 = fdiv double %mul76, %conv80
  %77 = load double, double* %unbiased_sample_variance2, align 8
  %78 = load double, double* %unbiased_sample_variance2, align 8
  %mul82 = fmul double %77, %78
  %79 = load i32, i32* %ARRAY2_SIZE.addr, align 4
  %80 = load i32, i32* %ARRAY2_SIZE.addr, align 4
  %mul83 = mul i32 %79, %80
  %81 = load i32, i32* %ARRAY2_SIZE.addr, align 4
  %sub84 = sub i32 %81, 1
  %mul85 = mul i32 %mul83, %sub84
  %conv86 = uitofp i32 %mul85 to double
  %div87 = fdiv double %mul82, %conv86
  %add88 = fadd double %div81, %div87
  %div89 = fdiv double %71, %add88
  store double %div89, double* %DEGREES_OF_FREEDOM, align 8
  %82 = load double, double* %DEGREES_OF_FREEDOM, align 8
  %div90 = fdiv double %82, 2.000000e+00
  store double %div90, double* %a, align 8
  %83 = load double, double* %DEGREES_OF_FREEDOM, align 8
  %84 = load double, double* %WELCH_T_STATISTIC, align 8
  %85 = load double, double* %WELCH_T_STATISTIC, align 8
  %mul91 = fmul double %84, %85
  %86 = load double, double* %DEGREES_OF_FREEDOM, align 8
  %add92 = fadd double %mul91, %86
  %div93 = fdiv double %83, %add92
  store double %div93, double* %value, align 8
  %87 = load double, double* %value, align 8
  %88 = call double @llvm.fabs.f64(double %87) #7
  %cmpinf94 = fcmp oeq double %88, 0x7FF0000000000000
  br i1 %cmpinf94, label %if.then100, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %for.end57
  %89 = load double, double* %value, align 8
  %cmp97 = fcmp uno double %89, %89
  br i1 %cmp97, label %if.then100, label %if.end101

if.then100:                                       ; preds = %lor.lhs.false, %for.end57
  store double 1.000000e+00, double* %retval, align 8
  br label %return

if.end101:                                        ; preds = %lor.lhs.false
  %90 = load double, double* %value, align 8
  %91 = call double @llvm.fabs.f64(double %90) #7
  %cmpinf102 = fcmp oeq double %91, 0x7FF0000000000000
  %92 = zext i1 %cmpinf102 to i32
  %cmp103 = icmp ne i32 %92, 0
  br i1 %cmp103, label %if.then109, label %lor.lhs.false105

lor.lhs.false105:                                 ; preds = %if.end101
  %93 = load double, double* %value, align 8
  %cmp106 = fcmp uno double %93, %93
  %94 = zext i1 %cmp106 to i32
  %cmp107 = icmp ne i32 %94, 0
  br i1 %cmp107, label %if.then109, label %if.end110

if.then109:                                       ; preds = %lor.lhs.false105, %if.end101
  store double 1.000000e+00, double* %retval, align 8
  br label %return

if.end110:                                        ; preds = %lor.lhs.false105
  %95 = load double, double* %a, align 8
  %conv111 = fpext double %95 to fp128
  %call112 = call fp128 @lgammal(fp128 %conv111) #9
  %add113 = fadd fp128 %call112, 0xLD0000000000000003FFE250D048E7A1B
  %96 = load double, double* %a, align 8
  %add114 = fadd double %96, 5.000000e-01
  %conv115 = fpext double %add114 to fp128
  %call116 = call fp128 @lgammal(fp128 %conv115) #9
  %sub117 = fsub fp128 %add113, %call116
  %conv118 = fptrunc fp128 %sub117 to double
  store double %conv118, double* %beta, align 8
  store double 1.000000e-15, double* %acu, align 8
  %97 = load double, double* %a, align 8
  %cmp119 = fcmp ole double %97, 0.000000e+00
  br i1 %cmp119, label %if.then121, label %if.end122

if.then121:                                       ; preds = %if.end110
  br label %if.end122

if.end122:                                        ; preds = %if.then121, %if.end110
  %98 = load double, double* %value, align 8
  %cmp123 = fcmp olt double %98, 0.000000e+00
  br i1 %cmp123, label %if.then128, label %lor.lhs.false125

lor.lhs.false125:                                 ; preds = %if.end122
  %99 = load double, double* %value, align 8
  %cmp126 = fcmp olt double 1.000000e+00, %99
  br i1 %cmp126, label %if.then128, label %if.end129

if.then128:                                       ; preds = %lor.lhs.false125, %if.end122
  %100 = load double, double* %value, align 8
  store double %100, double* %retval, align 8
  br label %return

if.end129:                                        ; preds = %lor.lhs.false125
  %101 = load double, double* %value, align 8
  %cmp130 = fcmp oeq double %101, 0.000000e+00
  br i1 %cmp130, label %if.then135, label %lor.lhs.false132

lor.lhs.false132:                                 ; preds = %if.end129
  %102 = load double, double* %value, align 8
  %cmp133 = fcmp oeq double %102, 1.000000e+00
  br i1 %cmp133, label %if.then135, label %if.end136

if.then135:                                       ; preds = %lor.lhs.false132, %if.end129
  %103 = load double, double* %value, align 8
  store double %103, double* %retval, align 8
  br label %return

if.end136:                                        ; preds = %lor.lhs.false132
  %104 = load double, double* %a, align 8
  %add137 = fadd double %104, 5.000000e-01
  store double %add137, double* %psq, align 8
  %105 = load double, double* %value, align 8
  %sub138 = fsub double 1.000000e+00, %105
  store double %sub138, double* %cx, align 8
  %106 = load double, double* %a, align 8
  %107 = load double, double* %psq, align 8
  %108 = load double, double* %value, align 8
  %mul139 = fmul double %107, %108
  %cmp140 = fcmp olt double %106, %mul139
  br i1 %cmp140, label %if.then142, label %if.else143

if.then142:                                       ; preds = %if.end136
  %109 = load double, double* %cx, align 8
  store double %109, double* %xx, align 8
  %110 = load double, double* %value, align 8
  store double %110, double* %cx, align 8
  store double 5.000000e-01, double* %pp, align 8
  %111 = load double, double* %a, align 8
  store double %111, double* %qq, align 8
  store i32 1, i32* %indx, align 4
  br label %if.end144

if.else143:                                       ; preds = %if.end136
  %112 = load double, double* %value, align 8
  store double %112, double* %xx, align 8
  %113 = load double, double* %a, align 8
  store double %113, double* %pp, align 8
  store double 5.000000e-01, double* %qq, align 8
  store i32 0, i32* %indx, align 4
  br label %if.end144

if.end144:                                        ; preds = %if.else143, %if.then142
  store double 1.000000e+00, double* %term, align 8
  store double 1.000000e+00, double* %ai, align 8
  store double 1.000000e+00, double* %value, align 8
  %114 = load double, double* %qq, align 8
  %115 = load double, double* %cx, align 8
  %116 = load double, double* %psq, align 8
  %mul145 = fmul double %115, %116
  %add146 = fadd double %114, %mul145
  %conv147 = fptosi double %add146 to i32
  store i32 %conv147, i32* %ns, align 4
  %117 = load double, double* %xx, align 8
  %118 = load double, double* %cx, align 8
  %div148 = fdiv double %117, %118
  store double %div148, double* %rx, align 8
  %119 = load double, double* %qq, align 8
  %120 = load double, double* %ai, align 8
  %sub149 = fsub double %119, %120
  store double %sub149, double* %temp, align 8
  %121 = load i32, i32* %ns, align 4
  %cmp150 = icmp eq i32 %121, 0
  br i1 %cmp150, label %if.then152, label %if.end153

if.then152:                                       ; preds = %if.end144
  %122 = load double, double* %xx, align 8
  store double %122, double* %rx, align 8
  br label %if.end153

if.end153:                                        ; preds = %if.then152, %if.end144
  br label %for.cond154

for.cond154:                                      ; preds = %if.end189, %if.end153
  %123 = load double, double* %term, align 8
  %124 = load double, double* %temp, align 8
  %mul155 = fmul double %123, %124
  %125 = load double, double* %rx, align 8
  %mul156 = fmul double %mul155, %125
  %126 = load double, double* %pp, align 8
  %127 = load double, double* %ai, align 8
  %add157 = fadd double %126, %127
  %div158 = fdiv double %mul156, %add157
  store double %div158, double* %term, align 8
  %128 = load double, double* %value, align 8
  %129 = load double, double* %term, align 8
  %add159 = fadd double %128, %129
  store double %add159, double* %value, align 8
  %130 = load double, double* %term, align 8
  %131 = call double @llvm.fabs.f64(double %130)
  store double %131, double* %temp, align 8
  %132 = load double, double* %temp, align 8
  %cmp160 = fcmp ole double %132, 1.000000e-15
  br i1 %cmp160, label %land.lhs.true, label %if.end176

land.lhs.true:                                    ; preds = %for.cond154
  %133 = load double, double* %temp, align 8
  %134 = load double, double* %value, align 8
  %mul162 = fmul double 1.000000e-15, %134
  %cmp163 = fcmp ole double %133, %mul162
  br i1 %cmp163, label %if.then165, label %if.end176

if.then165:                                       ; preds = %land.lhs.true
  %135 = load double, double* %value, align 8
  %136 = load double, double* %pp, align 8
  %137 = load double, double* %xx, align 8
  %138 = call double @llvm.log.f64(double %137)
  %mul166 = fmul double %136, %138
  %139 = load double, double* %qq, align 8
  %sub167 = fsub double %139, 1.000000e+00
  %140 = load double, double* %cx, align 8
  %141 = call double @llvm.log.f64(double %140)
  %mul168 = fmul double %sub167, %141
  %add169 = fadd double %mul166, %mul168
  %142 = load double, double* %beta, align 8
  %sub170 = fsub double %add169, %142
  %143 = call double @llvm.exp.f64(double %sub170)
  %mul171 = fmul double %135, %143
  %144 = load double, double* %pp, align 8
  %div172 = fdiv double %mul171, %144
  store double %div172, double* %value, align 8
  %145 = load i32, i32* %indx, align 4
  %tobool = icmp ne i32 %145, 0
  br i1 %tobool, label %if.then173, label %if.end175

if.then173:                                       ; preds = %if.then165
  %146 = load double, double* %value, align 8
  %sub174 = fsub double 1.000000e+00, %146
  store double %sub174, double* %value, align 8
  br label %if.end175

if.end175:                                        ; preds = %if.then173, %if.then165
  br label %for.end190

if.end176:                                        ; preds = %land.lhs.true, %for.cond154
  %147 = load double, double* %ai, align 8
  %add177 = fadd double %147, 1.000000e+00
  store double %add177, double* %ai, align 8
  %148 = load i32, i32* %ns, align 4
  %sub178 = sub nsw i32 %148, 1
  store i32 %sub178, i32* %ns, align 4
  %149 = load i32, i32* %ns, align 4
  %cmp179 = icmp sle i32 0, %149
  br i1 %cmp179, label %if.then181, label %if.else187

if.then181:                                       ; preds = %if.end176
  %150 = load double, double* %qq, align 8
  %151 = load double, double* %ai, align 8
  %sub182 = fsub double %150, %151
  store double %sub182, double* %temp, align 8
  %152 = load i32, i32* %ns, align 4
  %cmp183 = icmp eq i32 %152, 0
  br i1 %cmp183, label %if.then185, label %if.end186

if.then185:                                       ; preds = %if.then181
  %153 = load double, double* %xx, align 8
  store double %153, double* %rx, align 8
  br label %if.end186

if.end186:                                        ; preds = %if.then185, %if.then181
  br label %if.end189

if.else187:                                       ; preds = %if.end176
  %154 = load double, double* %psq, align 8
  store double %154, double* %temp, align 8
  %155 = load double, double* %psq, align 8
  %add188 = fadd double %155, 1.000000e+00
  store double %add188, double* %psq, align 8
  br label %if.end189

if.end189:                                        ; preds = %if.else187, %if.end186
  br label %for.cond154

for.end190:                                       ; preds = %if.end175
  %156 = load double, double* %value, align 8
  store double %156, double* %retval, align 8
  br label %return

return:                                           ; preds = %for.end190, %if.then135, %if.then128, %if.then109, %if.then100, %if.then30, %if.then2, %if.then
  %157 = load double, double* %retval, align 8
  ret double %157
}

; Function Attrs: nounwind readnone speculatable willreturn
declare double @llvm.fabs.f64(double %0) #1

declare i32 @puts(i8* %0) #2

; Function Attrs: noreturn
declare void @exit(i32 %0) #3

; Function Attrs: nounwind readnone speculatable willreturn
declare double @llvm.sqrt.f64(double %0) #1

; Function Attrs: nounwind readnone speculatable willreturn
declare double @llvm.pow.f64(double %0, double %1) #1

; Function Attrs: nounwind
declare fp128 @lgammal(fp128 %0) #4

; Function Attrs: nounwind readnone speculatable willreturn
declare double @llvm.log.f64(double %0) #1

; Function Attrs: nounwind readnone speculatable willreturn
declare double @llvm.exp.f64(double %0) #1

; Function Attrs: noinline nounwind optnone
define hidden i32 @main() #0 {
entry:
  %retval = alloca i32, align 4
  %d1 = alloca [15 x double], align 16
  %d2 = alloca [15 x double], align 16
  %d3 = alloca [10 x double], align 16
  %d4 = alloca [20 x double], align 16
  %d5 = alloca [10 x double], align 16
  %d6 = alloca [20 x double], align 16
  %d7 = alloca [6 x double], align 16
  %d8 = alloca [6 x double], align 16
  %x = alloca [4 x double], align 16
  %y = alloca [3 x double], align 16
  %v1 = alloca [3 x double], align 16
  %v2 = alloca [3 x double], align 16
  %s1 = alloca [2 x double], align 16
  %s2 = alloca [2 x double], align 16
  %z1 = alloca [3 x double], align 16
  %z2 = alloca [3 x double], align 16
  %CORRECT_ANSWERS = alloca [8 x double], align 16
  %pvalue = alloca double, align 8
  %error = alloca double, align 8
  store i32 0, i32* %retval, align 4
  %0 = bitcast [15 x double]* %d1 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 16 %0, i8* align 16 bitcast ([15 x double]* @__const.main.d1 to i8*), i32 120, i1 false)
  %1 = bitcast [15 x double]* %d2 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 16 %1, i8* align 16 bitcast ([15 x double]* @__const.main.d2 to i8*), i32 120, i1 false)
  %2 = bitcast [10 x double]* %d3 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 16 %2, i8* align 16 bitcast ([10 x double]* @__const.main.d3 to i8*), i32 80, i1 false)
  %3 = bitcast [20 x double]* %d4 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 16 %3, i8* align 16 bitcast ([20 x double]* @__const.main.d4 to i8*), i32 160, i1 false)
  %4 = bitcast [10 x double]* %d5 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 16 %4, i8* align 16 bitcast ([10 x double]* @__const.main.d5 to i8*), i32 80, i1 false)
  %5 = bitcast [20 x double]* %d6 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 16 %5, i8* align 16 bitcast ([20 x double]* @__const.main.d6 to i8*), i32 160, i1 false)
  %6 = bitcast [6 x double]* %d7 to i8*
  call void @llvm.memset.p0i8.i32(i8* align 16 %6, i8 0, i32 48, i1 false)
  %7 = bitcast i8* %6 to [6 x double]*
  %8 = getelementptr inbounds [6 x double], [6 x double]* %7, i32 0, i32 0
  store double 3.002000e+01, double* %8, align 16
  %9 = getelementptr inbounds [6 x double], [6 x double]* %7, i32 0, i32 1
  store double 2.999000e+01, double* %9, align 8
  %10 = getelementptr inbounds [6 x double], [6 x double]* %7, i32 0, i32 2
  store double 3.011000e+01, double* %10, align 16
  %11 = getelementptr inbounds [6 x double], [6 x double]* %7, i32 0, i32 3
  store double 2.997000e+01, double* %11, align 8
  %12 = getelementptr inbounds [6 x double], [6 x double]* %7, i32 0, i32 4
  store double 3.001000e+01, double* %12, align 16
  %13 = getelementptr inbounds [6 x double], [6 x double]* %7, i32 0, i32 5
  store double 2.999000e+01, double* %13, align 8
  %14 = bitcast [6 x double]* %d8 to i8*
  call void @llvm.memset.p0i8.i32(i8* align 16 %14, i8 0, i32 48, i1 false)
  %15 = bitcast i8* %14 to [6 x double]*
  %16 = getelementptr inbounds [6 x double], [6 x double]* %15, i32 0, i32 0
  store double 2.989000e+01, double* %16, align 16
  %17 = getelementptr inbounds [6 x double], [6 x double]* %15, i32 0, i32 1
  store double 2.993000e+01, double* %17, align 8
  %18 = getelementptr inbounds [6 x double], [6 x double]* %15, i32 0, i32 2
  store double 2.972000e+01, double* %18, align 16
  %19 = getelementptr inbounds [6 x double], [6 x double]* %15, i32 0, i32 3
  store double 2.998000e+01, double* %19, align 8
  %20 = getelementptr inbounds [6 x double], [6 x double]* %15, i32 0, i32 4
  store double 3.002000e+01, double* %20, align 16
  %21 = getelementptr inbounds [6 x double], [6 x double]* %15, i32 0, i32 5
  store double 2.998000e+01, double* %21, align 8
  %22 = bitcast [4 x double]* %x to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 16 %22, i8* align 16 bitcast ([4 x double]* @__const.main.x to i8*), i32 32, i1 false)
  %23 = bitcast [3 x double]* %y to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 16 %23, i8* align 16 bitcast ([3 x double]* @__const.main.y to i8*), i32 24, i1 false)
  %24 = bitcast [3 x double]* %v1 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 16 %24, i8* align 16 bitcast ([3 x double]* @__const.main.v1 to i8*), i32 24, i1 false)
  %25 = bitcast [3 x double]* %v2 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 16 %25, i8* align 16 bitcast ([3 x double]* @__const.main.v2 to i8*), i32 24, i1 false)
  %26 = bitcast [2 x double]* %s1 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 16 %26, i8* align 16 bitcast ([2 x double]* @__const.main.s1 to i8*), i32 16, i1 false)
  %27 = bitcast [2 x double]* %s2 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 16 %27, i8* align 16 bitcast ([2 x double]* @__const.main.s2 to i8*), i32 16, i1 false)
  %28 = bitcast [3 x double]* %z1 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 16 %28, i8* align 16 bitcast ([3 x double]* @__const.main.z1 to i8*), i32 24, i1 false)
  %29 = bitcast [3 x double]* %z2 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 16 %29, i8* align 16 bitcast ([3 x double]* @__const.main.z2 to i8*), i32 24, i1 false)
  %30 = bitcast [8 x double]* %CORRECT_ANSWERS to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 16 %30, i8* align 16 bitcast ([8 x double]* @__const.main.CORRECT_ANSWERS to i8*), i32 64, i1 false)
  %arraydecay = getelementptr inbounds [15 x double], [15 x double]* %d1, i32 0, i32 0
  %arraydecay1 = getelementptr inbounds [15 x double], [15 x double]* %d2, i32 0, i32 0
  %call = call double @Pvalue(double* %arraydecay, i32 15, double* %arraydecay1, i32 15)
  store double %call, double* %pvalue, align 8
  %31 = load double, double* %pvalue, align 8
  %arrayidx = getelementptr inbounds [8 x double], [8 x double]* %CORRECT_ANSWERS, i32 0, i32 0
  %32 = load double, double* %arrayidx, align 16
  %sub = fsub double %31, %32
  %33 = call double @llvm.fabs.f64(double %sub)
  store double %33, double* %error, align 8
  %34 = load double, double* %pvalue, align 8
  %call2 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([26 x i8], [26 x i8]* @.str.2, i32 0, i32 0), double %34)
  %arraydecay3 = getelementptr inbounds [10 x double], [10 x double]* %d3, i32 0, i32 0
  %arraydecay4 = getelementptr inbounds [20 x double], [20 x double]* %d4, i32 0, i32 0
  %call5 = call double @Pvalue(double* %arraydecay3, i32 10, double* %arraydecay4, i32 20)
  store double %call5, double* %pvalue, align 8
  %35 = load double, double* %pvalue, align 8
  %arrayidx6 = getelementptr inbounds [8 x double], [8 x double]* %CORRECT_ANSWERS, i32 0, i32 1
  %36 = load double, double* %arrayidx6, align 8
  %sub7 = fsub double %35, %36
  %37 = call double @llvm.fabs.f64(double %sub7)
  %38 = load double, double* %error, align 8
  %add = fadd double %38, %37
  store double %add, double* %error, align 8
  %39 = load double, double* %pvalue, align 8
  %call8 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([26 x i8], [26 x i8]* @.str.3, i32 0, i32 0), double %39)
  %arraydecay9 = getelementptr inbounds [10 x double], [10 x double]* %d5, i32 0, i32 0
  %arraydecay10 = getelementptr inbounds [20 x double], [20 x double]* %d6, i32 0, i32 0
  %call11 = call double @Pvalue(double* %arraydecay9, i32 10, double* %arraydecay10, i32 20)
  store double %call11, double* %pvalue, align 8
  %40 = load double, double* %pvalue, align 8
  %arrayidx12 = getelementptr inbounds [8 x double], [8 x double]* %CORRECT_ANSWERS, i32 0, i32 2
  %41 = load double, double* %arrayidx12, align 16
  %sub13 = fsub double %40, %41
  %42 = call double @llvm.fabs.f64(double %sub13)
  %43 = load double, double* %error, align 8
  %add14 = fadd double %43, %42
  store double %add14, double* %error, align 8
  %44 = load double, double* %pvalue, align 8
  %call15 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([26 x i8], [26 x i8]* @.str.4, i32 0, i32 0), double %44)
  %arraydecay16 = getelementptr inbounds [6 x double], [6 x double]* %d7, i32 0, i32 0
  %arraydecay17 = getelementptr inbounds [6 x double], [6 x double]* %d8, i32 0, i32 0
  %call18 = call double @Pvalue(double* %arraydecay16, i32 6, double* %arraydecay17, i32 6)
  store double %call18, double* %pvalue, align 8
  %45 = load double, double* %pvalue, align 8
  %call19 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([26 x i8], [26 x i8]* @.str.5, i32 0, i32 0), double %45)
  %46 = load double, double* %pvalue, align 8
  %arrayidx20 = getelementptr inbounds [8 x double], [8 x double]* %CORRECT_ANSWERS, i32 0, i32 3
  %47 = load double, double* %arrayidx20, align 8
  %sub21 = fsub double %46, %47
  %48 = call double @llvm.fabs.f64(double %sub21)
  %49 = load double, double* %error, align 8
  %add22 = fadd double %49, %48
  store double %add22, double* %error, align 8
  %arraydecay23 = getelementptr inbounds [4 x double], [4 x double]* %x, i32 0, i32 0
  %arraydecay24 = getelementptr inbounds [3 x double], [3 x double]* %y, i32 0, i32 0
  %call25 = call double @Pvalue(double* %arraydecay23, i32 4, double* %arraydecay24, i32 3)
  store double %call25, double* %pvalue, align 8
  %50 = load double, double* %pvalue, align 8
  %arrayidx26 = getelementptr inbounds [8 x double], [8 x double]* %CORRECT_ANSWERS, i32 0, i32 4
  %51 = load double, double* %arrayidx26, align 16
  %sub27 = fsub double %50, %51
  %52 = call double @llvm.fabs.f64(double %sub27)
  %53 = load double, double* %error, align 8
  %add28 = fadd double %53, %52
  store double %add28, double* %error, align 8
  %54 = load double, double* %pvalue, align 8
  %call29 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([26 x i8], [26 x i8]* @.str.6, i32 0, i32 0), double %54)
  %arraydecay30 = getelementptr inbounds [3 x double], [3 x double]* %v1, i32 0, i32 0
  %arraydecay31 = getelementptr inbounds [3 x double], [3 x double]* %v2, i32 0, i32 0
  %call32 = call double @Pvalue(double* %arraydecay30, i32 3, double* %arraydecay31, i32 3)
  store double %call32, double* %pvalue, align 8
  %55 = load double, double* %pvalue, align 8
  %arrayidx33 = getelementptr inbounds [8 x double], [8 x double]* %CORRECT_ANSWERS, i32 0, i32 5
  %56 = load double, double* %arrayidx33, align 8
  %sub34 = fsub double %55, %56
  %57 = call double @llvm.fabs.f64(double %sub34)
  %58 = load double, double* %error, align 8
  %add35 = fadd double %58, %57
  store double %add35, double* %error, align 8
  %59 = load double, double* %pvalue, align 8
  %call36 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([26 x i8], [26 x i8]* @.str.7, i32 0, i32 0), double %59)
  %arraydecay37 = getelementptr inbounds [2 x double], [2 x double]* %s1, i32 0, i32 0
  %arraydecay38 = getelementptr inbounds [2 x double], [2 x double]* %s2, i32 0, i32 0
  %call39 = call double @Pvalue(double* %arraydecay37, i32 2, double* %arraydecay38, i32 2)
  store double %call39, double* %pvalue, align 8
  %60 = load double, double* %pvalue, align 8
  %arrayidx40 = getelementptr inbounds [8 x double], [8 x double]* %CORRECT_ANSWERS, i32 0, i32 6
  %61 = load double, double* %arrayidx40, align 16
  %sub41 = fsub double %60, %61
  %62 = call double @llvm.fabs.f64(double %sub41)
  %63 = load double, double* %error, align 8
  %add42 = fadd double %63, %62
  store double %add42, double* %error, align 8
  %64 = load double, double* %pvalue, align 8
  %call43 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([26 x i8], [26 x i8]* @.str.8, i32 0, i32 0), double %64)
  %arraydecay44 = getelementptr inbounds [3 x double], [3 x double]* %z1, i32 0, i32 0
  %arraydecay45 = getelementptr inbounds [3 x double], [3 x double]* %z2, i32 0, i32 0
  %call46 = call double @Pvalue(double* %arraydecay44, i32 3, double* %arraydecay45, i32 3)
  store double %call46, double* %pvalue, align 8
  %65 = load double, double* %pvalue, align 8
  %arrayidx47 = getelementptr inbounds [8 x double], [8 x double]* %CORRECT_ANSWERS, i32 0, i32 7
  %66 = load double, double* %arrayidx47, align 8
  %sub48 = fsub double %65, %66
  %67 = call double @llvm.fabs.f64(double %sub48)
  %68 = load double, double* %error, align 8
  %add49 = fadd double %68, %67
  store double %add49, double* %error, align 8
  %69 = load double, double* %pvalue, align 8
  %call50 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([26 x i8], [26 x i8]* @.str.9, i32 0, i32 0), double %69)
  %70 = load double, double* %error, align 8
  %call51 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([28 x i8], [28 x i8]* @.str.10, i32 0, i32 0), double %70)
  ret i32 0
}

; Function Attrs: argmemonly nounwind willreturn
declare void @llvm.memcpy.p0i8.p0i8.i32(i8* noalias nocapture writeonly %0, i8* noalias nocapture readonly %1, i32 %2, i1 immarg %3) #5

; Function Attrs: argmemonly nounwind willreturn writeonly
declare void @llvm.memset.p0i8.i32(i8* nocapture writeonly %0, i8 %1, i32 %2, i1 immarg %3) #6

declare i32 @printf(i8* %0, ...) #2

attributes #0 = { noinline nounwind optnone "correctly-rounded-divide-sqrt-fp-math"="false" "disable-tail-calls"="false" "frame-pointer"="none" "less-precise-fpmad"="false" "min-legal-vector-width"="0" "no-infs-fp-math"="false" "no-jump-tables"="false" "no-nans-fp-math"="false" "no-signed-zeros-fp-math"="false" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="generic" "unsafe-fp-math"="false" "use-soft-float"="false" }
attributes #1 = { nounwind readnone speculatable willreturn }
attributes #2 = { "correctly-rounded-divide-sqrt-fp-math"="false" "disable-tail-calls"="false" "frame-pointer"="none" "less-precise-fpmad"="false" "no-infs-fp-math"="false" "no-nans-fp-math"="false" "no-signed-zeros-fp-math"="false" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="generic" "unsafe-fp-math"="false" "use-soft-float"="false" }
attributes #3 = { noreturn "correctly-rounded-divide-sqrt-fp-math"="false" "disable-tail-calls"="false" "frame-pointer"="none" "less-precise-fpmad"="false" "no-infs-fp-math"="false" "no-nans-fp-math"="false" "no-signed-zeros-fp-math"="false" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="generic" "unsafe-fp-math"="false" "use-soft-float"="false" }
attributes #4 = { nounwind "correctly-rounded-divide-sqrt-fp-math"="false" "disable-tail-calls"="false" "frame-pointer"="none" "less-precise-fpmad"="false" "no-infs-fp-math"="false" "no-nans-fp-math"="false" "no-signed-zeros-fp-math"="false" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="generic" "unsafe-fp-math"="false" "use-soft-float"="false" }
attributes #5 = { argmemonly nounwind willreturn }
attributes #6 = { argmemonly nounwind willreturn writeonly }
attributes #7 = { readnone }
attributes #8 = { noreturn }
attributes #9 = { nounwind }

!llvm.module.flags = !{!0}
!llvm.ident = !{!1}

!0 = !{i32 1, !"wchar_size", i32 4}
!1 = !{!"clang version 11.0.0 (https://github.com/Jacarte/llvm-project.git 0f6dea67136cc1e0b3d200eb2bb165628970c44b)"}

#########################################################
; exiting Souper's runOnFunction() for Pvalue()
rescanning function after transformation was applied

; entering Souper's runOnFunction() for Pvalue()

; ModuleID = './Welchs_t-test.c.bc'
source_filename = "./Welchs_t-test.c"
target datalayout = "e-m:e-p:32:32-i64:64-n32:64-S128"
target triple = "wasm32-unknown-wasi"

@.str = private unnamed_addr constant [63 x i8] c"Got a non-finite number in 1st array, can't calculate P-value.\00", align 1
@.str.1 = private unnamed_addr constant [63 x i8] c"Got a non-finite number in 2nd array, can't calculate P-value.\00", align 1
@__const.main.d1 = private unnamed_addr constant [15 x double] [double 2.750000e+01, double 2.100000e+01, double 1.900000e+01, double 2.360000e+01, double 1.700000e+01, double 1.790000e+01, double 1.690000e+01, double 2.010000e+01, double 2.190000e+01, double 2.260000e+01, double 2.310000e+01, double 1.960000e+01, double 1.900000e+01, double 2.170000e+01, double 2.140000e+01], align 16
@__const.main.d2 = private unnamed_addr constant [15 x double] [double 2.710000e+01, double 2.200000e+01, double 2.080000e+01, double 2.340000e+01, double 2.340000e+01, double 2.350000e+01, double 2.580000e+01, double 2.200000e+01, double 2.480000e+01, double 2.020000e+01, double 2.190000e+01, double 2.210000e+01, double 2.290000e+01, double 2.050000e+01, double 2.440000e+01], align 16
@__const.main.d3 = private unnamed_addr constant [10 x double] [double 1.720000e+01, double 2.090000e+01, double 2.260000e+01, double 1.810000e+01, double 2.170000e+01, double 2.140000e+01, double 2.350000e+01, double 2.420000e+01, double 1.470000e+01, double 2.180000e+01], align 16
@__const.main.d4 = private unnamed_addr constant [20 x double] [double 2.150000e+01, double 2.280000e+01, double 2.100000e+01, double 2.300000e+01, double 2.160000e+01, double 2.360000e+01, double 2.250000e+01, double 2.070000e+01, double 2.340000e+01, double 2.180000e+01, double 2.070000e+01, double 2.170000e+01, double 2.150000e+01, double 2.250000e+01, double 2.360000e+01, double 2.150000e+01, double 2.250000e+01, double 2.350000e+01, double 2.150000e+01, double 2.180000e+01], align 16
@__const.main.d5 = private unnamed_addr constant [10 x double] [double 1.980000e+01, double 2.040000e+01, double 1.960000e+01, double 1.780000e+01, double 1.850000e+01, double 1.890000e+01, double 1.830000e+01, double 1.890000e+01, double 1.950000e+01, double 2.200000e+01], align 16
@__const.main.d6 = private unnamed_addr constant [20 x double] [double 2.820000e+01, double 2.660000e+01, double 2.010000e+01, double 2.330000e+01, double 2.520000e+01, double 2.210000e+01, double 1.770000e+01, double 2.760000e+01, double 2.060000e+01, double 1.370000e+01, double 2.320000e+01, double 1.750000e+01, double 2.060000e+01, double 1.800000e+01, double 2.390000e+01, double 2.160000e+01, double 2.430000e+01, double 2.040000e+01, double 2.400000e+01, double 1.320000e+01], align 16
@__const.main.x = private unnamed_addr constant [4 x double] [double 3.000000e+00, double 4.000000e+00, double 1.000000e+00, double 2.100000e+00], align 16
@__const.main.y = private unnamed_addr constant [3 x double] [double 4.902000e+02, double 3.400000e+02, double 4.339000e+02], align 16
@__const.main.v1 = private unnamed_addr constant [3 x double] [double 1.026800e-02, double 1.670000e-04, double 1.670000e-04], align 16
@__const.main.v2 = private unnamed_addr constant [3 x double] [double 1.592580e-01, double 1.362780e-01, double 1.223890e-01], align 16
@__const.main.s1 = private unnamed_addr constant [2 x double] [double 0x3FB1111111111111, double 0x3FC4A5294A5294A5], align 16
@__const.main.s2 = private unnamed_addr constant [2 x double] [double 1.000000e-01, double 4.000000e-02], align 16
@__const.main.z1 = private unnamed_addr constant [3 x double] [double 0x3FD90B21642C8591, double 0x3FDDDDDDDDDDDDDE, double 0.000000e+00], align 16
@__const.main.z2 = private unnamed_addr constant [3 x double] [double 0.000000e+00, double 0x3FDC9882B9310572, double 0.000000e+00], align 16
@__const.main.CORRECT_ANSWERS = private unnamed_addr constant [8 x double] [double 0x3F95E41D648C236F, double 0x3FC30D3EA599BB79, double 0x3FA26AF51F458AEB, double 0x3FB73CEBAB27FA12, double 0x3F8604EA1C27764A, double 0x3F6BD85EAF35CBC8, double 0x3FE0DF5C6BE20DA6, double 0x3FE172D38028625E], align 16
@.str.2 = private unnamed_addr constant [26 x i8] c"Test sets 1 p-value = %g\0A\00", align 1
@.str.3 = private unnamed_addr constant [26 x i8] c"Test sets 2 p-value = %g\0A\00", align 1
@.str.4 = private unnamed_addr constant [26 x i8] c"Test sets 3 p-value = %g\0A\00", align 1
@.str.5 = private unnamed_addr constant [26 x i8] c"Test sets 4 p-value = %g\0A\00", align 1
@.str.6 = private unnamed_addr constant [26 x i8] c"Test sets 5 p-value = %g\0A\00", align 1
@.str.7 = private unnamed_addr constant [26 x i8] c"Test sets 6 p-value = %g\0A\00", align 1
@.str.8 = private unnamed_addr constant [26 x i8] c"Test sets 7 p-value = %g\0A\00", align 1
@.str.9 = private unnamed_addr constant [26 x i8] c"Test sets z p-value = %g\0A\00", align 1
@.str.10 = private unnamed_addr constant [28 x i8] c"the cumulative error is %g\0A\00", align 1
@llvm.used = appending global [1 x i8*] [i8* bitcast (i32 ()* @__main_void to i8*)], section "llvm.metadata"

@__main_void = alias i32 (), i32 ()* @main

; Function Attrs: noinline nounwind optnone
define hidden double @Pvalue(double* noalias %ARRAY1, i32 %ARRAY1_SIZE, double* noalias %ARRAY2, i32 %ARRAY2_SIZE) #0 {
entry:
  %retval = alloca double, align 8
  %ARRAY1.addr = alloca double*, align 4
  %ARRAY1_SIZE.addr = alloca i32, align 4
  %ARRAY2.addr = alloca double*, align 4
  %ARRAY2_SIZE.addr = alloca i32, align 4
  %fmean1 = alloca double, align 8
  %fmean2 = alloca double, align 8
  %x = alloca i32, align 4
  %x9 = alloca i32, align 4
  %unbiased_sample_variance1 = alloca double, align 8
  %unbiased_sample_variance2 = alloca double, align 8
  %x32 = alloca i32, align 4
  %x44 = alloca i32, align 4
  %WELCH_T_STATISTIC = alloca double, align 8
  %DEGREES_OF_FREEDOM = alloca double, align 8
  %a = alloca double, align 8
  %value = alloca double, align 8
  %beta = alloca double, align 8
  %acu = alloca double, align 8
  %ai = alloca double, align 8
  %cx = alloca double, align 8
  %indx = alloca i32, align 4
  %ns = alloca i32, align 4
  %pp = alloca double, align 8
  %psq = alloca double, align 8
  %qq = alloca double, align 8
  %rx = alloca double, align 8
  %temp = alloca double, align 8
  %term = alloca double, align 8
  %xx = alloca double, align 8
  store double* %ARRAY1, double** %ARRAY1.addr, align 4
  store i32 %ARRAY1_SIZE, i32* %ARRAY1_SIZE.addr, align 4
  store double* %ARRAY2, double** %ARRAY2.addr, align 4
  store i32 %ARRAY2_SIZE, i32* %ARRAY2_SIZE.addr, align 4
  %0 = load i32, i32* %ARRAY1_SIZE.addr, align 4
  %cmp = icmp ule i32 %0, 1
  br i1 %cmp, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  store double 1.000000e+00, double* %retval, align 8
  br label %return

if.else:                                          ; preds = %entry
  %1 = load i32, i32* %ARRAY2_SIZE.addr, align 4
  %cmp1 = icmp ule i32 %1, 1
  br i1 %cmp1, label %if.then2, label %if.end

if.then2:                                         ; preds = %if.else
  store double 1.000000e+00, double* %retval, align 8
  br label %return

if.end:                                           ; preds = %if.else
  br label %if.end3

if.end3:                                          ; preds = %if.end
  store double 0.000000e+00, double* %fmean1, align 8
  store double 0.000000e+00, double* %fmean2, align 8
  store i32 0, i32* %x, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.end3
  %2 = load i32, i32* %x, align 4
  %3 = load i32, i32* %ARRAY1_SIZE.addr, align 4
  %cmp4 = icmp ult i32 %2, %3
  br i1 %cmp4, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %4 = load double*, double** %ARRAY1.addr, align 4
  %5 = load i32, i32* %x, align 4
  %arrayidx = getelementptr inbounds double, double* %4, i32 %5
  %6 = load double, double* %arrayidx, align 8
  %7 = call double @llvm.fabs.f64(double %6) #7
  %cmpinf = fcmp one double %7, 0x7FF0000000000000
  %8 = zext i1 %cmpinf to i32
  %cmp5 = icmp eq i32 %8, 0
  br i1 %cmp5, label %if.then6, label %if.end7

if.then6:                                         ; preds = %for.body
  %call = call i32 @puts(i8* getelementptr inbounds ([63 x i8], [63 x i8]* @.str, i32 0, i32 0))
  call void @exit(i32 1) #8
  unreachable

if.end7:                                          ; preds = %for.body
  %9 = load double*, double** %ARRAY1.addr, align 4
  %10 = load i32, i32* %x, align 4
  %arrayidx8 = getelementptr inbounds double, double* %9, i32 %10
  %11 = load double, double* %arrayidx8, align 8
  %12 = load double, double* %fmean1, align 8
  %add = fadd double %12, %11
  store double %add, double* %fmean1, align 8
  br label %for.inc

for.inc:                                          ; preds = %if.end7
  %13 = load i32, i32* %x, align 4
  %inc = add i32 %13, 1
  store i32 %inc, i32* %x, align 4
  br label %for.cond

for.end:                                          ; preds = %for.cond
  %14 = load i32, i32* %ARRAY1_SIZE.addr, align 4
  %conv = uitofp i32 %14 to double
  %15 = load double, double* %fmean1, align 8
  %div = fdiv double %15, %conv
  store double %div, double* %fmean1, align 8
  store i32 0, i32* %x9, align 4
  br label %for.cond10

for.cond10:                                       ; preds = %for.inc23, %for.end
  %16 = load i32, i32* %x9, align 4
  %17 = load i32, i32* %ARRAY2_SIZE.addr, align 4
  %cmp11 = icmp ult i32 %16, %17
  br i1 %cmp11, label %for.body13, label %for.end25

for.body13:                                       ; preds = %for.cond10
  %18 = load double*, double** %ARRAY2.addr, align 4
  %19 = load i32, i32* %x9, align 4
  %arrayidx14 = getelementptr inbounds double, double* %18, i32 %19
  %20 = load double, double* %arrayidx14, align 8
  %21 = call double @llvm.fabs.f64(double %20) #7
  %cmpinf15 = fcmp one double %21, 0x7FF0000000000000
  %22 = zext i1 %cmpinf15 to i32
  %cmp16 = icmp eq i32 %22, 0
  br i1 %cmp16, label %if.then18, label %if.end20

if.then18:                                        ; preds = %for.body13
  %call19 = call i32 @puts(i8* getelementptr inbounds ([63 x i8], [63 x i8]* @.str.1, i32 0, i32 0))
  call void @exit(i32 1) #8
  unreachable

if.end20:                                         ; preds = %for.body13
  %23 = load double*, double** %ARRAY2.addr, align 4
  %24 = load i32, i32* %x9, align 4
  %arrayidx21 = getelementptr inbounds double, double* %23, i32 %24
  %25 = load double, double* %arrayidx21, align 8
  %26 = load double, double* %fmean2, align 8
  %add22 = fadd double %26, %25
  store double %add22, double* %fmean2, align 8
  br label %for.inc23

for.inc23:                                        ; preds = %if.end20
  %27 = load i32, i32* %x9, align 4
  %inc24 = add i32 %27, 1
  store i32 %inc24, i32* %x9, align 4
  br label %for.cond10

for.end25:                                        ; preds = %for.cond10
  %28 = load i32, i32* %ARRAY2_SIZE.addr, align 4
  %conv26 = uitofp i32 %28 to double
  %29 = load double, double* %fmean2, align 8
  %div27 = fdiv double %29, %conv26
  store double %div27, double* %fmean2, align 8
  %30 = load double, double* %fmean1, align 8
  %31 = load double, double* %fmean2, align 8
  %cmp28 = fcmp oeq double %30, %31
  br i1 %cmp28, label %if.then30, label %if.end31

if.then30:                                        ; preds = %for.end25
  store double 1.000000e+00, double* %retval, align 8
  br label %return

if.end31:                                         ; preds = %for.end25
  store double 0.000000e+00, double* %unbiased_sample_variance1, align 8
  store double 0.000000e+00, double* %unbiased_sample_variance2, align 8
  store i32 0, i32* %x32, align 4
  br label %for.cond33

for.cond33:                                       ; preds = %for.inc41, %if.end31
  %32 = load i32, i32* %x32, align 4
  %33 = load i32, i32* %ARRAY1_SIZE.addr, align 4
  %cmp34 = icmp ult i32 %32, %33
  br i1 %cmp34, label %for.body36, label %for.end43

for.body36:                                       ; preds = %for.cond33
  %34 = load double*, double** %ARRAY1.addr, align 4
  %35 = load i32, i32* %x32, align 4
  %arrayidx37 = getelementptr inbounds double, double* %34, i32 %35
  %36 = load double, double* %arrayidx37, align 8
  %37 = load double, double* %fmean1, align 8
  %sub = fsub double %36, %37
  %38 = load double*, double** %ARRAY1.addr, align 4
  %39 = load i32, i32* %x32, align 4
  %arrayidx38 = getelementptr inbounds double, double* %38, i32 %39
  %40 = load double, double* %arrayidx38, align 8
  %41 = load double, double* %fmean1, align 8
  %sub39 = fsub double %40, %41
  %mul = fmul double %sub, %sub39
  %42 = load double, double* %unbiased_sample_variance1, align 8
  %add40 = fadd double %42, %mul
  store double %add40, double* %unbiased_sample_variance1, align 8
  br label %for.inc41

for.inc41:                                        ; preds = %for.body36
  %43 = load i32, i32* %x32, align 4
  %inc42 = add i32 %43, 1
  store i32 %inc42, i32* %x32, align 4
  br label %for.cond33

for.end43:                                        ; preds = %for.cond33
  store i32 0, i32* %x44, align 4
  br label %for.cond45

for.cond45:                                       ; preds = %for.inc55, %for.end43
  %44 = load i32, i32* %x44, align 4
  %45 = load i32, i32* %ARRAY2_SIZE.addr, align 4
  %cmp46 = icmp ult i32 %44, %45
  br i1 %cmp46, label %for.body48, label %for.end57

for.body48:                                       ; preds = %for.cond45
  %46 = load double*, double** %ARRAY2.addr, align 4
  %47 = load i32, i32* %x44, align 4
  %arrayidx49 = getelementptr inbounds double, double* %46, i32 %47
  %48 = load double, double* %arrayidx49, align 8
  %49 = load double, double* %fmean2, align 8
  %sub50 = fsub double %48, %49
  %50 = load double*, double** %ARRAY2.addr, align 4
  %51 = load i32, i32* %x44, align 4
  %arrayidx51 = getelementptr inbounds double, double* %50, i32 %51
  %52 = load double, double* %arrayidx51, align 8
  %53 = load double, double* %fmean2, align 8
  %sub52 = fsub double %52, %53
  %mul53 = fmul double %sub50, %sub52
  %54 = load double, double* %unbiased_sample_variance2, align 8
  %add54 = fadd double %54, %mul53
  store double %add54, double* %unbiased_sample_variance2, align 8
  br label %for.inc55

for.inc55:                                        ; preds = %for.body48
  %55 = load i32, i32* %x44, align 4
  %inc56 = add i32 %55, 1
  store i32 %inc56, i32* %x44, align 4
  br label %for.cond45

for.end57:                                        ; preds = %for.cond45
  %56 = load double, double* %unbiased_sample_variance1, align 8
  %57 = load i32, i32* %ARRAY1_SIZE.addr, align 4
  %sub58 = sub i32 %57, 1
  %conv59 = uitofp i32 %sub58 to double
  %div60 = fdiv double %56, %conv59
  store double %div60, double* %unbiased_sample_variance1, align 8
  %58 = load double, double* %unbiased_sample_variance2, align 8
  %59 = load i32, i32* %ARRAY2_SIZE.addr, align 4
  %sub61 = sub i32 %59, 1
  %conv62 = uitofp i32 %sub61 to double
  %div63 = fdiv double %58, %conv62
  store double %div63, double* %unbiased_sample_variance2, align 8
  %60 = load double, double* %fmean1, align 8
  %61 = load double, double* %fmean2, align 8
  %sub64 = fsub double %60, %61
  %62 = load double, double* %unbiased_sample_variance1, align 8
  %63 = load i32, i32* %ARRAY1_SIZE.addr, align 4
  %conv65 = uitofp i32 %63 to double
  %div66 = fdiv double %62, %conv65
  %64 = load double, double* %unbiased_sample_variance2, align 8
  %65 = load i32, i32* %ARRAY2_SIZE.addr, align 4
  %conv67 = uitofp i32 %65 to double
  %div68 = fdiv double %64, %conv67
  %add69 = fadd double %div66, %div68
  %66 = call double @llvm.sqrt.f64(double %add69)
  %div70 = fdiv double %sub64, %66
  store double %div70, double* %WELCH_T_STATISTIC, align 8
  %67 = load double, double* %unbiased_sample_variance1, align 8
  %68 = load i32, i32* %ARRAY1_SIZE.addr, align 4
  %conv71 = uitofp i32 %68 to double
  %div72 = fdiv double %67, %conv71
  %69 = load double, double* %unbiased_sample_variance2, align 8
  %70 = load i32, i32* %ARRAY2_SIZE.addr, align 4
  %conv73 = uitofp i32 %70 to double
  %div74 = fdiv double %69, %conv73
  %add75 = fadd double %div72, %div74
  %71 = call double @llvm.pow.f64(double %add75, double 2.000000e+00)
  %72 = load double, double* %unbiased_sample_variance1, align 8
  %73 = load double, double* %unbiased_sample_variance1, align 8
  %mul76 = fmul double %72, %73
  %74 = load i32, i32* %ARRAY1_SIZE.addr, align 4
  %75 = load i32, i32* %ARRAY1_SIZE.addr, align 4
  %mul77 = mul i32 %74, %75
  %76 = load i32, i32* %ARRAY1_SIZE.addr, align 4
  %sub78 = sub i32 %76, 1
  %mul79 = mul i32 %mul77, %sub78
  %conv80 = uitofp i32 %mul79 to double
  %div81 = fdiv double %mul76, %conv80
  %77 = load double, double* %unbiased_sample_variance2, align 8
  %78 = load double, double* %unbiased_sample_variance2, align 8
  %mul82 = fmul double %77, %78
  %79 = load i32, i32* %ARRAY2_SIZE.addr, align 4
  %80 = load i32, i32* %ARRAY2_SIZE.addr, align 4
  %mul83 = mul i32 %79, %80
  %81 = load i32, i32* %ARRAY2_SIZE.addr, align 4
  %sub84 = sub i32 %81, 1
  %mul85 = mul i32 %mul83, %sub84
  %conv86 = uitofp i32 %mul85 to double
  %div87 = fdiv double %mul82, %conv86
  %add88 = fadd double %div81, %div87
  %div89 = fdiv double %71, %add88
  store double %div89, double* %DEGREES_OF_FREEDOM, align 8
  %82 = load double, double* %DEGREES_OF_FREEDOM, align 8
  %div90 = fdiv double %82, 2.000000e+00
  store double %div90, double* %a, align 8
  %83 = load double, double* %DEGREES_OF_FREEDOM, align 8
  %84 = load double, double* %WELCH_T_STATISTIC, align 8
  %85 = load double, double* %WELCH_T_STATISTIC, align 8
  %mul91 = fmul double %84, %85
  %86 = load double, double* %DEGREES_OF_FREEDOM, align 8
  %add92 = fadd double %mul91, %86
  %div93 = fdiv double %83, %add92
  store double %div93, double* %value, align 8
  %87 = load double, double* %value, align 8
  %88 = call double @llvm.fabs.f64(double %87) #7
  %cmpinf94 = fcmp oeq double %88, 0x7FF0000000000000
  br i1 %cmpinf94, label %if.then100, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %for.end57
  %89 = load double, double* %value, align 8
  %cmp97 = fcmp uno double %89, %89
  br i1 %cmp97, label %if.then100, label %if.end101

if.then100:                                       ; preds = %lor.lhs.false, %for.end57
  store double 1.000000e+00, double* %retval, align 8
  br label %return

if.end101:                                        ; preds = %lor.lhs.false
  %90 = load double, double* %value, align 8
  %91 = call double @llvm.fabs.f64(double %90) #7
  %cmpinf102 = fcmp oeq double %91, 0x7FF0000000000000
  %92 = zext i1 %cmpinf102 to i32
  %cmp103 = icmp ne i32 %92, 0
  br i1 %cmp103, label %if.then109, label %lor.lhs.false105

lor.lhs.false105:                                 ; preds = %if.end101
  %93 = load double, double* %value, align 8
  %cmp106 = fcmp uno double %93, %93
  %94 = zext i1 %cmp106 to i32
  %cmp107 = icmp ne i32 %94, 0
  br i1 %cmp107, label %if.then109, label %if.end110

if.then109:                                       ; preds = %lor.lhs.false105, %if.end101
  store double 1.000000e+00, double* %retval, align 8
  br label %return

if.end110:                                        ; preds = %lor.lhs.false105
  %95 = load double, double* %a, align 8
  %conv111 = fpext double %95 to fp128
  %call112 = call fp128 @lgammal(fp128 %conv111) #9
  %add113 = fadd fp128 %call112, 0xLD0000000000000003FFE250D048E7A1B
  %96 = load double, double* %a, align 8
  %add114 = fadd double %96, 5.000000e-01
  %conv115 = fpext double %add114 to fp128
  %call116 = call fp128 @lgammal(fp128 %conv115) #9
  %sub117 = fsub fp128 %add113, %call116
  %conv118 = fptrunc fp128 %sub117 to double
  store double %conv118, double* %beta, align 8
  store double 1.000000e-15, double* %acu, align 8
  %97 = load double, double* %a, align 8
  %cmp119 = fcmp ole double %97, 0.000000e+00
  br i1 %cmp119, label %if.then121, label %if.end122

if.then121:                                       ; preds = %if.end110
  br label %if.end122

if.end122:                                        ; preds = %if.then121, %if.end110
  %98 = load double, double* %value, align 8
  %cmp123 = fcmp olt double %98, 0.000000e+00
  br i1 %cmp123, label %if.then128, label %lor.lhs.false125

lor.lhs.false125:                                 ; preds = %if.end122
  %99 = load double, double* %value, align 8
  %cmp126 = fcmp olt double 1.000000e+00, %99
  br i1 %cmp126, label %if.then128, label %if.end129

if.then128:                                       ; preds = %lor.lhs.false125, %if.end122
  %100 = load double, double* %value, align 8
  store double %100, double* %retval, align 8
  br label %return

if.end129:                                        ; preds = %lor.lhs.false125
  %101 = load double, double* %value, align 8
  %cmp130 = fcmp oeq double %101, 0.000000e+00
  br i1 %cmp130, label %if.then135, label %lor.lhs.false132

lor.lhs.false132:                                 ; preds = %if.end129
  %102 = load double, double* %value, align 8
  %cmp133 = fcmp oeq double %102, 1.000000e+00
  br i1 %cmp133, label %if.then135, label %if.end136

if.then135:                                       ; preds = %lor.lhs.false132, %if.end129
  %103 = load double, double* %value, align 8
  store double %103, double* %retval, align 8
  br label %return

if.end136:                                        ; preds = %lor.lhs.false132
  %104 = load double, double* %a, align 8
  %add137 = fadd double %104, 5.000000e-01
  store double %add137, double* %psq, align 8
  %105 = load double, double* %value, align 8
  %sub138 = fsub double 1.000000e+00, %105
  store double %sub138, double* %cx, align 8
  %106 = load double, double* %a, align 8
  %107 = load double, double* %psq, align 8
  %108 = load double, double* %value, align 8
  %mul139 = fmul double %107, %108
  %cmp140 = fcmp olt double %106, %mul139
  br i1 %cmp140, label %if.then142, label %if.else143

if.then142:                                       ; preds = %if.end136
  %109 = load double, double* %cx, align 8
  store double %109, double* %xx, align 8
  %110 = load double, double* %value, align 8
  store double %110, double* %cx, align 8
  store double 5.000000e-01, double* %pp, align 8
  %111 = load double, double* %a, align 8
  store double %111, double* %qq, align 8
  store i32 1, i32* %indx, align 4
  br label %if.end144

if.else143:                                       ; preds = %if.end136
  %112 = load double, double* %value, align 8
  store double %112, double* %xx, align 8
  %113 = load double, double* %a, align 8
  store double %113, double* %pp, align 8
  store double 5.000000e-01, double* %qq, align 8
  store i32 0, i32* %indx, align 4
  br label %if.end144

if.end144:                                        ; preds = %if.else143, %if.then142
  store double 1.000000e+00, double* %term, align 8
  store double 1.000000e+00, double* %ai, align 8
  store double 1.000000e+00, double* %value, align 8
  %114 = load double, double* %qq, align 8
  %115 = load double, double* %cx, align 8
  %116 = load double, double* %psq, align 8
  %mul145 = fmul double %115, %116
  %add146 = fadd double %114, %mul145
  %conv147 = fptosi double %add146 to i32
  store i32 %conv147, i32* %ns, align 4
  %117 = load double, double* %xx, align 8
  %118 = load double, double* %cx, align 8
  %div148 = fdiv double %117, %118
  store double %div148, double* %rx, align 8
  %119 = load double, double* %qq, align 8
  %120 = load double, double* %ai, align 8
  %sub149 = fsub double %119, %120
  store double %sub149, double* %temp, align 8
  %121 = load i32, i32* %ns, align 4
  %cmp150 = icmp eq i32 %121, 0
  br i1 %cmp150, label %if.then152, label %if.end153

if.then152:                                       ; preds = %if.end144
  %122 = load double, double* %xx, align 8
  store double %122, double* %rx, align 8
  br label %if.end153

if.end153:                                        ; preds = %if.then152, %if.end144
  br label %for.cond154

for.cond154:                                      ; preds = %if.end189, %if.end153
  %123 = load double, double* %term, align 8
  %124 = load double, double* %temp, align 8
  %mul155 = fmul double %123, %124
  %125 = load double, double* %rx, align 8
  %mul156 = fmul double %mul155, %125
  %126 = load double, double* %pp, align 8
  %127 = load double, double* %ai, align 8
  %add157 = fadd double %126, %127
  %div158 = fdiv double %mul156, %add157
  store double %div158, double* %term, align 8
  %128 = load double, double* %value, align 8
  %129 = load double, double* %term, align 8
  %add159 = fadd double %128, %129
  store double %add159, double* %value, align 8
  %130 = load double, double* %term, align 8
  %131 = call double @llvm.fabs.f64(double %130)
  store double %131, double* %temp, align 8
  %132 = load double, double* %temp, align 8
  %cmp160 = fcmp ole double %132, 1.000000e-15
  br i1 %cmp160, label %land.lhs.true, label %if.end176

land.lhs.true:                                    ; preds = %for.cond154
  %133 = load double, double* %temp, align 8
  %134 = load double, double* %value, align 8
  %mul162 = fmul double 1.000000e-15, %134
  %cmp163 = fcmp ole double %133, %mul162
  br i1 %cmp163, label %if.then165, label %if.end176

if.then165:                                       ; preds = %land.lhs.true
  %135 = load double, double* %value, align 8
  %136 = load double, double* %pp, align 8
  %137 = load double, double* %xx, align 8
  %138 = call double @llvm.log.f64(double %137)
  %mul166 = fmul double %136, %138
  %139 = load double, double* %qq, align 8
  %sub167 = fsub double %139, 1.000000e+00
  %140 = load double, double* %cx, align 8
  %141 = call double @llvm.log.f64(double %140)
  %mul168 = fmul double %sub167, %141
  %add169 = fadd double %mul166, %mul168
  %142 = load double, double* %beta, align 8
  %sub170 = fsub double %add169, %142
  %143 = call double @llvm.exp.f64(double %sub170)
  %mul171 = fmul double %135, %143
  %144 = load double, double* %pp, align 8
  %div172 = fdiv double %mul171, %144
  store double %div172, double* %value, align 8
  %145 = load i32, i32* %indx, align 4
  %tobool = icmp ne i32 %145, 0
  br i1 %tobool, label %if.then173, label %if.end175

if.then173:                                       ; preds = %if.then165
  %146 = load double, double* %value, align 8
  %sub174 = fsub double 1.000000e+00, %146
  store double %sub174, double* %value, align 8
  br label %if.end175

if.end175:                                        ; preds = %if.then173, %if.then165
  br label %for.end190

if.end176:                                        ; preds = %land.lhs.true, %for.cond154
  %147 = load double, double* %ai, align 8
  %add177 = fadd double %147, 1.000000e+00
  store double %add177, double* %ai, align 8
  %148 = load i32, i32* %ns, align 4
  %sub178 = sub nsw i32 %148, 1
  store i32 %sub178, i32* %ns, align 4
  %149 = load i32, i32* %ns, align 4
  %cmp179 = icmp sle i32 0, %149
  br i1 %cmp179, label %if.then181, label %if.else187

if.then181:                                       ; preds = %if.end176
  %150 = load double, double* %qq, align 8
  %151 = load double, double* %ai, align 8
  %sub182 = fsub double %150, %151
  store double %sub182, double* %temp, align 8
  %152 = load i32, i32* %ns, align 4
  %cmp183 = icmp eq i32 %152, 0
  br i1 %cmp183, label %if.then185, label %if.end186

if.then185:                                       ; preds = %if.then181
  %153 = load double, double* %xx, align 8
  store double %153, double* %rx, align 8
  br label %if.end186

if.end186:                                        ; preds = %if.then185, %if.then181
  br label %if.end189

if.else187:                                       ; preds = %if.end176
  %154 = load double, double* %psq, align 8
  store double %154, double* %temp, align 8
  %155 = load double, double* %psq, align 8
  %add188 = fadd double %155, 1.000000e+00
  store double %add188, double* %psq, align 8
  br label %if.end189

if.end189:                                        ; preds = %if.else187, %if.end186
  br label %for.cond154

for.end190:                                       ; preds = %if.end175
  %156 = load double, double* %value, align 8
  store double %156, double* %retval, align 8
  br label %return

return:                                           ; preds = %for.end190, %if.then135, %if.then128, %if.then109, %if.then100, %if.then30, %if.then2, %if.then
  %157 = load double, double* %retval, align 8
  ret double %157
}

; Function Attrs: nounwind readnone speculatable willreturn
declare double @llvm.fabs.f64(double %0) #1

declare i32 @puts(i8* %0) #2

; Function Attrs: noreturn
declare void @exit(i32 %0) #3

; Function Attrs: nounwind readnone speculatable willreturn
declare double @llvm.sqrt.f64(double %0) #1

; Function Attrs: nounwind readnone speculatable willreturn
declare double @llvm.pow.f64(double %0, double %1) #1

; Function Attrs: nounwind
declare fp128 @lgammal(fp128 %0) #4

; Function Attrs: nounwind readnone speculatable willreturn
declare double @llvm.log.f64(double %0) #1

; Function Attrs: nounwind readnone speculatable willreturn
declare double @llvm.exp.f64(double %0) #1

; Function Attrs: noinline nounwind optnone
define hidden i32 @main() #0 {
entry:
  %retval = alloca i32, align 4
  %d1 = alloca [15 x double], align 16
  %d2 = alloca [15 x double], align 16
  %d3 = alloca [10 x double], align 16
  %d4 = alloca [20 x double], align 16
  %d5 = alloca [10 x double], align 16
  %d6 = alloca [20 x double], align 16
  %d7 = alloca [6 x double], align 16
  %d8 = alloca [6 x double], align 16
  %x = alloca [4 x double], align 16
  %y = alloca [3 x double], align 16
  %v1 = alloca [3 x double], align 16
  %v2 = alloca [3 x double], align 16
  %s1 = alloca [2 x double], align 16
  %s2 = alloca [2 x double], align 16
  %z1 = alloca [3 x double], align 16
  %z2 = alloca [3 x double], align 16
  %CORRECT_ANSWERS = alloca [8 x double], align 16
  %pvalue = alloca double, align 8
  %error = alloca double, align 8
  store i32 0, i32* %retval, align 4
  %0 = bitcast [15 x double]* %d1 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 16 %0, i8* align 16 bitcast ([15 x double]* @__const.main.d1 to i8*), i32 120, i1 false)
  %1 = bitcast [15 x double]* %d2 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 16 %1, i8* align 16 bitcast ([15 x double]* @__const.main.d2 to i8*), i32 120, i1 false)
  %2 = bitcast [10 x double]* %d3 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 16 %2, i8* align 16 bitcast ([10 x double]* @__const.main.d3 to i8*), i32 80, i1 false)
  %3 = bitcast [20 x double]* %d4 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 16 %3, i8* align 16 bitcast ([20 x double]* @__const.main.d4 to i8*), i32 160, i1 false)
  %4 = bitcast [10 x double]* %d5 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 16 %4, i8* align 16 bitcast ([10 x double]* @__const.main.d5 to i8*), i32 80, i1 false)
  %5 = bitcast [20 x double]* %d6 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 16 %5, i8* align 16 bitcast ([20 x double]* @__const.main.d6 to i8*), i32 160, i1 false)
  %6 = bitcast [6 x double]* %d7 to i8*
  call void @llvm.memset.p0i8.i32(i8* align 16 %6, i8 0, i32 48, i1 false)
  %7 = bitcast i8* %6 to [6 x double]*
  %8 = getelementptr inbounds [6 x double], [6 x double]* %7, i32 0, i32 0
  store double 3.002000e+01, double* %8, align 16
  %9 = getelementptr inbounds [6 x double], [6 x double]* %7, i32 0, i32 1
  store double 2.999000e+01, double* %9, align 8
  %10 = getelementptr inbounds [6 x double], [6 x double]* %7, i32 0, i32 2
  store double 3.011000e+01, double* %10, align 16
  %11 = getelementptr inbounds [6 x double], [6 x double]* %7, i32 0, i32 3
  store double 2.997000e+01, double* %11, align 8
  %12 = getelementptr inbounds [6 x double], [6 x double]* %7, i32 0, i32 4
  store double 3.001000e+01, double* %12, align 16
  %13 = getelementptr inbounds [6 x double], [6 x double]* %7, i32 0, i32 5
  store double 2.999000e+01, double* %13, align 8
  %14 = bitcast [6 x double]* %d8 to i8*
  call void @llvm.memset.p0i8.i32(i8* align 16 %14, i8 0, i32 48, i1 false)
  %15 = bitcast i8* %14 to [6 x double]*
  %16 = getelementptr inbounds [6 x double], [6 x double]* %15, i32 0, i32 0
  store double 2.989000e+01, double* %16, align 16
  %17 = getelementptr inbounds [6 x double], [6 x double]* %15, i32 0, i32 1
  store double 2.993000e+01, double* %17, align 8
  %18 = getelementptr inbounds [6 x double], [6 x double]* %15, i32 0, i32 2
  store double 2.972000e+01, double* %18, align 16
  %19 = getelementptr inbounds [6 x double], [6 x double]* %15, i32 0, i32 3
  store double 2.998000e+01, double* %19, align 8
  %20 = getelementptr inbounds [6 x double], [6 x double]* %15, i32 0, i32 4
  store double 3.002000e+01, double* %20, align 16
  %21 = getelementptr inbounds [6 x double], [6 x double]* %15, i32 0, i32 5
  store double 2.998000e+01, double* %21, align 8
  %22 = bitcast [4 x double]* %x to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 16 %22, i8* align 16 bitcast ([4 x double]* @__const.main.x to i8*), i32 32, i1 false)
  %23 = bitcast [3 x double]* %y to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 16 %23, i8* align 16 bitcast ([3 x double]* @__const.main.y to i8*), i32 24, i1 false)
  %24 = bitcast [3 x double]* %v1 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 16 %24, i8* align 16 bitcast ([3 x double]* @__const.main.v1 to i8*), i32 24, i1 false)
  %25 = bitcast [3 x double]* %v2 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 16 %25, i8* align 16 bitcast ([3 x double]* @__const.main.v2 to i8*), i32 24, i1 false)
  %26 = bitcast [2 x double]* %s1 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 16 %26, i8* align 16 bitcast ([2 x double]* @__const.main.s1 to i8*), i32 16, i1 false)
  %27 = bitcast [2 x double]* %s2 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 16 %27, i8* align 16 bitcast ([2 x double]* @__const.main.s2 to i8*), i32 16, i1 false)
  %28 = bitcast [3 x double]* %z1 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 16 %28, i8* align 16 bitcast ([3 x double]* @__const.main.z1 to i8*), i32 24, i1 false)
  %29 = bitcast [3 x double]* %z2 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 16 %29, i8* align 16 bitcast ([3 x double]* @__const.main.z2 to i8*), i32 24, i1 false)
  %30 = bitcast [8 x double]* %CORRECT_ANSWERS to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 16 %30, i8* align 16 bitcast ([8 x double]* @__const.main.CORRECT_ANSWERS to i8*), i32 64, i1 false)
  %arraydecay = getelementptr inbounds [15 x double], [15 x double]* %d1, i32 0, i32 0
  %arraydecay1 = getelementptr inbounds [15 x double], [15 x double]* %d2, i32 0, i32 0
  %call = call double @Pvalue(double* %arraydecay, i32 15, double* %arraydecay1, i32 15)
  store double %call, double* %pvalue, align 8
  %31 = load double, double* %pvalue, align 8
  %arrayidx = getelementptr inbounds [8 x double], [8 x double]* %CORRECT_ANSWERS, i32 0, i32 0
  %32 = load double, double* %arrayidx, align 16
  %sub = fsub double %31, %32
  %33 = call double @llvm.fabs.f64(double %sub)
  store double %33, double* %error, align 8
  %34 = load double, double* %pvalue, align 8
  %call2 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([26 x i8], [26 x i8]* @.str.2, i32 0, i32 0), double %34)
  %arraydecay3 = getelementptr inbounds [10 x double], [10 x double]* %d3, i32 0, i32 0
  %arraydecay4 = getelementptr inbounds [20 x double], [20 x double]* %d4, i32 0, i32 0
  %call5 = call double @Pvalue(double* %arraydecay3, i32 10, double* %arraydecay4, i32 20)
  store double %call5, double* %pvalue, align 8
  %35 = load double, double* %pvalue, align 8
  %arrayidx6 = getelementptr inbounds [8 x double], [8 x double]* %CORRECT_ANSWERS, i32 0, i32 1
  %36 = load double, double* %arrayidx6, align 8
  %sub7 = fsub double %35, %36
  %37 = call double @llvm.fabs.f64(double %sub7)
  %38 = load double, double* %error, align 8
  %add = fadd double %38, %37
  store double %add, double* %error, align 8
  %39 = load double, double* %pvalue, align 8
  %call8 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([26 x i8], [26 x i8]* @.str.3, i32 0, i32 0), double %39)
  %arraydecay9 = getelementptr inbounds [10 x double], [10 x double]* %d5, i32 0, i32 0
  %arraydecay10 = getelementptr inbounds [20 x double], [20 x double]* %d6, i32 0, i32 0
  %call11 = call double @Pvalue(double* %arraydecay9, i32 10, double* %arraydecay10, i32 20)
  store double %call11, double* %pvalue, align 8
  %40 = load double, double* %pvalue, align 8
  %arrayidx12 = getelementptr inbounds [8 x double], [8 x double]* %CORRECT_ANSWERS, i32 0, i32 2
  %41 = load double, double* %arrayidx12, align 16
  %sub13 = fsub double %40, %41
  %42 = call double @llvm.fabs.f64(double %sub13)
  %43 = load double, double* %error, align 8
  %add14 = fadd double %43, %42
  store double %add14, double* %error, align 8
  %44 = load double, double* %pvalue, align 8
  %call15 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([26 x i8], [26 x i8]* @.str.4, i32 0, i32 0), double %44)
  %arraydecay16 = getelementptr inbounds [6 x double], [6 x double]* %d7, i32 0, i32 0
  %arraydecay17 = getelementptr inbounds [6 x double], [6 x double]* %d8, i32 0, i32 0
  %call18 = call double @Pvalue(double* %arraydecay16, i32 6, double* %arraydecay17, i32 6)
  store double %call18, double* %pvalue, align 8
  %45 = load double, double* %pvalue, align 8
  %call19 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([26 x i8], [26 x i8]* @.str.5, i32 0, i32 0), double %45)
  %46 = load double, double* %pvalue, align 8
  %arrayidx20 = getelementptr inbounds [8 x double], [8 x double]* %CORRECT_ANSWERS, i32 0, i32 3
  %47 = load double, double* %arrayidx20, align 8
  %sub21 = fsub double %46, %47
  %48 = call double @llvm.fabs.f64(double %sub21)
  %49 = load double, double* %error, align 8
  %add22 = fadd double %49, %48
  store double %add22, double* %error, align 8
  %arraydecay23 = getelementptr inbounds [4 x double], [4 x double]* %x, i32 0, i32 0
  %arraydecay24 = getelementptr inbounds [3 x double], [3 x double]* %y, i32 0, i32 0
  %call25 = call double @Pvalue(double* %arraydecay23, i32 4, double* %arraydecay24, i32 3)
  store double %call25, double* %pvalue, align 8
  %50 = load double, double* %pvalue, align 8
  %arrayidx26 = getelementptr inbounds [8 x double], [8 x double]* %CORRECT_ANSWERS, i32 0, i32 4
  %51 = load double, double* %arrayidx26, align 16
  %sub27 = fsub double %50, %51
  %52 = call double @llvm.fabs.f64(double %sub27)
  %53 = load double, double* %error, align 8
  %add28 = fadd double %53, %52
  store double %add28, double* %error, align 8
  %54 = load double, double* %pvalue, align 8
  %call29 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([26 x i8], [26 x i8]* @.str.6, i32 0, i32 0), double %54)
  %arraydecay30 = getelementptr inbounds [3 x double], [3 x double]* %v1, i32 0, i32 0
  %arraydecay31 = getelementptr inbounds [3 x double], [3 x double]* %v2, i32 0, i32 0
  %call32 = call double @Pvalue(double* %arraydecay30, i32 3, double* %arraydecay31, i32 3)
  store double %call32, double* %pvalue, align 8
  %55 = load double, double* %pvalue, align 8
  %arrayidx33 = getelementptr inbounds [8 x double], [8 x double]* %CORRECT_ANSWERS, i32 0, i32 5
  %56 = load double, double* %arrayidx33, align 8
  %sub34 = fsub double %55, %56
  %57 = call double @llvm.fabs.f64(double %sub34)
  %58 = load double, double* %error, align 8
  %add35 = fadd double %58, %57
  store double %add35, double* %error, align 8
  %59 = load double, double* %pvalue, align 8
  %call36 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([26 x i8], [26 x i8]* @.str.7, i32 0, i32 0), double %59)
  %arraydecay37 = getelementptr inbounds [2 x double], [2 x double]* %s1, i32 0, i32 0
  %arraydecay38 = getelementptr inbounds [2 x double], [2 x double]* %s2, i32 0, i32 0
  %call39 = call double @Pvalue(double* %arraydecay37, i32 2, double* %arraydecay38, i32 2)
  store double %call39, double* %pvalue, align 8
  %60 = load double, double* %pvalue, align 8
  %arrayidx40 = getelementptr inbounds [8 x double], [8 x double]* %CORRECT_ANSWERS, i32 0, i32 6
  %61 = load double, double* %arrayidx40, align 16
  %sub41 = fsub double %60, %61
  %62 = call double @llvm.fabs.f64(double %sub41)
  %63 = load double, double* %error, align 8
  %add42 = fadd double %63, %62
  store double %add42, double* %error, align 8
  %64 = load double, double* %pvalue, align 8
  %call43 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([26 x i8], [26 x i8]* @.str.8, i32 0, i32 0), double %64)
  %arraydecay44 = getelementptr inbounds [3 x double], [3 x double]* %z1, i32 0, i32 0
  %arraydecay45 = getelementptr inbounds [3 x double], [3 x double]* %z2, i32 0, i32 0
  %call46 = call double @Pvalue(double* %arraydecay44, i32 3, double* %arraydecay45, i32 3)
  store double %call46, double* %pvalue, align 8
  %65 = load double, double* %pvalue, align 8
  %arrayidx47 = getelementptr inbounds [8 x double], [8 x double]* %CORRECT_ANSWERS, i32 0, i32 7
  %66 = load double, double* %arrayidx47, align 8
  %sub48 = fsub double %65, %66
  %67 = call double @llvm.fabs.f64(double %sub48)
  %68 = load double, double* %error, align 8
  %add49 = fadd double %68, %67
  store double %add49, double* %error, align 8
  %69 = load double, double* %pvalue, align 8
  %call50 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([26 x i8], [26 x i8]* @.str.9, i32 0, i32 0), double %69)
  %70 = load double, double* %error, align 8
  %call51 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([28 x i8], [28 x i8]* @.str.10, i32 0, i32 0), double %70)
  ret i32 0
}

; Function Attrs: argmemonly nounwind willreturn
declare void @llvm.memcpy.p0i8.p0i8.i32(i8* noalias nocapture writeonly %0, i8* noalias nocapture readonly %1, i32 %2, i1 immarg %3) #5

; Function Attrs: argmemonly nounwind willreturn writeonly
declare void @llvm.memset.p0i8.i32(i8* nocapture writeonly %0, i8 %1, i32 %2, i1 immarg %3) #6

declare i32 @printf(i8* %0, ...) #2

attributes #0 = { noinline nounwind optnone "correctly-rounded-divide-sqrt-fp-math"="false" "disable-tail-calls"="false" "frame-pointer"="none" "less-precise-fpmad"="false" "min-legal-vector-width"="0" "no-infs-fp-math"="false" "no-jump-tables"="false" "no-nans-fp-math"="false" "no-signed-zeros-fp-math"="false" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="generic" "unsafe-fp-math"="false" "use-soft-float"="false" }
attributes #1 = { nounwind readnone speculatable willreturn }
attributes #2 = { "correctly-rounded-divide-sqrt-fp-math"="false" "disable-tail-calls"="false" "frame-pointer"="none" "less-precise-fpmad"="false" "no-infs-fp-math"="false" "no-nans-fp-math"="false" "no-signed-zeros-fp-math"="false" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="generic" "unsafe-fp-math"="false" "use-soft-float"="false" }
attributes #3 = { noreturn "correctly-rounded-divide-sqrt-fp-math"="false" "disable-tail-calls"="false" "frame-pointer"="none" "less-precise-fpmad"="false" "no-infs-fp-math"="false" "no-nans-fp-math"="false" "no-signed-zeros-fp-math"="false" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="generic" "unsafe-fp-math"="false" "use-soft-float"="false" }
attributes #4 = { nounwind "correctly-rounded-divide-sqrt-fp-math"="false" "disable-tail-calls"="false" "frame-pointer"="none" "less-precise-fpmad"="false" "no-infs-fp-math"="false" "no-nans-fp-math"="false" "no-signed-zeros-fp-math"="false" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="generic" "unsafe-fp-math"="false" "use-soft-float"="false" }
attributes #5 = { argmemonly nounwind willreturn }
attributes #6 = { argmemonly nounwind willreturn writeonly }
attributes #7 = { readnone }
attributes #8 = { noreturn }
attributes #9 = { nounwind }

!llvm.module.flags = !{!0}
!llvm.ident = !{!1}

!0 = !{i32 1, !"wchar_size", i32 4}
!1 = !{!"clang version 11.0.0 (https://github.com/Jacarte/llvm-project.git 0f6dea67136cc1e0b3d200eb2bb165628970c44b)"}

; extracted candidates

; *****
; For LLVM instruction:
;  %0 = load i32, i32* %ARRAY1_SIZE.addr, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %cmp = icmp ule i32 %0, 1
; Looking for a replacement for:
%0:i32 = var
%1:i1 = ule %0, 1:i32
infer %1

; *****
; For LLVM instruction:
;  %1 = load i32, i32* %ARRAY2_SIZE.addr, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %cmp1 = icmp ule i32 %1, 1
; Looking for a replacement for:
%0:i32 = var
%1:i1 = ule %0, 1:i32
infer %1

; *****
; For LLVM instruction:
;  %2 = load i32, i32* %x, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %3 = load i32, i32* %ARRAY1_SIZE.addr, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %cmp4 = icmp ult i32 %2, %3
; Looking for a replacement for:
%0:i32 = var
%1:i32 = var
%2:i1 = ult %0, %1
infer %2

; *****
; For LLVM instruction:
;  %5 = load i32, i32* %x, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %cmpinf = fcmp one double %7, 0x7FF0000000000000
; Looking for a replacement for:
%0:i1 = var
infer %0

; *****
; For LLVM instruction:
;  %8 = zext i1 %cmpinf to i32
; Looking for a replacement for:
%0:i1 = var
%1:i32 = zext %0
infer %1

; *****
; For LLVM instruction:
;  %cmp5 = icmp eq i32 %8, 0
; Looking for a replacement for:
%0:i1 = var
%1:i32 = zext %0
%2:i1 = eq 0:i32, %1
infer %2

; *****
; For LLVM instruction:
;  %10 = load i32, i32* %x, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %13 = load i32, i32* %x, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %inc = add i32 %13, 1
; Looking for a replacement for:
%0:i32 = var
%1:i32 = add 1:i32, %0
infer %1

; *****
; For LLVM instruction:
;  %14 = load i32, i32* %ARRAY1_SIZE.addr, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %16 = load i32, i32* %x9, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %17 = load i32, i32* %ARRAY2_SIZE.addr, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %cmp11 = icmp ult i32 %16, %17
; Looking for a replacement for:
%0:i32 = var
%1:i32 = var
%2:i1 = ult %0, %1
infer %2

; *****
; For LLVM instruction:
;  %19 = load i32, i32* %x9, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %cmpinf15 = fcmp one double %21, 0x7FF0000000000000
; Looking for a replacement for:
%0:i1 = var
infer %0

; *****
; For LLVM instruction:
;  %22 = zext i1 %cmpinf15 to i32
; Looking for a replacement for:
%0:i1 = var
%1:i32 = zext %0
infer %1

; *****
; For LLVM instruction:
;  %cmp16 = icmp eq i32 %22, 0
; Looking for a replacement for:
%0:i1 = var
%1:i32 = zext %0
%2:i1 = eq 0:i32, %1
infer %2

; *****
; For LLVM instruction:
;  %24 = load i32, i32* %x9, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %27 = load i32, i32* %x9, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %inc24 = add i32 %27, 1
; Looking for a replacement for:
%0:i32 = var
%1:i32 = add 1:i32, %0
infer %1

; *****
; For LLVM instruction:
;  %28 = load i32, i32* %ARRAY2_SIZE.addr, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %cmp28 = fcmp oeq double %30, %31
; Looking for a replacement for:
%0:i1 = var
infer %0

; *****
; For LLVM instruction:
;  %32 = load i32, i32* %x32, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %33 = load i32, i32* %ARRAY1_SIZE.addr, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %cmp34 = icmp ult i32 %32, %33
; Looking for a replacement for:
%0:i32 = var
%1:i32 = var
%2:i1 = ult %0, %1
infer %2

; *****
; For LLVM instruction:
;  %35 = load i32, i32* %x32, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %39 = load i32, i32* %x32, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %43 = load i32, i32* %x32, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %inc42 = add i32 %43, 1
; Looking for a replacement for:
%0:i32 = var
%1:i32 = add 1:i32, %0
infer %1

; *****
; For LLVM instruction:
;  %44 = load i32, i32* %x44, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %45 = load i32, i32* %ARRAY2_SIZE.addr, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %cmp46 = icmp ult i32 %44, %45
; Looking for a replacement for:
%0:i32 = var
%1:i32 = var
%2:i1 = ult %0, %1
infer %2

; *****
; For LLVM instruction:
;  %47 = load i32, i32* %x44, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %51 = load i32, i32* %x44, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %55 = load i32, i32* %x44, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %inc56 = add i32 %55, 1
; Looking for a replacement for:
%0:i32 = var
%1:i32 = add 1:i32, %0
infer %1

; *****
; For LLVM instruction:
;  %57 = load i32, i32* %ARRAY1_SIZE.addr, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %sub58 = sub i32 %57, 1
; Looking for a replacement for:
%0:i32 = var
%1:i32 = sub %0, 1:i32
infer %1

; *****
; For LLVM instruction:
;  %59 = load i32, i32* %ARRAY2_SIZE.addr, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %sub61 = sub i32 %59, 1
; Looking for a replacement for:
%0:i32 = var
%1:i32 = sub %0, 1:i32
infer %1

; *****
; For LLVM instruction:
;  %63 = load i32, i32* %ARRAY1_SIZE.addr, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %65 = load i32, i32* %ARRAY2_SIZE.addr, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %68 = load i32, i32* %ARRAY1_SIZE.addr, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %70 = load i32, i32* %ARRAY2_SIZE.addr, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %74 = load i32, i32* %ARRAY1_SIZE.addr, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %75 = load i32, i32* %ARRAY1_SIZE.addr, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %mul77 = mul i32 %74, %75
; Looking for a replacement for:
%0:i32 = var
%1:i32 = var
%2:i32 = mul %0, %1
infer %2

; *****
; For LLVM instruction:
;  %76 = load i32, i32* %ARRAY1_SIZE.addr, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %sub78 = sub i32 %76, 1
; Looking for a replacement for:
%0:i32 = var
%1:i32 = sub %0, 1:i32
infer %1

; *****
; For LLVM instruction:
;  %mul79 = mul i32 %mul77, %sub78
; Looking for a replacement for:
%0:i32 = var
%1:i32 = sub %0, 1:i32
%2:i32 = var
%3:i32 = var
%4:i32 = mul %2, %3
%5:i32 = mul %1, %4
infer %5

; *****
; For LLVM instruction:
;  %79 = load i32, i32* %ARRAY2_SIZE.addr, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %80 = load i32, i32* %ARRAY2_SIZE.addr, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %mul83 = mul i32 %79, %80
; Looking for a replacement for:
%0:i32 = var
%1:i32 = var
%2:i32 = mul %0, %1
infer %2

; *****
; For LLVM instruction:
;  %81 = load i32, i32* %ARRAY2_SIZE.addr, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %sub84 = sub i32 %81, 1
; Looking for a replacement for:
%0:i32 = var
%1:i32 = sub %0, 1:i32
infer %1

; *****
; For LLVM instruction:
;  %mul85 = mul i32 %mul83, %sub84
; Looking for a replacement for:
%0:i32 = var
%1:i32 = sub %0, 1:i32
%2:i32 = var
%3:i32 = var
%4:i32 = mul %2, %3
%5:i32 = mul %1, %4
infer %5

; *****
; For LLVM instruction:
;  %cmpinf94 = fcmp oeq double %88, 0x7FF0000000000000
; Looking for a replacement for:
%0:i1 = var
infer %0

; *****
; For LLVM instruction:
;  %cmp97 = fcmp uno double %89, %89
; Looking for a replacement for:
%0:i1 = var
infer %0

; *****
; For LLVM instruction:
;  %cmpinf102 = fcmp oeq double %91, 0x7FF0000000000000
; Looking for a replacement for:
%0:i1 = var
infer %0

; *****
; For LLVM instruction:
;  %92 = zext i1 %cmpinf102 to i32
; Looking for a replacement for:
%0:i1 = var
%1:i32 = zext %0
infer %1

; *****
; For LLVM instruction:
;  %cmp103 = icmp ne i32 %92, 0
; Looking for a replacement for:
%0:i1 = var
%1:i32 = zext %0
%2:i1 = ne 0:i32, %1
infer %2

; *****
; For LLVM instruction:
;  %cmp106 = fcmp uno double %93, %93
; Looking for a replacement for:
%0:i1 = var
infer %0

; *****
; For LLVM instruction:
;  %94 = zext i1 %cmp106 to i32
; Looking for a replacement for:
%0:i1 = var
%1:i32 = zext %0
infer %1

; *****
; For LLVM instruction:
;  %cmp107 = icmp ne i32 %94, 0
; Looking for a replacement for:
%0:i1 = var
%1:i32 = zext %0
%2:i1 = ne 0:i32, %1
infer %2

; *****
; For LLVM instruction:
;  %cmp119 = fcmp ole double %97, 0.000000e+00
; Looking for a replacement for:
%0:i1 = var
infer %0

; *****
; For LLVM instruction:
;  %cmp123 = fcmp olt double %98, 0.000000e+00
; Looking for a replacement for:
%0:i1 = var
infer %0

; *****
; For LLVM instruction:
;  %cmp126 = fcmp olt double 1.000000e+00, %99
; Looking for a replacement for:
%0:i1 = var
infer %0

; *****
; For LLVM instruction:
;  %cmp130 = fcmp oeq double %101, 0.000000e+00
; Looking for a replacement for:
%0:i1 = var
infer %0

; *****
; For LLVM instruction:
;  %cmp133 = fcmp oeq double %102, 1.000000e+00
; Looking for a replacement for:
%0:i1 = var
infer %0

; *****
; For LLVM instruction:
;  %cmp140 = fcmp olt double %106, %mul139
; Looking for a replacement for:
%0:i1 = var
infer %0

; *****
; For LLVM instruction:
;  %conv147 = fptosi double %add146 to i32
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %121 = load i32, i32* %ns, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %cmp150 = icmp eq i32 %121, 0
; Looking for a replacement for:
%0:i32 = var
%1:i1 = eq 0:i32, %0
infer %1

; *****
; For LLVM instruction:
;  %cmp160 = fcmp ole double %132, 1.000000e-15
; Looking for a replacement for:
%0:i1 = var
infer %0

; *****
; For LLVM instruction:
;  %cmp163 = fcmp ole double %133, %mul162
; Looking for a replacement for:
%0:i1 = var
infer %0

; *****
; For LLVM instruction:
;  %145 = load i32, i32* %indx, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %tobool = icmp ne i32 %145, 0
; Looking for a replacement for:
%0:i32 = var
%1:i1 = ne 0:i32, %0
infer %1

; *****
; For LLVM instruction:
;  %148 = load i32, i32* %ns, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %sub178 = sub nsw i32 %148, 1
; Looking for a replacement for:
%0:i32 = var
%1:i32 = subnsw %0, 1:i32
infer %1

; *****
; For LLVM instruction:
;  %149 = load i32, i32* %ns, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %cmp179 = icmp sle i32 0, %149
; Looking for a replacement for:
%0:i32 = var
%1:i1 = sle 0:i32, %0
infer %1

; *****
; For LLVM instruction:
;  %152 = load i32, i32* %ns, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %cmp183 = icmp eq i32 %152, 0
; Looking for a replacement for:
%0:i32 = var
%1:i1 = eq 0:i32, %0
infer %1
"
; No valid RHS in the list
#########################################################

Module before replacement:
; ModuleID = './Welchs_t-test.c.bc'
source_filename = "./Welchs_t-test.c"
target datalayout = "e-m:e-p:32:32-i64:64-n32:64-S128"
target triple = "wasm32-unknown-wasi"

@.str = private unnamed_addr constant [63 x i8] c"Got a non-finite number in 1st array, can't calculate P-value.\00", align 1
@.str.1 = private unnamed_addr constant [63 x i8] c"Got a non-finite number in 2nd array, can't calculate P-value.\00", align 1
@__const.main.d1 = private unnamed_addr constant [15 x double] [double 2.750000e+01, double 2.100000e+01, double 1.900000e+01, double 2.360000e+01, double 1.700000e+01, double 1.790000e+01, double 1.690000e+01, double 2.010000e+01, double 2.190000e+01, double 2.260000e+01, double 2.310000e+01, double 1.960000e+01, double 1.900000e+01, double 2.170000e+01, double 2.140000e+01], align 16
@__const.main.d2 = private unnamed_addr constant [15 x double] [double 2.710000e+01, double 2.200000e+01, double 2.080000e+01, double 2.340000e+01, double 2.340000e+01, double 2.350000e+01, double 2.580000e+01, double 2.200000e+01, double 2.480000e+01, double 2.020000e+01, double 2.190000e+01, double 2.210000e+01, double 2.290000e+01, double 2.050000e+01, double 2.440000e+01], align 16
@__const.main.d3 = private unnamed_addr constant [10 x double] [double 1.720000e+01, double 2.090000e+01, double 2.260000e+01, double 1.810000e+01, double 2.170000e+01, double 2.140000e+01, double 2.350000e+01, double 2.420000e+01, double 1.470000e+01, double 2.180000e+01], align 16
@__const.main.d4 = private unnamed_addr constant [20 x double] [double 2.150000e+01, double 2.280000e+01, double 2.100000e+01, double 2.300000e+01, double 2.160000e+01, double 2.360000e+01, double 2.250000e+01, double 2.070000e+01, double 2.340000e+01, double 2.180000e+01, double 2.070000e+01, double 2.170000e+01, double 2.150000e+01, double 2.250000e+01, double 2.360000e+01, double 2.150000e+01, double 2.250000e+01, double 2.350000e+01, double 2.150000e+01, double 2.180000e+01], align 16
@__const.main.d5 = private unnamed_addr constant [10 x double] [double 1.980000e+01, double 2.040000e+01, double 1.960000e+01, double 1.780000e+01, double 1.850000e+01, double 1.890000e+01, double 1.830000e+01, double 1.890000e+01, double 1.950000e+01, double 2.200000e+01], align 16
@__const.main.d6 = private unnamed_addr constant [20 x double] [double 2.820000e+01, double 2.660000e+01, double 2.010000e+01, double 2.330000e+01, double 2.520000e+01, double 2.210000e+01, double 1.770000e+01, double 2.760000e+01, double 2.060000e+01, double 1.370000e+01, double 2.320000e+01, double 1.750000e+01, double 2.060000e+01, double 1.800000e+01, double 2.390000e+01, double 2.160000e+01, double 2.430000e+01, double 2.040000e+01, double 2.400000e+01, double 1.320000e+01], align 16
@__const.main.x = private unnamed_addr constant [4 x double] [double 3.000000e+00, double 4.000000e+00, double 1.000000e+00, double 2.100000e+00], align 16
@__const.main.y = private unnamed_addr constant [3 x double] [double 4.902000e+02, double 3.400000e+02, double 4.339000e+02], align 16
@__const.main.v1 = private unnamed_addr constant [3 x double] [double 1.026800e-02, double 1.670000e-04, double 1.670000e-04], align 16
@__const.main.v2 = private unnamed_addr constant [3 x double] [double 1.592580e-01, double 1.362780e-01, double 1.223890e-01], align 16
@__const.main.s1 = private unnamed_addr constant [2 x double] [double 0x3FB1111111111111, double 0x3FC4A5294A5294A5], align 16
@__const.main.s2 = private unnamed_addr constant [2 x double] [double 1.000000e-01, double 4.000000e-02], align 16
@__const.main.z1 = private unnamed_addr constant [3 x double] [double 0x3FD90B21642C8591, double 0x3FDDDDDDDDDDDDDE, double 0.000000e+00], align 16
@__const.main.z2 = private unnamed_addr constant [3 x double] [double 0.000000e+00, double 0x3FDC9882B9310572, double 0.000000e+00], align 16
@__const.main.CORRECT_ANSWERS = private unnamed_addr constant [8 x double] [double 0x3F95E41D648C236F, double 0x3FC30D3EA599BB79, double 0x3FA26AF51F458AEB, double 0x3FB73CEBAB27FA12, double 0x3F8604EA1C27764A, double 0x3F6BD85EAF35CBC8, double 0x3FE0DF5C6BE20DA6, double 0x3FE172D38028625E], align 16
@.str.2 = private unnamed_addr constant [26 x i8] c"Test sets 1 p-value = %g\0A\00", align 1
@.str.3 = private unnamed_addr constant [26 x i8] c"Test sets 2 p-value = %g\0A\00", align 1
@.str.4 = private unnamed_addr constant [26 x i8] c"Test sets 3 p-value = %g\0A\00", align 1
@.str.5 = private unnamed_addr constant [26 x i8] c"Test sets 4 p-value = %g\0A\00", align 1
@.str.6 = private unnamed_addr constant [26 x i8] c"Test sets 5 p-value = %g\0A\00", align 1
@.str.7 = private unnamed_addr constant [26 x i8] c"Test sets 6 p-value = %g\0A\00", align 1
@.str.8 = private unnamed_addr constant [26 x i8] c"Test sets 7 p-value = %g\0A\00", align 1
@.str.9 = private unnamed_addr constant [26 x i8] c"Test sets z p-value = %g\0A\00", align 1
@.str.10 = private unnamed_addr constant [28 x i8] c"the cumulative error is %g\0A\00", align 1
@llvm.used = appending global [1 x i8*] [i8* bitcast (i32 ()* @__main_void to i8*)], section "llvm.metadata"

@__main_void = alias i32 (), i32 ()* @main

; Function Attrs: noinline nounwind optnone
define hidden double @Pvalue(double* noalias %ARRAY1, i32 %ARRAY1_SIZE, double* noalias %ARRAY2, i32 %ARRAY2_SIZE) #0 {
entry:
  %retval = alloca double, align 8
  %ARRAY1.addr = alloca double*, align 4
  %ARRAY1_SIZE.addr = alloca i32, align 4
  %ARRAY2.addr = alloca double*, align 4
  %ARRAY2_SIZE.addr = alloca i32, align 4
  %fmean1 = alloca double, align 8
  %fmean2 = alloca double, align 8
  %x = alloca i32, align 4
  %x9 = alloca i32, align 4
  %unbiased_sample_variance1 = alloca double, align 8
  %unbiased_sample_variance2 = alloca double, align 8
  %x32 = alloca i32, align 4
  %x44 = alloca i32, align 4
  %WELCH_T_STATISTIC = alloca double, align 8
  %DEGREES_OF_FREEDOM = alloca double, align 8
  %a = alloca double, align 8
  %value = alloca double, align 8
  %beta = alloca double, align 8
  %acu = alloca double, align 8
  %ai = alloca double, align 8
  %cx = alloca double, align 8
  %indx = alloca i32, align 4
  %ns = alloca i32, align 4
  %pp = alloca double, align 8
  %psq = alloca double, align 8
  %qq = alloca double, align 8
  %rx = alloca double, align 8
  %temp = alloca double, align 8
  %term = alloca double, align 8
  %xx = alloca double, align 8
  store double* %ARRAY1, double** %ARRAY1.addr, align 4
  store i32 %ARRAY1_SIZE, i32* %ARRAY1_SIZE.addr, align 4
  store double* %ARRAY2, double** %ARRAY2.addr, align 4
  store i32 %ARRAY2_SIZE, i32* %ARRAY2_SIZE.addr, align 4
  %0 = load i32, i32* %ARRAY1_SIZE.addr, align 4
  %cmp = icmp ule i32 %0, 1
  br i1 %cmp, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  store double 1.000000e+00, double* %retval, align 8
  br label %return

if.else:                                          ; preds = %entry
  %1 = load i32, i32* %ARRAY2_SIZE.addr, align 4
  %cmp1 = icmp ule i32 %1, 1
  br i1 %cmp1, label %if.then2, label %if.end

if.then2:                                         ; preds = %if.else
  store double 1.000000e+00, double* %retval, align 8
  br label %return

if.end:                                           ; preds = %if.else
  br label %if.end3

if.end3:                                          ; preds = %if.end
  store double 0.000000e+00, double* %fmean1, align 8
  store double 0.000000e+00, double* %fmean2, align 8
  store i32 0, i32* %x, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.end3
  %2 = load i32, i32* %x, align 4
  %3 = load i32, i32* %ARRAY1_SIZE.addr, align 4
  %cmp4 = icmp ult i32 %2, %3
  br i1 %cmp4, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %4 = load double*, double** %ARRAY1.addr, align 4
  %5 = load i32, i32* %x, align 4
  %arrayidx = getelementptr inbounds double, double* %4, i32 %5
  %6 = load double, double* %arrayidx, align 8
  %7 = call double @llvm.fabs.f64(double %6) #7
  %cmpinf = fcmp one double %7, 0x7FF0000000000000
  %8 = zext i1 %cmpinf to i32
  %cmp5 = icmp eq i32 %8, 0
  br i1 %cmp5, label %if.then6, label %if.end7

if.then6:                                         ; preds = %for.body
  %call = call i32 @puts(i8* getelementptr inbounds ([63 x i8], [63 x i8]* @.str, i32 0, i32 0))
  call void @exit(i32 1) #8
  unreachable

if.end7:                                          ; preds = %for.body
  %9 = load double*, double** %ARRAY1.addr, align 4
  %10 = load i32, i32* %x, align 4
  %arrayidx8 = getelementptr inbounds double, double* %9, i32 %10
  %11 = load double, double* %arrayidx8, align 8
  %12 = load double, double* %fmean1, align 8
  %add = fadd double %12, %11
  store double %add, double* %fmean1, align 8
  br label %for.inc

for.inc:                                          ; preds = %if.end7
  %13 = load i32, i32* %x, align 4
  %inc = add i32 %13, 1
  store i32 %inc, i32* %x, align 4
  br label %for.cond

for.end:                                          ; preds = %for.cond
  %14 = load i32, i32* %ARRAY1_SIZE.addr, align 4
  %conv = uitofp i32 %14 to double
  %15 = load double, double* %fmean1, align 8
  %div = fdiv double %15, %conv
  store double %div, double* %fmean1, align 8
  store i32 0, i32* %x9, align 4
  br label %for.cond10

for.cond10:                                       ; preds = %for.inc23, %for.end
  %16 = load i32, i32* %x9, align 4
  %17 = load i32, i32* %ARRAY2_SIZE.addr, align 4
  %cmp11 = icmp ult i32 %16, %17
  br i1 %cmp11, label %for.body13, label %for.end25

for.body13:                                       ; preds = %for.cond10
  %18 = load double*, double** %ARRAY2.addr, align 4
  %19 = load i32, i32* %x9, align 4
  %arrayidx14 = getelementptr inbounds double, double* %18, i32 %19
  %20 = load double, double* %arrayidx14, align 8
  %21 = call double @llvm.fabs.f64(double %20) #7
  %cmpinf15 = fcmp one double %21, 0x7FF0000000000000
  %22 = zext i1 %cmpinf15 to i32
  %cmp16 = icmp eq i32 %22, 0
  br i1 %cmp16, label %if.then18, label %if.end20

if.then18:                                        ; preds = %for.body13
  %call19 = call i32 @puts(i8* getelementptr inbounds ([63 x i8], [63 x i8]* @.str.1, i32 0, i32 0))
  call void @exit(i32 1) #8
  unreachable

if.end20:                                         ; preds = %for.body13
  %23 = load double*, double** %ARRAY2.addr, align 4
  %24 = load i32, i32* %x9, align 4
  %arrayidx21 = getelementptr inbounds double, double* %23, i32 %24
  %25 = load double, double* %arrayidx21, align 8
  %26 = load double, double* %fmean2, align 8
  %add22 = fadd double %26, %25
  store double %add22, double* %fmean2, align 8
  br label %for.inc23

for.inc23:                                        ; preds = %if.end20
  %27 = load i32, i32* %x9, align 4
  %inc24 = add i32 %27, 1
  store i32 %inc24, i32* %x9, align 4
  br label %for.cond10

for.end25:                                        ; preds = %for.cond10
  %28 = load i32, i32* %ARRAY2_SIZE.addr, align 4
  %conv26 = uitofp i32 %28 to double
  %29 = load double, double* %fmean2, align 8
  %div27 = fdiv double %29, %conv26
  store double %div27, double* %fmean2, align 8
  %30 = load double, double* %fmean1, align 8
  %31 = load double, double* %fmean2, align 8
  %cmp28 = fcmp oeq double %30, %31
  br i1 %cmp28, label %if.then30, label %if.end31

if.then30:                                        ; preds = %for.end25
  store double 1.000000e+00, double* %retval, align 8
  br label %return

if.end31:                                         ; preds = %for.end25
  store double 0.000000e+00, double* %unbiased_sample_variance1, align 8
  store double 0.000000e+00, double* %unbiased_sample_variance2, align 8
  store i32 0, i32* %x32, align 4
  br label %for.cond33

for.cond33:                                       ; preds = %for.inc41, %if.end31
  %32 = load i32, i32* %x32, align 4
  %33 = load i32, i32* %ARRAY1_SIZE.addr, align 4
  %cmp34 = icmp ult i32 %32, %33
  br i1 %cmp34, label %for.body36, label %for.end43

for.body36:                                       ; preds = %for.cond33
  %34 = load double*, double** %ARRAY1.addr, align 4
  %35 = load i32, i32* %x32, align 4
  %arrayidx37 = getelementptr inbounds double, double* %34, i32 %35
  %36 = load double, double* %arrayidx37, align 8
  %37 = load double, double* %fmean1, align 8
  %sub = fsub double %36, %37
  %38 = load double*, double** %ARRAY1.addr, align 4
  %39 = load i32, i32* %x32, align 4
  %arrayidx38 = getelementptr inbounds double, double* %38, i32 %39
  %40 = load double, double* %arrayidx38, align 8
  %41 = load double, double* %fmean1, align 8
  %sub39 = fsub double %40, %41
  %mul = fmul double %sub, %sub39
  %42 = load double, double* %unbiased_sample_variance1, align 8
  %add40 = fadd double %42, %mul
  store double %add40, double* %unbiased_sample_variance1, align 8
  br label %for.inc41

for.inc41:                                        ; preds = %for.body36
  %43 = load i32, i32* %x32, align 4
  %inc42 = add i32 %43, 1
  store i32 %inc42, i32* %x32, align 4
  br label %for.cond33

for.end43:                                        ; preds = %for.cond33
  store i32 0, i32* %x44, align 4
  br label %for.cond45

for.cond45:                                       ; preds = %for.inc55, %for.end43
  %44 = load i32, i32* %x44, align 4
  %45 = load i32, i32* %ARRAY2_SIZE.addr, align 4
  %cmp46 = icmp ult i32 %44, %45
  br i1 %cmp46, label %for.body48, label %for.end57

for.body48:                                       ; preds = %for.cond45
  %46 = load double*, double** %ARRAY2.addr, align 4
  %47 = load i32, i32* %x44, align 4
  %arrayidx49 = getelementptr inbounds double, double* %46, i32 %47
  %48 = load double, double* %arrayidx49, align 8
  %49 = load double, double* %fmean2, align 8
  %sub50 = fsub double %48, %49
  %50 = load double*, double** %ARRAY2.addr, align 4
  %51 = load i32, i32* %x44, align 4
  %arrayidx51 = getelementptr inbounds double, double* %50, i32 %51
  %52 = load double, double* %arrayidx51, align 8
  %53 = load double, double* %fmean2, align 8
  %sub52 = fsub double %52, %53
  %mul53 = fmul double %sub50, %sub52
  %54 = load double, double* %unbiased_sample_variance2, align 8
  %add54 = fadd double %54, %mul53
  store double %add54, double* %unbiased_sample_variance2, align 8
  br label %for.inc55

for.inc55:                                        ; preds = %for.body48
  %55 = load i32, i32* %x44, align 4
  %inc56 = add i32 %55, 1
  store i32 %inc56, i32* %x44, align 4
  br label %for.cond45

for.end57:                                        ; preds = %for.cond45
  %56 = load double, double* %unbiased_sample_variance1, align 8
  %57 = load i32, i32* %ARRAY1_SIZE.addr, align 4
  %sub58 = sub i32 %57, 1
  %conv59 = uitofp i32 %sub58 to double
  %div60 = fdiv double %56, %conv59
  store double %div60, double* %unbiased_sample_variance1, align 8
  %58 = load double, double* %unbiased_sample_variance2, align 8
  %59 = load i32, i32* %ARRAY2_SIZE.addr, align 4
  %sub61 = sub i32 %59, 1
  %conv62 = uitofp i32 %sub61 to double
  %div63 = fdiv double %58, %conv62
  store double %div63, double* %unbiased_sample_variance2, align 8
  %60 = load double, double* %fmean1, align 8
  %61 = load double, double* %fmean2, align 8
  %sub64 = fsub double %60, %61
  %62 = load double, double* %unbiased_sample_variance1, align 8
  %63 = load i32, i32* %ARRAY1_SIZE.addr, align 4
  %conv65 = uitofp i32 %63 to double
  %div66 = fdiv double %62, %conv65
  %64 = load double, double* %unbiased_sample_variance2, align 8
  %65 = load i32, i32* %ARRAY2_SIZE.addr, align 4
  %conv67 = uitofp i32 %65 to double
  %div68 = fdiv double %64, %conv67
  %add69 = fadd double %div66, %div68
  %66 = call double @llvm.sqrt.f64(double %add69)
  %div70 = fdiv double %sub64, %66
  store double %div70, double* %WELCH_T_STATISTIC, align 8
  %67 = load double, double* %unbiased_sample_variance1, align 8
  %68 = load i32, i32* %ARRAY1_SIZE.addr, align 4
  %conv71 = uitofp i32 %68 to double
  %div72 = fdiv double %67, %conv71
  %69 = load double, double* %unbiased_sample_variance2, align 8
  %70 = load i32, i32* %ARRAY2_SIZE.addr, align 4
  %conv73 = uitofp i32 %70 to double
  %div74 = fdiv double %69, %conv73
  %add75 = fadd double %div72, %div74
  %71 = call double @llvm.pow.f64(double %add75, double 2.000000e+00)
  %72 = load double, double* %unbiased_sample_variance1, align 8
  %73 = load double, double* %unbiased_sample_variance1, align 8
  %mul76 = fmul double %72, %73
  %74 = load i32, i32* %ARRAY1_SIZE.addr, align 4
  %75 = load i32, i32* %ARRAY1_SIZE.addr, align 4
  %mul77 = mul i32 %74, %75
  %76 = load i32, i32* %ARRAY1_SIZE.addr, align 4
  %sub78 = sub i32 %76, 1
  %mul79 = mul i32 %mul77, %sub78
  %conv80 = uitofp i32 %mul79 to double
  %div81 = fdiv double %mul76, %conv80
  %77 = load double, double* %unbiased_sample_variance2, align 8
  %78 = load double, double* %unbiased_sample_variance2, align 8
  %mul82 = fmul double %77, %78
  %79 = load i32, i32* %ARRAY2_SIZE.addr, align 4
  %80 = load i32, i32* %ARRAY2_SIZE.addr, align 4
  %mul83 = mul i32 %79, %80
  %81 = load i32, i32* %ARRAY2_SIZE.addr, align 4
  %sub84 = sub i32 %81, 1
  %mul85 = mul i32 %mul83, %sub84
  %conv86 = uitofp i32 %mul85 to double
  %div87 = fdiv double %mul82, %conv86
  %add88 = fadd double %div81, %div87
  %div89 = fdiv double %71, %add88
  store double %div89, double* %DEGREES_OF_FREEDOM, align 8
  %82 = load double, double* %DEGREES_OF_FREEDOM, align 8
  %div90 = fdiv double %82, 2.000000e+00
  store double %div90, double* %a, align 8
  %83 = load double, double* %DEGREES_OF_FREEDOM, align 8
  %84 = load double, double* %WELCH_T_STATISTIC, align 8
  %85 = load double, double* %WELCH_T_STATISTIC, align 8
  %mul91 = fmul double %84, %85
  %86 = load double, double* %DEGREES_OF_FREEDOM, align 8
  %add92 = fadd double %mul91, %86
  %div93 = fdiv double %83, %add92
  store double %div93, double* %value, align 8
  %87 = load double, double* %value, align 8
  %88 = call double @llvm.fabs.f64(double %87) #7
  %cmpinf94 = fcmp oeq double %88, 0x7FF0000000000000
  br i1 %cmpinf94, label %if.then100, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %for.end57
  %89 = load double, double* %value, align 8
  %cmp97 = fcmp uno double %89, %89
  br i1 %cmp97, label %if.then100, label %if.end101

if.then100:                                       ; preds = %lor.lhs.false, %for.end57
  store double 1.000000e+00, double* %retval, align 8
  br label %return

if.end101:                                        ; preds = %lor.lhs.false
  %90 = load double, double* %value, align 8
  %91 = call double @llvm.fabs.f64(double %90) #7
  %cmpinf102 = fcmp oeq double %91, 0x7FF0000000000000
  %92 = zext i1 %cmpinf102 to i32
  %cmp103 = icmp ne i32 %92, 0
  br i1 %cmp103, label %if.then109, label %lor.lhs.false105

lor.lhs.false105:                                 ; preds = %if.end101
  %93 = load double, double* %value, align 8
  %cmp106 = fcmp uno double %93, %93
  %94 = zext i1 %cmp106 to i32
  %cmp107 = icmp ne i32 %94, 0
  br i1 %cmp107, label %if.then109, label %if.end110

if.then109:                                       ; preds = %lor.lhs.false105, %if.end101
  store double 1.000000e+00, double* %retval, align 8
  br label %return

if.end110:                                        ; preds = %lor.lhs.false105
  %95 = load double, double* %a, align 8
  %conv111 = fpext double %95 to fp128
  %call112 = call fp128 @lgammal(fp128 %conv111) #9
  %add113 = fadd fp128 %call112, 0xLD0000000000000003FFE250D048E7A1B
  %96 = load double, double* %a, align 8
  %add114 = fadd double %96, 5.000000e-01
  %conv115 = fpext double %add114 to fp128
  %call116 = call fp128 @lgammal(fp128 %conv115) #9
  %sub117 = fsub fp128 %add113, %call116
  %conv118 = fptrunc fp128 %sub117 to double
  store double %conv118, double* %beta, align 8
  store double 1.000000e-15, double* %acu, align 8
  %97 = load double, double* %a, align 8
  %cmp119 = fcmp ole double %97, 0.000000e+00
  br i1 %cmp119, label %if.then121, label %if.end122

if.then121:                                       ; preds = %if.end110
  br label %if.end122

if.end122:                                        ; preds = %if.then121, %if.end110
  %98 = load double, double* %value, align 8
  %cmp123 = fcmp olt double %98, 0.000000e+00
  br i1 %cmp123, label %if.then128, label %lor.lhs.false125

lor.lhs.false125:                                 ; preds = %if.end122
  %99 = load double, double* %value, align 8
  %cmp126 = fcmp olt double 1.000000e+00, %99
  br i1 %cmp126, label %if.then128, label %if.end129

if.then128:                                       ; preds = %lor.lhs.false125, %if.end122
  %100 = load double, double* %value, align 8
  store double %100, double* %retval, align 8
  br label %return

if.end129:                                        ; preds = %lor.lhs.false125
  %101 = load double, double* %value, align 8
  %cmp130 = fcmp oeq double %101, 0.000000e+00
  br i1 %cmp130, label %if.then135, label %lor.lhs.false132

lor.lhs.false132:                                 ; preds = %if.end129
  %102 = load double, double* %value, align 8
  %cmp133 = fcmp oeq double %102, 1.000000e+00
  br i1 %cmp133, label %if.then135, label %if.end136

if.then135:                                       ; preds = %lor.lhs.false132, %if.end129
  %103 = load double, double* %value, align 8
  store double %103, double* %retval, align 8
  br label %return

if.end136:                                        ; preds = %lor.lhs.false132
  %104 = load double, double* %a, align 8
  %add137 = fadd double %104, 5.000000e-01
  store double %add137, double* %psq, align 8
  %105 = load double, double* %value, align 8
  %sub138 = fsub double 1.000000e+00, %105
  store double %sub138, double* %cx, align 8
  %106 = load double, double* %a, align 8
  %107 = load double, double* %psq, align 8
  %108 = load double, double* %value, align 8
  %mul139 = fmul double %107, %108
  %cmp140 = fcmp olt double %106, %mul139
  br i1 %cmp140, label %if.then142, label %if.else143

if.then142:                                       ; preds = %if.end136
  %109 = load double, double* %cx, align 8
  store double %109, double* %xx, align 8
  %110 = load double, double* %value, align 8
  store double %110, double* %cx, align 8
  store double 5.000000e-01, double* %pp, align 8
  %111 = load double, double* %a, align 8
  store double %111, double* %qq, align 8
  store i32 1, i32* %indx, align 4
  br label %if.end144

if.else143:                                       ; preds = %if.end136
  %112 = load double, double* %value, align 8
  store double %112, double* %xx, align 8
  %113 = load double, double* %a, align 8
  store double %113, double* %pp, align 8
  store double 5.000000e-01, double* %qq, align 8
  store i32 0, i32* %indx, align 4
  br label %if.end144

if.end144:                                        ; preds = %if.else143, %if.then142
  store double 1.000000e+00, double* %term, align 8
  store double 1.000000e+00, double* %ai, align 8
  store double 1.000000e+00, double* %value, align 8
  %114 = load double, double* %qq, align 8
  %115 = load double, double* %cx, align 8
  %116 = load double, double* %psq, align 8
  %mul145 = fmul double %115, %116
  %add146 = fadd double %114, %mul145
  %conv147 = fptosi double %add146 to i32
  store i32 %conv147, i32* %ns, align 4
  %117 = load double, double* %xx, align 8
  %118 = load double, double* %cx, align 8
  %div148 = fdiv double %117, %118
  store double %div148, double* %rx, align 8
  %119 = load double, double* %qq, align 8
  %120 = load double, double* %ai, align 8
  %sub149 = fsub double %119, %120
  store double %sub149, double* %temp, align 8
  %121 = load i32, i32* %ns, align 4
  %cmp150 = icmp eq i32 %121, 0
  br i1 %cmp150, label %if.then152, label %if.end153

if.then152:                                       ; preds = %if.end144
  %122 = load double, double* %xx, align 8
  store double %122, double* %rx, align 8
  br label %if.end153

if.end153:                                        ; preds = %if.then152, %if.end144
  br label %for.cond154

for.cond154:                                      ; preds = %if.end189, %if.end153
  %123 = load double, double* %term, align 8
  %124 = load double, double* %temp, align 8
  %mul155 = fmul double %123, %124
  %125 = load double, double* %rx, align 8
  %mul156 = fmul double %mul155, %125
  %126 = load double, double* %pp, align 8
  %127 = load double, double* %ai, align 8
  %add157 = fadd double %126, %127
  %div158 = fdiv double %mul156, %add157
  store double %div158, double* %term, align 8
  %128 = load double, double* %value, align 8
  %129 = load double, double* %term, align 8
  %add159 = fadd double %128, %129
  store double %add159, double* %value, align 8
  %130 = load double, double* %term, align 8
  %131 = call double @llvm.fabs.f64(double %130)
  store double %131, double* %temp, align 8
  %132 = load double, double* %temp, align 8
  %cmp160 = fcmp ole double %132, 1.000000e-15
  br i1 %cmp160, label %land.lhs.true, label %if.end176

land.lhs.true:                                    ; preds = %for.cond154
  %133 = load double, double* %temp, align 8
  %134 = load double, double* %value, align 8
  %mul162 = fmul double 1.000000e-15, %134
  %cmp163 = fcmp ole double %133, %mul162
  br i1 %cmp163, label %if.then165, label %if.end176

if.then165:                                       ; preds = %land.lhs.true
  %135 = load double, double* %value, align 8
  %136 = load double, double* %pp, align 8
  %137 = load double, double* %xx, align 8
  %138 = call double @llvm.log.f64(double %137)
  %mul166 = fmul double %136, %138
  %139 = load double, double* %qq, align 8
  %sub167 = fsub double %139, 1.000000e+00
  %140 = load double, double* %cx, align 8
  %141 = call double @llvm.log.f64(double %140)
  %mul168 = fmul double %sub167, %141
  %add169 = fadd double %mul166, %mul168
  %142 = load double, double* %beta, align 8
  %sub170 = fsub double %add169, %142
  %143 = call double @llvm.exp.f64(double %sub170)
  %mul171 = fmul double %135, %143
  %144 = load double, double* %pp, align 8
  %div172 = fdiv double %mul171, %144
  store double %div172, double* %value, align 8
  %145 = load i32, i32* %indx, align 4
  %tobool = icmp ne i32 %145, 0
  br i1 %tobool, label %if.then173, label %if.end175

if.then173:                                       ; preds = %if.then165
  %146 = load double, double* %value, align 8
  %sub174 = fsub double 1.000000e+00, %146
  store double %sub174, double* %value, align 8
  br label %if.end175

if.end175:                                        ; preds = %if.then173, %if.then165
  br label %for.end190

if.end176:                                        ; preds = %land.lhs.true, %for.cond154
  %147 = load double, double* %ai, align 8
  %add177 = fadd double %147, 1.000000e+00
  store double %add177, double* %ai, align 8
  %148 = load i32, i32* %ns, align 4
  %sub178 = sub nsw i32 %148, 1
  store i32 %sub178, i32* %ns, align 4
  %149 = load i32, i32* %ns, align 4
  %cmp179 = icmp sle i32 0, %149
  br i1 %cmp179, label %if.then181, label %if.else187

if.then181:                                       ; preds = %if.end176
  %150 = load double, double* %qq, align 8
  %151 = load double, double* %ai, align 8
  %sub182 = fsub double %150, %151
  store double %sub182, double* %temp, align 8
  %152 = load i32, i32* %ns, align 4
  %cmp183 = icmp eq i32 %152, 0
  br i1 %cmp183, label %if.then185, label %if.end186

if.then185:                                       ; preds = %if.then181
  %153 = load double, double* %xx, align 8
  store double %153, double* %rx, align 8
  br label %if.end186

if.end186:                                        ; preds = %if.then185, %if.then181
  br label %if.end189

if.else187:                                       ; preds = %if.end176
  %154 = load double, double* %psq, align 8
  store double %154, double* %temp, align 8
  %155 = load double, double* %psq, align 8
  %add188 = fadd double %155, 1.000000e+00
  store double %add188, double* %psq, align 8
  br label %if.end189

if.end189:                                        ; preds = %if.else187, %if.end186
  br label %for.cond154

for.end190:                                       ; preds = %if.end175
  %156 = load double, double* %value, align 8
  store double %156, double* %retval, align 8
  br label %return

return:                                           ; preds = %for.end190, %if.then135, %if.then128, %if.then109, %if.then100, %if.then30, %if.then2, %if.then
  %157 = load double, double* %retval, align 8
  ret double %157
}

; Function Attrs: nounwind readnone speculatable willreturn
declare double @llvm.fabs.f64(double %0) #1

declare i32 @puts(i8* %0) #2

; Function Attrs: noreturn
declare void @exit(i32 %0) #3

; Function Attrs: nounwind readnone speculatable willreturn
declare double @llvm.sqrt.f64(double %0) #1

; Function Attrs: nounwind readnone speculatable willreturn
declare double @llvm.pow.f64(double %0, double %1) #1

; Function Attrs: nounwind
declare fp128 @lgammal(fp128 %0) #4

; Function Attrs: nounwind readnone speculatable willreturn
declare double @llvm.log.f64(double %0) #1

; Function Attrs: nounwind readnone speculatable willreturn
declare double @llvm.exp.f64(double %0) #1

; Function Attrs: noinline nounwind optnone
define hidden i32 @main() #0 {
entry:
  %retval = alloca i32, align 4
  %d1 = alloca [15 x double], align 16
  %d2 = alloca [15 x double], align 16
  %d3 = alloca [10 x double], align 16
  %d4 = alloca [20 x double], align 16
  %d5 = alloca [10 x double], align 16
  %d6 = alloca [20 x double], align 16
  %d7 = alloca [6 x double], align 16
  %d8 = alloca [6 x double], align 16
  %x = alloca [4 x double], align 16
  %y = alloca [3 x double], align 16
  %v1 = alloca [3 x double], align 16
  %v2 = alloca [3 x double], align 16
  %s1 = alloca [2 x double], align 16
  %s2 = alloca [2 x double], align 16
  %z1 = alloca [3 x double], align 16
  %z2 = alloca [3 x double], align 16
  %CORRECT_ANSWERS = alloca [8 x double], align 16
  %pvalue = alloca double, align 8
  %error = alloca double, align 8
  store i32 0, i32* %retval, align 4
  %0 = bitcast [15 x double]* %d1 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 16 %0, i8* align 16 bitcast ([15 x double]* @__const.main.d1 to i8*), i32 120, i1 false)
  %1 = bitcast [15 x double]* %d2 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 16 %1, i8* align 16 bitcast ([15 x double]* @__const.main.d2 to i8*), i32 120, i1 false)
  %2 = bitcast [10 x double]* %d3 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 16 %2, i8* align 16 bitcast ([10 x double]* @__const.main.d3 to i8*), i32 80, i1 false)
  %3 = bitcast [20 x double]* %d4 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 16 %3, i8* align 16 bitcast ([20 x double]* @__const.main.d4 to i8*), i32 160, i1 false)
  %4 = bitcast [10 x double]* %d5 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 16 %4, i8* align 16 bitcast ([10 x double]* @__const.main.d5 to i8*), i32 80, i1 false)
  %5 = bitcast [20 x double]* %d6 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 16 %5, i8* align 16 bitcast ([20 x double]* @__const.main.d6 to i8*), i32 160, i1 false)
  %6 = bitcast [6 x double]* %d7 to i8*
  call void @llvm.memset.p0i8.i32(i8* align 16 %6, i8 0, i32 48, i1 false)
  %7 = bitcast i8* %6 to [6 x double]*
  %8 = getelementptr inbounds [6 x double], [6 x double]* %7, i32 0, i32 0
  store double 3.002000e+01, double* %8, align 16
  %9 = getelementptr inbounds [6 x double], [6 x double]* %7, i32 0, i32 1
  store double 2.999000e+01, double* %9, align 8
  %10 = getelementptr inbounds [6 x double], [6 x double]* %7, i32 0, i32 2
  store double 3.011000e+01, double* %10, align 16
  %11 = getelementptr inbounds [6 x double], [6 x double]* %7, i32 0, i32 3
  store double 2.997000e+01, double* %11, align 8
  %12 = getelementptr inbounds [6 x double], [6 x double]* %7, i32 0, i32 4
  store double 3.001000e+01, double* %12, align 16
  %13 = getelementptr inbounds [6 x double], [6 x double]* %7, i32 0, i32 5
  store double 2.999000e+01, double* %13, align 8
  %14 = bitcast [6 x double]* %d8 to i8*
  call void @llvm.memset.p0i8.i32(i8* align 16 %14, i8 0, i32 48, i1 false)
  %15 = bitcast i8* %14 to [6 x double]*
  %16 = getelementptr inbounds [6 x double], [6 x double]* %15, i32 0, i32 0
  store double 2.989000e+01, double* %16, align 16
  %17 = getelementptr inbounds [6 x double], [6 x double]* %15, i32 0, i32 1
  store double 2.993000e+01, double* %17, align 8
  %18 = getelementptr inbounds [6 x double], [6 x double]* %15, i32 0, i32 2
  store double 2.972000e+01, double* %18, align 16
  %19 = getelementptr inbounds [6 x double], [6 x double]* %15, i32 0, i32 3
  store double 2.998000e+01, double* %19, align 8
  %20 = getelementptr inbounds [6 x double], [6 x double]* %15, i32 0, i32 4
  store double 3.002000e+01, double* %20, align 16
  %21 = getelementptr inbounds [6 x double], [6 x double]* %15, i32 0, i32 5
  store double 2.998000e+01, double* %21, align 8
  %22 = bitcast [4 x double]* %x to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 16 %22, i8* align 16 bitcast ([4 x double]* @__const.main.x to i8*), i32 32, i1 false)
  %23 = bitcast [3 x double]* %y to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 16 %23, i8* align 16 bitcast ([3 x double]* @__const.main.y to i8*), i32 24, i1 false)
  %24 = bitcast [3 x double]* %v1 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 16 %24, i8* align 16 bitcast ([3 x double]* @__const.main.v1 to i8*), i32 24, i1 false)
  %25 = bitcast [3 x double]* %v2 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 16 %25, i8* align 16 bitcast ([3 x double]* @__const.main.v2 to i8*), i32 24, i1 false)
  %26 = bitcast [2 x double]* %s1 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 16 %26, i8* align 16 bitcast ([2 x double]* @__const.main.s1 to i8*), i32 16, i1 false)
  %27 = bitcast [2 x double]* %s2 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 16 %27, i8* align 16 bitcast ([2 x double]* @__const.main.s2 to i8*), i32 16, i1 false)
  %28 = bitcast [3 x double]* %z1 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 16 %28, i8* align 16 bitcast ([3 x double]* @__const.main.z1 to i8*), i32 24, i1 false)
  %29 = bitcast [3 x double]* %z2 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 16 %29, i8* align 16 bitcast ([3 x double]* @__const.main.z2 to i8*), i32 24, i1 false)
  %30 = bitcast [8 x double]* %CORRECT_ANSWERS to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 16 %30, i8* align 16 bitcast ([8 x double]* @__const.main.CORRECT_ANSWERS to i8*), i32 64, i1 false)
  %arraydecay = getelementptr inbounds [15 x double], [15 x double]* %d1, i32 0, i32 0
  %arraydecay1 = getelementptr inbounds [15 x double], [15 x double]* %d2, i32 0, i32 0
  %call = call double @Pvalue(double* %arraydecay, i32 15, double* %arraydecay1, i32 15)
  store double %call, double* %pvalue, align 8
  %31 = load double, double* %pvalue, align 8
  %arrayidx = getelementptr inbounds [8 x double], [8 x double]* %CORRECT_ANSWERS, i32 0, i32 0
  %32 = load double, double* %arrayidx, align 16
  %sub = fsub double %31, %32
  %33 = call double @llvm.fabs.f64(double %sub)
  store double %33, double* %error, align 8
  %34 = load double, double* %pvalue, align 8
  %call2 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([26 x i8], [26 x i8]* @.str.2, i32 0, i32 0), double %34)
  %arraydecay3 = getelementptr inbounds [10 x double], [10 x double]* %d3, i32 0, i32 0
  %arraydecay4 = getelementptr inbounds [20 x double], [20 x double]* %d4, i32 0, i32 0
  %call5 = call double @Pvalue(double* %arraydecay3, i32 10, double* %arraydecay4, i32 20)
  store double %call5, double* %pvalue, align 8
  %35 = load double, double* %pvalue, align 8
  %arrayidx6 = getelementptr inbounds [8 x double], [8 x double]* %CORRECT_ANSWERS, i32 0, i32 1
  %36 = load double, double* %arrayidx6, align 8
  %sub7 = fsub double %35, %36
  %37 = call double @llvm.fabs.f64(double %sub7)
  %38 = load double, double* %error, align 8
  %add = fadd double %38, %37
  store double %add, double* %error, align 8
  %39 = load double, double* %pvalue, align 8
  %call8 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([26 x i8], [26 x i8]* @.str.3, i32 0, i32 0), double %39)
  %arraydecay9 = getelementptr inbounds [10 x double], [10 x double]* %d5, i32 0, i32 0
  %arraydecay10 = getelementptr inbounds [20 x double], [20 x double]* %d6, i32 0, i32 0
  %call11 = call double @Pvalue(double* %arraydecay9, i32 10, double* %arraydecay10, i32 20)
  store double %call11, double* %pvalue, align 8
  %40 = load double, double* %pvalue, align 8
  %arrayidx12 = getelementptr inbounds [8 x double], [8 x double]* %CORRECT_ANSWERS, i32 0, i32 2
  %41 = load double, double* %arrayidx12, align 16
  %sub13 = fsub double %40, %41
  %42 = call double @llvm.fabs.f64(double %sub13)
  %43 = load double, double* %error, align 8
  %add14 = fadd double %43, %42
  store double %add14, double* %error, align 8
  %44 = load double, double* %pvalue, align 8
  %call15 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([26 x i8], [26 x i8]* @.str.4, i32 0, i32 0), double %44)
  %arraydecay16 = getelementptr inbounds [6 x double], [6 x double]* %d7, i32 0, i32 0
  %arraydecay17 = getelementptr inbounds [6 x double], [6 x double]* %d8, i32 0, i32 0
  %call18 = call double @Pvalue(double* %arraydecay16, i32 6, double* %arraydecay17, i32 6)
  store double %call18, double* %pvalue, align 8
  %45 = load double, double* %pvalue, align 8
  %call19 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([26 x i8], [26 x i8]* @.str.5, i32 0, i32 0), double %45)
  %46 = load double, double* %pvalue, align 8
  %arrayidx20 = getelementptr inbounds [8 x double], [8 x double]* %CORRECT_ANSWERS, i32 0, i32 3
  %47 = load double, double* %arrayidx20, align 8
  %sub21 = fsub double %46, %47
  %48 = call double @llvm.fabs.f64(double %sub21)
  %49 = load double, double* %error, align 8
  %add22 = fadd double %49, %48
  store double %add22, double* %error, align 8
  %arraydecay23 = getelementptr inbounds [4 x double], [4 x double]* %x, i32 0, i32 0
  %arraydecay24 = getelementptr inbounds [3 x double], [3 x double]* %y, i32 0, i32 0
  %call25 = call double @Pvalue(double* %arraydecay23, i32 4, double* %arraydecay24, i32 3)
  store double %call25, double* %pvalue, align 8
  %50 = load double, double* %pvalue, align 8
  %arrayidx26 = getelementptr inbounds [8 x double], [8 x double]* %CORRECT_ANSWERS, i32 0, i32 4
  %51 = load double, double* %arrayidx26, align 16
  %sub27 = fsub double %50, %51
  %52 = call double @llvm.fabs.f64(double %sub27)
  %53 = load double, double* %error, align 8
  %add28 = fadd double %53, %52
  store double %add28, double* %error, align 8
  %54 = load double, double* %pvalue, align 8
  %call29 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([26 x i8], [26 x i8]* @.str.6, i32 0, i32 0), double %54)
  %arraydecay30 = getelementptr inbounds [3 x double], [3 x double]* %v1, i32 0, i32 0
  %arraydecay31 = getelementptr inbounds [3 x double], [3 x double]* %v2, i32 0, i32 0
  %call32 = call double @Pvalue(double* %arraydecay30, i32 3, double* %arraydecay31, i32 3)
  store double %call32, double* %pvalue, align 8
  %55 = load double, double* %pvalue, align 8
  %arrayidx33 = getelementptr inbounds [8 x double], [8 x double]* %CORRECT_ANSWERS, i32 0, i32 5
  %56 = load double, double* %arrayidx33, align 8
  %sub34 = fsub double %55, %56
  %57 = call double @llvm.fabs.f64(double %sub34)
  %58 = load double, double* %error, align 8
  %add35 = fadd double %58, %57
  store double %add35, double* %error, align 8
  %59 = load double, double* %pvalue, align 8
  %call36 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([26 x i8], [26 x i8]* @.str.7, i32 0, i32 0), double %59)
  %arraydecay37 = getelementptr inbounds [2 x double], [2 x double]* %s1, i32 0, i32 0
  %arraydecay38 = getelementptr inbounds [2 x double], [2 x double]* %s2, i32 0, i32 0
  %call39 = call double @Pvalue(double* %arraydecay37, i32 2, double* %arraydecay38, i32 2)
  store double %call39, double* %pvalue, align 8
  %60 = load double, double* %pvalue, align 8
  %arrayidx40 = getelementptr inbounds [8 x double], [8 x double]* %CORRECT_ANSWERS, i32 0, i32 6
  %61 = load double, double* %arrayidx40, align 16
  %sub41 = fsub double %60, %61
  %62 = call double @llvm.fabs.f64(double %sub41)
  %63 = load double, double* %error, align 8
  %add42 = fadd double %63, %62
  store double %add42, double* %error, align 8
  %64 = load double, double* %pvalue, align 8
  %call43 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([26 x i8], [26 x i8]* @.str.8, i32 0, i32 0), double %64)
  %arraydecay44 = getelementptr inbounds [3 x double], [3 x double]* %z1, i32 0, i32 0
  %arraydecay45 = getelementptr inbounds [3 x double], [3 x double]* %z2, i32 0, i32 0
  %call46 = call double @Pvalue(double* %arraydecay44, i32 3, double* %arraydecay45, i32 3)
  store double %call46, double* %pvalue, align 8
  %65 = load double, double* %pvalue, align 8
  %arrayidx47 = getelementptr inbounds [8 x double], [8 x double]* %CORRECT_ANSWERS, i32 0, i32 7
  %66 = load double, double* %arrayidx47, align 8
  %sub48 = fsub double %65, %66
  %67 = call double @llvm.fabs.f64(double %sub48)
  %68 = load double, double* %error, align 8
  %add49 = fadd double %68, %67
  store double %add49, double* %error, align 8
  %69 = load double, double* %pvalue, align 8
  %call50 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([26 x i8], [26 x i8]* @.str.9, i32 0, i32 0), double %69)
  %70 = load double, double* %error, align 8
  %call51 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([28 x i8], [28 x i8]* @.str.10, i32 0, i32 0), double %70)
  ret i32 0
}

; Function Attrs: argmemonly nounwind willreturn
declare void @llvm.memcpy.p0i8.p0i8.i32(i8* noalias nocapture writeonly %0, i8* noalias nocapture readonly %1, i32 %2, i1 immarg %3) #5

; Function Attrs: argmemonly nounwind willreturn writeonly
declare void @llvm.memset.p0i8.i32(i8* nocapture writeonly %0, i8 %1, i32 %2, i1 immarg %3) #6

declare i32 @printf(i8* %0, ...) #2

attributes #0 = { noinline nounwind optnone "correctly-rounded-divide-sqrt-fp-math"="false" "disable-tail-calls"="false" "frame-pointer"="none" "less-precise-fpmad"="false" "min-legal-vector-width"="0" "no-infs-fp-math"="false" "no-jump-tables"="false" "no-nans-fp-math"="false" "no-signed-zeros-fp-math"="false" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="generic" "unsafe-fp-math"="false" "use-soft-float"="false" }
attributes #1 = { nounwind readnone speculatable willreturn }
attributes #2 = { "correctly-rounded-divide-sqrt-fp-math"="false" "disable-tail-calls"="false" "frame-pointer"="none" "less-precise-fpmad"="false" "no-infs-fp-math"="false" "no-nans-fp-math"="false" "no-signed-zeros-fp-math"="false" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="generic" "unsafe-fp-math"="false" "use-soft-float"="false" }
attributes #3 = { noreturn "correctly-rounded-divide-sqrt-fp-math"="false" "disable-tail-calls"="false" "frame-pointer"="none" "less-precise-fpmad"="false" "no-infs-fp-math"="false" "no-nans-fp-math"="false" "no-signed-zeros-fp-math"="false" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="generic" "unsafe-fp-math"="false" "use-soft-float"="false" }
attributes #4 = { nounwind "correctly-rounded-divide-sqrt-fp-math"="false" "disable-tail-calls"="false" "frame-pointer"="none" "less-precise-fpmad"="false" "no-infs-fp-math"="false" "no-nans-fp-math"="false" "no-signed-zeros-fp-math"="false" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="generic" "unsafe-fp-math"="false" "use-soft-float"="false" }
attributes #5 = { argmemonly nounwind willreturn }
attributes #6 = { argmemonly nounwind willreturn writeonly }
attributes #7 = { readnone }
attributes #8 = { noreturn }
attributes #9 = { nounwind }

!llvm.module.flags = !{!0}
!llvm.ident = !{!1}

!0 = !{i32 1, !"wchar_size", i32 4}
!1 = !{!"clang version 11.0.0 (https://github.com/Jacarte/llvm-project.git 0f6dea67136cc1e0b3d200eb2bb165628970c44b)"}

; Replacing "  %cmp103 = icmp ne i32 %92, 0"
; from ""
; with "  %cmpinf102 = fcmp oeq double %91, 0x7FF0000000000000" in:
"%0:i1 = var
%1:i32 = zext %0
%2:i1 = ne 0:i32, %1
cand %2 %0
"
; with "  %cmpinf102 = fcmp oeq double %91, 0x7FF0000000000000"

Module after replacement:
; ModuleID = './Welchs_t-test.c.bc'
source_filename = "./Welchs_t-test.c"
target datalayout = "e-m:e-p:32:32-i64:64-n32:64-S128"
target triple = "wasm32-unknown-wasi"

@.str = private unnamed_addr constant [63 x i8] c"Got a non-finite number in 1st array, can't calculate P-value.\00", align 1
@.str.1 = private unnamed_addr constant [63 x i8] c"Got a non-finite number in 2nd array, can't calculate P-value.\00", align 1
@__const.main.d1 = private unnamed_addr constant [15 x double] [double 2.750000e+01, double 2.100000e+01, double 1.900000e+01, double 2.360000e+01, double 1.700000e+01, double 1.790000e+01, double 1.690000e+01, double 2.010000e+01, double 2.190000e+01, double 2.260000e+01, double 2.310000e+01, double 1.960000e+01, double 1.900000e+01, double 2.170000e+01, double 2.140000e+01], align 16
@__const.main.d2 = private unnamed_addr constant [15 x double] [double 2.710000e+01, double 2.200000e+01, double 2.080000e+01, double 2.340000e+01, double 2.340000e+01, double 2.350000e+01, double 2.580000e+01, double 2.200000e+01, double 2.480000e+01, double 2.020000e+01, double 2.190000e+01, double 2.210000e+01, double 2.290000e+01, double 2.050000e+01, double 2.440000e+01], align 16
@__const.main.d3 = private unnamed_addr constant [10 x double] [double 1.720000e+01, double 2.090000e+01, double 2.260000e+01, double 1.810000e+01, double 2.170000e+01, double 2.140000e+01, double 2.350000e+01, double 2.420000e+01, double 1.470000e+01, double 2.180000e+01], align 16
@__const.main.d4 = private unnamed_addr constant [20 x double] [double 2.150000e+01, double 2.280000e+01, double 2.100000e+01, double 2.300000e+01, double 2.160000e+01, double 2.360000e+01, double 2.250000e+01, double 2.070000e+01, double 2.340000e+01, double 2.180000e+01, double 2.070000e+01, double 2.170000e+01, double 2.150000e+01, double 2.250000e+01, double 2.360000e+01, double 2.150000e+01, double 2.250000e+01, double 2.350000e+01, double 2.150000e+01, double 2.180000e+01], align 16
@__const.main.d5 = private unnamed_addr constant [10 x double] [double 1.980000e+01, double 2.040000e+01, double 1.960000e+01, double 1.780000e+01, double 1.850000e+01, double 1.890000e+01, double 1.830000e+01, double 1.890000e+01, double 1.950000e+01, double 2.200000e+01], align 16
@__const.main.d6 = private unnamed_addr constant [20 x double] [double 2.820000e+01, double 2.660000e+01, double 2.010000e+01, double 2.330000e+01, double 2.520000e+01, double 2.210000e+01, double 1.770000e+01, double 2.760000e+01, double 2.060000e+01, double 1.370000e+01, double 2.320000e+01, double 1.750000e+01, double 2.060000e+01, double 1.800000e+01, double 2.390000e+01, double 2.160000e+01, double 2.430000e+01, double 2.040000e+01, double 2.400000e+01, double 1.320000e+01], align 16
@__const.main.x = private unnamed_addr constant [4 x double] [double 3.000000e+00, double 4.000000e+00, double 1.000000e+00, double 2.100000e+00], align 16
@__const.main.y = private unnamed_addr constant [3 x double] [double 4.902000e+02, double 3.400000e+02, double 4.339000e+02], align 16
@__const.main.v1 = private unnamed_addr constant [3 x double] [double 1.026800e-02, double 1.670000e-04, double 1.670000e-04], align 16
@__const.main.v2 = private unnamed_addr constant [3 x double] [double 1.592580e-01, double 1.362780e-01, double 1.223890e-01], align 16
@__const.main.s1 = private unnamed_addr constant [2 x double] [double 0x3FB1111111111111, double 0x3FC4A5294A5294A5], align 16
@__const.main.s2 = private unnamed_addr constant [2 x double] [double 1.000000e-01, double 4.000000e-02], align 16
@__const.main.z1 = private unnamed_addr constant [3 x double] [double 0x3FD90B21642C8591, double 0x3FDDDDDDDDDDDDDE, double 0.000000e+00], align 16
@__const.main.z2 = private unnamed_addr constant [3 x double] [double 0.000000e+00, double 0x3FDC9882B9310572, double 0.000000e+00], align 16
@__const.main.CORRECT_ANSWERS = private unnamed_addr constant [8 x double] [double 0x3F95E41D648C236F, double 0x3FC30D3EA599BB79, double 0x3FA26AF51F458AEB, double 0x3FB73CEBAB27FA12, double 0x3F8604EA1C27764A, double 0x3F6BD85EAF35CBC8, double 0x3FE0DF5C6BE20DA6, double 0x3FE172D38028625E], align 16
@.str.2 = private unnamed_addr constant [26 x i8] c"Test sets 1 p-value = %g\0A\00", align 1
@.str.3 = private unnamed_addr constant [26 x i8] c"Test sets 2 p-value = %g\0A\00", align 1
@.str.4 = private unnamed_addr constant [26 x i8] c"Test sets 3 p-value = %g\0A\00", align 1
@.str.5 = private unnamed_addr constant [26 x i8] c"Test sets 4 p-value = %g\0A\00", align 1
@.str.6 = private unnamed_addr constant [26 x i8] c"Test sets 5 p-value = %g\0A\00", align 1
@.str.7 = private unnamed_addr constant [26 x i8] c"Test sets 6 p-value = %g\0A\00", align 1
@.str.8 = private unnamed_addr constant [26 x i8] c"Test sets 7 p-value = %g\0A\00", align 1
@.str.9 = private unnamed_addr constant [26 x i8] c"Test sets z p-value = %g\0A\00", align 1
@.str.10 = private unnamed_addr constant [28 x i8] c"the cumulative error is %g\0A\00", align 1
@llvm.used = appending global [1 x i8*] [i8* bitcast (i32 ()* @__main_void to i8*)], section "llvm.metadata"

@__main_void = alias i32 (), i32 ()* @main

; Function Attrs: noinline nounwind optnone
define hidden double @Pvalue(double* noalias %ARRAY1, i32 %ARRAY1_SIZE, double* noalias %ARRAY2, i32 %ARRAY2_SIZE) #0 {
entry:
  %retval = alloca double, align 8
  %ARRAY1.addr = alloca double*, align 4
  %ARRAY1_SIZE.addr = alloca i32, align 4
  %ARRAY2.addr = alloca double*, align 4
  %ARRAY2_SIZE.addr = alloca i32, align 4
  %fmean1 = alloca double, align 8
  %fmean2 = alloca double, align 8
  %x = alloca i32, align 4
  %x9 = alloca i32, align 4
  %unbiased_sample_variance1 = alloca double, align 8
  %unbiased_sample_variance2 = alloca double, align 8
  %x32 = alloca i32, align 4
  %x44 = alloca i32, align 4
  %WELCH_T_STATISTIC = alloca double, align 8
  %DEGREES_OF_FREEDOM = alloca double, align 8
  %a = alloca double, align 8
  %value = alloca double, align 8
  %beta = alloca double, align 8
  %acu = alloca double, align 8
  %ai = alloca double, align 8
  %cx = alloca double, align 8
  %indx = alloca i32, align 4
  %ns = alloca i32, align 4
  %pp = alloca double, align 8
  %psq = alloca double, align 8
  %qq = alloca double, align 8
  %rx = alloca double, align 8
  %temp = alloca double, align 8
  %term = alloca double, align 8
  %xx = alloca double, align 8
  store double* %ARRAY1, double** %ARRAY1.addr, align 4
  store i32 %ARRAY1_SIZE, i32* %ARRAY1_SIZE.addr, align 4
  store double* %ARRAY2, double** %ARRAY2.addr, align 4
  store i32 %ARRAY2_SIZE, i32* %ARRAY2_SIZE.addr, align 4
  %0 = load i32, i32* %ARRAY1_SIZE.addr, align 4
  %cmp = icmp ule i32 %0, 1
  br i1 %cmp, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  store double 1.000000e+00, double* %retval, align 8
  br label %return

if.else:                                          ; preds = %entry
  %1 = load i32, i32* %ARRAY2_SIZE.addr, align 4
  %cmp1 = icmp ule i32 %1, 1
  br i1 %cmp1, label %if.then2, label %if.end

if.then2:                                         ; preds = %if.else
  store double 1.000000e+00, double* %retval, align 8
  br label %return

if.end:                                           ; preds = %if.else
  br label %if.end3

if.end3:                                          ; preds = %if.end
  store double 0.000000e+00, double* %fmean1, align 8
  store double 0.000000e+00, double* %fmean2, align 8
  store i32 0, i32* %x, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.end3
  %2 = load i32, i32* %x, align 4
  %3 = load i32, i32* %ARRAY1_SIZE.addr, align 4
  %cmp4 = icmp ult i32 %2, %3
  br i1 %cmp4, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %4 = load double*, double** %ARRAY1.addr, align 4
  %5 = load i32, i32* %x, align 4
  %arrayidx = getelementptr inbounds double, double* %4, i32 %5
  %6 = load double, double* %arrayidx, align 8
  %7 = call double @llvm.fabs.f64(double %6) #7
  %cmpinf = fcmp one double %7, 0x7FF0000000000000
  %8 = zext i1 %cmpinf to i32
  %cmp5 = icmp eq i32 %8, 0
  br i1 %cmp5, label %if.then6, label %if.end7

if.then6:                                         ; preds = %for.body
  %call = call i32 @puts(i8* getelementptr inbounds ([63 x i8], [63 x i8]* @.str, i32 0, i32 0))
  call void @exit(i32 1) #8
  unreachable

if.end7:                                          ; preds = %for.body
  %9 = load double*, double** %ARRAY1.addr, align 4
  %10 = load i32, i32* %x, align 4
  %arrayidx8 = getelementptr inbounds double, double* %9, i32 %10
  %11 = load double, double* %arrayidx8, align 8
  %12 = load double, double* %fmean1, align 8
  %add = fadd double %12, %11
  store double %add, double* %fmean1, align 8
  br label %for.inc

for.inc:                                          ; preds = %if.end7
  %13 = load i32, i32* %x, align 4
  %inc = add i32 %13, 1
  store i32 %inc, i32* %x, align 4
  br label %for.cond

for.end:                                          ; preds = %for.cond
  %14 = load i32, i32* %ARRAY1_SIZE.addr, align 4
  %conv = uitofp i32 %14 to double
  %15 = load double, double* %fmean1, align 8
  %div = fdiv double %15, %conv
  store double %div, double* %fmean1, align 8
  store i32 0, i32* %x9, align 4
  br label %for.cond10

for.cond10:                                       ; preds = %for.inc23, %for.end
  %16 = load i32, i32* %x9, align 4
  %17 = load i32, i32* %ARRAY2_SIZE.addr, align 4
  %cmp11 = icmp ult i32 %16, %17
  br i1 %cmp11, label %for.body13, label %for.end25

for.body13:                                       ; preds = %for.cond10
  %18 = load double*, double** %ARRAY2.addr, align 4
  %19 = load i32, i32* %x9, align 4
  %arrayidx14 = getelementptr inbounds double, double* %18, i32 %19
  %20 = load double, double* %arrayidx14, align 8
  %21 = call double @llvm.fabs.f64(double %20) #7
  %cmpinf15 = fcmp one double %21, 0x7FF0000000000000
  %22 = zext i1 %cmpinf15 to i32
  %cmp16 = icmp eq i32 %22, 0
  br i1 %cmp16, label %if.then18, label %if.end20

if.then18:                                        ; preds = %for.body13
  %call19 = call i32 @puts(i8* getelementptr inbounds ([63 x i8], [63 x i8]* @.str.1, i32 0, i32 0))
  call void @exit(i32 1) #8
  unreachable

if.end20:                                         ; preds = %for.body13
  %23 = load double*, double** %ARRAY2.addr, align 4
  %24 = load i32, i32* %x9, align 4
  %arrayidx21 = getelementptr inbounds double, double* %23, i32 %24
  %25 = load double, double* %arrayidx21, align 8
  %26 = load double, double* %fmean2, align 8
  %add22 = fadd double %26, %25
  store double %add22, double* %fmean2, align 8
  br label %for.inc23

for.inc23:                                        ; preds = %if.end20
  %27 = load i32, i32* %x9, align 4
  %inc24 = add i32 %27, 1
  store i32 %inc24, i32* %x9, align 4
  br label %for.cond10

for.end25:                                        ; preds = %for.cond10
  %28 = load i32, i32* %ARRAY2_SIZE.addr, align 4
  %conv26 = uitofp i32 %28 to double
  %29 = load double, double* %fmean2, align 8
  %div27 = fdiv double %29, %conv26
  store double %div27, double* %fmean2, align 8
  %30 = load double, double* %fmean1, align 8
  %31 = load double, double* %fmean2, align 8
  %cmp28 = fcmp oeq double %30, %31
  br i1 %cmp28, label %if.then30, label %if.end31

if.then30:                                        ; preds = %for.end25
  store double 1.000000e+00, double* %retval, align 8
  br label %return

if.end31:                                         ; preds = %for.end25
  store double 0.000000e+00, double* %unbiased_sample_variance1, align 8
  store double 0.000000e+00, double* %unbiased_sample_variance2, align 8
  store i32 0, i32* %x32, align 4
  br label %for.cond33

for.cond33:                                       ; preds = %for.inc41, %if.end31
  %32 = load i32, i32* %x32, align 4
  %33 = load i32, i32* %ARRAY1_SIZE.addr, align 4
  %cmp34 = icmp ult i32 %32, %33
  br i1 %cmp34, label %for.body36, label %for.end43

for.body36:                                       ; preds = %for.cond33
  %34 = load double*, double** %ARRAY1.addr, align 4
  %35 = load i32, i32* %x32, align 4
  %arrayidx37 = getelementptr inbounds double, double* %34, i32 %35
  %36 = load double, double* %arrayidx37, align 8
  %37 = load double, double* %fmean1, align 8
  %sub = fsub double %36, %37
  %38 = load double*, double** %ARRAY1.addr, align 4
  %39 = load i32, i32* %x32, align 4
  %arrayidx38 = getelementptr inbounds double, double* %38, i32 %39
  %40 = load double, double* %arrayidx38, align 8
  %41 = load double, double* %fmean1, align 8
  %sub39 = fsub double %40, %41
  %mul = fmul double %sub, %sub39
  %42 = load double, double* %unbiased_sample_variance1, align 8
  %add40 = fadd double %42, %mul
  store double %add40, double* %unbiased_sample_variance1, align 8
  br label %for.inc41

for.inc41:                                        ; preds = %for.body36
  %43 = load i32, i32* %x32, align 4
  %inc42 = add i32 %43, 1
  store i32 %inc42, i32* %x32, align 4
  br label %for.cond33

for.end43:                                        ; preds = %for.cond33
  store i32 0, i32* %x44, align 4
  br label %for.cond45

for.cond45:                                       ; preds = %for.inc55, %for.end43
  %44 = load i32, i32* %x44, align 4
  %45 = load i32, i32* %ARRAY2_SIZE.addr, align 4
  %cmp46 = icmp ult i32 %44, %45
  br i1 %cmp46, label %for.body48, label %for.end57

for.body48:                                       ; preds = %for.cond45
  %46 = load double*, double** %ARRAY2.addr, align 4
  %47 = load i32, i32* %x44, align 4
  %arrayidx49 = getelementptr inbounds double, double* %46, i32 %47
  %48 = load double, double* %arrayidx49, align 8
  %49 = load double, double* %fmean2, align 8
  %sub50 = fsub double %48, %49
  %50 = load double*, double** %ARRAY2.addr, align 4
  %51 = load i32, i32* %x44, align 4
  %arrayidx51 = getelementptr inbounds double, double* %50, i32 %51
  %52 = load double, double* %arrayidx51, align 8
  %53 = load double, double* %fmean2, align 8
  %sub52 = fsub double %52, %53
  %mul53 = fmul double %sub50, %sub52
  %54 = load double, double* %unbiased_sample_variance2, align 8
  %add54 = fadd double %54, %mul53
  store double %add54, double* %unbiased_sample_variance2, align 8
  br label %for.inc55

for.inc55:                                        ; preds = %for.body48
  %55 = load i32, i32* %x44, align 4
  %inc56 = add i32 %55, 1
  store i32 %inc56, i32* %x44, align 4
  br label %for.cond45

for.end57:                                        ; preds = %for.cond45
  %56 = load double, double* %unbiased_sample_variance1, align 8
  %57 = load i32, i32* %ARRAY1_SIZE.addr, align 4
  %sub58 = sub i32 %57, 1
  %conv59 = uitofp i32 %sub58 to double
  %div60 = fdiv double %56, %conv59
  store double %div60, double* %unbiased_sample_variance1, align 8
  %58 = load double, double* %unbiased_sample_variance2, align 8
  %59 = load i32, i32* %ARRAY2_SIZE.addr, align 4
  %sub61 = sub i32 %59, 1
  %conv62 = uitofp i32 %sub61 to double
  %div63 = fdiv double %58, %conv62
  store double %div63, double* %unbiased_sample_variance2, align 8
  %60 = load double, double* %fmean1, align 8
  %61 = load double, double* %fmean2, align 8
  %sub64 = fsub double %60, %61
  %62 = load double, double* %unbiased_sample_variance1, align 8
  %63 = load i32, i32* %ARRAY1_SIZE.addr, align 4
  %conv65 = uitofp i32 %63 to double
  %div66 = fdiv double %62, %conv65
  %64 = load double, double* %unbiased_sample_variance2, align 8
  %65 = load i32, i32* %ARRAY2_SIZE.addr, align 4
  %conv67 = uitofp i32 %65 to double
  %div68 = fdiv double %64, %conv67
  %add69 = fadd double %div66, %div68
  %66 = call double @llvm.sqrt.f64(double %add69)
  %div70 = fdiv double %sub64, %66
  store double %div70, double* %WELCH_T_STATISTIC, align 8
  %67 = load double, double* %unbiased_sample_variance1, align 8
  %68 = load i32, i32* %ARRAY1_SIZE.addr, align 4
  %conv71 = uitofp i32 %68 to double
  %div72 = fdiv double %67, %conv71
  %69 = load double, double* %unbiased_sample_variance2, align 8
  %70 = load i32, i32* %ARRAY2_SIZE.addr, align 4
  %conv73 = uitofp i32 %70 to double
  %div74 = fdiv double %69, %conv73
  %add75 = fadd double %div72, %div74
  %71 = call double @llvm.pow.f64(double %add75, double 2.000000e+00)
  %72 = load double, double* %unbiased_sample_variance1, align 8
  %73 = load double, double* %unbiased_sample_variance1, align 8
  %mul76 = fmul double %72, %73
  %74 = load i32, i32* %ARRAY1_SIZE.addr, align 4
  %75 = load i32, i32* %ARRAY1_SIZE.addr, align 4
  %mul77 = mul i32 %74, %75
  %76 = load i32, i32* %ARRAY1_SIZE.addr, align 4
  %sub78 = sub i32 %76, 1
  %mul79 = mul i32 %mul77, %sub78
  %conv80 = uitofp i32 %mul79 to double
  %div81 = fdiv double %mul76, %conv80
  %77 = load double, double* %unbiased_sample_variance2, align 8
  %78 = load double, double* %unbiased_sample_variance2, align 8
  %mul82 = fmul double %77, %78
  %79 = load i32, i32* %ARRAY2_SIZE.addr, align 4
  %80 = load i32, i32* %ARRAY2_SIZE.addr, align 4
  %mul83 = mul i32 %79, %80
  %81 = load i32, i32* %ARRAY2_SIZE.addr, align 4
  %sub84 = sub i32 %81, 1
  %mul85 = mul i32 %mul83, %sub84
  %conv86 = uitofp i32 %mul85 to double
  %div87 = fdiv double %mul82, %conv86
  %add88 = fadd double %div81, %div87
  %div89 = fdiv double %71, %add88
  store double %div89, double* %DEGREES_OF_FREEDOM, align 8
  %82 = load double, double* %DEGREES_OF_FREEDOM, align 8
  %div90 = fdiv double %82, 2.000000e+00
  store double %div90, double* %a, align 8
  %83 = load double, double* %DEGREES_OF_FREEDOM, align 8
  %84 = load double, double* %WELCH_T_STATISTIC, align 8
  %85 = load double, double* %WELCH_T_STATISTIC, align 8
  %mul91 = fmul double %84, %85
  %86 = load double, double* %DEGREES_OF_FREEDOM, align 8
  %add92 = fadd double %mul91, %86
  %div93 = fdiv double %83, %add92
  store double %div93, double* %value, align 8
  %87 = load double, double* %value, align 8
  %88 = call double @llvm.fabs.f64(double %87) #7
  %cmpinf94 = fcmp oeq double %88, 0x7FF0000000000000
  br i1 %cmpinf94, label %if.then100, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %for.end57
  %89 = load double, double* %value, align 8
  %cmp97 = fcmp uno double %89, %89
  br i1 %cmp97, label %if.then100, label %if.end101

if.then100:                                       ; preds = %lor.lhs.false, %for.end57
  store double 1.000000e+00, double* %retval, align 8
  br label %return

if.end101:                                        ; preds = %lor.lhs.false
  %90 = load double, double* %value, align 8
  %91 = call double @llvm.fabs.f64(double %90) #7
  %cmpinf102 = fcmp oeq double %91, 0x7FF0000000000000
  br i1 %cmpinf102, label %if.then109, label %lor.lhs.false105

lor.lhs.false105:                                 ; preds = %if.end101
  %92 = load double, double* %value, align 8
  %cmp106 = fcmp uno double %92, %92
  %93 = zext i1 %cmp106 to i32
  %cmp107 = icmp ne i32 %93, 0
  br i1 %cmp107, label %if.then109, label %if.end110

if.then109:                                       ; preds = %lor.lhs.false105, %if.end101
  store double 1.000000e+00, double* %retval, align 8
  br label %return

if.end110:                                        ; preds = %lor.lhs.false105
  %94 = load double, double* %a, align 8
  %conv111 = fpext double %94 to fp128
  %call112 = call fp128 @lgammal(fp128 %conv111) #9
  %add113 = fadd fp128 %call112, 0xLD0000000000000003FFE250D048E7A1B
  %95 = load double, double* %a, align 8
  %add114 = fadd double %95, 5.000000e-01
  %conv115 = fpext double %add114 to fp128
  %call116 = call fp128 @lgammal(fp128 %conv115) #9
  %sub117 = fsub fp128 %add113, %call116
  %conv118 = fptrunc fp128 %sub117 to double
  store double %conv118, double* %beta, align 8
  store double 1.000000e-15, double* %acu, align 8
  %96 = load double, double* %a, align 8
  %cmp119 = fcmp ole double %96, 0.000000e+00
  br i1 %cmp119, label %if.then121, label %if.end122

if.then121:                                       ; preds = %if.end110
  br label %if.end122

if.end122:                                        ; preds = %if.then121, %if.end110
  %97 = load double, double* %value, align 8
  %cmp123 = fcmp olt double %97, 0.000000e+00
  br i1 %cmp123, label %if.then128, label %lor.lhs.false125

lor.lhs.false125:                                 ; preds = %if.end122
  %98 = load double, double* %value, align 8
  %cmp126 = fcmp olt double 1.000000e+00, %98
  br i1 %cmp126, label %if.then128, label %if.end129

if.then128:                                       ; preds = %lor.lhs.false125, %if.end122
  %99 = load double, double* %value, align 8
  store double %99, double* %retval, align 8
  br label %return

if.end129:                                        ; preds = %lor.lhs.false125
  %100 = load double, double* %value, align 8
  %cmp130 = fcmp oeq double %100, 0.000000e+00
  br i1 %cmp130, label %if.then135, label %lor.lhs.false132

lor.lhs.false132:                                 ; preds = %if.end129
  %101 = load double, double* %value, align 8
  %cmp133 = fcmp oeq double %101, 1.000000e+00
  br i1 %cmp133, label %if.then135, label %if.end136

if.then135:                                       ; preds = %lor.lhs.false132, %if.end129
  %102 = load double, double* %value, align 8
  store double %102, double* %retval, align 8
  br label %return

if.end136:                                        ; preds = %lor.lhs.false132
  %103 = load double, double* %a, align 8
  %add137 = fadd double %103, 5.000000e-01
  store double %add137, double* %psq, align 8
  %104 = load double, double* %value, align 8
  %sub138 = fsub double 1.000000e+00, %104
  store double %sub138, double* %cx, align 8
  %105 = load double, double* %a, align 8
  %106 = load double, double* %psq, align 8
  %107 = load double, double* %value, align 8
  %mul139 = fmul double %106, %107
  %cmp140 = fcmp olt double %105, %mul139
  br i1 %cmp140, label %if.then142, label %if.else143

if.then142:                                       ; preds = %if.end136
  %108 = load double, double* %cx, align 8
  store double %108, double* %xx, align 8
  %109 = load double, double* %value, align 8
  store double %109, double* %cx, align 8
  store double 5.000000e-01, double* %pp, align 8
  %110 = load double, double* %a, align 8
  store double %110, double* %qq, align 8
  store i32 1, i32* %indx, align 4
  br label %if.end144

if.else143:                                       ; preds = %if.end136
  %111 = load double, double* %value, align 8
  store double %111, double* %xx, align 8
  %112 = load double, double* %a, align 8
  store double %112, double* %pp, align 8
  store double 5.000000e-01, double* %qq, align 8
  store i32 0, i32* %indx, align 4
  br label %if.end144

if.end144:                                        ; preds = %if.else143, %if.then142
  store double 1.000000e+00, double* %term, align 8
  store double 1.000000e+00, double* %ai, align 8
  store double 1.000000e+00, double* %value, align 8
  %113 = load double, double* %qq, align 8
  %114 = load double, double* %cx, align 8
  %115 = load double, double* %psq, align 8
  %mul145 = fmul double %114, %115
  %add146 = fadd double %113, %mul145
  %conv147 = fptosi double %add146 to i32
  store i32 %conv147, i32* %ns, align 4
  %116 = load double, double* %xx, align 8
  %117 = load double, double* %cx, align 8
  %div148 = fdiv double %116, %117
  store double %div148, double* %rx, align 8
  %118 = load double, double* %qq, align 8
  %119 = load double, double* %ai, align 8
  %sub149 = fsub double %118, %119
  store double %sub149, double* %temp, align 8
  %120 = load i32, i32* %ns, align 4
  %cmp150 = icmp eq i32 %120, 0
  br i1 %cmp150, label %if.then152, label %if.end153

if.then152:                                       ; preds = %if.end144
  %121 = load double, double* %xx, align 8
  store double %121, double* %rx, align 8
  br label %if.end153

if.end153:                                        ; preds = %if.then152, %if.end144
  br label %for.cond154

for.cond154:                                      ; preds = %if.end189, %if.end153
  %122 = load double, double* %term, align 8
  %123 = load double, double* %temp, align 8
  %mul155 = fmul double %122, %123
  %124 = load double, double* %rx, align 8
  %mul156 = fmul double %mul155, %124
  %125 = load double, double* %pp, align 8
  %126 = load double, double* %ai, align 8
  %add157 = fadd double %125, %126
  %div158 = fdiv double %mul156, %add157
  store double %div158, double* %term, align 8
  %127 = load double, double* %value, align 8
  %128 = load double, double* %term, align 8
  %add159 = fadd double %127, %128
  store double %add159, double* %value, align 8
  %129 = load double, double* %term, align 8
  %130 = call double @llvm.fabs.f64(double %129)
  store double %130, double* %temp, align 8
  %131 = load double, double* %temp, align 8
  %cmp160 = fcmp ole double %131, 1.000000e-15
  br i1 %cmp160, label %land.lhs.true, label %if.end176

land.lhs.true:                                    ; preds = %for.cond154
  %132 = load double, double* %temp, align 8
  %133 = load double, double* %value, align 8
  %mul162 = fmul double 1.000000e-15, %133
  %cmp163 = fcmp ole double %132, %mul162
  br i1 %cmp163, label %if.then165, label %if.end176

if.then165:                                       ; preds = %land.lhs.true
  %134 = load double, double* %value, align 8
  %135 = load double, double* %pp, align 8
  %136 = load double, double* %xx, align 8
  %137 = call double @llvm.log.f64(double %136)
  %mul166 = fmul double %135, %137
  %138 = load double, double* %qq, align 8
  %sub167 = fsub double %138, 1.000000e+00
  %139 = load double, double* %cx, align 8
  %140 = call double @llvm.log.f64(double %139)
  %mul168 = fmul double %sub167, %140
  %add169 = fadd double %mul166, %mul168
  %141 = load double, double* %beta, align 8
  %sub170 = fsub double %add169, %141
  %142 = call double @llvm.exp.f64(double %sub170)
  %mul171 = fmul double %134, %142
  %143 = load double, double* %pp, align 8
  %div172 = fdiv double %mul171, %143
  store double %div172, double* %value, align 8
  %144 = load i32, i32* %indx, align 4
  %tobool = icmp ne i32 %144, 0
  br i1 %tobool, label %if.then173, label %if.end175

if.then173:                                       ; preds = %if.then165
  %145 = load double, double* %value, align 8
  %sub174 = fsub double 1.000000e+00, %145
  store double %sub174, double* %value, align 8
  br label %if.end175

if.end175:                                        ; preds = %if.then173, %if.then165
  br label %for.end190

if.end176:                                        ; preds = %land.lhs.true, %for.cond154
  %146 = load double, double* %ai, align 8
  %add177 = fadd double %146, 1.000000e+00
  store double %add177, double* %ai, align 8
  %147 = load i32, i32* %ns, align 4
  %sub178 = sub nsw i32 %147, 1
  store i32 %sub178, i32* %ns, align 4
  %148 = load i32, i32* %ns, align 4
  %cmp179 = icmp sle i32 0, %148
  br i1 %cmp179, label %if.then181, label %if.else187

if.then181:                                       ; preds = %if.end176
  %149 = load double, double* %qq, align 8
  %150 = load double, double* %ai, align 8
  %sub182 = fsub double %149, %150
  store double %sub182, double* %temp, align 8
  %151 = load i32, i32* %ns, align 4
  %cmp183 = icmp eq i32 %151, 0
  br i1 %cmp183, label %if.then185, label %if.end186

if.then185:                                       ; preds = %if.then181
  %152 = load double, double* %xx, align 8
  store double %152, double* %rx, align 8
  br label %if.end186

if.end186:                                        ; preds = %if.then185, %if.then181
  br label %if.end189

if.else187:                                       ; preds = %if.end176
  %153 = load double, double* %psq, align 8
  store double %153, double* %temp, align 8
  %154 = load double, double* %psq, align 8
  %add188 = fadd double %154, 1.000000e+00
  store double %add188, double* %psq, align 8
  br label %if.end189

if.end189:                                        ; preds = %if.else187, %if.end186
  br label %for.cond154

for.end190:                                       ; preds = %if.end175
  %155 = load double, double* %value, align 8
  store double %155, double* %retval, align 8
  br label %return

return:                                           ; preds = %for.end190, %if.then135, %if.then128, %if.then109, %if.then100, %if.then30, %if.then2, %if.then
  %156 = load double, double* %retval, align 8
  ret double %156
}

; Function Attrs: nounwind readnone speculatable willreturn
declare double @llvm.fabs.f64(double %0) #1

declare i32 @puts(i8* %0) #2

; Function Attrs: noreturn
declare void @exit(i32 %0) #3

; Function Attrs: nounwind readnone speculatable willreturn
declare double @llvm.sqrt.f64(double %0) #1

; Function Attrs: nounwind readnone speculatable willreturn
declare double @llvm.pow.f64(double %0, double %1) #1

; Function Attrs: nounwind
declare fp128 @lgammal(fp128 %0) #4

; Function Attrs: nounwind readnone speculatable willreturn
declare double @llvm.log.f64(double %0) #1

; Function Attrs: nounwind readnone speculatable willreturn
declare double @llvm.exp.f64(double %0) #1

; Function Attrs: noinline nounwind optnone
define hidden i32 @main() #0 {
entry:
  %retval = alloca i32, align 4
  %d1 = alloca [15 x double], align 16
  %d2 = alloca [15 x double], align 16
  %d3 = alloca [10 x double], align 16
  %d4 = alloca [20 x double], align 16
  %d5 = alloca [10 x double], align 16
  %d6 = alloca [20 x double], align 16
  %d7 = alloca [6 x double], align 16
  %d8 = alloca [6 x double], align 16
  %x = alloca [4 x double], align 16
  %y = alloca [3 x double], align 16
  %v1 = alloca [3 x double], align 16
  %v2 = alloca [3 x double], align 16
  %s1 = alloca [2 x double], align 16
  %s2 = alloca [2 x double], align 16
  %z1 = alloca [3 x double], align 16
  %z2 = alloca [3 x double], align 16
  %CORRECT_ANSWERS = alloca [8 x double], align 16
  %pvalue = alloca double, align 8
  %error = alloca double, align 8
  store i32 0, i32* %retval, align 4
  %0 = bitcast [15 x double]* %d1 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 16 %0, i8* align 16 bitcast ([15 x double]* @__const.main.d1 to i8*), i32 120, i1 false)
  %1 = bitcast [15 x double]* %d2 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 16 %1, i8* align 16 bitcast ([15 x double]* @__const.main.d2 to i8*), i32 120, i1 false)
  %2 = bitcast [10 x double]* %d3 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 16 %2, i8* align 16 bitcast ([10 x double]* @__const.main.d3 to i8*), i32 80, i1 false)
  %3 = bitcast [20 x double]* %d4 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 16 %3, i8* align 16 bitcast ([20 x double]* @__const.main.d4 to i8*), i32 160, i1 false)
  %4 = bitcast [10 x double]* %d5 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 16 %4, i8* align 16 bitcast ([10 x double]* @__const.main.d5 to i8*), i32 80, i1 false)
  %5 = bitcast [20 x double]* %d6 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 16 %5, i8* align 16 bitcast ([20 x double]* @__const.main.d6 to i8*), i32 160, i1 false)
  %6 = bitcast [6 x double]* %d7 to i8*
  call void @llvm.memset.p0i8.i32(i8* align 16 %6, i8 0, i32 48, i1 false)
  %7 = bitcast i8* %6 to [6 x double]*
  %8 = getelementptr inbounds [6 x double], [6 x double]* %7, i32 0, i32 0
  store double 3.002000e+01, double* %8, align 16
  %9 = getelementptr inbounds [6 x double], [6 x double]* %7, i32 0, i32 1
  store double 2.999000e+01, double* %9, align 8
  %10 = getelementptr inbounds [6 x double], [6 x double]* %7, i32 0, i32 2
  store double 3.011000e+01, double* %10, align 16
  %11 = getelementptr inbounds [6 x double], [6 x double]* %7, i32 0, i32 3
  store double 2.997000e+01, double* %11, align 8
  %12 = getelementptr inbounds [6 x double], [6 x double]* %7, i32 0, i32 4
  store double 3.001000e+01, double* %12, align 16
  %13 = getelementptr inbounds [6 x double], [6 x double]* %7, i32 0, i32 5
  store double 2.999000e+01, double* %13, align 8
  %14 = bitcast [6 x double]* %d8 to i8*
  call void @llvm.memset.p0i8.i32(i8* align 16 %14, i8 0, i32 48, i1 false)
  %15 = bitcast i8* %14 to [6 x double]*
  %16 = getelementptr inbounds [6 x double], [6 x double]* %15, i32 0, i32 0
  store double 2.989000e+01, double* %16, align 16
  %17 = getelementptr inbounds [6 x double], [6 x double]* %15, i32 0, i32 1
  store double 2.993000e+01, double* %17, align 8
  %18 = getelementptr inbounds [6 x double], [6 x double]* %15, i32 0, i32 2
  store double 2.972000e+01, double* %18, align 16
  %19 = getelementptr inbounds [6 x double], [6 x double]* %15, i32 0, i32 3
  store double 2.998000e+01, double* %19, align 8
  %20 = getelementptr inbounds [6 x double], [6 x double]* %15, i32 0, i32 4
  store double 3.002000e+01, double* %20, align 16
  %21 = getelementptr inbounds [6 x double], [6 x double]* %15, i32 0, i32 5
  store double 2.998000e+01, double* %21, align 8
  %22 = bitcast [4 x double]* %x to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 16 %22, i8* align 16 bitcast ([4 x double]* @__const.main.x to i8*), i32 32, i1 false)
  %23 = bitcast [3 x double]* %y to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 16 %23, i8* align 16 bitcast ([3 x double]* @__const.main.y to i8*), i32 24, i1 false)
  %24 = bitcast [3 x double]* %v1 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 16 %24, i8* align 16 bitcast ([3 x double]* @__const.main.v1 to i8*), i32 24, i1 false)
  %25 = bitcast [3 x double]* %v2 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 16 %25, i8* align 16 bitcast ([3 x double]* @__const.main.v2 to i8*), i32 24, i1 false)
  %26 = bitcast [2 x double]* %s1 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 16 %26, i8* align 16 bitcast ([2 x double]* @__const.main.s1 to i8*), i32 16, i1 false)
  %27 = bitcast [2 x double]* %s2 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 16 %27, i8* align 16 bitcast ([2 x double]* @__const.main.s2 to i8*), i32 16, i1 false)
  %28 = bitcast [3 x double]* %z1 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 16 %28, i8* align 16 bitcast ([3 x double]* @__const.main.z1 to i8*), i32 24, i1 false)
  %29 = bitcast [3 x double]* %z2 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 16 %29, i8* align 16 bitcast ([3 x double]* @__const.main.z2 to i8*), i32 24, i1 false)
  %30 = bitcast [8 x double]* %CORRECT_ANSWERS to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 16 %30, i8* align 16 bitcast ([8 x double]* @__const.main.CORRECT_ANSWERS to i8*), i32 64, i1 false)
  %arraydecay = getelementptr inbounds [15 x double], [15 x double]* %d1, i32 0, i32 0
  %arraydecay1 = getelementptr inbounds [15 x double], [15 x double]* %d2, i32 0, i32 0
  %call = call double @Pvalue(double* %arraydecay, i32 15, double* %arraydecay1, i32 15)
  store double %call, double* %pvalue, align 8
  %31 = load double, double* %pvalue, align 8
  %arrayidx = getelementptr inbounds [8 x double], [8 x double]* %CORRECT_ANSWERS, i32 0, i32 0
  %32 = load double, double* %arrayidx, align 16
  %sub = fsub double %31, %32
  %33 = call double @llvm.fabs.f64(double %sub)
  store double %33, double* %error, align 8
  %34 = load double, double* %pvalue, align 8
  %call2 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([26 x i8], [26 x i8]* @.str.2, i32 0, i32 0), double %34)
  %arraydecay3 = getelementptr inbounds [10 x double], [10 x double]* %d3, i32 0, i32 0
  %arraydecay4 = getelementptr inbounds [20 x double], [20 x double]* %d4, i32 0, i32 0
  %call5 = call double @Pvalue(double* %arraydecay3, i32 10, double* %arraydecay4, i32 20)
  store double %call5, double* %pvalue, align 8
  %35 = load double, double* %pvalue, align 8
  %arrayidx6 = getelementptr inbounds [8 x double], [8 x double]* %CORRECT_ANSWERS, i32 0, i32 1
  %36 = load double, double* %arrayidx6, align 8
  %sub7 = fsub double %35, %36
  %37 = call double @llvm.fabs.f64(double %sub7)
  %38 = load double, double* %error, align 8
  %add = fadd double %38, %37
  store double %add, double* %error, align 8
  %39 = load double, double* %pvalue, align 8
  %call8 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([26 x i8], [26 x i8]* @.str.3, i32 0, i32 0), double %39)
  %arraydecay9 = getelementptr inbounds [10 x double], [10 x double]* %d5, i32 0, i32 0
  %arraydecay10 = getelementptr inbounds [20 x double], [20 x double]* %d6, i32 0, i32 0
  %call11 = call double @Pvalue(double* %arraydecay9, i32 10, double* %arraydecay10, i32 20)
  store double %call11, double* %pvalue, align 8
  %40 = load double, double* %pvalue, align 8
  %arrayidx12 = getelementptr inbounds [8 x double], [8 x double]* %CORRECT_ANSWERS, i32 0, i32 2
  %41 = load double, double* %arrayidx12, align 16
  %sub13 = fsub double %40, %41
  %42 = call double @llvm.fabs.f64(double %sub13)
  %43 = load double, double* %error, align 8
  %add14 = fadd double %43, %42
  store double %add14, double* %error, align 8
  %44 = load double, double* %pvalue, align 8
  %call15 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([26 x i8], [26 x i8]* @.str.4, i32 0, i32 0), double %44)
  %arraydecay16 = getelementptr inbounds [6 x double], [6 x double]* %d7, i32 0, i32 0
  %arraydecay17 = getelementptr inbounds [6 x double], [6 x double]* %d8, i32 0, i32 0
  %call18 = call double @Pvalue(double* %arraydecay16, i32 6, double* %arraydecay17, i32 6)
  store double %call18, double* %pvalue, align 8
  %45 = load double, double* %pvalue, align 8
  %call19 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([26 x i8], [26 x i8]* @.str.5, i32 0, i32 0), double %45)
  %46 = load double, double* %pvalue, align 8
  %arrayidx20 = getelementptr inbounds [8 x double], [8 x double]* %CORRECT_ANSWERS, i32 0, i32 3
  %47 = load double, double* %arrayidx20, align 8
  %sub21 = fsub double %46, %47
  %48 = call double @llvm.fabs.f64(double %sub21)
  %49 = load double, double* %error, align 8
  %add22 = fadd double %49, %48
  store double %add22, double* %error, align 8
  %arraydecay23 = getelementptr inbounds [4 x double], [4 x double]* %x, i32 0, i32 0
  %arraydecay24 = getelementptr inbounds [3 x double], [3 x double]* %y, i32 0, i32 0
  %call25 = call double @Pvalue(double* %arraydecay23, i32 4, double* %arraydecay24, i32 3)
  store double %call25, double* %pvalue, align 8
  %50 = load double, double* %pvalue, align 8
  %arrayidx26 = getelementptr inbounds [8 x double], [8 x double]* %CORRECT_ANSWERS, i32 0, i32 4
  %51 = load double, double* %arrayidx26, align 16
  %sub27 = fsub double %50, %51
  %52 = call double @llvm.fabs.f64(double %sub27)
  %53 = load double, double* %error, align 8
  %add28 = fadd double %53, %52
  store double %add28, double* %error, align 8
  %54 = load double, double* %pvalue, align 8
  %call29 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([26 x i8], [26 x i8]* @.str.6, i32 0, i32 0), double %54)
  %arraydecay30 = getelementptr inbounds [3 x double], [3 x double]* %v1, i32 0, i32 0
  %arraydecay31 = getelementptr inbounds [3 x double], [3 x double]* %v2, i32 0, i32 0
  %call32 = call double @Pvalue(double* %arraydecay30, i32 3, double* %arraydecay31, i32 3)
  store double %call32, double* %pvalue, align 8
  %55 = load double, double* %pvalue, align 8
  %arrayidx33 = getelementptr inbounds [8 x double], [8 x double]* %CORRECT_ANSWERS, i32 0, i32 5
  %56 = load double, double* %arrayidx33, align 8
  %sub34 = fsub double %55, %56
  %57 = call double @llvm.fabs.f64(double %sub34)
  %58 = load double, double* %error, align 8
  %add35 = fadd double %58, %57
  store double %add35, double* %error, align 8
  %59 = load double, double* %pvalue, align 8
  %call36 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([26 x i8], [26 x i8]* @.str.7, i32 0, i32 0), double %59)
  %arraydecay37 = getelementptr inbounds [2 x double], [2 x double]* %s1, i32 0, i32 0
  %arraydecay38 = getelementptr inbounds [2 x double], [2 x double]* %s2, i32 0, i32 0
  %call39 = call double @Pvalue(double* %arraydecay37, i32 2, double* %arraydecay38, i32 2)
  store double %call39, double* %pvalue, align 8
  %60 = load double, double* %pvalue, align 8
  %arrayidx40 = getelementptr inbounds [8 x double], [8 x double]* %CORRECT_ANSWERS, i32 0, i32 6
  %61 = load double, double* %arrayidx40, align 16
  %sub41 = fsub double %60, %61
  %62 = call double @llvm.fabs.f64(double %sub41)
  %63 = load double, double* %error, align 8
  %add42 = fadd double %63, %62
  store double %add42, double* %error, align 8
  %64 = load double, double* %pvalue, align 8
  %call43 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([26 x i8], [26 x i8]* @.str.8, i32 0, i32 0), double %64)
  %arraydecay44 = getelementptr inbounds [3 x double], [3 x double]* %z1, i32 0, i32 0
  %arraydecay45 = getelementptr inbounds [3 x double], [3 x double]* %z2, i32 0, i32 0
  %call46 = call double @Pvalue(double* %arraydecay44, i32 3, double* %arraydecay45, i32 3)
  store double %call46, double* %pvalue, align 8
  %65 = load double, double* %pvalue, align 8
  %arrayidx47 = getelementptr inbounds [8 x double], [8 x double]* %CORRECT_ANSWERS, i32 0, i32 7
  %66 = load double, double* %arrayidx47, align 8
  %sub48 = fsub double %65, %66
  %67 = call double @llvm.fabs.f64(double %sub48)
  %68 = load double, double* %error, align 8
  %add49 = fadd double %68, %67
  store double %add49, double* %error, align 8
  %69 = load double, double* %pvalue, align 8
  %call50 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([26 x i8], [26 x i8]* @.str.9, i32 0, i32 0), double %69)
  %70 = load double, double* %error, align 8
  %call51 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([28 x i8], [28 x i8]* @.str.10, i32 0, i32 0), double %70)
  ret i32 0
}

; Function Attrs: argmemonly nounwind willreturn
declare void @llvm.memcpy.p0i8.p0i8.i32(i8* noalias nocapture writeonly %0, i8* noalias nocapture readonly %1, i32 %2, i1 immarg %3) #5

; Function Attrs: argmemonly nounwind willreturn writeonly
declare void @llvm.memset.p0i8.i32(i8* nocapture writeonly %0, i8 %1, i32 %2, i1 immarg %3) #6

declare i32 @printf(i8* %0, ...) #2

attributes #0 = { noinline nounwind optnone "correctly-rounded-divide-sqrt-fp-math"="false" "disable-tail-calls"="false" "frame-pointer"="none" "less-precise-fpmad"="false" "min-legal-vector-width"="0" "no-infs-fp-math"="false" "no-jump-tables"="false" "no-nans-fp-math"="false" "no-signed-zeros-fp-math"="false" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="generic" "unsafe-fp-math"="false" "use-soft-float"="false" }
attributes #1 = { nounwind readnone speculatable willreturn }
attributes #2 = { "correctly-rounded-divide-sqrt-fp-math"="false" "disable-tail-calls"="false" "frame-pointer"="none" "less-precise-fpmad"="false" "no-infs-fp-math"="false" "no-nans-fp-math"="false" "no-signed-zeros-fp-math"="false" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="generic" "unsafe-fp-math"="false" "use-soft-float"="false" }
attributes #3 = { noreturn "correctly-rounded-divide-sqrt-fp-math"="false" "disable-tail-calls"="false" "frame-pointer"="none" "less-precise-fpmad"="false" "no-infs-fp-math"="false" "no-nans-fp-math"="false" "no-signed-zeros-fp-math"="false" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="generic" "unsafe-fp-math"="false" "use-soft-float"="false" }
attributes #4 = { nounwind "correctly-rounded-divide-sqrt-fp-math"="false" "disable-tail-calls"="false" "frame-pointer"="none" "less-precise-fpmad"="false" "no-infs-fp-math"="false" "no-nans-fp-math"="false" "no-signed-zeros-fp-math"="false" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="generic" "unsafe-fp-math"="false" "use-soft-float"="false" }
attributes #5 = { argmemonly nounwind willreturn }
attributes #6 = { argmemonly nounwind willreturn writeonly }
attributes #7 = { readnone }
attributes #8 = { noreturn }
attributes #9 = { nounwind }

!llvm.module.flags = !{!0}
!llvm.ident = !{!1}

!0 = !{i32 1, !"wchar_size", i32 4}
!1 = !{!"clang version 11.0.0 (https://github.com/Jacarte/llvm-project.git 0f6dea67136cc1e0b3d200eb2bb165628970c44b)"}

#########################################################
; exiting Souper's runOnFunction() for Pvalue()
rescanning function after transformation was applied

; entering Souper's runOnFunction() for Pvalue()

; ModuleID = './Welchs_t-test.c.bc'
source_filename = "./Welchs_t-test.c"
target datalayout = "e-m:e-p:32:32-i64:64-n32:64-S128"
target triple = "wasm32-unknown-wasi"

@.str = private unnamed_addr constant [63 x i8] c"Got a non-finite number in 1st array, can't calculate P-value.\00", align 1
@.str.1 = private unnamed_addr constant [63 x i8] c"Got a non-finite number in 2nd array, can't calculate P-value.\00", align 1
@__const.main.d1 = private unnamed_addr constant [15 x double] [double 2.750000e+01, double 2.100000e+01, double 1.900000e+01, double 2.360000e+01, double 1.700000e+01, double 1.790000e+01, double 1.690000e+01, double 2.010000e+01, double 2.190000e+01, double 2.260000e+01, double 2.310000e+01, double 1.960000e+01, double 1.900000e+01, double 2.170000e+01, double 2.140000e+01], align 16
@__const.main.d2 = private unnamed_addr constant [15 x double] [double 2.710000e+01, double 2.200000e+01, double 2.080000e+01, double 2.340000e+01, double 2.340000e+01, double 2.350000e+01, double 2.580000e+01, double 2.200000e+01, double 2.480000e+01, double 2.020000e+01, double 2.190000e+01, double 2.210000e+01, double 2.290000e+01, double 2.050000e+01, double 2.440000e+01], align 16
@__const.main.d3 = private unnamed_addr constant [10 x double] [double 1.720000e+01, double 2.090000e+01, double 2.260000e+01, double 1.810000e+01, double 2.170000e+01, double 2.140000e+01, double 2.350000e+01, double 2.420000e+01, double 1.470000e+01, double 2.180000e+01], align 16
@__const.main.d4 = private unnamed_addr constant [20 x double] [double 2.150000e+01, double 2.280000e+01, double 2.100000e+01, double 2.300000e+01, double 2.160000e+01, double 2.360000e+01, double 2.250000e+01, double 2.070000e+01, double 2.340000e+01, double 2.180000e+01, double 2.070000e+01, double 2.170000e+01, double 2.150000e+01, double 2.250000e+01, double 2.360000e+01, double 2.150000e+01, double 2.250000e+01, double 2.350000e+01, double 2.150000e+01, double 2.180000e+01], align 16
@__const.main.d5 = private unnamed_addr constant [10 x double] [double 1.980000e+01, double 2.040000e+01, double 1.960000e+01, double 1.780000e+01, double 1.850000e+01, double 1.890000e+01, double 1.830000e+01, double 1.890000e+01, double 1.950000e+01, double 2.200000e+01], align 16
@__const.main.d6 = private unnamed_addr constant [20 x double] [double 2.820000e+01, double 2.660000e+01, double 2.010000e+01, double 2.330000e+01, double 2.520000e+01, double 2.210000e+01, double 1.770000e+01, double 2.760000e+01, double 2.060000e+01, double 1.370000e+01, double 2.320000e+01, double 1.750000e+01, double 2.060000e+01, double 1.800000e+01, double 2.390000e+01, double 2.160000e+01, double 2.430000e+01, double 2.040000e+01, double 2.400000e+01, double 1.320000e+01], align 16
@__const.main.x = private unnamed_addr constant [4 x double] [double 3.000000e+00, double 4.000000e+00, double 1.000000e+00, double 2.100000e+00], align 16
@__const.main.y = private unnamed_addr constant [3 x double] [double 4.902000e+02, double 3.400000e+02, double 4.339000e+02], align 16
@__const.main.v1 = private unnamed_addr constant [3 x double] [double 1.026800e-02, double 1.670000e-04, double 1.670000e-04], align 16
@__const.main.v2 = private unnamed_addr constant [3 x double] [double 1.592580e-01, double 1.362780e-01, double 1.223890e-01], align 16
@__const.main.s1 = private unnamed_addr constant [2 x double] [double 0x3FB1111111111111, double 0x3FC4A5294A5294A5], align 16
@__const.main.s2 = private unnamed_addr constant [2 x double] [double 1.000000e-01, double 4.000000e-02], align 16
@__const.main.z1 = private unnamed_addr constant [3 x double] [double 0x3FD90B21642C8591, double 0x3FDDDDDDDDDDDDDE, double 0.000000e+00], align 16
@__const.main.z2 = private unnamed_addr constant [3 x double] [double 0.000000e+00, double 0x3FDC9882B9310572, double 0.000000e+00], align 16
@__const.main.CORRECT_ANSWERS = private unnamed_addr constant [8 x double] [double 0x3F95E41D648C236F, double 0x3FC30D3EA599BB79, double 0x3FA26AF51F458AEB, double 0x3FB73CEBAB27FA12, double 0x3F8604EA1C27764A, double 0x3F6BD85EAF35CBC8, double 0x3FE0DF5C6BE20DA6, double 0x3FE172D38028625E], align 16
@.str.2 = private unnamed_addr constant [26 x i8] c"Test sets 1 p-value = %g\0A\00", align 1
@.str.3 = private unnamed_addr constant [26 x i8] c"Test sets 2 p-value = %g\0A\00", align 1
@.str.4 = private unnamed_addr constant [26 x i8] c"Test sets 3 p-value = %g\0A\00", align 1
@.str.5 = private unnamed_addr constant [26 x i8] c"Test sets 4 p-value = %g\0A\00", align 1
@.str.6 = private unnamed_addr constant [26 x i8] c"Test sets 5 p-value = %g\0A\00", align 1
@.str.7 = private unnamed_addr constant [26 x i8] c"Test sets 6 p-value = %g\0A\00", align 1
@.str.8 = private unnamed_addr constant [26 x i8] c"Test sets 7 p-value = %g\0A\00", align 1
@.str.9 = private unnamed_addr constant [26 x i8] c"Test sets z p-value = %g\0A\00", align 1
@.str.10 = private unnamed_addr constant [28 x i8] c"the cumulative error is %g\0A\00", align 1
@llvm.used = appending global [1 x i8*] [i8* bitcast (i32 ()* @__main_void to i8*)], section "llvm.metadata"

@__main_void = alias i32 (), i32 ()* @main

; Function Attrs: noinline nounwind optnone
define hidden double @Pvalue(double* noalias %ARRAY1, i32 %ARRAY1_SIZE, double* noalias %ARRAY2, i32 %ARRAY2_SIZE) #0 {
entry:
  %retval = alloca double, align 8
  %ARRAY1.addr = alloca double*, align 4
  %ARRAY1_SIZE.addr = alloca i32, align 4
  %ARRAY2.addr = alloca double*, align 4
  %ARRAY2_SIZE.addr = alloca i32, align 4
  %fmean1 = alloca double, align 8
  %fmean2 = alloca double, align 8
  %x = alloca i32, align 4
  %x9 = alloca i32, align 4
  %unbiased_sample_variance1 = alloca double, align 8
  %unbiased_sample_variance2 = alloca double, align 8
  %x32 = alloca i32, align 4
  %x44 = alloca i32, align 4
  %WELCH_T_STATISTIC = alloca double, align 8
  %DEGREES_OF_FREEDOM = alloca double, align 8
  %a = alloca double, align 8
  %value = alloca double, align 8
  %beta = alloca double, align 8
  %acu = alloca double, align 8
  %ai = alloca double, align 8
  %cx = alloca double, align 8
  %indx = alloca i32, align 4
  %ns = alloca i32, align 4
  %pp = alloca double, align 8
  %psq = alloca double, align 8
  %qq = alloca double, align 8
  %rx = alloca double, align 8
  %temp = alloca double, align 8
  %term = alloca double, align 8
  %xx = alloca double, align 8
  store double* %ARRAY1, double** %ARRAY1.addr, align 4
  store i32 %ARRAY1_SIZE, i32* %ARRAY1_SIZE.addr, align 4
  store double* %ARRAY2, double** %ARRAY2.addr, align 4
  store i32 %ARRAY2_SIZE, i32* %ARRAY2_SIZE.addr, align 4
  %0 = load i32, i32* %ARRAY1_SIZE.addr, align 4
  %cmp = icmp ule i32 %0, 1
  br i1 %cmp, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  store double 1.000000e+00, double* %retval, align 8
  br label %return

if.else:                                          ; preds = %entry
  %1 = load i32, i32* %ARRAY2_SIZE.addr, align 4
  %cmp1 = icmp ule i32 %1, 1
  br i1 %cmp1, label %if.then2, label %if.end

if.then2:                                         ; preds = %if.else
  store double 1.000000e+00, double* %retval, align 8
  br label %return

if.end:                                           ; preds = %if.else
  br label %if.end3

if.end3:                                          ; preds = %if.end
  store double 0.000000e+00, double* %fmean1, align 8
  store double 0.000000e+00, double* %fmean2, align 8
  store i32 0, i32* %x, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.end3
  %2 = load i32, i32* %x, align 4
  %3 = load i32, i32* %ARRAY1_SIZE.addr, align 4
  %cmp4 = icmp ult i32 %2, %3
  br i1 %cmp4, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %4 = load double*, double** %ARRAY1.addr, align 4
  %5 = load i32, i32* %x, align 4
  %arrayidx = getelementptr inbounds double, double* %4, i32 %5
  %6 = load double, double* %arrayidx, align 8
  %7 = call double @llvm.fabs.f64(double %6) #7
  %cmpinf = fcmp one double %7, 0x7FF0000000000000
  %8 = zext i1 %cmpinf to i32
  %cmp5 = icmp eq i32 %8, 0
  br i1 %cmp5, label %if.then6, label %if.end7

if.then6:                                         ; preds = %for.body
  %call = call i32 @puts(i8* getelementptr inbounds ([63 x i8], [63 x i8]* @.str, i32 0, i32 0))
  call void @exit(i32 1) #8
  unreachable

if.end7:                                          ; preds = %for.body
  %9 = load double*, double** %ARRAY1.addr, align 4
  %10 = load i32, i32* %x, align 4
  %arrayidx8 = getelementptr inbounds double, double* %9, i32 %10
  %11 = load double, double* %arrayidx8, align 8
  %12 = load double, double* %fmean1, align 8
  %add = fadd double %12, %11
  store double %add, double* %fmean1, align 8
  br label %for.inc

for.inc:                                          ; preds = %if.end7
  %13 = load i32, i32* %x, align 4
  %inc = add i32 %13, 1
  store i32 %inc, i32* %x, align 4
  br label %for.cond

for.end:                                          ; preds = %for.cond
  %14 = load i32, i32* %ARRAY1_SIZE.addr, align 4
  %conv = uitofp i32 %14 to double
  %15 = load double, double* %fmean1, align 8
  %div = fdiv double %15, %conv
  store double %div, double* %fmean1, align 8
  store i32 0, i32* %x9, align 4
  br label %for.cond10

for.cond10:                                       ; preds = %for.inc23, %for.end
  %16 = load i32, i32* %x9, align 4
  %17 = load i32, i32* %ARRAY2_SIZE.addr, align 4
  %cmp11 = icmp ult i32 %16, %17
  br i1 %cmp11, label %for.body13, label %for.end25

for.body13:                                       ; preds = %for.cond10
  %18 = load double*, double** %ARRAY2.addr, align 4
  %19 = load i32, i32* %x9, align 4
  %arrayidx14 = getelementptr inbounds double, double* %18, i32 %19
  %20 = load double, double* %arrayidx14, align 8
  %21 = call double @llvm.fabs.f64(double %20) #7
  %cmpinf15 = fcmp one double %21, 0x7FF0000000000000
  %22 = zext i1 %cmpinf15 to i32
  %cmp16 = icmp eq i32 %22, 0
  br i1 %cmp16, label %if.then18, label %if.end20

if.then18:                                        ; preds = %for.body13
  %call19 = call i32 @puts(i8* getelementptr inbounds ([63 x i8], [63 x i8]* @.str.1, i32 0, i32 0))
  call void @exit(i32 1) #8
  unreachable

if.end20:                                         ; preds = %for.body13
  %23 = load double*, double** %ARRAY2.addr, align 4
  %24 = load i32, i32* %x9, align 4
  %arrayidx21 = getelementptr inbounds double, double* %23, i32 %24
  %25 = load double, double* %arrayidx21, align 8
  %26 = load double, double* %fmean2, align 8
  %add22 = fadd double %26, %25
  store double %add22, double* %fmean2, align 8
  br label %for.inc23

for.inc23:                                        ; preds = %if.end20
  %27 = load i32, i32* %x9, align 4
  %inc24 = add i32 %27, 1
  store i32 %inc24, i32* %x9, align 4
  br label %for.cond10

for.end25:                                        ; preds = %for.cond10
  %28 = load i32, i32* %ARRAY2_SIZE.addr, align 4
  %conv26 = uitofp i32 %28 to double
  %29 = load double, double* %fmean2, align 8
  %div27 = fdiv double %29, %conv26
  store double %div27, double* %fmean2, align 8
  %30 = load double, double* %fmean1, align 8
  %31 = load double, double* %fmean2, align 8
  %cmp28 = fcmp oeq double %30, %31
  br i1 %cmp28, label %if.then30, label %if.end31

if.then30:                                        ; preds = %for.end25
  store double 1.000000e+00, double* %retval, align 8
  br label %return

if.end31:                                         ; preds = %for.end25
  store double 0.000000e+00, double* %unbiased_sample_variance1, align 8
  store double 0.000000e+00, double* %unbiased_sample_variance2, align 8
  store i32 0, i32* %x32, align 4
  br label %for.cond33

for.cond33:                                       ; preds = %for.inc41, %if.end31
  %32 = load i32, i32* %x32, align 4
  %33 = load i32, i32* %ARRAY1_SIZE.addr, align 4
  %cmp34 = icmp ult i32 %32, %33
  br i1 %cmp34, label %for.body36, label %for.end43

for.body36:                                       ; preds = %for.cond33
  %34 = load double*, double** %ARRAY1.addr, align 4
  %35 = load i32, i32* %x32, align 4
  %arrayidx37 = getelementptr inbounds double, double* %34, i32 %35
  %36 = load double, double* %arrayidx37, align 8
  %37 = load double, double* %fmean1, align 8
  %sub = fsub double %36, %37
  %38 = load double*, double** %ARRAY1.addr, align 4
  %39 = load i32, i32* %x32, align 4
  %arrayidx38 = getelementptr inbounds double, double* %38, i32 %39
  %40 = load double, double* %arrayidx38, align 8
  %41 = load double, double* %fmean1, align 8
  %sub39 = fsub double %40, %41
  %mul = fmul double %sub, %sub39
  %42 = load double, double* %unbiased_sample_variance1, align 8
  %add40 = fadd double %42, %mul
  store double %add40, double* %unbiased_sample_variance1, align 8
  br label %for.inc41

for.inc41:                                        ; preds = %for.body36
  %43 = load i32, i32* %x32, align 4
  %inc42 = add i32 %43, 1
  store i32 %inc42, i32* %x32, align 4
  br label %for.cond33

for.end43:                                        ; preds = %for.cond33
  store i32 0, i32* %x44, align 4
  br label %for.cond45

for.cond45:                                       ; preds = %for.inc55, %for.end43
  %44 = load i32, i32* %x44, align 4
  %45 = load i32, i32* %ARRAY2_SIZE.addr, align 4
  %cmp46 = icmp ult i32 %44, %45
  br i1 %cmp46, label %for.body48, label %for.end57

for.body48:                                       ; preds = %for.cond45
  %46 = load double*, double** %ARRAY2.addr, align 4
  %47 = load i32, i32* %x44, align 4
  %arrayidx49 = getelementptr inbounds double, double* %46, i32 %47
  %48 = load double, double* %arrayidx49, align 8
  %49 = load double, double* %fmean2, align 8
  %sub50 = fsub double %48, %49
  %50 = load double*, double** %ARRAY2.addr, align 4
  %51 = load i32, i32* %x44, align 4
  %arrayidx51 = getelementptr inbounds double, double* %50, i32 %51
  %52 = load double, double* %arrayidx51, align 8
  %53 = load double, double* %fmean2, align 8
  %sub52 = fsub double %52, %53
  %mul53 = fmul double %sub50, %sub52
  %54 = load double, double* %unbiased_sample_variance2, align 8
  %add54 = fadd double %54, %mul53
  store double %add54, double* %unbiased_sample_variance2, align 8
  br label %for.inc55

for.inc55:                                        ; preds = %for.body48
  %55 = load i32, i32* %x44, align 4
  %inc56 = add i32 %55, 1
  store i32 %inc56, i32* %x44, align 4
  br label %for.cond45

for.end57:                                        ; preds = %for.cond45
  %56 = load double, double* %unbiased_sample_variance1, align 8
  %57 = load i32, i32* %ARRAY1_SIZE.addr, align 4
  %sub58 = sub i32 %57, 1
  %conv59 = uitofp i32 %sub58 to double
  %div60 = fdiv double %56, %conv59
  store double %div60, double* %unbiased_sample_variance1, align 8
  %58 = load double, double* %unbiased_sample_variance2, align 8
  %59 = load i32, i32* %ARRAY2_SIZE.addr, align 4
  %sub61 = sub i32 %59, 1
  %conv62 = uitofp i32 %sub61 to double
  %div63 = fdiv double %58, %conv62
  store double %div63, double* %unbiased_sample_variance2, align 8
  %60 = load double, double* %fmean1, align 8
  %61 = load double, double* %fmean2, align 8
  %sub64 = fsub double %60, %61
  %62 = load double, double* %unbiased_sample_variance1, align 8
  %63 = load i32, i32* %ARRAY1_SIZE.addr, align 4
  %conv65 = uitofp i32 %63 to double
  %div66 = fdiv double %62, %conv65
  %64 = load double, double* %unbiased_sample_variance2, align 8
  %65 = load i32, i32* %ARRAY2_SIZE.addr, align 4
  %conv67 = uitofp i32 %65 to double
  %div68 = fdiv double %64, %conv67
  %add69 = fadd double %div66, %div68
  %66 = call double @llvm.sqrt.f64(double %add69)
  %div70 = fdiv double %sub64, %66
  store double %div70, double* %WELCH_T_STATISTIC, align 8
  %67 = load double, double* %unbiased_sample_variance1, align 8
  %68 = load i32, i32* %ARRAY1_SIZE.addr, align 4
  %conv71 = uitofp i32 %68 to double
  %div72 = fdiv double %67, %conv71
  %69 = load double, double* %unbiased_sample_variance2, align 8
  %70 = load i32, i32* %ARRAY2_SIZE.addr, align 4
  %conv73 = uitofp i32 %70 to double
  %div74 = fdiv double %69, %conv73
  %add75 = fadd double %div72, %div74
  %71 = call double @llvm.pow.f64(double %add75, double 2.000000e+00)
  %72 = load double, double* %unbiased_sample_variance1, align 8
  %73 = load double, double* %unbiased_sample_variance1, align 8
  %mul76 = fmul double %72, %73
  %74 = load i32, i32* %ARRAY1_SIZE.addr, align 4
  %75 = load i32, i32* %ARRAY1_SIZE.addr, align 4
  %mul77 = mul i32 %74, %75
  %76 = load i32, i32* %ARRAY1_SIZE.addr, align 4
  %sub78 = sub i32 %76, 1
  %mul79 = mul i32 %mul77, %sub78
  %conv80 = uitofp i32 %mul79 to double
  %div81 = fdiv double %mul76, %conv80
  %77 = load double, double* %unbiased_sample_variance2, align 8
  %78 = load double, double* %unbiased_sample_variance2, align 8
  %mul82 = fmul double %77, %78
  %79 = load i32, i32* %ARRAY2_SIZE.addr, align 4
  %80 = load i32, i32* %ARRAY2_SIZE.addr, align 4
  %mul83 = mul i32 %79, %80
  %81 = load i32, i32* %ARRAY2_SIZE.addr, align 4
  %sub84 = sub i32 %81, 1
  %mul85 = mul i32 %mul83, %sub84
  %conv86 = uitofp i32 %mul85 to double
  %div87 = fdiv double %mul82, %conv86
  %add88 = fadd double %div81, %div87
  %div89 = fdiv double %71, %add88
  store double %div89, double* %DEGREES_OF_FREEDOM, align 8
  %82 = load double, double* %DEGREES_OF_FREEDOM, align 8
  %div90 = fdiv double %82, 2.000000e+00
  store double %div90, double* %a, align 8
  %83 = load double, double* %DEGREES_OF_FREEDOM, align 8
  %84 = load double, double* %WELCH_T_STATISTIC, align 8
  %85 = load double, double* %WELCH_T_STATISTIC, align 8
  %mul91 = fmul double %84, %85
  %86 = load double, double* %DEGREES_OF_FREEDOM, align 8
  %add92 = fadd double %mul91, %86
  %div93 = fdiv double %83, %add92
  store double %div93, double* %value, align 8
  %87 = load double, double* %value, align 8
  %88 = call double @llvm.fabs.f64(double %87) #7
  %cmpinf94 = fcmp oeq double %88, 0x7FF0000000000000
  br i1 %cmpinf94, label %if.then100, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %for.end57
  %89 = load double, double* %value, align 8
  %cmp97 = fcmp uno double %89, %89
  br i1 %cmp97, label %if.then100, label %if.end101

if.then100:                                       ; preds = %lor.lhs.false, %for.end57
  store double 1.000000e+00, double* %retval, align 8
  br label %return

if.end101:                                        ; preds = %lor.lhs.false
  %90 = load double, double* %value, align 8
  %91 = call double @llvm.fabs.f64(double %90) #7
  %cmpinf102 = fcmp oeq double %91, 0x7FF0000000000000
  br i1 %cmpinf102, label %if.then109, label %lor.lhs.false105

lor.lhs.false105:                                 ; preds = %if.end101
  %92 = load double, double* %value, align 8
  %cmp106 = fcmp uno double %92, %92
  %93 = zext i1 %cmp106 to i32
  %cmp107 = icmp ne i32 %93, 0
  br i1 %cmp107, label %if.then109, label %if.end110

if.then109:                                       ; preds = %lor.lhs.false105, %if.end101
  store double 1.000000e+00, double* %retval, align 8
  br label %return

if.end110:                                        ; preds = %lor.lhs.false105
  %94 = load double, double* %a, align 8
  %conv111 = fpext double %94 to fp128
  %call112 = call fp128 @lgammal(fp128 %conv111) #9
  %add113 = fadd fp128 %call112, 0xLD0000000000000003FFE250D048E7A1B
  %95 = load double, double* %a, align 8
  %add114 = fadd double %95, 5.000000e-01
  %conv115 = fpext double %add114 to fp128
  %call116 = call fp128 @lgammal(fp128 %conv115) #9
  %sub117 = fsub fp128 %add113, %call116
  %conv118 = fptrunc fp128 %sub117 to double
  store double %conv118, double* %beta, align 8
  store double 1.000000e-15, double* %acu, align 8
  %96 = load double, double* %a, align 8
  %cmp119 = fcmp ole double %96, 0.000000e+00
  br i1 %cmp119, label %if.then121, label %if.end122

if.then121:                                       ; preds = %if.end110
  br label %if.end122

if.end122:                                        ; preds = %if.then121, %if.end110
  %97 = load double, double* %value, align 8
  %cmp123 = fcmp olt double %97, 0.000000e+00
  br i1 %cmp123, label %if.then128, label %lor.lhs.false125

lor.lhs.false125:                                 ; preds = %if.end122
  %98 = load double, double* %value, align 8
  %cmp126 = fcmp olt double 1.000000e+00, %98
  br i1 %cmp126, label %if.then128, label %if.end129

if.then128:                                       ; preds = %lor.lhs.false125, %if.end122
  %99 = load double, double* %value, align 8
  store double %99, double* %retval, align 8
  br label %return

if.end129:                                        ; preds = %lor.lhs.false125
  %100 = load double, double* %value, align 8
  %cmp130 = fcmp oeq double %100, 0.000000e+00
  br i1 %cmp130, label %if.then135, label %lor.lhs.false132

lor.lhs.false132:                                 ; preds = %if.end129
  %101 = load double, double* %value, align 8
  %cmp133 = fcmp oeq double %101, 1.000000e+00
  br i1 %cmp133, label %if.then135, label %if.end136

if.then135:                                       ; preds = %lor.lhs.false132, %if.end129
  %102 = load double, double* %value, align 8
  store double %102, double* %retval, align 8
  br label %return

if.end136:                                        ; preds = %lor.lhs.false132
  %103 = load double, double* %a, align 8
  %add137 = fadd double %103, 5.000000e-01
  store double %add137, double* %psq, align 8
  %104 = load double, double* %value, align 8
  %sub138 = fsub double 1.000000e+00, %104
  store double %sub138, double* %cx, align 8
  %105 = load double, double* %a, align 8
  %106 = load double, double* %psq, align 8
  %107 = load double, double* %value, align 8
  %mul139 = fmul double %106, %107
  %cmp140 = fcmp olt double %105, %mul139
  br i1 %cmp140, label %if.then142, label %if.else143

if.then142:                                       ; preds = %if.end136
  %108 = load double, double* %cx, align 8
  store double %108, double* %xx, align 8
  %109 = load double, double* %value, align 8
  store double %109, double* %cx, align 8
  store double 5.000000e-01, double* %pp, align 8
  %110 = load double, double* %a, align 8
  store double %110, double* %qq, align 8
  store i32 1, i32* %indx, align 4
  br label %if.end144

if.else143:                                       ; preds = %if.end136
  %111 = load double, double* %value, align 8
  store double %111, double* %xx, align 8
  %112 = load double, double* %a, align 8
  store double %112, double* %pp, align 8
  store double 5.000000e-01, double* %qq, align 8
  store i32 0, i32* %indx, align 4
  br label %if.end144

if.end144:                                        ; preds = %if.else143, %if.then142
  store double 1.000000e+00, double* %term, align 8
  store double 1.000000e+00, double* %ai, align 8
  store double 1.000000e+00, double* %value, align 8
  %113 = load double, double* %qq, align 8
  %114 = load double, double* %cx, align 8
  %115 = load double, double* %psq, align 8
  %mul145 = fmul double %114, %115
  %add146 = fadd double %113, %mul145
  %conv147 = fptosi double %add146 to i32
  store i32 %conv147, i32* %ns, align 4
  %116 = load double, double* %xx, align 8
  %117 = load double, double* %cx, align 8
  %div148 = fdiv double %116, %117
  store double %div148, double* %rx, align 8
  %118 = load double, double* %qq, align 8
  %119 = load double, double* %ai, align 8
  %sub149 = fsub double %118, %119
  store double %sub149, double* %temp, align 8
  %120 = load i32, i32* %ns, align 4
  %cmp150 = icmp eq i32 %120, 0
  br i1 %cmp150, label %if.then152, label %if.end153

if.then152:                                       ; preds = %if.end144
  %121 = load double, double* %xx, align 8
  store double %121, double* %rx, align 8
  br label %if.end153

if.end153:                                        ; preds = %if.then152, %if.end144
  br label %for.cond154

for.cond154:                                      ; preds = %if.end189, %if.end153
  %122 = load double, double* %term, align 8
  %123 = load double, double* %temp, align 8
  %mul155 = fmul double %122, %123
  %124 = load double, double* %rx, align 8
  %mul156 = fmul double %mul155, %124
  %125 = load double, double* %pp, align 8
  %126 = load double, double* %ai, align 8
  %add157 = fadd double %125, %126
  %div158 = fdiv double %mul156, %add157
  store double %div158, double* %term, align 8
  %127 = load double, double* %value, align 8
  %128 = load double, double* %term, align 8
  %add159 = fadd double %127, %128
  store double %add159, double* %value, align 8
  %129 = load double, double* %term, align 8
  %130 = call double @llvm.fabs.f64(double %129)
  store double %130, double* %temp, align 8
  %131 = load double, double* %temp, align 8
  %cmp160 = fcmp ole double %131, 1.000000e-15
  br i1 %cmp160, label %land.lhs.true, label %if.end176

land.lhs.true:                                    ; preds = %for.cond154
  %132 = load double, double* %temp, align 8
  %133 = load double, double* %value, align 8
  %mul162 = fmul double 1.000000e-15, %133
  %cmp163 = fcmp ole double %132, %mul162
  br i1 %cmp163, label %if.then165, label %if.end176

if.then165:                                       ; preds = %land.lhs.true
  %134 = load double, double* %value, align 8
  %135 = load double, double* %pp, align 8
  %136 = load double, double* %xx, align 8
  %137 = call double @llvm.log.f64(double %136)
  %mul166 = fmul double %135, %137
  %138 = load double, double* %qq, align 8
  %sub167 = fsub double %138, 1.000000e+00
  %139 = load double, double* %cx, align 8
  %140 = call double @llvm.log.f64(double %139)
  %mul168 = fmul double %sub167, %140
  %add169 = fadd double %mul166, %mul168
  %141 = load double, double* %beta, align 8
  %sub170 = fsub double %add169, %141
  %142 = call double @llvm.exp.f64(double %sub170)
  %mul171 = fmul double %134, %142
  %143 = load double, double* %pp, align 8
  %div172 = fdiv double %mul171, %143
  store double %div172, double* %value, align 8
  %144 = load i32, i32* %indx, align 4
  %tobool = icmp ne i32 %144, 0
  br i1 %tobool, label %if.then173, label %if.end175

if.then173:                                       ; preds = %if.then165
  %145 = load double, double* %value, align 8
  %sub174 = fsub double 1.000000e+00, %145
  store double %sub174, double* %value, align 8
  br label %if.end175

if.end175:                                        ; preds = %if.then173, %if.then165
  br label %for.end190

if.end176:                                        ; preds = %land.lhs.true, %for.cond154
  %146 = load double, double* %ai, align 8
  %add177 = fadd double %146, 1.000000e+00
  store double %add177, double* %ai, align 8
  %147 = load i32, i32* %ns, align 4
  %sub178 = sub nsw i32 %147, 1
  store i32 %sub178, i32* %ns, align 4
  %148 = load i32, i32* %ns, align 4
  %cmp179 = icmp sle i32 0, %148
  br i1 %cmp179, label %if.then181, label %if.else187

if.then181:                                       ; preds = %if.end176
  %149 = load double, double* %qq, align 8
  %150 = load double, double* %ai, align 8
  %sub182 = fsub double %149, %150
  store double %sub182, double* %temp, align 8
  %151 = load i32, i32* %ns, align 4
  %cmp183 = icmp eq i32 %151, 0
  br i1 %cmp183, label %if.then185, label %if.end186

if.then185:                                       ; preds = %if.then181
  %152 = load double, double* %xx, align 8
  store double %152, double* %rx, align 8
  br label %if.end186

if.end186:                                        ; preds = %if.then185, %if.then181
  br label %if.end189

if.else187:                                       ; preds = %if.end176
  %153 = load double, double* %psq, align 8
  store double %153, double* %temp, align 8
  %154 = load double, double* %psq, align 8
  %add188 = fadd double %154, 1.000000e+00
  store double %add188, double* %psq, align 8
  br label %if.end189

if.end189:                                        ; preds = %if.else187, %if.end186
  br label %for.cond154

for.end190:                                       ; preds = %if.end175
  %155 = load double, double* %value, align 8
  store double %155, double* %retval, align 8
  br label %return

return:                                           ; preds = %for.end190, %if.then135, %if.then128, %if.then109, %if.then100, %if.then30, %if.then2, %if.then
  %156 = load double, double* %retval, align 8
  ret double %156
}

; Function Attrs: nounwind readnone speculatable willreturn
declare double @llvm.fabs.f64(double %0) #1

declare i32 @puts(i8* %0) #2

; Function Attrs: noreturn
declare void @exit(i32 %0) #3

; Function Attrs: nounwind readnone speculatable willreturn
declare double @llvm.sqrt.f64(double %0) #1

; Function Attrs: nounwind readnone speculatable willreturn
declare double @llvm.pow.f64(double %0, double %1) #1

; Function Attrs: nounwind
declare fp128 @lgammal(fp128 %0) #4

; Function Attrs: nounwind readnone speculatable willreturn
declare double @llvm.log.f64(double %0) #1

; Function Attrs: nounwind readnone speculatable willreturn
declare double @llvm.exp.f64(double %0) #1

; Function Attrs: noinline nounwind optnone
define hidden i32 @main() #0 {
entry:
  %retval = alloca i32, align 4
  %d1 = alloca [15 x double], align 16
  %d2 = alloca [15 x double], align 16
  %d3 = alloca [10 x double], align 16
  %d4 = alloca [20 x double], align 16
  %d5 = alloca [10 x double], align 16
  %d6 = alloca [20 x double], align 16
  %d7 = alloca [6 x double], align 16
  %d8 = alloca [6 x double], align 16
  %x = alloca [4 x double], align 16
  %y = alloca [3 x double], align 16
  %v1 = alloca [3 x double], align 16
  %v2 = alloca [3 x double], align 16
  %s1 = alloca [2 x double], align 16
  %s2 = alloca [2 x double], align 16
  %z1 = alloca [3 x double], align 16
  %z2 = alloca [3 x double], align 16
  %CORRECT_ANSWERS = alloca [8 x double], align 16
  %pvalue = alloca double, align 8
  %error = alloca double, align 8
  store i32 0, i32* %retval, align 4
  %0 = bitcast [15 x double]* %d1 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 16 %0, i8* align 16 bitcast ([15 x double]* @__const.main.d1 to i8*), i32 120, i1 false)
  %1 = bitcast [15 x double]* %d2 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 16 %1, i8* align 16 bitcast ([15 x double]* @__const.main.d2 to i8*), i32 120, i1 false)
  %2 = bitcast [10 x double]* %d3 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 16 %2, i8* align 16 bitcast ([10 x double]* @__const.main.d3 to i8*), i32 80, i1 false)
  %3 = bitcast [20 x double]* %d4 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 16 %3, i8* align 16 bitcast ([20 x double]* @__const.main.d4 to i8*), i32 160, i1 false)
  %4 = bitcast [10 x double]* %d5 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 16 %4, i8* align 16 bitcast ([10 x double]* @__const.main.d5 to i8*), i32 80, i1 false)
  %5 = bitcast [20 x double]* %d6 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 16 %5, i8* align 16 bitcast ([20 x double]* @__const.main.d6 to i8*), i32 160, i1 false)
  %6 = bitcast [6 x double]* %d7 to i8*
  call void @llvm.memset.p0i8.i32(i8* align 16 %6, i8 0, i32 48, i1 false)
  %7 = bitcast i8* %6 to [6 x double]*
  %8 = getelementptr inbounds [6 x double], [6 x double]* %7, i32 0, i32 0
  store double 3.002000e+01, double* %8, align 16
  %9 = getelementptr inbounds [6 x double], [6 x double]* %7, i32 0, i32 1
  store double 2.999000e+01, double* %9, align 8
  %10 = getelementptr inbounds [6 x double], [6 x double]* %7, i32 0, i32 2
  store double 3.011000e+01, double* %10, align 16
  %11 = getelementptr inbounds [6 x double], [6 x double]* %7, i32 0, i32 3
  store double 2.997000e+01, double* %11, align 8
  %12 = getelementptr inbounds [6 x double], [6 x double]* %7, i32 0, i32 4
  store double 3.001000e+01, double* %12, align 16
  %13 = getelementptr inbounds [6 x double], [6 x double]* %7, i32 0, i32 5
  store double 2.999000e+01, double* %13, align 8
  %14 = bitcast [6 x double]* %d8 to i8*
  call void @llvm.memset.p0i8.i32(i8* align 16 %14, i8 0, i32 48, i1 false)
  %15 = bitcast i8* %14 to [6 x double]*
  %16 = getelementptr inbounds [6 x double], [6 x double]* %15, i32 0, i32 0
  store double 2.989000e+01, double* %16, align 16
  %17 = getelementptr inbounds [6 x double], [6 x double]* %15, i32 0, i32 1
  store double 2.993000e+01, double* %17, align 8
  %18 = getelementptr inbounds [6 x double], [6 x double]* %15, i32 0, i32 2
  store double 2.972000e+01, double* %18, align 16
  %19 = getelementptr inbounds [6 x double], [6 x double]* %15, i32 0, i32 3
  store double 2.998000e+01, double* %19, align 8
  %20 = getelementptr inbounds [6 x double], [6 x double]* %15, i32 0, i32 4
  store double 3.002000e+01, double* %20, align 16
  %21 = getelementptr inbounds [6 x double], [6 x double]* %15, i32 0, i32 5
  store double 2.998000e+01, double* %21, align 8
  %22 = bitcast [4 x double]* %x to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 16 %22, i8* align 16 bitcast ([4 x double]* @__const.main.x to i8*), i32 32, i1 false)
  %23 = bitcast [3 x double]* %y to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 16 %23, i8* align 16 bitcast ([3 x double]* @__const.main.y to i8*), i32 24, i1 false)
  %24 = bitcast [3 x double]* %v1 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 16 %24, i8* align 16 bitcast ([3 x double]* @__const.main.v1 to i8*), i32 24, i1 false)
  %25 = bitcast [3 x double]* %v2 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 16 %25, i8* align 16 bitcast ([3 x double]* @__const.main.v2 to i8*), i32 24, i1 false)
  %26 = bitcast [2 x double]* %s1 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 16 %26, i8* align 16 bitcast ([2 x double]* @__const.main.s1 to i8*), i32 16, i1 false)
  %27 = bitcast [2 x double]* %s2 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 16 %27, i8* align 16 bitcast ([2 x double]* @__const.main.s2 to i8*), i32 16, i1 false)
  %28 = bitcast [3 x double]* %z1 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 16 %28, i8* align 16 bitcast ([3 x double]* @__const.main.z1 to i8*), i32 24, i1 false)
  %29 = bitcast [3 x double]* %z2 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 16 %29, i8* align 16 bitcast ([3 x double]* @__const.main.z2 to i8*), i32 24, i1 false)
  %30 = bitcast [8 x double]* %CORRECT_ANSWERS to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 16 %30, i8* align 16 bitcast ([8 x double]* @__const.main.CORRECT_ANSWERS to i8*), i32 64, i1 false)
  %arraydecay = getelementptr inbounds [15 x double], [15 x double]* %d1, i32 0, i32 0
  %arraydecay1 = getelementptr inbounds [15 x double], [15 x double]* %d2, i32 0, i32 0
  %call = call double @Pvalue(double* %arraydecay, i32 15, double* %arraydecay1, i32 15)
  store double %call, double* %pvalue, align 8
  %31 = load double, double* %pvalue, align 8
  %arrayidx = getelementptr inbounds [8 x double], [8 x double]* %CORRECT_ANSWERS, i32 0, i32 0
  %32 = load double, double* %arrayidx, align 16
  %sub = fsub double %31, %32
  %33 = call double @llvm.fabs.f64(double %sub)
  store double %33, double* %error, align 8
  %34 = load double, double* %pvalue, align 8
  %call2 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([26 x i8], [26 x i8]* @.str.2, i32 0, i32 0), double %34)
  %arraydecay3 = getelementptr inbounds [10 x double], [10 x double]* %d3, i32 0, i32 0
  %arraydecay4 = getelementptr inbounds [20 x double], [20 x double]* %d4, i32 0, i32 0
  %call5 = call double @Pvalue(double* %arraydecay3, i32 10, double* %arraydecay4, i32 20)
  store double %call5, double* %pvalue, align 8
  %35 = load double, double* %pvalue, align 8
  %arrayidx6 = getelementptr inbounds [8 x double], [8 x double]* %CORRECT_ANSWERS, i32 0, i32 1
  %36 = load double, double* %arrayidx6, align 8
  %sub7 = fsub double %35, %36
  %37 = call double @llvm.fabs.f64(double %sub7)
  %38 = load double, double* %error, align 8
  %add = fadd double %38, %37
  store double %add, double* %error, align 8
  %39 = load double, double* %pvalue, align 8
  %call8 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([26 x i8], [26 x i8]* @.str.3, i32 0, i32 0), double %39)
  %arraydecay9 = getelementptr inbounds [10 x double], [10 x double]* %d5, i32 0, i32 0
  %arraydecay10 = getelementptr inbounds [20 x double], [20 x double]* %d6, i32 0, i32 0
  %call11 = call double @Pvalue(double* %arraydecay9, i32 10, double* %arraydecay10, i32 20)
  store double %call11, double* %pvalue, align 8
  %40 = load double, double* %pvalue, align 8
  %arrayidx12 = getelementptr inbounds [8 x double], [8 x double]* %CORRECT_ANSWERS, i32 0, i32 2
  %41 = load double, double* %arrayidx12, align 16
  %sub13 = fsub double %40, %41
  %42 = call double @llvm.fabs.f64(double %sub13)
  %43 = load double, double* %error, align 8
  %add14 = fadd double %43, %42
  store double %add14, double* %error, align 8
  %44 = load double, double* %pvalue, align 8
  %call15 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([26 x i8], [26 x i8]* @.str.4, i32 0, i32 0), double %44)
  %arraydecay16 = getelementptr inbounds [6 x double], [6 x double]* %d7, i32 0, i32 0
  %arraydecay17 = getelementptr inbounds [6 x double], [6 x double]* %d8, i32 0, i32 0
  %call18 = call double @Pvalue(double* %arraydecay16, i32 6, double* %arraydecay17, i32 6)
  store double %call18, double* %pvalue, align 8
  %45 = load double, double* %pvalue, align 8
  %call19 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([26 x i8], [26 x i8]* @.str.5, i32 0, i32 0), double %45)
  %46 = load double, double* %pvalue, align 8
  %arrayidx20 = getelementptr inbounds [8 x double], [8 x double]* %CORRECT_ANSWERS, i32 0, i32 3
  %47 = load double, double* %arrayidx20, align 8
  %sub21 = fsub double %46, %47
  %48 = call double @llvm.fabs.f64(double %sub21)
  %49 = load double, double* %error, align 8
  %add22 = fadd double %49, %48
  store double %add22, double* %error, align 8
  %arraydecay23 = getelementptr inbounds [4 x double], [4 x double]* %x, i32 0, i32 0
  %arraydecay24 = getelementptr inbounds [3 x double], [3 x double]* %y, i32 0, i32 0
  %call25 = call double @Pvalue(double* %arraydecay23, i32 4, double* %arraydecay24, i32 3)
  store double %call25, double* %pvalue, align 8
  %50 = load double, double* %pvalue, align 8
  %arrayidx26 = getelementptr inbounds [8 x double], [8 x double]* %CORRECT_ANSWERS, i32 0, i32 4
  %51 = load double, double* %arrayidx26, align 16
  %sub27 = fsub double %50, %51
  %52 = call double @llvm.fabs.f64(double %sub27)
  %53 = load double, double* %error, align 8
  %add28 = fadd double %53, %52
  store double %add28, double* %error, align 8
  %54 = load double, double* %pvalue, align 8
  %call29 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([26 x i8], [26 x i8]* @.str.6, i32 0, i32 0), double %54)
  %arraydecay30 = getelementptr inbounds [3 x double], [3 x double]* %v1, i32 0, i32 0
  %arraydecay31 = getelementptr inbounds [3 x double], [3 x double]* %v2, i32 0, i32 0
  %call32 = call double @Pvalue(double* %arraydecay30, i32 3, double* %arraydecay31, i32 3)
  store double %call32, double* %pvalue, align 8
  %55 = load double, double* %pvalue, align 8
  %arrayidx33 = getelementptr inbounds [8 x double], [8 x double]* %CORRECT_ANSWERS, i32 0, i32 5
  %56 = load double, double* %arrayidx33, align 8
  %sub34 = fsub double %55, %56
  %57 = call double @llvm.fabs.f64(double %sub34)
  %58 = load double, double* %error, align 8
  %add35 = fadd double %58, %57
  store double %add35, double* %error, align 8
  %59 = load double, double* %pvalue, align 8
  %call36 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([26 x i8], [26 x i8]* @.str.7, i32 0, i32 0), double %59)
  %arraydecay37 = getelementptr inbounds [2 x double], [2 x double]* %s1, i32 0, i32 0
  %arraydecay38 = getelementptr inbounds [2 x double], [2 x double]* %s2, i32 0, i32 0
  %call39 = call double @Pvalue(double* %arraydecay37, i32 2, double* %arraydecay38, i32 2)
  store double %call39, double* %pvalue, align 8
  %60 = load double, double* %pvalue, align 8
  %arrayidx40 = getelementptr inbounds [8 x double], [8 x double]* %CORRECT_ANSWERS, i32 0, i32 6
  %61 = load double, double* %arrayidx40, align 16
  %sub41 = fsub double %60, %61
  %62 = call double @llvm.fabs.f64(double %sub41)
  %63 = load double, double* %error, align 8
  %add42 = fadd double %63, %62
  store double %add42, double* %error, align 8
  %64 = load double, double* %pvalue, align 8
  %call43 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([26 x i8], [26 x i8]* @.str.8, i32 0, i32 0), double %64)
  %arraydecay44 = getelementptr inbounds [3 x double], [3 x double]* %z1, i32 0, i32 0
  %arraydecay45 = getelementptr inbounds [3 x double], [3 x double]* %z2, i32 0, i32 0
  %call46 = call double @Pvalue(double* %arraydecay44, i32 3, double* %arraydecay45, i32 3)
  store double %call46, double* %pvalue, align 8
  %65 = load double, double* %pvalue, align 8
  %arrayidx47 = getelementptr inbounds [8 x double], [8 x double]* %CORRECT_ANSWERS, i32 0, i32 7
  %66 = load double, double* %arrayidx47, align 8
  %sub48 = fsub double %65, %66
  %67 = call double @llvm.fabs.f64(double %sub48)
  %68 = load double, double* %error, align 8
  %add49 = fadd double %68, %67
  store double %add49, double* %error, align 8
  %69 = load double, double* %pvalue, align 8
  %call50 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([26 x i8], [26 x i8]* @.str.9, i32 0, i32 0), double %69)
  %70 = load double, double* %error, align 8
  %call51 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([28 x i8], [28 x i8]* @.str.10, i32 0, i32 0), double %70)
  ret i32 0
}

; Function Attrs: argmemonly nounwind willreturn
declare void @llvm.memcpy.p0i8.p0i8.i32(i8* noalias nocapture writeonly %0, i8* noalias nocapture readonly %1, i32 %2, i1 immarg %3) #5

; Function Attrs: argmemonly nounwind willreturn writeonly
declare void @llvm.memset.p0i8.i32(i8* nocapture writeonly %0, i8 %1, i32 %2, i1 immarg %3) #6

declare i32 @printf(i8* %0, ...) #2

attributes #0 = { noinline nounwind optnone "correctly-rounded-divide-sqrt-fp-math"="false" "disable-tail-calls"="false" "frame-pointer"="none" "less-precise-fpmad"="false" "min-legal-vector-width"="0" "no-infs-fp-math"="false" "no-jump-tables"="false" "no-nans-fp-math"="false" "no-signed-zeros-fp-math"="false" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="generic" "unsafe-fp-math"="false" "use-soft-float"="false" }
attributes #1 = { nounwind readnone speculatable willreturn }
attributes #2 = { "correctly-rounded-divide-sqrt-fp-math"="false" "disable-tail-calls"="false" "frame-pointer"="none" "less-precise-fpmad"="false" "no-infs-fp-math"="false" "no-nans-fp-math"="false" "no-signed-zeros-fp-math"="false" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="generic" "unsafe-fp-math"="false" "use-soft-float"="false" }
attributes #3 = { noreturn "correctly-rounded-divide-sqrt-fp-math"="false" "disable-tail-calls"="false" "frame-pointer"="none" "less-precise-fpmad"="false" "no-infs-fp-math"="false" "no-nans-fp-math"="false" "no-signed-zeros-fp-math"="false" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="generic" "unsafe-fp-math"="false" "use-soft-float"="false" }
attributes #4 = { nounwind "correctly-rounded-divide-sqrt-fp-math"="false" "disable-tail-calls"="false" "frame-pointer"="none" "less-precise-fpmad"="false" "no-infs-fp-math"="false" "no-nans-fp-math"="false" "no-signed-zeros-fp-math"="false" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="generic" "unsafe-fp-math"="false" "use-soft-float"="false" }
attributes #5 = { argmemonly nounwind willreturn }
attributes #6 = { argmemonly nounwind willreturn writeonly }
attributes #7 = { readnone }
attributes #8 = { noreturn }
attributes #9 = { nounwind }

!llvm.module.flags = !{!0}
!llvm.ident = !{!1}

!0 = !{i32 1, !"wchar_size", i32 4}
!1 = !{!"clang version 11.0.0 (https://github.com/Jacarte/llvm-project.git 0f6dea67136cc1e0b3d200eb2bb165628970c44b)"}

; extracted candidates

; *****
; For LLVM instruction:
;  %0 = load i32, i32* %ARRAY1_SIZE.addr, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %cmp = icmp ule i32 %0, 1
; Looking for a replacement for:
%0:i32 = var
%1:i1 = ule %0, 1:i32
infer %1

; *****
; For LLVM instruction:
;  %1 = load i32, i32* %ARRAY2_SIZE.addr, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %cmp1 = icmp ule i32 %1, 1
; Looking for a replacement for:
%0:i32 = var
%1:i1 = ule %0, 1:i32
infer %1

; *****
; For LLVM instruction:
;  %2 = load i32, i32* %x, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %3 = load i32, i32* %ARRAY1_SIZE.addr, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %cmp4 = icmp ult i32 %2, %3
; Looking for a replacement for:
%0:i32 = var
%1:i32 = var
%2:i1 = ult %0, %1
infer %2

; *****
; For LLVM instruction:
;  %5 = load i32, i32* %x, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %cmpinf = fcmp one double %7, 0x7FF0000000000000
; Looking for a replacement for:
%0:i1 = var
infer %0

; *****
; For LLVM instruction:
;  %8 = zext i1 %cmpinf to i32
; Looking for a replacement for:
%0:i1 = var
%1:i32 = zext %0
infer %1

; *****
; For LLVM instruction:
;  %cmp5 = icmp eq i32 %8, 0
; Looking for a replacement for:
%0:i1 = var
%1:i32 = zext %0
%2:i1 = eq 0:i32, %1
infer %2

; *****
; For LLVM instruction:
;  %10 = load i32, i32* %x, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %13 = load i32, i32* %x, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %inc = add i32 %13, 1
; Looking for a replacement for:
%0:i32 = var
%1:i32 = add 1:i32, %0
infer %1

; *****
; For LLVM instruction:
;  %14 = load i32, i32* %ARRAY1_SIZE.addr, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %16 = load i32, i32* %x9, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %17 = load i32, i32* %ARRAY2_SIZE.addr, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %cmp11 = icmp ult i32 %16, %17
; Looking for a replacement for:
%0:i32 = var
%1:i32 = var
%2:i1 = ult %0, %1
infer %2

; *****
; For LLVM instruction:
;  %19 = load i32, i32* %x9, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %cmpinf15 = fcmp one double %21, 0x7FF0000000000000
; Looking for a replacement for:
%0:i1 = var
infer %0

; *****
; For LLVM instruction:
;  %22 = zext i1 %cmpinf15 to i32
; Looking for a replacement for:
%0:i1 = var
%1:i32 = zext %0
infer %1

; *****
; For LLVM instruction:
;  %cmp16 = icmp eq i32 %22, 0
; Looking for a replacement for:
%0:i1 = var
%1:i32 = zext %0
%2:i1 = eq 0:i32, %1
infer %2

; *****
; For LLVM instruction:
;  %24 = load i32, i32* %x9, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %27 = load i32, i32* %x9, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %inc24 = add i32 %27, 1
; Looking for a replacement for:
%0:i32 = var
%1:i32 = add 1:i32, %0
infer %1

; *****
; For LLVM instruction:
;  %28 = load i32, i32* %ARRAY2_SIZE.addr, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %cmp28 = fcmp oeq double %30, %31
; Looking for a replacement for:
%0:i1 = var
infer %0

; *****
; For LLVM instruction:
;  %32 = load i32, i32* %x32, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %33 = load i32, i32* %ARRAY1_SIZE.addr, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %cmp34 = icmp ult i32 %32, %33
; Looking for a replacement for:
%0:i32 = var
%1:i32 = var
%2:i1 = ult %0, %1
infer %2

; *****
; For LLVM instruction:
;  %35 = load i32, i32* %x32, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %39 = load i32, i32* %x32, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %43 = load i32, i32* %x32, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %inc42 = add i32 %43, 1
; Looking for a replacement for:
%0:i32 = var
%1:i32 = add 1:i32, %0
infer %1

; *****
; For LLVM instruction:
;  %44 = load i32, i32* %x44, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %45 = load i32, i32* %ARRAY2_SIZE.addr, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %cmp46 = icmp ult i32 %44, %45
; Looking for a replacement for:
%0:i32 = var
%1:i32 = var
%2:i1 = ult %0, %1
infer %2

; *****
; For LLVM instruction:
;  %47 = load i32, i32* %x44, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %51 = load i32, i32* %x44, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %55 = load i32, i32* %x44, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %inc56 = add i32 %55, 1
; Looking for a replacement for:
%0:i32 = var
%1:i32 = add 1:i32, %0
infer %1

; *****
; For LLVM instruction:
;  %57 = load i32, i32* %ARRAY1_SIZE.addr, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %sub58 = sub i32 %57, 1
; Looking for a replacement for:
%0:i32 = var
%1:i32 = sub %0, 1:i32
infer %1

; *****
; For LLVM instruction:
;  %59 = load i32, i32* %ARRAY2_SIZE.addr, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %sub61 = sub i32 %59, 1
; Looking for a replacement for:
%0:i32 = var
%1:i32 = sub %0, 1:i32
infer %1

; *****
; For LLVM instruction:
;  %63 = load i32, i32* %ARRAY1_SIZE.addr, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %65 = load i32, i32* %ARRAY2_SIZE.addr, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %68 = load i32, i32* %ARRAY1_SIZE.addr, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %70 = load i32, i32* %ARRAY2_SIZE.addr, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %74 = load i32, i32* %ARRAY1_SIZE.addr, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %75 = load i32, i32* %ARRAY1_SIZE.addr, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %mul77 = mul i32 %74, %75
; Looking for a replacement for:
%0:i32 = var
%1:i32 = var
%2:i32 = mul %0, %1
infer %2

; *****
; For LLVM instruction:
;  %76 = load i32, i32* %ARRAY1_SIZE.addr, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %sub78 = sub i32 %76, 1
; Looking for a replacement for:
%0:i32 = var
%1:i32 = sub %0, 1:i32
infer %1

; *****
; For LLVM instruction:
;  %mul79 = mul i32 %mul77, %sub78
; Looking for a replacement for:
%0:i32 = var
%1:i32 = sub %0, 1:i32
%2:i32 = var
%3:i32 = var
%4:i32 = mul %2, %3
%5:i32 = mul %1, %4
infer %5

; *****
; For LLVM instruction:
;  %79 = load i32, i32* %ARRAY2_SIZE.addr, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %80 = load i32, i32* %ARRAY2_SIZE.addr, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %mul83 = mul i32 %79, %80
; Looking for a replacement for:
%0:i32 = var
%1:i32 = var
%2:i32 = mul %0, %1
infer %2

; *****
; For LLVM instruction:
;  %81 = load i32, i32* %ARRAY2_SIZE.addr, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %sub84 = sub i32 %81, 1
; Looking for a replacement for:
%0:i32 = var
%1:i32 = sub %0, 1:i32
infer %1

; *****
; For LLVM instruction:
;  %mul85 = mul i32 %mul83, %sub84
; Looking for a replacement for:
%0:i32 = var
%1:i32 = sub %0, 1:i32
%2:i32 = var
%3:i32 = var
%4:i32 = mul %2, %3
%5:i32 = mul %1, %4
infer %5

; *****
; For LLVM instruction:
;  %cmpinf94 = fcmp oeq double %88, 0x7FF0000000000000
; Looking for a replacement for:
%0:i1 = var
infer %0

; *****
; For LLVM instruction:
;  %cmp97 = fcmp uno double %89, %89
; Looking for a replacement for:
%0:i1 = var
infer %0

; *****
; For LLVM instruction:
;  %cmpinf102 = fcmp oeq double %91, 0x7FF0000000000000
; Looking for a replacement for:
%0:i1 = var
infer %0

; *****
; For LLVM instruction:
;  %cmp106 = fcmp uno double %92, %92
; Looking for a replacement for:
%0:i1 = var
infer %0

; *****
; For LLVM instruction:
;  %93 = zext i1 %cmp106 to i32
; Looking for a replacement for:
%0:i1 = var
%1:i32 = zext %0
infer %1

; *****
; For LLVM instruction:
;  %cmp107 = icmp ne i32 %93, 0
; Looking for a replacement for:
%0:i1 = var
%1:i32 = zext %0
%2:i1 = ne 0:i32, %1
infer %2

; *****
; For LLVM instruction:
;  %cmp119 = fcmp ole double %96, 0.000000e+00
; Looking for a replacement for:
%0:i1 = var
infer %0

; *****
; For LLVM instruction:
;  %cmp123 = fcmp olt double %97, 0.000000e+00
; Looking for a replacement for:
%0:i1 = var
infer %0

; *****
; For LLVM instruction:
;  %cmp126 = fcmp olt double 1.000000e+00, %98
; Looking for a replacement for:
%0:i1 = var
infer %0

; *****
; For LLVM instruction:
;  %cmp130 = fcmp oeq double %100, 0.000000e+00
; Looking for a replacement for:
%0:i1 = var
infer %0

; *****
; For LLVM instruction:
;  %cmp133 = fcmp oeq double %101, 1.000000e+00
; Looking for a replacement for:
%0:i1 = var
infer %0

; *****
; For LLVM instruction:
;  %cmp140 = fcmp olt double %105, %mul139
; Looking for a replacement for:
%0:i1 = var
infer %0

; *****
; For LLVM instruction:
;  %conv147 = fptosi double %add146 to i32
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %120 = load i32, i32* %ns, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %cmp150 = icmp eq i32 %120, 0
; Looking for a replacement for:
%0:i32 = var
%1:i1 = eq 0:i32, %0
infer %1

; *****
; For LLVM instruction:
;  %cmp160 = fcmp ole double %131, 1.000000e-15
; Looking for a replacement for:
%0:i1 = var
infer %0

; *****
; For LLVM instruction:
;  %cmp163 = fcmp ole double %132, %mul162
; Looking for a replacement for:
%0:i1 = var
infer %0

; *****
; For LLVM instruction:
;  %144 = load i32, i32* %indx, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %tobool = icmp ne i32 %144, 0
; Looking for a replacement for:
%0:i32 = var
%1:i1 = ne 0:i32, %0
infer %1

; *****
; For LLVM instruction:
;  %147 = load i32, i32* %ns, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %sub178 = sub nsw i32 %147, 1
; Looking for a replacement for:
%0:i32 = var
%1:i32 = subnsw %0, 1:i32
infer %1

; *****
; For LLVM instruction:
;  %148 = load i32, i32* %ns, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %cmp179 = icmp sle i32 0, %148
; Looking for a replacement for:
%0:i32 = var
%1:i1 = sle 0:i32, %0
infer %1

; *****
; For LLVM instruction:
;  %151 = load i32, i32* %ns, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %cmp183 = icmp eq i32 %151, 0
; Looking for a replacement for:
%0:i32 = var
%1:i1 = eq 0:i32, %0
infer %1
"
; No valid RHS in the list
#########################################################

Module before replacement:
; ModuleID = './Welchs_t-test.c.bc'
source_filename = "./Welchs_t-test.c"
target datalayout = "e-m:e-p:32:32-i64:64-n32:64-S128"
target triple = "wasm32-unknown-wasi"

@.str = private unnamed_addr constant [63 x i8] c"Got a non-finite number in 1st array, can't calculate P-value.\00", align 1
@.str.1 = private unnamed_addr constant [63 x i8] c"Got a non-finite number in 2nd array, can't calculate P-value.\00", align 1
@__const.main.d1 = private unnamed_addr constant [15 x double] [double 2.750000e+01, double 2.100000e+01, double 1.900000e+01, double 2.360000e+01, double 1.700000e+01, double 1.790000e+01, double 1.690000e+01, double 2.010000e+01, double 2.190000e+01, double 2.260000e+01, double 2.310000e+01, double 1.960000e+01, double 1.900000e+01, double 2.170000e+01, double 2.140000e+01], align 16
@__const.main.d2 = private unnamed_addr constant [15 x double] [double 2.710000e+01, double 2.200000e+01, double 2.080000e+01, double 2.340000e+01, double 2.340000e+01, double 2.350000e+01, double 2.580000e+01, double 2.200000e+01, double 2.480000e+01, double 2.020000e+01, double 2.190000e+01, double 2.210000e+01, double 2.290000e+01, double 2.050000e+01, double 2.440000e+01], align 16
@__const.main.d3 = private unnamed_addr constant [10 x double] [double 1.720000e+01, double 2.090000e+01, double 2.260000e+01, double 1.810000e+01, double 2.170000e+01, double 2.140000e+01, double 2.350000e+01, double 2.420000e+01, double 1.470000e+01, double 2.180000e+01], align 16
@__const.main.d4 = private unnamed_addr constant [20 x double] [double 2.150000e+01, double 2.280000e+01, double 2.100000e+01, double 2.300000e+01, double 2.160000e+01, double 2.360000e+01, double 2.250000e+01, double 2.070000e+01, double 2.340000e+01, double 2.180000e+01, double 2.070000e+01, double 2.170000e+01, double 2.150000e+01, double 2.250000e+01, double 2.360000e+01, double 2.150000e+01, double 2.250000e+01, double 2.350000e+01, double 2.150000e+01, double 2.180000e+01], align 16
@__const.main.d5 = private unnamed_addr constant [10 x double] [double 1.980000e+01, double 2.040000e+01, double 1.960000e+01, double 1.780000e+01, double 1.850000e+01, double 1.890000e+01, double 1.830000e+01, double 1.890000e+01, double 1.950000e+01, double 2.200000e+01], align 16
@__const.main.d6 = private unnamed_addr constant [20 x double] [double 2.820000e+01, double 2.660000e+01, double 2.010000e+01, double 2.330000e+01, double 2.520000e+01, double 2.210000e+01, double 1.770000e+01, double 2.760000e+01, double 2.060000e+01, double 1.370000e+01, double 2.320000e+01, double 1.750000e+01, double 2.060000e+01, double 1.800000e+01, double 2.390000e+01, double 2.160000e+01, double 2.430000e+01, double 2.040000e+01, double 2.400000e+01, double 1.320000e+01], align 16
@__const.main.x = private unnamed_addr constant [4 x double] [double 3.000000e+00, double 4.000000e+00, double 1.000000e+00, double 2.100000e+00], align 16
@__const.main.y = private unnamed_addr constant [3 x double] [double 4.902000e+02, double 3.400000e+02, double 4.339000e+02], align 16
@__const.main.v1 = private unnamed_addr constant [3 x double] [double 1.026800e-02, double 1.670000e-04, double 1.670000e-04], align 16
@__const.main.v2 = private unnamed_addr constant [3 x double] [double 1.592580e-01, double 1.362780e-01, double 1.223890e-01], align 16
@__const.main.s1 = private unnamed_addr constant [2 x double] [double 0x3FB1111111111111, double 0x3FC4A5294A5294A5], align 16
@__const.main.s2 = private unnamed_addr constant [2 x double] [double 1.000000e-01, double 4.000000e-02], align 16
@__const.main.z1 = private unnamed_addr constant [3 x double] [double 0x3FD90B21642C8591, double 0x3FDDDDDDDDDDDDDE, double 0.000000e+00], align 16
@__const.main.z2 = private unnamed_addr constant [3 x double] [double 0.000000e+00, double 0x3FDC9882B9310572, double 0.000000e+00], align 16
@__const.main.CORRECT_ANSWERS = private unnamed_addr constant [8 x double] [double 0x3F95E41D648C236F, double 0x3FC30D3EA599BB79, double 0x3FA26AF51F458AEB, double 0x3FB73CEBAB27FA12, double 0x3F8604EA1C27764A, double 0x3F6BD85EAF35CBC8, double 0x3FE0DF5C6BE20DA6, double 0x3FE172D38028625E], align 16
@.str.2 = private unnamed_addr constant [26 x i8] c"Test sets 1 p-value = %g\0A\00", align 1
@.str.3 = private unnamed_addr constant [26 x i8] c"Test sets 2 p-value = %g\0A\00", align 1
@.str.4 = private unnamed_addr constant [26 x i8] c"Test sets 3 p-value = %g\0A\00", align 1
@.str.5 = private unnamed_addr constant [26 x i8] c"Test sets 4 p-value = %g\0A\00", align 1
@.str.6 = private unnamed_addr constant [26 x i8] c"Test sets 5 p-value = %g\0A\00", align 1
@.str.7 = private unnamed_addr constant [26 x i8] c"Test sets 6 p-value = %g\0A\00", align 1
@.str.8 = private unnamed_addr constant [26 x i8] c"Test sets 7 p-value = %g\0A\00", align 1
@.str.9 = private unnamed_addr constant [26 x i8] c"Test sets z p-value = %g\0A\00", align 1
@.str.10 = private unnamed_addr constant [28 x i8] c"the cumulative error is %g\0A\00", align 1
@llvm.used = appending global [1 x i8*] [i8* bitcast (i32 ()* @__main_void to i8*)], section "llvm.metadata"

@__main_void = alias i32 (), i32 ()* @main

; Function Attrs: noinline nounwind optnone
define hidden double @Pvalue(double* noalias %ARRAY1, i32 %ARRAY1_SIZE, double* noalias %ARRAY2, i32 %ARRAY2_SIZE) #0 {
entry:
  %retval = alloca double, align 8
  %ARRAY1.addr = alloca double*, align 4
  %ARRAY1_SIZE.addr = alloca i32, align 4
  %ARRAY2.addr = alloca double*, align 4
  %ARRAY2_SIZE.addr = alloca i32, align 4
  %fmean1 = alloca double, align 8
  %fmean2 = alloca double, align 8
  %x = alloca i32, align 4
  %x9 = alloca i32, align 4
  %unbiased_sample_variance1 = alloca double, align 8
  %unbiased_sample_variance2 = alloca double, align 8
  %x32 = alloca i32, align 4
  %x44 = alloca i32, align 4
  %WELCH_T_STATISTIC = alloca double, align 8
  %DEGREES_OF_FREEDOM = alloca double, align 8
  %a = alloca double, align 8
  %value = alloca double, align 8
  %beta = alloca double, align 8
  %acu = alloca double, align 8
  %ai = alloca double, align 8
  %cx = alloca double, align 8
  %indx = alloca i32, align 4
  %ns = alloca i32, align 4
  %pp = alloca double, align 8
  %psq = alloca double, align 8
  %qq = alloca double, align 8
  %rx = alloca double, align 8
  %temp = alloca double, align 8
  %term = alloca double, align 8
  %xx = alloca double, align 8
  store double* %ARRAY1, double** %ARRAY1.addr, align 4
  store i32 %ARRAY1_SIZE, i32* %ARRAY1_SIZE.addr, align 4
  store double* %ARRAY2, double** %ARRAY2.addr, align 4
  store i32 %ARRAY2_SIZE, i32* %ARRAY2_SIZE.addr, align 4
  %0 = load i32, i32* %ARRAY1_SIZE.addr, align 4
  %cmp = icmp ule i32 %0, 1
  br i1 %cmp, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  store double 1.000000e+00, double* %retval, align 8
  br label %return

if.else:                                          ; preds = %entry
  %1 = load i32, i32* %ARRAY2_SIZE.addr, align 4
  %cmp1 = icmp ule i32 %1, 1
  br i1 %cmp1, label %if.then2, label %if.end

if.then2:                                         ; preds = %if.else
  store double 1.000000e+00, double* %retval, align 8
  br label %return

if.end:                                           ; preds = %if.else
  br label %if.end3

if.end3:                                          ; preds = %if.end
  store double 0.000000e+00, double* %fmean1, align 8
  store double 0.000000e+00, double* %fmean2, align 8
  store i32 0, i32* %x, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.end3
  %2 = load i32, i32* %x, align 4
  %3 = load i32, i32* %ARRAY1_SIZE.addr, align 4
  %cmp4 = icmp ult i32 %2, %3
  br i1 %cmp4, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %4 = load double*, double** %ARRAY1.addr, align 4
  %5 = load i32, i32* %x, align 4
  %arrayidx = getelementptr inbounds double, double* %4, i32 %5
  %6 = load double, double* %arrayidx, align 8
  %7 = call double @llvm.fabs.f64(double %6) #7
  %cmpinf = fcmp one double %7, 0x7FF0000000000000
  %8 = zext i1 %cmpinf to i32
  %cmp5 = icmp eq i32 %8, 0
  br i1 %cmp5, label %if.then6, label %if.end7

if.then6:                                         ; preds = %for.body
  %call = call i32 @puts(i8* getelementptr inbounds ([63 x i8], [63 x i8]* @.str, i32 0, i32 0))
  call void @exit(i32 1) #8
  unreachable

if.end7:                                          ; preds = %for.body
  %9 = load double*, double** %ARRAY1.addr, align 4
  %10 = load i32, i32* %x, align 4
  %arrayidx8 = getelementptr inbounds double, double* %9, i32 %10
  %11 = load double, double* %arrayidx8, align 8
  %12 = load double, double* %fmean1, align 8
  %add = fadd double %12, %11
  store double %add, double* %fmean1, align 8
  br label %for.inc

for.inc:                                          ; preds = %if.end7
  %13 = load i32, i32* %x, align 4
  %inc = add i32 %13, 1
  store i32 %inc, i32* %x, align 4
  br label %for.cond

for.end:                                          ; preds = %for.cond
  %14 = load i32, i32* %ARRAY1_SIZE.addr, align 4
  %conv = uitofp i32 %14 to double
  %15 = load double, double* %fmean1, align 8
  %div = fdiv double %15, %conv
  store double %div, double* %fmean1, align 8
  store i32 0, i32* %x9, align 4
  br label %for.cond10

for.cond10:                                       ; preds = %for.inc23, %for.end
  %16 = load i32, i32* %x9, align 4
  %17 = load i32, i32* %ARRAY2_SIZE.addr, align 4
  %cmp11 = icmp ult i32 %16, %17
  br i1 %cmp11, label %for.body13, label %for.end25

for.body13:                                       ; preds = %for.cond10
  %18 = load double*, double** %ARRAY2.addr, align 4
  %19 = load i32, i32* %x9, align 4
  %arrayidx14 = getelementptr inbounds double, double* %18, i32 %19
  %20 = load double, double* %arrayidx14, align 8
  %21 = call double @llvm.fabs.f64(double %20) #7
  %cmpinf15 = fcmp one double %21, 0x7FF0000000000000
  %22 = zext i1 %cmpinf15 to i32
  %cmp16 = icmp eq i32 %22, 0
  br i1 %cmp16, label %if.then18, label %if.end20

if.then18:                                        ; preds = %for.body13
  %call19 = call i32 @puts(i8* getelementptr inbounds ([63 x i8], [63 x i8]* @.str.1, i32 0, i32 0))
  call void @exit(i32 1) #8
  unreachable

if.end20:                                         ; preds = %for.body13
  %23 = load double*, double** %ARRAY2.addr, align 4
  %24 = load i32, i32* %x9, align 4
  %arrayidx21 = getelementptr inbounds double, double* %23, i32 %24
  %25 = load double, double* %arrayidx21, align 8
  %26 = load double, double* %fmean2, align 8
  %add22 = fadd double %26, %25
  store double %add22, double* %fmean2, align 8
  br label %for.inc23

for.inc23:                                        ; preds = %if.end20
  %27 = load i32, i32* %x9, align 4
  %inc24 = add i32 %27, 1
  store i32 %inc24, i32* %x9, align 4
  br label %for.cond10

for.end25:                                        ; preds = %for.cond10
  %28 = load i32, i32* %ARRAY2_SIZE.addr, align 4
  %conv26 = uitofp i32 %28 to double
  %29 = load double, double* %fmean2, align 8
  %div27 = fdiv double %29, %conv26
  store double %div27, double* %fmean2, align 8
  %30 = load double, double* %fmean1, align 8
  %31 = load double, double* %fmean2, align 8
  %cmp28 = fcmp oeq double %30, %31
  br i1 %cmp28, label %if.then30, label %if.end31

if.then30:                                        ; preds = %for.end25
  store double 1.000000e+00, double* %retval, align 8
  br label %return

if.end31:                                         ; preds = %for.end25
  store double 0.000000e+00, double* %unbiased_sample_variance1, align 8
  store double 0.000000e+00, double* %unbiased_sample_variance2, align 8
  store i32 0, i32* %x32, align 4
  br label %for.cond33

for.cond33:                                       ; preds = %for.inc41, %if.end31
  %32 = load i32, i32* %x32, align 4
  %33 = load i32, i32* %ARRAY1_SIZE.addr, align 4
  %cmp34 = icmp ult i32 %32, %33
  br i1 %cmp34, label %for.body36, label %for.end43

for.body36:                                       ; preds = %for.cond33
  %34 = load double*, double** %ARRAY1.addr, align 4
  %35 = load i32, i32* %x32, align 4
  %arrayidx37 = getelementptr inbounds double, double* %34, i32 %35
  %36 = load double, double* %arrayidx37, align 8
  %37 = load double, double* %fmean1, align 8
  %sub = fsub double %36, %37
  %38 = load double*, double** %ARRAY1.addr, align 4
  %39 = load i32, i32* %x32, align 4
  %arrayidx38 = getelementptr inbounds double, double* %38, i32 %39
  %40 = load double, double* %arrayidx38, align 8
  %41 = load double, double* %fmean1, align 8
  %sub39 = fsub double %40, %41
  %mul = fmul double %sub, %sub39
  %42 = load double, double* %unbiased_sample_variance1, align 8
  %add40 = fadd double %42, %mul
  store double %add40, double* %unbiased_sample_variance1, align 8
  br label %for.inc41

for.inc41:                                        ; preds = %for.body36
  %43 = load i32, i32* %x32, align 4
  %inc42 = add i32 %43, 1
  store i32 %inc42, i32* %x32, align 4
  br label %for.cond33

for.end43:                                        ; preds = %for.cond33
  store i32 0, i32* %x44, align 4
  br label %for.cond45

for.cond45:                                       ; preds = %for.inc55, %for.end43
  %44 = load i32, i32* %x44, align 4
  %45 = load i32, i32* %ARRAY2_SIZE.addr, align 4
  %cmp46 = icmp ult i32 %44, %45
  br i1 %cmp46, label %for.body48, label %for.end57

for.body48:                                       ; preds = %for.cond45
  %46 = load double*, double** %ARRAY2.addr, align 4
  %47 = load i32, i32* %x44, align 4
  %arrayidx49 = getelementptr inbounds double, double* %46, i32 %47
  %48 = load double, double* %arrayidx49, align 8
  %49 = load double, double* %fmean2, align 8
  %sub50 = fsub double %48, %49
  %50 = load double*, double** %ARRAY2.addr, align 4
  %51 = load i32, i32* %x44, align 4
  %arrayidx51 = getelementptr inbounds double, double* %50, i32 %51
  %52 = load double, double* %arrayidx51, align 8
  %53 = load double, double* %fmean2, align 8
  %sub52 = fsub double %52, %53
  %mul53 = fmul double %sub50, %sub52
  %54 = load double, double* %unbiased_sample_variance2, align 8
  %add54 = fadd double %54, %mul53
  store double %add54, double* %unbiased_sample_variance2, align 8
  br label %for.inc55

for.inc55:                                        ; preds = %for.body48
  %55 = load i32, i32* %x44, align 4
  %inc56 = add i32 %55, 1
  store i32 %inc56, i32* %x44, align 4
  br label %for.cond45

for.end57:                                        ; preds = %for.cond45
  %56 = load double, double* %unbiased_sample_variance1, align 8
  %57 = load i32, i32* %ARRAY1_SIZE.addr, align 4
  %sub58 = sub i32 %57, 1
  %conv59 = uitofp i32 %sub58 to double
  %div60 = fdiv double %56, %conv59
  store double %div60, double* %unbiased_sample_variance1, align 8
  %58 = load double, double* %unbiased_sample_variance2, align 8
  %59 = load i32, i32* %ARRAY2_SIZE.addr, align 4
  %sub61 = sub i32 %59, 1
  %conv62 = uitofp i32 %sub61 to double
  %div63 = fdiv double %58, %conv62
  store double %div63, double* %unbiased_sample_variance2, align 8
  %60 = load double, double* %fmean1, align 8
  %61 = load double, double* %fmean2, align 8
  %sub64 = fsub double %60, %61
  %62 = load double, double* %unbiased_sample_variance1, align 8
  %63 = load i32, i32* %ARRAY1_SIZE.addr, align 4
  %conv65 = uitofp i32 %63 to double
  %div66 = fdiv double %62, %conv65
  %64 = load double, double* %unbiased_sample_variance2, align 8
  %65 = load i32, i32* %ARRAY2_SIZE.addr, align 4
  %conv67 = uitofp i32 %65 to double
  %div68 = fdiv double %64, %conv67
  %add69 = fadd double %div66, %div68
  %66 = call double @llvm.sqrt.f64(double %add69)
  %div70 = fdiv double %sub64, %66
  store double %div70, double* %WELCH_T_STATISTIC, align 8
  %67 = load double, double* %unbiased_sample_variance1, align 8
  %68 = load i32, i32* %ARRAY1_SIZE.addr, align 4
  %conv71 = uitofp i32 %68 to double
  %div72 = fdiv double %67, %conv71
  %69 = load double, double* %unbiased_sample_variance2, align 8
  %70 = load i32, i32* %ARRAY2_SIZE.addr, align 4
  %conv73 = uitofp i32 %70 to double
  %div74 = fdiv double %69, %conv73
  %add75 = fadd double %div72, %div74
  %71 = call double @llvm.pow.f64(double %add75, double 2.000000e+00)
  %72 = load double, double* %unbiased_sample_variance1, align 8
  %73 = load double, double* %unbiased_sample_variance1, align 8
  %mul76 = fmul double %72, %73
  %74 = load i32, i32* %ARRAY1_SIZE.addr, align 4
  %75 = load i32, i32* %ARRAY1_SIZE.addr, align 4
  %mul77 = mul i32 %74, %75
  %76 = load i32, i32* %ARRAY1_SIZE.addr, align 4
  %sub78 = sub i32 %76, 1
  %mul79 = mul i32 %mul77, %sub78
  %conv80 = uitofp i32 %mul79 to double
  %div81 = fdiv double %mul76, %conv80
  %77 = load double, double* %unbiased_sample_variance2, align 8
  %78 = load double, double* %unbiased_sample_variance2, align 8
  %mul82 = fmul double %77, %78
  %79 = load i32, i32* %ARRAY2_SIZE.addr, align 4
  %80 = load i32, i32* %ARRAY2_SIZE.addr, align 4
  %mul83 = mul i32 %79, %80
  %81 = load i32, i32* %ARRAY2_SIZE.addr, align 4
  %sub84 = sub i32 %81, 1
  %mul85 = mul i32 %mul83, %sub84
  %conv86 = uitofp i32 %mul85 to double
  %div87 = fdiv double %mul82, %conv86
  %add88 = fadd double %div81, %div87
  %div89 = fdiv double %71, %add88
  store double %div89, double* %DEGREES_OF_FREEDOM, align 8
  %82 = load double, double* %DEGREES_OF_FREEDOM, align 8
  %div90 = fdiv double %82, 2.000000e+00
  store double %div90, double* %a, align 8
  %83 = load double, double* %DEGREES_OF_FREEDOM, align 8
  %84 = load double, double* %WELCH_T_STATISTIC, align 8
  %85 = load double, double* %WELCH_T_STATISTIC, align 8
  %mul91 = fmul double %84, %85
  %86 = load double, double* %DEGREES_OF_FREEDOM, align 8
  %add92 = fadd double %mul91, %86
  %div93 = fdiv double %83, %add92
  store double %div93, double* %value, align 8
  %87 = load double, double* %value, align 8
  %88 = call double @llvm.fabs.f64(double %87) #7
  %cmpinf94 = fcmp oeq double %88, 0x7FF0000000000000
  br i1 %cmpinf94, label %if.then100, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %for.end57
  %89 = load double, double* %value, align 8
  %cmp97 = fcmp uno double %89, %89
  br i1 %cmp97, label %if.then100, label %if.end101

if.then100:                                       ; preds = %lor.lhs.false, %for.end57
  store double 1.000000e+00, double* %retval, align 8
  br label %return

if.end101:                                        ; preds = %lor.lhs.false
  %90 = load double, double* %value, align 8
  %91 = call double @llvm.fabs.f64(double %90) #7
  %cmpinf102 = fcmp oeq double %91, 0x7FF0000000000000
  br i1 %cmpinf102, label %if.then109, label %lor.lhs.false105

lor.lhs.false105:                                 ; preds = %if.end101
  %92 = load double, double* %value, align 8
  %cmp106 = fcmp uno double %92, %92
  %93 = zext i1 %cmp106 to i32
  %cmp107 = icmp ne i32 %93, 0
  br i1 %cmp107, label %if.then109, label %if.end110

if.then109:                                       ; preds = %lor.lhs.false105, %if.end101
  store double 1.000000e+00, double* %retval, align 8
  br label %return

if.end110:                                        ; preds = %lor.lhs.false105
  %94 = load double, double* %a, align 8
  %conv111 = fpext double %94 to fp128
  %call112 = call fp128 @lgammal(fp128 %conv111) #9
  %add113 = fadd fp128 %call112, 0xLD0000000000000003FFE250D048E7A1B
  %95 = load double, double* %a, align 8
  %add114 = fadd double %95, 5.000000e-01
  %conv115 = fpext double %add114 to fp128
  %call116 = call fp128 @lgammal(fp128 %conv115) #9
  %sub117 = fsub fp128 %add113, %call116
  %conv118 = fptrunc fp128 %sub117 to double
  store double %conv118, double* %beta, align 8
  store double 1.000000e-15, double* %acu, align 8
  %96 = load double, double* %a, align 8
  %cmp119 = fcmp ole double %96, 0.000000e+00
  br i1 %cmp119, label %if.then121, label %if.end122

if.then121:                                       ; preds = %if.end110
  br label %if.end122

if.end122:                                        ; preds = %if.then121, %if.end110
  %97 = load double, double* %value, align 8
  %cmp123 = fcmp olt double %97, 0.000000e+00
  br i1 %cmp123, label %if.then128, label %lor.lhs.false125

lor.lhs.false125:                                 ; preds = %if.end122
  %98 = load double, double* %value, align 8
  %cmp126 = fcmp olt double 1.000000e+00, %98
  br i1 %cmp126, label %if.then128, label %if.end129

if.then128:                                       ; preds = %lor.lhs.false125, %if.end122
  %99 = load double, double* %value, align 8
  store double %99, double* %retval, align 8
  br label %return

if.end129:                                        ; preds = %lor.lhs.false125
  %100 = load double, double* %value, align 8
  %cmp130 = fcmp oeq double %100, 0.000000e+00
  br i1 %cmp130, label %if.then135, label %lor.lhs.false132

lor.lhs.false132:                                 ; preds = %if.end129
  %101 = load double, double* %value, align 8
  %cmp133 = fcmp oeq double %101, 1.000000e+00
  br i1 %cmp133, label %if.then135, label %if.end136

if.then135:                                       ; preds = %lor.lhs.false132, %if.end129
  %102 = load double, double* %value, align 8
  store double %102, double* %retval, align 8
  br label %return

if.end136:                                        ; preds = %lor.lhs.false132
  %103 = load double, double* %a, align 8
  %add137 = fadd double %103, 5.000000e-01
  store double %add137, double* %psq, align 8
  %104 = load double, double* %value, align 8
  %sub138 = fsub double 1.000000e+00, %104
  store double %sub138, double* %cx, align 8
  %105 = load double, double* %a, align 8
  %106 = load double, double* %psq, align 8
  %107 = load double, double* %value, align 8
  %mul139 = fmul double %106, %107
  %cmp140 = fcmp olt double %105, %mul139
  br i1 %cmp140, label %if.then142, label %if.else143

if.then142:                                       ; preds = %if.end136
  %108 = load double, double* %cx, align 8
  store double %108, double* %xx, align 8
  %109 = load double, double* %value, align 8
  store double %109, double* %cx, align 8
  store double 5.000000e-01, double* %pp, align 8
  %110 = load double, double* %a, align 8
  store double %110, double* %qq, align 8
  store i32 1, i32* %indx, align 4
  br label %if.end144

if.else143:                                       ; preds = %if.end136
  %111 = load double, double* %value, align 8
  store double %111, double* %xx, align 8
  %112 = load double, double* %a, align 8
  store double %112, double* %pp, align 8
  store double 5.000000e-01, double* %qq, align 8
  store i32 0, i32* %indx, align 4
  br label %if.end144

if.end144:                                        ; preds = %if.else143, %if.then142
  store double 1.000000e+00, double* %term, align 8
  store double 1.000000e+00, double* %ai, align 8
  store double 1.000000e+00, double* %value, align 8
  %113 = load double, double* %qq, align 8
  %114 = load double, double* %cx, align 8
  %115 = load double, double* %psq, align 8
  %mul145 = fmul double %114, %115
  %add146 = fadd double %113, %mul145
  %conv147 = fptosi double %add146 to i32
  store i32 %conv147, i32* %ns, align 4
  %116 = load double, double* %xx, align 8
  %117 = load double, double* %cx, align 8
  %div148 = fdiv double %116, %117
  store double %div148, double* %rx, align 8
  %118 = load double, double* %qq, align 8
  %119 = load double, double* %ai, align 8
  %sub149 = fsub double %118, %119
  store double %sub149, double* %temp, align 8
  %120 = load i32, i32* %ns, align 4
  %cmp150 = icmp eq i32 %120, 0
  br i1 %cmp150, label %if.then152, label %if.end153

if.then152:                                       ; preds = %if.end144
  %121 = load double, double* %xx, align 8
  store double %121, double* %rx, align 8
  br label %if.end153

if.end153:                                        ; preds = %if.then152, %if.end144
  br label %for.cond154

for.cond154:                                      ; preds = %if.end189, %if.end153
  %122 = load double, double* %term, align 8
  %123 = load double, double* %temp, align 8
  %mul155 = fmul double %122, %123
  %124 = load double, double* %rx, align 8
  %mul156 = fmul double %mul155, %124
  %125 = load double, double* %pp, align 8
  %126 = load double, double* %ai, align 8
  %add157 = fadd double %125, %126
  %div158 = fdiv double %mul156, %add157
  store double %div158, double* %term, align 8
  %127 = load double, double* %value, align 8
  %128 = load double, double* %term, align 8
  %add159 = fadd double %127, %128
  store double %add159, double* %value, align 8
  %129 = load double, double* %term, align 8
  %130 = call double @llvm.fabs.f64(double %129)
  store double %130, double* %temp, align 8
  %131 = load double, double* %temp, align 8
  %cmp160 = fcmp ole double %131, 1.000000e-15
  br i1 %cmp160, label %land.lhs.true, label %if.end176

land.lhs.true:                                    ; preds = %for.cond154
  %132 = load double, double* %temp, align 8
  %133 = load double, double* %value, align 8
  %mul162 = fmul double 1.000000e-15, %133
  %cmp163 = fcmp ole double %132, %mul162
  br i1 %cmp163, label %if.then165, label %if.end176

if.then165:                                       ; preds = %land.lhs.true
  %134 = load double, double* %value, align 8
  %135 = load double, double* %pp, align 8
  %136 = load double, double* %xx, align 8
  %137 = call double @llvm.log.f64(double %136)
  %mul166 = fmul double %135, %137
  %138 = load double, double* %qq, align 8
  %sub167 = fsub double %138, 1.000000e+00
  %139 = load double, double* %cx, align 8
  %140 = call double @llvm.log.f64(double %139)
  %mul168 = fmul double %sub167, %140
  %add169 = fadd double %mul166, %mul168
  %141 = load double, double* %beta, align 8
  %sub170 = fsub double %add169, %141
  %142 = call double @llvm.exp.f64(double %sub170)
  %mul171 = fmul double %134, %142
  %143 = load double, double* %pp, align 8
  %div172 = fdiv double %mul171, %143
  store double %div172, double* %value, align 8
  %144 = load i32, i32* %indx, align 4
  %tobool = icmp ne i32 %144, 0
  br i1 %tobool, label %if.then173, label %if.end175

if.then173:                                       ; preds = %if.then165
  %145 = load double, double* %value, align 8
  %sub174 = fsub double 1.000000e+00, %145
  store double %sub174, double* %value, align 8
  br label %if.end175

if.end175:                                        ; preds = %if.then173, %if.then165
  br label %for.end190

if.end176:                                        ; preds = %land.lhs.true, %for.cond154
  %146 = load double, double* %ai, align 8
  %add177 = fadd double %146, 1.000000e+00
  store double %add177, double* %ai, align 8
  %147 = load i32, i32* %ns, align 4
  %sub178 = sub nsw i32 %147, 1
  store i32 %sub178, i32* %ns, align 4
  %148 = load i32, i32* %ns, align 4
  %cmp179 = icmp sle i32 0, %148
  br i1 %cmp179, label %if.then181, label %if.else187

if.then181:                                       ; preds = %if.end176
  %149 = load double, double* %qq, align 8
  %150 = load double, double* %ai, align 8
  %sub182 = fsub double %149, %150
  store double %sub182, double* %temp, align 8
  %151 = load i32, i32* %ns, align 4
  %cmp183 = icmp eq i32 %151, 0
  br i1 %cmp183, label %if.then185, label %if.end186

if.then185:                                       ; preds = %if.then181
  %152 = load double, double* %xx, align 8
  store double %152, double* %rx, align 8
  br label %if.end186

if.end186:                                        ; preds = %if.then185, %if.then181
  br label %if.end189

if.else187:                                       ; preds = %if.end176
  %153 = load double, double* %psq, align 8
  store double %153, double* %temp, align 8
  %154 = load double, double* %psq, align 8
  %add188 = fadd double %154, 1.000000e+00
  store double %add188, double* %psq, align 8
  br label %if.end189

if.end189:                                        ; preds = %if.else187, %if.end186
  br label %for.cond154

for.end190:                                       ; preds = %if.end175
  %155 = load double, double* %value, align 8
  store double %155, double* %retval, align 8
  br label %return

return:                                           ; preds = %for.end190, %if.then135, %if.then128, %if.then109, %if.then100, %if.then30, %if.then2, %if.then
  %156 = load double, double* %retval, align 8
  ret double %156
}

; Function Attrs: nounwind readnone speculatable willreturn
declare double @llvm.fabs.f64(double %0) #1

declare i32 @puts(i8* %0) #2

; Function Attrs: noreturn
declare void @exit(i32 %0) #3

; Function Attrs: nounwind readnone speculatable willreturn
declare double @llvm.sqrt.f64(double %0) #1

; Function Attrs: nounwind readnone speculatable willreturn
declare double @llvm.pow.f64(double %0, double %1) #1

; Function Attrs: nounwind
declare fp128 @lgammal(fp128 %0) #4

; Function Attrs: nounwind readnone speculatable willreturn
declare double @llvm.log.f64(double %0) #1

; Function Attrs: nounwind readnone speculatable willreturn
declare double @llvm.exp.f64(double %0) #1

; Function Attrs: noinline nounwind optnone
define hidden i32 @main() #0 {
entry:
  %retval = alloca i32, align 4
  %d1 = alloca [15 x double], align 16
  %d2 = alloca [15 x double], align 16
  %d3 = alloca [10 x double], align 16
  %d4 = alloca [20 x double], align 16
  %d5 = alloca [10 x double], align 16
  %d6 = alloca [20 x double], align 16
  %d7 = alloca [6 x double], align 16
  %d8 = alloca [6 x double], align 16
  %x = alloca [4 x double], align 16
  %y = alloca [3 x double], align 16
  %v1 = alloca [3 x double], align 16
  %v2 = alloca [3 x double], align 16
  %s1 = alloca [2 x double], align 16
  %s2 = alloca [2 x double], align 16
  %z1 = alloca [3 x double], align 16
  %z2 = alloca [3 x double], align 16
  %CORRECT_ANSWERS = alloca [8 x double], align 16
  %pvalue = alloca double, align 8
  %error = alloca double, align 8
  store i32 0, i32* %retval, align 4
  %0 = bitcast [15 x double]* %d1 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 16 %0, i8* align 16 bitcast ([15 x double]* @__const.main.d1 to i8*), i32 120, i1 false)
  %1 = bitcast [15 x double]* %d2 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 16 %1, i8* align 16 bitcast ([15 x double]* @__const.main.d2 to i8*), i32 120, i1 false)
  %2 = bitcast [10 x double]* %d3 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 16 %2, i8* align 16 bitcast ([10 x double]* @__const.main.d3 to i8*), i32 80, i1 false)
  %3 = bitcast [20 x double]* %d4 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 16 %3, i8* align 16 bitcast ([20 x double]* @__const.main.d4 to i8*), i32 160, i1 false)
  %4 = bitcast [10 x double]* %d5 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 16 %4, i8* align 16 bitcast ([10 x double]* @__const.main.d5 to i8*), i32 80, i1 false)
  %5 = bitcast [20 x double]* %d6 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 16 %5, i8* align 16 bitcast ([20 x double]* @__const.main.d6 to i8*), i32 160, i1 false)
  %6 = bitcast [6 x double]* %d7 to i8*
  call void @llvm.memset.p0i8.i32(i8* align 16 %6, i8 0, i32 48, i1 false)
  %7 = bitcast i8* %6 to [6 x double]*
  %8 = getelementptr inbounds [6 x double], [6 x double]* %7, i32 0, i32 0
  store double 3.002000e+01, double* %8, align 16
  %9 = getelementptr inbounds [6 x double], [6 x double]* %7, i32 0, i32 1
  store double 2.999000e+01, double* %9, align 8
  %10 = getelementptr inbounds [6 x double], [6 x double]* %7, i32 0, i32 2
  store double 3.011000e+01, double* %10, align 16
  %11 = getelementptr inbounds [6 x double], [6 x double]* %7, i32 0, i32 3
  store double 2.997000e+01, double* %11, align 8
  %12 = getelementptr inbounds [6 x double], [6 x double]* %7, i32 0, i32 4
  store double 3.001000e+01, double* %12, align 16
  %13 = getelementptr inbounds [6 x double], [6 x double]* %7, i32 0, i32 5
  store double 2.999000e+01, double* %13, align 8
  %14 = bitcast [6 x double]* %d8 to i8*
  call void @llvm.memset.p0i8.i32(i8* align 16 %14, i8 0, i32 48, i1 false)
  %15 = bitcast i8* %14 to [6 x double]*
  %16 = getelementptr inbounds [6 x double], [6 x double]* %15, i32 0, i32 0
  store double 2.989000e+01, double* %16, align 16
  %17 = getelementptr inbounds [6 x double], [6 x double]* %15, i32 0, i32 1
  store double 2.993000e+01, double* %17, align 8
  %18 = getelementptr inbounds [6 x double], [6 x double]* %15, i32 0, i32 2
  store double 2.972000e+01, double* %18, align 16
  %19 = getelementptr inbounds [6 x double], [6 x double]* %15, i32 0, i32 3
  store double 2.998000e+01, double* %19, align 8
  %20 = getelementptr inbounds [6 x double], [6 x double]* %15, i32 0, i32 4
  store double 3.002000e+01, double* %20, align 16
  %21 = getelementptr inbounds [6 x double], [6 x double]* %15, i32 0, i32 5
  store double 2.998000e+01, double* %21, align 8
  %22 = bitcast [4 x double]* %x to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 16 %22, i8* align 16 bitcast ([4 x double]* @__const.main.x to i8*), i32 32, i1 false)
  %23 = bitcast [3 x double]* %y to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 16 %23, i8* align 16 bitcast ([3 x double]* @__const.main.y to i8*), i32 24, i1 false)
  %24 = bitcast [3 x double]* %v1 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 16 %24, i8* align 16 bitcast ([3 x double]* @__const.main.v1 to i8*), i32 24, i1 false)
  %25 = bitcast [3 x double]* %v2 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 16 %25, i8* align 16 bitcast ([3 x double]* @__const.main.v2 to i8*), i32 24, i1 false)
  %26 = bitcast [2 x double]* %s1 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 16 %26, i8* align 16 bitcast ([2 x double]* @__const.main.s1 to i8*), i32 16, i1 false)
  %27 = bitcast [2 x double]* %s2 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 16 %27, i8* align 16 bitcast ([2 x double]* @__const.main.s2 to i8*), i32 16, i1 false)
  %28 = bitcast [3 x double]* %z1 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 16 %28, i8* align 16 bitcast ([3 x double]* @__const.main.z1 to i8*), i32 24, i1 false)
  %29 = bitcast [3 x double]* %z2 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 16 %29, i8* align 16 bitcast ([3 x double]* @__const.main.z2 to i8*), i32 24, i1 false)
  %30 = bitcast [8 x double]* %CORRECT_ANSWERS to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 16 %30, i8* align 16 bitcast ([8 x double]* @__const.main.CORRECT_ANSWERS to i8*), i32 64, i1 false)
  %arraydecay = getelementptr inbounds [15 x double], [15 x double]* %d1, i32 0, i32 0
  %arraydecay1 = getelementptr inbounds [15 x double], [15 x double]* %d2, i32 0, i32 0
  %call = call double @Pvalue(double* %arraydecay, i32 15, double* %arraydecay1, i32 15)
  store double %call, double* %pvalue, align 8
  %31 = load double, double* %pvalue, align 8
  %arrayidx = getelementptr inbounds [8 x double], [8 x double]* %CORRECT_ANSWERS, i32 0, i32 0
  %32 = load double, double* %arrayidx, align 16
  %sub = fsub double %31, %32
  %33 = call double @llvm.fabs.f64(double %sub)
  store double %33, double* %error, align 8
  %34 = load double, double* %pvalue, align 8
  %call2 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([26 x i8], [26 x i8]* @.str.2, i32 0, i32 0), double %34)
  %arraydecay3 = getelementptr inbounds [10 x double], [10 x double]* %d3, i32 0, i32 0
  %arraydecay4 = getelementptr inbounds [20 x double], [20 x double]* %d4, i32 0, i32 0
  %call5 = call double @Pvalue(double* %arraydecay3, i32 10, double* %arraydecay4, i32 20)
  store double %call5, double* %pvalue, align 8
  %35 = load double, double* %pvalue, align 8
  %arrayidx6 = getelementptr inbounds [8 x double], [8 x double]* %CORRECT_ANSWERS, i32 0, i32 1
  %36 = load double, double* %arrayidx6, align 8
  %sub7 = fsub double %35, %36
  %37 = call double @llvm.fabs.f64(double %sub7)
  %38 = load double, double* %error, align 8
  %add = fadd double %38, %37
  store double %add, double* %error, align 8
  %39 = load double, double* %pvalue, align 8
  %call8 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([26 x i8], [26 x i8]* @.str.3, i32 0, i32 0), double %39)
  %arraydecay9 = getelementptr inbounds [10 x double], [10 x double]* %d5, i32 0, i32 0
  %arraydecay10 = getelementptr inbounds [20 x double], [20 x double]* %d6, i32 0, i32 0
  %call11 = call double @Pvalue(double* %arraydecay9, i32 10, double* %arraydecay10, i32 20)
  store double %call11, double* %pvalue, align 8
  %40 = load double, double* %pvalue, align 8
  %arrayidx12 = getelementptr inbounds [8 x double], [8 x double]* %CORRECT_ANSWERS, i32 0, i32 2
  %41 = load double, double* %arrayidx12, align 16
  %sub13 = fsub double %40, %41
  %42 = call double @llvm.fabs.f64(double %sub13)
  %43 = load double, double* %error, align 8
  %add14 = fadd double %43, %42
  store double %add14, double* %error, align 8
  %44 = load double, double* %pvalue, align 8
  %call15 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([26 x i8], [26 x i8]* @.str.4, i32 0, i32 0), double %44)
  %arraydecay16 = getelementptr inbounds [6 x double], [6 x double]* %d7, i32 0, i32 0
  %arraydecay17 = getelementptr inbounds [6 x double], [6 x double]* %d8, i32 0, i32 0
  %call18 = call double @Pvalue(double* %arraydecay16, i32 6, double* %arraydecay17, i32 6)
  store double %call18, double* %pvalue, align 8
  %45 = load double, double* %pvalue, align 8
  %call19 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([26 x i8], [26 x i8]* @.str.5, i32 0, i32 0), double %45)
  %46 = load double, double* %pvalue, align 8
  %arrayidx20 = getelementptr inbounds [8 x double], [8 x double]* %CORRECT_ANSWERS, i32 0, i32 3
  %47 = load double, double* %arrayidx20, align 8
  %sub21 = fsub double %46, %47
  %48 = call double @llvm.fabs.f64(double %sub21)
  %49 = load double, double* %error, align 8
  %add22 = fadd double %49, %48
  store double %add22, double* %error, align 8
  %arraydecay23 = getelementptr inbounds [4 x double], [4 x double]* %x, i32 0, i32 0
  %arraydecay24 = getelementptr inbounds [3 x double], [3 x double]* %y, i32 0, i32 0
  %call25 = call double @Pvalue(double* %arraydecay23, i32 4, double* %arraydecay24, i32 3)
  store double %call25, double* %pvalue, align 8
  %50 = load double, double* %pvalue, align 8
  %arrayidx26 = getelementptr inbounds [8 x double], [8 x double]* %CORRECT_ANSWERS, i32 0, i32 4
  %51 = load double, double* %arrayidx26, align 16
  %sub27 = fsub double %50, %51
  %52 = call double @llvm.fabs.f64(double %sub27)
  %53 = load double, double* %error, align 8
  %add28 = fadd double %53, %52
  store double %add28, double* %error, align 8
  %54 = load double, double* %pvalue, align 8
  %call29 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([26 x i8], [26 x i8]* @.str.6, i32 0, i32 0), double %54)
  %arraydecay30 = getelementptr inbounds [3 x double], [3 x double]* %v1, i32 0, i32 0
  %arraydecay31 = getelementptr inbounds [3 x double], [3 x double]* %v2, i32 0, i32 0
  %call32 = call double @Pvalue(double* %arraydecay30, i32 3, double* %arraydecay31, i32 3)
  store double %call32, double* %pvalue, align 8
  %55 = load double, double* %pvalue, align 8
  %arrayidx33 = getelementptr inbounds [8 x double], [8 x double]* %CORRECT_ANSWERS, i32 0, i32 5
  %56 = load double, double* %arrayidx33, align 8
  %sub34 = fsub double %55, %56
  %57 = call double @llvm.fabs.f64(double %sub34)
  %58 = load double, double* %error, align 8
  %add35 = fadd double %58, %57
  store double %add35, double* %error, align 8
  %59 = load double, double* %pvalue, align 8
  %call36 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([26 x i8], [26 x i8]* @.str.7, i32 0, i32 0), double %59)
  %arraydecay37 = getelementptr inbounds [2 x double], [2 x double]* %s1, i32 0, i32 0
  %arraydecay38 = getelementptr inbounds [2 x double], [2 x double]* %s2, i32 0, i32 0
  %call39 = call double @Pvalue(double* %arraydecay37, i32 2, double* %arraydecay38, i32 2)
  store double %call39, double* %pvalue, align 8
  %60 = load double, double* %pvalue, align 8
  %arrayidx40 = getelementptr inbounds [8 x double], [8 x double]* %CORRECT_ANSWERS, i32 0, i32 6
  %61 = load double, double* %arrayidx40, align 16
  %sub41 = fsub double %60, %61
  %62 = call double @llvm.fabs.f64(double %sub41)
  %63 = load double, double* %error, align 8
  %add42 = fadd double %63, %62
  store double %add42, double* %error, align 8
  %64 = load double, double* %pvalue, align 8
  %call43 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([26 x i8], [26 x i8]* @.str.8, i32 0, i32 0), double %64)
  %arraydecay44 = getelementptr inbounds [3 x double], [3 x double]* %z1, i32 0, i32 0
  %arraydecay45 = getelementptr inbounds [3 x double], [3 x double]* %z2, i32 0, i32 0
  %call46 = call double @Pvalue(double* %arraydecay44, i32 3, double* %arraydecay45, i32 3)
  store double %call46, double* %pvalue, align 8
  %65 = load double, double* %pvalue, align 8
  %arrayidx47 = getelementptr inbounds [8 x double], [8 x double]* %CORRECT_ANSWERS, i32 0, i32 7
  %66 = load double, double* %arrayidx47, align 8
  %sub48 = fsub double %65, %66
  %67 = call double @llvm.fabs.f64(double %sub48)
  %68 = load double, double* %error, align 8
  %add49 = fadd double %68, %67
  store double %add49, double* %error, align 8
  %69 = load double, double* %pvalue, align 8
  %call50 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([26 x i8], [26 x i8]* @.str.9, i32 0, i32 0), double %69)
  %70 = load double, double* %error, align 8
  %call51 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([28 x i8], [28 x i8]* @.str.10, i32 0, i32 0), double %70)
  ret i32 0
}

; Function Attrs: argmemonly nounwind willreturn
declare void @llvm.memcpy.p0i8.p0i8.i32(i8* noalias nocapture writeonly %0, i8* noalias nocapture readonly %1, i32 %2, i1 immarg %3) #5

; Function Attrs: argmemonly nounwind willreturn writeonly
declare void @llvm.memset.p0i8.i32(i8* nocapture writeonly %0, i8 %1, i32 %2, i1 immarg %3) #6

declare i32 @printf(i8* %0, ...) #2

attributes #0 = { noinline nounwind optnone "correctly-rounded-divide-sqrt-fp-math"="false" "disable-tail-calls"="false" "frame-pointer"="none" "less-precise-fpmad"="false" "min-legal-vector-width"="0" "no-infs-fp-math"="false" "no-jump-tables"="false" "no-nans-fp-math"="false" "no-signed-zeros-fp-math"="false" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="generic" "unsafe-fp-math"="false" "use-soft-float"="false" }
attributes #1 = { nounwind readnone speculatable willreturn }
attributes #2 = { "correctly-rounded-divide-sqrt-fp-math"="false" "disable-tail-calls"="false" "frame-pointer"="none" "less-precise-fpmad"="false" "no-infs-fp-math"="false" "no-nans-fp-math"="false" "no-signed-zeros-fp-math"="false" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="generic" "unsafe-fp-math"="false" "use-soft-float"="false" }
attributes #3 = { noreturn "correctly-rounded-divide-sqrt-fp-math"="false" "disable-tail-calls"="false" "frame-pointer"="none" "less-precise-fpmad"="false" "no-infs-fp-math"="false" "no-nans-fp-math"="false" "no-signed-zeros-fp-math"="false" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="generic" "unsafe-fp-math"="false" "use-soft-float"="false" }
attributes #4 = { nounwind "correctly-rounded-divide-sqrt-fp-math"="false" "disable-tail-calls"="false" "frame-pointer"="none" "less-precise-fpmad"="false" "no-infs-fp-math"="false" "no-nans-fp-math"="false" "no-signed-zeros-fp-math"="false" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="generic" "unsafe-fp-math"="false" "use-soft-float"="false" }
attributes #5 = { argmemonly nounwind willreturn }
attributes #6 = { argmemonly nounwind willreturn writeonly }
attributes #7 = { readnone }
attributes #8 = { noreturn }
attributes #9 = { nounwind }

!llvm.module.flags = !{!0}
!llvm.ident = !{!1}

!0 = !{i32 1, !"wchar_size", i32 4}
!1 = !{!"clang version 11.0.0 (https://github.com/Jacarte/llvm-project.git 0f6dea67136cc1e0b3d200eb2bb165628970c44b)"}

; Replacing "  %cmp107 = icmp ne i32 %93, 0"
; from ""
; with "  %cmp106 = fcmp uno double %92, %92" in:
"%0:i1 = var
%1:i32 = zext %0
%2:i1 = ne 0:i32, %1
cand %2 %0
"
; with "  %cmp106 = fcmp uno double %92, %92"

Module after replacement:
; ModuleID = './Welchs_t-test.c.bc'
source_filename = "./Welchs_t-test.c"
target datalayout = "e-m:e-p:32:32-i64:64-n32:64-S128"
target triple = "wasm32-unknown-wasi"

@.str = private unnamed_addr constant [63 x i8] c"Got a non-finite number in 1st array, can't calculate P-value.\00", align 1
@.str.1 = private unnamed_addr constant [63 x i8] c"Got a non-finite number in 2nd array, can't calculate P-value.\00", align 1
@__const.main.d1 = private unnamed_addr constant [15 x double] [double 2.750000e+01, double 2.100000e+01, double 1.900000e+01, double 2.360000e+01, double 1.700000e+01, double 1.790000e+01, double 1.690000e+01, double 2.010000e+01, double 2.190000e+01, double 2.260000e+01, double 2.310000e+01, double 1.960000e+01, double 1.900000e+01, double 2.170000e+01, double 2.140000e+01], align 16
@__const.main.d2 = private unnamed_addr constant [15 x double] [double 2.710000e+01, double 2.200000e+01, double 2.080000e+01, double 2.340000e+01, double 2.340000e+01, double 2.350000e+01, double 2.580000e+01, double 2.200000e+01, double 2.480000e+01, double 2.020000e+01, double 2.190000e+01, double 2.210000e+01, double 2.290000e+01, double 2.050000e+01, double 2.440000e+01], align 16
@__const.main.d3 = private unnamed_addr constant [10 x double] [double 1.720000e+01, double 2.090000e+01, double 2.260000e+01, double 1.810000e+01, double 2.170000e+01, double 2.140000e+01, double 2.350000e+01, double 2.420000e+01, double 1.470000e+01, double 2.180000e+01], align 16
@__const.main.d4 = private unnamed_addr constant [20 x double] [double 2.150000e+01, double 2.280000e+01, double 2.100000e+01, double 2.300000e+01, double 2.160000e+01, double 2.360000e+01, double 2.250000e+01, double 2.070000e+01, double 2.340000e+01, double 2.180000e+01, double 2.070000e+01, double 2.170000e+01, double 2.150000e+01, double 2.250000e+01, double 2.360000e+01, double 2.150000e+01, double 2.250000e+01, double 2.350000e+01, double 2.150000e+01, double 2.180000e+01], align 16
@__const.main.d5 = private unnamed_addr constant [10 x double] [double 1.980000e+01, double 2.040000e+01, double 1.960000e+01, double 1.780000e+01, double 1.850000e+01, double 1.890000e+01, double 1.830000e+01, double 1.890000e+01, double 1.950000e+01, double 2.200000e+01], align 16
@__const.main.d6 = private unnamed_addr constant [20 x double] [double 2.820000e+01, double 2.660000e+01, double 2.010000e+01, double 2.330000e+01, double 2.520000e+01, double 2.210000e+01, double 1.770000e+01, double 2.760000e+01, double 2.060000e+01, double 1.370000e+01, double 2.320000e+01, double 1.750000e+01, double 2.060000e+01, double 1.800000e+01, double 2.390000e+01, double 2.160000e+01, double 2.430000e+01, double 2.040000e+01, double 2.400000e+01, double 1.320000e+01], align 16
@__const.main.x = private unnamed_addr constant [4 x double] [double 3.000000e+00, double 4.000000e+00, double 1.000000e+00, double 2.100000e+00], align 16
@__const.main.y = private unnamed_addr constant [3 x double] [double 4.902000e+02, double 3.400000e+02, double 4.339000e+02], align 16
@__const.main.v1 = private unnamed_addr constant [3 x double] [double 1.026800e-02, double 1.670000e-04, double 1.670000e-04], align 16
@__const.main.v2 = private unnamed_addr constant [3 x double] [double 1.592580e-01, double 1.362780e-01, double 1.223890e-01], align 16
@__const.main.s1 = private unnamed_addr constant [2 x double] [double 0x3FB1111111111111, double 0x3FC4A5294A5294A5], align 16
@__const.main.s2 = private unnamed_addr constant [2 x double] [double 1.000000e-01, double 4.000000e-02], align 16
@__const.main.z1 = private unnamed_addr constant [3 x double] [double 0x3FD90B21642C8591, double 0x3FDDDDDDDDDDDDDE, double 0.000000e+00], align 16
@__const.main.z2 = private unnamed_addr constant [3 x double] [double 0.000000e+00, double 0x3FDC9882B9310572, double 0.000000e+00], align 16
@__const.main.CORRECT_ANSWERS = private unnamed_addr constant [8 x double] [double 0x3F95E41D648C236F, double 0x3FC30D3EA599BB79, double 0x3FA26AF51F458AEB, double 0x3FB73CEBAB27FA12, double 0x3F8604EA1C27764A, double 0x3F6BD85EAF35CBC8, double 0x3FE0DF5C6BE20DA6, double 0x3FE172D38028625E], align 16
@.str.2 = private unnamed_addr constant [26 x i8] c"Test sets 1 p-value = %g\0A\00", align 1
@.str.3 = private unnamed_addr constant [26 x i8] c"Test sets 2 p-value = %g\0A\00", align 1
@.str.4 = private unnamed_addr constant [26 x i8] c"Test sets 3 p-value = %g\0A\00", align 1
@.str.5 = private unnamed_addr constant [26 x i8] c"Test sets 4 p-value = %g\0A\00", align 1
@.str.6 = private unnamed_addr constant [26 x i8] c"Test sets 5 p-value = %g\0A\00", align 1
@.str.7 = private unnamed_addr constant [26 x i8] c"Test sets 6 p-value = %g\0A\00", align 1
@.str.8 = private unnamed_addr constant [26 x i8] c"Test sets 7 p-value = %g\0A\00", align 1
@.str.9 = private unnamed_addr constant [26 x i8] c"Test sets z p-value = %g\0A\00", align 1
@.str.10 = private unnamed_addr constant [28 x i8] c"the cumulative error is %g\0A\00", align 1
@llvm.used = appending global [1 x i8*] [i8* bitcast (i32 ()* @__main_void to i8*)], section "llvm.metadata"

@__main_void = alias i32 (), i32 ()* @main

; Function Attrs: noinline nounwind optnone
define hidden double @Pvalue(double* noalias %ARRAY1, i32 %ARRAY1_SIZE, double* noalias %ARRAY2, i32 %ARRAY2_SIZE) #0 {
entry:
  %retval = alloca double, align 8
  %ARRAY1.addr = alloca double*, align 4
  %ARRAY1_SIZE.addr = alloca i32, align 4
  %ARRAY2.addr = alloca double*, align 4
  %ARRAY2_SIZE.addr = alloca i32, align 4
  %fmean1 = alloca double, align 8
  %fmean2 = alloca double, align 8
  %x = alloca i32, align 4
  %x9 = alloca i32, align 4
  %unbiased_sample_variance1 = alloca double, align 8
  %unbiased_sample_variance2 = alloca double, align 8
  %x32 = alloca i32, align 4
  %x44 = alloca i32, align 4
  %WELCH_T_STATISTIC = alloca double, align 8
  %DEGREES_OF_FREEDOM = alloca double, align 8
  %a = alloca double, align 8
  %value = alloca double, align 8
  %beta = alloca double, align 8
  %acu = alloca double, align 8
  %ai = alloca double, align 8
  %cx = alloca double, align 8
  %indx = alloca i32, align 4
  %ns = alloca i32, align 4
  %pp = alloca double, align 8
  %psq = alloca double, align 8
  %qq = alloca double, align 8
  %rx = alloca double, align 8
  %temp = alloca double, align 8
  %term = alloca double, align 8
  %xx = alloca double, align 8
  store double* %ARRAY1, double** %ARRAY1.addr, align 4
  store i32 %ARRAY1_SIZE, i32* %ARRAY1_SIZE.addr, align 4
  store double* %ARRAY2, double** %ARRAY2.addr, align 4
  store i32 %ARRAY2_SIZE, i32* %ARRAY2_SIZE.addr, align 4
  %0 = load i32, i32* %ARRAY1_SIZE.addr, align 4
  %cmp = icmp ule i32 %0, 1
  br i1 %cmp, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  store double 1.000000e+00, double* %retval, align 8
  br label %return

if.else:                                          ; preds = %entry
  %1 = load i32, i32* %ARRAY2_SIZE.addr, align 4
  %cmp1 = icmp ule i32 %1, 1
  br i1 %cmp1, label %if.then2, label %if.end

if.then2:                                         ; preds = %if.else
  store double 1.000000e+00, double* %retval, align 8
  br label %return

if.end:                                           ; preds = %if.else
  br label %if.end3

if.end3:                                          ; preds = %if.end
  store double 0.000000e+00, double* %fmean1, align 8
  store double 0.000000e+00, double* %fmean2, align 8
  store i32 0, i32* %x, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.end3
  %2 = load i32, i32* %x, align 4
  %3 = load i32, i32* %ARRAY1_SIZE.addr, align 4
  %cmp4 = icmp ult i32 %2, %3
  br i1 %cmp4, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %4 = load double*, double** %ARRAY1.addr, align 4
  %5 = load i32, i32* %x, align 4
  %arrayidx = getelementptr inbounds double, double* %4, i32 %5
  %6 = load double, double* %arrayidx, align 8
  %7 = call double @llvm.fabs.f64(double %6) #7
  %cmpinf = fcmp one double %7, 0x7FF0000000000000
  %8 = zext i1 %cmpinf to i32
  %cmp5 = icmp eq i32 %8, 0
  br i1 %cmp5, label %if.then6, label %if.end7

if.then6:                                         ; preds = %for.body
  %call = call i32 @puts(i8* getelementptr inbounds ([63 x i8], [63 x i8]* @.str, i32 0, i32 0))
  call void @exit(i32 1) #8
  unreachable

if.end7:                                          ; preds = %for.body
  %9 = load double*, double** %ARRAY1.addr, align 4
  %10 = load i32, i32* %x, align 4
  %arrayidx8 = getelementptr inbounds double, double* %9, i32 %10
  %11 = load double, double* %arrayidx8, align 8
  %12 = load double, double* %fmean1, align 8
  %add = fadd double %12, %11
  store double %add, double* %fmean1, align 8
  br label %for.inc

for.inc:                                          ; preds = %if.end7
  %13 = load i32, i32* %x, align 4
  %inc = add i32 %13, 1
  store i32 %inc, i32* %x, align 4
  br label %for.cond

for.end:                                          ; preds = %for.cond
  %14 = load i32, i32* %ARRAY1_SIZE.addr, align 4
  %conv = uitofp i32 %14 to double
  %15 = load double, double* %fmean1, align 8
  %div = fdiv double %15, %conv
  store double %div, double* %fmean1, align 8
  store i32 0, i32* %x9, align 4
  br label %for.cond10

for.cond10:                                       ; preds = %for.inc23, %for.end
  %16 = load i32, i32* %x9, align 4
  %17 = load i32, i32* %ARRAY2_SIZE.addr, align 4
  %cmp11 = icmp ult i32 %16, %17
  br i1 %cmp11, label %for.body13, label %for.end25

for.body13:                                       ; preds = %for.cond10
  %18 = load double*, double** %ARRAY2.addr, align 4
  %19 = load i32, i32* %x9, align 4
  %arrayidx14 = getelementptr inbounds double, double* %18, i32 %19
  %20 = load double, double* %arrayidx14, align 8
  %21 = call double @llvm.fabs.f64(double %20) #7
  %cmpinf15 = fcmp one double %21, 0x7FF0000000000000
  %22 = zext i1 %cmpinf15 to i32
  %cmp16 = icmp eq i32 %22, 0
  br i1 %cmp16, label %if.then18, label %if.end20

if.then18:                                        ; preds = %for.body13
  %call19 = call i32 @puts(i8* getelementptr inbounds ([63 x i8], [63 x i8]* @.str.1, i32 0, i32 0))
  call void @exit(i32 1) #8
  unreachable

if.end20:                                         ; preds = %for.body13
  %23 = load double*, double** %ARRAY2.addr, align 4
  %24 = load i32, i32* %x9, align 4
  %arrayidx21 = getelementptr inbounds double, double* %23, i32 %24
  %25 = load double, double* %arrayidx21, align 8
  %26 = load double, double* %fmean2, align 8
  %add22 = fadd double %26, %25
  store double %add22, double* %fmean2, align 8
  br label %for.inc23

for.inc23:                                        ; preds = %if.end20
  %27 = load i32, i32* %x9, align 4
  %inc24 = add i32 %27, 1
  store i32 %inc24, i32* %x9, align 4
  br label %for.cond10

for.end25:                                        ; preds = %for.cond10
  %28 = load i32, i32* %ARRAY2_SIZE.addr, align 4
  %conv26 = uitofp i32 %28 to double
  %29 = load double, double* %fmean2, align 8
  %div27 = fdiv double %29, %conv26
  store double %div27, double* %fmean2, align 8
  %30 = load double, double* %fmean1, align 8
  %31 = load double, double* %fmean2, align 8
  %cmp28 = fcmp oeq double %30, %31
  br i1 %cmp28, label %if.then30, label %if.end31

if.then30:                                        ; preds = %for.end25
  store double 1.000000e+00, double* %retval, align 8
  br label %return

if.end31:                                         ; preds = %for.end25
  store double 0.000000e+00, double* %unbiased_sample_variance1, align 8
  store double 0.000000e+00, double* %unbiased_sample_variance2, align 8
  store i32 0, i32* %x32, align 4
  br label %for.cond33

for.cond33:                                       ; preds = %for.inc41, %if.end31
  %32 = load i32, i32* %x32, align 4
  %33 = load i32, i32* %ARRAY1_SIZE.addr, align 4
  %cmp34 = icmp ult i32 %32, %33
  br i1 %cmp34, label %for.body36, label %for.end43

for.body36:                                       ; preds = %for.cond33
  %34 = load double*, double** %ARRAY1.addr, align 4
  %35 = load i32, i32* %x32, align 4
  %arrayidx37 = getelementptr inbounds double, double* %34, i32 %35
  %36 = load double, double* %arrayidx37, align 8
  %37 = load double, double* %fmean1, align 8
  %sub = fsub double %36, %37
  %38 = load double*, double** %ARRAY1.addr, align 4
  %39 = load i32, i32* %x32, align 4
  %arrayidx38 = getelementptr inbounds double, double* %38, i32 %39
  %40 = load double, double* %arrayidx38, align 8
  %41 = load double, double* %fmean1, align 8
  %sub39 = fsub double %40, %41
  %mul = fmul double %sub, %sub39
  %42 = load double, double* %unbiased_sample_variance1, align 8
  %add40 = fadd double %42, %mul
  store double %add40, double* %unbiased_sample_variance1, align 8
  br label %for.inc41

for.inc41:                                        ; preds = %for.body36
  %43 = load i32, i32* %x32, align 4
  %inc42 = add i32 %43, 1
  store i32 %inc42, i32* %x32, align 4
  br label %for.cond33

for.end43:                                        ; preds = %for.cond33
  store i32 0, i32* %x44, align 4
  br label %for.cond45

for.cond45:                                       ; preds = %for.inc55, %for.end43
  %44 = load i32, i32* %x44, align 4
  %45 = load i32, i32* %ARRAY2_SIZE.addr, align 4
  %cmp46 = icmp ult i32 %44, %45
  br i1 %cmp46, label %for.body48, label %for.end57

for.body48:                                       ; preds = %for.cond45
  %46 = load double*, double** %ARRAY2.addr, align 4
  %47 = load i32, i32* %x44, align 4
  %arrayidx49 = getelementptr inbounds double, double* %46, i32 %47
  %48 = load double, double* %arrayidx49, align 8
  %49 = load double, double* %fmean2, align 8
  %sub50 = fsub double %48, %49
  %50 = load double*, double** %ARRAY2.addr, align 4
  %51 = load i32, i32* %x44, align 4
  %arrayidx51 = getelementptr inbounds double, double* %50, i32 %51
  %52 = load double, double* %arrayidx51, align 8
  %53 = load double, double* %fmean2, align 8
  %sub52 = fsub double %52, %53
  %mul53 = fmul double %sub50, %sub52
  %54 = load double, double* %unbiased_sample_variance2, align 8
  %add54 = fadd double %54, %mul53
  store double %add54, double* %unbiased_sample_variance2, align 8
  br label %for.inc55

for.inc55:                                        ; preds = %for.body48
  %55 = load i32, i32* %x44, align 4
  %inc56 = add i32 %55, 1
  store i32 %inc56, i32* %x44, align 4
  br label %for.cond45

for.end57:                                        ; preds = %for.cond45
  %56 = load double, double* %unbiased_sample_variance1, align 8
  %57 = load i32, i32* %ARRAY1_SIZE.addr, align 4
  %sub58 = sub i32 %57, 1
  %conv59 = uitofp i32 %sub58 to double
  %div60 = fdiv double %56, %conv59
  store double %div60, double* %unbiased_sample_variance1, align 8
  %58 = load double, double* %unbiased_sample_variance2, align 8
  %59 = load i32, i32* %ARRAY2_SIZE.addr, align 4
  %sub61 = sub i32 %59, 1
  %conv62 = uitofp i32 %sub61 to double
  %div63 = fdiv double %58, %conv62
  store double %div63, double* %unbiased_sample_variance2, align 8
  %60 = load double, double* %fmean1, align 8
  %61 = load double, double* %fmean2, align 8
  %sub64 = fsub double %60, %61
  %62 = load double, double* %unbiased_sample_variance1, align 8
  %63 = load i32, i32* %ARRAY1_SIZE.addr, align 4
  %conv65 = uitofp i32 %63 to double
  %div66 = fdiv double %62, %conv65
  %64 = load double, double* %unbiased_sample_variance2, align 8
  %65 = load i32, i32* %ARRAY2_SIZE.addr, align 4
  %conv67 = uitofp i32 %65 to double
  %div68 = fdiv double %64, %conv67
  %add69 = fadd double %div66, %div68
  %66 = call double @llvm.sqrt.f64(double %add69)
  %div70 = fdiv double %sub64, %66
  store double %div70, double* %WELCH_T_STATISTIC, align 8
  %67 = load double, double* %unbiased_sample_variance1, align 8
  %68 = load i32, i32* %ARRAY1_SIZE.addr, align 4
  %conv71 = uitofp i32 %68 to double
  %div72 = fdiv double %67, %conv71
  %69 = load double, double* %unbiased_sample_variance2, align 8
  %70 = load i32, i32* %ARRAY2_SIZE.addr, align 4
  %conv73 = uitofp i32 %70 to double
  %div74 = fdiv double %69, %conv73
  %add75 = fadd double %div72, %div74
  %71 = call double @llvm.pow.f64(double %add75, double 2.000000e+00)
  %72 = load double, double* %unbiased_sample_variance1, align 8
  %73 = load double, double* %unbiased_sample_variance1, align 8
  %mul76 = fmul double %72, %73
  %74 = load i32, i32* %ARRAY1_SIZE.addr, align 4
  %75 = load i32, i32* %ARRAY1_SIZE.addr, align 4
  %mul77 = mul i32 %74, %75
  %76 = load i32, i32* %ARRAY1_SIZE.addr, align 4
  %sub78 = sub i32 %76, 1
  %mul79 = mul i32 %mul77, %sub78
  %conv80 = uitofp i32 %mul79 to double
  %div81 = fdiv double %mul76, %conv80
  %77 = load double, double* %unbiased_sample_variance2, align 8
  %78 = load double, double* %unbiased_sample_variance2, align 8
  %mul82 = fmul double %77, %78
  %79 = load i32, i32* %ARRAY2_SIZE.addr, align 4
  %80 = load i32, i32* %ARRAY2_SIZE.addr, align 4
  %mul83 = mul i32 %79, %80
  %81 = load i32, i32* %ARRAY2_SIZE.addr, align 4
  %sub84 = sub i32 %81, 1
  %mul85 = mul i32 %mul83, %sub84
  %conv86 = uitofp i32 %mul85 to double
  %div87 = fdiv double %mul82, %conv86
  %add88 = fadd double %div81, %div87
  %div89 = fdiv double %71, %add88
  store double %div89, double* %DEGREES_OF_FREEDOM, align 8
  %82 = load double, double* %DEGREES_OF_FREEDOM, align 8
  %div90 = fdiv double %82, 2.000000e+00
  store double %div90, double* %a, align 8
  %83 = load double, double* %DEGREES_OF_FREEDOM, align 8
  %84 = load double, double* %WELCH_T_STATISTIC, align 8
  %85 = load double, double* %WELCH_T_STATISTIC, align 8
  %mul91 = fmul double %84, %85
  %86 = load double, double* %DEGREES_OF_FREEDOM, align 8
  %add92 = fadd double %mul91, %86
  %div93 = fdiv double %83, %add92
  store double %div93, double* %value, align 8
  %87 = load double, double* %value, align 8
  %88 = call double @llvm.fabs.f64(double %87) #7
  %cmpinf94 = fcmp oeq double %88, 0x7FF0000000000000
  br i1 %cmpinf94, label %if.then100, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %for.end57
  %89 = load double, double* %value, align 8
  %cmp97 = fcmp uno double %89, %89
  br i1 %cmp97, label %if.then100, label %if.end101

if.then100:                                       ; preds = %lor.lhs.false, %for.end57
  store double 1.000000e+00, double* %retval, align 8
  br label %return

if.end101:                                        ; preds = %lor.lhs.false
  %90 = load double, double* %value, align 8
  %91 = call double @llvm.fabs.f64(double %90) #7
  %cmpinf102 = fcmp oeq double %91, 0x7FF0000000000000
  br i1 %cmpinf102, label %if.then109, label %lor.lhs.false105

lor.lhs.false105:                                 ; preds = %if.end101
  %92 = load double, double* %value, align 8
  %cmp106 = fcmp uno double %92, %92
  br i1 %cmp106, label %if.then109, label %if.end110

if.then109:                                       ; preds = %lor.lhs.false105, %if.end101
  store double 1.000000e+00, double* %retval, align 8
  br label %return

if.end110:                                        ; preds = %lor.lhs.false105
  %93 = load double, double* %a, align 8
  %conv111 = fpext double %93 to fp128
  %call112 = call fp128 @lgammal(fp128 %conv111) #9
  %add113 = fadd fp128 %call112, 0xLD0000000000000003FFE250D048E7A1B
  %94 = load double, double* %a, align 8
  %add114 = fadd double %94, 5.000000e-01
  %conv115 = fpext double %add114 to fp128
  %call116 = call fp128 @lgammal(fp128 %conv115) #9
  %sub117 = fsub fp128 %add113, %call116
  %conv118 = fptrunc fp128 %sub117 to double
  store double %conv118, double* %beta, align 8
  store double 1.000000e-15, double* %acu, align 8
  %95 = load double, double* %a, align 8
  %cmp119 = fcmp ole double %95, 0.000000e+00
  br i1 %cmp119, label %if.then121, label %if.end122

if.then121:                                       ; preds = %if.end110
  br label %if.end122

if.end122:                                        ; preds = %if.then121, %if.end110
  %96 = load double, double* %value, align 8
  %cmp123 = fcmp olt double %96, 0.000000e+00
  br i1 %cmp123, label %if.then128, label %lor.lhs.false125

lor.lhs.false125:                                 ; preds = %if.end122
  %97 = load double, double* %value, align 8
  %cmp126 = fcmp olt double 1.000000e+00, %97
  br i1 %cmp126, label %if.then128, label %if.end129

if.then128:                                       ; preds = %lor.lhs.false125, %if.end122
  %98 = load double, double* %value, align 8
  store double %98, double* %retval, align 8
  br label %return

if.end129:                                        ; preds = %lor.lhs.false125
  %99 = load double, double* %value, align 8
  %cmp130 = fcmp oeq double %99, 0.000000e+00
  br i1 %cmp130, label %if.then135, label %lor.lhs.false132

lor.lhs.false132:                                 ; preds = %if.end129
  %100 = load double, double* %value, align 8
  %cmp133 = fcmp oeq double %100, 1.000000e+00
  br i1 %cmp133, label %if.then135, label %if.end136

if.then135:                                       ; preds = %lor.lhs.false132, %if.end129
  %101 = load double, double* %value, align 8
  store double %101, double* %retval, align 8
  br label %return

if.end136:                                        ; preds = %lor.lhs.false132
  %102 = load double, double* %a, align 8
  %add137 = fadd double %102, 5.000000e-01
  store double %add137, double* %psq, align 8
  %103 = load double, double* %value, align 8
  %sub138 = fsub double 1.000000e+00, %103
  store double %sub138, double* %cx, align 8
  %104 = load double, double* %a, align 8
  %105 = load double, double* %psq, align 8
  %106 = load double, double* %value, align 8
  %mul139 = fmul double %105, %106
  %cmp140 = fcmp olt double %104, %mul139
  br i1 %cmp140, label %if.then142, label %if.else143

if.then142:                                       ; preds = %if.end136
  %107 = load double, double* %cx, align 8
  store double %107, double* %xx, align 8
  %108 = load double, double* %value, align 8
  store double %108, double* %cx, align 8
  store double 5.000000e-01, double* %pp, align 8
  %109 = load double, double* %a, align 8
  store double %109, double* %qq, align 8
  store i32 1, i32* %indx, align 4
  br label %if.end144

if.else143:                                       ; preds = %if.end136
  %110 = load double, double* %value, align 8
  store double %110, double* %xx, align 8
  %111 = load double, double* %a, align 8
  store double %111, double* %pp, align 8
  store double 5.000000e-01, double* %qq, align 8
  store i32 0, i32* %indx, align 4
  br label %if.end144

if.end144:                                        ; preds = %if.else143, %if.then142
  store double 1.000000e+00, double* %term, align 8
  store double 1.000000e+00, double* %ai, align 8
  store double 1.000000e+00, double* %value, align 8
  %112 = load double, double* %qq, align 8
  %113 = load double, double* %cx, align 8
  %114 = load double, double* %psq, align 8
  %mul145 = fmul double %113, %114
  %add146 = fadd double %112, %mul145
  %conv147 = fptosi double %add146 to i32
  store i32 %conv147, i32* %ns, align 4
  %115 = load double, double* %xx, align 8
  %116 = load double, double* %cx, align 8
  %div148 = fdiv double %115, %116
  store double %div148, double* %rx, align 8
  %117 = load double, double* %qq, align 8
  %118 = load double, double* %ai, align 8
  %sub149 = fsub double %117, %118
  store double %sub149, double* %temp, align 8
  %119 = load i32, i32* %ns, align 4
  %cmp150 = icmp eq i32 %119, 0
  br i1 %cmp150, label %if.then152, label %if.end153

if.then152:                                       ; preds = %if.end144
  %120 = load double, double* %xx, align 8
  store double %120, double* %rx, align 8
  br label %if.end153

if.end153:                                        ; preds = %if.then152, %if.end144
  br label %for.cond154

for.cond154:                                      ; preds = %if.end189, %if.end153
  %121 = load double, double* %term, align 8
  %122 = load double, double* %temp, align 8
  %mul155 = fmul double %121, %122
  %123 = load double, double* %rx, align 8
  %mul156 = fmul double %mul155, %123
  %124 = load double, double* %pp, align 8
  %125 = load double, double* %ai, align 8
  %add157 = fadd double %124, %125
  %div158 = fdiv double %mul156, %add157
  store double %div158, double* %term, align 8
  %126 = load double, double* %value, align 8
  %127 = load double, double* %term, align 8
  %add159 = fadd double %126, %127
  store double %add159, double* %value, align 8
  %128 = load double, double* %term, align 8
  %129 = call double @llvm.fabs.f64(double %128)
  store double %129, double* %temp, align 8
  %130 = load double, double* %temp, align 8
  %cmp160 = fcmp ole double %130, 1.000000e-15
  br i1 %cmp160, label %land.lhs.true, label %if.end176

land.lhs.true:                                    ; preds = %for.cond154
  %131 = load double, double* %temp, align 8
  %132 = load double, double* %value, align 8
  %mul162 = fmul double 1.000000e-15, %132
  %cmp163 = fcmp ole double %131, %mul162
  br i1 %cmp163, label %if.then165, label %if.end176

if.then165:                                       ; preds = %land.lhs.true
  %133 = load double, double* %value, align 8
  %134 = load double, double* %pp, align 8
  %135 = load double, double* %xx, align 8
  %136 = call double @llvm.log.f64(double %135)
  %mul166 = fmul double %134, %136
  %137 = load double, double* %qq, align 8
  %sub167 = fsub double %137, 1.000000e+00
  %138 = load double, double* %cx, align 8
  %139 = call double @llvm.log.f64(double %138)
  %mul168 = fmul double %sub167, %139
  %add169 = fadd double %mul166, %mul168
  %140 = load double, double* %beta, align 8
  %sub170 = fsub double %add169, %140
  %141 = call double @llvm.exp.f64(double %sub170)
  %mul171 = fmul double %133, %141
  %142 = load double, double* %pp, align 8
  %div172 = fdiv double %mul171, %142
  store double %div172, double* %value, align 8
  %143 = load i32, i32* %indx, align 4
  %tobool = icmp ne i32 %143, 0
  br i1 %tobool, label %if.then173, label %if.end175

if.then173:                                       ; preds = %if.then165
  %144 = load double, double* %value, align 8
  %sub174 = fsub double 1.000000e+00, %144
  store double %sub174, double* %value, align 8
  br label %if.end175

if.end175:                                        ; preds = %if.then173, %if.then165
  br label %for.end190

if.end176:                                        ; preds = %land.lhs.true, %for.cond154
  %145 = load double, double* %ai, align 8
  %add177 = fadd double %145, 1.000000e+00
  store double %add177, double* %ai, align 8
  %146 = load i32, i32* %ns, align 4
  %sub178 = sub nsw i32 %146, 1
  store i32 %sub178, i32* %ns, align 4
  %147 = load i32, i32* %ns, align 4
  %cmp179 = icmp sle i32 0, %147
  br i1 %cmp179, label %if.then181, label %if.else187

if.then181:                                       ; preds = %if.end176
  %148 = load double, double* %qq, align 8
  %149 = load double, double* %ai, align 8
  %sub182 = fsub double %148, %149
  store double %sub182, double* %temp, align 8
  %150 = load i32, i32* %ns, align 4
  %cmp183 = icmp eq i32 %150, 0
  br i1 %cmp183, label %if.then185, label %if.end186

if.then185:                                       ; preds = %if.then181
  %151 = load double, double* %xx, align 8
  store double %151, double* %rx, align 8
  br label %if.end186

if.end186:                                        ; preds = %if.then185, %if.then181
  br label %if.end189

if.else187:                                       ; preds = %if.end176
  %152 = load double, double* %psq, align 8
  store double %152, double* %temp, align 8
  %153 = load double, double* %psq, align 8
  %add188 = fadd double %153, 1.000000e+00
  store double %add188, double* %psq, align 8
  br label %if.end189

if.end189:                                        ; preds = %if.else187, %if.end186
  br label %for.cond154

for.end190:                                       ; preds = %if.end175
  %154 = load double, double* %value, align 8
  store double %154, double* %retval, align 8
  br label %return

return:                                           ; preds = %for.end190, %if.then135, %if.then128, %if.then109, %if.then100, %if.then30, %if.then2, %if.then
  %155 = load double, double* %retval, align 8
  ret double %155
}

; Function Attrs: nounwind readnone speculatable willreturn
declare double @llvm.fabs.f64(double %0) #1

declare i32 @puts(i8* %0) #2

; Function Attrs: noreturn
declare void @exit(i32 %0) #3

; Function Attrs: nounwind readnone speculatable willreturn
declare double @llvm.sqrt.f64(double %0) #1

; Function Attrs: nounwind readnone speculatable willreturn
declare double @llvm.pow.f64(double %0, double %1) #1

; Function Attrs: nounwind
declare fp128 @lgammal(fp128 %0) #4

; Function Attrs: nounwind readnone speculatable willreturn
declare double @llvm.log.f64(double %0) #1

; Function Attrs: nounwind readnone speculatable willreturn
declare double @llvm.exp.f64(double %0) #1

; Function Attrs: noinline nounwind optnone
define hidden i32 @main() #0 {
entry:
  %retval = alloca i32, align 4
  %d1 = alloca [15 x double], align 16
  %d2 = alloca [15 x double], align 16
  %d3 = alloca [10 x double], align 16
  %d4 = alloca [20 x double], align 16
  %d5 = alloca [10 x double], align 16
  %d6 = alloca [20 x double], align 16
  %d7 = alloca [6 x double], align 16
  %d8 = alloca [6 x double], align 16
  %x = alloca [4 x double], align 16
  %y = alloca [3 x double], align 16
  %v1 = alloca [3 x double], align 16
  %v2 = alloca [3 x double], align 16
  %s1 = alloca [2 x double], align 16
  %s2 = alloca [2 x double], align 16
  %z1 = alloca [3 x double], align 16
  %z2 = alloca [3 x double], align 16
  %CORRECT_ANSWERS = alloca [8 x double], align 16
  %pvalue = alloca double, align 8
  %error = alloca double, align 8
  store i32 0, i32* %retval, align 4
  %0 = bitcast [15 x double]* %d1 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 16 %0, i8* align 16 bitcast ([15 x double]* @__const.main.d1 to i8*), i32 120, i1 false)
  %1 = bitcast [15 x double]* %d2 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 16 %1, i8* align 16 bitcast ([15 x double]* @__const.main.d2 to i8*), i32 120, i1 false)
  %2 = bitcast [10 x double]* %d3 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 16 %2, i8* align 16 bitcast ([10 x double]* @__const.main.d3 to i8*), i32 80, i1 false)
  %3 = bitcast [20 x double]* %d4 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 16 %3, i8* align 16 bitcast ([20 x double]* @__const.main.d4 to i8*), i32 160, i1 false)
  %4 = bitcast [10 x double]* %d5 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 16 %4, i8* align 16 bitcast ([10 x double]* @__const.main.d5 to i8*), i32 80, i1 false)
  %5 = bitcast [20 x double]* %d6 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 16 %5, i8* align 16 bitcast ([20 x double]* @__const.main.d6 to i8*), i32 160, i1 false)
  %6 = bitcast [6 x double]* %d7 to i8*
  call void @llvm.memset.p0i8.i32(i8* align 16 %6, i8 0, i32 48, i1 false)
  %7 = bitcast i8* %6 to [6 x double]*
  %8 = getelementptr inbounds [6 x double], [6 x double]* %7, i32 0, i32 0
  store double 3.002000e+01, double* %8, align 16
  %9 = getelementptr inbounds [6 x double], [6 x double]* %7, i32 0, i32 1
  store double 2.999000e+01, double* %9, align 8
  %10 = getelementptr inbounds [6 x double], [6 x double]* %7, i32 0, i32 2
  store double 3.011000e+01, double* %10, align 16
  %11 = getelementptr inbounds [6 x double], [6 x double]* %7, i32 0, i32 3
  store double 2.997000e+01, double* %11, align 8
  %12 = getelementptr inbounds [6 x double], [6 x double]* %7, i32 0, i32 4
  store double 3.001000e+01, double* %12, align 16
  %13 = getelementptr inbounds [6 x double], [6 x double]* %7, i32 0, i32 5
  store double 2.999000e+01, double* %13, align 8
  %14 = bitcast [6 x double]* %d8 to i8*
  call void @llvm.memset.p0i8.i32(i8* align 16 %14, i8 0, i32 48, i1 false)
  %15 = bitcast i8* %14 to [6 x double]*
  %16 = getelementptr inbounds [6 x double], [6 x double]* %15, i32 0, i32 0
  store double 2.989000e+01, double* %16, align 16
  %17 = getelementptr inbounds [6 x double], [6 x double]* %15, i32 0, i32 1
  store double 2.993000e+01, double* %17, align 8
  %18 = getelementptr inbounds [6 x double], [6 x double]* %15, i32 0, i32 2
  store double 2.972000e+01, double* %18, align 16
  %19 = getelementptr inbounds [6 x double], [6 x double]* %15, i32 0, i32 3
  store double 2.998000e+01, double* %19, align 8
  %20 = getelementptr inbounds [6 x double], [6 x double]* %15, i32 0, i32 4
  store double 3.002000e+01, double* %20, align 16
  %21 = getelementptr inbounds [6 x double], [6 x double]* %15, i32 0, i32 5
  store double 2.998000e+01, double* %21, align 8
  %22 = bitcast [4 x double]* %x to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 16 %22, i8* align 16 bitcast ([4 x double]* @__const.main.x to i8*), i32 32, i1 false)
  %23 = bitcast [3 x double]* %y to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 16 %23, i8* align 16 bitcast ([3 x double]* @__const.main.y to i8*), i32 24, i1 false)
  %24 = bitcast [3 x double]* %v1 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 16 %24, i8* align 16 bitcast ([3 x double]* @__const.main.v1 to i8*), i32 24, i1 false)
  %25 = bitcast [3 x double]* %v2 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 16 %25, i8* align 16 bitcast ([3 x double]* @__const.main.v2 to i8*), i32 24, i1 false)
  %26 = bitcast [2 x double]* %s1 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 16 %26, i8* align 16 bitcast ([2 x double]* @__const.main.s1 to i8*), i32 16, i1 false)
  %27 = bitcast [2 x double]* %s2 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 16 %27, i8* align 16 bitcast ([2 x double]* @__const.main.s2 to i8*), i32 16, i1 false)
  %28 = bitcast [3 x double]* %z1 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 16 %28, i8* align 16 bitcast ([3 x double]* @__const.main.z1 to i8*), i32 24, i1 false)
  %29 = bitcast [3 x double]* %z2 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 16 %29, i8* align 16 bitcast ([3 x double]* @__const.main.z2 to i8*), i32 24, i1 false)
  %30 = bitcast [8 x double]* %CORRECT_ANSWERS to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 16 %30, i8* align 16 bitcast ([8 x double]* @__const.main.CORRECT_ANSWERS to i8*), i32 64, i1 false)
  %arraydecay = getelementptr inbounds [15 x double], [15 x double]* %d1, i32 0, i32 0
  %arraydecay1 = getelementptr inbounds [15 x double], [15 x double]* %d2, i32 0, i32 0
  %call = call double @Pvalue(double* %arraydecay, i32 15, double* %arraydecay1, i32 15)
  store double %call, double* %pvalue, align 8
  %31 = load double, double* %pvalue, align 8
  %arrayidx = getelementptr inbounds [8 x double], [8 x double]* %CORRECT_ANSWERS, i32 0, i32 0
  %32 = load double, double* %arrayidx, align 16
  %sub = fsub double %31, %32
  %33 = call double @llvm.fabs.f64(double %sub)
  store double %33, double* %error, align 8
  %34 = load double, double* %pvalue, align 8
  %call2 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([26 x i8], [26 x i8]* @.str.2, i32 0, i32 0), double %34)
  %arraydecay3 = getelementptr inbounds [10 x double], [10 x double]* %d3, i32 0, i32 0
  %arraydecay4 = getelementptr inbounds [20 x double], [20 x double]* %d4, i32 0, i32 0
  %call5 = call double @Pvalue(double* %arraydecay3, i32 10, double* %arraydecay4, i32 20)
  store double %call5, double* %pvalue, align 8
  %35 = load double, double* %pvalue, align 8
  %arrayidx6 = getelementptr inbounds [8 x double], [8 x double]* %CORRECT_ANSWERS, i32 0, i32 1
  %36 = load double, double* %arrayidx6, align 8
  %sub7 = fsub double %35, %36
  %37 = call double @llvm.fabs.f64(double %sub7)
  %38 = load double, double* %error, align 8
  %add = fadd double %38, %37
  store double %add, double* %error, align 8
  %39 = load double, double* %pvalue, align 8
  %call8 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([26 x i8], [26 x i8]* @.str.3, i32 0, i32 0), double %39)
  %arraydecay9 = getelementptr inbounds [10 x double], [10 x double]* %d5, i32 0, i32 0
  %arraydecay10 = getelementptr inbounds [20 x double], [20 x double]* %d6, i32 0, i32 0
  %call11 = call double @Pvalue(double* %arraydecay9, i32 10, double* %arraydecay10, i32 20)
  store double %call11, double* %pvalue, align 8
  %40 = load double, double* %pvalue, align 8
  %arrayidx12 = getelementptr inbounds [8 x double], [8 x double]* %CORRECT_ANSWERS, i32 0, i32 2
  %41 = load double, double* %arrayidx12, align 16
  %sub13 = fsub double %40, %41
  %42 = call double @llvm.fabs.f64(double %sub13)
  %43 = load double, double* %error, align 8
  %add14 = fadd double %43, %42
  store double %add14, double* %error, align 8
  %44 = load double, double* %pvalue, align 8
  %call15 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([26 x i8], [26 x i8]* @.str.4, i32 0, i32 0), double %44)
  %arraydecay16 = getelementptr inbounds [6 x double], [6 x double]* %d7, i32 0, i32 0
  %arraydecay17 = getelementptr inbounds [6 x double], [6 x double]* %d8, i32 0, i32 0
  %call18 = call double @Pvalue(double* %arraydecay16, i32 6, double* %arraydecay17, i32 6)
  store double %call18, double* %pvalue, align 8
  %45 = load double, double* %pvalue, align 8
  %call19 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([26 x i8], [26 x i8]* @.str.5, i32 0, i32 0), double %45)
  %46 = load double, double* %pvalue, align 8
  %arrayidx20 = getelementptr inbounds [8 x double], [8 x double]* %CORRECT_ANSWERS, i32 0, i32 3
  %47 = load double, double* %arrayidx20, align 8
  %sub21 = fsub double %46, %47
  %48 = call double @llvm.fabs.f64(double %sub21)
  %49 = load double, double* %error, align 8
  %add22 = fadd double %49, %48
  store double %add22, double* %error, align 8
  %arraydecay23 = getelementptr inbounds [4 x double], [4 x double]* %x, i32 0, i32 0
  %arraydecay24 = getelementptr inbounds [3 x double], [3 x double]* %y, i32 0, i32 0
  %call25 = call double @Pvalue(double* %arraydecay23, i32 4, double* %arraydecay24, i32 3)
  store double %call25, double* %pvalue, align 8
  %50 = load double, double* %pvalue, align 8
  %arrayidx26 = getelementptr inbounds [8 x double], [8 x double]* %CORRECT_ANSWERS, i32 0, i32 4
  %51 = load double, double* %arrayidx26, align 16
  %sub27 = fsub double %50, %51
  %52 = call double @llvm.fabs.f64(double %sub27)
  %53 = load double, double* %error, align 8
  %add28 = fadd double %53, %52
  store double %add28, double* %error, align 8
  %54 = load double, double* %pvalue, align 8
  %call29 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([26 x i8], [26 x i8]* @.str.6, i32 0, i32 0), double %54)
  %arraydecay30 = getelementptr inbounds [3 x double], [3 x double]* %v1, i32 0, i32 0
  %arraydecay31 = getelementptr inbounds [3 x double], [3 x double]* %v2, i32 0, i32 0
  %call32 = call double @Pvalue(double* %arraydecay30, i32 3, double* %arraydecay31, i32 3)
  store double %call32, double* %pvalue, align 8
  %55 = load double, double* %pvalue, align 8
  %arrayidx33 = getelementptr inbounds [8 x double], [8 x double]* %CORRECT_ANSWERS, i32 0, i32 5
  %56 = load double, double* %arrayidx33, align 8
  %sub34 = fsub double %55, %56
  %57 = call double @llvm.fabs.f64(double %sub34)
  %58 = load double, double* %error, align 8
  %add35 = fadd double %58, %57
  store double %add35, double* %error, align 8
  %59 = load double, double* %pvalue, align 8
  %call36 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([26 x i8], [26 x i8]* @.str.7, i32 0, i32 0), double %59)
  %arraydecay37 = getelementptr inbounds [2 x double], [2 x double]* %s1, i32 0, i32 0
  %arraydecay38 = getelementptr inbounds [2 x double], [2 x double]* %s2, i32 0, i32 0
  %call39 = call double @Pvalue(double* %arraydecay37, i32 2, double* %arraydecay38, i32 2)
  store double %call39, double* %pvalue, align 8
  %60 = load double, double* %pvalue, align 8
  %arrayidx40 = getelementptr inbounds [8 x double], [8 x double]* %CORRECT_ANSWERS, i32 0, i32 6
  %61 = load double, double* %arrayidx40, align 16
  %sub41 = fsub double %60, %61
  %62 = call double @llvm.fabs.f64(double %sub41)
  %63 = load double, double* %error, align 8
  %add42 = fadd double %63, %62
  store double %add42, double* %error, align 8
  %64 = load double, double* %pvalue, align 8
  %call43 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([26 x i8], [26 x i8]* @.str.8, i32 0, i32 0), double %64)
  %arraydecay44 = getelementptr inbounds [3 x double], [3 x double]* %z1, i32 0, i32 0
  %arraydecay45 = getelementptr inbounds [3 x double], [3 x double]* %z2, i32 0, i32 0
  %call46 = call double @Pvalue(double* %arraydecay44, i32 3, double* %arraydecay45, i32 3)
  store double %call46, double* %pvalue, align 8
  %65 = load double, double* %pvalue, align 8
  %arrayidx47 = getelementptr inbounds [8 x double], [8 x double]* %CORRECT_ANSWERS, i32 0, i32 7
  %66 = load double, double* %arrayidx47, align 8
  %sub48 = fsub double %65, %66
  %67 = call double @llvm.fabs.f64(double %sub48)
  %68 = load double, double* %error, align 8
  %add49 = fadd double %68, %67
  store double %add49, double* %error, align 8
  %69 = load double, double* %pvalue, align 8
  %call50 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([26 x i8], [26 x i8]* @.str.9, i32 0, i32 0), double %69)
  %70 = load double, double* %error, align 8
  %call51 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([28 x i8], [28 x i8]* @.str.10, i32 0, i32 0), double %70)
  ret i32 0
}

; Function Attrs: argmemonly nounwind willreturn
declare void @llvm.memcpy.p0i8.p0i8.i32(i8* noalias nocapture writeonly %0, i8* noalias nocapture readonly %1, i32 %2, i1 immarg %3) #5

; Function Attrs: argmemonly nounwind willreturn writeonly
declare void @llvm.memset.p0i8.i32(i8* nocapture writeonly %0, i8 %1, i32 %2, i1 immarg %3) #6

declare i32 @printf(i8* %0, ...) #2

attributes #0 = { noinline nounwind optnone "correctly-rounded-divide-sqrt-fp-math"="false" "disable-tail-calls"="false" "frame-pointer"="none" "less-precise-fpmad"="false" "min-legal-vector-width"="0" "no-infs-fp-math"="false" "no-jump-tables"="false" "no-nans-fp-math"="false" "no-signed-zeros-fp-math"="false" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="generic" "unsafe-fp-math"="false" "use-soft-float"="false" }
attributes #1 = { nounwind readnone speculatable willreturn }
attributes #2 = { "correctly-rounded-divide-sqrt-fp-math"="false" "disable-tail-calls"="false" "frame-pointer"="none" "less-precise-fpmad"="false" "no-infs-fp-math"="false" "no-nans-fp-math"="false" "no-signed-zeros-fp-math"="false" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="generic" "unsafe-fp-math"="false" "use-soft-float"="false" }
attributes #3 = { noreturn "correctly-rounded-divide-sqrt-fp-math"="false" "disable-tail-calls"="false" "frame-pointer"="none" "less-precise-fpmad"="false" "no-infs-fp-math"="false" "no-nans-fp-math"="false" "no-signed-zeros-fp-math"="false" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="generic" "unsafe-fp-math"="false" "use-soft-float"="false" }
attributes #4 = { nounwind "correctly-rounded-divide-sqrt-fp-math"="false" "disable-tail-calls"="false" "frame-pointer"="none" "less-precise-fpmad"="false" "no-infs-fp-math"="false" "no-nans-fp-math"="false" "no-signed-zeros-fp-math"="false" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="generic" "unsafe-fp-math"="false" "use-soft-float"="false" }
attributes #5 = { argmemonly nounwind willreturn }
attributes #6 = { argmemonly nounwind willreturn writeonly }
attributes #7 = { readnone }
attributes #8 = { noreturn }
attributes #9 = { nounwind }

!llvm.module.flags = !{!0}
!llvm.ident = !{!1}

!0 = !{i32 1, !"wchar_size", i32 4}
!1 = !{!"clang version 11.0.0 (https://github.com/Jacarte/llvm-project.git 0f6dea67136cc1e0b3d200eb2bb165628970c44b)"}

#########################################################
; exiting Souper's runOnFunction() for Pvalue()
rescanning function after transformation was applied

; entering Souper's runOnFunction() for Pvalue()

; ModuleID = './Welchs_t-test.c.bc'
source_filename = "./Welchs_t-test.c"
target datalayout = "e-m:e-p:32:32-i64:64-n32:64-S128"
target triple = "wasm32-unknown-wasi"

@.str = private unnamed_addr constant [63 x i8] c"Got a non-finite number in 1st array, can't calculate P-value.\00", align 1
@.str.1 = private unnamed_addr constant [63 x i8] c"Got a non-finite number in 2nd array, can't calculate P-value.\00", align 1
@__const.main.d1 = private unnamed_addr constant [15 x double] [double 2.750000e+01, double 2.100000e+01, double 1.900000e+01, double 2.360000e+01, double 1.700000e+01, double 1.790000e+01, double 1.690000e+01, double 2.010000e+01, double 2.190000e+01, double 2.260000e+01, double 2.310000e+01, double 1.960000e+01, double 1.900000e+01, double 2.170000e+01, double 2.140000e+01], align 16
@__const.main.d2 = private unnamed_addr constant [15 x double] [double 2.710000e+01, double 2.200000e+01, double 2.080000e+01, double 2.340000e+01, double 2.340000e+01, double 2.350000e+01, double 2.580000e+01, double 2.200000e+01, double 2.480000e+01, double 2.020000e+01, double 2.190000e+01, double 2.210000e+01, double 2.290000e+01, double 2.050000e+01, double 2.440000e+01], align 16
@__const.main.d3 = private unnamed_addr constant [10 x double] [double 1.720000e+01, double 2.090000e+01, double 2.260000e+01, double 1.810000e+01, double 2.170000e+01, double 2.140000e+01, double 2.350000e+01, double 2.420000e+01, double 1.470000e+01, double 2.180000e+01], align 16
@__const.main.d4 = private unnamed_addr constant [20 x double] [double 2.150000e+01, double 2.280000e+01, double 2.100000e+01, double 2.300000e+01, double 2.160000e+01, double 2.360000e+01, double 2.250000e+01, double 2.070000e+01, double 2.340000e+01, double 2.180000e+01, double 2.070000e+01, double 2.170000e+01, double 2.150000e+01, double 2.250000e+01, double 2.360000e+01, double 2.150000e+01, double 2.250000e+01, double 2.350000e+01, double 2.150000e+01, double 2.180000e+01], align 16
@__const.main.d5 = private unnamed_addr constant [10 x double] [double 1.980000e+01, double 2.040000e+01, double 1.960000e+01, double 1.780000e+01, double 1.850000e+01, double 1.890000e+01, double 1.830000e+01, double 1.890000e+01, double 1.950000e+01, double 2.200000e+01], align 16
@__const.main.d6 = private unnamed_addr constant [20 x double] [double 2.820000e+01, double 2.660000e+01, double 2.010000e+01, double 2.330000e+01, double 2.520000e+01, double 2.210000e+01, double 1.770000e+01, double 2.760000e+01, double 2.060000e+01, double 1.370000e+01, double 2.320000e+01, double 1.750000e+01, double 2.060000e+01, double 1.800000e+01, double 2.390000e+01, double 2.160000e+01, double 2.430000e+01, double 2.040000e+01, double 2.400000e+01, double 1.320000e+01], align 16
@__const.main.x = private unnamed_addr constant [4 x double] [double 3.000000e+00, double 4.000000e+00, double 1.000000e+00, double 2.100000e+00], align 16
@__const.main.y = private unnamed_addr constant [3 x double] [double 4.902000e+02, double 3.400000e+02, double 4.339000e+02], align 16
@__const.main.v1 = private unnamed_addr constant [3 x double] [double 1.026800e-02, double 1.670000e-04, double 1.670000e-04], align 16
@__const.main.v2 = private unnamed_addr constant [3 x double] [double 1.592580e-01, double 1.362780e-01, double 1.223890e-01], align 16
@__const.main.s1 = private unnamed_addr constant [2 x double] [double 0x3FB1111111111111, double 0x3FC4A5294A5294A5], align 16
@__const.main.s2 = private unnamed_addr constant [2 x double] [double 1.000000e-01, double 4.000000e-02], align 16
@__const.main.z1 = private unnamed_addr constant [3 x double] [double 0x3FD90B21642C8591, double 0x3FDDDDDDDDDDDDDE, double 0.000000e+00], align 16
@__const.main.z2 = private unnamed_addr constant [3 x double] [double 0.000000e+00, double 0x3FDC9882B9310572, double 0.000000e+00], align 16
@__const.main.CORRECT_ANSWERS = private unnamed_addr constant [8 x double] [double 0x3F95E41D648C236F, double 0x3FC30D3EA599BB79, double 0x3FA26AF51F458AEB, double 0x3FB73CEBAB27FA12, double 0x3F8604EA1C27764A, double 0x3F6BD85EAF35CBC8, double 0x3FE0DF5C6BE20DA6, double 0x3FE172D38028625E], align 16
@.str.2 = private unnamed_addr constant [26 x i8] c"Test sets 1 p-value = %g\0A\00", align 1
@.str.3 = private unnamed_addr constant [26 x i8] c"Test sets 2 p-value = %g\0A\00", align 1
@.str.4 = private unnamed_addr constant [26 x i8] c"Test sets 3 p-value = %g\0A\00", align 1
@.str.5 = private unnamed_addr constant [26 x i8] c"Test sets 4 p-value = %g\0A\00", align 1
@.str.6 = private unnamed_addr constant [26 x i8] c"Test sets 5 p-value = %g\0A\00", align 1
@.str.7 = private unnamed_addr constant [26 x i8] c"Test sets 6 p-value = %g\0A\00", align 1
@.str.8 = private unnamed_addr constant [26 x i8] c"Test sets 7 p-value = %g\0A\00", align 1
@.str.9 = private unnamed_addr constant [26 x i8] c"Test sets z p-value = %g\0A\00", align 1
@.str.10 = private unnamed_addr constant [28 x i8] c"the cumulative error is %g\0A\00", align 1
@llvm.used = appending global [1 x i8*] [i8* bitcast (i32 ()* @__main_void to i8*)], section "llvm.metadata"

@__main_void = alias i32 (), i32 ()* @main

; Function Attrs: noinline nounwind optnone
define hidden double @Pvalue(double* noalias %ARRAY1, i32 %ARRAY1_SIZE, double* noalias %ARRAY2, i32 %ARRAY2_SIZE) #0 {
entry:
  %retval = alloca double, align 8
  %ARRAY1.addr = alloca double*, align 4
  %ARRAY1_SIZE.addr = alloca i32, align 4
  %ARRAY2.addr = alloca double*, align 4
  %ARRAY2_SIZE.addr = alloca i32, align 4
  %fmean1 = alloca double, align 8
  %fmean2 = alloca double, align 8
  %x = alloca i32, align 4
  %x9 = alloca i32, align 4
  %unbiased_sample_variance1 = alloca double, align 8
  %unbiased_sample_variance2 = alloca double, align 8
  %x32 = alloca i32, align 4
  %x44 = alloca i32, align 4
  %WELCH_T_STATISTIC = alloca double, align 8
  %DEGREES_OF_FREEDOM = alloca double, align 8
  %a = alloca double, align 8
  %value = alloca double, align 8
  %beta = alloca double, align 8
  %acu = alloca double, align 8
  %ai = alloca double, align 8
  %cx = alloca double, align 8
  %indx = alloca i32, align 4
  %ns = alloca i32, align 4
  %pp = alloca double, align 8
  %psq = alloca double, align 8
  %qq = alloca double, align 8
  %rx = alloca double, align 8
  %temp = alloca double, align 8
  %term = alloca double, align 8
  %xx = alloca double, align 8
  store double* %ARRAY1, double** %ARRAY1.addr, align 4
  store i32 %ARRAY1_SIZE, i32* %ARRAY1_SIZE.addr, align 4
  store double* %ARRAY2, double** %ARRAY2.addr, align 4
  store i32 %ARRAY2_SIZE, i32* %ARRAY2_SIZE.addr, align 4
  %0 = load i32, i32* %ARRAY1_SIZE.addr, align 4
  %cmp = icmp ule i32 %0, 1
  br i1 %cmp, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  store double 1.000000e+00, double* %retval, align 8
  br label %return

if.else:                                          ; preds = %entry
  %1 = load i32, i32* %ARRAY2_SIZE.addr, align 4
  %cmp1 = icmp ule i32 %1, 1
  br i1 %cmp1, label %if.then2, label %if.end

if.then2:                                         ; preds = %if.else
  store double 1.000000e+00, double* %retval, align 8
  br label %return

if.end:                                           ; preds = %if.else
  br label %if.end3

if.end3:                                          ; preds = %if.end
  store double 0.000000e+00, double* %fmean1, align 8
  store double 0.000000e+00, double* %fmean2, align 8
  store i32 0, i32* %x, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.end3
  %2 = load i32, i32* %x, align 4
  %3 = load i32, i32* %ARRAY1_SIZE.addr, align 4
  %cmp4 = icmp ult i32 %2, %3
  br i1 %cmp4, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %4 = load double*, double** %ARRAY1.addr, align 4
  %5 = load i32, i32* %x, align 4
  %arrayidx = getelementptr inbounds double, double* %4, i32 %5
  %6 = load double, double* %arrayidx, align 8
  %7 = call double @llvm.fabs.f64(double %6) #7
  %cmpinf = fcmp one double %7, 0x7FF0000000000000
  %8 = zext i1 %cmpinf to i32
  %cmp5 = icmp eq i32 %8, 0
  br i1 %cmp5, label %if.then6, label %if.end7

if.then6:                                         ; preds = %for.body
  %call = call i32 @puts(i8* getelementptr inbounds ([63 x i8], [63 x i8]* @.str, i32 0, i32 0))
  call void @exit(i32 1) #8
  unreachable

if.end7:                                          ; preds = %for.body
  %9 = load double*, double** %ARRAY1.addr, align 4
  %10 = load i32, i32* %x, align 4
  %arrayidx8 = getelementptr inbounds double, double* %9, i32 %10
  %11 = load double, double* %arrayidx8, align 8
  %12 = load double, double* %fmean1, align 8
  %add = fadd double %12, %11
  store double %add, double* %fmean1, align 8
  br label %for.inc

for.inc:                                          ; preds = %if.end7
  %13 = load i32, i32* %x, align 4
  %inc = add i32 %13, 1
  store i32 %inc, i32* %x, align 4
  br label %for.cond

for.end:                                          ; preds = %for.cond
  %14 = load i32, i32* %ARRAY1_SIZE.addr, align 4
  %conv = uitofp i32 %14 to double
  %15 = load double, double* %fmean1, align 8
  %div = fdiv double %15, %conv
  store double %div, double* %fmean1, align 8
  store i32 0, i32* %x9, align 4
  br label %for.cond10

for.cond10:                                       ; preds = %for.inc23, %for.end
  %16 = load i32, i32* %x9, align 4
  %17 = load i32, i32* %ARRAY2_SIZE.addr, align 4
  %cmp11 = icmp ult i32 %16, %17
  br i1 %cmp11, label %for.body13, label %for.end25

for.body13:                                       ; preds = %for.cond10
  %18 = load double*, double** %ARRAY2.addr, align 4
  %19 = load i32, i32* %x9, align 4
  %arrayidx14 = getelementptr inbounds double, double* %18, i32 %19
  %20 = load double, double* %arrayidx14, align 8
  %21 = call double @llvm.fabs.f64(double %20) #7
  %cmpinf15 = fcmp one double %21, 0x7FF0000000000000
  %22 = zext i1 %cmpinf15 to i32
  %cmp16 = icmp eq i32 %22, 0
  br i1 %cmp16, label %if.then18, label %if.end20

if.then18:                                        ; preds = %for.body13
  %call19 = call i32 @puts(i8* getelementptr inbounds ([63 x i8], [63 x i8]* @.str.1, i32 0, i32 0))
  call void @exit(i32 1) #8
  unreachable

if.end20:                                         ; preds = %for.body13
  %23 = load double*, double** %ARRAY2.addr, align 4
  %24 = load i32, i32* %x9, align 4
  %arrayidx21 = getelementptr inbounds double, double* %23, i32 %24
  %25 = load double, double* %arrayidx21, align 8
  %26 = load double, double* %fmean2, align 8
  %add22 = fadd double %26, %25
  store double %add22, double* %fmean2, align 8
  br label %for.inc23

for.inc23:                                        ; preds = %if.end20
  %27 = load i32, i32* %x9, align 4
  %inc24 = add i32 %27, 1
  store i32 %inc24, i32* %x9, align 4
  br label %for.cond10

for.end25:                                        ; preds = %for.cond10
  %28 = load i32, i32* %ARRAY2_SIZE.addr, align 4
  %conv26 = uitofp i32 %28 to double
  %29 = load double, double* %fmean2, align 8
  %div27 = fdiv double %29, %conv26
  store double %div27, double* %fmean2, align 8
  %30 = load double, double* %fmean1, align 8
  %31 = load double, double* %fmean2, align 8
  %cmp28 = fcmp oeq double %30, %31
  br i1 %cmp28, label %if.then30, label %if.end31

if.then30:                                        ; preds = %for.end25
  store double 1.000000e+00, double* %retval, align 8
  br label %return

if.end31:                                         ; preds = %for.end25
  store double 0.000000e+00, double* %unbiased_sample_variance1, align 8
  store double 0.000000e+00, double* %unbiased_sample_variance2, align 8
  store i32 0, i32* %x32, align 4
  br label %for.cond33

for.cond33:                                       ; preds = %for.inc41, %if.end31
  %32 = load i32, i32* %x32, align 4
  %33 = load i32, i32* %ARRAY1_SIZE.addr, align 4
  %cmp34 = icmp ult i32 %32, %33
  br i1 %cmp34, label %for.body36, label %for.end43

for.body36:                                       ; preds = %for.cond33
  %34 = load double*, double** %ARRAY1.addr, align 4
  %35 = load i32, i32* %x32, align 4
  %arrayidx37 = getelementptr inbounds double, double* %34, i32 %35
  %36 = load double, double* %arrayidx37, align 8
  %37 = load double, double* %fmean1, align 8
  %sub = fsub double %36, %37
  %38 = load double*, double** %ARRAY1.addr, align 4
  %39 = load i32, i32* %x32, align 4
  %arrayidx38 = getelementptr inbounds double, double* %38, i32 %39
  %40 = load double, double* %arrayidx38, align 8
  %41 = load double, double* %fmean1, align 8
  %sub39 = fsub double %40, %41
  %mul = fmul double %sub, %sub39
  %42 = load double, double* %unbiased_sample_variance1, align 8
  %add40 = fadd double %42, %mul
  store double %add40, double* %unbiased_sample_variance1, align 8
  br label %for.inc41

for.inc41:                                        ; preds = %for.body36
  %43 = load i32, i32* %x32, align 4
  %inc42 = add i32 %43, 1
  store i32 %inc42, i32* %x32, align 4
  br label %for.cond33

for.end43:                                        ; preds = %for.cond33
  store i32 0, i32* %x44, align 4
  br label %for.cond45

for.cond45:                                       ; preds = %for.inc55, %for.end43
  %44 = load i32, i32* %x44, align 4
  %45 = load i32, i32* %ARRAY2_SIZE.addr, align 4
  %cmp46 = icmp ult i32 %44, %45
  br i1 %cmp46, label %for.body48, label %for.end57

for.body48:                                       ; preds = %for.cond45
  %46 = load double*, double** %ARRAY2.addr, align 4
  %47 = load i32, i32* %x44, align 4
  %arrayidx49 = getelementptr inbounds double, double* %46, i32 %47
  %48 = load double, double* %arrayidx49, align 8
  %49 = load double, double* %fmean2, align 8
  %sub50 = fsub double %48, %49
  %50 = load double*, double** %ARRAY2.addr, align 4
  %51 = load i32, i32* %x44, align 4
  %arrayidx51 = getelementptr inbounds double, double* %50, i32 %51
  %52 = load double, double* %arrayidx51, align 8
  %53 = load double, double* %fmean2, align 8
  %sub52 = fsub double %52, %53
  %mul53 = fmul double %sub50, %sub52
  %54 = load double, double* %unbiased_sample_variance2, align 8
  %add54 = fadd double %54, %mul53
  store double %add54, double* %unbiased_sample_variance2, align 8
  br label %for.inc55

for.inc55:                                        ; preds = %for.body48
  %55 = load i32, i32* %x44, align 4
  %inc56 = add i32 %55, 1
  store i32 %inc56, i32* %x44, align 4
  br label %for.cond45

for.end57:                                        ; preds = %for.cond45
  %56 = load double, double* %unbiased_sample_variance1, align 8
  %57 = load i32, i32* %ARRAY1_SIZE.addr, align 4
  %sub58 = sub i32 %57, 1
  %conv59 = uitofp i32 %sub58 to double
  %div60 = fdiv double %56, %conv59
  store double %div60, double* %unbiased_sample_variance1, align 8
  %58 = load double, double* %unbiased_sample_variance2, align 8
  %59 = load i32, i32* %ARRAY2_SIZE.addr, align 4
  %sub61 = sub i32 %59, 1
  %conv62 = uitofp i32 %sub61 to double
  %div63 = fdiv double %58, %conv62
  store double %div63, double* %unbiased_sample_variance2, align 8
  %60 = load double, double* %fmean1, align 8
  %61 = load double, double* %fmean2, align 8
  %sub64 = fsub double %60, %61
  %62 = load double, double* %unbiased_sample_variance1, align 8
  %63 = load i32, i32* %ARRAY1_SIZE.addr, align 4
  %conv65 = uitofp i32 %63 to double
  %div66 = fdiv double %62, %conv65
  %64 = load double, double* %unbiased_sample_variance2, align 8
  %65 = load i32, i32* %ARRAY2_SIZE.addr, align 4
  %conv67 = uitofp i32 %65 to double
  %div68 = fdiv double %64, %conv67
  %add69 = fadd double %div66, %div68
  %66 = call double @llvm.sqrt.f64(double %add69)
  %div70 = fdiv double %sub64, %66
  store double %div70, double* %WELCH_T_STATISTIC, align 8
  %67 = load double, double* %unbiased_sample_variance1, align 8
  %68 = load i32, i32* %ARRAY1_SIZE.addr, align 4
  %conv71 = uitofp i32 %68 to double
  %div72 = fdiv double %67, %conv71
  %69 = load double, double* %unbiased_sample_variance2, align 8
  %70 = load i32, i32* %ARRAY2_SIZE.addr, align 4
  %conv73 = uitofp i32 %70 to double
  %div74 = fdiv double %69, %conv73
  %add75 = fadd double %div72, %div74
  %71 = call double @llvm.pow.f64(double %add75, double 2.000000e+00)
  %72 = load double, double* %unbiased_sample_variance1, align 8
  %73 = load double, double* %unbiased_sample_variance1, align 8
  %mul76 = fmul double %72, %73
  %74 = load i32, i32* %ARRAY1_SIZE.addr, align 4
  %75 = load i32, i32* %ARRAY1_SIZE.addr, align 4
  %mul77 = mul i32 %74, %75
  %76 = load i32, i32* %ARRAY1_SIZE.addr, align 4
  %sub78 = sub i32 %76, 1
  %mul79 = mul i32 %mul77, %sub78
  %conv80 = uitofp i32 %mul79 to double
  %div81 = fdiv double %mul76, %conv80
  %77 = load double, double* %unbiased_sample_variance2, align 8
  %78 = load double, double* %unbiased_sample_variance2, align 8
  %mul82 = fmul double %77, %78
  %79 = load i32, i32* %ARRAY2_SIZE.addr, align 4
  %80 = load i32, i32* %ARRAY2_SIZE.addr, align 4
  %mul83 = mul i32 %79, %80
  %81 = load i32, i32* %ARRAY2_SIZE.addr, align 4
  %sub84 = sub i32 %81, 1
  %mul85 = mul i32 %mul83, %sub84
  %conv86 = uitofp i32 %mul85 to double
  %div87 = fdiv double %mul82, %conv86
  %add88 = fadd double %div81, %div87
  %div89 = fdiv double %71, %add88
  store double %div89, double* %DEGREES_OF_FREEDOM, align 8
  %82 = load double, double* %DEGREES_OF_FREEDOM, align 8
  %div90 = fdiv double %82, 2.000000e+00
  store double %div90, double* %a, align 8
  %83 = load double, double* %DEGREES_OF_FREEDOM, align 8
  %84 = load double, double* %WELCH_T_STATISTIC, align 8
  %85 = load double, double* %WELCH_T_STATISTIC, align 8
  %mul91 = fmul double %84, %85
  %86 = load double, double* %DEGREES_OF_FREEDOM, align 8
  %add92 = fadd double %mul91, %86
  %div93 = fdiv double %83, %add92
  store double %div93, double* %value, align 8
  %87 = load double, double* %value, align 8
  %88 = call double @llvm.fabs.f64(double %87) #7
  %cmpinf94 = fcmp oeq double %88, 0x7FF0000000000000
  br i1 %cmpinf94, label %if.then100, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %for.end57
  %89 = load double, double* %value, align 8
  %cmp97 = fcmp uno double %89, %89
  br i1 %cmp97, label %if.then100, label %if.end101

if.then100:                                       ; preds = %lor.lhs.false, %for.end57
  store double 1.000000e+00, double* %retval, align 8
  br label %return

if.end101:                                        ; preds = %lor.lhs.false
  %90 = load double, double* %value, align 8
  %91 = call double @llvm.fabs.f64(double %90) #7
  %cmpinf102 = fcmp oeq double %91, 0x7FF0000000000000
  br i1 %cmpinf102, label %if.then109, label %lor.lhs.false105

lor.lhs.false105:                                 ; preds = %if.end101
  %92 = load double, double* %value, align 8
  %cmp106 = fcmp uno double %92, %92
  br i1 %cmp106, label %if.then109, label %if.end110

if.then109:                                       ; preds = %lor.lhs.false105, %if.end101
  store double 1.000000e+00, double* %retval, align 8
  br label %return

if.end110:                                        ; preds = %lor.lhs.false105
  %93 = load double, double* %a, align 8
  %conv111 = fpext double %93 to fp128
  %call112 = call fp128 @lgammal(fp128 %conv111) #9
  %add113 = fadd fp128 %call112, 0xLD0000000000000003FFE250D048E7A1B
  %94 = load double, double* %a, align 8
  %add114 = fadd double %94, 5.000000e-01
  %conv115 = fpext double %add114 to fp128
  %call116 = call fp128 @lgammal(fp128 %conv115) #9
  %sub117 = fsub fp128 %add113, %call116
  %conv118 = fptrunc fp128 %sub117 to double
  store double %conv118, double* %beta, align 8
  store double 1.000000e-15, double* %acu, align 8
  %95 = load double, double* %a, align 8
  %cmp119 = fcmp ole double %95, 0.000000e+00
  br i1 %cmp119, label %if.then121, label %if.end122

if.then121:                                       ; preds = %if.end110
  br label %if.end122

if.end122:                                        ; preds = %if.then121, %if.end110
  %96 = load double, double* %value, align 8
  %cmp123 = fcmp olt double %96, 0.000000e+00
  br i1 %cmp123, label %if.then128, label %lor.lhs.false125

lor.lhs.false125:                                 ; preds = %if.end122
  %97 = load double, double* %value, align 8
  %cmp126 = fcmp olt double 1.000000e+00, %97
  br i1 %cmp126, label %if.then128, label %if.end129

if.then128:                                       ; preds = %lor.lhs.false125, %if.end122
  %98 = load double, double* %value, align 8
  store double %98, double* %retval, align 8
  br label %return

if.end129:                                        ; preds = %lor.lhs.false125
  %99 = load double, double* %value, align 8
  %cmp130 = fcmp oeq double %99, 0.000000e+00
  br i1 %cmp130, label %if.then135, label %lor.lhs.false132

lor.lhs.false132:                                 ; preds = %if.end129
  %100 = load double, double* %value, align 8
  %cmp133 = fcmp oeq double %100, 1.000000e+00
  br i1 %cmp133, label %if.then135, label %if.end136

if.then135:                                       ; preds = %lor.lhs.false132, %if.end129
  %101 = load double, double* %value, align 8
  store double %101, double* %retval, align 8
  br label %return

if.end136:                                        ; preds = %lor.lhs.false132
  %102 = load double, double* %a, align 8
  %add137 = fadd double %102, 5.000000e-01
  store double %add137, double* %psq, align 8
  %103 = load double, double* %value, align 8
  %sub138 = fsub double 1.000000e+00, %103
  store double %sub138, double* %cx, align 8
  %104 = load double, double* %a, align 8
  %105 = load double, double* %psq, align 8
  %106 = load double, double* %value, align 8
  %mul139 = fmul double %105, %106
  %cmp140 = fcmp olt double %104, %mul139
  br i1 %cmp140, label %if.then142, label %if.else143

if.then142:                                       ; preds = %if.end136
  %107 = load double, double* %cx, align 8
  store double %107, double* %xx, align 8
  %108 = load double, double* %value, align 8
  store double %108, double* %cx, align 8
  store double 5.000000e-01, double* %pp, align 8
  %109 = load double, double* %a, align 8
  store double %109, double* %qq, align 8
  store i32 1, i32* %indx, align 4
  br label %if.end144

if.else143:                                       ; preds = %if.end136
  %110 = load double, double* %value, align 8
  store double %110, double* %xx, align 8
  %111 = load double, double* %a, align 8
  store double %111, double* %pp, align 8
  store double 5.000000e-01, double* %qq, align 8
  store i32 0, i32* %indx, align 4
  br label %if.end144

if.end144:                                        ; preds = %if.else143, %if.then142
  store double 1.000000e+00, double* %term, align 8
  store double 1.000000e+00, double* %ai, align 8
  store double 1.000000e+00, double* %value, align 8
  %112 = load double, double* %qq, align 8
  %113 = load double, double* %cx, align 8
  %114 = load double, double* %psq, align 8
  %mul145 = fmul double %113, %114
  %add146 = fadd double %112, %mul145
  %conv147 = fptosi double %add146 to i32
  store i32 %conv147, i32* %ns, align 4
  %115 = load double, double* %xx, align 8
  %116 = load double, double* %cx, align 8
  %div148 = fdiv double %115, %116
  store double %div148, double* %rx, align 8
  %117 = load double, double* %qq, align 8
  %118 = load double, double* %ai, align 8
  %sub149 = fsub double %117, %118
  store double %sub149, double* %temp, align 8
  %119 = load i32, i32* %ns, align 4
  %cmp150 = icmp eq i32 %119, 0
  br i1 %cmp150, label %if.then152, label %if.end153

if.then152:                                       ; preds = %if.end144
  %120 = load double, double* %xx, align 8
  store double %120, double* %rx, align 8
  br label %if.end153

if.end153:                                        ; preds = %if.then152, %if.end144
  br label %for.cond154

for.cond154:                                      ; preds = %if.end189, %if.end153
  %121 = load double, double* %term, align 8
  %122 = load double, double* %temp, align 8
  %mul155 = fmul double %121, %122
  %123 = load double, double* %rx, align 8
  %mul156 = fmul double %mul155, %123
  %124 = load double, double* %pp, align 8
  %125 = load double, double* %ai, align 8
  %add157 = fadd double %124, %125
  %div158 = fdiv double %mul156, %add157
  store double %div158, double* %term, align 8
  %126 = load double, double* %value, align 8
  %127 = load double, double* %term, align 8
  %add159 = fadd double %126, %127
  store double %add159, double* %value, align 8
  %128 = load double, double* %term, align 8
  %129 = call double @llvm.fabs.f64(double %128)
  store double %129, double* %temp, align 8
  %130 = load double, double* %temp, align 8
  %cmp160 = fcmp ole double %130, 1.000000e-15
  br i1 %cmp160, label %land.lhs.true, label %if.end176

land.lhs.true:                                    ; preds = %for.cond154
  %131 = load double, double* %temp, align 8
  %132 = load double, double* %value, align 8
  %mul162 = fmul double 1.000000e-15, %132
  %cmp163 = fcmp ole double %131, %mul162
  br i1 %cmp163, label %if.then165, label %if.end176

if.then165:                                       ; preds = %land.lhs.true
  %133 = load double, double* %value, align 8
  %134 = load double, double* %pp, align 8
  %135 = load double, double* %xx, align 8
  %136 = call double @llvm.log.f64(double %135)
  %mul166 = fmul double %134, %136
  %137 = load double, double* %qq, align 8
  %sub167 = fsub double %137, 1.000000e+00
  %138 = load double, double* %cx, align 8
  %139 = call double @llvm.log.f64(double %138)
  %mul168 = fmul double %sub167, %139
  %add169 = fadd double %mul166, %mul168
  %140 = load double, double* %beta, align 8
  %sub170 = fsub double %add169, %140
  %141 = call double @llvm.exp.f64(double %sub170)
  %mul171 = fmul double %133, %141
  %142 = load double, double* %pp, align 8
  %div172 = fdiv double %mul171, %142
  store double %div172, double* %value, align 8
  %143 = load i32, i32* %indx, align 4
  %tobool = icmp ne i32 %143, 0
  br i1 %tobool, label %if.then173, label %if.end175

if.then173:                                       ; preds = %if.then165
  %144 = load double, double* %value, align 8
  %sub174 = fsub double 1.000000e+00, %144
  store double %sub174, double* %value, align 8
  br label %if.end175

if.end175:                                        ; preds = %if.then173, %if.then165
  br label %for.end190

if.end176:                                        ; preds = %land.lhs.true, %for.cond154
  %145 = load double, double* %ai, align 8
  %add177 = fadd double %145, 1.000000e+00
  store double %add177, double* %ai, align 8
  %146 = load i32, i32* %ns, align 4
  %sub178 = sub nsw i32 %146, 1
  store i32 %sub178, i32* %ns, align 4
  %147 = load i32, i32* %ns, align 4
  %cmp179 = icmp sle i32 0, %147
  br i1 %cmp179, label %if.then181, label %if.else187

if.then181:                                       ; preds = %if.end176
  %148 = load double, double* %qq, align 8
  %149 = load double, double* %ai, align 8
  %sub182 = fsub double %148, %149
  store double %sub182, double* %temp, align 8
  %150 = load i32, i32* %ns, align 4
  %cmp183 = icmp eq i32 %150, 0
  br i1 %cmp183, label %if.then185, label %if.end186

if.then185:                                       ; preds = %if.then181
  %151 = load double, double* %xx, align 8
  store double %151, double* %rx, align 8
  br label %if.end186

if.end186:                                        ; preds = %if.then185, %if.then181
  br label %if.end189

if.else187:                                       ; preds = %if.end176
  %152 = load double, double* %psq, align 8
  store double %152, double* %temp, align 8
  %153 = load double, double* %psq, align 8
  %add188 = fadd double %153, 1.000000e+00
  store double %add188, double* %psq, align 8
  br label %if.end189

if.end189:                                        ; preds = %if.else187, %if.end186
  br label %for.cond154

for.end190:                                       ; preds = %if.end175
  %154 = load double, double* %value, align 8
  store double %154, double* %retval, align 8
  br label %return

return:                                           ; preds = %for.end190, %if.then135, %if.then128, %if.then109, %if.then100, %if.then30, %if.then2, %if.then
  %155 = load double, double* %retval, align 8
  ret double %155
}

; Function Attrs: nounwind readnone speculatable willreturn
declare double @llvm.fabs.f64(double %0) #1

declare i32 @puts(i8* %0) #2

; Function Attrs: noreturn
declare void @exit(i32 %0) #3

; Function Attrs: nounwind readnone speculatable willreturn
declare double @llvm.sqrt.f64(double %0) #1

; Function Attrs: nounwind readnone speculatable willreturn
declare double @llvm.pow.f64(double %0, double %1) #1

; Function Attrs: nounwind
declare fp128 @lgammal(fp128 %0) #4

; Function Attrs: nounwind readnone speculatable willreturn
declare double @llvm.log.f64(double %0) #1

; Function Attrs: nounwind readnone speculatable willreturn
declare double @llvm.exp.f64(double %0) #1

; Function Attrs: noinline nounwind optnone
define hidden i32 @main() #0 {
entry:
  %retval = alloca i32, align 4
  %d1 = alloca [15 x double], align 16
  %d2 = alloca [15 x double], align 16
  %d3 = alloca [10 x double], align 16
  %d4 = alloca [20 x double], align 16
  %d5 = alloca [10 x double], align 16
  %d6 = alloca [20 x double], align 16
  %d7 = alloca [6 x double], align 16
  %d8 = alloca [6 x double], align 16
  %x = alloca [4 x double], align 16
  %y = alloca [3 x double], align 16
  %v1 = alloca [3 x double], align 16
  %v2 = alloca [3 x double], align 16
  %s1 = alloca [2 x double], align 16
  %s2 = alloca [2 x double], align 16
  %z1 = alloca [3 x double], align 16
  %z2 = alloca [3 x double], align 16
  %CORRECT_ANSWERS = alloca [8 x double], align 16
  %pvalue = alloca double, align 8
  %error = alloca double, align 8
  store i32 0, i32* %retval, align 4
  %0 = bitcast [15 x double]* %d1 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 16 %0, i8* align 16 bitcast ([15 x double]* @__const.main.d1 to i8*), i32 120, i1 false)
  %1 = bitcast [15 x double]* %d2 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 16 %1, i8* align 16 bitcast ([15 x double]* @__const.main.d2 to i8*), i32 120, i1 false)
  %2 = bitcast [10 x double]* %d3 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 16 %2, i8* align 16 bitcast ([10 x double]* @__const.main.d3 to i8*), i32 80, i1 false)
  %3 = bitcast [20 x double]* %d4 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 16 %3, i8* align 16 bitcast ([20 x double]* @__const.main.d4 to i8*), i32 160, i1 false)
  %4 = bitcast [10 x double]* %d5 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 16 %4, i8* align 16 bitcast ([10 x double]* @__const.main.d5 to i8*), i32 80, i1 false)
  %5 = bitcast [20 x double]* %d6 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 16 %5, i8* align 16 bitcast ([20 x double]* @__const.main.d6 to i8*), i32 160, i1 false)
  %6 = bitcast [6 x double]* %d7 to i8*
  call void @llvm.memset.p0i8.i32(i8* align 16 %6, i8 0, i32 48, i1 false)
  %7 = bitcast i8* %6 to [6 x double]*
  %8 = getelementptr inbounds [6 x double], [6 x double]* %7, i32 0, i32 0
  store double 3.002000e+01, double* %8, align 16
  %9 = getelementptr inbounds [6 x double], [6 x double]* %7, i32 0, i32 1
  store double 2.999000e+01, double* %9, align 8
  %10 = getelementptr inbounds [6 x double], [6 x double]* %7, i32 0, i32 2
  store double 3.011000e+01, double* %10, align 16
  %11 = getelementptr inbounds [6 x double], [6 x double]* %7, i32 0, i32 3
  store double 2.997000e+01, double* %11, align 8
  %12 = getelementptr inbounds [6 x double], [6 x double]* %7, i32 0, i32 4
  store double 3.001000e+01, double* %12, align 16
  %13 = getelementptr inbounds [6 x double], [6 x double]* %7, i32 0, i32 5
  store double 2.999000e+01, double* %13, align 8
  %14 = bitcast [6 x double]* %d8 to i8*
  call void @llvm.memset.p0i8.i32(i8* align 16 %14, i8 0, i32 48, i1 false)
  %15 = bitcast i8* %14 to [6 x double]*
  %16 = getelementptr inbounds [6 x double], [6 x double]* %15, i32 0, i32 0
  store double 2.989000e+01, double* %16, align 16
  %17 = getelementptr inbounds [6 x double], [6 x double]* %15, i32 0, i32 1
  store double 2.993000e+01, double* %17, align 8
  %18 = getelementptr inbounds [6 x double], [6 x double]* %15, i32 0, i32 2
  store double 2.972000e+01, double* %18, align 16
  %19 = getelementptr inbounds [6 x double], [6 x double]* %15, i32 0, i32 3
  store double 2.998000e+01, double* %19, align 8
  %20 = getelementptr inbounds [6 x double], [6 x double]* %15, i32 0, i32 4
  store double 3.002000e+01, double* %20, align 16
  %21 = getelementptr inbounds [6 x double], [6 x double]* %15, i32 0, i32 5
  store double 2.998000e+01, double* %21, align 8
  %22 = bitcast [4 x double]* %x to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 16 %22, i8* align 16 bitcast ([4 x double]* @__const.main.x to i8*), i32 32, i1 false)
  %23 = bitcast [3 x double]* %y to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 16 %23, i8* align 16 bitcast ([3 x double]* @__const.main.y to i8*), i32 24, i1 false)
  %24 = bitcast [3 x double]* %v1 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 16 %24, i8* align 16 bitcast ([3 x double]* @__const.main.v1 to i8*), i32 24, i1 false)
  %25 = bitcast [3 x double]* %v2 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 16 %25, i8* align 16 bitcast ([3 x double]* @__const.main.v2 to i8*), i32 24, i1 false)
  %26 = bitcast [2 x double]* %s1 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 16 %26, i8* align 16 bitcast ([2 x double]* @__const.main.s1 to i8*), i32 16, i1 false)
  %27 = bitcast [2 x double]* %s2 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 16 %27, i8* align 16 bitcast ([2 x double]* @__const.main.s2 to i8*), i32 16, i1 false)
  %28 = bitcast [3 x double]* %z1 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 16 %28, i8* align 16 bitcast ([3 x double]* @__const.main.z1 to i8*), i32 24, i1 false)
  %29 = bitcast [3 x double]* %z2 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 16 %29, i8* align 16 bitcast ([3 x double]* @__const.main.z2 to i8*), i32 24, i1 false)
  %30 = bitcast [8 x double]* %CORRECT_ANSWERS to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 16 %30, i8* align 16 bitcast ([8 x double]* @__const.main.CORRECT_ANSWERS to i8*), i32 64, i1 false)
  %arraydecay = getelementptr inbounds [15 x double], [15 x double]* %d1, i32 0, i32 0
  %arraydecay1 = getelementptr inbounds [15 x double], [15 x double]* %d2, i32 0, i32 0
  %call = call double @Pvalue(double* %arraydecay, i32 15, double* %arraydecay1, i32 15)
  store double %call, double* %pvalue, align 8
  %31 = load double, double* %pvalue, align 8
  %arrayidx = getelementptr inbounds [8 x double], [8 x double]* %CORRECT_ANSWERS, i32 0, i32 0
  %32 = load double, double* %arrayidx, align 16
  %sub = fsub double %31, %32
  %33 = call double @llvm.fabs.f64(double %sub)
  store double %33, double* %error, align 8
  %34 = load double, double* %pvalue, align 8
  %call2 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([26 x i8], [26 x i8]* @.str.2, i32 0, i32 0), double %34)
  %arraydecay3 = getelementptr inbounds [10 x double], [10 x double]* %d3, i32 0, i32 0
  %arraydecay4 = getelementptr inbounds [20 x double], [20 x double]* %d4, i32 0, i32 0
  %call5 = call double @Pvalue(double* %arraydecay3, i32 10, double* %arraydecay4, i32 20)
  store double %call5, double* %pvalue, align 8
  %35 = load double, double* %pvalue, align 8
  %arrayidx6 = getelementptr inbounds [8 x double], [8 x double]* %CORRECT_ANSWERS, i32 0, i32 1
  %36 = load double, double* %arrayidx6, align 8
  %sub7 = fsub double %35, %36
  %37 = call double @llvm.fabs.f64(double %sub7)
  %38 = load double, double* %error, align 8
  %add = fadd double %38, %37
  store double %add, double* %error, align 8
  %39 = load double, double* %pvalue, align 8
  %call8 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([26 x i8], [26 x i8]* @.str.3, i32 0, i32 0), double %39)
  %arraydecay9 = getelementptr inbounds [10 x double], [10 x double]* %d5, i32 0, i32 0
  %arraydecay10 = getelementptr inbounds [20 x double], [20 x double]* %d6, i32 0, i32 0
  %call11 = call double @Pvalue(double* %arraydecay9, i32 10, double* %arraydecay10, i32 20)
  store double %call11, double* %pvalue, align 8
  %40 = load double, double* %pvalue, align 8
  %arrayidx12 = getelementptr inbounds [8 x double], [8 x double]* %CORRECT_ANSWERS, i32 0, i32 2
  %41 = load double, double* %arrayidx12, align 16
  %sub13 = fsub double %40, %41
  %42 = call double @llvm.fabs.f64(double %sub13)
  %43 = load double, double* %error, align 8
  %add14 = fadd double %43, %42
  store double %add14, double* %error, align 8
  %44 = load double, double* %pvalue, align 8
  %call15 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([26 x i8], [26 x i8]* @.str.4, i32 0, i32 0), double %44)
  %arraydecay16 = getelementptr inbounds [6 x double], [6 x double]* %d7, i32 0, i32 0
  %arraydecay17 = getelementptr inbounds [6 x double], [6 x double]* %d8, i32 0, i32 0
  %call18 = call double @Pvalue(double* %arraydecay16, i32 6, double* %arraydecay17, i32 6)
  store double %call18, double* %pvalue, align 8
  %45 = load double, double* %pvalue, align 8
  %call19 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([26 x i8], [26 x i8]* @.str.5, i32 0, i32 0), double %45)
  %46 = load double, double* %pvalue, align 8
  %arrayidx20 = getelementptr inbounds [8 x double], [8 x double]* %CORRECT_ANSWERS, i32 0, i32 3
  %47 = load double, double* %arrayidx20, align 8
  %sub21 = fsub double %46, %47
  %48 = call double @llvm.fabs.f64(double %sub21)
  %49 = load double, double* %error, align 8
  %add22 = fadd double %49, %48
  store double %add22, double* %error, align 8
  %arraydecay23 = getelementptr inbounds [4 x double], [4 x double]* %x, i32 0, i32 0
  %arraydecay24 = getelementptr inbounds [3 x double], [3 x double]* %y, i32 0, i32 0
  %call25 = call double @Pvalue(double* %arraydecay23, i32 4, double* %arraydecay24, i32 3)
  store double %call25, double* %pvalue, align 8
  %50 = load double, double* %pvalue, align 8
  %arrayidx26 = getelementptr inbounds [8 x double], [8 x double]* %CORRECT_ANSWERS, i32 0, i32 4
  %51 = load double, double* %arrayidx26, align 16
  %sub27 = fsub double %50, %51
  %52 = call double @llvm.fabs.f64(double %sub27)
  %53 = load double, double* %error, align 8
  %add28 = fadd double %53, %52
  store double %add28, double* %error, align 8
  %54 = load double, double* %pvalue, align 8
  %call29 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([26 x i8], [26 x i8]* @.str.6, i32 0, i32 0), double %54)
  %arraydecay30 = getelementptr inbounds [3 x double], [3 x double]* %v1, i32 0, i32 0
  %arraydecay31 = getelementptr inbounds [3 x double], [3 x double]* %v2, i32 0, i32 0
  %call32 = call double @Pvalue(double* %arraydecay30, i32 3, double* %arraydecay31, i32 3)
  store double %call32, double* %pvalue, align 8
  %55 = load double, double* %pvalue, align 8
  %arrayidx33 = getelementptr inbounds [8 x double], [8 x double]* %CORRECT_ANSWERS, i32 0, i32 5
  %56 = load double, double* %arrayidx33, align 8
  %sub34 = fsub double %55, %56
  %57 = call double @llvm.fabs.f64(double %sub34)
  %58 = load double, double* %error, align 8
  %add35 = fadd double %58, %57
  store double %add35, double* %error, align 8
  %59 = load double, double* %pvalue, align 8
  %call36 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([26 x i8], [26 x i8]* @.str.7, i32 0, i32 0), double %59)
  %arraydecay37 = getelementptr inbounds [2 x double], [2 x double]* %s1, i32 0, i32 0
  %arraydecay38 = getelementptr inbounds [2 x double], [2 x double]* %s2, i32 0, i32 0
  %call39 = call double @Pvalue(double* %arraydecay37, i32 2, double* %arraydecay38, i32 2)
  store double %call39, double* %pvalue, align 8
  %60 = load double, double* %pvalue, align 8
  %arrayidx40 = getelementptr inbounds [8 x double], [8 x double]* %CORRECT_ANSWERS, i32 0, i32 6
  %61 = load double, double* %arrayidx40, align 16
  %sub41 = fsub double %60, %61
  %62 = call double @llvm.fabs.f64(double %sub41)
  %63 = load double, double* %error, align 8
  %add42 = fadd double %63, %62
  store double %add42, double* %error, align 8
  %64 = load double, double* %pvalue, align 8
  %call43 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([26 x i8], [26 x i8]* @.str.8, i32 0, i32 0), double %64)
  %arraydecay44 = getelementptr inbounds [3 x double], [3 x double]* %z1, i32 0, i32 0
  %arraydecay45 = getelementptr inbounds [3 x double], [3 x double]* %z2, i32 0, i32 0
  %call46 = call double @Pvalue(double* %arraydecay44, i32 3, double* %arraydecay45, i32 3)
  store double %call46, double* %pvalue, align 8
  %65 = load double, double* %pvalue, align 8
  %arrayidx47 = getelementptr inbounds [8 x double], [8 x double]* %CORRECT_ANSWERS, i32 0, i32 7
  %66 = load double, double* %arrayidx47, align 8
  %sub48 = fsub double %65, %66
  %67 = call double @llvm.fabs.f64(double %sub48)
  %68 = load double, double* %error, align 8
  %add49 = fadd double %68, %67
  store double %add49, double* %error, align 8
  %69 = load double, double* %pvalue, align 8
  %call50 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([26 x i8], [26 x i8]* @.str.9, i32 0, i32 0), double %69)
  %70 = load double, double* %error, align 8
  %call51 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([28 x i8], [28 x i8]* @.str.10, i32 0, i32 0), double %70)
  ret i32 0
}

; Function Attrs: argmemonly nounwind willreturn
declare void @llvm.memcpy.p0i8.p0i8.i32(i8* noalias nocapture writeonly %0, i8* noalias nocapture readonly %1, i32 %2, i1 immarg %3) #5

; Function Attrs: argmemonly nounwind willreturn writeonly
declare void @llvm.memset.p0i8.i32(i8* nocapture writeonly %0, i8 %1, i32 %2, i1 immarg %3) #6

declare i32 @printf(i8* %0, ...) #2

attributes #0 = { noinline nounwind optnone "correctly-rounded-divide-sqrt-fp-math"="false" "disable-tail-calls"="false" "frame-pointer"="none" "less-precise-fpmad"="false" "min-legal-vector-width"="0" "no-infs-fp-math"="false" "no-jump-tables"="false" "no-nans-fp-math"="false" "no-signed-zeros-fp-math"="false" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="generic" "unsafe-fp-math"="false" "use-soft-float"="false" }
attributes #1 = { nounwind readnone speculatable willreturn }
attributes #2 = { "correctly-rounded-divide-sqrt-fp-math"="false" "disable-tail-calls"="false" "frame-pointer"="none" "less-precise-fpmad"="false" "no-infs-fp-math"="false" "no-nans-fp-math"="false" "no-signed-zeros-fp-math"="false" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="generic" "unsafe-fp-math"="false" "use-soft-float"="false" }
attributes #3 = { noreturn "correctly-rounded-divide-sqrt-fp-math"="false" "disable-tail-calls"="false" "frame-pointer"="none" "less-precise-fpmad"="false" "no-infs-fp-math"="false" "no-nans-fp-math"="false" "no-signed-zeros-fp-math"="false" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="generic" "unsafe-fp-math"="false" "use-soft-float"="false" }
attributes #4 = { nounwind "correctly-rounded-divide-sqrt-fp-math"="false" "disable-tail-calls"="false" "frame-pointer"="none" "less-precise-fpmad"="false" "no-infs-fp-math"="false" "no-nans-fp-math"="false" "no-signed-zeros-fp-math"="false" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="generic" "unsafe-fp-math"="false" "use-soft-float"="false" }
attributes #5 = { argmemonly nounwind willreturn }
attributes #6 = { argmemonly nounwind willreturn writeonly }
attributes #7 = { readnone }
attributes #8 = { noreturn }
attributes #9 = { nounwind }

!llvm.module.flags = !{!0}
!llvm.ident = !{!1}

!0 = !{i32 1, !"wchar_size", i32 4}
!1 = !{!"clang version 11.0.0 (https://github.com/Jacarte/llvm-project.git 0f6dea67136cc1e0b3d200eb2bb165628970c44b)"}

; extracted candidates

; *****
; For LLVM instruction:
;  %0 = load i32, i32* %ARRAY1_SIZE.addr, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %cmp = icmp ule i32 %0, 1
; Looking for a replacement for:
%0:i32 = var
%1:i1 = ule %0, 1:i32
infer %1

; *****
; For LLVM instruction:
;  %1 = load i32, i32* %ARRAY2_SIZE.addr, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %cmp1 = icmp ule i32 %1, 1
; Looking for a replacement for:
%0:i32 = var
%1:i1 = ule %0, 1:i32
infer %1

; *****
; For LLVM instruction:
;  %2 = load i32, i32* %x, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %3 = load i32, i32* %ARRAY1_SIZE.addr, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %cmp4 = icmp ult i32 %2, %3
; Looking for a replacement for:
%0:i32 = var
%1:i32 = var
%2:i1 = ult %0, %1
infer %2

; *****
; For LLVM instruction:
;  %5 = load i32, i32* %x, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %cmpinf = fcmp one double %7, 0x7FF0000000000000
; Looking for a replacement for:
%0:i1 = var
infer %0

; *****
; For LLVM instruction:
;  %8 = zext i1 %cmpinf to i32
; Looking for a replacement for:
%0:i1 = var
%1:i32 = zext %0
infer %1

; *****
; For LLVM instruction:
;  %cmp5 = icmp eq i32 %8, 0
; Looking for a replacement for:
%0:i1 = var
%1:i32 = zext %0
%2:i1 = eq 0:i32, %1
infer %2

; *****
; For LLVM instruction:
;  %10 = load i32, i32* %x, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %13 = load i32, i32* %x, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %inc = add i32 %13, 1
; Looking for a replacement for:
%0:i32 = var
%1:i32 = add 1:i32, %0
infer %1

; *****
; For LLVM instruction:
;  %14 = load i32, i32* %ARRAY1_SIZE.addr, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %16 = load i32, i32* %x9, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %17 = load i32, i32* %ARRAY2_SIZE.addr, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %cmp11 = icmp ult i32 %16, %17
; Looking for a replacement for:
%0:i32 = var
%1:i32 = var
%2:i1 = ult %0, %1
infer %2

; *****
; For LLVM instruction:
;  %19 = load i32, i32* %x9, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %cmpinf15 = fcmp one double %21, 0x7FF0000000000000
; Looking for a replacement for:
%0:i1 = var
infer %0

; *****
; For LLVM instruction:
;  %22 = zext i1 %cmpinf15 to i32
; Looking for a replacement for:
%0:i1 = var
%1:i32 = zext %0
infer %1

; *****
; For LLVM instruction:
;  %cmp16 = icmp eq i32 %22, 0
; Looking for a replacement for:
%0:i1 = var
%1:i32 = zext %0
%2:i1 = eq 0:i32, %1
infer %2

; *****
; For LLVM instruction:
;  %24 = load i32, i32* %x9, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %27 = load i32, i32* %x9, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %inc24 = add i32 %27, 1
; Looking for a replacement for:
%0:i32 = var
%1:i32 = add 1:i32, %0
infer %1

; *****
; For LLVM instruction:
;  %28 = load i32, i32* %ARRAY2_SIZE.addr, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %cmp28 = fcmp oeq double %30, %31
; Looking for a replacement for:
%0:i1 = var
infer %0

; *****
; For LLVM instruction:
;  %32 = load i32, i32* %x32, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %33 = load i32, i32* %ARRAY1_SIZE.addr, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %cmp34 = icmp ult i32 %32, %33
; Looking for a replacement for:
%0:i32 = var
%1:i32 = var
%2:i1 = ult %0, %1
infer %2

; *****
; For LLVM instruction:
;  %35 = load i32, i32* %x32, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %39 = load i32, i32* %x32, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %43 = load i32, i32* %x32, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %inc42 = add i32 %43, 1
; Looking for a replacement for:
%0:i32 = var
%1:i32 = add 1:i32, %0
infer %1

; *****
; For LLVM instruction:
;  %44 = load i32, i32* %x44, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %45 = load i32, i32* %ARRAY2_SIZE.addr, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %cmp46 = icmp ult i32 %44, %45
; Looking for a replacement for:
%0:i32 = var
%1:i32 = var
%2:i1 = ult %0, %1
infer %2

; *****
; For LLVM instruction:
;  %47 = load i32, i32* %x44, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %51 = load i32, i32* %x44, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %55 = load i32, i32* %x44, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %inc56 = add i32 %55, 1
; Looking for a replacement for:
%0:i32 = var
%1:i32 = add 1:i32, %0
infer %1

; *****
; For LLVM instruction:
;  %57 = load i32, i32* %ARRAY1_SIZE.addr, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %sub58 = sub i32 %57, 1
; Looking for a replacement for:
%0:i32 = var
%1:i32 = sub %0, 1:i32
infer %1

; *****
; For LLVM instruction:
;  %59 = load i32, i32* %ARRAY2_SIZE.addr, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %sub61 = sub i32 %59, 1
; Looking for a replacement for:
%0:i32 = var
%1:i32 = sub %0, 1:i32
infer %1

; *****
; For LLVM instruction:
;  %63 = load i32, i32* %ARRAY1_SIZE.addr, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %65 = load i32, i32* %ARRAY2_SIZE.addr, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %68 = load i32, i32* %ARRAY1_SIZE.addr, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %70 = load i32, i32* %ARRAY2_SIZE.addr, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %74 = load i32, i32* %ARRAY1_SIZE.addr, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %75 = load i32, i32* %ARRAY1_SIZE.addr, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %mul77 = mul i32 %74, %75
; Looking for a replacement for:
%0:i32 = var
%1:i32 = var
%2:i32 = mul %0, %1
infer %2

; *****
; For LLVM instruction:
;  %76 = load i32, i32* %ARRAY1_SIZE.addr, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %sub78 = sub i32 %76, 1
; Looking for a replacement for:
%0:i32 = var
%1:i32 = sub %0, 1:i32
infer %1

; *****
; For LLVM instruction:
;  %mul79 = mul i32 %mul77, %sub78
; Looking for a replacement for:
%0:i32 = var
%1:i32 = sub %0, 1:i32
%2:i32 = var
%3:i32 = var
%4:i32 = mul %2, %3
%5:i32 = mul %1, %4
infer %5

; *****
; For LLVM instruction:
;  %79 = load i32, i32* %ARRAY2_SIZE.addr, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %80 = load i32, i32* %ARRAY2_SIZE.addr, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %mul83 = mul i32 %79, %80
; Looking for a replacement for:
%0:i32 = var
%1:i32 = var
%2:i32 = mul %0, %1
infer %2

; *****
; For LLVM instruction:
;  %81 = load i32, i32* %ARRAY2_SIZE.addr, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %sub84 = sub i32 %81, 1
; Looking for a replacement for:
%0:i32 = var
%1:i32 = sub %0, 1:i32
infer %1

; *****
; For LLVM instruction:
;  %mul85 = mul i32 %mul83, %sub84
; Looking for a replacement for:
%0:i32 = var
%1:i32 = sub %0, 1:i32
%2:i32 = var
%3:i32 = var
%4:i32 = mul %2, %3
%5:i32 = mul %1, %4
infer %5

; *****
; For LLVM instruction:
;  %cmpinf94 = fcmp oeq double %88, 0x7FF0000000000000
; Looking for a replacement for:
%0:i1 = var
infer %0

; *****
; For LLVM instruction:
;  %cmp97 = fcmp uno double %89, %89
; Looking for a replacement for:
%0:i1 = var
infer %0

; *****
; For LLVM instruction:
;  %cmpinf102 = fcmp oeq double %91, 0x7FF0000000000000
; Looking for a replacement for:
%0:i1 = var
infer %0

; *****
; For LLVM instruction:
;  %cmp106 = fcmp uno double %92, %92
; Looking for a replacement for:
%0:i1 = var
infer %0

; *****
; For LLVM instruction:
;  %cmp119 = fcmp ole double %95, 0.000000e+00
; Looking for a replacement for:
%0:i1 = var
infer %0

; *****
; For LLVM instruction:
;  %cmp123 = fcmp olt double %96, 0.000000e+00
; Looking for a replacement for:
%0:i1 = var
infer %0

; *****
; For LLVM instruction:
;  %cmp126 = fcmp olt double 1.000000e+00, %97
; Looking for a replacement for:
%0:i1 = var
infer %0

; *****
; For LLVM instruction:
;  %cmp130 = fcmp oeq double %99, 0.000000e+00
; Looking for a replacement for:
%0:i1 = var
infer %0

; *****
; For LLVM instruction:
;  %cmp133 = fcmp oeq double %100, 1.000000e+00
; Looking for a replacement for:
%0:i1 = var
infer %0

; *****
; For LLVM instruction:
;  %cmp140 = fcmp olt double %104, %mul139
; Looking for a replacement for:
%0:i1 = var
infer %0

; *****
; For LLVM instruction:
;  %conv147 = fptosi double %add146 to i32
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %119 = load i32, i32* %ns, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %cmp150 = icmp eq i32 %119, 0
; Looking for a replacement for:
%0:i32 = var
%1:i1 = eq 0:i32, %0
infer %1

; *****
; For LLVM instruction:
;  %cmp160 = fcmp ole double %130, 1.000000e-15
; Looking for a replacement for:
%0:i1 = var
infer %0

; *****
; For LLVM instruction:
;  %cmp163 = fcmp ole double %131, %mul162
; Looking for a replacement for:
%0:i1 = var
infer %0

; *****
; For LLVM instruction:
;  %143 = load i32, i32* %indx, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %tobool = icmp ne i32 %143, 0
; Looking for a replacement for:
%0:i32 = var
%1:i1 = ne 0:i32, %0
infer %1

; *****
; For LLVM instruction:
;  %146 = load i32, i32* %ns, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %sub178 = sub nsw i32 %146, 1
; Looking for a replacement for:
%0:i32 = var
%1:i32 = subnsw %0, 1:i32
infer %1

; *****
; For LLVM instruction:
;  %147 = load i32, i32* %ns, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %cmp179 = icmp sle i32 0, %147
; Looking for a replacement for:
%0:i32 = var
%1:i1 = sle 0:i32, %0
infer %1

; *****
; For LLVM instruction:
;  %150 = load i32, i32* %ns, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %cmp183 = icmp eq i32 %150, 0
; Looking for a replacement for:
%0:i32 = var
%1:i1 = eq 0:i32, %0
infer %1
got 2 candidates from LHS

-------------------------------------------------
%0:i32 = var
%1:i1 = eq 0:i32, %0
infer %1


--------------------------------
guess 0

%0:i1 = var ; reservedconst_1

Cost = 0
first query is SAT, returning the model:
reservedconst_1: -1
0 th attempt: second query is SAT-- constant doesn't work
first query is SAT, returning the model:
reservedconst_1: 0
1 th attempt: second query is SAT-- constant doesn't work
first query is UNSAT-- no more guesses
Dataflow Pruned 0/0
There are 1 Guesses
There are 0 RHSs before deduplication
There are 0 RHSs after deduplication
got 2 candidates from LHS

-------------------------------------------------
%0:i32 = var
%1:i1 = ne 0:i32, %0
infer %1


--------------------------------
guess 0

%0:i1 = var ; reservedconst_1

Cost = 0
first query is SAT, returning the model:
reservedconst_1: 0
0 th attempt: second query is SAT-- constant doesn't work
first query is SAT, returning the model:
reservedconst_1: -1
1 th attempt: second query is SAT-- constant doesn't work
first query is UNSAT-- no more guesses
Dataflow Pruned 0/0
There are 1 Guesses
There are 0 RHSs before deduplication
There are 0 RHSs after deduplication
got 2 candidates from LHS

-------------------------------------------------
%0:i32 = var
%1:i32 = subnsw %0, 1:i32
infer %1


--------------------------------
guess 0

%0:i32 = var ; reservedconst_1

Cost = 0
first query is SAT, returning the model:
reservedconst_1: -1
0 th attempt: second query is SAT-- constant doesn't work
first query is SAT, returning the model:
reservedconst_1: 536870911
1 th attempt: second query is SAT-- constant doesn't work
first query is UNSAT-- no more guesses

--------------------------------
guess 1

%0:i32 = var

Cost = 0
second query is SAT-- constant doesn't work
Dataflow Pruned 0/0
There are 2 Guesses
There are 0 RHSs before deduplication
There are 0 RHSs after deduplication
got 2 candidates from LHS

-------------------------------------------------
%0:i32 = var
%1:i1 = sle 0:i32, %0
infer %1


--------------------------------
guess 0

%0:i1 = var ; reservedconst_1

Cost = 0
first query is SAT, returning the model:
reservedconst_1: -1
0 th attempt: second query is SAT-- constant doesn't work
first query is SAT, returning the model:
reservedconst_1: 0
1 th attempt: second query is SAT-- constant doesn't work
first query is UNSAT-- no more guesses
Dataflow Pruned 0/0
There are 1 Guesses
There are 0 RHSs before deduplication
There are 0 RHSs after deduplication
#########################################################
; exiting Souper's runOnFunction() for Pvalue()

; entering Souper's runOnFunction() for main()

; ModuleID = './Welchs_t-test.c.bc'
source_filename = "./Welchs_t-test.c"
target datalayout = "e-m:e-p:32:32-i64:64-n32:64-S128"
target triple = "wasm32-unknown-wasi"

@.str = private unnamed_addr constant [63 x i8] c"Got a non-finite number in 1st array, can't calculate P-value.\00", align 1
@.str.1 = private unnamed_addr constant [63 x i8] c"Got a non-finite number in 2nd array, can't calculate P-value.\00", align 1
@__const.main.d1 = private unnamed_addr constant [15 x double] [double 2.750000e+01, double 2.100000e+01, double 1.900000e+01, double 2.360000e+01, double 1.700000e+01, double 1.790000e+01, double 1.690000e+01, double 2.010000e+01, double 2.190000e+01, double 2.260000e+01, double 2.310000e+01, double 1.960000e+01, double 1.900000e+01, double 2.170000e+01, double 2.140000e+01], align 16
@__const.main.d2 = private unnamed_addr constant [15 x double] [double 2.710000e+01, double 2.200000e+01, double 2.080000e+01, double 2.340000e+01, double 2.340000e+01, double 2.350000e+01, double 2.580000e+01, double 2.200000e+01, double 2.480000e+01, double 2.020000e+01, double 2.190000e+01, double 2.210000e+01, double 2.290000e+01, double 2.050000e+01, double 2.440000e+01], align 16
@__const.main.d3 = private unnamed_addr constant [10 x double] [double 1.720000e+01, double 2.090000e+01, double 2.260000e+01, double 1.810000e+01, double 2.170000e+01, double 2.140000e+01, double 2.350000e+01, double 2.420000e+01, double 1.470000e+01, double 2.180000e+01], align 16
@__const.main.d4 = private unnamed_addr constant [20 x double] [double 2.150000e+01, double 2.280000e+01, double 2.100000e+01, double 2.300000e+01, double 2.160000e+01, double 2.360000e+01, double 2.250000e+01, double 2.070000e+01, double 2.340000e+01, double 2.180000e+01, double 2.070000e+01, double 2.170000e+01, double 2.150000e+01, double 2.250000e+01, double 2.360000e+01, double 2.150000e+01, double 2.250000e+01, double 2.350000e+01, double 2.150000e+01, double 2.180000e+01], align 16
@__const.main.d5 = private unnamed_addr constant [10 x double] [double 1.980000e+01, double 2.040000e+01, double 1.960000e+01, double 1.780000e+01, double 1.850000e+01, double 1.890000e+01, double 1.830000e+01, double 1.890000e+01, double 1.950000e+01, double 2.200000e+01], align 16
@__const.main.d6 = private unnamed_addr constant [20 x double] [double 2.820000e+01, double 2.660000e+01, double 2.010000e+01, double 2.330000e+01, double 2.520000e+01, double 2.210000e+01, double 1.770000e+01, double 2.760000e+01, double 2.060000e+01, double 1.370000e+01, double 2.320000e+01, double 1.750000e+01, double 2.060000e+01, double 1.800000e+01, double 2.390000e+01, double 2.160000e+01, double 2.430000e+01, double 2.040000e+01, double 2.400000e+01, double 1.320000e+01], align 16
@__const.main.x = private unnamed_addr constant [4 x double] [double 3.000000e+00, double 4.000000e+00, double 1.000000e+00, double 2.100000e+00], align 16
@__const.main.y = private unnamed_addr constant [3 x double] [double 4.902000e+02, double 3.400000e+02, double 4.339000e+02], align 16
@__const.main.v1 = private unnamed_addr constant [3 x double] [double 1.026800e-02, double 1.670000e-04, double 1.670000e-04], align 16
@__const.main.v2 = private unnamed_addr constant [3 x double] [double 1.592580e-01, double 1.362780e-01, double 1.223890e-01], align 16
@__const.main.s1 = private unnamed_addr constant [2 x double] [double 0x3FB1111111111111, double 0x3FC4A5294A5294A5], align 16
@__const.main.s2 = private unnamed_addr constant [2 x double] [double 1.000000e-01, double 4.000000e-02], align 16
@__const.main.z1 = private unnamed_addr constant [3 x double] [double 0x3FD90B21642C8591, double 0x3FDDDDDDDDDDDDDE, double 0.000000e+00], align 16
@__const.main.z2 = private unnamed_addr constant [3 x double] [double 0.000000e+00, double 0x3FDC9882B9310572, double 0.000000e+00], align 16
@__const.main.CORRECT_ANSWERS = private unnamed_addr constant [8 x double] [double 0x3F95E41D648C236F, double 0x3FC30D3EA599BB79, double 0x3FA26AF51F458AEB, double 0x3FB73CEBAB27FA12, double 0x3F8604EA1C27764A, double 0x3F6BD85EAF35CBC8, double 0x3FE0DF5C6BE20DA6, double 0x3FE172D38028625E], align 16
@.str.2 = private unnamed_addr constant [26 x i8] c"Test sets 1 p-value = %g\0A\00", align 1
@.str.3 = private unnamed_addr constant [26 x i8] c"Test sets 2 p-value = %g\0A\00", align 1
@.str.4 = private unnamed_addr constant [26 x i8] c"Test sets 3 p-value = %g\0A\00", align 1
@.str.5 = private unnamed_addr constant [26 x i8] c"Test sets 4 p-value = %g\0A\00", align 1
@.str.6 = private unnamed_addr constant [26 x i8] c"Test sets 5 p-value = %g\0A\00", align 1
@.str.7 = private unnamed_addr constant [26 x i8] c"Test sets 6 p-value = %g\0A\00", align 1
@.str.8 = private unnamed_addr constant [26 x i8] c"Test sets 7 p-value = %g\0A\00", align 1
@.str.9 = private unnamed_addr constant [26 x i8] c"Test sets z p-value = %g\0A\00", align 1
@.str.10 = private unnamed_addr constant [28 x i8] c"the cumulative error is %g\0A\00", align 1
@llvm.used = appending global [1 x i8*] [i8* bitcast (i32 ()* @__main_void to i8*)], section "llvm.metadata"

@__main_void = alias i32 (), i32 ()* @main

; Function Attrs: noinline nounwind optnone
define hidden double @Pvalue(double* noalias %ARRAY1, i32 %ARRAY1_SIZE, double* noalias %ARRAY2, i32 %ARRAY2_SIZE) #0 {
entry:
  %retval = alloca double, align 8
  %ARRAY1.addr = alloca double*, align 4
  %ARRAY1_SIZE.addr = alloca i32, align 4
  %ARRAY2.addr = alloca double*, align 4
  %ARRAY2_SIZE.addr = alloca i32, align 4
  %fmean1 = alloca double, align 8
  %fmean2 = alloca double, align 8
  %x = alloca i32, align 4
  %x9 = alloca i32, align 4
  %unbiased_sample_variance1 = alloca double, align 8
  %unbiased_sample_variance2 = alloca double, align 8
  %x32 = alloca i32, align 4
  %x44 = alloca i32, align 4
  %WELCH_T_STATISTIC = alloca double, align 8
  %DEGREES_OF_FREEDOM = alloca double, align 8
  %a = alloca double, align 8
  %value = alloca double, align 8
  %beta = alloca double, align 8
  %acu = alloca double, align 8
  %ai = alloca double, align 8
  %cx = alloca double, align 8
  %indx = alloca i32, align 4
  %ns = alloca i32, align 4
  %pp = alloca double, align 8
  %psq = alloca double, align 8
  %qq = alloca double, align 8
  %rx = alloca double, align 8
  %temp = alloca double, align 8
  %term = alloca double, align 8
  %xx = alloca double, align 8
  store double* %ARRAY1, double** %ARRAY1.addr, align 4
  store i32 %ARRAY1_SIZE, i32* %ARRAY1_SIZE.addr, align 4
  store double* %ARRAY2, double** %ARRAY2.addr, align 4
  store i32 %ARRAY2_SIZE, i32* %ARRAY2_SIZE.addr, align 4
  %0 = load i32, i32* %ARRAY1_SIZE.addr, align 4
  %cmp = icmp ule i32 %0, 1
  br i1 %cmp, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  store double 1.000000e+00, double* %retval, align 8
  br label %return

if.else:                                          ; preds = %entry
  %1 = load i32, i32* %ARRAY2_SIZE.addr, align 4
  %cmp1 = icmp ule i32 %1, 1
  br i1 %cmp1, label %if.then2, label %if.end

if.then2:                                         ; preds = %if.else
  store double 1.000000e+00, double* %retval, align 8
  br label %return

if.end:                                           ; preds = %if.else
  br label %if.end3

if.end3:                                          ; preds = %if.end
  store double 0.000000e+00, double* %fmean1, align 8
  store double 0.000000e+00, double* %fmean2, align 8
  store i32 0, i32* %x, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.end3
  %2 = load i32, i32* %x, align 4
  %3 = load i32, i32* %ARRAY1_SIZE.addr, align 4
  %cmp4 = icmp ult i32 %2, %3
  br i1 %cmp4, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %4 = load double*, double** %ARRAY1.addr, align 4
  %5 = load i32, i32* %x, align 4
  %arrayidx = getelementptr inbounds double, double* %4, i32 %5
  %6 = load double, double* %arrayidx, align 8
  %7 = call double @llvm.fabs.f64(double %6) #7
  %cmpinf = fcmp one double %7, 0x7FF0000000000000
  %8 = zext i1 %cmpinf to i32
  %cmp5 = icmp eq i32 %8, 0
  br i1 %cmp5, label %if.then6, label %if.end7

if.then6:                                         ; preds = %for.body
  %call = call i32 @puts(i8* getelementptr inbounds ([63 x i8], [63 x i8]* @.str, i32 0, i32 0))
  call void @exit(i32 1) #8
  unreachable

if.end7:                                          ; preds = %for.body
  %9 = load double*, double** %ARRAY1.addr, align 4
  %10 = load i32, i32* %x, align 4
  %arrayidx8 = getelementptr inbounds double, double* %9, i32 %10
  %11 = load double, double* %arrayidx8, align 8
  %12 = load double, double* %fmean1, align 8
  %add = fadd double %12, %11
  store double %add, double* %fmean1, align 8
  br label %for.inc

for.inc:                                          ; preds = %if.end7
  %13 = load i32, i32* %x, align 4
  %inc = add i32 %13, 1
  store i32 %inc, i32* %x, align 4
  br label %for.cond

for.end:                                          ; preds = %for.cond
  %14 = load i32, i32* %ARRAY1_SIZE.addr, align 4
  %conv = uitofp i32 %14 to double
  %15 = load double, double* %fmean1, align 8
  %div = fdiv double %15, %conv
  store double %div, double* %fmean1, align 8
  store i32 0, i32* %x9, align 4
  br label %for.cond10

for.cond10:                                       ; preds = %for.inc23, %for.end
  %16 = load i32, i32* %x9, align 4
  %17 = load i32, i32* %ARRAY2_SIZE.addr, align 4
  %cmp11 = icmp ult i32 %16, %17
  br i1 %cmp11, label %for.body13, label %for.end25

for.body13:                                       ; preds = %for.cond10
  %18 = load double*, double** %ARRAY2.addr, align 4
  %19 = load i32, i32* %x9, align 4
  %arrayidx14 = getelementptr inbounds double, double* %18, i32 %19
  %20 = load double, double* %arrayidx14, align 8
  %21 = call double @llvm.fabs.f64(double %20) #7
  %cmpinf15 = fcmp one double %21, 0x7FF0000000000000
  %22 = zext i1 %cmpinf15 to i32
  %cmp16 = icmp eq i32 %22, 0
  br i1 %cmp16, label %if.then18, label %if.end20

if.then18:                                        ; preds = %for.body13
  %call19 = call i32 @puts(i8* getelementptr inbounds ([63 x i8], [63 x i8]* @.str.1, i32 0, i32 0))
  call void @exit(i32 1) #8
  unreachable

if.end20:                                         ; preds = %for.body13
  %23 = load double*, double** %ARRAY2.addr, align 4
  %24 = load i32, i32* %x9, align 4
  %arrayidx21 = getelementptr inbounds double, double* %23, i32 %24
  %25 = load double, double* %arrayidx21, align 8
  %26 = load double, double* %fmean2, align 8
  %add22 = fadd double %26, %25
  store double %add22, double* %fmean2, align 8
  br label %for.inc23

for.inc23:                                        ; preds = %if.end20
  %27 = load i32, i32* %x9, align 4
  %inc24 = add i32 %27, 1
  store i32 %inc24, i32* %x9, align 4
  br label %for.cond10

for.end25:                                        ; preds = %for.cond10
  %28 = load i32, i32* %ARRAY2_SIZE.addr, align 4
  %conv26 = uitofp i32 %28 to double
  %29 = load double, double* %fmean2, align 8
  %div27 = fdiv double %29, %conv26
  store double %div27, double* %fmean2, align 8
  %30 = load double, double* %fmean1, align 8
  %31 = load double, double* %fmean2, align 8
  %cmp28 = fcmp oeq double %30, %31
  br i1 %cmp28, label %if.then30, label %if.end31

if.then30:                                        ; preds = %for.end25
  store double 1.000000e+00, double* %retval, align 8
  br label %return

if.end31:                                         ; preds = %for.end25
  store double 0.000000e+00, double* %unbiased_sample_variance1, align 8
  store double 0.000000e+00, double* %unbiased_sample_variance2, align 8
  store i32 0, i32* %x32, align 4
  br label %for.cond33

for.cond33:                                       ; preds = %for.inc41, %if.end31
  %32 = load i32, i32* %x32, align 4
  %33 = load i32, i32* %ARRAY1_SIZE.addr, align 4
  %cmp34 = icmp ult i32 %32, %33
  br i1 %cmp34, label %for.body36, label %for.end43

for.body36:                                       ; preds = %for.cond33
  %34 = load double*, double** %ARRAY1.addr, align 4
  %35 = load i32, i32* %x32, align 4
  %arrayidx37 = getelementptr inbounds double, double* %34, i32 %35
  %36 = load double, double* %arrayidx37, align 8
  %37 = load double, double* %fmean1, align 8
  %sub = fsub double %36, %37
  %38 = load double*, double** %ARRAY1.addr, align 4
  %39 = load i32, i32* %x32, align 4
  %arrayidx38 = getelementptr inbounds double, double* %38, i32 %39
  %40 = load double, double* %arrayidx38, align 8
  %41 = load double, double* %fmean1, align 8
  %sub39 = fsub double %40, %41
  %mul = fmul double %sub, %sub39
  %42 = load double, double* %unbiased_sample_variance1, align 8
  %add40 = fadd double %42, %mul
  store double %add40, double* %unbiased_sample_variance1, align 8
  br label %for.inc41

for.inc41:                                        ; preds = %for.body36
  %43 = load i32, i32* %x32, align 4
  %inc42 = add i32 %43, 1
  store i32 %inc42, i32* %x32, align 4
  br label %for.cond33

for.end43:                                        ; preds = %for.cond33
  store i32 0, i32* %x44, align 4
  br label %for.cond45

for.cond45:                                       ; preds = %for.inc55, %for.end43
  %44 = load i32, i32* %x44, align 4
  %45 = load i32, i32* %ARRAY2_SIZE.addr, align 4
  %cmp46 = icmp ult i32 %44, %45
  br i1 %cmp46, label %for.body48, label %for.end57

for.body48:                                       ; preds = %for.cond45
  %46 = load double*, double** %ARRAY2.addr, align 4
  %47 = load i32, i32* %x44, align 4
  %arrayidx49 = getelementptr inbounds double, double* %46, i32 %47
  %48 = load double, double* %arrayidx49, align 8
  %49 = load double, double* %fmean2, align 8
  %sub50 = fsub double %48, %49
  %50 = load double*, double** %ARRAY2.addr, align 4
  %51 = load i32, i32* %x44, align 4
  %arrayidx51 = getelementptr inbounds double, double* %50, i32 %51
  %52 = load double, double* %arrayidx51, align 8
  %53 = load double, double* %fmean2, align 8
  %sub52 = fsub double %52, %53
  %mul53 = fmul double %sub50, %sub52
  %54 = load double, double* %unbiased_sample_variance2, align 8
  %add54 = fadd double %54, %mul53
  store double %add54, double* %unbiased_sample_variance2, align 8
  br label %for.inc55

for.inc55:                                        ; preds = %for.body48
  %55 = load i32, i32* %x44, align 4
  %inc56 = add i32 %55, 1
  store i32 %inc56, i32* %x44, align 4
  br label %for.cond45

for.end57:                                        ; preds = %for.cond45
  %56 = load double, double* %unbiased_sample_variance1, align 8
  %57 = load i32, i32* %ARRAY1_SIZE.addr, align 4
  %sub58 = sub i32 %57, 1
  %conv59 = uitofp i32 %sub58 to double
  %div60 = fdiv double %56, %conv59
  store double %div60, double* %unbiased_sample_variance1, align 8
  %58 = load double, double* %unbiased_sample_variance2, align 8
  %59 = load i32, i32* %ARRAY2_SIZE.addr, align 4
  %sub61 = sub i32 %59, 1
  %conv62 = uitofp i32 %sub61 to double
  %div63 = fdiv double %58, %conv62
  store double %div63, double* %unbiased_sample_variance2, align 8
  %60 = load double, double* %fmean1, align 8
  %61 = load double, double* %fmean2, align 8
  %sub64 = fsub double %60, %61
  %62 = load double, double* %unbiased_sample_variance1, align 8
  %63 = load i32, i32* %ARRAY1_SIZE.addr, align 4
  %conv65 = uitofp i32 %63 to double
  %div66 = fdiv double %62, %conv65
  %64 = load double, double* %unbiased_sample_variance2, align 8
  %65 = load i32, i32* %ARRAY2_SIZE.addr, align 4
  %conv67 = uitofp i32 %65 to double
  %div68 = fdiv double %64, %conv67
  %add69 = fadd double %div66, %div68
  %66 = call double @llvm.sqrt.f64(double %add69)
  %div70 = fdiv double %sub64, %66
  store double %div70, double* %WELCH_T_STATISTIC, align 8
  %67 = load double, double* %unbiased_sample_variance1, align 8
  %68 = load i32, i32* %ARRAY1_SIZE.addr, align 4
  %conv71 = uitofp i32 %68 to double
  %div72 = fdiv double %67, %conv71
  %69 = load double, double* %unbiased_sample_variance2, align 8
  %70 = load i32, i32* %ARRAY2_SIZE.addr, align 4
  %conv73 = uitofp i32 %70 to double
  %div74 = fdiv double %69, %conv73
  %add75 = fadd double %div72, %div74
  %71 = call double @llvm.pow.f64(double %add75, double 2.000000e+00)
  %72 = load double, double* %unbiased_sample_variance1, align 8
  %73 = load double, double* %unbiased_sample_variance1, align 8
  %mul76 = fmul double %72, %73
  %74 = load i32, i32* %ARRAY1_SIZE.addr, align 4
  %75 = load i32, i32* %ARRAY1_SIZE.addr, align 4
  %mul77 = mul i32 %74, %75
  %76 = load i32, i32* %ARRAY1_SIZE.addr, align 4
  %sub78 = sub i32 %76, 1
  %mul79 = mul i32 %mul77, %sub78
  %conv80 = uitofp i32 %mul79 to double
  %div81 = fdiv double %mul76, %conv80
  %77 = load double, double* %unbiased_sample_variance2, align 8
  %78 = load double, double* %unbiased_sample_variance2, align 8
  %mul82 = fmul double %77, %78
  %79 = load i32, i32* %ARRAY2_SIZE.addr, align 4
  %80 = load i32, i32* %ARRAY2_SIZE.addr, align 4
  %mul83 = mul i32 %79, %80
  %81 = load i32, i32* %ARRAY2_SIZE.addr, align 4
  %sub84 = sub i32 %81, 1
  %mul85 = mul i32 %mul83, %sub84
  %conv86 = uitofp i32 %mul85 to double
  %div87 = fdiv double %mul82, %conv86
  %add88 = fadd double %div81, %div87
  %div89 = fdiv double %71, %add88
  store double %div89, double* %DEGREES_OF_FREEDOM, align 8
  %82 = load double, double* %DEGREES_OF_FREEDOM, align 8
  %div90 = fdiv double %82, 2.000000e+00
  store double %div90, double* %a, align 8
  %83 = load double, double* %DEGREES_OF_FREEDOM, align 8
  %84 = load double, double* %WELCH_T_STATISTIC, align 8
  %85 = load double, double* %WELCH_T_STATISTIC, align 8
  %mul91 = fmul double %84, %85
  %86 = load double, double* %DEGREES_OF_FREEDOM, align 8
  %add92 = fadd double %mul91, %86
  %div93 = fdiv double %83, %add92
  store double %div93, double* %value, align 8
  %87 = load double, double* %value, align 8
  %88 = call double @llvm.fabs.f64(double %87) #7
  %cmpinf94 = fcmp oeq double %88, 0x7FF0000000000000
  br i1 %cmpinf94, label %if.then100, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %for.end57
  %89 = load double, double* %value, align 8
  %cmp97 = fcmp uno double %89, %89
  br i1 %cmp97, label %if.then100, label %if.end101

if.then100:                                       ; preds = %lor.lhs.false, %for.end57
  store double 1.000000e+00, double* %retval, align 8
  br label %return

if.end101:                                        ; preds = %lor.lhs.false
  %90 = load double, double* %value, align 8
  %91 = call double @llvm.fabs.f64(double %90) #7
  %cmpinf102 = fcmp oeq double %91, 0x7FF0000000000000
  br i1 %cmpinf102, label %if.then109, label %lor.lhs.false105

lor.lhs.false105:                                 ; preds = %if.end101
  %92 = load double, double* %value, align 8
  %cmp106 = fcmp uno double %92, %92
  br i1 %cmp106, label %if.then109, label %if.end110

if.then109:                                       ; preds = %lor.lhs.false105, %if.end101
  store double 1.000000e+00, double* %retval, align 8
  br label %return

if.end110:                                        ; preds = %lor.lhs.false105
  %93 = load double, double* %a, align 8
  %conv111 = fpext double %93 to fp128
  %call112 = call fp128 @lgammal(fp128 %conv111) #9
  %add113 = fadd fp128 %call112, 0xLD0000000000000003FFE250D048E7A1B
  %94 = load double, double* %a, align 8
  %add114 = fadd double %94, 5.000000e-01
  %conv115 = fpext double %add114 to fp128
  %call116 = call fp128 @lgammal(fp128 %conv115) #9
  %sub117 = fsub fp128 %add113, %call116
  %conv118 = fptrunc fp128 %sub117 to double
  store double %conv118, double* %beta, align 8
  store double 1.000000e-15, double* %acu, align 8
  %95 = load double, double* %a, align 8
  %cmp119 = fcmp ole double %95, 0.000000e+00
  br i1 %cmp119, label %if.then121, label %if.end122

if.then121:                                       ; preds = %if.end110
  br label %if.end122

if.end122:                                        ; preds = %if.then121, %if.end110
  %96 = load double, double* %value, align 8
  %cmp123 = fcmp olt double %96, 0.000000e+00
  br i1 %cmp123, label %if.then128, label %lor.lhs.false125

lor.lhs.false125:                                 ; preds = %if.end122
  %97 = load double, double* %value, align 8
  %cmp126 = fcmp olt double 1.000000e+00, %97
  br i1 %cmp126, label %if.then128, label %if.end129

if.then128:                                       ; preds = %lor.lhs.false125, %if.end122
  %98 = load double, double* %value, align 8
  store double %98, double* %retval, align 8
  br label %return

if.end129:                                        ; preds = %lor.lhs.false125
  %99 = load double, double* %value, align 8
  %cmp130 = fcmp oeq double %99, 0.000000e+00
  br i1 %cmp130, label %if.then135, label %lor.lhs.false132

lor.lhs.false132:                                 ; preds = %if.end129
  %100 = load double, double* %value, align 8
  %cmp133 = fcmp oeq double %100, 1.000000e+00
  br i1 %cmp133, label %if.then135, label %if.end136

if.then135:                                       ; preds = %lor.lhs.false132, %if.end129
  %101 = load double, double* %value, align 8
  store double %101, double* %retval, align 8
  br label %return

if.end136:                                        ; preds = %lor.lhs.false132
  %102 = load double, double* %a, align 8
  %add137 = fadd double %102, 5.000000e-01
  store double %add137, double* %psq, align 8
  %103 = load double, double* %value, align 8
  %sub138 = fsub double 1.000000e+00, %103
  store double %sub138, double* %cx, align 8
  %104 = load double, double* %a, align 8
  %105 = load double, double* %psq, align 8
  %106 = load double, double* %value, align 8
  %mul139 = fmul double %105, %106
  %cmp140 = fcmp olt double %104, %mul139
  br i1 %cmp140, label %if.then142, label %if.else143

if.then142:                                       ; preds = %if.end136
  %107 = load double, double* %cx, align 8
  store double %107, double* %xx, align 8
  %108 = load double, double* %value, align 8
  store double %108, double* %cx, align 8
  store double 5.000000e-01, double* %pp, align 8
  %109 = load double, double* %a, align 8
  store double %109, double* %qq, align 8
  store i32 1, i32* %indx, align 4
  br label %if.end144

if.else143:                                       ; preds = %if.end136
  %110 = load double, double* %value, align 8
  store double %110, double* %xx, align 8
  %111 = load double, double* %a, align 8
  store double %111, double* %pp, align 8
  store double 5.000000e-01, double* %qq, align 8
  store i32 0, i32* %indx, align 4
  br label %if.end144

if.end144:                                        ; preds = %if.else143, %if.then142
  store double 1.000000e+00, double* %term, align 8
  store double 1.000000e+00, double* %ai, align 8
  store double 1.000000e+00, double* %value, align 8
  %112 = load double, double* %qq, align 8
  %113 = load double, double* %cx, align 8
  %114 = load double, double* %psq, align 8
  %mul145 = fmul double %113, %114
  %add146 = fadd double %112, %mul145
  %conv147 = fptosi double %add146 to i32
  store i32 %conv147, i32* %ns, align 4
  %115 = load double, double* %xx, align 8
  %116 = load double, double* %cx, align 8
  %div148 = fdiv double %115, %116
  store double %div148, double* %rx, align 8
  %117 = load double, double* %qq, align 8
  %118 = load double, double* %ai, align 8
  %sub149 = fsub double %117, %118
  store double %sub149, double* %temp, align 8
  %119 = load i32, i32* %ns, align 4
  %cmp150 = icmp eq i32 %119, 0
  br i1 %cmp150, label %if.then152, label %if.end153

if.then152:                                       ; preds = %if.end144
  %120 = load double, double* %xx, align 8
  store double %120, double* %rx, align 8
  br label %if.end153

if.end153:                                        ; preds = %if.then152, %if.end144
  br label %for.cond154

for.cond154:                                      ; preds = %if.end189, %if.end153
  %121 = load double, double* %term, align 8
  %122 = load double, double* %temp, align 8
  %mul155 = fmul double %121, %122
  %123 = load double, double* %rx, align 8
  %mul156 = fmul double %mul155, %123
  %124 = load double, double* %pp, align 8
  %125 = load double, double* %ai, align 8
  %add157 = fadd double %124, %125
  %div158 = fdiv double %mul156, %add157
  store double %div158, double* %term, align 8
  %126 = load double, double* %value, align 8
  %127 = load double, double* %term, align 8
  %add159 = fadd double %126, %127
  store double %add159, double* %value, align 8
  %128 = load double, double* %term, align 8
  %129 = call double @llvm.fabs.f64(double %128)
  store double %129, double* %temp, align 8
  %130 = load double, double* %temp, align 8
  %cmp160 = fcmp ole double %130, 1.000000e-15
  br i1 %cmp160, label %land.lhs.true, label %if.end176

land.lhs.true:                                    ; preds = %for.cond154
  %131 = load double, double* %temp, align 8
  %132 = load double, double* %value, align 8
  %mul162 = fmul double 1.000000e-15, %132
  %cmp163 = fcmp ole double %131, %mul162
  br i1 %cmp163, label %if.then165, label %if.end176

if.then165:                                       ; preds = %land.lhs.true
  %133 = load double, double* %value, align 8
  %134 = load double, double* %pp, align 8
  %135 = load double, double* %xx, align 8
  %136 = call double @llvm.log.f64(double %135)
  %mul166 = fmul double %134, %136
  %137 = load double, double* %qq, align 8
  %sub167 = fsub double %137, 1.000000e+00
  %138 = load double, double* %cx, align 8
  %139 = call double @llvm.log.f64(double %138)
  %mul168 = fmul double %sub167, %139
  %add169 = fadd double %mul166, %mul168
  %140 = load double, double* %beta, align 8
  %sub170 = fsub double %add169, %140
  %141 = call double @llvm.exp.f64(double %sub170)
  %mul171 = fmul double %133, %141
  %142 = load double, double* %pp, align 8
  %div172 = fdiv double %mul171, %142
  store double %div172, double* %value, align 8
  %143 = load i32, i32* %indx, align 4
  %tobool = icmp ne i32 %143, 0
  br i1 %tobool, label %if.then173, label %if.end175

if.then173:                                       ; preds = %if.then165
  %144 = load double, double* %value, align 8
  %sub174 = fsub double 1.000000e+00, %144
  store double %sub174, double* %value, align 8
  br label %if.end175

if.end175:                                        ; preds = %if.then173, %if.then165
  br label %for.end190

if.end176:                                        ; preds = %land.lhs.true, %for.cond154
  %145 = load double, double* %ai, align 8
  %add177 = fadd double %145, 1.000000e+00
  store double %add177, double* %ai, align 8
  %146 = load i32, i32* %ns, align 4
  %sub178 = sub nsw i32 %146, 1
  store i32 %sub178, i32* %ns, align 4
  %147 = load i32, i32* %ns, align 4
  %cmp179 = icmp sle i32 0, %147
  br i1 %cmp179, label %if.then181, label %if.else187

if.then181:                                       ; preds = %if.end176
  %148 = load double, double* %qq, align 8
  %149 = load double, double* %ai, align 8
  %sub182 = fsub double %148, %149
  store double %sub182, double* %temp, align 8
  %150 = load i32, i32* %ns, align 4
  %cmp183 = icmp eq i32 %150, 0
  br i1 %cmp183, label %if.then185, label %if.end186

if.then185:                                       ; preds = %if.then181
  %151 = load double, double* %xx, align 8
  store double %151, double* %rx, align 8
  br label %if.end186

if.end186:                                        ; preds = %if.then185, %if.then181
  br label %if.end189

if.else187:                                       ; preds = %if.end176
  %152 = load double, double* %psq, align 8
  store double %152, double* %temp, align 8
  %153 = load double, double* %psq, align 8
  %add188 = fadd double %153, 1.000000e+00
  store double %add188, double* %psq, align 8
  br label %if.end189

if.end189:                                        ; preds = %if.else187, %if.end186
  br label %for.cond154

for.end190:                                       ; preds = %if.end175
  %154 = load double, double* %value, align 8
  store double %154, double* %retval, align 8
  br label %return

return:                                           ; preds = %for.end190, %if.then135, %if.then128, %if.then109, %if.then100, %if.then30, %if.then2, %if.then
  %155 = load double, double* %retval, align 8
  ret double %155
}

; Function Attrs: nounwind readnone speculatable willreturn
declare double @llvm.fabs.f64(double %0) #1

declare i32 @puts(i8* %0) #2

; Function Attrs: noreturn
declare void @exit(i32 %0) #3

; Function Attrs: nounwind readnone speculatable willreturn
declare double @llvm.sqrt.f64(double %0) #1

; Function Attrs: nounwind readnone speculatable willreturn
declare double @llvm.pow.f64(double %0, double %1) #1

; Function Attrs: nounwind
declare fp128 @lgammal(fp128 %0) #4

; Function Attrs: nounwind readnone speculatable willreturn
declare double @llvm.log.f64(double %0) #1

; Function Attrs: nounwind readnone speculatable willreturn
declare double @llvm.exp.f64(double %0) #1

; Function Attrs: noinline nounwind optnone
define hidden i32 @main() #0 {
entry:
  %retval = alloca i32, align 4
  %d1 = alloca [15 x double], align 16
  %d2 = alloca [15 x double], align 16
  %d3 = alloca [10 x double], align 16
  %d4 = alloca [20 x double], align 16
  %d5 = alloca [10 x double], align 16
  %d6 = alloca [20 x double], align 16
  %d7 = alloca [6 x double], align 16
  %d8 = alloca [6 x double], align 16
  %x = alloca [4 x double], align 16
  %y = alloca [3 x double], align 16
  %v1 = alloca [3 x double], align 16
  %v2 = alloca [3 x double], align 16
  %s1 = alloca [2 x double], align 16
  %s2 = alloca [2 x double], align 16
  %z1 = alloca [3 x double], align 16
  %z2 = alloca [3 x double], align 16
  %CORRECT_ANSWERS = alloca [8 x double], align 16
  %pvalue = alloca double, align 8
  %error = alloca double, align 8
  store i32 0, i32* %retval, align 4
  %0 = bitcast [15 x double]* %d1 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 16 %0, i8* align 16 bitcast ([15 x double]* @__const.main.d1 to i8*), i32 120, i1 false)
  %1 = bitcast [15 x double]* %d2 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 16 %1, i8* align 16 bitcast ([15 x double]* @__const.main.d2 to i8*), i32 120, i1 false)
  %2 = bitcast [10 x double]* %d3 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 16 %2, i8* align 16 bitcast ([10 x double]* @__const.main.d3 to i8*), i32 80, i1 false)
  %3 = bitcast [20 x double]* %d4 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 16 %3, i8* align 16 bitcast ([20 x double]* @__const.main.d4 to i8*), i32 160, i1 false)
  %4 = bitcast [10 x double]* %d5 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 16 %4, i8* align 16 bitcast ([10 x double]* @__const.main.d5 to i8*), i32 80, i1 false)
  %5 = bitcast [20 x double]* %d6 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 16 %5, i8* align 16 bitcast ([20 x double]* @__const.main.d6 to i8*), i32 160, i1 false)
  %6 = bitcast [6 x double]* %d7 to i8*
  call void @llvm.memset.p0i8.i32(i8* align 16 %6, i8 0, i32 48, i1 false)
  %7 = bitcast i8* %6 to [6 x double]*
  %8 = getelementptr inbounds [6 x double], [6 x double]* %7, i32 0, i32 0
  store double 3.002000e+01, double* %8, align 16
  %9 = getelementptr inbounds [6 x double], [6 x double]* %7, i32 0, i32 1
  store double 2.999000e+01, double* %9, align 8
  %10 = getelementptr inbounds [6 x double], [6 x double]* %7, i32 0, i32 2
  store double 3.011000e+01, double* %10, align 16
  %11 = getelementptr inbounds [6 x double], [6 x double]* %7, i32 0, i32 3
  store double 2.997000e+01, double* %11, align 8
  %12 = getelementptr inbounds [6 x double], [6 x double]* %7, i32 0, i32 4
  store double 3.001000e+01, double* %12, align 16
  %13 = getelementptr inbounds [6 x double], [6 x double]* %7, i32 0, i32 5
  store double 2.999000e+01, double* %13, align 8
  %14 = bitcast [6 x double]* %d8 to i8*
  call void @llvm.memset.p0i8.i32(i8* align 16 %14, i8 0, i32 48, i1 false)
  %15 = bitcast i8* %14 to [6 x double]*
  %16 = getelementptr inbounds [6 x double], [6 x double]* %15, i32 0, i32 0
  store double 2.989000e+01, double* %16, align 16
  %17 = getelementptr inbounds [6 x double], [6 x double]* %15, i32 0, i32 1
  store double 2.993000e+01, double* %17, align 8
  %18 = getelementptr inbounds [6 x double], [6 x double]* %15, i32 0, i32 2
  store double 2.972000e+01, double* %18, align 16
  %19 = getelementptr inbounds [6 x double], [6 x double]* %15, i32 0, i32 3
  store double 2.998000e+01, double* %19, align 8
  %20 = getelementptr inbounds [6 x double], [6 x double]* %15, i32 0, i32 4
  store double 3.002000e+01, double* %20, align 16
  %21 = getelementptr inbounds [6 x double], [6 x double]* %15, i32 0, i32 5
  store double 2.998000e+01, double* %21, align 8
  %22 = bitcast [4 x double]* %x to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 16 %22, i8* align 16 bitcast ([4 x double]* @__const.main.x to i8*), i32 32, i1 false)
  %23 = bitcast [3 x double]* %y to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 16 %23, i8* align 16 bitcast ([3 x double]* @__const.main.y to i8*), i32 24, i1 false)
  %24 = bitcast [3 x double]* %v1 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 16 %24, i8* align 16 bitcast ([3 x double]* @__const.main.v1 to i8*), i32 24, i1 false)
  %25 = bitcast [3 x double]* %v2 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 16 %25, i8* align 16 bitcast ([3 x double]* @__const.main.v2 to i8*), i32 24, i1 false)
  %26 = bitcast [2 x double]* %s1 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 16 %26, i8* align 16 bitcast ([2 x double]* @__const.main.s1 to i8*), i32 16, i1 false)
  %27 = bitcast [2 x double]* %s2 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 16 %27, i8* align 16 bitcast ([2 x double]* @__const.main.s2 to i8*), i32 16, i1 false)
  %28 = bitcast [3 x double]* %z1 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 16 %28, i8* align 16 bitcast ([3 x double]* @__const.main.z1 to i8*), i32 24, i1 false)
  %29 = bitcast [3 x double]* %z2 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 16 %29, i8* align 16 bitcast ([3 x double]* @__const.main.z2 to i8*), i32 24, i1 false)
  %30 = bitcast [8 x double]* %CORRECT_ANSWERS to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 16 %30, i8* align 16 bitcast ([8 x double]* @__const.main.CORRECT_ANSWERS to i8*), i32 64, i1 false)
  %arraydecay = getelementptr inbounds [15 x double], [15 x double]* %d1, i32 0, i32 0
  %arraydecay1 = getelementptr inbounds [15 x double], [15 x double]* %d2, i32 0, i32 0
  %call = call double @Pvalue(double* %arraydecay, i32 15, double* %arraydecay1, i32 15)
  store double %call, double* %pvalue, align 8
  %31 = load double, double* %pvalue, align 8
  %arrayidx = getelementptr inbounds [8 x double], [8 x double]* %CORRECT_ANSWERS, i32 0, i32 0
  %32 = load double, double* %arrayidx, align 16
  %sub = fsub double %31, %32
  %33 = call double @llvm.fabs.f64(double %sub)
  store double %33, double* %error, align 8
  %34 = load double, double* %pvalue, align 8
  %call2 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([26 x i8], [26 x i8]* @.str.2, i32 0, i32 0), double %34)
  %arraydecay3 = getelementptr inbounds [10 x double], [10 x double]* %d3, i32 0, i32 0
  %arraydecay4 = getelementptr inbounds [20 x double], [20 x double]* %d4, i32 0, i32 0
  %call5 = call double @Pvalue(double* %arraydecay3, i32 10, double* %arraydecay4, i32 20)
  store double %call5, double* %pvalue, align 8
  %35 = load double, double* %pvalue, align 8
  %arrayidx6 = getelementptr inbounds [8 x double], [8 x double]* %CORRECT_ANSWERS, i32 0, i32 1
  %36 = load double, double* %arrayidx6, align 8
  %sub7 = fsub double %35, %36
  %37 = call double @llvm.fabs.f64(double %sub7)
  %38 = load double, double* %error, align 8
  %add = fadd double %38, %37
  store double %add, double* %error, align 8
  %39 = load double, double* %pvalue, align 8
  %call8 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([26 x i8], [26 x i8]* @.str.3, i32 0, i32 0), double %39)
  %arraydecay9 = getelementptr inbounds [10 x double], [10 x double]* %d5, i32 0, i32 0
  %arraydecay10 = getelementptr inbounds [20 x double], [20 x double]* %d6, i32 0, i32 0
  %call11 = call double @Pvalue(double* %arraydecay9, i32 10, double* %arraydecay10, i32 20)
  store double %call11, double* %pvalue, align 8
  %40 = load double, double* %pvalue, align 8
  %arrayidx12 = getelementptr inbounds [8 x double], [8 x double]* %CORRECT_ANSWERS, i32 0, i32 2
  %41 = load double, double* %arrayidx12, align 16
  %sub13 = fsub double %40, %41
  %42 = call double @llvm.fabs.f64(double %sub13)
  %43 = load double, double* %error, align 8
  %add14 = fadd double %43, %42
  store double %add14, double* %error, align 8
  %44 = load double, double* %pvalue, align 8
  %call15 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([26 x i8], [26 x i8]* @.str.4, i32 0, i32 0), double %44)
  %arraydecay16 = getelementptr inbounds [6 x double], [6 x double]* %d7, i32 0, i32 0
  %arraydecay17 = getelementptr inbounds [6 x double], [6 x double]* %d8, i32 0, i32 0
  %call18 = call double @Pvalue(double* %arraydecay16, i32 6, double* %arraydecay17, i32 6)
  store double %call18, double* %pvalue, align 8
  %45 = load double, double* %pvalue, align 8
  %call19 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([26 x i8], [26 x i8]* @.str.5, i32 0, i32 0), double %45)
  %46 = load double, double* %pvalue, align 8
  %arrayidx20 = getelementptr inbounds [8 x double], [8 x double]* %CORRECT_ANSWERS, i32 0, i32 3
  %47 = load double, double* %arrayidx20, align 8
  %sub21 = fsub double %46, %47
  %48 = call double @llvm.fabs.f64(double %sub21)
  %49 = load double, double* %error, align 8
  %add22 = fadd double %49, %48
  store double %add22, double* %error, align 8
  %arraydecay23 = getelementptr inbounds [4 x double], [4 x double]* %x, i32 0, i32 0
  %arraydecay24 = getelementptr inbounds [3 x double], [3 x double]* %y, i32 0, i32 0
  %call25 = call double @Pvalue(double* %arraydecay23, i32 4, double* %arraydecay24, i32 3)
  store double %call25, double* %pvalue, align 8
  %50 = load double, double* %pvalue, align 8
  %arrayidx26 = getelementptr inbounds [8 x double], [8 x double]* %CORRECT_ANSWERS, i32 0, i32 4
  %51 = load double, double* %arrayidx26, align 16
  %sub27 = fsub double %50, %51
  %52 = call double @llvm.fabs.f64(double %sub27)
  %53 = load double, double* %error, align 8
  %add28 = fadd double %53, %52
  store double %add28, double* %error, align 8
  %54 = load double, double* %pvalue, align 8
  %call29 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([26 x i8], [26 x i8]* @.str.6, i32 0, i32 0), double %54)
  %arraydecay30 = getelementptr inbounds [3 x double], [3 x double]* %v1, i32 0, i32 0
  %arraydecay31 = getelementptr inbounds [3 x double], [3 x double]* %v2, i32 0, i32 0
  %call32 = call double @Pvalue(double* %arraydecay30, i32 3, double* %arraydecay31, i32 3)
  store double %call32, double* %pvalue, align 8
  %55 = load double, double* %pvalue, align 8
  %arrayidx33 = getelementptr inbounds [8 x double], [8 x double]* %CORRECT_ANSWERS, i32 0, i32 5
  %56 = load double, double* %arrayidx33, align 8
  %sub34 = fsub double %55, %56
  %57 = call double @llvm.fabs.f64(double %sub34)
  %58 = load double, double* %error, align 8
  %add35 = fadd double %58, %57
  store double %add35, double* %error, align 8
  %59 = load double, double* %pvalue, align 8
  %call36 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([26 x i8], [26 x i8]* @.str.7, i32 0, i32 0), double %59)
  %arraydecay37 = getelementptr inbounds [2 x double], [2 x double]* %s1, i32 0, i32 0
  %arraydecay38 = getelementptr inbounds [2 x double], [2 x double]* %s2, i32 0, i32 0
  %call39 = call double @Pvalue(double* %arraydecay37, i32 2, double* %arraydecay38, i32 2)
  store double %call39, double* %pvalue, align 8
  %60 = load double, double* %pvalue, align 8
  %arrayidx40 = getelementptr inbounds [8 x double], [8 x double]* %CORRECT_ANSWERS, i32 0, i32 6
  %61 = load double, double* %arrayidx40, align 16
  %sub41 = fsub double %60, %61
  %62 = call double @llvm.fabs.f64(double %sub41)
  %63 = load double, double* %error, align 8
  %add42 = fadd double %63, %62
  store double %add42, double* %error, align 8
  %64 = load double, double* %pvalue, align 8
  %call43 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([26 x i8], [26 x i8]* @.str.8, i32 0, i32 0), double %64)
  %arraydecay44 = getelementptr inbounds [3 x double], [3 x double]* %z1, i32 0, i32 0
  %arraydecay45 = getelementptr inbounds [3 x double], [3 x double]* %z2, i32 0, i32 0
  %call46 = call double @Pvalue(double* %arraydecay44, i32 3, double* %arraydecay45, i32 3)
  store double %call46, double* %pvalue, align 8
  %65 = load double, double* %pvalue, align 8
  %arrayidx47 = getelementptr inbounds [8 x double], [8 x double]* %CORRECT_ANSWERS, i32 0, i32 7
  %66 = load double, double* %arrayidx47, align 8
  %sub48 = fsub double %65, %66
  %67 = call double @llvm.fabs.f64(double %sub48)
  %68 = load double, double* %error, align 8
  %add49 = fadd double %68, %67
  store double %add49, double* %error, align 8
  %69 = load double, double* %pvalue, align 8
  %call50 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([26 x i8], [26 x i8]* @.str.9, i32 0, i32 0), double %69)
  %70 = load double, double* %error, align 8
  %call51 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([28 x i8], [28 x i8]* @.str.10, i32 0, i32 0), double %70)
  ret i32 0
}

; Function Attrs: argmemonly nounwind willreturn
declare void @llvm.memcpy.p0i8.p0i8.i32(i8* noalias nocapture writeonly %0, i8* noalias nocapture readonly %1, i32 %2, i1 immarg %3) #5

; Function Attrs: argmemonly nounwind willreturn writeonly
declare void @llvm.memset.p0i8.i32(i8* nocapture writeonly %0, i8 %1, i32 %2, i1 immarg %3) #6

declare i32 @printf(i8* %0, ...) #2

attributes #0 = { noinline nounwind optnone "correctly-rounded-divide-sqrt-fp-math"="false" "disable-tail-calls"="false" "frame-pointer"="none" "less-precise-fpmad"="false" "min-legal-vector-width"="0" "no-infs-fp-math"="false" "no-jump-tables"="false" "no-nans-fp-math"="false" "no-signed-zeros-fp-math"="false" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="generic" "unsafe-fp-math"="false" "use-soft-float"="false" }
attributes #1 = { nounwind readnone speculatable willreturn }
attributes #2 = { "correctly-rounded-divide-sqrt-fp-math"="false" "disable-tail-calls"="false" "frame-pointer"="none" "less-precise-fpmad"="false" "no-infs-fp-math"="false" "no-nans-fp-math"="false" "no-signed-zeros-fp-math"="false" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="generic" "unsafe-fp-math"="false" "use-soft-float"="false" }
attributes #3 = { noreturn "correctly-rounded-divide-sqrt-fp-math"="false" "disable-tail-calls"="false" "frame-pointer"="none" "less-precise-fpmad"="false" "no-infs-fp-math"="false" "no-nans-fp-math"="false" "no-signed-zeros-fp-math"="false" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="generic" "unsafe-fp-math"="false" "use-soft-float"="false" }
attributes #4 = { nounwind "correctly-rounded-divide-sqrt-fp-math"="false" "disable-tail-calls"="false" "frame-pointer"="none" "less-precise-fpmad"="false" "no-infs-fp-math"="false" "no-nans-fp-math"="false" "no-signed-zeros-fp-math"="false" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="generic" "unsafe-fp-math"="false" "use-soft-float"="false" }
attributes #5 = { argmemonly nounwind willreturn }
attributes #6 = { argmemonly nounwind willreturn writeonly }
attributes #7 = { readnone }
attributes #8 = { noreturn }
attributes #9 = { nounwind }

!llvm.module.flags = !{!0}
!llvm.ident = !{!1}

!0 = !{i32 1, !"wchar_size", i32 4}
!1 = !{!"clang version 11.0.0 (https://github.com/Jacarte/llvm-project.git 0f6dea67136cc1e0b3d200eb2bb165628970c44b)"}

; extracted candidates
#########################################################
; exiting Souper's runOnFunction() for main()
Total of 4 replacements done on this module
Total of 4 replacements candidates on this module
