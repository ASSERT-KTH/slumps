
Entering the Souper pass's runOnModule()


; entering Souper's runOnFunction() for irand()

; ModuleID = './Maze_generation.c.bc'
source_filename = "./Maze_generation.c"
target datalayout = "e-m:e-p:32:32-i64:64-n32:64-S128"
target triple = "wasm32-unknown-wasi"

@glyph = hidden global [30 x i32] [i32 12288, i32 9474, i32 9474, i32 9474, i32 9472, i32 9496, i32 9488, i32 9508, i32 9472, i32 9492, i32 9484, i32 9500, i32 9472, i32 9524, i32 9516, i32 9532, i32 12288, i32 9478, i32 9478, i32 9478, i32 9476, i32 9583, i32 9582, i32 32, i32 9476, i32 9584, i32 9581, i32 32, i32 9476, i32 0], align 16
@h = hidden global i32 0, align 4
@w = hidden global i32 0, align 4
@cell = hidden global i8** null, align 4
@.str = private unnamed_addr constant [6 x i8] c"\1B[31m\00", align 1
@.str.1 = private unnamed_addr constant [4 x i8] c"%lc\00", align 1
@.str.2 = private unnamed_addr constant [4 x i8] c"\1B[m\00", align 1
@__const.walk.d = private unnamed_addr constant [4 x i32] [i32 0, i32 1, i32 2, i32 3], align 16
@avail = hidden global i32 0, align 4
@dirs = internal global [4 x [2 x i32]] [[2 x i32] [i32 -2, i32 0], [2 x i32] [i32 0, i32 2], [2 x i32] [i32 2, i32 0], [2 x i32] [i32 0, i32 -2]], align 16
@.str.3 = private unnamed_addr constant [1 x i8] zeroinitializer, align 1

; Function Attrs: noinline nounwind optnone
define hidden i32 @irand(i32 %n) #0 {
entry:
  %n.addr = alloca i32, align 4
  %r = alloca i32, align 4
  %rmax = alloca i32, align 4
  store i32 %n, i32* %n.addr, align 4
  %0 = load i32, i32* %n.addr, align 4
  %1 = load i32, i32* %n.addr, align 4
  %div = sdiv i32 2147483647, %1
  %mul = mul nsw i32 %0, %div
  store i32 %mul, i32* %rmax, align 4
  br label %while.cond

while.cond:                                       ; preds = %while.body, %entry
  %call = call i32 @rand()
  store i32 %call, i32* %r, align 4
  %2 = load i32, i32* %rmax, align 4
  %cmp = icmp sge i32 %call, %2
  br i1 %cmp, label %while.body, label %while.end

while.body:                                       ; preds = %while.cond
  br label %while.cond

while.end:                                        ; preds = %while.cond
  %3 = load i32, i32* %r, align 4
  %4 = load i32, i32* %n.addr, align 4
  %div1 = sdiv i32 2147483647, %4
  %div2 = sdiv i32 %3, %div1
  ret i32 %div2
}

declare i32 @rand() #1

; Function Attrs: noinline nounwind optnone
define hidden void @show() #0 {
entry:
  %i = alloca i32, align 4
  %j = alloca i32, align 4
  %c = alloca i32, align 4
  store i32 0, i32* %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc16, %entry
  %0 = load i32, i32* %i, align 4
  %1 = load i32, i32* @h, align 4
  %mul = mul nsw i32 2, %1
  %cmp = icmp sle i32 %0, %mul
  br i1 %cmp, label %for.body, label %for.end18

for.body:                                         ; preds = %for.cond
  store i32 0, i32* %j, align 4
  br label %for.cond1

for.cond1:                                        ; preds = %for.inc, %for.body
  %2 = load i32, i32* %j, align 4
  %3 = load i32, i32* @w, align 4
  %mul2 = mul nsw i32 2, %3
  %cmp3 = icmp sle i32 %2, %mul2
  br i1 %cmp3, label %for.body4, label %for.end

for.body4:                                        ; preds = %for.cond1
  %4 = load i8**, i8*** @cell, align 4
  %5 = load i32, i32* %i, align 4
  %arrayidx = getelementptr inbounds i8*, i8** %4, i32 %5
  %6 = load i8*, i8** %arrayidx, align 4
  %7 = load i32, i32* %j, align 4
  %arrayidx5 = getelementptr inbounds i8, i8* %6, i32 %7
  %8 = load i8, i8* %arrayidx5, align 1
  %conv = zext i8 %8 to i32
  store i32 %conv, i32* %c, align 4
  %9 = load i32, i32* %c, align 4
  %cmp6 = icmp sgt i32 %9, 16
  br i1 %cmp6, label %if.then, label %if.end

if.then:                                          ; preds = %for.body4
  %call = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([6 x i8], [6 x i8]* @.str, i32 0, i32 0))
  br label %if.end

if.end:                                           ; preds = %if.then, %for.body4
  %10 = load i32, i32* %c, align 4
  %arrayidx8 = getelementptr inbounds [30 x i32], [30 x i32]* @glyph, i32 0, i32 %10
  %11 = load i32, i32* %arrayidx8, align 4
  %call9 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([4 x i8], [4 x i8]* @.str.1, i32 0, i32 0), i32 %11)
  %12 = load i32, i32* %c, align 4
  %cmp10 = icmp sgt i32 %12, 16
  br i1 %cmp10, label %if.then12, label %if.end14

if.then12:                                        ; preds = %if.end
  %call13 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([4 x i8], [4 x i8]* @.str.2, i32 0, i32 0))
  br label %if.end14

if.end14:                                         ; preds = %if.then12, %if.end
  br label %for.inc

for.inc:                                          ; preds = %if.end14
  %13 = load i32, i32* %j, align 4
  %inc = add nsw i32 %13, 1
  store i32 %inc, i32* %j, align 4
  br label %for.cond1

for.end:                                          ; preds = %for.cond1
  %call15 = call i32 @putchar(i32 10)
  br label %for.inc16

for.inc16:                                        ; preds = %for.end
  %14 = load i32, i32* %i, align 4
  %inc17 = add nsw i32 %14, 1
  store i32 %inc17, i32* %i, align 4
  br label %for.cond

for.end18:                                        ; preds = %for.cond
  ret void
}

declare i32 @printf(i8* %0, ...) #1

declare i32 @putchar(i32 %0) #1

; Function Attrs: noinline nounwind optnone
define hidden void @walk(i32 %x, i32 %y) #0 {
entry:
  %x.addr = alloca i32, align 4
  %y.addr = alloca i32, align 4
  %i = alloca i32, align 4
  %t = alloca i32, align 4
  %x1 = alloca i32, align 4
  %y1 = alloca i32, align 4
  %d = alloca [4 x i32], align 16
  store i32 %x, i32* %x.addr, align 4
  store i32 %y, i32* %y.addr, align 4
  %0 = bitcast [4 x i32]* %d to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 16 %0, i8* align 16 bitcast ([4 x i32]* @__const.walk.d to i8*), i32 16, i1 false)
  %1 = load i8**, i8*** @cell, align 4
  %2 = load i32, i32* %y.addr, align 4
  %arrayidx = getelementptr inbounds i8*, i8** %1, i32 %2
  %3 = load i8*, i8** %arrayidx, align 4
  %4 = load i32, i32* %x.addr, align 4
  %arrayidx1 = getelementptr inbounds i8, i8* %3, i32 %4
  %5 = load i8, i8* %arrayidx1, align 1
  %conv = zext i8 %5 to i32
  %or = or i32 %conv, 16
  %conv2 = trunc i32 %or to i8
  store i8 %conv2, i8* %arrayidx1, align 1
  %6 = load i32, i32* @avail, align 4
  %dec = add nsw i32 %6, -1
  store i32 %dec, i32* @avail, align 4
  store i32 3, i32* %x1, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %7 = load i32, i32* %x1, align 4
  %tobool = icmp ne i32 %7, 0
  br i1 %tobool, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %8 = load i32, i32* %x1, align 4
  %9 = load i32, i32* %x1, align 4
  %add = add nsw i32 %9, 1
  %call = call i32 @irand(i32 %add)
  store i32 %call, i32* %y1, align 4
  %cmp = icmp ne i32 %8, %call
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %for.body
  %10 = load i32, i32* %x1, align 4
  %arrayidx4 = getelementptr inbounds [4 x i32], [4 x i32]* %d, i32 0, i32 %10
  %11 = load i32, i32* %arrayidx4, align 4
  store i32 %11, i32* %i, align 4
  %12 = load i32, i32* %y1, align 4
  %arrayidx5 = getelementptr inbounds [4 x i32], [4 x i32]* %d, i32 0, i32 %12
  %13 = load i32, i32* %arrayidx5, align 4
  %14 = load i32, i32* %x1, align 4
  %arrayidx6 = getelementptr inbounds [4 x i32], [4 x i32]* %d, i32 0, i32 %14
  store i32 %13, i32* %arrayidx6, align 4
  %15 = load i32, i32* %i, align 4
  %16 = load i32, i32* %y1, align 4
  %arrayidx7 = getelementptr inbounds [4 x i32], [4 x i32]* %d, i32 0, i32 %16
  store i32 %15, i32* %arrayidx7, align 4
  br label %if.end

if.end:                                           ; preds = %if.then, %for.body
  br label %for.inc

for.inc:                                          ; preds = %if.end
  %17 = load i32, i32* %x1, align 4
  %dec8 = add nsw i32 %17, -1
  store i32 %dec8, i32* %x1, align 4
  br label %for.cond

for.end:                                          ; preds = %for.cond
  store i32 0, i32* %i, align 4
  br label %for.cond9

for.cond9:                                        ; preds = %for.inc72, %for.end
  %18 = load i32, i32* @avail, align 4
  %tobool10 = icmp ne i32 %18, 0
  br i1 %tobool10, label %land.rhs, label %land.end

land.rhs:                                         ; preds = %for.cond9
  %19 = load i32, i32* %i, align 4
  %cmp11 = icmp slt i32 %19, 4
  br label %land.end

land.end:                                         ; preds = %land.rhs, %for.cond9
  %20 = phi i1 [ false, %for.cond9 ], [ %cmp11, %land.rhs ]
  br i1 %20, label %for.body13, label %for.end73

for.body13:                                       ; preds = %land.end
  %21 = load i32, i32* %x.addr, align 4
  %22 = load i32, i32* %i, align 4
  %arrayidx14 = getelementptr inbounds [4 x i32], [4 x i32]* %d, i32 0, i32 %22
  %23 = load i32, i32* %arrayidx14, align 4
  %arrayidx15 = getelementptr inbounds [4 x [2 x i32]], [4 x [2 x i32]]* @dirs, i32 0, i32 %23
  %arrayidx16 = getelementptr inbounds [2 x i32], [2 x i32]* %arrayidx15, i32 0, i32 0
  %24 = load i32, i32* %arrayidx16, align 8
  %add17 = add nsw i32 %21, %24
  store i32 %add17, i32* %x1, align 4
  %25 = load i32, i32* %y.addr, align 4
  %26 = load i32, i32* %i, align 4
  %arrayidx18 = getelementptr inbounds [4 x i32], [4 x i32]* %d, i32 0, i32 %26
  %27 = load i32, i32* %arrayidx18, align 4
  %arrayidx19 = getelementptr inbounds [4 x [2 x i32]], [4 x [2 x i32]]* @dirs, i32 0, i32 %27
  %arrayidx20 = getelementptr inbounds [2 x i32], [2 x i32]* %arrayidx19, i32 0, i32 1
  %28 = load i32, i32* %arrayidx20, align 4
  %add21 = add nsw i32 %25, %28
  store i32 %add21, i32* %y1, align 4
  %29 = load i8**, i8*** @cell, align 4
  %30 = load i32, i32* %y1, align 4
  %arrayidx22 = getelementptr inbounds i8*, i8** %29, i32 %30
  %31 = load i8*, i8** %arrayidx22, align 4
  %32 = load i32, i32* %x1, align 4
  %arrayidx23 = getelementptr inbounds i8, i8* %31, i32 %32
  %33 = load i8, i8* %arrayidx23, align 1
  %conv24 = zext i8 %33 to i32
  %and = and i32 %conv24, 16
  %tobool25 = icmp ne i32 %and, 0
  br i1 %tobool25, label %if.then26, label %if.end27

if.then26:                                        ; preds = %for.body13
  br label %for.inc72

if.end27:                                         ; preds = %for.body13
  %34 = load i32, i32* %x1, align 4
  %35 = load i32, i32* %x.addr, align 4
  %cmp28 = icmp eq i32 %34, %35
  br i1 %cmp28, label %if.then30, label %if.else

if.then30:                                        ; preds = %if.end27
  %36 = load i32, i32* %y.addr, align 4
  %37 = load i32, i32* %y1, align 4
  %add31 = add nsw i32 %36, %37
  %div = sdiv i32 %add31, 2
  store i32 %div, i32* %t, align 4
  %38 = load i8**, i8*** @cell, align 4
  %39 = load i32, i32* %t, align 4
  %arrayidx32 = getelementptr inbounds i8*, i8** %38, i32 %39
  %40 = load i8*, i8** %arrayidx32, align 4
  %41 = load i32, i32* %x.addr, align 4
  %add33 = add nsw i32 %41, 1
  %arrayidx34 = getelementptr inbounds i8, i8* %40, i32 %add33
  %42 = load i8, i8* %arrayidx34, align 1
  %conv35 = zext i8 %42 to i32
  %and36 = and i32 %conv35, -5
  %conv37 = trunc i32 %and36 to i8
  store i8 %conv37, i8* %arrayidx34, align 1
  %43 = load i8**, i8*** @cell, align 4
  %44 = load i32, i32* %t, align 4
  %arrayidx38 = getelementptr inbounds i8*, i8** %43, i32 %44
  %45 = load i8*, i8** %arrayidx38, align 4
  %46 = load i32, i32* %x.addr, align 4
  %arrayidx39 = getelementptr inbounds i8, i8* %45, i32 %46
  %47 = load i8, i8* %arrayidx39, align 1
  %conv40 = zext i8 %47 to i32
  %and41 = and i32 %conv40, -13
  %conv42 = trunc i32 %and41 to i8
  store i8 %conv42, i8* %arrayidx39, align 1
  %48 = load i8**, i8*** @cell, align 4
  %49 = load i32, i32* %t, align 4
  %arrayidx43 = getelementptr inbounds i8*, i8** %48, i32 %49
  %50 = load i8*, i8** %arrayidx43, align 4
  %51 = load i32, i32* %x.addr, align 4
  %sub = sub nsw i32 %51, 1
  %arrayidx44 = getelementptr inbounds i8, i8* %50, i32 %sub
  %52 = load i8, i8* %arrayidx44, align 1
  %conv45 = zext i8 %52 to i32
  %and46 = and i32 %conv45, -9
  %conv47 = trunc i32 %and46 to i8
  store i8 %conv47, i8* %arrayidx44, align 1
  br label %if.end71

if.else:                                          ; preds = %if.end27
  %53 = load i32, i32* %y1, align 4
  %54 = load i32, i32* %y.addr, align 4
  %cmp48 = icmp eq i32 %53, %54
  br i1 %cmp48, label %if.then50, label %if.end70

if.then50:                                        ; preds = %if.else
  %55 = load i32, i32* %x.addr, align 4
  %56 = load i32, i32* %x1, align 4
  %add51 = add nsw i32 %55, %56
  %div52 = sdiv i32 %add51, 2
  store i32 %div52, i32* %t, align 4
  %57 = load i8**, i8*** @cell, align 4
  %58 = load i32, i32* %y.addr, align 4
  %sub53 = sub nsw i32 %58, 1
  %arrayidx54 = getelementptr inbounds i8*, i8** %57, i32 %sub53
  %59 = load i8*, i8** %arrayidx54, align 4
  %60 = load i32, i32* %t, align 4
  %arrayidx55 = getelementptr inbounds i8, i8* %59, i32 %60
  %61 = load i8, i8* %arrayidx55, align 1
  %conv56 = zext i8 %61 to i32
  %and57 = and i32 %conv56, -3
  %conv58 = trunc i32 %and57 to i8
  store i8 %conv58, i8* %arrayidx55, align 1
  %62 = load i8**, i8*** @cell, align 4
  %63 = load i32, i32* %y.addr, align 4
  %arrayidx59 = getelementptr inbounds i8*, i8** %62, i32 %63
  %64 = load i8*, i8** %arrayidx59, align 4
  %65 = load i32, i32* %t, align 4
  %arrayidx60 = getelementptr inbounds i8, i8* %64, i32 %65
  %66 = load i8, i8* %arrayidx60, align 1
  %conv61 = zext i8 %66 to i32
  %and62 = and i32 %conv61, -4
  %conv63 = trunc i32 %and62 to i8
  store i8 %conv63, i8* %arrayidx60, align 1
  %67 = load i8**, i8*** @cell, align 4
  %68 = load i32, i32* %y.addr, align 4
  %add64 = add nsw i32 %68, 1
  %arrayidx65 = getelementptr inbounds i8*, i8** %67, i32 %add64
  %69 = load i8*, i8** %arrayidx65, align 4
  %70 = load i32, i32* %t, align 4
  %arrayidx66 = getelementptr inbounds i8, i8* %69, i32 %70
  %71 = load i8, i8* %arrayidx66, align 1
  %conv67 = zext i8 %71 to i32
  %and68 = and i32 %conv67, -2
  %conv69 = trunc i32 %and68 to i8
  store i8 %conv69, i8* %arrayidx66, align 1
  br label %if.end70

if.end70:                                         ; preds = %if.then50, %if.else
  br label %if.end71

if.end71:                                         ; preds = %if.end70, %if.then30
  %72 = load i32, i32* %x1, align 4
  %73 = load i32, i32* %y1, align 4
  call void @walk(i32 %72, i32 %73)
  br label %for.inc72

for.inc72:                                        ; preds = %if.end71, %if.then26
  %74 = load i32, i32* %i, align 4
  %inc = add nsw i32 %74, 1
  store i32 %inc, i32* %i, align 4
  br label %for.cond9

for.end73:                                        ; preds = %land.end
  ret void
}

; Function Attrs: argmemonly nounwind willreturn
declare void @llvm.memcpy.p0i8.p0i8.i32(i8* noalias nocapture writeonly %0, i8* noalias nocapture readonly %1, i32 %2, i1 immarg %3) #2

; Function Attrs: noinline nounwind optnone
define hidden i32 @solve(i32 %x, i32 %y, i32 %tox, i32 %toy) #0 {
entry:
  %retval = alloca i32, align 4
  %x.addr = alloca i32, align 4
  %y.addr = alloca i32, align 4
  %tox.addr = alloca i32, align 4
  %toy.addr = alloca i32, align 4
  %i = alloca i32, align 4
  %t = alloca i32, align 4
  %x1 = alloca i32, align 4
  %y1 = alloca i32, align 4
  store i32 %x, i32* %x.addr, align 4
  store i32 %y, i32* %y.addr, align 4
  store i32 %tox, i32* %tox.addr, align 4
  store i32 %toy, i32* %toy.addr, align 4
  %0 = load i8**, i8*** @cell, align 4
  %1 = load i32, i32* %y.addr, align 4
  %arrayidx = getelementptr inbounds i8*, i8** %0, i32 %1
  %2 = load i8*, i8** %arrayidx, align 4
  %3 = load i32, i32* %x.addr, align 4
  %arrayidx1 = getelementptr inbounds i8, i8* %2, i32 %3
  %4 = load i8, i8* %arrayidx1, align 1
  %conv = zext i8 %4 to i32
  %or = or i32 %conv, 16
  %conv2 = trunc i32 %or to i8
  store i8 %conv2, i8* %arrayidx1, align 1
  %5 = load i32, i32* %x.addr, align 4
  %6 = load i32, i32* %tox.addr, align 4
  %cmp = icmp eq i32 %5, %6
  br i1 %cmp, label %land.lhs.true, label %if.end

land.lhs.true:                                    ; preds = %entry
  %7 = load i32, i32* %y.addr, align 4
  %8 = load i32, i32* %toy.addr, align 4
  %cmp4 = icmp eq i32 %7, %8
  br i1 %cmp4, label %if.then, label %if.end

if.then:                                          ; preds = %land.lhs.true
  store i32 1, i32* %retval, align 4
  br label %return

if.end:                                           ; preds = %land.lhs.true, %entry
  store i32 0, i32* %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.end
  %9 = load i32, i32* %i, align 4
  %cmp6 = icmp sle i32 %9, 3
  br i1 %cmp6, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %10 = load i32, i32* %x.addr, align 4
  %11 = load i32, i32* %i, align 4
  %arrayidx8 = getelementptr inbounds [4 x [2 x i32]], [4 x [2 x i32]]* @dirs, i32 0, i32 %11
  %arrayidx9 = getelementptr inbounds [2 x i32], [2 x i32]* %arrayidx8, i32 0, i32 0
  %12 = load i32, i32* %arrayidx9, align 8
  %add = add nsw i32 %10, %12
  store i32 %add, i32* %x1, align 4
  %13 = load i32, i32* %y.addr, align 4
  %14 = load i32, i32* %i, align 4
  %arrayidx10 = getelementptr inbounds [4 x [2 x i32]], [4 x [2 x i32]]* @dirs, i32 0, i32 %14
  %arrayidx11 = getelementptr inbounds [2 x i32], [2 x i32]* %arrayidx10, i32 0, i32 1
  %15 = load i32, i32* %arrayidx11, align 4
  %add12 = add nsw i32 %13, %15
  store i32 %add12, i32* %y1, align 4
  %16 = load i8**, i8*** @cell, align 4
  %17 = load i32, i32* %y1, align 4
  %arrayidx13 = getelementptr inbounds i8*, i8** %16, i32 %17
  %18 = load i8*, i8** %arrayidx13, align 4
  %19 = load i32, i32* %x1, align 4
  %arrayidx14 = getelementptr inbounds i8, i8* %18, i32 %19
  %20 = load i8, i8* %arrayidx14, align 1
  %tobool = icmp ne i8 %20, 0
  br i1 %tobool, label %if.then15, label %if.end16

if.then15:                                        ; preds = %for.body
  br label %for.inc

if.end16:                                         ; preds = %for.body
  %21 = load i32, i32* %x1, align 4
  %22 = load i32, i32* %x.addr, align 4
  %cmp17 = icmp eq i32 %21, %22
  br i1 %cmp17, label %if.then19, label %if.else

if.then19:                                        ; preds = %if.end16
  %23 = load i32, i32* %y.addr, align 4
  %24 = load i32, i32* %y1, align 4
  %add20 = add nsw i32 %23, %24
  %div = sdiv i32 %add20, 2
  store i32 %div, i32* %t, align 4
  %25 = load i8**, i8*** @cell, align 4
  %26 = load i32, i32* %t, align 4
  %arrayidx21 = getelementptr inbounds i8*, i8** %25, i32 %26
  %27 = load i8*, i8** %arrayidx21, align 4
  %28 = load i32, i32* %x.addr, align 4
  %arrayidx22 = getelementptr inbounds i8, i8* %27, i32 %28
  %29 = load i8, i8* %arrayidx22, align 1
  %conv23 = zext i8 %29 to i32
  %tobool24 = icmp ne i32 %conv23, 0
  br i1 %tobool24, label %if.then26, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %if.then19
  %30 = load i32, i32* %x1, align 4
  %31 = load i32, i32* %y1, align 4
  %32 = load i32, i32* %tox.addr, align 4
  %33 = load i32, i32* %toy.addr, align 4
  %call = call i32 @solve(i32 %30, i32 %31, i32 %32, i32 %33)
  %tobool25 = icmp ne i32 %call, 0
  br i1 %tobool25, label %if.end27, label %if.then26

if.then26:                                        ; preds = %lor.lhs.false, %if.then19
  br label %for.inc

if.end27:                                         ; preds = %lor.lhs.false
  %34 = load i8**, i8*** @cell, align 4
  %35 = load i32, i32* %t, align 4
  %sub = sub nsw i32 %35, 1
  %arrayidx28 = getelementptr inbounds i8*, i8** %34, i32 %sub
  %36 = load i8*, i8** %arrayidx28, align 4
  %37 = load i32, i32* %x.addr, align 4
  %arrayidx29 = getelementptr inbounds i8, i8* %36, i32 %37
  %38 = load i8, i8* %arrayidx29, align 1
  %conv30 = zext i8 %38 to i32
  %or31 = or i32 %conv30, 2
  %conv32 = trunc i32 %or31 to i8
  store i8 %conv32, i8* %arrayidx29, align 1
  %39 = load i8**, i8*** @cell, align 4
  %40 = load i32, i32* %t, align 4
  %arrayidx33 = getelementptr inbounds i8*, i8** %39, i32 %40
  %41 = load i8*, i8** %arrayidx33, align 4
  %42 = load i32, i32* %x.addr, align 4
  %arrayidx34 = getelementptr inbounds i8, i8* %41, i32 %42
  %43 = load i8, i8* %arrayidx34, align 1
  %conv35 = zext i8 %43 to i32
  %or36 = or i32 %conv35, 19
  %conv37 = trunc i32 %or36 to i8
  store i8 %conv37, i8* %arrayidx34, align 1
  %44 = load i8**, i8*** @cell, align 4
  %45 = load i32, i32* %t, align 4
  %add38 = add nsw i32 %45, 1
  %arrayidx39 = getelementptr inbounds i8*, i8** %44, i32 %add38
  %46 = load i8*, i8** %arrayidx39, align 4
  %47 = load i32, i32* %x.addr, align 4
  %arrayidx40 = getelementptr inbounds i8, i8* %46, i32 %47
  %48 = load i8, i8* %arrayidx40, align 1
  %conv41 = zext i8 %48 to i32
  %or42 = or i32 %conv41, 1
  %conv43 = trunc i32 %or42 to i8
  store i8 %conv43, i8* %arrayidx40, align 1
  br label %if.end76

if.else:                                          ; preds = %if.end16
  %49 = load i32, i32* %y1, align 4
  %50 = load i32, i32* %y.addr, align 4
  %cmp44 = icmp eq i32 %49, %50
  br i1 %cmp44, label %if.then46, label %if.end75

if.then46:                                        ; preds = %if.else
  %51 = load i32, i32* %x.addr, align 4
  %52 = load i32, i32* %x1, align 4
  %add47 = add nsw i32 %51, %52
  %div48 = sdiv i32 %add47, 2
  store i32 %div48, i32* %t, align 4
  %53 = load i8**, i8*** @cell, align 4
  %54 = load i32, i32* %y.addr, align 4
  %arrayidx49 = getelementptr inbounds i8*, i8** %53, i32 %54
  %55 = load i8*, i8** %arrayidx49, align 4
  %56 = load i32, i32* %t, align 4
  %arrayidx50 = getelementptr inbounds i8, i8* %55, i32 %56
  %57 = load i8, i8* %arrayidx50, align 1
  %conv51 = zext i8 %57 to i32
  %tobool52 = icmp ne i32 %conv51, 0
  br i1 %tobool52, label %if.then56, label %lor.lhs.false53

lor.lhs.false53:                                  ; preds = %if.then46
  %58 = load i32, i32* %x1, align 4
  %59 = load i32, i32* %y1, align 4
  %60 = load i32, i32* %tox.addr, align 4
  %61 = load i32, i32* %toy.addr, align 4
  %call54 = call i32 @solve(i32 %58, i32 %59, i32 %60, i32 %61)
  %tobool55 = icmp ne i32 %call54, 0
  br i1 %tobool55, label %if.end57, label %if.then56

if.then56:                                        ; preds = %lor.lhs.false53, %if.then46
  br label %for.inc

if.end57:                                         ; preds = %lor.lhs.false53
  %62 = load i8**, i8*** @cell, align 4
  %63 = load i32, i32* %y.addr, align 4
  %arrayidx58 = getelementptr inbounds i8*, i8** %62, i32 %63
  %64 = load i8*, i8** %arrayidx58, align 4
  %65 = load i32, i32* %t, align 4
  %sub59 = sub nsw i32 %65, 1
  %arrayidx60 = getelementptr inbounds i8, i8* %64, i32 %sub59
  %66 = load i8, i8* %arrayidx60, align 1
  %conv61 = zext i8 %66 to i32
  %or62 = or i32 %conv61, 8
  %conv63 = trunc i32 %or62 to i8
  store i8 %conv63, i8* %arrayidx60, align 1
  %67 = load i8**, i8*** @cell, align 4
  %68 = load i32, i32* %y.addr, align 4
  %arrayidx64 = getelementptr inbounds i8*, i8** %67, i32 %68
  %69 = load i8*, i8** %arrayidx64, align 4
  %70 = load i32, i32* %t, align 4
  %arrayidx65 = getelementptr inbounds i8, i8* %69, i32 %70
  %71 = load i8, i8* %arrayidx65, align 1
  %conv66 = zext i8 %71 to i32
  %or67 = or i32 %conv66, 28
  %conv68 = trunc i32 %or67 to i8
  store i8 %conv68, i8* %arrayidx65, align 1
  %72 = load i8**, i8*** @cell, align 4
  %73 = load i32, i32* %y.addr, align 4
  %arrayidx69 = getelementptr inbounds i8*, i8** %72, i32 %73
  %74 = load i8*, i8** %arrayidx69, align 4
  %75 = load i32, i32* %t, align 4
  %add70 = add nsw i32 %75, 1
  %arrayidx71 = getelementptr inbounds i8, i8* %74, i32 %add70
  %76 = load i8, i8* %arrayidx71, align 1
  %conv72 = zext i8 %76 to i32
  %or73 = or i32 %conv72, 4
  %conv74 = trunc i32 %or73 to i8
  store i8 %conv74, i8* %arrayidx71, align 1
  br label %if.end75

if.end75:                                         ; preds = %if.end57, %if.else
  br label %if.end76

if.end76:                                         ; preds = %if.end75, %if.end27
  store i32 1, i32* %retval, align 4
  br label %return

for.inc:                                          ; preds = %if.then56, %if.then26, %if.then15
  %77 = load i32, i32* %i, align 4
  %inc = add nsw i32 %77, 1
  store i32 %inc, i32* %i, align 4
  br label %for.cond

for.end:                                          ; preds = %for.cond
  %78 = load i8**, i8*** @cell, align 4
  %79 = load i32, i32* %y.addr, align 4
  %arrayidx77 = getelementptr inbounds i8*, i8** %78, i32 %79
  %80 = load i8*, i8** %arrayidx77, align 4
  %81 = load i32, i32* %x.addr, align 4
  %arrayidx78 = getelementptr inbounds i8, i8* %80, i32 %81
  %82 = load i8, i8* %arrayidx78, align 1
  %conv79 = zext i8 %82 to i32
  %and = and i32 %conv79, -17
  %conv80 = trunc i32 %and to i8
  store i8 %conv80, i8* %arrayidx78, align 1
  store i32 0, i32* %retval, align 4
  br label %return

return:                                           ; preds = %for.end, %if.end76, %if.then
  %83 = load i32, i32* %retval, align 4
  ret i32 %83
}

; Function Attrs: noinline nounwind optnone
define hidden void @make_maze() #0 {
entry:
  %i = alloca i32, align 4
  %j = alloca i32, align 4
  %h2 = alloca i32, align 4
  %w2 = alloca i32, align 4
  %p = alloca i8**, align 4
  %0 = load i32, i32* @h, align 4
  %mul = mul nsw i32 2, %0
  %add = add nsw i32 %mul, 2
  store i32 %add, i32* %h2, align 4
  %1 = load i32, i32* @w, align 4
  %mul1 = mul nsw i32 2, %1
  %add2 = add nsw i32 %mul1, 2
  store i32 %add2, i32* %w2, align 4
  %2 = load i32, i32* %h2, align 4
  %add3 = add nsw i32 %2, 2
  %mul4 = mul i32 4, %add3
  %3 = load i32, i32* %w2, align 4
  %4 = load i32, i32* %h2, align 4
  %mul5 = mul nsw i32 %3, %4
  %add6 = add i32 %mul4, %mul5
  %add7 = add i32 %add6, 1
  %call = call noalias i8* @calloc(i32 %add7, i32 1)
  %5 = bitcast i8* %call to i8**
  store i8** %5, i8*** %p, align 4
  %6 = load i8**, i8*** %p, align 4
  %7 = load i32, i32* %h2, align 4
  %add.ptr = getelementptr inbounds i8*, i8** %6, i32 %7
  %add.ptr8 = getelementptr inbounds i8*, i8** %add.ptr, i32 2
  %8 = bitcast i8** %add.ptr8 to i8*
  %add.ptr9 = getelementptr inbounds i8, i8* %8, i32 1
  %9 = load i8**, i8*** %p, align 4
  %arrayidx = getelementptr inbounds i8*, i8** %9, i32 1
  store i8* %add.ptr9, i8** %arrayidx, align 4
  store i32 2, i32* %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %10 = load i32, i32* %i, align 4
  %11 = load i32, i32* %h2, align 4
  %cmp = icmp sle i32 %10, %11
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %12 = load i8**, i8*** %p, align 4
  %13 = load i32, i32* %i, align 4
  %sub = sub nsw i32 %13, 1
  %arrayidx10 = getelementptr inbounds i8*, i8** %12, i32 %sub
  %14 = load i8*, i8** %arrayidx10, align 4
  %15 = load i32, i32* %w2, align 4
  %add.ptr11 = getelementptr inbounds i8, i8* %14, i32 %15
  %16 = load i8**, i8*** %p, align 4
  %17 = load i32, i32* %i, align 4
  %arrayidx12 = getelementptr inbounds i8*, i8** %16, i32 %17
  store i8* %add.ptr11, i8** %arrayidx12, align 4
  br label %for.inc

for.inc:                                          ; preds = %for.body
  %18 = load i32, i32* %i, align 4
  %inc = add nsw i32 %18, 1
  store i32 %inc, i32* %i, align 4
  br label %for.cond

for.end:                                          ; preds = %for.cond
  %19 = load i8**, i8*** %p, align 4
  %20 = load i32, i32* %h2, align 4
  %arrayidx13 = getelementptr inbounds i8*, i8** %19, i32 %20
  %21 = load i8*, i8** %arrayidx13, align 4
  %22 = load i8**, i8*** %p, align 4
  %arrayidx14 = getelementptr inbounds i8*, i8** %22, i32 0
  store i8* %21, i8** %arrayidx14, align 4
  %23 = load i8**, i8*** %p, align 4
  %arrayidx15 = getelementptr inbounds i8*, i8** %23, i32 1
  store i8** %arrayidx15, i8*** @cell, align 4
  store i32 -1, i32* %i, align 4
  br label %for.cond16

for.cond16:                                       ; preds = %for.inc26, %for.end
  %24 = load i32, i32* %i, align 4
  %25 = load i32, i32* @h, align 4
  %mul17 = mul nsw i32 2, %25
  %add18 = add nsw i32 %mul17, 1
  %cmp19 = icmp sle i32 %24, %add18
  br i1 %cmp19, label %for.body20, label %for.end28

for.body20:                                       ; preds = %for.cond16
  %26 = load i8**, i8*** @cell, align 4
  %27 = load i32, i32* %i, align 4
  %arrayidx21 = getelementptr inbounds i8*, i8** %26, i32 %27
  %28 = load i8*, i8** %arrayidx21, align 4
  %29 = load i32, i32* %w2, align 4
  %sub22 = sub nsw i32 %29, 1
  %arrayidx23 = getelementptr inbounds i8, i8* %28, i32 %sub22
  store i8 16, i8* %arrayidx23, align 1
  %30 = load i8**, i8*** @cell, align 4
  %31 = load i32, i32* %i, align 4
  %arrayidx24 = getelementptr inbounds i8*, i8** %30, i32 %31
  %32 = load i8*, i8** %arrayidx24, align 4
  %arrayidx25 = getelementptr inbounds i8, i8* %32, i32 -1
  store i8 16, i8* %arrayidx25, align 1
  br label %for.inc26

for.inc26:                                        ; preds = %for.body20
  %33 = load i32, i32* %i, align 4
  %inc27 = add nsw i32 %33, 1
  store i32 %inc27, i32* %i, align 4
  br label %for.cond16

for.end28:                                        ; preds = %for.cond16
  store i32 0, i32* %j, align 4
  br label %for.cond29

for.cond29:                                       ; preds = %for.inc38, %for.end28
  %34 = load i32, i32* %j, align 4
  %35 = load i32, i32* @w, align 4
  %mul30 = mul nsw i32 2, %35
  %cmp31 = icmp sle i32 %34, %mul30
  br i1 %cmp31, label %for.body32, label %for.end40

for.body32:                                       ; preds = %for.cond29
  %36 = load i8**, i8*** @cell, align 4
  %37 = load i32, i32* %h2, align 4
  %sub33 = sub nsw i32 %37, 1
  %arrayidx34 = getelementptr inbounds i8*, i8** %36, i32 %sub33
  %38 = load i8*, i8** %arrayidx34, align 4
  %39 = load i32, i32* %j, align 4
  %arrayidx35 = getelementptr inbounds i8, i8* %38, i32 %39
  store i8 16, i8* %arrayidx35, align 1
  %40 = load i8**, i8*** @cell, align 4
  %arrayidx36 = getelementptr inbounds i8*, i8** %40, i32 -1
  %41 = load i8*, i8** %arrayidx36, align 4
  %42 = load i32, i32* %j, align 4
  %arrayidx37 = getelementptr inbounds i8, i8* %41, i32 %42
  store i8 16, i8* %arrayidx37, align 1
  br label %for.inc38

for.inc38:                                        ; preds = %for.body32
  %43 = load i32, i32* %j, align 4
  %inc39 = add nsw i32 %43, 1
  store i32 %inc39, i32* %j, align 4
  br label %for.cond29

for.end40:                                        ; preds = %for.cond29
  store i32 0, i32* %i, align 4
  br label %for.cond41

for.cond41:                                       ; preds = %for.inc55, %for.end40
  %44 = load i32, i32* %i, align 4
  %45 = load i32, i32* @h, align 4
  %cmp42 = icmp sle i32 %44, %45
  br i1 %cmp42, label %for.body43, label %for.end57

for.body43:                                       ; preds = %for.cond41
  store i32 0, i32* %j, align 4
  br label %for.cond44

for.cond44:                                       ; preds = %for.inc52, %for.body43
  %46 = load i32, i32* %j, align 4
  %47 = load i32, i32* @w, align 4
  %mul45 = mul nsw i32 2, %47
  %cmp46 = icmp sle i32 %46, %mul45
  br i1 %cmp46, label %for.body47, label %for.end54

for.body47:                                       ; preds = %for.cond44
  %48 = load i8**, i8*** @cell, align 4
  %49 = load i32, i32* %i, align 4
  %mul48 = mul nsw i32 2, %49
  %arrayidx49 = getelementptr inbounds i8*, i8** %48, i32 %mul48
  %50 = load i8*, i8** %arrayidx49, align 4
  %51 = load i32, i32* %j, align 4
  %arrayidx50 = getelementptr inbounds i8, i8* %50, i32 %51
  %52 = load i8, i8* %arrayidx50, align 1
  %conv = zext i8 %52 to i32
  %or = or i32 %conv, 12
  %conv51 = trunc i32 %or to i8
  store i8 %conv51, i8* %arrayidx50, align 1
  br label %for.inc52

for.inc52:                                        ; preds = %for.body47
  %53 = load i32, i32* %j, align 4
  %inc53 = add nsw i32 %53, 1
  store i32 %inc53, i32* %j, align 4
  br label %for.cond44

for.end54:                                        ; preds = %for.cond44
  br label %for.inc55

for.inc55:                                        ; preds = %for.end54
  %54 = load i32, i32* %i, align 4
  %inc56 = add nsw i32 %54, 1
  store i32 %inc56, i32* %i, align 4
  br label %for.cond41

for.end57:                                        ; preds = %for.cond41
  store i32 0, i32* %i, align 4
  br label %for.cond58

for.cond58:                                       ; preds = %for.inc76, %for.end57
  %55 = load i32, i32* %i, align 4
  %56 = load i32, i32* @h, align 4
  %mul59 = mul nsw i32 2, %56
  %cmp60 = icmp sle i32 %55, %mul59
  br i1 %cmp60, label %for.body62, label %for.end78

for.body62:                                       ; preds = %for.cond58
  store i32 0, i32* %j, align 4
  br label %for.cond63

for.cond63:                                       ; preds = %for.inc73, %for.body62
  %57 = load i32, i32* %j, align 4
  %58 = load i32, i32* @w, align 4
  %cmp64 = icmp sle i32 %57, %58
  br i1 %cmp64, label %for.body66, label %for.end75

for.body66:                                       ; preds = %for.cond63
  %59 = load i8**, i8*** @cell, align 4
  %60 = load i32, i32* %i, align 4
  %arrayidx67 = getelementptr inbounds i8*, i8** %59, i32 %60
  %61 = load i8*, i8** %arrayidx67, align 4
  %62 = load i32, i32* %j, align 4
  %mul68 = mul nsw i32 2, %62
  %arrayidx69 = getelementptr inbounds i8, i8* %61, i32 %mul68
  %63 = load i8, i8* %arrayidx69, align 1
  %conv70 = zext i8 %63 to i32
  %or71 = or i32 %conv70, 3
  %conv72 = trunc i32 %or71 to i8
  store i8 %conv72, i8* %arrayidx69, align 1
  br label %for.inc73

for.inc73:                                        ; preds = %for.body66
  %64 = load i32, i32* %j, align 4
  %inc74 = add nsw i32 %64, 1
  store i32 %inc74, i32* %j, align 4
  br label %for.cond63

for.end75:                                        ; preds = %for.cond63
  br label %for.inc76

for.inc76:                                        ; preds = %for.end75
  %65 = load i32, i32* %i, align 4
  %inc77 = add nsw i32 %65, 1
  store i32 %inc77, i32* %i, align 4
  br label %for.cond58

for.end78:                                        ; preds = %for.cond58
  store i32 0, i32* %j, align 4
  br label %for.cond79

for.cond79:                                       ; preds = %for.inc94, %for.end78
  %66 = load i32, i32* %j, align 4
  %67 = load i32, i32* @w, align 4
  %mul80 = mul nsw i32 2, %67
  %cmp81 = icmp sle i32 %66, %mul80
  br i1 %cmp81, label %for.body83, label %for.end96

for.body83:                                       ; preds = %for.cond79
  %68 = load i8**, i8*** @cell, align 4
  %arrayidx84 = getelementptr inbounds i8*, i8** %68, i32 0
  %69 = load i8*, i8** %arrayidx84, align 4
  %70 = load i32, i32* %j, align 4
  %arrayidx85 = getelementptr inbounds i8, i8* %69, i32 %70
  %71 = load i8, i8* %arrayidx85, align 1
  %conv86 = zext i8 %71 to i32
  %and = and i32 %conv86, -2
  %conv87 = trunc i32 %and to i8
  store i8 %conv87, i8* %arrayidx85, align 1
  %72 = load i8**, i8*** @cell, align 4
  %73 = load i32, i32* @h, align 4
  %mul88 = mul nsw i32 2, %73
  %arrayidx89 = getelementptr inbounds i8*, i8** %72, i32 %mul88
  %74 = load i8*, i8** %arrayidx89, align 4
  %75 = load i32, i32* %j, align 4
  %arrayidx90 = getelementptr inbounds i8, i8* %74, i32 %75
  %76 = load i8, i8* %arrayidx90, align 1
  %conv91 = zext i8 %76 to i32
  %and92 = and i32 %conv91, -3
  %conv93 = trunc i32 %and92 to i8
  store i8 %conv93, i8* %arrayidx90, align 1
  br label %for.inc94

for.inc94:                                        ; preds = %for.body83
  %77 = load i32, i32* %j, align 4
  %inc95 = add nsw i32 %77, 1
  store i32 %inc95, i32* %j, align 4
  br label %for.cond79

for.end96:                                        ; preds = %for.cond79
  store i32 0, i32* %i, align 4
  br label %for.cond97

for.cond97:                                       ; preds = %for.inc113, %for.end96
  %78 = load i32, i32* %i, align 4
  %79 = load i32, i32* @h, align 4
  %mul98 = mul nsw i32 2, %79
  %cmp99 = icmp sle i32 %78, %mul98
  br i1 %cmp99, label %for.body101, label %for.end115

for.body101:                                      ; preds = %for.cond97
  %80 = load i8**, i8*** @cell, align 4
  %81 = load i32, i32* %i, align 4
  %arrayidx102 = getelementptr inbounds i8*, i8** %80, i32 %81
  %82 = load i8*, i8** %arrayidx102, align 4
  %arrayidx103 = getelementptr inbounds i8, i8* %82, i32 0
  %83 = load i8, i8* %arrayidx103, align 1
  %conv104 = zext i8 %83 to i32
  %and105 = and i32 %conv104, -5
  %conv106 = trunc i32 %and105 to i8
  store i8 %conv106, i8* %arrayidx103, align 1
  %84 = load i8**, i8*** @cell, align 4
  %85 = load i32, i32* %i, align 4
  %arrayidx107 = getelementptr inbounds i8*, i8** %84, i32 %85
  %86 = load i8*, i8** %arrayidx107, align 4
  %87 = load i32, i32* @w, align 4
  %mul108 = mul nsw i32 2, %87
  %arrayidx109 = getelementptr inbounds i8, i8* %86, i32 %mul108
  %88 = load i8, i8* %arrayidx109, align 1
  %conv110 = zext i8 %88 to i32
  %and111 = and i32 %conv110, -9
  %conv112 = trunc i32 %and111 to i8
  store i8 %conv112, i8* %arrayidx109, align 1
  br label %for.inc113

for.inc113:                                       ; preds = %for.body101
  %89 = load i32, i32* %i, align 4
  %inc114 = add nsw i32 %89, 1
  store i32 %inc114, i32* %i, align 4
  br label %for.cond97

for.end115:                                       ; preds = %for.cond97
  %90 = load i32, i32* @w, align 4
  %91 = load i32, i32* @h, align 4
  %mul116 = mul nsw i32 %90, %91
  store i32 %mul116, i32* @avail, align 4
  %call117 = call i32 @irand(i32 2)
  %mul118 = mul nsw i32 %call117, 2
  %add119 = add nsw i32 %mul118, 1
  %92 = load i32, i32* @h, align 4
  %call120 = call i32 @irand(i32 %92)
  %mul121 = mul nsw i32 %call120, 2
  %add122 = add nsw i32 %mul121, 1
  call void @walk(i32 %add119, i32 %add122)
  store i32 0, i32* %i, align 4
  br label %for.cond123

for.cond123:                                      ; preds = %for.inc141, %for.end115
  %93 = load i32, i32* %i, align 4
  %94 = load i32, i32* @h, align 4
  %mul124 = mul nsw i32 2, %94
  %cmp125 = icmp sle i32 %93, %mul124
  br i1 %cmp125, label %for.body127, label %for.end143

for.body127:                                      ; preds = %for.cond123
  store i32 0, i32* %j, align 4
  br label %for.cond128

for.cond128:                                      ; preds = %for.inc138, %for.body127
  %95 = load i32, i32* %j, align 4
  %96 = load i32, i32* @w, align 4
  %mul129 = mul nsw i32 2, %96
  %cmp130 = icmp sle i32 %95, %mul129
  br i1 %cmp130, label %for.body132, label %for.end140

for.body132:                                      ; preds = %for.cond128
  %97 = load i8**, i8*** @cell, align 4
  %98 = load i32, i32* %i, align 4
  %arrayidx133 = getelementptr inbounds i8*, i8** %97, i32 %98
  %99 = load i8*, i8** %arrayidx133, align 4
  %100 = load i32, i32* %j, align 4
  %arrayidx134 = getelementptr inbounds i8, i8* %99, i32 %100
  %101 = load i8, i8* %arrayidx134, align 1
  %conv135 = zext i8 %101 to i32
  %and136 = and i32 %conv135, -17
  %conv137 = trunc i32 %and136 to i8
  store i8 %conv137, i8* %arrayidx134, align 1
  br label %for.inc138

for.inc138:                                       ; preds = %for.body132
  %102 = load i32, i32* %j, align 4
  %inc139 = add nsw i32 %102, 1
  store i32 %inc139, i32* %j, align 4
  br label %for.cond128

for.end140:                                       ; preds = %for.cond128
  br label %for.inc141

for.inc141:                                       ; preds = %for.end140
  %103 = load i32, i32* %i, align 4
  %inc142 = add nsw i32 %103, 1
  store i32 %inc142, i32* %i, align 4
  br label %for.cond123

for.end143:                                       ; preds = %for.cond123
  %104 = load i32, i32* @w, align 4
  %mul144 = mul nsw i32 2, %104
  %sub145 = sub nsw i32 %mul144, 1
  %105 = load i32, i32* @h, align 4
  %mul146 = mul nsw i32 2, %105
  %sub147 = sub nsw i32 %mul146, 1
  %call148 = call i32 @solve(i32 1, i32 1, i32 %sub145, i32 %sub147)
  call void @show()
  ret void
}

declare noalias i8* @calloc(i32 %0, i32 %1) #1

; Function Attrs: noinline nounwind optnone
define hidden i32 @__main_argc_argv(i32 %c, i8** %v) #0 {
entry:
  %retval = alloca i32, align 4
  %c.addr = alloca i32, align 4
  %v.addr = alloca i8**, align 4
  store i32 0, i32* %retval, align 4
  store i32 %c, i32* %c.addr, align 4
  store i8** %v, i8*** %v.addr, align 4
  %call = call i8* @setlocale(i32 6, i8* getelementptr inbounds ([1 x i8], [1 x i8]* @.str.3, i32 0, i32 0))
  %0 = load i32, i32* %c.addr, align 4
  %cmp = icmp slt i32 %0, 2
  br i1 %cmp, label %if.then, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %entry
  %1 = load i8**, i8*** %v.addr, align 4
  %arrayidx = getelementptr inbounds i8*, i8** %1, i32 1
  %2 = load i8*, i8** %arrayidx, align 4
  %call1 = call i32 @atoi(i8* %2)
  store i32 %call1, i32* @w, align 4
  %cmp2 = icmp sle i32 %call1, 0
  br i1 %cmp2, label %if.then, label %if.end

if.then:                                          ; preds = %lor.lhs.false, %entry
  store i32 16, i32* @w, align 4
  br label %if.end

if.end:                                           ; preds = %if.then, %lor.lhs.false
  %3 = load i32, i32* %c.addr, align 4
  %cmp3 = icmp slt i32 %3, 3
  br i1 %cmp3, label %if.then8, label %lor.lhs.false4

lor.lhs.false4:                                   ; preds = %if.end
  %4 = load i8**, i8*** %v.addr, align 4
  %arrayidx5 = getelementptr inbounds i8*, i8** %4, i32 2
  %5 = load i8*, i8** %arrayidx5, align 4
  %call6 = call i32 @atoi(i8* %5)
  store i32 %call6, i32* @h, align 4
  %cmp7 = icmp sle i32 %call6, 0
  br i1 %cmp7, label %if.then8, label %if.end9

if.then8:                                         ; preds = %lor.lhs.false4, %if.end
  store i32 8, i32* @h, align 4
  br label %if.end9

if.end9:                                          ; preds = %if.then8, %lor.lhs.false4
  call void @make_maze()
  ret i32 0
}

declare i8* @setlocale(i32 %0, i8* %1) #1

declare i32 @atoi(i8* %0) #1

attributes #0 = { noinline nounwind optnone "correctly-rounded-divide-sqrt-fp-math"="false" "disable-tail-calls"="false" "frame-pointer"="none" "less-precise-fpmad"="false" "min-legal-vector-width"="0" "no-infs-fp-math"="false" "no-jump-tables"="false" "no-nans-fp-math"="false" "no-signed-zeros-fp-math"="false" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="generic" "unsafe-fp-math"="false" "use-soft-float"="false" }
attributes #1 = { "correctly-rounded-divide-sqrt-fp-math"="false" "disable-tail-calls"="false" "frame-pointer"="none" "less-precise-fpmad"="false" "no-infs-fp-math"="false" "no-nans-fp-math"="false" "no-signed-zeros-fp-math"="false" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="generic" "unsafe-fp-math"="false" "use-soft-float"="false" }
attributes #2 = { argmemonly nounwind willreturn }

!llvm.module.flags = !{!0}
!llvm.ident = !{!1}

!0 = !{i32 1, !"wchar_size", i32 4}
!1 = !{!"clang version 11.0.0 (https://github.com/Jacarte/llvm-project.git 0f6dea67136cc1e0b3d200eb2bb165628970c44b)"}

; extracted candidates

; *****
; For LLVM instruction:
;  %0 = load i32, i32* %n.addr, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %1 = load i32, i32* %n.addr, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %div = sdiv i32 2147483647, %1
; Looking for a replacement for:
%0:i32 = var
%1:i32 = sdiv 2147483647:i32, %0
infer %1

; *****
; For LLVM instruction:
;  %mul = mul nsw i32 %0, %div
; Looking for a replacement for:
%0:i32 = var
%1:i32 = var
%2:i32 = sdiv 2147483647:i32, %1
%3:i32 = mulnsw %0, %2
infer %3

; *****
; For LLVM instruction:
;  %call = call i32 @rand()
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %2 = load i32, i32* %rmax, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %cmp = icmp sge i32 %call, %2
; Looking for a replacement for:
%0:i32 = var
%1:i32 = var
%2:i1 = sle %0, %1
infer %2

; *****
; For LLVM instruction:
;  %3 = load i32, i32* %r, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %4 = load i32, i32* %n.addr, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %div1 = sdiv i32 2147483647, %4
; Looking for a replacement for:
%0:i32 = var
%1:i32 = sdiv 2147483647:i32, %0
infer %1

; *****
; For LLVM instruction:
;  %div2 = sdiv i32 %3, %div1
; Looking for a replacement for:
%0:i32 = var
%1:i32 = var
%2:i32 = sdiv 2147483647:i32, %1
%3:i32 = sdiv %0, %2
infer %3
got 1 candidates from LHS

-------------------------------------------------
%0:i32 = var
infer %0


--------------------------------
guess 0

%0:i32 = var ; reservedconst_1

Cost = 0
first query is SAT, returning the model:
reservedconst_1: 0
0 th attempt: second query is SAT-- constant doesn't work
first query is SAT, returning the model:
reservedconst_1: -1
1 th attempt: second query is SAT-- constant doesn't work
first query is UNSAT-- no more guesses
Dataflow Pruned 0/0
There are 1 Guesses
There are 0 RHSs before deduplication
There are 0 RHSs after deduplication
got 2 candidates from LHS

-------------------------------------------------
%0:i32 = var
%1:i32 = sdiv 2147483647:i32, %0
infer %1


--------------------------------
guess 0

%0:i32 = var ; reservedconst_1

Cost = 0
first query is SAT, returning the model:
reservedconst_1: -1
0 th attempt: second query is SAT-- constant doesn't work
first query is SAT, returning the model:
reservedconst_1: 8192
1 th attempt: second query is SAT-- constant doesn't work
first query is UNSAT-- no more guesses

--------------------------------
guess 1

%0:i32 = var

Cost = 0
second query is SAT-- constant doesn't work
Dataflow Pruned 0/0
There are 2 Guesses
There are 0 RHSs before deduplication
There are 0 RHSs after deduplication
got 4 candidates from LHS

-------------------------------------------------
%0:i32 = var
%1:i32 = var
%2:i32 = sdiv 2147483647:i32, %1
%3:i32 = mulnsw %0, %2
infer %3


--------------------------------
guess 0

%0:i32 = var ; reservedconst_1

Cost = 0
first query is SAT, returning the model:
reservedconst_1: 0
ConstantSynthesis: solver returns error on second query

--------------------------------
guess 1

%0:i32 = var

Cost = 0
second query is SAT-- constant doesn't work

--------------------------------
guess 2

%0:i32 = var

Cost = 0
verification query failed!
Dataflow Pruned 0/0
There are 4 Guesses
There are 0 RHSs before deduplication
There are 0 RHSs after deduplication
got 3 candidates from LHS

-------------------------------------------------
%0:i32 = var
%1:i32 = var
%2:i1 = sle %0, %1
infer %2


--------------------------------
guess 0

%0:i1 = var ; reservedconst_1

Cost = 0
first query is SAT, returning the model:
reservedconst_1: -1
0 th attempt: second query is SAT-- constant doesn't work
first query is SAT, returning the model:
reservedconst_1: 0
1 th attempt: second query is SAT-- constant doesn't work
first query is UNSAT-- no more guesses
Dataflow Pruned 0/0
There are 1 Guesses
There are 0 RHSs before deduplication
There are 0 RHSs after deduplication
got 4 candidates from LHS

-------------------------------------------------
%0:i32 = var
%1:i32 = var
%2:i32 = sdiv 2147483647:i32, %1
%3:i32 = sdiv %0, %2
infer %3


--------------------------------
guess 0

%0:i32 = var ; reservedconst_1

Cost = 0
first query is SAT, returning the model:
reservedconst_1: 0
0 th attempt: second query is SAT-- constant doesn't work
first query is SAT, returning the model:
reservedconst_1: 16777216
1 th attempt: second query is SAT-- constant doesn't work
first query is UNSAT-- no more guesses

--------------------------------
guess 1

%0:i32 = var

Cost = 0
second query is SAT-- constant doesn't work

--------------------------------
guess 2

%0:i32 = var

Cost = 0
second query is SAT-- constant doesn't work

--------------------------------
guess 3

%0:i32 = var
%1:i32 = sdiv 2147483647:i32, %0

Cost = 5
second query is SAT-- constant doesn't work
Dataflow Pruned 0/0
There are 4 Guesses
There are 0 RHSs before deduplication
There are 0 RHSs after deduplication
#########################################################
; exiting Souper's runOnFunction() for irand()

; entering Souper's runOnFunction() for show()

; ModuleID = './Maze_generation.c.bc'
source_filename = "./Maze_generation.c"
target datalayout = "e-m:e-p:32:32-i64:64-n32:64-S128"
target triple = "wasm32-unknown-wasi"

@glyph = hidden global [30 x i32] [i32 12288, i32 9474, i32 9474, i32 9474, i32 9472, i32 9496, i32 9488, i32 9508, i32 9472, i32 9492, i32 9484, i32 9500, i32 9472, i32 9524, i32 9516, i32 9532, i32 12288, i32 9478, i32 9478, i32 9478, i32 9476, i32 9583, i32 9582, i32 32, i32 9476, i32 9584, i32 9581, i32 32, i32 9476, i32 0], align 16
@h = hidden global i32 0, align 4
@w = hidden global i32 0, align 4
@cell = hidden global i8** null, align 4
@.str = private unnamed_addr constant [6 x i8] c"\1B[31m\00", align 1
@.str.1 = private unnamed_addr constant [4 x i8] c"%lc\00", align 1
@.str.2 = private unnamed_addr constant [4 x i8] c"\1B[m\00", align 1
@__const.walk.d = private unnamed_addr constant [4 x i32] [i32 0, i32 1, i32 2, i32 3], align 16
@avail = hidden global i32 0, align 4
@dirs = internal global [4 x [2 x i32]] [[2 x i32] [i32 -2, i32 0], [2 x i32] [i32 0, i32 2], [2 x i32] [i32 2, i32 0], [2 x i32] [i32 0, i32 -2]], align 16
@.str.3 = private unnamed_addr constant [1 x i8] zeroinitializer, align 1

; Function Attrs: noinline nounwind optnone
define hidden i32 @irand(i32 %n) #0 {
entry:
  %n.addr = alloca i32, align 4
  %r = alloca i32, align 4
  %rmax = alloca i32, align 4
  store i32 %n, i32* %n.addr, align 4
  %0 = load i32, i32* %n.addr, align 4
  %1 = load i32, i32* %n.addr, align 4
  %div = sdiv i32 2147483647, %1
  %mul = mul nsw i32 %0, %div
  store i32 %mul, i32* %rmax, align 4
  br label %while.cond

while.cond:                                       ; preds = %while.body, %entry
  %call = call i32 @rand()
  store i32 %call, i32* %r, align 4
  %2 = load i32, i32* %rmax, align 4
  %cmp = icmp sge i32 %call, %2
  br i1 %cmp, label %while.body, label %while.end

while.body:                                       ; preds = %while.cond
  br label %while.cond

while.end:                                        ; preds = %while.cond
  %3 = load i32, i32* %r, align 4
  %4 = load i32, i32* %n.addr, align 4
  %div1 = sdiv i32 2147483647, %4
  %div2 = sdiv i32 %3, %div1
  ret i32 %div2
}

declare i32 @rand() #1

; Function Attrs: noinline nounwind optnone
define hidden void @show() #0 {
entry:
  %i = alloca i32, align 4
  %j = alloca i32, align 4
  %c = alloca i32, align 4
  store i32 0, i32* %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc16, %entry
  %0 = load i32, i32* %i, align 4
  %1 = load i32, i32* @h, align 4
  %mul = mul nsw i32 2, %1
  %cmp = icmp sle i32 %0, %mul
  br i1 %cmp, label %for.body, label %for.end18

for.body:                                         ; preds = %for.cond
  store i32 0, i32* %j, align 4
  br label %for.cond1

for.cond1:                                        ; preds = %for.inc, %for.body
  %2 = load i32, i32* %j, align 4
  %3 = load i32, i32* @w, align 4
  %mul2 = mul nsw i32 2, %3
  %cmp3 = icmp sle i32 %2, %mul2
  br i1 %cmp3, label %for.body4, label %for.end

for.body4:                                        ; preds = %for.cond1
  %4 = load i8**, i8*** @cell, align 4
  %5 = load i32, i32* %i, align 4
  %arrayidx = getelementptr inbounds i8*, i8** %4, i32 %5
  %6 = load i8*, i8** %arrayidx, align 4
  %7 = load i32, i32* %j, align 4
  %arrayidx5 = getelementptr inbounds i8, i8* %6, i32 %7
  %8 = load i8, i8* %arrayidx5, align 1
  %conv = zext i8 %8 to i32
  store i32 %conv, i32* %c, align 4
  %9 = load i32, i32* %c, align 4
  %cmp6 = icmp sgt i32 %9, 16
  br i1 %cmp6, label %if.then, label %if.end

if.then:                                          ; preds = %for.body4
  %call = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([6 x i8], [6 x i8]* @.str, i32 0, i32 0))
  br label %if.end

if.end:                                           ; preds = %if.then, %for.body4
  %10 = load i32, i32* %c, align 4
  %arrayidx8 = getelementptr inbounds [30 x i32], [30 x i32]* @glyph, i32 0, i32 %10
  %11 = load i32, i32* %arrayidx8, align 4
  %call9 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([4 x i8], [4 x i8]* @.str.1, i32 0, i32 0), i32 %11)
  %12 = load i32, i32* %c, align 4
  %cmp10 = icmp sgt i32 %12, 16
  br i1 %cmp10, label %if.then12, label %if.end14

if.then12:                                        ; preds = %if.end
  %call13 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([4 x i8], [4 x i8]* @.str.2, i32 0, i32 0))
  br label %if.end14

if.end14:                                         ; preds = %if.then12, %if.end
  br label %for.inc

for.inc:                                          ; preds = %if.end14
  %13 = load i32, i32* %j, align 4
  %inc = add nsw i32 %13, 1
  store i32 %inc, i32* %j, align 4
  br label %for.cond1

for.end:                                          ; preds = %for.cond1
  %call15 = call i32 @putchar(i32 10)
  br label %for.inc16

for.inc16:                                        ; preds = %for.end
  %14 = load i32, i32* %i, align 4
  %inc17 = add nsw i32 %14, 1
  store i32 %inc17, i32* %i, align 4
  br label %for.cond

for.end18:                                        ; preds = %for.cond
  ret void
}

declare i32 @printf(i8* %0, ...) #1

declare i32 @putchar(i32 %0) #1

; Function Attrs: noinline nounwind optnone
define hidden void @walk(i32 %x, i32 %y) #0 {
entry:
  %x.addr = alloca i32, align 4
  %y.addr = alloca i32, align 4
  %i = alloca i32, align 4
  %t = alloca i32, align 4
  %x1 = alloca i32, align 4
  %y1 = alloca i32, align 4
  %d = alloca [4 x i32], align 16
  store i32 %x, i32* %x.addr, align 4
  store i32 %y, i32* %y.addr, align 4
  %0 = bitcast [4 x i32]* %d to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 16 %0, i8* align 16 bitcast ([4 x i32]* @__const.walk.d to i8*), i32 16, i1 false)
  %1 = load i8**, i8*** @cell, align 4
  %2 = load i32, i32* %y.addr, align 4
  %arrayidx = getelementptr inbounds i8*, i8** %1, i32 %2
  %3 = load i8*, i8** %arrayidx, align 4
  %4 = load i32, i32* %x.addr, align 4
  %arrayidx1 = getelementptr inbounds i8, i8* %3, i32 %4
  %5 = load i8, i8* %arrayidx1, align 1
  %conv = zext i8 %5 to i32
  %or = or i32 %conv, 16
  %conv2 = trunc i32 %or to i8
  store i8 %conv2, i8* %arrayidx1, align 1
  %6 = load i32, i32* @avail, align 4
  %dec = add nsw i32 %6, -1
  store i32 %dec, i32* @avail, align 4
  store i32 3, i32* %x1, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %7 = load i32, i32* %x1, align 4
  %tobool = icmp ne i32 %7, 0
  br i1 %tobool, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %8 = load i32, i32* %x1, align 4
  %9 = load i32, i32* %x1, align 4
  %add = add nsw i32 %9, 1
  %call = call i32 @irand(i32 %add)
  store i32 %call, i32* %y1, align 4
  %cmp = icmp ne i32 %8, %call
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %for.body
  %10 = load i32, i32* %x1, align 4
  %arrayidx4 = getelementptr inbounds [4 x i32], [4 x i32]* %d, i32 0, i32 %10
  %11 = load i32, i32* %arrayidx4, align 4
  store i32 %11, i32* %i, align 4
  %12 = load i32, i32* %y1, align 4
  %arrayidx5 = getelementptr inbounds [4 x i32], [4 x i32]* %d, i32 0, i32 %12
  %13 = load i32, i32* %arrayidx5, align 4
  %14 = load i32, i32* %x1, align 4
  %arrayidx6 = getelementptr inbounds [4 x i32], [4 x i32]* %d, i32 0, i32 %14
  store i32 %13, i32* %arrayidx6, align 4
  %15 = load i32, i32* %i, align 4
  %16 = load i32, i32* %y1, align 4
  %arrayidx7 = getelementptr inbounds [4 x i32], [4 x i32]* %d, i32 0, i32 %16
  store i32 %15, i32* %arrayidx7, align 4
  br label %if.end

if.end:                                           ; preds = %if.then, %for.body
  br label %for.inc

for.inc:                                          ; preds = %if.end
  %17 = load i32, i32* %x1, align 4
  %dec8 = add nsw i32 %17, -1
  store i32 %dec8, i32* %x1, align 4
  br label %for.cond

for.end:                                          ; preds = %for.cond
  store i32 0, i32* %i, align 4
  br label %for.cond9

for.cond9:                                        ; preds = %for.inc72, %for.end
  %18 = load i32, i32* @avail, align 4
  %tobool10 = icmp ne i32 %18, 0
  br i1 %tobool10, label %land.rhs, label %land.end

land.rhs:                                         ; preds = %for.cond9
  %19 = load i32, i32* %i, align 4
  %cmp11 = icmp slt i32 %19, 4
  br label %land.end

land.end:                                         ; preds = %land.rhs, %for.cond9
  %20 = phi i1 [ false, %for.cond9 ], [ %cmp11, %land.rhs ]
  br i1 %20, label %for.body13, label %for.end73

for.body13:                                       ; preds = %land.end
  %21 = load i32, i32* %x.addr, align 4
  %22 = load i32, i32* %i, align 4
  %arrayidx14 = getelementptr inbounds [4 x i32], [4 x i32]* %d, i32 0, i32 %22
  %23 = load i32, i32* %arrayidx14, align 4
  %arrayidx15 = getelementptr inbounds [4 x [2 x i32]], [4 x [2 x i32]]* @dirs, i32 0, i32 %23
  %arrayidx16 = getelementptr inbounds [2 x i32], [2 x i32]* %arrayidx15, i32 0, i32 0
  %24 = load i32, i32* %arrayidx16, align 8
  %add17 = add nsw i32 %21, %24
  store i32 %add17, i32* %x1, align 4
  %25 = load i32, i32* %y.addr, align 4
  %26 = load i32, i32* %i, align 4
  %arrayidx18 = getelementptr inbounds [4 x i32], [4 x i32]* %d, i32 0, i32 %26
  %27 = load i32, i32* %arrayidx18, align 4
  %arrayidx19 = getelementptr inbounds [4 x [2 x i32]], [4 x [2 x i32]]* @dirs, i32 0, i32 %27
  %arrayidx20 = getelementptr inbounds [2 x i32], [2 x i32]* %arrayidx19, i32 0, i32 1
  %28 = load i32, i32* %arrayidx20, align 4
  %add21 = add nsw i32 %25, %28
  store i32 %add21, i32* %y1, align 4
  %29 = load i8**, i8*** @cell, align 4
  %30 = load i32, i32* %y1, align 4
  %arrayidx22 = getelementptr inbounds i8*, i8** %29, i32 %30
  %31 = load i8*, i8** %arrayidx22, align 4
  %32 = load i32, i32* %x1, align 4
  %arrayidx23 = getelementptr inbounds i8, i8* %31, i32 %32
  %33 = load i8, i8* %arrayidx23, align 1
  %conv24 = zext i8 %33 to i32
  %and = and i32 %conv24, 16
  %tobool25 = icmp ne i32 %and, 0
  br i1 %tobool25, label %if.then26, label %if.end27

if.then26:                                        ; preds = %for.body13
  br label %for.inc72

if.end27:                                         ; preds = %for.body13
  %34 = load i32, i32* %x1, align 4
  %35 = load i32, i32* %x.addr, align 4
  %cmp28 = icmp eq i32 %34, %35
  br i1 %cmp28, label %if.then30, label %if.else

if.then30:                                        ; preds = %if.end27
  %36 = load i32, i32* %y.addr, align 4
  %37 = load i32, i32* %y1, align 4
  %add31 = add nsw i32 %36, %37
  %div = sdiv i32 %add31, 2
  store i32 %div, i32* %t, align 4
  %38 = load i8**, i8*** @cell, align 4
  %39 = load i32, i32* %t, align 4
  %arrayidx32 = getelementptr inbounds i8*, i8** %38, i32 %39
  %40 = load i8*, i8** %arrayidx32, align 4
  %41 = load i32, i32* %x.addr, align 4
  %add33 = add nsw i32 %41, 1
  %arrayidx34 = getelementptr inbounds i8, i8* %40, i32 %add33
  %42 = load i8, i8* %arrayidx34, align 1
  %conv35 = zext i8 %42 to i32
  %and36 = and i32 %conv35, -5
  %conv37 = trunc i32 %and36 to i8
  store i8 %conv37, i8* %arrayidx34, align 1
  %43 = load i8**, i8*** @cell, align 4
  %44 = load i32, i32* %t, align 4
  %arrayidx38 = getelementptr inbounds i8*, i8** %43, i32 %44
  %45 = load i8*, i8** %arrayidx38, align 4
  %46 = load i32, i32* %x.addr, align 4
  %arrayidx39 = getelementptr inbounds i8, i8* %45, i32 %46
  %47 = load i8, i8* %arrayidx39, align 1
  %conv40 = zext i8 %47 to i32
  %and41 = and i32 %conv40, -13
  %conv42 = trunc i32 %and41 to i8
  store i8 %conv42, i8* %arrayidx39, align 1
  %48 = load i8**, i8*** @cell, align 4
  %49 = load i32, i32* %t, align 4
  %arrayidx43 = getelementptr inbounds i8*, i8** %48, i32 %49
  %50 = load i8*, i8** %arrayidx43, align 4
  %51 = load i32, i32* %x.addr, align 4
  %sub = sub nsw i32 %51, 1
  %arrayidx44 = getelementptr inbounds i8, i8* %50, i32 %sub
  %52 = load i8, i8* %arrayidx44, align 1
  %conv45 = zext i8 %52 to i32
  %and46 = and i32 %conv45, -9
  %conv47 = trunc i32 %and46 to i8
  store i8 %conv47, i8* %arrayidx44, align 1
  br label %if.end71

if.else:                                          ; preds = %if.end27
  %53 = load i32, i32* %y1, align 4
  %54 = load i32, i32* %y.addr, align 4
  %cmp48 = icmp eq i32 %53, %54
  br i1 %cmp48, label %if.then50, label %if.end70

if.then50:                                        ; preds = %if.else
  %55 = load i32, i32* %x.addr, align 4
  %56 = load i32, i32* %x1, align 4
  %add51 = add nsw i32 %55, %56
  %div52 = sdiv i32 %add51, 2
  store i32 %div52, i32* %t, align 4
  %57 = load i8**, i8*** @cell, align 4
  %58 = load i32, i32* %y.addr, align 4
  %sub53 = sub nsw i32 %58, 1
  %arrayidx54 = getelementptr inbounds i8*, i8** %57, i32 %sub53
  %59 = load i8*, i8** %arrayidx54, align 4
  %60 = load i32, i32* %t, align 4
  %arrayidx55 = getelementptr inbounds i8, i8* %59, i32 %60
  %61 = load i8, i8* %arrayidx55, align 1
  %conv56 = zext i8 %61 to i32
  %and57 = and i32 %conv56, -3
  %conv58 = trunc i32 %and57 to i8
  store i8 %conv58, i8* %arrayidx55, align 1
  %62 = load i8**, i8*** @cell, align 4
  %63 = load i32, i32* %y.addr, align 4
  %arrayidx59 = getelementptr inbounds i8*, i8** %62, i32 %63
  %64 = load i8*, i8** %arrayidx59, align 4
  %65 = load i32, i32* %t, align 4
  %arrayidx60 = getelementptr inbounds i8, i8* %64, i32 %65
  %66 = load i8, i8* %arrayidx60, align 1
  %conv61 = zext i8 %66 to i32
  %and62 = and i32 %conv61, -4
  %conv63 = trunc i32 %and62 to i8
  store i8 %conv63, i8* %arrayidx60, align 1
  %67 = load i8**, i8*** @cell, align 4
  %68 = load i32, i32* %y.addr, align 4
  %add64 = add nsw i32 %68, 1
  %arrayidx65 = getelementptr inbounds i8*, i8** %67, i32 %add64
  %69 = load i8*, i8** %arrayidx65, align 4
  %70 = load i32, i32* %t, align 4
  %arrayidx66 = getelementptr inbounds i8, i8* %69, i32 %70
  %71 = load i8, i8* %arrayidx66, align 1
  %conv67 = zext i8 %71 to i32
  %and68 = and i32 %conv67, -2
  %conv69 = trunc i32 %and68 to i8
  store i8 %conv69, i8* %arrayidx66, align 1
  br label %if.end70

if.end70:                                         ; preds = %if.then50, %if.else
  br label %if.end71

if.end71:                                         ; preds = %if.end70, %if.then30
  %72 = load i32, i32* %x1, align 4
  %73 = load i32, i32* %y1, align 4
  call void @walk(i32 %72, i32 %73)
  br label %for.inc72

for.inc72:                                        ; preds = %if.end71, %if.then26
  %74 = load i32, i32* %i, align 4
  %inc = add nsw i32 %74, 1
  store i32 %inc, i32* %i, align 4
  br label %for.cond9

for.end73:                                        ; preds = %land.end
  ret void
}

; Function Attrs: argmemonly nounwind willreturn
declare void @llvm.memcpy.p0i8.p0i8.i32(i8* noalias nocapture writeonly %0, i8* noalias nocapture readonly %1, i32 %2, i1 immarg %3) #2

; Function Attrs: noinline nounwind optnone
define hidden i32 @solve(i32 %x, i32 %y, i32 %tox, i32 %toy) #0 {
entry:
  %retval = alloca i32, align 4
  %x.addr = alloca i32, align 4
  %y.addr = alloca i32, align 4
  %tox.addr = alloca i32, align 4
  %toy.addr = alloca i32, align 4
  %i = alloca i32, align 4
  %t = alloca i32, align 4
  %x1 = alloca i32, align 4
  %y1 = alloca i32, align 4
  store i32 %x, i32* %x.addr, align 4
  store i32 %y, i32* %y.addr, align 4
  store i32 %tox, i32* %tox.addr, align 4
  store i32 %toy, i32* %toy.addr, align 4
  %0 = load i8**, i8*** @cell, align 4
  %1 = load i32, i32* %y.addr, align 4
  %arrayidx = getelementptr inbounds i8*, i8** %0, i32 %1
  %2 = load i8*, i8** %arrayidx, align 4
  %3 = load i32, i32* %x.addr, align 4
  %arrayidx1 = getelementptr inbounds i8, i8* %2, i32 %3
  %4 = load i8, i8* %arrayidx1, align 1
  %conv = zext i8 %4 to i32
  %or = or i32 %conv, 16
  %conv2 = trunc i32 %or to i8
  store i8 %conv2, i8* %arrayidx1, align 1
  %5 = load i32, i32* %x.addr, align 4
  %6 = load i32, i32* %tox.addr, align 4
  %cmp = icmp eq i32 %5, %6
  br i1 %cmp, label %land.lhs.true, label %if.end

land.lhs.true:                                    ; preds = %entry
  %7 = load i32, i32* %y.addr, align 4
  %8 = load i32, i32* %toy.addr, align 4
  %cmp4 = icmp eq i32 %7, %8
  br i1 %cmp4, label %if.then, label %if.end

if.then:                                          ; preds = %land.lhs.true
  store i32 1, i32* %retval, align 4
  br label %return

if.end:                                           ; preds = %land.lhs.true, %entry
  store i32 0, i32* %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.end
  %9 = load i32, i32* %i, align 4
  %cmp6 = icmp sle i32 %9, 3
  br i1 %cmp6, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %10 = load i32, i32* %x.addr, align 4
  %11 = load i32, i32* %i, align 4
  %arrayidx8 = getelementptr inbounds [4 x [2 x i32]], [4 x [2 x i32]]* @dirs, i32 0, i32 %11
  %arrayidx9 = getelementptr inbounds [2 x i32], [2 x i32]* %arrayidx8, i32 0, i32 0
  %12 = load i32, i32* %arrayidx9, align 8
  %add = add nsw i32 %10, %12
  store i32 %add, i32* %x1, align 4
  %13 = load i32, i32* %y.addr, align 4
  %14 = load i32, i32* %i, align 4
  %arrayidx10 = getelementptr inbounds [4 x [2 x i32]], [4 x [2 x i32]]* @dirs, i32 0, i32 %14
  %arrayidx11 = getelementptr inbounds [2 x i32], [2 x i32]* %arrayidx10, i32 0, i32 1
  %15 = load i32, i32* %arrayidx11, align 4
  %add12 = add nsw i32 %13, %15
  store i32 %add12, i32* %y1, align 4
  %16 = load i8**, i8*** @cell, align 4
  %17 = load i32, i32* %y1, align 4
  %arrayidx13 = getelementptr inbounds i8*, i8** %16, i32 %17
  %18 = load i8*, i8** %arrayidx13, align 4
  %19 = load i32, i32* %x1, align 4
  %arrayidx14 = getelementptr inbounds i8, i8* %18, i32 %19
  %20 = load i8, i8* %arrayidx14, align 1
  %tobool = icmp ne i8 %20, 0
  br i1 %tobool, label %if.then15, label %if.end16

if.then15:                                        ; preds = %for.body
  br label %for.inc

if.end16:                                         ; preds = %for.body
  %21 = load i32, i32* %x1, align 4
  %22 = load i32, i32* %x.addr, align 4
  %cmp17 = icmp eq i32 %21, %22
  br i1 %cmp17, label %if.then19, label %if.else

if.then19:                                        ; preds = %if.end16
  %23 = load i32, i32* %y.addr, align 4
  %24 = load i32, i32* %y1, align 4
  %add20 = add nsw i32 %23, %24
  %div = sdiv i32 %add20, 2
  store i32 %div, i32* %t, align 4
  %25 = load i8**, i8*** @cell, align 4
  %26 = load i32, i32* %t, align 4
  %arrayidx21 = getelementptr inbounds i8*, i8** %25, i32 %26
  %27 = load i8*, i8** %arrayidx21, align 4
  %28 = load i32, i32* %x.addr, align 4
  %arrayidx22 = getelementptr inbounds i8, i8* %27, i32 %28
  %29 = load i8, i8* %arrayidx22, align 1
  %conv23 = zext i8 %29 to i32
  %tobool24 = icmp ne i32 %conv23, 0
  br i1 %tobool24, label %if.then26, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %if.then19
  %30 = load i32, i32* %x1, align 4
  %31 = load i32, i32* %y1, align 4
  %32 = load i32, i32* %tox.addr, align 4
  %33 = load i32, i32* %toy.addr, align 4
  %call = call i32 @solve(i32 %30, i32 %31, i32 %32, i32 %33)
  %tobool25 = icmp ne i32 %call, 0
  br i1 %tobool25, label %if.end27, label %if.then26

if.then26:                                        ; preds = %lor.lhs.false, %if.then19
  br label %for.inc

if.end27:                                         ; preds = %lor.lhs.false
  %34 = load i8**, i8*** @cell, align 4
  %35 = load i32, i32* %t, align 4
  %sub = sub nsw i32 %35, 1
  %arrayidx28 = getelementptr inbounds i8*, i8** %34, i32 %sub
  %36 = load i8*, i8** %arrayidx28, align 4
  %37 = load i32, i32* %x.addr, align 4
  %arrayidx29 = getelementptr inbounds i8, i8* %36, i32 %37
  %38 = load i8, i8* %arrayidx29, align 1
  %conv30 = zext i8 %38 to i32
  %or31 = or i32 %conv30, 2
  %conv32 = trunc i32 %or31 to i8
  store i8 %conv32, i8* %arrayidx29, align 1
  %39 = load i8**, i8*** @cell, align 4
  %40 = load i32, i32* %t, align 4
  %arrayidx33 = getelementptr inbounds i8*, i8** %39, i32 %40
  %41 = load i8*, i8** %arrayidx33, align 4
  %42 = load i32, i32* %x.addr, align 4
  %arrayidx34 = getelementptr inbounds i8, i8* %41, i32 %42
  %43 = load i8, i8* %arrayidx34, align 1
  %conv35 = zext i8 %43 to i32
  %or36 = or i32 %conv35, 19
  %conv37 = trunc i32 %or36 to i8
  store i8 %conv37, i8* %arrayidx34, align 1
  %44 = load i8**, i8*** @cell, align 4
  %45 = load i32, i32* %t, align 4
  %add38 = add nsw i32 %45, 1
  %arrayidx39 = getelementptr inbounds i8*, i8** %44, i32 %add38
  %46 = load i8*, i8** %arrayidx39, align 4
  %47 = load i32, i32* %x.addr, align 4
  %arrayidx40 = getelementptr inbounds i8, i8* %46, i32 %47
  %48 = load i8, i8* %arrayidx40, align 1
  %conv41 = zext i8 %48 to i32
  %or42 = or i32 %conv41, 1
  %conv43 = trunc i32 %or42 to i8
  store i8 %conv43, i8* %arrayidx40, align 1
  br label %if.end76

if.else:                                          ; preds = %if.end16
  %49 = load i32, i32* %y1, align 4
  %50 = load i32, i32* %y.addr, align 4
  %cmp44 = icmp eq i32 %49, %50
  br i1 %cmp44, label %if.then46, label %if.end75

if.then46:                                        ; preds = %if.else
  %51 = load i32, i32* %x.addr, align 4
  %52 = load i32, i32* %x1, align 4
  %add47 = add nsw i32 %51, %52
  %div48 = sdiv i32 %add47, 2
  store i32 %div48, i32* %t, align 4
  %53 = load i8**, i8*** @cell, align 4
  %54 = load i32, i32* %y.addr, align 4
  %arrayidx49 = getelementptr inbounds i8*, i8** %53, i32 %54
  %55 = load i8*, i8** %arrayidx49, align 4
  %56 = load i32, i32* %t, align 4
  %arrayidx50 = getelementptr inbounds i8, i8* %55, i32 %56
  %57 = load i8, i8* %arrayidx50, align 1
  %conv51 = zext i8 %57 to i32
  %tobool52 = icmp ne i32 %conv51, 0
  br i1 %tobool52, label %if.then56, label %lor.lhs.false53

lor.lhs.false53:                                  ; preds = %if.then46
  %58 = load i32, i32* %x1, align 4
  %59 = load i32, i32* %y1, align 4
  %60 = load i32, i32* %tox.addr, align 4
  %61 = load i32, i32* %toy.addr, align 4
  %call54 = call i32 @solve(i32 %58, i32 %59, i32 %60, i32 %61)
  %tobool55 = icmp ne i32 %call54, 0
  br i1 %tobool55, label %if.end57, label %if.then56

if.then56:                                        ; preds = %lor.lhs.false53, %if.then46
  br label %for.inc

if.end57:                                         ; preds = %lor.lhs.false53
  %62 = load i8**, i8*** @cell, align 4
  %63 = load i32, i32* %y.addr, align 4
  %arrayidx58 = getelementptr inbounds i8*, i8** %62, i32 %63
  %64 = load i8*, i8** %arrayidx58, align 4
  %65 = load i32, i32* %t, align 4
  %sub59 = sub nsw i32 %65, 1
  %arrayidx60 = getelementptr inbounds i8, i8* %64, i32 %sub59
  %66 = load i8, i8* %arrayidx60, align 1
  %conv61 = zext i8 %66 to i32
  %or62 = or i32 %conv61, 8
  %conv63 = trunc i32 %or62 to i8
  store i8 %conv63, i8* %arrayidx60, align 1
  %67 = load i8**, i8*** @cell, align 4
  %68 = load i32, i32* %y.addr, align 4
  %arrayidx64 = getelementptr inbounds i8*, i8** %67, i32 %68
  %69 = load i8*, i8** %arrayidx64, align 4
  %70 = load i32, i32* %t, align 4
  %arrayidx65 = getelementptr inbounds i8, i8* %69, i32 %70
  %71 = load i8, i8* %arrayidx65, align 1
  %conv66 = zext i8 %71 to i32
  %or67 = or i32 %conv66, 28
  %conv68 = trunc i32 %or67 to i8
  store i8 %conv68, i8* %arrayidx65, align 1
  %72 = load i8**, i8*** @cell, align 4
  %73 = load i32, i32* %y.addr, align 4
  %arrayidx69 = getelementptr inbounds i8*, i8** %72, i32 %73
  %74 = load i8*, i8** %arrayidx69, align 4
  %75 = load i32, i32* %t, align 4
  %add70 = add nsw i32 %75, 1
  %arrayidx71 = getelementptr inbounds i8, i8* %74, i32 %add70
  %76 = load i8, i8* %arrayidx71, align 1
  %conv72 = zext i8 %76 to i32
  %or73 = or i32 %conv72, 4
  %conv74 = trunc i32 %or73 to i8
  store i8 %conv74, i8* %arrayidx71, align 1
  br label %if.end75

if.end75:                                         ; preds = %if.end57, %if.else
  br label %if.end76

if.end76:                                         ; preds = %if.end75, %if.end27
  store i32 1, i32* %retval, align 4
  br label %return

for.inc:                                          ; preds = %if.then56, %if.then26, %if.then15
  %77 = load i32, i32* %i, align 4
  %inc = add nsw i32 %77, 1
  store i32 %inc, i32* %i, align 4
  br label %for.cond

for.end:                                          ; preds = %for.cond
  %78 = load i8**, i8*** @cell, align 4
  %79 = load i32, i32* %y.addr, align 4
  %arrayidx77 = getelementptr inbounds i8*, i8** %78, i32 %79
  %80 = load i8*, i8** %arrayidx77, align 4
  %81 = load i32, i32* %x.addr, align 4
  %arrayidx78 = getelementptr inbounds i8, i8* %80, i32 %81
  %82 = load i8, i8* %arrayidx78, align 1
  %conv79 = zext i8 %82 to i32
  %and = and i32 %conv79, -17
  %conv80 = trunc i32 %and to i8
  store i8 %conv80, i8* %arrayidx78, align 1
  store i32 0, i32* %retval, align 4
  br label %return

return:                                           ; preds = %for.end, %if.end76, %if.then
  %83 = load i32, i32* %retval, align 4
  ret i32 %83
}

; Function Attrs: noinline nounwind optnone
define hidden void @make_maze() #0 {
entry:
  %i = alloca i32, align 4
  %j = alloca i32, align 4
  %h2 = alloca i32, align 4
  %w2 = alloca i32, align 4
  %p = alloca i8**, align 4
  %0 = load i32, i32* @h, align 4
  %mul = mul nsw i32 2, %0
  %add = add nsw i32 %mul, 2
  store i32 %add, i32* %h2, align 4
  %1 = load i32, i32* @w, align 4
  %mul1 = mul nsw i32 2, %1
  %add2 = add nsw i32 %mul1, 2
  store i32 %add2, i32* %w2, align 4
  %2 = load i32, i32* %h2, align 4
  %add3 = add nsw i32 %2, 2
  %mul4 = mul i32 4, %add3
  %3 = load i32, i32* %w2, align 4
  %4 = load i32, i32* %h2, align 4
  %mul5 = mul nsw i32 %3, %4
  %add6 = add i32 %mul4, %mul5
  %add7 = add i32 %add6, 1
  %call = call noalias i8* @calloc(i32 %add7, i32 1)
  %5 = bitcast i8* %call to i8**
  store i8** %5, i8*** %p, align 4
  %6 = load i8**, i8*** %p, align 4
  %7 = load i32, i32* %h2, align 4
  %add.ptr = getelementptr inbounds i8*, i8** %6, i32 %7
  %add.ptr8 = getelementptr inbounds i8*, i8** %add.ptr, i32 2
  %8 = bitcast i8** %add.ptr8 to i8*
  %add.ptr9 = getelementptr inbounds i8, i8* %8, i32 1
  %9 = load i8**, i8*** %p, align 4
  %arrayidx = getelementptr inbounds i8*, i8** %9, i32 1
  store i8* %add.ptr9, i8** %arrayidx, align 4
  store i32 2, i32* %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %10 = load i32, i32* %i, align 4
  %11 = load i32, i32* %h2, align 4
  %cmp = icmp sle i32 %10, %11
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %12 = load i8**, i8*** %p, align 4
  %13 = load i32, i32* %i, align 4
  %sub = sub nsw i32 %13, 1
  %arrayidx10 = getelementptr inbounds i8*, i8** %12, i32 %sub
  %14 = load i8*, i8** %arrayidx10, align 4
  %15 = load i32, i32* %w2, align 4
  %add.ptr11 = getelementptr inbounds i8, i8* %14, i32 %15
  %16 = load i8**, i8*** %p, align 4
  %17 = load i32, i32* %i, align 4
  %arrayidx12 = getelementptr inbounds i8*, i8** %16, i32 %17
  store i8* %add.ptr11, i8** %arrayidx12, align 4
  br label %for.inc

for.inc:                                          ; preds = %for.body
  %18 = load i32, i32* %i, align 4
  %inc = add nsw i32 %18, 1
  store i32 %inc, i32* %i, align 4
  br label %for.cond

for.end:                                          ; preds = %for.cond
  %19 = load i8**, i8*** %p, align 4
  %20 = load i32, i32* %h2, align 4
  %arrayidx13 = getelementptr inbounds i8*, i8** %19, i32 %20
  %21 = load i8*, i8** %arrayidx13, align 4
  %22 = load i8**, i8*** %p, align 4
  %arrayidx14 = getelementptr inbounds i8*, i8** %22, i32 0
  store i8* %21, i8** %arrayidx14, align 4
  %23 = load i8**, i8*** %p, align 4
  %arrayidx15 = getelementptr inbounds i8*, i8** %23, i32 1
  store i8** %arrayidx15, i8*** @cell, align 4
  store i32 -1, i32* %i, align 4
  br label %for.cond16

for.cond16:                                       ; preds = %for.inc26, %for.end
  %24 = load i32, i32* %i, align 4
  %25 = load i32, i32* @h, align 4
  %mul17 = mul nsw i32 2, %25
  %add18 = add nsw i32 %mul17, 1
  %cmp19 = icmp sle i32 %24, %add18
  br i1 %cmp19, label %for.body20, label %for.end28

for.body20:                                       ; preds = %for.cond16
  %26 = load i8**, i8*** @cell, align 4
  %27 = load i32, i32* %i, align 4
  %arrayidx21 = getelementptr inbounds i8*, i8** %26, i32 %27
  %28 = load i8*, i8** %arrayidx21, align 4
  %29 = load i32, i32* %w2, align 4
  %sub22 = sub nsw i32 %29, 1
  %arrayidx23 = getelementptr inbounds i8, i8* %28, i32 %sub22
  store i8 16, i8* %arrayidx23, align 1
  %30 = load i8**, i8*** @cell, align 4
  %31 = load i32, i32* %i, align 4
  %arrayidx24 = getelementptr inbounds i8*, i8** %30, i32 %31
  %32 = load i8*, i8** %arrayidx24, align 4
  %arrayidx25 = getelementptr inbounds i8, i8* %32, i32 -1
  store i8 16, i8* %arrayidx25, align 1
  br label %for.inc26

for.inc26:                                        ; preds = %for.body20
  %33 = load i32, i32* %i, align 4
  %inc27 = add nsw i32 %33, 1
  store i32 %inc27, i32* %i, align 4
  br label %for.cond16

for.end28:                                        ; preds = %for.cond16
  store i32 0, i32* %j, align 4
  br label %for.cond29

for.cond29:                                       ; preds = %for.inc38, %for.end28
  %34 = load i32, i32* %j, align 4
  %35 = load i32, i32* @w, align 4
  %mul30 = mul nsw i32 2, %35
  %cmp31 = icmp sle i32 %34, %mul30
  br i1 %cmp31, label %for.body32, label %for.end40

for.body32:                                       ; preds = %for.cond29
  %36 = load i8**, i8*** @cell, align 4
  %37 = load i32, i32* %h2, align 4
  %sub33 = sub nsw i32 %37, 1
  %arrayidx34 = getelementptr inbounds i8*, i8** %36, i32 %sub33
  %38 = load i8*, i8** %arrayidx34, align 4
  %39 = load i32, i32* %j, align 4
  %arrayidx35 = getelementptr inbounds i8, i8* %38, i32 %39
  store i8 16, i8* %arrayidx35, align 1
  %40 = load i8**, i8*** @cell, align 4
  %arrayidx36 = getelementptr inbounds i8*, i8** %40, i32 -1
  %41 = load i8*, i8** %arrayidx36, align 4
  %42 = load i32, i32* %j, align 4
  %arrayidx37 = getelementptr inbounds i8, i8* %41, i32 %42
  store i8 16, i8* %arrayidx37, align 1
  br label %for.inc38

for.inc38:                                        ; preds = %for.body32
  %43 = load i32, i32* %j, align 4
  %inc39 = add nsw i32 %43, 1
  store i32 %inc39, i32* %j, align 4
  br label %for.cond29

for.end40:                                        ; preds = %for.cond29
  store i32 0, i32* %i, align 4
  br label %for.cond41

for.cond41:                                       ; preds = %for.inc55, %for.end40
  %44 = load i32, i32* %i, align 4
  %45 = load i32, i32* @h, align 4
  %cmp42 = icmp sle i32 %44, %45
  br i1 %cmp42, label %for.body43, label %for.end57

for.body43:                                       ; preds = %for.cond41
  store i32 0, i32* %j, align 4
  br label %for.cond44

for.cond44:                                       ; preds = %for.inc52, %for.body43
  %46 = load i32, i32* %j, align 4
  %47 = load i32, i32* @w, align 4
  %mul45 = mul nsw i32 2, %47
  %cmp46 = icmp sle i32 %46, %mul45
  br i1 %cmp46, label %for.body47, label %for.end54

for.body47:                                       ; preds = %for.cond44
  %48 = load i8**, i8*** @cell, align 4
  %49 = load i32, i32* %i, align 4
  %mul48 = mul nsw i32 2, %49
  %arrayidx49 = getelementptr inbounds i8*, i8** %48, i32 %mul48
  %50 = load i8*, i8** %arrayidx49, align 4
  %51 = load i32, i32* %j, align 4
  %arrayidx50 = getelementptr inbounds i8, i8* %50, i32 %51
  %52 = load i8, i8* %arrayidx50, align 1
  %conv = zext i8 %52 to i32
  %or = or i32 %conv, 12
  %conv51 = trunc i32 %or to i8
  store i8 %conv51, i8* %arrayidx50, align 1
  br label %for.inc52

for.inc52:                                        ; preds = %for.body47
  %53 = load i32, i32* %j, align 4
  %inc53 = add nsw i32 %53, 1
  store i32 %inc53, i32* %j, align 4
  br label %for.cond44

for.end54:                                        ; preds = %for.cond44
  br label %for.inc55

for.inc55:                                        ; preds = %for.end54
  %54 = load i32, i32* %i, align 4
  %inc56 = add nsw i32 %54, 1
  store i32 %inc56, i32* %i, align 4
  br label %for.cond41

for.end57:                                        ; preds = %for.cond41
  store i32 0, i32* %i, align 4
  br label %for.cond58

for.cond58:                                       ; preds = %for.inc76, %for.end57
  %55 = load i32, i32* %i, align 4
  %56 = load i32, i32* @h, align 4
  %mul59 = mul nsw i32 2, %56
  %cmp60 = icmp sle i32 %55, %mul59
  br i1 %cmp60, label %for.body62, label %for.end78

for.body62:                                       ; preds = %for.cond58
  store i32 0, i32* %j, align 4
  br label %for.cond63

for.cond63:                                       ; preds = %for.inc73, %for.body62
  %57 = load i32, i32* %j, align 4
  %58 = load i32, i32* @w, align 4
  %cmp64 = icmp sle i32 %57, %58
  br i1 %cmp64, label %for.body66, label %for.end75

for.body66:                                       ; preds = %for.cond63
  %59 = load i8**, i8*** @cell, align 4
  %60 = load i32, i32* %i, align 4
  %arrayidx67 = getelementptr inbounds i8*, i8** %59, i32 %60
  %61 = load i8*, i8** %arrayidx67, align 4
  %62 = load i32, i32* %j, align 4
  %mul68 = mul nsw i32 2, %62
  %arrayidx69 = getelementptr inbounds i8, i8* %61, i32 %mul68
  %63 = load i8, i8* %arrayidx69, align 1
  %conv70 = zext i8 %63 to i32
  %or71 = or i32 %conv70, 3
  %conv72 = trunc i32 %or71 to i8
  store i8 %conv72, i8* %arrayidx69, align 1
  br label %for.inc73

for.inc73:                                        ; preds = %for.body66
  %64 = load i32, i32* %j, align 4
  %inc74 = add nsw i32 %64, 1
  store i32 %inc74, i32* %j, align 4
  br label %for.cond63

for.end75:                                        ; preds = %for.cond63
  br label %for.inc76

for.inc76:                                        ; preds = %for.end75
  %65 = load i32, i32* %i, align 4
  %inc77 = add nsw i32 %65, 1
  store i32 %inc77, i32* %i, align 4
  br label %for.cond58

for.end78:                                        ; preds = %for.cond58
  store i32 0, i32* %j, align 4
  br label %for.cond79

for.cond79:                                       ; preds = %for.inc94, %for.end78
  %66 = load i32, i32* %j, align 4
  %67 = load i32, i32* @w, align 4
  %mul80 = mul nsw i32 2, %67
  %cmp81 = icmp sle i32 %66, %mul80
  br i1 %cmp81, label %for.body83, label %for.end96

for.body83:                                       ; preds = %for.cond79
  %68 = load i8**, i8*** @cell, align 4
  %arrayidx84 = getelementptr inbounds i8*, i8** %68, i32 0
  %69 = load i8*, i8** %arrayidx84, align 4
  %70 = load i32, i32* %j, align 4
  %arrayidx85 = getelementptr inbounds i8, i8* %69, i32 %70
  %71 = load i8, i8* %arrayidx85, align 1
  %conv86 = zext i8 %71 to i32
  %and = and i32 %conv86, -2
  %conv87 = trunc i32 %and to i8
  store i8 %conv87, i8* %arrayidx85, align 1
  %72 = load i8**, i8*** @cell, align 4
  %73 = load i32, i32* @h, align 4
  %mul88 = mul nsw i32 2, %73
  %arrayidx89 = getelementptr inbounds i8*, i8** %72, i32 %mul88
  %74 = load i8*, i8** %arrayidx89, align 4
  %75 = load i32, i32* %j, align 4
  %arrayidx90 = getelementptr inbounds i8, i8* %74, i32 %75
  %76 = load i8, i8* %arrayidx90, align 1
  %conv91 = zext i8 %76 to i32
  %and92 = and i32 %conv91, -3
  %conv93 = trunc i32 %and92 to i8
  store i8 %conv93, i8* %arrayidx90, align 1
  br label %for.inc94

for.inc94:                                        ; preds = %for.body83
  %77 = load i32, i32* %j, align 4
  %inc95 = add nsw i32 %77, 1
  store i32 %inc95, i32* %j, align 4
  br label %for.cond79

for.end96:                                        ; preds = %for.cond79
  store i32 0, i32* %i, align 4
  br label %for.cond97

for.cond97:                                       ; preds = %for.inc113, %for.end96
  %78 = load i32, i32* %i, align 4
  %79 = load i32, i32* @h, align 4
  %mul98 = mul nsw i32 2, %79
  %cmp99 = icmp sle i32 %78, %mul98
  br i1 %cmp99, label %for.body101, label %for.end115

for.body101:                                      ; preds = %for.cond97
  %80 = load i8**, i8*** @cell, align 4
  %81 = load i32, i32* %i, align 4
  %arrayidx102 = getelementptr inbounds i8*, i8** %80, i32 %81
  %82 = load i8*, i8** %arrayidx102, align 4
  %arrayidx103 = getelementptr inbounds i8, i8* %82, i32 0
  %83 = load i8, i8* %arrayidx103, align 1
  %conv104 = zext i8 %83 to i32
  %and105 = and i32 %conv104, -5
  %conv106 = trunc i32 %and105 to i8
  store i8 %conv106, i8* %arrayidx103, align 1
  %84 = load i8**, i8*** @cell, align 4
  %85 = load i32, i32* %i, align 4
  %arrayidx107 = getelementptr inbounds i8*, i8** %84, i32 %85
  %86 = load i8*, i8** %arrayidx107, align 4
  %87 = load i32, i32* @w, align 4
  %mul108 = mul nsw i32 2, %87
  %arrayidx109 = getelementptr inbounds i8, i8* %86, i32 %mul108
  %88 = load i8, i8* %arrayidx109, align 1
  %conv110 = zext i8 %88 to i32
  %and111 = and i32 %conv110, -9
  %conv112 = trunc i32 %and111 to i8
  store i8 %conv112, i8* %arrayidx109, align 1
  br label %for.inc113

for.inc113:                                       ; preds = %for.body101
  %89 = load i32, i32* %i, align 4
  %inc114 = add nsw i32 %89, 1
  store i32 %inc114, i32* %i, align 4
  br label %for.cond97

for.end115:                                       ; preds = %for.cond97
  %90 = load i32, i32* @w, align 4
  %91 = load i32, i32* @h, align 4
  %mul116 = mul nsw i32 %90, %91
  store i32 %mul116, i32* @avail, align 4
  %call117 = call i32 @irand(i32 2)
  %mul118 = mul nsw i32 %call117, 2
  %add119 = add nsw i32 %mul118, 1
  %92 = load i32, i32* @h, align 4
  %call120 = call i32 @irand(i32 %92)
  %mul121 = mul nsw i32 %call120, 2
  %add122 = add nsw i32 %mul121, 1
  call void @walk(i32 %add119, i32 %add122)
  store i32 0, i32* %i, align 4
  br label %for.cond123

for.cond123:                                      ; preds = %for.inc141, %for.end115
  %93 = load i32, i32* %i, align 4
  %94 = load i32, i32* @h, align 4
  %mul124 = mul nsw i32 2, %94
  %cmp125 = icmp sle i32 %93, %mul124
  br i1 %cmp125, label %for.body127, label %for.end143

for.body127:                                      ; preds = %for.cond123
  store i32 0, i32* %j, align 4
  br label %for.cond128

for.cond128:                                      ; preds = %for.inc138, %for.body127
  %95 = load i32, i32* %j, align 4
  %96 = load i32, i32* @w, align 4
  %mul129 = mul nsw i32 2, %96
  %cmp130 = icmp sle i32 %95, %mul129
  br i1 %cmp130, label %for.body132, label %for.end140

for.body132:                                      ; preds = %for.cond128
  %97 = load i8**, i8*** @cell, align 4
  %98 = load i32, i32* %i, align 4
  %arrayidx133 = getelementptr inbounds i8*, i8** %97, i32 %98
  %99 = load i8*, i8** %arrayidx133, align 4
  %100 = load i32, i32* %j, align 4
  %arrayidx134 = getelementptr inbounds i8, i8* %99, i32 %100
  %101 = load i8, i8* %arrayidx134, align 1
  %conv135 = zext i8 %101 to i32
  %and136 = and i32 %conv135, -17
  %conv137 = trunc i32 %and136 to i8
  store i8 %conv137, i8* %arrayidx134, align 1
  br label %for.inc138

for.inc138:                                       ; preds = %for.body132
  %102 = load i32, i32* %j, align 4
  %inc139 = add nsw i32 %102, 1
  store i32 %inc139, i32* %j, align 4
  br label %for.cond128

for.end140:                                       ; preds = %for.cond128
  br label %for.inc141

for.inc141:                                       ; preds = %for.end140
  %103 = load i32, i32* %i, align 4
  %inc142 = add nsw i32 %103, 1
  store i32 %inc142, i32* %i, align 4
  br label %for.cond123

for.end143:                                       ; preds = %for.cond123
  %104 = load i32, i32* @w, align 4
  %mul144 = mul nsw i32 2, %104
  %sub145 = sub nsw i32 %mul144, 1
  %105 = load i32, i32* @h, align 4
  %mul146 = mul nsw i32 2, %105
  %sub147 = sub nsw i32 %mul146, 1
  %call148 = call i32 @solve(i32 1, i32 1, i32 %sub145, i32 %sub147)
  call void @show()
  ret void
}

declare noalias i8* @calloc(i32 %0, i32 %1) #1

; Function Attrs: noinline nounwind optnone
define hidden i32 @__main_argc_argv(i32 %c, i8** %v) #0 {
entry:
  %retval = alloca i32, align 4
  %c.addr = alloca i32, align 4
  %v.addr = alloca i8**, align 4
  store i32 0, i32* %retval, align 4
  store i32 %c, i32* %c.addr, align 4
  store i8** %v, i8*** %v.addr, align 4
  %call = call i8* @setlocale(i32 6, i8* getelementptr inbounds ([1 x i8], [1 x i8]* @.str.3, i32 0, i32 0))
  %0 = load i32, i32* %c.addr, align 4
  %cmp = icmp slt i32 %0, 2
  br i1 %cmp, label %if.then, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %entry
  %1 = load i8**, i8*** %v.addr, align 4
  %arrayidx = getelementptr inbounds i8*, i8** %1, i32 1
  %2 = load i8*, i8** %arrayidx, align 4
  %call1 = call i32 @atoi(i8* %2)
  store i32 %call1, i32* @w, align 4
  %cmp2 = icmp sle i32 %call1, 0
  br i1 %cmp2, label %if.then, label %if.end

if.then:                                          ; preds = %lor.lhs.false, %entry
  store i32 16, i32* @w, align 4
  br label %if.end

if.end:                                           ; preds = %if.then, %lor.lhs.false
  %3 = load i32, i32* %c.addr, align 4
  %cmp3 = icmp slt i32 %3, 3
  br i1 %cmp3, label %if.then8, label %lor.lhs.false4

lor.lhs.false4:                                   ; preds = %if.end
  %4 = load i8**, i8*** %v.addr, align 4
  %arrayidx5 = getelementptr inbounds i8*, i8** %4, i32 2
  %5 = load i8*, i8** %arrayidx5, align 4
  %call6 = call i32 @atoi(i8* %5)
  store i32 %call6, i32* @h, align 4
  %cmp7 = icmp sle i32 %call6, 0
  br i1 %cmp7, label %if.then8, label %if.end9

if.then8:                                         ; preds = %lor.lhs.false4, %if.end
  store i32 8, i32* @h, align 4
  br label %if.end9

if.end9:                                          ; preds = %if.then8, %lor.lhs.false4
  call void @make_maze()
  ret i32 0
}

declare i8* @setlocale(i32 %0, i8* %1) #1

declare i32 @atoi(i8* %0) #1

attributes #0 = { noinline nounwind optnone "correctly-rounded-divide-sqrt-fp-math"="false" "disable-tail-calls"="false" "frame-pointer"="none" "less-precise-fpmad"="false" "min-legal-vector-width"="0" "no-infs-fp-math"="false" "no-jump-tables"="false" "no-nans-fp-math"="false" "no-signed-zeros-fp-math"="false" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="generic" "unsafe-fp-math"="false" "use-soft-float"="false" }
attributes #1 = { "correctly-rounded-divide-sqrt-fp-math"="false" "disable-tail-calls"="false" "frame-pointer"="none" "less-precise-fpmad"="false" "no-infs-fp-math"="false" "no-nans-fp-math"="false" "no-signed-zeros-fp-math"="false" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="generic" "unsafe-fp-math"="false" "use-soft-float"="false" }
attributes #2 = { argmemonly nounwind willreturn }

!llvm.module.flags = !{!0}
!llvm.ident = !{!1}

!0 = !{i32 1, !"wchar_size", i32 4}
!1 = !{!"clang version 11.0.0 (https://github.com/Jacarte/llvm-project.git 0f6dea67136cc1e0b3d200eb2bb165628970c44b)"}

; extracted candidates

; *****
; For LLVM instruction:
;  %0 = load i32, i32* %i, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %1 = load i32, i32* @h, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %mul = mul nsw i32 2, %1
; Looking for a replacement for:
%0:i32 = var
%1:i32 = mulnsw 2:i32, %0
infer %1

; *****
; For LLVM instruction:
;  %cmp = icmp sle i32 %0, %mul
; Looking for a replacement for:
%0:i32 = var
%1:i32 = var
%2:i32 = mulnsw 2:i32, %1
%3:i1 = sle %0, %2
infer %3

; *****
; For LLVM instruction:
;  %2 = load i32, i32* %j, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %3 = load i32, i32* @w, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %mul2 = mul nsw i32 2, %3
; Looking for a replacement for:
%0:i32 = var
%1:i32 = mulnsw 2:i32, %0
infer %1

; *****
; For LLVM instruction:
;  %cmp3 = icmp sle i32 %2, %mul2
; Looking for a replacement for:
%0:i32 = var
%1:i32 = var
%2:i32 = mulnsw 2:i32, %1
%3:i1 = sle %0, %2
infer %3

; *****
; For LLVM instruction:
;  %5 = load i32, i32* %i, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %7 = load i32, i32* %j, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %8 = load i8, i8* %arrayidx5, align 1
; Looking for a replacement for:
%0:i8 = var
infer %0

; *****
; For LLVM instruction:
;  %conv = zext i8 %8 to i32
; Looking for a replacement for:
%0:i8 = var
%1:i32 = zext %0
infer %1

; *****
; For LLVM instruction:
;  %9 = load i32, i32* %c, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %cmp6 = icmp sgt i32 %9, 16
; Looking for a replacement for:
%0:i32 = var
%1:i1 = slt 16:i32, %0
infer %1

; *****
; For LLVM instruction:
;  %10 = load i32, i32* %c, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %11 = load i32, i32* %arrayidx8, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %12 = load i32, i32* %c, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %cmp10 = icmp sgt i32 %12, 16
; Looking for a replacement for:
%0:i32 = var
%1:i1 = slt 16:i32, %0
infer %1

; *****
; For LLVM instruction:
;  %13 = load i32, i32* %j, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %inc = add nsw i32 %13, 1
; Looking for a replacement for:
%0:i32 = var
%1:i32 = addnsw 1:i32, %0
infer %1

; *****
; For LLVM instruction:
;  %14 = load i32, i32* %i, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %inc17 = add nsw i32 %14, 1
; Looking for a replacement for:
%0:i32 = var
%1:i32 = addnsw 1:i32, %0
infer %1
got 2 candidates from LHS

-------------------------------------------------
%0:i32 = var
%1:i32 = mulnsw 2:i32, %0
infer %1


--------------------------------
guess 0

%0:i32 = var ; reservedconst_1

Cost = 0
first query is SAT, returning the model:
reservedconst_1: 0
0 th attempt: second query is SAT-- constant doesn't work
first query is SAT, returning the model:
reservedconst_1: 1073741824
1 th attempt: second query is SAT-- constant doesn't work
first query is UNSAT-- no more guesses

--------------------------------
guess 1

%0:i32 = var

Cost = 0
second query is SAT-- constant doesn't work
Dataflow Pruned 0/0
There are 2 Guesses
There are 0 RHSs before deduplication
There are 0 RHSs after deduplication
got 4 candidates from LHS

-------------------------------------------------
%0:i32 = var
%1:i32 = var
%2:i32 = mulnsw 2:i32, %1
%3:i1 = sle %0, %2
infer %3


--------------------------------
guess 0

%0:i1 = var ; reservedconst_1

Cost = 0
first query is SAT, returning the model:
reservedconst_1: -1
0 th attempt: second query is SAT-- constant doesn't work
first query is SAT, returning the model:
reservedconst_1: 0
1 th attempt: second query is SAT-- constant doesn't work
first query is UNSAT-- no more guesses
Dataflow Pruned 0/0
There are 1 Guesses
There are 0 RHSs before deduplication
There are 0 RHSs after deduplication
got 1 candidates from LHS

-------------------------------------------------
%0:i8 = var
infer %0


--------------------------------
guess 0

%0:i8 = var ; reservedconst_1

Cost = 0
first query is SAT, returning the model:
reservedconst_1: 0
0 th attempt: second query is SAT-- constant doesn't work
first query is SAT, returning the model:
reservedconst_1: -1
1 th attempt: second query is SAT-- constant doesn't work
first query is UNSAT-- no more guesses
Dataflow Pruned 0/0
There are 1 Guesses
There are 0 RHSs before deduplication
There are 0 RHSs after deduplication
got 2 candidates from LHS

-------------------------------------------------
%0:i8 = var
%1:i32 = zext %0
infer %1


--------------------------------
guess 0

%0:i32 = var ; reservedconst_1

Cost = 0
first query is SAT, returning the model:
reservedconst_1: 0
0 th attempt: second query is SAT-- constant doesn't work
first query is SAT, returning the model:
reservedconst_1: 255
1 th attempt: second query is SAT-- constant doesn't work
first query is UNSAT-- no more guesses
Dataflow Pruned 0/0
There are 1 Guesses
There are 0 RHSs before deduplication
There are 0 RHSs after deduplication
got 2 candidates from LHS

-------------------------------------------------
%0:i32 = var
%1:i1 = slt 16:i32, %0
infer %1


--------------------------------
guess 0

%0:i1 = var ; reservedconst_1

Cost = 0
first query is SAT, returning the model:
reservedconst_1: 0
0 th attempt: second query is SAT-- constant doesn't work
first query is SAT, returning the model:
reservedconst_1: -1
1 th attempt: second query is SAT-- constant doesn't work
first query is UNSAT-- no more guesses
Dataflow Pruned 0/0
There are 1 Guesses
There are 0 RHSs before deduplication
There are 0 RHSs after deduplication
got 2 candidates from LHS

-------------------------------------------------
%0:i32 = var
%1:i32 = addnsw 1:i32, %0
infer %1


--------------------------------
guess 0

%0:i32 = var ; reservedconst_1

Cost = 0
first query is SAT, returning the model:
reservedconst_1: 1
0 th attempt: second query is SAT-- constant doesn't work
first query is SAT, returning the model:
reservedconst_1: 268435457
1 th attempt: second query is SAT-- constant doesn't work
first query is UNSAT-- no more guesses

--------------------------------
guess 1

%0:i32 = var

Cost = 0
second query is SAT-- constant doesn't work
Dataflow Pruned 0/0
There are 2 Guesses
There are 0 RHSs before deduplication
There are 0 RHSs after deduplication
#########################################################
; exiting Souper's runOnFunction() for show()

; entering Souper's runOnFunction() for walk()

; ModuleID = './Maze_generation.c.bc'
source_filename = "./Maze_generation.c"
target datalayout = "e-m:e-p:32:32-i64:64-n32:64-S128"
target triple = "wasm32-unknown-wasi"

@glyph = hidden global [30 x i32] [i32 12288, i32 9474, i32 9474, i32 9474, i32 9472, i32 9496, i32 9488, i32 9508, i32 9472, i32 9492, i32 9484, i32 9500, i32 9472, i32 9524, i32 9516, i32 9532, i32 12288, i32 9478, i32 9478, i32 9478, i32 9476, i32 9583, i32 9582, i32 32, i32 9476, i32 9584, i32 9581, i32 32, i32 9476, i32 0], align 16
@h = hidden global i32 0, align 4
@w = hidden global i32 0, align 4
@cell = hidden global i8** null, align 4
@.str = private unnamed_addr constant [6 x i8] c"\1B[31m\00", align 1
@.str.1 = private unnamed_addr constant [4 x i8] c"%lc\00", align 1
@.str.2 = private unnamed_addr constant [4 x i8] c"\1B[m\00", align 1
@__const.walk.d = private unnamed_addr constant [4 x i32] [i32 0, i32 1, i32 2, i32 3], align 16
@avail = hidden global i32 0, align 4
@dirs = internal global [4 x [2 x i32]] [[2 x i32] [i32 -2, i32 0], [2 x i32] [i32 0, i32 2], [2 x i32] [i32 2, i32 0], [2 x i32] [i32 0, i32 -2]], align 16
@.str.3 = private unnamed_addr constant [1 x i8] zeroinitializer, align 1

; Function Attrs: noinline nounwind optnone
define hidden i32 @irand(i32 %n) #0 {
entry:
  %n.addr = alloca i32, align 4
  %r = alloca i32, align 4
  %rmax = alloca i32, align 4
  store i32 %n, i32* %n.addr, align 4
  %0 = load i32, i32* %n.addr, align 4
  %1 = load i32, i32* %n.addr, align 4
  %div = sdiv i32 2147483647, %1
  %mul = mul nsw i32 %0, %div
  store i32 %mul, i32* %rmax, align 4
  br label %while.cond

while.cond:                                       ; preds = %while.body, %entry
  %call = call i32 @rand()
  store i32 %call, i32* %r, align 4
  %2 = load i32, i32* %rmax, align 4
  %cmp = icmp sge i32 %call, %2
  br i1 %cmp, label %while.body, label %while.end

while.body:                                       ; preds = %while.cond
  br label %while.cond

while.end:                                        ; preds = %while.cond
  %3 = load i32, i32* %r, align 4
  %4 = load i32, i32* %n.addr, align 4
  %div1 = sdiv i32 2147483647, %4
  %div2 = sdiv i32 %3, %div1
  ret i32 %div2
}

declare i32 @rand() #1

; Function Attrs: noinline nounwind optnone
define hidden void @show() #0 {
entry:
  %i = alloca i32, align 4
  %j = alloca i32, align 4
  %c = alloca i32, align 4
  store i32 0, i32* %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc16, %entry
  %0 = load i32, i32* %i, align 4
  %1 = load i32, i32* @h, align 4
  %mul = mul nsw i32 2, %1
  %cmp = icmp sle i32 %0, %mul
  br i1 %cmp, label %for.body, label %for.end18

for.body:                                         ; preds = %for.cond
  store i32 0, i32* %j, align 4
  br label %for.cond1

for.cond1:                                        ; preds = %for.inc, %for.body
  %2 = load i32, i32* %j, align 4
  %3 = load i32, i32* @w, align 4
  %mul2 = mul nsw i32 2, %3
  %cmp3 = icmp sle i32 %2, %mul2
  br i1 %cmp3, label %for.body4, label %for.end

for.body4:                                        ; preds = %for.cond1
  %4 = load i8**, i8*** @cell, align 4
  %5 = load i32, i32* %i, align 4
  %arrayidx = getelementptr inbounds i8*, i8** %4, i32 %5
  %6 = load i8*, i8** %arrayidx, align 4
  %7 = load i32, i32* %j, align 4
  %arrayidx5 = getelementptr inbounds i8, i8* %6, i32 %7
  %8 = load i8, i8* %arrayidx5, align 1
  %conv = zext i8 %8 to i32
  store i32 %conv, i32* %c, align 4
  %9 = load i32, i32* %c, align 4
  %cmp6 = icmp sgt i32 %9, 16
  br i1 %cmp6, label %if.then, label %if.end

if.then:                                          ; preds = %for.body4
  %call = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([6 x i8], [6 x i8]* @.str, i32 0, i32 0))
  br label %if.end

if.end:                                           ; preds = %if.then, %for.body4
  %10 = load i32, i32* %c, align 4
  %arrayidx8 = getelementptr inbounds [30 x i32], [30 x i32]* @glyph, i32 0, i32 %10
  %11 = load i32, i32* %arrayidx8, align 4
  %call9 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([4 x i8], [4 x i8]* @.str.1, i32 0, i32 0), i32 %11)
  %12 = load i32, i32* %c, align 4
  %cmp10 = icmp sgt i32 %12, 16
  br i1 %cmp10, label %if.then12, label %if.end14

if.then12:                                        ; preds = %if.end
  %call13 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([4 x i8], [4 x i8]* @.str.2, i32 0, i32 0))
  br label %if.end14

if.end14:                                         ; preds = %if.then12, %if.end
  br label %for.inc

for.inc:                                          ; preds = %if.end14
  %13 = load i32, i32* %j, align 4
  %inc = add nsw i32 %13, 1
  store i32 %inc, i32* %j, align 4
  br label %for.cond1

for.end:                                          ; preds = %for.cond1
  %call15 = call i32 @putchar(i32 10)
  br label %for.inc16

for.inc16:                                        ; preds = %for.end
  %14 = load i32, i32* %i, align 4
  %inc17 = add nsw i32 %14, 1
  store i32 %inc17, i32* %i, align 4
  br label %for.cond

for.end18:                                        ; preds = %for.cond
  ret void
}

declare i32 @printf(i8* %0, ...) #1

declare i32 @putchar(i32 %0) #1

; Function Attrs: noinline nounwind optnone
define hidden void @walk(i32 %x, i32 %y) #0 {
entry:
  %x.addr = alloca i32, align 4
  %y.addr = alloca i32, align 4
  %i = alloca i32, align 4
  %t = alloca i32, align 4
  %x1 = alloca i32, align 4
  %y1 = alloca i32, align 4
  %d = alloca [4 x i32], align 16
  store i32 %x, i32* %x.addr, align 4
  store i32 %y, i32* %y.addr, align 4
  %0 = bitcast [4 x i32]* %d to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 16 %0, i8* align 16 bitcast ([4 x i32]* @__const.walk.d to i8*), i32 16, i1 false)
  %1 = load i8**, i8*** @cell, align 4
  %2 = load i32, i32* %y.addr, align 4
  %arrayidx = getelementptr inbounds i8*, i8** %1, i32 %2
  %3 = load i8*, i8** %arrayidx, align 4
  %4 = load i32, i32* %x.addr, align 4
  %arrayidx1 = getelementptr inbounds i8, i8* %3, i32 %4
  %5 = load i8, i8* %arrayidx1, align 1
  %conv = zext i8 %5 to i32
  %or = or i32 %conv, 16
  %conv2 = trunc i32 %or to i8
  store i8 %conv2, i8* %arrayidx1, align 1
  %6 = load i32, i32* @avail, align 4
  %dec = add nsw i32 %6, -1
  store i32 %dec, i32* @avail, align 4
  store i32 3, i32* %x1, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %7 = load i32, i32* %x1, align 4
  %tobool = icmp ne i32 %7, 0
  br i1 %tobool, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %8 = load i32, i32* %x1, align 4
  %9 = load i32, i32* %x1, align 4
  %add = add nsw i32 %9, 1
  %call = call i32 @irand(i32 %add)
  store i32 %call, i32* %y1, align 4
  %cmp = icmp ne i32 %8, %call
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %for.body
  %10 = load i32, i32* %x1, align 4
  %arrayidx4 = getelementptr inbounds [4 x i32], [4 x i32]* %d, i32 0, i32 %10
  %11 = load i32, i32* %arrayidx4, align 4
  store i32 %11, i32* %i, align 4
  %12 = load i32, i32* %y1, align 4
  %arrayidx5 = getelementptr inbounds [4 x i32], [4 x i32]* %d, i32 0, i32 %12
  %13 = load i32, i32* %arrayidx5, align 4
  %14 = load i32, i32* %x1, align 4
  %arrayidx6 = getelementptr inbounds [4 x i32], [4 x i32]* %d, i32 0, i32 %14
  store i32 %13, i32* %arrayidx6, align 4
  %15 = load i32, i32* %i, align 4
  %16 = load i32, i32* %y1, align 4
  %arrayidx7 = getelementptr inbounds [4 x i32], [4 x i32]* %d, i32 0, i32 %16
  store i32 %15, i32* %arrayidx7, align 4
  br label %if.end

if.end:                                           ; preds = %if.then, %for.body
  br label %for.inc

for.inc:                                          ; preds = %if.end
  %17 = load i32, i32* %x1, align 4
  %dec8 = add nsw i32 %17, -1
  store i32 %dec8, i32* %x1, align 4
  br label %for.cond

for.end:                                          ; preds = %for.cond
  store i32 0, i32* %i, align 4
  br label %for.cond9

for.cond9:                                        ; preds = %for.inc72, %for.end
  %18 = load i32, i32* @avail, align 4
  %tobool10 = icmp ne i32 %18, 0
  br i1 %tobool10, label %land.rhs, label %land.end

land.rhs:                                         ; preds = %for.cond9
  %19 = load i32, i32* %i, align 4
  %cmp11 = icmp slt i32 %19, 4
  br label %land.end

land.end:                                         ; preds = %land.rhs, %for.cond9
  %20 = phi i1 [ false, %for.cond9 ], [ %cmp11, %land.rhs ]
  br i1 %20, label %for.body13, label %for.end73

for.body13:                                       ; preds = %land.end
  %21 = load i32, i32* %x.addr, align 4
  %22 = load i32, i32* %i, align 4
  %arrayidx14 = getelementptr inbounds [4 x i32], [4 x i32]* %d, i32 0, i32 %22
  %23 = load i32, i32* %arrayidx14, align 4
  %arrayidx15 = getelementptr inbounds [4 x [2 x i32]], [4 x [2 x i32]]* @dirs, i32 0, i32 %23
  %arrayidx16 = getelementptr inbounds [2 x i32], [2 x i32]* %arrayidx15, i32 0, i32 0
  %24 = load i32, i32* %arrayidx16, align 8
  %add17 = add nsw i32 %21, %24
  store i32 %add17, i32* %x1, align 4
  %25 = load i32, i32* %y.addr, align 4
  %26 = load i32, i32* %i, align 4
  %arrayidx18 = getelementptr inbounds [4 x i32], [4 x i32]* %d, i32 0, i32 %26
  %27 = load i32, i32* %arrayidx18, align 4
  %arrayidx19 = getelementptr inbounds [4 x [2 x i32]], [4 x [2 x i32]]* @dirs, i32 0, i32 %27
  %arrayidx20 = getelementptr inbounds [2 x i32], [2 x i32]* %arrayidx19, i32 0, i32 1
  %28 = load i32, i32* %arrayidx20, align 4
  %add21 = add nsw i32 %25, %28
  store i32 %add21, i32* %y1, align 4
  %29 = load i8**, i8*** @cell, align 4
  %30 = load i32, i32* %y1, align 4
  %arrayidx22 = getelementptr inbounds i8*, i8** %29, i32 %30
  %31 = load i8*, i8** %arrayidx22, align 4
  %32 = load i32, i32* %x1, align 4
  %arrayidx23 = getelementptr inbounds i8, i8* %31, i32 %32
  %33 = load i8, i8* %arrayidx23, align 1
  %conv24 = zext i8 %33 to i32
  %and = and i32 %conv24, 16
  %tobool25 = icmp ne i32 %and, 0
  br i1 %tobool25, label %if.then26, label %if.end27

if.then26:                                        ; preds = %for.body13
  br label %for.inc72

if.end27:                                         ; preds = %for.body13
  %34 = load i32, i32* %x1, align 4
  %35 = load i32, i32* %x.addr, align 4
  %cmp28 = icmp eq i32 %34, %35
  br i1 %cmp28, label %if.then30, label %if.else

if.then30:                                        ; preds = %if.end27
  %36 = load i32, i32* %y.addr, align 4
  %37 = load i32, i32* %y1, align 4
  %add31 = add nsw i32 %36, %37
  %div = sdiv i32 %add31, 2
  store i32 %div, i32* %t, align 4
  %38 = load i8**, i8*** @cell, align 4
  %39 = load i32, i32* %t, align 4
  %arrayidx32 = getelementptr inbounds i8*, i8** %38, i32 %39
  %40 = load i8*, i8** %arrayidx32, align 4
  %41 = load i32, i32* %x.addr, align 4
  %add33 = add nsw i32 %41, 1
  %arrayidx34 = getelementptr inbounds i8, i8* %40, i32 %add33
  %42 = load i8, i8* %arrayidx34, align 1
  %conv35 = zext i8 %42 to i32
  %and36 = and i32 %conv35, -5
  %conv37 = trunc i32 %and36 to i8
  store i8 %conv37, i8* %arrayidx34, align 1
  %43 = load i8**, i8*** @cell, align 4
  %44 = load i32, i32* %t, align 4
  %arrayidx38 = getelementptr inbounds i8*, i8** %43, i32 %44
  %45 = load i8*, i8** %arrayidx38, align 4
  %46 = load i32, i32* %x.addr, align 4
  %arrayidx39 = getelementptr inbounds i8, i8* %45, i32 %46
  %47 = load i8, i8* %arrayidx39, align 1
  %conv40 = zext i8 %47 to i32
  %and41 = and i32 %conv40, -13
  %conv42 = trunc i32 %and41 to i8
  store i8 %conv42, i8* %arrayidx39, align 1
  %48 = load i8**, i8*** @cell, align 4
  %49 = load i32, i32* %t, align 4
  %arrayidx43 = getelementptr inbounds i8*, i8** %48, i32 %49
  %50 = load i8*, i8** %arrayidx43, align 4
  %51 = load i32, i32* %x.addr, align 4
  %sub = sub nsw i32 %51, 1
  %arrayidx44 = getelementptr inbounds i8, i8* %50, i32 %sub
  %52 = load i8, i8* %arrayidx44, align 1
  %conv45 = zext i8 %52 to i32
  %and46 = and i32 %conv45, -9
  %conv47 = trunc i32 %and46 to i8
  store i8 %conv47, i8* %arrayidx44, align 1
  br label %if.end71

if.else:                                          ; preds = %if.end27
  %53 = load i32, i32* %y1, align 4
  %54 = load i32, i32* %y.addr, align 4
  %cmp48 = icmp eq i32 %53, %54
  br i1 %cmp48, label %if.then50, label %if.end70

if.then50:                                        ; preds = %if.else
  %55 = load i32, i32* %x.addr, align 4
  %56 = load i32, i32* %x1, align 4
  %add51 = add nsw i32 %55, %56
  %div52 = sdiv i32 %add51, 2
  store i32 %div52, i32* %t, align 4
  %57 = load i8**, i8*** @cell, align 4
  %58 = load i32, i32* %y.addr, align 4
  %sub53 = sub nsw i32 %58, 1
  %arrayidx54 = getelementptr inbounds i8*, i8** %57, i32 %sub53
  %59 = load i8*, i8** %arrayidx54, align 4
  %60 = load i32, i32* %t, align 4
  %arrayidx55 = getelementptr inbounds i8, i8* %59, i32 %60
  %61 = load i8, i8* %arrayidx55, align 1
  %conv56 = zext i8 %61 to i32
  %and57 = and i32 %conv56, -3
  %conv58 = trunc i32 %and57 to i8
  store i8 %conv58, i8* %arrayidx55, align 1
  %62 = load i8**, i8*** @cell, align 4
  %63 = load i32, i32* %y.addr, align 4
  %arrayidx59 = getelementptr inbounds i8*, i8** %62, i32 %63
  %64 = load i8*, i8** %arrayidx59, align 4
  %65 = load i32, i32* %t, align 4
  %arrayidx60 = getelementptr inbounds i8, i8* %64, i32 %65
  %66 = load i8, i8* %arrayidx60, align 1
  %conv61 = zext i8 %66 to i32
  %and62 = and i32 %conv61, -4
  %conv63 = trunc i32 %and62 to i8
  store i8 %conv63, i8* %arrayidx60, align 1
  %67 = load i8**, i8*** @cell, align 4
  %68 = load i32, i32* %y.addr, align 4
  %add64 = add nsw i32 %68, 1
  %arrayidx65 = getelementptr inbounds i8*, i8** %67, i32 %add64
  %69 = load i8*, i8** %arrayidx65, align 4
  %70 = load i32, i32* %t, align 4
  %arrayidx66 = getelementptr inbounds i8, i8* %69, i32 %70
  %71 = load i8, i8* %arrayidx66, align 1
  %conv67 = zext i8 %71 to i32
  %and68 = and i32 %conv67, -2
  %conv69 = trunc i32 %and68 to i8
  store i8 %conv69, i8* %arrayidx66, align 1
  br label %if.end70

if.end70:                                         ; preds = %if.then50, %if.else
  br label %if.end71

if.end71:                                         ; preds = %if.end70, %if.then30
  %72 = load i32, i32* %x1, align 4
  %73 = load i32, i32* %y1, align 4
  call void @walk(i32 %72, i32 %73)
  br label %for.inc72

for.inc72:                                        ; preds = %if.end71, %if.then26
  %74 = load i32, i32* %i, align 4
  %inc = add nsw i32 %74, 1
  store i32 %inc, i32* %i, align 4
  br label %for.cond9

for.end73:                                        ; preds = %land.end
  ret void
}

; Function Attrs: argmemonly nounwind willreturn
declare void @llvm.memcpy.p0i8.p0i8.i32(i8* noalias nocapture writeonly %0, i8* noalias nocapture readonly %1, i32 %2, i1 immarg %3) #2

; Function Attrs: noinline nounwind optnone
define hidden i32 @solve(i32 %x, i32 %y, i32 %tox, i32 %toy) #0 {
entry:
  %retval = alloca i32, align 4
  %x.addr = alloca i32, align 4
  %y.addr = alloca i32, align 4
  %tox.addr = alloca i32, align 4
  %toy.addr = alloca i32, align 4
  %i = alloca i32, align 4
  %t = alloca i32, align 4
  %x1 = alloca i32, align 4
  %y1 = alloca i32, align 4
  store i32 %x, i32* %x.addr, align 4
  store i32 %y, i32* %y.addr, align 4
  store i32 %tox, i32* %tox.addr, align 4
  store i32 %toy, i32* %toy.addr, align 4
  %0 = load i8**, i8*** @cell, align 4
  %1 = load i32, i32* %y.addr, align 4
  %arrayidx = getelementptr inbounds i8*, i8** %0, i32 %1
  %2 = load i8*, i8** %arrayidx, align 4
  %3 = load i32, i32* %x.addr, align 4
  %arrayidx1 = getelementptr inbounds i8, i8* %2, i32 %3
  %4 = load i8, i8* %arrayidx1, align 1
  %conv = zext i8 %4 to i32
  %or = or i32 %conv, 16
  %conv2 = trunc i32 %or to i8
  store i8 %conv2, i8* %arrayidx1, align 1
  %5 = load i32, i32* %x.addr, align 4
  %6 = load i32, i32* %tox.addr, align 4
  %cmp = icmp eq i32 %5, %6
  br i1 %cmp, label %land.lhs.true, label %if.end

land.lhs.true:                                    ; preds = %entry
  %7 = load i32, i32* %y.addr, align 4
  %8 = load i32, i32* %toy.addr, align 4
  %cmp4 = icmp eq i32 %7, %8
  br i1 %cmp4, label %if.then, label %if.end

if.then:                                          ; preds = %land.lhs.true
  store i32 1, i32* %retval, align 4
  br label %return

if.end:                                           ; preds = %land.lhs.true, %entry
  store i32 0, i32* %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.end
  %9 = load i32, i32* %i, align 4
  %cmp6 = icmp sle i32 %9, 3
  br i1 %cmp6, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %10 = load i32, i32* %x.addr, align 4
  %11 = load i32, i32* %i, align 4
  %arrayidx8 = getelementptr inbounds [4 x [2 x i32]], [4 x [2 x i32]]* @dirs, i32 0, i32 %11
  %arrayidx9 = getelementptr inbounds [2 x i32], [2 x i32]* %arrayidx8, i32 0, i32 0
  %12 = load i32, i32* %arrayidx9, align 8
  %add = add nsw i32 %10, %12
  store i32 %add, i32* %x1, align 4
  %13 = load i32, i32* %y.addr, align 4
  %14 = load i32, i32* %i, align 4
  %arrayidx10 = getelementptr inbounds [4 x [2 x i32]], [4 x [2 x i32]]* @dirs, i32 0, i32 %14
  %arrayidx11 = getelementptr inbounds [2 x i32], [2 x i32]* %arrayidx10, i32 0, i32 1
  %15 = load i32, i32* %arrayidx11, align 4
  %add12 = add nsw i32 %13, %15
  store i32 %add12, i32* %y1, align 4
  %16 = load i8**, i8*** @cell, align 4
  %17 = load i32, i32* %y1, align 4
  %arrayidx13 = getelementptr inbounds i8*, i8** %16, i32 %17
  %18 = load i8*, i8** %arrayidx13, align 4
  %19 = load i32, i32* %x1, align 4
  %arrayidx14 = getelementptr inbounds i8, i8* %18, i32 %19
  %20 = load i8, i8* %arrayidx14, align 1
  %tobool = icmp ne i8 %20, 0
  br i1 %tobool, label %if.then15, label %if.end16

if.then15:                                        ; preds = %for.body
  br label %for.inc

if.end16:                                         ; preds = %for.body
  %21 = load i32, i32* %x1, align 4
  %22 = load i32, i32* %x.addr, align 4
  %cmp17 = icmp eq i32 %21, %22
  br i1 %cmp17, label %if.then19, label %if.else

if.then19:                                        ; preds = %if.end16
  %23 = load i32, i32* %y.addr, align 4
  %24 = load i32, i32* %y1, align 4
  %add20 = add nsw i32 %23, %24
  %div = sdiv i32 %add20, 2
  store i32 %div, i32* %t, align 4
  %25 = load i8**, i8*** @cell, align 4
  %26 = load i32, i32* %t, align 4
  %arrayidx21 = getelementptr inbounds i8*, i8** %25, i32 %26
  %27 = load i8*, i8** %arrayidx21, align 4
  %28 = load i32, i32* %x.addr, align 4
  %arrayidx22 = getelementptr inbounds i8, i8* %27, i32 %28
  %29 = load i8, i8* %arrayidx22, align 1
  %conv23 = zext i8 %29 to i32
  %tobool24 = icmp ne i32 %conv23, 0
  br i1 %tobool24, label %if.then26, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %if.then19
  %30 = load i32, i32* %x1, align 4
  %31 = load i32, i32* %y1, align 4
  %32 = load i32, i32* %tox.addr, align 4
  %33 = load i32, i32* %toy.addr, align 4
  %call = call i32 @solve(i32 %30, i32 %31, i32 %32, i32 %33)
  %tobool25 = icmp ne i32 %call, 0
  br i1 %tobool25, label %if.end27, label %if.then26

if.then26:                                        ; preds = %lor.lhs.false, %if.then19
  br label %for.inc

if.end27:                                         ; preds = %lor.lhs.false
  %34 = load i8**, i8*** @cell, align 4
  %35 = load i32, i32* %t, align 4
  %sub = sub nsw i32 %35, 1
  %arrayidx28 = getelementptr inbounds i8*, i8** %34, i32 %sub
  %36 = load i8*, i8** %arrayidx28, align 4
  %37 = load i32, i32* %x.addr, align 4
  %arrayidx29 = getelementptr inbounds i8, i8* %36, i32 %37
  %38 = load i8, i8* %arrayidx29, align 1
  %conv30 = zext i8 %38 to i32
  %or31 = or i32 %conv30, 2
  %conv32 = trunc i32 %or31 to i8
  store i8 %conv32, i8* %arrayidx29, align 1
  %39 = load i8**, i8*** @cell, align 4
  %40 = load i32, i32* %t, align 4
  %arrayidx33 = getelementptr inbounds i8*, i8** %39, i32 %40
  %41 = load i8*, i8** %arrayidx33, align 4
  %42 = load i32, i32* %x.addr, align 4
  %arrayidx34 = getelementptr inbounds i8, i8* %41, i32 %42
  %43 = load i8, i8* %arrayidx34, align 1
  %conv35 = zext i8 %43 to i32
  %or36 = or i32 %conv35, 19
  %conv37 = trunc i32 %or36 to i8
  store i8 %conv37, i8* %arrayidx34, align 1
  %44 = load i8**, i8*** @cell, align 4
  %45 = load i32, i32* %t, align 4
  %add38 = add nsw i32 %45, 1
  %arrayidx39 = getelementptr inbounds i8*, i8** %44, i32 %add38
  %46 = load i8*, i8** %arrayidx39, align 4
  %47 = load i32, i32* %x.addr, align 4
  %arrayidx40 = getelementptr inbounds i8, i8* %46, i32 %47
  %48 = load i8, i8* %arrayidx40, align 1
  %conv41 = zext i8 %48 to i32
  %or42 = or i32 %conv41, 1
  %conv43 = trunc i32 %or42 to i8
  store i8 %conv43, i8* %arrayidx40, align 1
  br label %if.end76

if.else:                                          ; preds = %if.end16
  %49 = load i32, i32* %y1, align 4
  %50 = load i32, i32* %y.addr, align 4
  %cmp44 = icmp eq i32 %49, %50
  br i1 %cmp44, label %if.then46, label %if.end75

if.then46:                                        ; preds = %if.else
  %51 = load i32, i32* %x.addr, align 4
  %52 = load i32, i32* %x1, align 4
  %add47 = add nsw i32 %51, %52
  %div48 = sdiv i32 %add47, 2
  store i32 %div48, i32* %t, align 4
  %53 = load i8**, i8*** @cell, align 4
  %54 = load i32, i32* %y.addr, align 4
  %arrayidx49 = getelementptr inbounds i8*, i8** %53, i32 %54
  %55 = load i8*, i8** %arrayidx49, align 4
  %56 = load i32, i32* %t, align 4
  %arrayidx50 = getelementptr inbounds i8, i8* %55, i32 %56
  %57 = load i8, i8* %arrayidx50, align 1
  %conv51 = zext i8 %57 to i32
  %tobool52 = icmp ne i32 %conv51, 0
  br i1 %tobool52, label %if.then56, label %lor.lhs.false53

lor.lhs.false53:                                  ; preds = %if.then46
  %58 = load i32, i32* %x1, align 4
  %59 = load i32, i32* %y1, align 4
  %60 = load i32, i32* %tox.addr, align 4
  %61 = load i32, i32* %toy.addr, align 4
  %call54 = call i32 @solve(i32 %58, i32 %59, i32 %60, i32 %61)
  %tobool55 = icmp ne i32 %call54, 0
  br i1 %tobool55, label %if.end57, label %if.then56

if.then56:                                        ; preds = %lor.lhs.false53, %if.then46
  br label %for.inc

if.end57:                                         ; preds = %lor.lhs.false53
  %62 = load i8**, i8*** @cell, align 4
  %63 = load i32, i32* %y.addr, align 4
  %arrayidx58 = getelementptr inbounds i8*, i8** %62, i32 %63
  %64 = load i8*, i8** %arrayidx58, align 4
  %65 = load i32, i32* %t, align 4
  %sub59 = sub nsw i32 %65, 1
  %arrayidx60 = getelementptr inbounds i8, i8* %64, i32 %sub59
  %66 = load i8, i8* %arrayidx60, align 1
  %conv61 = zext i8 %66 to i32
  %or62 = or i32 %conv61, 8
  %conv63 = trunc i32 %or62 to i8
  store i8 %conv63, i8* %arrayidx60, align 1
  %67 = load i8**, i8*** @cell, align 4
  %68 = load i32, i32* %y.addr, align 4
  %arrayidx64 = getelementptr inbounds i8*, i8** %67, i32 %68
  %69 = load i8*, i8** %arrayidx64, align 4
  %70 = load i32, i32* %t, align 4
  %arrayidx65 = getelementptr inbounds i8, i8* %69, i32 %70
  %71 = load i8, i8* %arrayidx65, align 1
  %conv66 = zext i8 %71 to i32
  %or67 = or i32 %conv66, 28
  %conv68 = trunc i32 %or67 to i8
  store i8 %conv68, i8* %arrayidx65, align 1
  %72 = load i8**, i8*** @cell, align 4
  %73 = load i32, i32* %y.addr, align 4
  %arrayidx69 = getelementptr inbounds i8*, i8** %72, i32 %73
  %74 = load i8*, i8** %arrayidx69, align 4
  %75 = load i32, i32* %t, align 4
  %add70 = add nsw i32 %75, 1
  %arrayidx71 = getelementptr inbounds i8, i8* %74, i32 %add70
  %76 = load i8, i8* %arrayidx71, align 1
  %conv72 = zext i8 %76 to i32
  %or73 = or i32 %conv72, 4
  %conv74 = trunc i32 %or73 to i8
  store i8 %conv74, i8* %arrayidx71, align 1
  br label %if.end75

if.end75:                                         ; preds = %if.end57, %if.else
  br label %if.end76

if.end76:                                         ; preds = %if.end75, %if.end27
  store i32 1, i32* %retval, align 4
  br label %return

for.inc:                                          ; preds = %if.then56, %if.then26, %if.then15
  %77 = load i32, i32* %i, align 4
  %inc = add nsw i32 %77, 1
  store i32 %inc, i32* %i, align 4
  br label %for.cond

for.end:                                          ; preds = %for.cond
  %78 = load i8**, i8*** @cell, align 4
  %79 = load i32, i32* %y.addr, align 4
  %arrayidx77 = getelementptr inbounds i8*, i8** %78, i32 %79
  %80 = load i8*, i8** %arrayidx77, align 4
  %81 = load i32, i32* %x.addr, align 4
  %arrayidx78 = getelementptr inbounds i8, i8* %80, i32 %81
  %82 = load i8, i8* %arrayidx78, align 1
  %conv79 = zext i8 %82 to i32
  %and = and i32 %conv79, -17
  %conv80 = trunc i32 %and to i8
  store i8 %conv80, i8* %arrayidx78, align 1
  store i32 0, i32* %retval, align 4
  br label %return

return:                                           ; preds = %for.end, %if.end76, %if.then
  %83 = load i32, i32* %retval, align 4
  ret i32 %83
}

; Function Attrs: noinline nounwind optnone
define hidden void @make_maze() #0 {
entry:
  %i = alloca i32, align 4
  %j = alloca i32, align 4
  %h2 = alloca i32, align 4
  %w2 = alloca i32, align 4
  %p = alloca i8**, align 4
  %0 = load i32, i32* @h, align 4
  %mul = mul nsw i32 2, %0
  %add = add nsw i32 %mul, 2
  store i32 %add, i32* %h2, align 4
  %1 = load i32, i32* @w, align 4
  %mul1 = mul nsw i32 2, %1
  %add2 = add nsw i32 %mul1, 2
  store i32 %add2, i32* %w2, align 4
  %2 = load i32, i32* %h2, align 4
  %add3 = add nsw i32 %2, 2
  %mul4 = mul i32 4, %add3
  %3 = load i32, i32* %w2, align 4
  %4 = load i32, i32* %h2, align 4
  %mul5 = mul nsw i32 %3, %4
  %add6 = add i32 %mul4, %mul5
  %add7 = add i32 %add6, 1
  %call = call noalias i8* @calloc(i32 %add7, i32 1)
  %5 = bitcast i8* %call to i8**
  store i8** %5, i8*** %p, align 4
  %6 = load i8**, i8*** %p, align 4
  %7 = load i32, i32* %h2, align 4
  %add.ptr = getelementptr inbounds i8*, i8** %6, i32 %7
  %add.ptr8 = getelementptr inbounds i8*, i8** %add.ptr, i32 2
  %8 = bitcast i8** %add.ptr8 to i8*
  %add.ptr9 = getelementptr inbounds i8, i8* %8, i32 1
  %9 = load i8**, i8*** %p, align 4
  %arrayidx = getelementptr inbounds i8*, i8** %9, i32 1
  store i8* %add.ptr9, i8** %arrayidx, align 4
  store i32 2, i32* %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %10 = load i32, i32* %i, align 4
  %11 = load i32, i32* %h2, align 4
  %cmp = icmp sle i32 %10, %11
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %12 = load i8**, i8*** %p, align 4
  %13 = load i32, i32* %i, align 4
  %sub = sub nsw i32 %13, 1
  %arrayidx10 = getelementptr inbounds i8*, i8** %12, i32 %sub
  %14 = load i8*, i8** %arrayidx10, align 4
  %15 = load i32, i32* %w2, align 4
  %add.ptr11 = getelementptr inbounds i8, i8* %14, i32 %15
  %16 = load i8**, i8*** %p, align 4
  %17 = load i32, i32* %i, align 4
  %arrayidx12 = getelementptr inbounds i8*, i8** %16, i32 %17
  store i8* %add.ptr11, i8** %arrayidx12, align 4
  br label %for.inc

for.inc:                                          ; preds = %for.body
  %18 = load i32, i32* %i, align 4
  %inc = add nsw i32 %18, 1
  store i32 %inc, i32* %i, align 4
  br label %for.cond

for.end:                                          ; preds = %for.cond
  %19 = load i8**, i8*** %p, align 4
  %20 = load i32, i32* %h2, align 4
  %arrayidx13 = getelementptr inbounds i8*, i8** %19, i32 %20
  %21 = load i8*, i8** %arrayidx13, align 4
  %22 = load i8**, i8*** %p, align 4
  %arrayidx14 = getelementptr inbounds i8*, i8** %22, i32 0
  store i8* %21, i8** %arrayidx14, align 4
  %23 = load i8**, i8*** %p, align 4
  %arrayidx15 = getelementptr inbounds i8*, i8** %23, i32 1
  store i8** %arrayidx15, i8*** @cell, align 4
  store i32 -1, i32* %i, align 4
  br label %for.cond16

for.cond16:                                       ; preds = %for.inc26, %for.end
  %24 = load i32, i32* %i, align 4
  %25 = load i32, i32* @h, align 4
  %mul17 = mul nsw i32 2, %25
  %add18 = add nsw i32 %mul17, 1
  %cmp19 = icmp sle i32 %24, %add18
  br i1 %cmp19, label %for.body20, label %for.end28

for.body20:                                       ; preds = %for.cond16
  %26 = load i8**, i8*** @cell, align 4
  %27 = load i32, i32* %i, align 4
  %arrayidx21 = getelementptr inbounds i8*, i8** %26, i32 %27
  %28 = load i8*, i8** %arrayidx21, align 4
  %29 = load i32, i32* %w2, align 4
  %sub22 = sub nsw i32 %29, 1
  %arrayidx23 = getelementptr inbounds i8, i8* %28, i32 %sub22
  store i8 16, i8* %arrayidx23, align 1
  %30 = load i8**, i8*** @cell, align 4
  %31 = load i32, i32* %i, align 4
  %arrayidx24 = getelementptr inbounds i8*, i8** %30, i32 %31
  %32 = load i8*, i8** %arrayidx24, align 4
  %arrayidx25 = getelementptr inbounds i8, i8* %32, i32 -1
  store i8 16, i8* %arrayidx25, align 1
  br label %for.inc26

for.inc26:                                        ; preds = %for.body20
  %33 = load i32, i32* %i, align 4
  %inc27 = add nsw i32 %33, 1
  store i32 %inc27, i32* %i, align 4
  br label %for.cond16

for.end28:                                        ; preds = %for.cond16
  store i32 0, i32* %j, align 4
  br label %for.cond29

for.cond29:                                       ; preds = %for.inc38, %for.end28
  %34 = load i32, i32* %j, align 4
  %35 = load i32, i32* @w, align 4
  %mul30 = mul nsw i32 2, %35
  %cmp31 = icmp sle i32 %34, %mul30
  br i1 %cmp31, label %for.body32, label %for.end40

for.body32:                                       ; preds = %for.cond29
  %36 = load i8**, i8*** @cell, align 4
  %37 = load i32, i32* %h2, align 4
  %sub33 = sub nsw i32 %37, 1
  %arrayidx34 = getelementptr inbounds i8*, i8** %36, i32 %sub33
  %38 = load i8*, i8** %arrayidx34, align 4
  %39 = load i32, i32* %j, align 4
  %arrayidx35 = getelementptr inbounds i8, i8* %38, i32 %39
  store i8 16, i8* %arrayidx35, align 1
  %40 = load i8**, i8*** @cell, align 4
  %arrayidx36 = getelementptr inbounds i8*, i8** %40, i32 -1
  %41 = load i8*, i8** %arrayidx36, align 4
  %42 = load i32, i32* %j, align 4
  %arrayidx37 = getelementptr inbounds i8, i8* %41, i32 %42
  store i8 16, i8* %arrayidx37, align 1
  br label %for.inc38

for.inc38:                                        ; preds = %for.body32
  %43 = load i32, i32* %j, align 4
  %inc39 = add nsw i32 %43, 1
  store i32 %inc39, i32* %j, align 4
  br label %for.cond29

for.end40:                                        ; preds = %for.cond29
  store i32 0, i32* %i, align 4
  br label %for.cond41

for.cond41:                                       ; preds = %for.inc55, %for.end40
  %44 = load i32, i32* %i, align 4
  %45 = load i32, i32* @h, align 4
  %cmp42 = icmp sle i32 %44, %45
  br i1 %cmp42, label %for.body43, label %for.end57

for.body43:                                       ; preds = %for.cond41
  store i32 0, i32* %j, align 4
  br label %for.cond44

for.cond44:                                       ; preds = %for.inc52, %for.body43
  %46 = load i32, i32* %j, align 4
  %47 = load i32, i32* @w, align 4
  %mul45 = mul nsw i32 2, %47
  %cmp46 = icmp sle i32 %46, %mul45
  br i1 %cmp46, label %for.body47, label %for.end54

for.body47:                                       ; preds = %for.cond44
  %48 = load i8**, i8*** @cell, align 4
  %49 = load i32, i32* %i, align 4
  %mul48 = mul nsw i32 2, %49
  %arrayidx49 = getelementptr inbounds i8*, i8** %48, i32 %mul48
  %50 = load i8*, i8** %arrayidx49, align 4
  %51 = load i32, i32* %j, align 4
  %arrayidx50 = getelementptr inbounds i8, i8* %50, i32 %51
  %52 = load i8, i8* %arrayidx50, align 1
  %conv = zext i8 %52 to i32
  %or = or i32 %conv, 12
  %conv51 = trunc i32 %or to i8
  store i8 %conv51, i8* %arrayidx50, align 1
  br label %for.inc52

for.inc52:                                        ; preds = %for.body47
  %53 = load i32, i32* %j, align 4
  %inc53 = add nsw i32 %53, 1
  store i32 %inc53, i32* %j, align 4
  br label %for.cond44

for.end54:                                        ; preds = %for.cond44
  br label %for.inc55

for.inc55:                                        ; preds = %for.end54
  %54 = load i32, i32* %i, align 4
  %inc56 = add nsw i32 %54, 1
  store i32 %inc56, i32* %i, align 4
  br label %for.cond41

for.end57:                                        ; preds = %for.cond41
  store i32 0, i32* %i, align 4
  br label %for.cond58

for.cond58:                                       ; preds = %for.inc76, %for.end57
  %55 = load i32, i32* %i, align 4
  %56 = load i32, i32* @h, align 4
  %mul59 = mul nsw i32 2, %56
  %cmp60 = icmp sle i32 %55, %mul59
  br i1 %cmp60, label %for.body62, label %for.end78

for.body62:                                       ; preds = %for.cond58
  store i32 0, i32* %j, align 4
  br label %for.cond63

for.cond63:                                       ; preds = %for.inc73, %for.body62
  %57 = load i32, i32* %j, align 4
  %58 = load i32, i32* @w, align 4
  %cmp64 = icmp sle i32 %57, %58
  br i1 %cmp64, label %for.body66, label %for.end75

for.body66:                                       ; preds = %for.cond63
  %59 = load i8**, i8*** @cell, align 4
  %60 = load i32, i32* %i, align 4
  %arrayidx67 = getelementptr inbounds i8*, i8** %59, i32 %60
  %61 = load i8*, i8** %arrayidx67, align 4
  %62 = load i32, i32* %j, align 4
  %mul68 = mul nsw i32 2, %62
  %arrayidx69 = getelementptr inbounds i8, i8* %61, i32 %mul68
  %63 = load i8, i8* %arrayidx69, align 1
  %conv70 = zext i8 %63 to i32
  %or71 = or i32 %conv70, 3
  %conv72 = trunc i32 %or71 to i8
  store i8 %conv72, i8* %arrayidx69, align 1
  br label %for.inc73

for.inc73:                                        ; preds = %for.body66
  %64 = load i32, i32* %j, align 4
  %inc74 = add nsw i32 %64, 1
  store i32 %inc74, i32* %j, align 4
  br label %for.cond63

for.end75:                                        ; preds = %for.cond63
  br label %for.inc76

for.inc76:                                        ; preds = %for.end75
  %65 = load i32, i32* %i, align 4
  %inc77 = add nsw i32 %65, 1
  store i32 %inc77, i32* %i, align 4
  br label %for.cond58

for.end78:                                        ; preds = %for.cond58
  store i32 0, i32* %j, align 4
  br label %for.cond79

for.cond79:                                       ; preds = %for.inc94, %for.end78
  %66 = load i32, i32* %j, align 4
  %67 = load i32, i32* @w, align 4
  %mul80 = mul nsw i32 2, %67
  %cmp81 = icmp sle i32 %66, %mul80
  br i1 %cmp81, label %for.body83, label %for.end96

for.body83:                                       ; preds = %for.cond79
  %68 = load i8**, i8*** @cell, align 4
  %arrayidx84 = getelementptr inbounds i8*, i8** %68, i32 0
  %69 = load i8*, i8** %arrayidx84, align 4
  %70 = load i32, i32* %j, align 4
  %arrayidx85 = getelementptr inbounds i8, i8* %69, i32 %70
  %71 = load i8, i8* %arrayidx85, align 1
  %conv86 = zext i8 %71 to i32
  %and = and i32 %conv86, -2
  %conv87 = trunc i32 %and to i8
  store i8 %conv87, i8* %arrayidx85, align 1
  %72 = load i8**, i8*** @cell, align 4
  %73 = load i32, i32* @h, align 4
  %mul88 = mul nsw i32 2, %73
  %arrayidx89 = getelementptr inbounds i8*, i8** %72, i32 %mul88
  %74 = load i8*, i8** %arrayidx89, align 4
  %75 = load i32, i32* %j, align 4
  %arrayidx90 = getelementptr inbounds i8, i8* %74, i32 %75
  %76 = load i8, i8* %arrayidx90, align 1
  %conv91 = zext i8 %76 to i32
  %and92 = and i32 %conv91, -3
  %conv93 = trunc i32 %and92 to i8
  store i8 %conv93, i8* %arrayidx90, align 1
  br label %for.inc94

for.inc94:                                        ; preds = %for.body83
  %77 = load i32, i32* %j, align 4
  %inc95 = add nsw i32 %77, 1
  store i32 %inc95, i32* %j, align 4
  br label %for.cond79

for.end96:                                        ; preds = %for.cond79
  store i32 0, i32* %i, align 4
  br label %for.cond97

for.cond97:                                       ; preds = %for.inc113, %for.end96
  %78 = load i32, i32* %i, align 4
  %79 = load i32, i32* @h, align 4
  %mul98 = mul nsw i32 2, %79
  %cmp99 = icmp sle i32 %78, %mul98
  br i1 %cmp99, label %for.body101, label %for.end115

for.body101:                                      ; preds = %for.cond97
  %80 = load i8**, i8*** @cell, align 4
  %81 = load i32, i32* %i, align 4
  %arrayidx102 = getelementptr inbounds i8*, i8** %80, i32 %81
  %82 = load i8*, i8** %arrayidx102, align 4
  %arrayidx103 = getelementptr inbounds i8, i8* %82, i32 0
  %83 = load i8, i8* %arrayidx103, align 1
  %conv104 = zext i8 %83 to i32
  %and105 = and i32 %conv104, -5
  %conv106 = trunc i32 %and105 to i8
  store i8 %conv106, i8* %arrayidx103, align 1
  %84 = load i8**, i8*** @cell, align 4
  %85 = load i32, i32* %i, align 4
  %arrayidx107 = getelementptr inbounds i8*, i8** %84, i32 %85
  %86 = load i8*, i8** %arrayidx107, align 4
  %87 = load i32, i32* @w, align 4
  %mul108 = mul nsw i32 2, %87
  %arrayidx109 = getelementptr inbounds i8, i8* %86, i32 %mul108
  %88 = load i8, i8* %arrayidx109, align 1
  %conv110 = zext i8 %88 to i32
  %and111 = and i32 %conv110, -9
  %conv112 = trunc i32 %and111 to i8
  store i8 %conv112, i8* %arrayidx109, align 1
  br label %for.inc113

for.inc113:                                       ; preds = %for.body101
  %89 = load i32, i32* %i, align 4
  %inc114 = add nsw i32 %89, 1
  store i32 %inc114, i32* %i, align 4
  br label %for.cond97

for.end115:                                       ; preds = %for.cond97
  %90 = load i32, i32* @w, align 4
  %91 = load i32, i32* @h, align 4
  %mul116 = mul nsw i32 %90, %91
  store i32 %mul116, i32* @avail, align 4
  %call117 = call i32 @irand(i32 2)
  %mul118 = mul nsw i32 %call117, 2
  %add119 = add nsw i32 %mul118, 1
  %92 = load i32, i32* @h, align 4
  %call120 = call i32 @irand(i32 %92)
  %mul121 = mul nsw i32 %call120, 2
  %add122 = add nsw i32 %mul121, 1
  call void @walk(i32 %add119, i32 %add122)
  store i32 0, i32* %i, align 4
  br label %for.cond123

for.cond123:                                      ; preds = %for.inc141, %for.end115
  %93 = load i32, i32* %i, align 4
  %94 = load i32, i32* @h, align 4
  %mul124 = mul nsw i32 2, %94
  %cmp125 = icmp sle i32 %93, %mul124
  br i1 %cmp125, label %for.body127, label %for.end143

for.body127:                                      ; preds = %for.cond123
  store i32 0, i32* %j, align 4
  br label %for.cond128

for.cond128:                                      ; preds = %for.inc138, %for.body127
  %95 = load i32, i32* %j, align 4
  %96 = load i32, i32* @w, align 4
  %mul129 = mul nsw i32 2, %96
  %cmp130 = icmp sle i32 %95, %mul129
  br i1 %cmp130, label %for.body132, label %for.end140

for.body132:                                      ; preds = %for.cond128
  %97 = load i8**, i8*** @cell, align 4
  %98 = load i32, i32* %i, align 4
  %arrayidx133 = getelementptr inbounds i8*, i8** %97, i32 %98
  %99 = load i8*, i8** %arrayidx133, align 4
  %100 = load i32, i32* %j, align 4
  %arrayidx134 = getelementptr inbounds i8, i8* %99, i32 %100
  %101 = load i8, i8* %arrayidx134, align 1
  %conv135 = zext i8 %101 to i32
  %and136 = and i32 %conv135, -17
  %conv137 = trunc i32 %and136 to i8
  store i8 %conv137, i8* %arrayidx134, align 1
  br label %for.inc138

for.inc138:                                       ; preds = %for.body132
  %102 = load i32, i32* %j, align 4
  %inc139 = add nsw i32 %102, 1
  store i32 %inc139, i32* %j, align 4
  br label %for.cond128

for.end140:                                       ; preds = %for.cond128
  br label %for.inc141

for.inc141:                                       ; preds = %for.end140
  %103 = load i32, i32* %i, align 4
  %inc142 = add nsw i32 %103, 1
  store i32 %inc142, i32* %i, align 4
  br label %for.cond123

for.end143:                                       ; preds = %for.cond123
  %104 = load i32, i32* @w, align 4
  %mul144 = mul nsw i32 2, %104
  %sub145 = sub nsw i32 %mul144, 1
  %105 = load i32, i32* @h, align 4
  %mul146 = mul nsw i32 2, %105
  %sub147 = sub nsw i32 %mul146, 1
  %call148 = call i32 @solve(i32 1, i32 1, i32 %sub145, i32 %sub147)
  call void @show()
  ret void
}

declare noalias i8* @calloc(i32 %0, i32 %1) #1

; Function Attrs: noinline nounwind optnone
define hidden i32 @__main_argc_argv(i32 %c, i8** %v) #0 {
entry:
  %retval = alloca i32, align 4
  %c.addr = alloca i32, align 4
  %v.addr = alloca i8**, align 4
  store i32 0, i32* %retval, align 4
  store i32 %c, i32* %c.addr, align 4
  store i8** %v, i8*** %v.addr, align 4
  %call = call i8* @setlocale(i32 6, i8* getelementptr inbounds ([1 x i8], [1 x i8]* @.str.3, i32 0, i32 0))
  %0 = load i32, i32* %c.addr, align 4
  %cmp = icmp slt i32 %0, 2
  br i1 %cmp, label %if.then, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %entry
  %1 = load i8**, i8*** %v.addr, align 4
  %arrayidx = getelementptr inbounds i8*, i8** %1, i32 1
  %2 = load i8*, i8** %arrayidx, align 4
  %call1 = call i32 @atoi(i8* %2)
  store i32 %call1, i32* @w, align 4
  %cmp2 = icmp sle i32 %call1, 0
  br i1 %cmp2, label %if.then, label %if.end

if.then:                                          ; preds = %lor.lhs.false, %entry
  store i32 16, i32* @w, align 4
  br label %if.end

if.end:                                           ; preds = %if.then, %lor.lhs.false
  %3 = load i32, i32* %c.addr, align 4
  %cmp3 = icmp slt i32 %3, 3
  br i1 %cmp3, label %if.then8, label %lor.lhs.false4

lor.lhs.false4:                                   ; preds = %if.end
  %4 = load i8**, i8*** %v.addr, align 4
  %arrayidx5 = getelementptr inbounds i8*, i8** %4, i32 2
  %5 = load i8*, i8** %arrayidx5, align 4
  %call6 = call i32 @atoi(i8* %5)
  store i32 %call6, i32* @h, align 4
  %cmp7 = icmp sle i32 %call6, 0
  br i1 %cmp7, label %if.then8, label %if.end9

if.then8:                                         ; preds = %lor.lhs.false4, %if.end
  store i32 8, i32* @h, align 4
  br label %if.end9

if.end9:                                          ; preds = %if.then8, %lor.lhs.false4
  call void @make_maze()
  ret i32 0
}

declare i8* @setlocale(i32 %0, i8* %1) #1

declare i32 @atoi(i8* %0) #1

attributes #0 = { noinline nounwind optnone "correctly-rounded-divide-sqrt-fp-math"="false" "disable-tail-calls"="false" "frame-pointer"="none" "less-precise-fpmad"="false" "min-legal-vector-width"="0" "no-infs-fp-math"="false" "no-jump-tables"="false" "no-nans-fp-math"="false" "no-signed-zeros-fp-math"="false" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="generic" "unsafe-fp-math"="false" "use-soft-float"="false" }
attributes #1 = { "correctly-rounded-divide-sqrt-fp-math"="false" "disable-tail-calls"="false" "frame-pointer"="none" "less-precise-fpmad"="false" "no-infs-fp-math"="false" "no-nans-fp-math"="false" "no-signed-zeros-fp-math"="false" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="generic" "unsafe-fp-math"="false" "use-soft-float"="false" }
attributes #2 = { argmemonly nounwind willreturn }

!llvm.module.flags = !{!0}
!llvm.ident = !{!1}

!0 = !{i32 1, !"wchar_size", i32 4}
!1 = !{!"clang version 11.0.0 (https://github.com/Jacarte/llvm-project.git 0f6dea67136cc1e0b3d200eb2bb165628970c44b)"}

; extracted candidates

; *****
; For LLVM instruction:
;  %2 = load i32, i32* %y.addr, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %4 = load i32, i32* %x.addr, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %5 = load i8, i8* %arrayidx1, align 1
; Looking for a replacement for:
%0:i8 = var
infer %0 (demandedBits=11101111)

; *****
; For LLVM instruction:
;  %conv = zext i8 %5 to i32
; Looking for a replacement for:
%0:i8 = var
%1:i32 = zext %0
infer %1 (demandedBits=00000000000000000000000011101111)

; *****
; For LLVM instruction:
;  %or = or i32 %conv, 16
; Looking for a replacement for:
%0:i8 = var
%1:i32 = zext %0
%2:i32 = or 16:i32, %1
infer %2 (demandedBits=00000000000000000000000011111111)

; *****
; For LLVM instruction:
;  %conv2 = trunc i32 %or to i8
; Looking for a replacement for:
%0:i8 = var
%1:i32 = zext %0
%2:i32 = or 16:i32, %1
%3:i8 = trunc %2
infer %3

; *****
; For LLVM instruction:
;  %6 = load i32, i32* @avail, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %dec = add nsw i32 %6, -1
; Looking for a replacement for:
%0:i32 = var
%1:i32 = addnsw 4294967295:i32, %0
infer %1

; *****
; For LLVM instruction:
;  %7 = load i32, i32* %x1, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %tobool = icmp ne i32 %7, 0
; Looking for a replacement for:
%0:i32 = var
%1:i1 = ne 0:i32, %0
infer %1

; *****
; For LLVM instruction:
;  %8 = load i32, i32* %x1, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %9 = load i32, i32* %x1, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %add = add nsw i32 %9, 1
; Looking for a replacement for:
%0:i32 = var
%1:i32 = addnsw 1:i32, %0
infer %1

; *****
; For LLVM instruction:
;  %call = call i32 @irand(i32 %add)
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %cmp = icmp ne i32 %8, %call
; Looking for a replacement for:
%0:i32 = var
%1:i32 = var
%2:i1 = ne %0, %1
infer %2

; *****
; For LLVM instruction:
;  %10 = load i32, i32* %x1, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %11 = load i32, i32* %arrayidx4, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %12 = load i32, i32* %y1, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %13 = load i32, i32* %arrayidx5, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %14 = load i32, i32* %x1, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %15 = load i32, i32* %i, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %16 = load i32, i32* %y1, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %17 = load i32, i32* %x1, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %dec8 = add nsw i32 %17, -1
; Looking for a replacement for:
%0:i32 = var
%1:i32 = addnsw 4294967295:i32, %0
infer %1

; *****
; For LLVM instruction:
;  %18 = load i32, i32* @avail, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %tobool10 = icmp ne i32 %18, 0
; Looking for a replacement for:
%0:i32 = var
%1:i1 = ne 0:i32, %0
infer %1

; *****
; For LLVM instruction:
;  %19 = load i32, i32* %i, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %cmp11 = icmp slt i32 %19, 4
; Looking for a replacement for:
%0:i32 = var
%1:i1 = slt %0, 4:i32
infer %1

; *****
; For LLVM instruction:
;  %20 = phi i1 [ false, %for.cond9 ], [ %cmp11, %land.rhs ]
; Looking for a replacement for:
%0:i1 = var
infer %0

; *****
; For LLVM instruction:
;  %21 = load i32, i32* %x.addr, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %22 = load i32, i32* %i, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %23 = load i32, i32* %arrayidx14, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %24 = load i32, i32* %arrayidx16, align 8
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %add17 = add nsw i32 %21, %24
; Looking for a replacement for:
%0:i32 = var
%1:i32 = var
%2:i32 = addnsw %0, %1
infer %2

; *****
; For LLVM instruction:
;  %25 = load i32, i32* %y.addr, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %26 = load i32, i32* %i, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %27 = load i32, i32* %arrayidx18, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %28 = load i32, i32* %arrayidx20, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %add21 = add nsw i32 %25, %28
; Looking for a replacement for:
%0:i32 = var
%1:i32 = var
%2:i32 = addnsw %0, %1
infer %2

; *****
; For LLVM instruction:
;  %30 = load i32, i32* %y1, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %32 = load i32, i32* %x1, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %33 = load i8, i8* %arrayidx23, align 1
; Looking for a replacement for:
%0:i8 = var
infer %0 (demandedBits=00010000)

; *****
; For LLVM instruction:
;  %conv24 = zext i8 %33 to i32
; Looking for a replacement for:
%0:i8 = var
%1:i32 = zext %0
infer %1 (demandedBits=00000000000000000000000000010000)

; *****
; For LLVM instruction:
;  %and = and i32 %conv24, 16
; Looking for a replacement for:
%0:i8 = var
%1:i32 = zext %0
%2:i32 = and 16:i32, %1
infer %2

; *****
; For LLVM instruction:
;  %tobool25 = icmp ne i32 %and, 0
; Looking for a replacement for:
%0:i8 = var
%1:i32 = zext %0
%2:i32 = and 16:i32, %1
%3:i1 = ne 0:i32, %2
infer %3

; *****
; For LLVM instruction:
;  %34 = load i32, i32* %x1, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %35 = load i32, i32* %x.addr, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %cmp28 = icmp eq i32 %34, %35
; Looking for a replacement for:
%0:i32 = var
%1:i32 = var
%2:i1 = eq %0, %1
infer %2

; *****
; For LLVM instruction:
;  %36 = load i32, i32* %y.addr, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %37 = load i32, i32* %y1, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %add31 = add nsw i32 %36, %37
; Looking for a replacement for:
%0:i32 = var
%1:i32 = var
%2:i32 = addnsw %0, %1
infer %2

; *****
; For LLVM instruction:
;  %div = sdiv i32 %add31, 2
; Looking for a replacement for:
%0:i32 = var
%1:i32 = var
%2:i32 = addnsw %0, %1
%3:i32 = sdiv %2, 2:i32
infer %3

; *****
; For LLVM instruction:
;  %39 = load i32, i32* %t, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %41 = load i32, i32* %x.addr, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %add33 = add nsw i32 %41, 1
; Looking for a replacement for:
%0:i32 = var
%1:i32 = addnsw 1:i32, %0
infer %1

; *****
; For LLVM instruction:
;  %42 = load i8, i8* %arrayidx34, align 1
; Looking for a replacement for:
%0:i8 = var
infer %0 (demandedBits=11111011)

; *****
; For LLVM instruction:
;  %conv35 = zext i8 %42 to i32
; Looking for a replacement for:
%0:i8 = var
%1:i32 = zext %0
infer %1 (demandedBits=00000000000000000000000011111011)

; *****
; For LLVM instruction:
;  %and36 = and i32 %conv35, -5
; Looking for a replacement for:
%0:i8 = var
%1:i32 = zext %0
%2:i32 = and 4294967291:i32, %1
infer %2 (demandedBits=00000000000000000000000011111111)

; *****
; For LLVM instruction:
;  %conv37 = trunc i32 %and36 to i8
; Looking for a replacement for:
%0:i8 = var
%1:i32 = zext %0
%2:i32 = and 4294967291:i32, %1
%3:i8 = trunc %2
infer %3

; *****
; For LLVM instruction:
;  %44 = load i32, i32* %t, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %46 = load i32, i32* %x.addr, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %47 = load i8, i8* %arrayidx39, align 1
; Looking for a replacement for:
%0:i8 = var
infer %0 (demandedBits=11110011)

; *****
; For LLVM instruction:
;  %conv40 = zext i8 %47 to i32
; Looking for a replacement for:
%0:i8 = var
%1:i32 = zext %0
infer %1 (demandedBits=00000000000000000000000011110011)

; *****
; For LLVM instruction:
;  %and41 = and i32 %conv40, -13
; Looking for a replacement for:
%0:i8 = var
%1:i32 = zext %0
%2:i32 = and 4294967283:i32, %1
infer %2 (demandedBits=00000000000000000000000011111111)

; *****
; For LLVM instruction:
;  %conv42 = trunc i32 %and41 to i8
; Looking for a replacement for:
%0:i8 = var
%1:i32 = zext %0
%2:i32 = and 4294967283:i32, %1
%3:i8 = trunc %2
infer %3

; *****
; For LLVM instruction:
;  %49 = load i32, i32* %t, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %51 = load i32, i32* %x.addr, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %sub = sub nsw i32 %51, 1
; Looking for a replacement for:
%0:i32 = var
%1:i32 = subnsw %0, 1:i32
infer %1

; *****
; For LLVM instruction:
;  %52 = load i8, i8* %arrayidx44, align 1
; Looking for a replacement for:
%0:i8 = var
infer %0 (demandedBits=11110111)

; *****
; For LLVM instruction:
;  %conv45 = zext i8 %52 to i32
; Looking for a replacement for:
%0:i8 = var
%1:i32 = zext %0
infer %1 (demandedBits=00000000000000000000000011110111)

; *****
; For LLVM instruction:
;  %and46 = and i32 %conv45, -9
; Looking for a replacement for:
%0:i8 = var
%1:i32 = zext %0
%2:i32 = and 4294967287:i32, %1
infer %2 (demandedBits=00000000000000000000000011111111)

; *****
; For LLVM instruction:
;  %conv47 = trunc i32 %and46 to i8
; Looking for a replacement for:
%0:i8 = var
%1:i32 = zext %0
%2:i32 = and 4294967287:i32, %1
%3:i8 = trunc %2
infer %3

; *****
; For LLVM instruction:
;  %53 = load i32, i32* %y1, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %54 = load i32, i32* %y.addr, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %cmp48 = icmp eq i32 %53, %54
; Looking for a replacement for:
%0:i32 = var
%1:i32 = var
%2:i1 = eq %0, %1
infer %2

; *****
; For LLVM instruction:
;  %55 = load i32, i32* %x.addr, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %56 = load i32, i32* %x1, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %add51 = add nsw i32 %55, %56
; Looking for a replacement for:
%0:i32 = var
%1:i32 = var
%2:i32 = addnsw %0, %1
infer %2

; *****
; For LLVM instruction:
;  %div52 = sdiv i32 %add51, 2
; Looking for a replacement for:
%0:i32 = var
%1:i32 = var
%2:i32 = addnsw %0, %1
%3:i32 = sdiv %2, 2:i32
infer %3

; *****
; For LLVM instruction:
;  %58 = load i32, i32* %y.addr, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %sub53 = sub nsw i32 %58, 1
; Looking for a replacement for:
%0:i32 = var
%1:i32 = subnsw %0, 1:i32
infer %1

; *****
; For LLVM instruction:
;  %60 = load i32, i32* %t, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %61 = load i8, i8* %arrayidx55, align 1
; Looking for a replacement for:
%0:i8 = var
infer %0 (demandedBits=11111101)

; *****
; For LLVM instruction:
;  %conv56 = zext i8 %61 to i32
; Looking for a replacement for:
%0:i8 = var
%1:i32 = zext %0
infer %1 (demandedBits=00000000000000000000000011111101)

; *****
; For LLVM instruction:
;  %and57 = and i32 %conv56, -3
; Looking for a replacement for:
%0:i8 = var
%1:i32 = zext %0
%2:i32 = and 4294967293:i32, %1
infer %2 (demandedBits=00000000000000000000000011111111)

; *****
; For LLVM instruction:
;  %conv58 = trunc i32 %and57 to i8
; Looking for a replacement for:
%0:i8 = var
%1:i32 = zext %0
%2:i32 = and 4294967293:i32, %1
%3:i8 = trunc %2
infer %3

; *****
; For LLVM instruction:
;  %63 = load i32, i32* %y.addr, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %65 = load i32, i32* %t, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %66 = load i8, i8* %arrayidx60, align 1
; Looking for a replacement for:
%0:i8 = var
infer %0 (demandedBits=11111100)

; *****
; For LLVM instruction:
;  %conv61 = zext i8 %66 to i32
; Looking for a replacement for:
%0:i8 = var
%1:i32 = zext %0
infer %1 (demandedBits=00000000000000000000000011111100)

; *****
; For LLVM instruction:
;  %and62 = and i32 %conv61, -4
; Looking for a replacement for:
%0:i8 = var
%1:i32 = zext %0
%2:i32 = and 4294967292:i32, %1
infer %2 (demandedBits=00000000000000000000000011111111)

; *****
; For LLVM instruction:
;  %conv63 = trunc i32 %and62 to i8
; Looking for a replacement for:
%0:i8 = var
%1:i32 = zext %0
%2:i32 = and 4294967292:i32, %1
%3:i8 = trunc %2
infer %3

; *****
; For LLVM instruction:
;  %68 = load i32, i32* %y.addr, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %add64 = add nsw i32 %68, 1
; Looking for a replacement for:
%0:i32 = var
%1:i32 = addnsw 1:i32, %0
infer %1

; *****
; For LLVM instruction:
;  %70 = load i32, i32* %t, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %71 = load i8, i8* %arrayidx66, align 1
; Looking for a replacement for:
%0:i8 = var
infer %0 (demandedBits=11111110)

; *****
; For LLVM instruction:
;  %conv67 = zext i8 %71 to i32
; Looking for a replacement for:
%0:i8 = var
%1:i32 = zext %0
infer %1 (demandedBits=00000000000000000000000011111110)

; *****
; For LLVM instruction:
;  %and68 = and i32 %conv67, -2
; Looking for a replacement for:
%0:i8 = var
%1:i32 = zext %0
%2:i32 = and 4294967294:i32, %1
infer %2 (demandedBits=00000000000000000000000011111111)

; *****
; For LLVM instruction:
;  %conv69 = trunc i32 %and68 to i8
; Looking for a replacement for:
%0:i8 = var
%1:i32 = zext %0
%2:i32 = and 4294967294:i32, %1
%3:i8 = trunc %2
infer %3

; *****
; For LLVM instruction:
;  %72 = load i32, i32* %x1, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %73 = load i32, i32* %y1, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %74 = load i32, i32* %i, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %inc = add nsw i32 %74, 1
; Looking for a replacement for:
%0:i32 = var
%1:i32 = addnsw 1:i32, %0
infer %1
got 1 candidates from LHS

-------------------------------------------------
%0:i8 = var
infer %0 (demandedBits=11101111)


--------------------------------
guess 0

%0:i8 = var ; reservedconst_1

Cost = 0
ConstantSynthesis: solver returns error on first query
Dataflow Pruned 0/0
There are 1 Guesses
There are 0 RHSs before deduplication
There are 0 RHSs after deduplication
got 2 candidates from LHS

-------------------------------------------------
%0:i8 = var
%1:i32 = zext %0
infer %1 (demandedBits=00000000000000000000000011101111)


--------------------------------
guess 0

%0:i32 = var ; reservedconst_1

Cost = 0
first query is SAT, returning the model:
reservedconst_1: 0
0 th attempt: second query is SAT-- constant doesn't work
first query is SAT, returning the model:
reservedconst_1: 207
1 th attempt: second query is SAT-- constant doesn't work
first query is UNSAT-- no more guesses
Dataflow Pruned 0/0
There are 1 Guesses
There are 0 RHSs before deduplication
There are 0 RHSs after deduplication
got 3 candidates from LHS

-------------------------------------------------
%0:i8 = var
%1:i32 = zext %0
%2:i32 = or 16:i32, %1
infer %2 (demandedBits=00000000000000000000000011111111)


--------------------------------
guess 0

%0:i32 = var ; reservedconst_1

Cost = 0
first query is SAT, returning the model:
reservedconst_1: 16
0 th attempt: second query is SAT-- constant doesn't work
first query is SAT, returning the model:
reservedconst_1: 223
1 th attempt: second query is SAT-- constant doesn't work
first query is UNSAT-- no more guesses

--------------------------------
guess 1

%0:i8 = var
%1:i32 = zext %0

Cost = 1
second query is SAT-- constant doesn't work
Dataflow Pruned 0/0
There are 2 Guesses
There are 0 RHSs before deduplication
There are 0 RHSs after deduplication
got 4 candidates from LHS

-------------------------------------------------
%0:i8 = var
%1:i32 = zext %0
%2:i32 = or 16:i32, %1
%3:i8 = trunc %2
infer %3


--------------------------------
guess 0

%0:i8 = var ; reservedconst_1

Cost = 0
first query is SAT, returning the model:
reservedconst_1: 16
0 th attempt: second query is SAT-- constant doesn't work
first query is SAT, returning the model:
reservedconst_1: -3
1 th attempt: second query is SAT-- constant doesn't work
first query is UNSAT-- no more guesses

--------------------------------
guess 1

%0:i8 = var

Cost = 0
second query is SAT-- constant doesn't work
Dataflow Pruned 0/0
There are 2 Guesses
There are 0 RHSs before deduplication
There are 0 RHSs after deduplication
got 2 candidates from LHS

-------------------------------------------------
%0:i32 = var
%1:i32 = addnsw 4294967295:i32, %0
infer %1


--------------------------------
guess 0

%0:i32 = var ; reservedconst_1

Cost = 0
first query is SAT, returning the model:
reservedconst_1: -1
0 th attempt: second query is SAT-- constant doesn't work
first query is SAT, returning the model:
reservedconst_1: 536870911
1 th attempt: second query is SAT-- constant doesn't work
first query is UNSAT-- no more guesses

--------------------------------
guess 1

%0:i32 = var

Cost = 0
second query is SAT-- constant doesn't work
Dataflow Pruned 0/0
There are 2 Guesses
There are 0 RHSs before deduplication
There are 0 RHSs after deduplication
got 2 candidates from LHS

-------------------------------------------------
%0:i32 = var
%1:i1 = ne 0:i32, %0
infer %1


--------------------------------
guess 0

%0:i1 = var ; reservedconst_1

Cost = 0
first query is SAT, returning the model:
reservedconst_1: 0
0 th attempt: second query is SAT-- constant doesn't work
first query is SAT, returning the model:
reservedconst_1: -1
1 th attempt: second query is SAT-- constant doesn't work
first query is UNSAT-- no more guesses
Dataflow Pruned 0/0
There are 1 Guesses
There are 0 RHSs before deduplication
There are 0 RHSs after deduplication
got 3 candidates from LHS

-------------------------------------------------
%0:i32 = var
%1:i32 = var
%2:i1 = ne %0, %1
infer %2


--------------------------------
guess 0

%0:i1 = var ; reservedconst_1

Cost = 0
first query is SAT, returning the model:
reservedconst_1: 0
0 th attempt: second query is SAT-- constant doesn't work
first query is SAT, returning the model:
reservedconst_1: -1
1 th attempt: second query is SAT-- constant doesn't work
first query is UNSAT-- no more guesses
Dataflow Pruned 0/0
There are 1 Guesses
There are 0 RHSs before deduplication
There are 0 RHSs after deduplication
got 2 candidates from LHS

-------------------------------------------------
%0:i32 = var
%1:i1 = slt %0, 4:i32
infer %1


--------------------------------
guess 0

%0:i1 = var ; reservedconst_1

Cost = 0
first query is SAT, returning the model:
reservedconst_1: -1
0 th attempt: second query is SAT-- constant doesn't work
first query is SAT, returning the model:
reservedconst_1: 0
1 th attempt: second query is SAT-- constant doesn't work
first query is UNSAT-- no more guesses
Dataflow Pruned 0/0
There are 1 Guesses
There are 0 RHSs before deduplication
There are 0 RHSs after deduplication
got 1 candidates from LHS

-------------------------------------------------
%0:i1 = var
infer %0


--------------------------------
guess 0

%0:i1 = var ; reservedconst_1

Cost = 0
first query is SAT, returning the model:
reservedconst_1: 0
0 th attempt: second query is SAT-- constant doesn't work
first query is SAT, returning the model:
reservedconst_1: -1
1 th attempt: second query is SAT-- constant doesn't work
first query is UNSAT-- no more guesses
Dataflow Pruned 0/0
There are 1 Guesses
There are 0 RHSs before deduplication
There are 0 RHSs after deduplication
got 3 candidates from LHS

-------------------------------------------------
%0:i32 = var
%1:i32 = var
%2:i32 = addnsw %0, %1
infer %2


--------------------------------
guess 0

%0:i32 = var ; reservedconst_1

Cost = 0
first query is SAT, returning the model:
reservedconst_1: 0
0 th attempt: second query is SAT-- constant doesn't work
first query is SAT, returning the model:
reservedconst_1: -2
1 th attempt: second query is SAT-- constant doesn't work
first query is UNSAT-- no more guesses

--------------------------------
guess 1

%0:i32 = var

Cost = 0
second query is SAT-- constant doesn't work

--------------------------------
guess 2

%0:i32 = var

Cost = 0
second query is SAT-- constant doesn't work
Dataflow Pruned 0/0
There are 3 Guesses
There are 0 RHSs before deduplication
There are 0 RHSs after deduplication
got 1 candidates from LHS

-------------------------------------------------
%0:i8 = var
infer %0 (demandedBits=00010000)


--------------------------------
guess 0

%0:i8 = var ; reservedconst_1

Cost = 0
first query is SAT, returning the model:
reservedconst_1: 0
0 th attempt: second query is SAT-- constant doesn't work
first query is SAT, returning the model:
reservedconst_1: 16
1 th attempt: second query is SAT-- constant doesn't work
first query is UNSAT-- no more guesses
Dataflow Pruned 0/0
There are 1 Guesses
There are 0 RHSs before deduplication
There are 0 RHSs after deduplication
got 2 candidates from LHS

-------------------------------------------------
%0:i8 = var
%1:i32 = zext %0
infer %1 (demandedBits=00000000000000000000000000010000)


--------------------------------
guess 0

%0:i32 = var ; reservedconst_1

Cost = 0
first query is SAT, returning the model:
reservedconst_1: 0
0 th attempt: second query is SAT-- constant doesn't work
first query is SAT, returning the model:
reservedconst_1: 16
1 th attempt: second query is SAT-- constant doesn't work
first query is UNSAT-- no more guesses
Dataflow Pruned 0/0
There are 1 Guesses
There are 0 RHSs before deduplication
There are 0 RHSs after deduplication
got 3 candidates from LHS

-------------------------------------------------
%0:i8 = var
%1:i32 = zext %0
%2:i32 = and 16:i32, %1
infer %2


--------------------------------
guess 0

%0:i32 = var ; reservedconst_1

Cost = 0
first query is SAT, returning the model:
reservedconst_1: 0
0 th attempt: second query is SAT-- constant doesn't work
first query is SAT, returning the model:
reservedconst_1: 16
1 th attempt: second query is SAT-- constant doesn't work
first query is UNSAT-- no more guesses

--------------------------------
guess 1

%0:i8 = var
%1:i32 = zext %0

Cost = 1
second query is SAT-- constant doesn't work
Dataflow Pruned 0/0
There are 2 Guesses
There are 0 RHSs before deduplication
There are 0 RHSs after deduplication
got 4 candidates from LHS

-------------------------------------------------
%0:i8 = var
%1:i32 = zext %0
%2:i32 = and 16:i32, %1
%3:i1 = ne 0:i32, %2
infer %3


--------------------------------
guess 0

%0:i1 = var ; reservedconst_1

Cost = 0
first query is SAT, returning the model:
reservedconst_1: 0
0 th attempt: second query is SAT-- constant doesn't work
first query is SAT, returning the model:
reservedconst_1: -1
1 th attempt: second query is SAT-- constant doesn't work
first query is UNSAT-- no more guesses
Dataflow Pruned 0/0
There are 1 Guesses
There are 0 RHSs before deduplication
There are 0 RHSs after deduplication
got 3 candidates from LHS

-------------------------------------------------
%0:i32 = var
%1:i32 = var
%2:i1 = eq %0, %1
infer %2


--------------------------------
guess 0

%0:i1 = var ; reservedconst_1

Cost = 0
first query is SAT, returning the model:
reservedconst_1: -1
0 th attempt: second query is SAT-- constant doesn't work
first query is SAT, returning the model:
reservedconst_1: 0
1 th attempt: second query is SAT-- constant doesn't work
first query is UNSAT-- no more guesses
Dataflow Pruned 0/0
There are 1 Guesses
There are 0 RHSs before deduplication
There are 0 RHSs after deduplication
got 4 candidates from LHS

-------------------------------------------------
%0:i32 = var
%1:i32 = var
%2:i32 = addnsw %0, %1
%3:i32 = sdiv %2, 2:i32
infer %3


--------------------------------
guess 0

%0:i32 = var ; reservedconst_1

Cost = 0
first query is SAT, returning the model:
reservedconst_1: 0
0 th attempt: second query is SAT-- constant doesn't work
first query is SAT, returning the model:
reservedconst_1: -1073741824
1 th attempt: second query is SAT-- constant doesn't work
first query is UNSAT-- no more guesses

--------------------------------
guess 1

%0:i32 = var

Cost = 0
second query is SAT-- constant doesn't work

--------------------------------
guess 2

%0:i32 = var

Cost = 0
second query is SAT-- constant doesn't work

--------------------------------
guess 3

%0:i32 = var
%1:i32 = var
%2:i32 = addnsw %0, %1

Cost = 1
second query is SAT-- constant doesn't work
Dataflow Pruned 0/0
There are 4 Guesses
There are 0 RHSs before deduplication
There are 0 RHSs after deduplication
got 1 candidates from LHS

-------------------------------------------------
%0:i8 = var
infer %0 (demandedBits=11111011)


--------------------------------
guess 0

%0:i8 = var ; reservedconst_1

Cost = 0
first query is SAT, returning the model:
reservedconst_1: 0
0 th attempt: second query is SAT-- constant doesn't work
first query is SAT, returning the model:
reservedconst_1: -37
1 th attempt: second query is SAT-- constant doesn't work
first query is UNSAT-- no more guesses
Dataflow Pruned 0/0
There are 1 Guesses
There are 0 RHSs before deduplication
There are 0 RHSs after deduplication
got 2 candidates from LHS

-------------------------------------------------
%0:i8 = var
%1:i32 = zext %0
infer %1 (demandedBits=00000000000000000000000011111011)


--------------------------------
guess 0

%0:i32 = var ; reservedconst_1

Cost = 0
first query is SAT, returning the model:
reservedconst_1: 0
0 th attempt: second query is SAT-- constant doesn't work
first query is SAT, returning the model:
reservedconst_1: 219
1 th attempt: second query is SAT-- constant doesn't work
first query is UNSAT-- no more guesses
Dataflow Pruned 0/0
There are 1 Guesses
There are 0 RHSs before deduplication
There are 0 RHSs after deduplication
got 3 candidates from LHS

-------------------------------------------------
%0:i8 = var
%1:i32 = zext %0
%2:i32 = and 4294967291:i32, %1
infer %2 (demandedBits=00000000000000000000000011111111)


--------------------------------
guess 0

%0:i32 = var ; reservedconst_1

Cost = 0
first query is SAT, returning the model:
reservedconst_1: 0
0 th attempt: second query is SAT-- constant doesn't work
first query is SAT, returning the model:
reservedconst_1: 219
1 th attempt: second query is SAT-- constant doesn't work
first query is UNSAT-- no more guesses

--------------------------------
guess 1

%0:i8 = var
%1:i32 = zext %0

Cost = 1
second query is SAT-- constant doesn't work
Dataflow Pruned 0/0
There are 2 Guesses
There are 0 RHSs before deduplication
There are 0 RHSs after deduplication
got 4 candidates from LHS

-------------------------------------------------
%0:i8 = var
%1:i32 = zext %0
%2:i32 = and 4294967291:i32, %1
%3:i8 = trunc %2
infer %3


--------------------------------
guess 0

%0:i8 = var ; reservedconst_1

Cost = 0
first query is SAT, returning the model:
reservedconst_1: 0
0 th attempt: second query is SAT-- constant doesn't work
first query is SAT, returning the model:
reservedconst_1: -37
1 th attempt: second query is SAT-- constant doesn't work
first query is UNSAT-- no more guesses

--------------------------------
guess 1

%0:i8 = var

Cost = 0
second query is SAT-- constant doesn't work
Dataflow Pruned 0/0
There are 2 Guesses
There are 0 RHSs before deduplication
There are 0 RHSs after deduplication
got 1 candidates from LHS

-------------------------------------------------
%0:i8 = var
infer %0 (demandedBits=11110011)


--------------------------------
guess 0

%0:i8 = var ; reservedconst_1

Cost = 0
first query is SAT, returning the model:
reservedconst_1: 0
0 th attempt: second query is SAT-- constant doesn't work
first query is SAT, returning the model:
reservedconst_1: -13
1 th attempt: second query is SAT-- constant doesn't work
first query is UNSAT-- no more guesses
Dataflow Pruned 0/0
There are 1 Guesses
There are 0 RHSs before deduplication
There are 0 RHSs after deduplication
got 2 candidates from LHS

-------------------------------------------------
%0:i8 = var
%1:i32 = zext %0
infer %1 (demandedBits=00000000000000000000000011110011)


--------------------------------
guess 0

%0:i32 = var ; reservedconst_1

Cost = 0
first query is SAT, returning the model:
reservedconst_1: 0
0 th attempt: second query is SAT-- constant doesn't work
first query is SAT, returning the model:
reservedconst_1: 243
1 th attempt: second query is SAT-- constant doesn't work
first query is UNSAT-- no more guesses
Dataflow Pruned 0/0
There are 1 Guesses
There are 0 RHSs before deduplication
There are 0 RHSs after deduplication
got 3 candidates from LHS

-------------------------------------------------
%0:i8 = var
%1:i32 = zext %0
%2:i32 = and 4294967283:i32, %1
infer %2 (demandedBits=00000000000000000000000011111111)


--------------------------------
guess 0

%0:i32 = var ; reservedconst_1

Cost = 0
first query is SAT, returning the model:
reservedconst_1: 0
0 th attempt: second query is SAT-- constant doesn't work
first query is SAT, returning the model:
reservedconst_1: 243
1 th attempt: second query is SAT-- constant doesn't work
first query is UNSAT-- no more guesses

--------------------------------
guess 1

%0:i8 = var
%1:i32 = zext %0

Cost = 1
second query is SAT-- constant doesn't work
Dataflow Pruned 0/0
There are 2 Guesses
There are 0 RHSs before deduplication
There are 0 RHSs after deduplication
got 4 candidates from LHS

-------------------------------------------------
%0:i8 = var
%1:i32 = zext %0
%2:i32 = and 4294967283:i32, %1
%3:i8 = trunc %2
infer %3


--------------------------------
guess 0

%0:i8 = var ; reservedconst_1

Cost = 0
first query is SAT, returning the model:
reservedconst_1: 0
0 th attempt: second query is SAT-- constant doesn't work
first query is SAT, returning the model:
reservedconst_1: -13
1 th attempt: second query is SAT-- constant doesn't work
first query is UNSAT-- no more guesses

--------------------------------
guess 1

%0:i8 = var

Cost = 0
second query is SAT-- constant doesn't work
Dataflow Pruned 0/0
There are 2 Guesses
There are 0 RHSs before deduplication
There are 0 RHSs after deduplication
got 2 candidates from LHS

-------------------------------------------------
%0:i32 = var
%1:i32 = subnsw %0, 1:i32
infer %1


--------------------------------
guess 0

%0:i32 = var ; reservedconst_1

Cost = 0
first query is SAT, returning the model:
reservedconst_1: -1
0 th attempt: second query is SAT-- constant doesn't work
first query is SAT, returning the model:
reservedconst_1: 536870911
1 th attempt: second query is SAT-- constant doesn't work
first query is UNSAT-- no more guesses

--------------------------------
guess 1

%0:i32 = var

Cost = 0
second query is SAT-- constant doesn't work
Dataflow Pruned 0/0
There are 2 Guesses
There are 0 RHSs before deduplication
There are 0 RHSs after deduplication
got 1 candidates from LHS

-------------------------------------------------
%0:i8 = var
infer %0 (demandedBits=11110111)


--------------------------------
guess 0

%0:i8 = var ; reservedconst_1

Cost = 0
first query is SAT, returning the model:
reservedconst_1: 0
0 th attempt: second query is SAT-- constant doesn't work
first query is SAT, returning the model:
reservedconst_1: -41
1 th attempt: second query is SAT-- constant doesn't work
first query is UNSAT-- no more guesses
Dataflow Pruned 0/0
There are 1 Guesses
There are 0 RHSs before deduplication
There are 0 RHSs after deduplication
got 2 candidates from LHS

-------------------------------------------------
%0:i8 = var
%1:i32 = zext %0
infer %1 (demandedBits=00000000000000000000000011110111)


--------------------------------
guess 0

%0:i32 = var ; reservedconst_1

Cost = 0
first query is SAT, returning the model:
reservedconst_1: 0
0 th attempt: second query is SAT-- constant doesn't work
first query is SAT, returning the model:
reservedconst_1: 215
1 th attempt: second query is SAT-- constant doesn't work
first query is UNSAT-- no more guesses
Dataflow Pruned 0/0
There are 1 Guesses
There are 0 RHSs before deduplication
There are 0 RHSs after deduplication
got 3 candidates from LHS

-------------------------------------------------
%0:i8 = var
%1:i32 = zext %0
%2:i32 = and 4294967287:i32, %1
infer %2 (demandedBits=00000000000000000000000011111111)


--------------------------------
guess 0

%0:i32 = var ; reservedconst_1

Cost = 0
first query is SAT, returning the model:
reservedconst_1: 0
0 th attempt: second query is SAT-- constant doesn't work
first query is SAT, returning the model:
reservedconst_1: 215
1 th attempt: second query is SAT-- constant doesn't work
first query is UNSAT-- no more guesses

--------------------------------
guess 1

%0:i8 = var
%1:i32 = zext %0

Cost = 1
second query is SAT-- constant doesn't work
Dataflow Pruned 0/0
There are 2 Guesses
There are 0 RHSs before deduplication
There are 0 RHSs after deduplication
got 4 candidates from LHS

-------------------------------------------------
%0:i8 = var
%1:i32 = zext %0
%2:i32 = and 4294967287:i32, %1
%3:i8 = trunc %2
infer %3


--------------------------------
guess 0

%0:i8 = var ; reservedconst_1

Cost = 0
first query is SAT, returning the model:
reservedconst_1: 0
0 th attempt: second query is SAT-- constant doesn't work
first query is SAT, returning the model:
reservedconst_1: -41
1 th attempt: second query is SAT-- constant doesn't work
first query is UNSAT-- no more guesses

--------------------------------
guess 1

%0:i8 = var

Cost = 0
second query is SAT-- constant doesn't work
Dataflow Pruned 0/0
There are 2 Guesses
There are 0 RHSs before deduplication
There are 0 RHSs after deduplication
got 1 candidates from LHS

-------------------------------------------------
%0:i8 = var
infer %0 (demandedBits=11111101)


--------------------------------
guess 0

%0:i8 = var ; reservedconst_1

Cost = 0
first query is SAT, returning the model:
reservedconst_1: 0
0 th attempt: second query is SAT-- constant doesn't work
first query is SAT, returning the model:
reservedconst_1: -35
1 th attempt: second query is SAT-- constant doesn't work
first query is UNSAT-- no more guesses
Dataflow Pruned 0/0
There are 1 Guesses
There are 0 RHSs before deduplication
There are 0 RHSs after deduplication
got 2 candidates from LHS

-------------------------------------------------
%0:i8 = var
%1:i32 = zext %0
infer %1 (demandedBits=00000000000000000000000011111101)


--------------------------------
guess 0

%0:i32 = var ; reservedconst_1

Cost = 0
first query is SAT, returning the model:
reservedconst_1: 0
0 th attempt: second query is SAT-- constant doesn't work
first query is SAT, returning the model:
reservedconst_1: 221
1 th attempt: second query is SAT-- constant doesn't work
first query is UNSAT-- no more guesses
Dataflow Pruned 0/0
There are 1 Guesses
There are 0 RHSs before deduplication
There are 0 RHSs after deduplication
got 3 candidates from LHS

-------------------------------------------------
%0:i8 = var
%1:i32 = zext %0
%2:i32 = and 4294967293:i32, %1
infer %2 (demandedBits=00000000000000000000000011111111)


--------------------------------
guess 0

%0:i32 = var ; reservedconst_1

Cost = 0
first query is SAT, returning the model:
reservedconst_1: 0
0 th attempt: second query is SAT-- constant doesn't work
first query is SAT, returning the model:
reservedconst_1: 221
1 th attempt: second query is SAT-- constant doesn't work
first query is UNSAT-- no more guesses

--------------------------------
guess 1

%0:i8 = var
%1:i32 = zext %0

Cost = 1
second query is SAT-- constant doesn't work
Dataflow Pruned 0/0
There are 2 Guesses
There are 0 RHSs before deduplication
There are 0 RHSs after deduplication
got 4 candidates from LHS

-------------------------------------------------
%0:i8 = var
%1:i32 = zext %0
%2:i32 = and 4294967293:i32, %1
%3:i8 = trunc %2
infer %3


--------------------------------
guess 0

%0:i8 = var ; reservedconst_1

Cost = 0
first query is SAT, returning the model:
reservedconst_1: 0
0 th attempt: second query is SAT-- constant doesn't work
first query is SAT, returning the model:
reservedconst_1: -35
1 th attempt: second query is SAT-- constant doesn't work
first query is UNSAT-- no more guesses

--------------------------------
guess 1

%0:i8 = var

Cost = 0
second query is SAT-- constant doesn't work
Dataflow Pruned 0/0
There are 2 Guesses
There are 0 RHSs before deduplication
There are 0 RHSs after deduplication
got 1 candidates from LHS

-------------------------------------------------
%0:i8 = var
infer %0 (demandedBits=11111100)


--------------------------------
guess 0

%0:i8 = var ; reservedconst_1

Cost = 0
first query is SAT, returning the model:
reservedconst_1: 0
0 th attempt: second query is SAT-- constant doesn't work
first query is SAT, returning the model:
reservedconst_1: -4
1 th attempt: second query is SAT-- constant doesn't work
first query is UNSAT-- no more guesses
Dataflow Pruned 0/0
There are 1 Guesses
There are 0 RHSs before deduplication
There are 0 RHSs after deduplication
got 2 candidates from LHS

-------------------------------------------------
%0:i8 = var
%1:i32 = zext %0
infer %1 (demandedBits=00000000000000000000000011111100)


--------------------------------
guess 0

%0:i32 = var ; reservedconst_1

Cost = 0
first query is SAT, returning the model:
reservedconst_1: 0
0 th attempt: second query is SAT-- constant doesn't work
first query is SAT, returning the model:
reservedconst_1: 252
1 th attempt: second query is SAT-- constant doesn't work
first query is UNSAT-- no more guesses
Dataflow Pruned 0/0
There are 1 Guesses
There are 0 RHSs before deduplication
There are 0 RHSs after deduplication
got 3 candidates from LHS

-------------------------------------------------
%0:i8 = var
%1:i32 = zext %0
%2:i32 = and 4294967292:i32, %1
infer %2 (demandedBits=00000000000000000000000011111111)


--------------------------------
guess 0

%0:i32 = var ; reservedconst_1

Cost = 0
first query is SAT, returning the model:
reservedconst_1: 0
0 th attempt: second query is SAT-- constant doesn't work
first query is SAT, returning the model:
reservedconst_1: 252
1 th attempt: second query is SAT-- constant doesn't work
first query is UNSAT-- no more guesses

--------------------------------
guess 1

%0:i8 = var
%1:i32 = zext %0

Cost = 1
second query is SAT-- constant doesn't work
Dataflow Pruned 0/0
There are 2 Guesses
There are 0 RHSs before deduplication
There are 0 RHSs after deduplication
got 4 candidates from LHS

-------------------------------------------------
%0:i8 = var
%1:i32 = zext %0
%2:i32 = and 4294967292:i32, %1
%3:i8 = trunc %2
infer %3


--------------------------------
guess 0

%0:i8 = var ; reservedconst_1

Cost = 0
first query is SAT, returning the model:
reservedconst_1: 0
0 th attempt: second query is SAT-- constant doesn't work
first query is SAT, returning the model:
reservedconst_1: -4
1 th attempt: second query is SAT-- constant doesn't work
first query is UNSAT-- no more guesses

--------------------------------
guess 1

%0:i8 = var

Cost = 0
second query is SAT-- constant doesn't work
Dataflow Pruned 0/0
There are 2 Guesses
There are 0 RHSs before deduplication
There are 0 RHSs after deduplication
got 1 candidates from LHS

-------------------------------------------------
%0:i8 = var
infer %0 (demandedBits=11111110)


--------------------------------
guess 0

%0:i8 = var ; reservedconst_1

Cost = 0
first query is SAT, returning the model:
reservedconst_1: 0
0 th attempt: second query is SAT-- constant doesn't work
first query is SAT, returning the model:
reservedconst_1: -2
1 th attempt: second query is SAT-- constant doesn't work
first query is UNSAT-- no more guesses
Dataflow Pruned 0/0
There are 1 Guesses
There are 0 RHSs before deduplication
There are 0 RHSs after deduplication
got 2 candidates from LHS

-------------------------------------------------
%0:i8 = var
%1:i32 = zext %0
infer %1 (demandedBits=00000000000000000000000011111110)


--------------------------------
guess 0

%0:i32 = var ; reservedconst_1

Cost = 0
first query is SAT, returning the model:
reservedconst_1: 0
0 th attempt: second query is SAT-- constant doesn't work
first query is SAT, returning the model:
reservedconst_1: 254
1 th attempt: second query is SAT-- constant doesn't work
first query is UNSAT-- no more guesses
Dataflow Pruned 0/0
There are 1 Guesses
There are 0 RHSs before deduplication
There are 0 RHSs after deduplication
got 3 candidates from LHS

-------------------------------------------------
%0:i8 = var
%1:i32 = zext %0
%2:i32 = and 4294967294:i32, %1
infer %2 (demandedBits=00000000000000000000000011111111)


--------------------------------
guess 0

%0:i32 = var ; reservedconst_1

Cost = 0
first query is SAT, returning the model:
reservedconst_1: 0
0 th attempt: second query is SAT-- constant doesn't work
first query is SAT, returning the model:
reservedconst_1: 254
1 th attempt: second query is SAT-- constant doesn't work
first query is UNSAT-- no more guesses

--------------------------------
guess 1

%0:i8 = var
%1:i32 = zext %0

Cost = 1
second query is SAT-- constant doesn't work
Dataflow Pruned 0/0
There are 2 Guesses
There are 0 RHSs before deduplication
There are 0 RHSs after deduplication
got 4 candidates from LHS

-------------------------------------------------
%0:i8 = var
%1:i32 = zext %0
%2:i32 = and 4294967294:i32, %1
%3:i8 = trunc %2
infer %3


--------------------------------
guess 0

%0:i8 = var ; reservedconst_1

Cost = 0
first query is SAT, returning the model:
reservedconst_1: 0
0 th attempt: second query is SAT-- constant doesn't work
first query is SAT, returning the model:
reservedconst_1: -2
1 th attempt: second query is SAT-- constant doesn't work
first query is UNSAT-- no more guesses

--------------------------------
guess 1

%0:i8 = var

Cost = 0
second query is SAT-- constant doesn't work
Dataflow Pruned 0/0
There are 2 Guesses
There are 0 RHSs before deduplication
There are 0 RHSs after deduplication
#########################################################
; exiting Souper's runOnFunction() for walk()

; entering Souper's runOnFunction() for solve()

; ModuleID = './Maze_generation.c.bc'
source_filename = "./Maze_generation.c"
target datalayout = "e-m:e-p:32:32-i64:64-n32:64-S128"
target triple = "wasm32-unknown-wasi"

@glyph = hidden global [30 x i32] [i32 12288, i32 9474, i32 9474, i32 9474, i32 9472, i32 9496, i32 9488, i32 9508, i32 9472, i32 9492, i32 9484, i32 9500, i32 9472, i32 9524, i32 9516, i32 9532, i32 12288, i32 9478, i32 9478, i32 9478, i32 9476, i32 9583, i32 9582, i32 32, i32 9476, i32 9584, i32 9581, i32 32, i32 9476, i32 0], align 16
@h = hidden global i32 0, align 4
@w = hidden global i32 0, align 4
@cell = hidden global i8** null, align 4
@.str = private unnamed_addr constant [6 x i8] c"\1B[31m\00", align 1
@.str.1 = private unnamed_addr constant [4 x i8] c"%lc\00", align 1
@.str.2 = private unnamed_addr constant [4 x i8] c"\1B[m\00", align 1
@__const.walk.d = private unnamed_addr constant [4 x i32] [i32 0, i32 1, i32 2, i32 3], align 16
@avail = hidden global i32 0, align 4
@dirs = internal global [4 x [2 x i32]] [[2 x i32] [i32 -2, i32 0], [2 x i32] [i32 0, i32 2], [2 x i32] [i32 2, i32 0], [2 x i32] [i32 0, i32 -2]], align 16
@.str.3 = private unnamed_addr constant [1 x i8] zeroinitializer, align 1

; Function Attrs: noinline nounwind optnone
define hidden i32 @irand(i32 %n) #0 {
entry:
  %n.addr = alloca i32, align 4
  %r = alloca i32, align 4
  %rmax = alloca i32, align 4
  store i32 %n, i32* %n.addr, align 4
  %0 = load i32, i32* %n.addr, align 4
  %1 = load i32, i32* %n.addr, align 4
  %div = sdiv i32 2147483647, %1
  %mul = mul nsw i32 %0, %div
  store i32 %mul, i32* %rmax, align 4
  br label %while.cond

while.cond:                                       ; preds = %while.body, %entry
  %call = call i32 @rand()
  store i32 %call, i32* %r, align 4
  %2 = load i32, i32* %rmax, align 4
  %cmp = icmp sge i32 %call, %2
  br i1 %cmp, label %while.body, label %while.end

while.body:                                       ; preds = %while.cond
  br label %while.cond

while.end:                                        ; preds = %while.cond
  %3 = load i32, i32* %r, align 4
  %4 = load i32, i32* %n.addr, align 4
  %div1 = sdiv i32 2147483647, %4
  %div2 = sdiv i32 %3, %div1
  ret i32 %div2
}

declare i32 @rand() #1

; Function Attrs: noinline nounwind optnone
define hidden void @show() #0 {
entry:
  %i = alloca i32, align 4
  %j = alloca i32, align 4
  %c = alloca i32, align 4
  store i32 0, i32* %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc16, %entry
  %0 = load i32, i32* %i, align 4
  %1 = load i32, i32* @h, align 4
  %mul = mul nsw i32 2, %1
  %cmp = icmp sle i32 %0, %mul
  br i1 %cmp, label %for.body, label %for.end18

for.body:                                         ; preds = %for.cond
  store i32 0, i32* %j, align 4
  br label %for.cond1

for.cond1:                                        ; preds = %for.inc, %for.body
  %2 = load i32, i32* %j, align 4
  %3 = load i32, i32* @w, align 4
  %mul2 = mul nsw i32 2, %3
  %cmp3 = icmp sle i32 %2, %mul2
  br i1 %cmp3, label %for.body4, label %for.end

for.body4:                                        ; preds = %for.cond1
  %4 = load i8**, i8*** @cell, align 4
  %5 = load i32, i32* %i, align 4
  %arrayidx = getelementptr inbounds i8*, i8** %4, i32 %5
  %6 = load i8*, i8** %arrayidx, align 4
  %7 = load i32, i32* %j, align 4
  %arrayidx5 = getelementptr inbounds i8, i8* %6, i32 %7
  %8 = load i8, i8* %arrayidx5, align 1
  %conv = zext i8 %8 to i32
  store i32 %conv, i32* %c, align 4
  %9 = load i32, i32* %c, align 4
  %cmp6 = icmp sgt i32 %9, 16
  br i1 %cmp6, label %if.then, label %if.end

if.then:                                          ; preds = %for.body4
  %call = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([6 x i8], [6 x i8]* @.str, i32 0, i32 0))
  br label %if.end

if.end:                                           ; preds = %if.then, %for.body4
  %10 = load i32, i32* %c, align 4
  %arrayidx8 = getelementptr inbounds [30 x i32], [30 x i32]* @glyph, i32 0, i32 %10
  %11 = load i32, i32* %arrayidx8, align 4
  %call9 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([4 x i8], [4 x i8]* @.str.1, i32 0, i32 0), i32 %11)
  %12 = load i32, i32* %c, align 4
  %cmp10 = icmp sgt i32 %12, 16
  br i1 %cmp10, label %if.then12, label %if.end14

if.then12:                                        ; preds = %if.end
  %call13 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([4 x i8], [4 x i8]* @.str.2, i32 0, i32 0))
  br label %if.end14

if.end14:                                         ; preds = %if.then12, %if.end
  br label %for.inc

for.inc:                                          ; preds = %if.end14
  %13 = load i32, i32* %j, align 4
  %inc = add nsw i32 %13, 1
  store i32 %inc, i32* %j, align 4
  br label %for.cond1

for.end:                                          ; preds = %for.cond1
  %call15 = call i32 @putchar(i32 10)
  br label %for.inc16

for.inc16:                                        ; preds = %for.end
  %14 = load i32, i32* %i, align 4
  %inc17 = add nsw i32 %14, 1
  store i32 %inc17, i32* %i, align 4
  br label %for.cond

for.end18:                                        ; preds = %for.cond
  ret void
}

declare i32 @printf(i8* %0, ...) #1

declare i32 @putchar(i32 %0) #1

; Function Attrs: noinline nounwind optnone
define hidden void @walk(i32 %x, i32 %y) #0 {
entry:
  %x.addr = alloca i32, align 4
  %y.addr = alloca i32, align 4
  %i = alloca i32, align 4
  %t = alloca i32, align 4
  %x1 = alloca i32, align 4
  %y1 = alloca i32, align 4
  %d = alloca [4 x i32], align 16
  store i32 %x, i32* %x.addr, align 4
  store i32 %y, i32* %y.addr, align 4
  %0 = bitcast [4 x i32]* %d to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 16 %0, i8* align 16 bitcast ([4 x i32]* @__const.walk.d to i8*), i32 16, i1 false)
  %1 = load i8**, i8*** @cell, align 4
  %2 = load i32, i32* %y.addr, align 4
  %arrayidx = getelementptr inbounds i8*, i8** %1, i32 %2
  %3 = load i8*, i8** %arrayidx, align 4
  %4 = load i32, i32* %x.addr, align 4
  %arrayidx1 = getelementptr inbounds i8, i8* %3, i32 %4
  %5 = load i8, i8* %arrayidx1, align 1
  %conv = zext i8 %5 to i32
  %or = or i32 %conv, 16
  %conv2 = trunc i32 %or to i8
  store i8 %conv2, i8* %arrayidx1, align 1
  %6 = load i32, i32* @avail, align 4
  %dec = add nsw i32 %6, -1
  store i32 %dec, i32* @avail, align 4
  store i32 3, i32* %x1, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %7 = load i32, i32* %x1, align 4
  %tobool = icmp ne i32 %7, 0
  br i1 %tobool, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %8 = load i32, i32* %x1, align 4
  %9 = load i32, i32* %x1, align 4
  %add = add nsw i32 %9, 1
  %call = call i32 @irand(i32 %add)
  store i32 %call, i32* %y1, align 4
  %cmp = icmp ne i32 %8, %call
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %for.body
  %10 = load i32, i32* %x1, align 4
  %arrayidx4 = getelementptr inbounds [4 x i32], [4 x i32]* %d, i32 0, i32 %10
  %11 = load i32, i32* %arrayidx4, align 4
  store i32 %11, i32* %i, align 4
  %12 = load i32, i32* %y1, align 4
  %arrayidx5 = getelementptr inbounds [4 x i32], [4 x i32]* %d, i32 0, i32 %12
  %13 = load i32, i32* %arrayidx5, align 4
  %14 = load i32, i32* %x1, align 4
  %arrayidx6 = getelementptr inbounds [4 x i32], [4 x i32]* %d, i32 0, i32 %14
  store i32 %13, i32* %arrayidx6, align 4
  %15 = load i32, i32* %i, align 4
  %16 = load i32, i32* %y1, align 4
  %arrayidx7 = getelementptr inbounds [4 x i32], [4 x i32]* %d, i32 0, i32 %16
  store i32 %15, i32* %arrayidx7, align 4
  br label %if.end

if.end:                                           ; preds = %if.then, %for.body
  br label %for.inc

for.inc:                                          ; preds = %if.end
  %17 = load i32, i32* %x1, align 4
  %dec8 = add nsw i32 %17, -1
  store i32 %dec8, i32* %x1, align 4
  br label %for.cond

for.end:                                          ; preds = %for.cond
  store i32 0, i32* %i, align 4
  br label %for.cond9

for.cond9:                                        ; preds = %for.inc72, %for.end
  %18 = load i32, i32* @avail, align 4
  %tobool10 = icmp ne i32 %18, 0
  br i1 %tobool10, label %land.rhs, label %land.end

land.rhs:                                         ; preds = %for.cond9
  %19 = load i32, i32* %i, align 4
  %cmp11 = icmp slt i32 %19, 4
  br label %land.end

land.end:                                         ; preds = %land.rhs, %for.cond9
  %20 = phi i1 [ false, %for.cond9 ], [ %cmp11, %land.rhs ]
  br i1 %20, label %for.body13, label %for.end73

for.body13:                                       ; preds = %land.end
  %21 = load i32, i32* %x.addr, align 4
  %22 = load i32, i32* %i, align 4
  %arrayidx14 = getelementptr inbounds [4 x i32], [4 x i32]* %d, i32 0, i32 %22
  %23 = load i32, i32* %arrayidx14, align 4
  %arrayidx15 = getelementptr inbounds [4 x [2 x i32]], [4 x [2 x i32]]* @dirs, i32 0, i32 %23
  %arrayidx16 = getelementptr inbounds [2 x i32], [2 x i32]* %arrayidx15, i32 0, i32 0
  %24 = load i32, i32* %arrayidx16, align 8
  %add17 = add nsw i32 %21, %24
  store i32 %add17, i32* %x1, align 4
  %25 = load i32, i32* %y.addr, align 4
  %26 = load i32, i32* %i, align 4
  %arrayidx18 = getelementptr inbounds [4 x i32], [4 x i32]* %d, i32 0, i32 %26
  %27 = load i32, i32* %arrayidx18, align 4
  %arrayidx19 = getelementptr inbounds [4 x [2 x i32]], [4 x [2 x i32]]* @dirs, i32 0, i32 %27
  %arrayidx20 = getelementptr inbounds [2 x i32], [2 x i32]* %arrayidx19, i32 0, i32 1
  %28 = load i32, i32* %arrayidx20, align 4
  %add21 = add nsw i32 %25, %28
  store i32 %add21, i32* %y1, align 4
  %29 = load i8**, i8*** @cell, align 4
  %30 = load i32, i32* %y1, align 4
  %arrayidx22 = getelementptr inbounds i8*, i8** %29, i32 %30
  %31 = load i8*, i8** %arrayidx22, align 4
  %32 = load i32, i32* %x1, align 4
  %arrayidx23 = getelementptr inbounds i8, i8* %31, i32 %32
  %33 = load i8, i8* %arrayidx23, align 1
  %conv24 = zext i8 %33 to i32
  %and = and i32 %conv24, 16
  %tobool25 = icmp ne i32 %and, 0
  br i1 %tobool25, label %if.then26, label %if.end27

if.then26:                                        ; preds = %for.body13
  br label %for.inc72

if.end27:                                         ; preds = %for.body13
  %34 = load i32, i32* %x1, align 4
  %35 = load i32, i32* %x.addr, align 4
  %cmp28 = icmp eq i32 %34, %35
  br i1 %cmp28, label %if.then30, label %if.else

if.then30:                                        ; preds = %if.end27
  %36 = load i32, i32* %y.addr, align 4
  %37 = load i32, i32* %y1, align 4
  %add31 = add nsw i32 %36, %37
  %div = sdiv i32 %add31, 2
  store i32 %div, i32* %t, align 4
  %38 = load i8**, i8*** @cell, align 4
  %39 = load i32, i32* %t, align 4
  %arrayidx32 = getelementptr inbounds i8*, i8** %38, i32 %39
  %40 = load i8*, i8** %arrayidx32, align 4
  %41 = load i32, i32* %x.addr, align 4
  %add33 = add nsw i32 %41, 1
  %arrayidx34 = getelementptr inbounds i8, i8* %40, i32 %add33
  %42 = load i8, i8* %arrayidx34, align 1
  %conv35 = zext i8 %42 to i32
  %and36 = and i32 %conv35, -5
  %conv37 = trunc i32 %and36 to i8
  store i8 %conv37, i8* %arrayidx34, align 1
  %43 = load i8**, i8*** @cell, align 4
  %44 = load i32, i32* %t, align 4
  %arrayidx38 = getelementptr inbounds i8*, i8** %43, i32 %44
  %45 = load i8*, i8** %arrayidx38, align 4
  %46 = load i32, i32* %x.addr, align 4
  %arrayidx39 = getelementptr inbounds i8, i8* %45, i32 %46
  %47 = load i8, i8* %arrayidx39, align 1
  %conv40 = zext i8 %47 to i32
  %and41 = and i32 %conv40, -13
  %conv42 = trunc i32 %and41 to i8
  store i8 %conv42, i8* %arrayidx39, align 1
  %48 = load i8**, i8*** @cell, align 4
  %49 = load i32, i32* %t, align 4
  %arrayidx43 = getelementptr inbounds i8*, i8** %48, i32 %49
  %50 = load i8*, i8** %arrayidx43, align 4
  %51 = load i32, i32* %x.addr, align 4
  %sub = sub nsw i32 %51, 1
  %arrayidx44 = getelementptr inbounds i8, i8* %50, i32 %sub
  %52 = load i8, i8* %arrayidx44, align 1
  %conv45 = zext i8 %52 to i32
  %and46 = and i32 %conv45, -9
  %conv47 = trunc i32 %and46 to i8
  store i8 %conv47, i8* %arrayidx44, align 1
  br label %if.end71

if.else:                                          ; preds = %if.end27
  %53 = load i32, i32* %y1, align 4
  %54 = load i32, i32* %y.addr, align 4
  %cmp48 = icmp eq i32 %53, %54
  br i1 %cmp48, label %if.then50, label %if.end70

if.then50:                                        ; preds = %if.else
  %55 = load i32, i32* %x.addr, align 4
  %56 = load i32, i32* %x1, align 4
  %add51 = add nsw i32 %55, %56
  %div52 = sdiv i32 %add51, 2
  store i32 %div52, i32* %t, align 4
  %57 = load i8**, i8*** @cell, align 4
  %58 = load i32, i32* %y.addr, align 4
  %sub53 = sub nsw i32 %58, 1
  %arrayidx54 = getelementptr inbounds i8*, i8** %57, i32 %sub53
  %59 = load i8*, i8** %arrayidx54, align 4
  %60 = load i32, i32* %t, align 4
  %arrayidx55 = getelementptr inbounds i8, i8* %59, i32 %60
  %61 = load i8, i8* %arrayidx55, align 1
  %conv56 = zext i8 %61 to i32
  %and57 = and i32 %conv56, -3
  %conv58 = trunc i32 %and57 to i8
  store i8 %conv58, i8* %arrayidx55, align 1
  %62 = load i8**, i8*** @cell, align 4
  %63 = load i32, i32* %y.addr, align 4
  %arrayidx59 = getelementptr inbounds i8*, i8** %62, i32 %63
  %64 = load i8*, i8** %arrayidx59, align 4
  %65 = load i32, i32* %t, align 4
  %arrayidx60 = getelementptr inbounds i8, i8* %64, i32 %65
  %66 = load i8, i8* %arrayidx60, align 1
  %conv61 = zext i8 %66 to i32
  %and62 = and i32 %conv61, -4
  %conv63 = trunc i32 %and62 to i8
  store i8 %conv63, i8* %arrayidx60, align 1
  %67 = load i8**, i8*** @cell, align 4
  %68 = load i32, i32* %y.addr, align 4
  %add64 = add nsw i32 %68, 1
  %arrayidx65 = getelementptr inbounds i8*, i8** %67, i32 %add64
  %69 = load i8*, i8** %arrayidx65, align 4
  %70 = load i32, i32* %t, align 4
  %arrayidx66 = getelementptr inbounds i8, i8* %69, i32 %70
  %71 = load i8, i8* %arrayidx66, align 1
  %conv67 = zext i8 %71 to i32
  %and68 = and i32 %conv67, -2
  %conv69 = trunc i32 %and68 to i8
  store i8 %conv69, i8* %arrayidx66, align 1
  br label %if.end70

if.end70:                                         ; preds = %if.then50, %if.else
  br label %if.end71

if.end71:                                         ; preds = %if.end70, %if.then30
  %72 = load i32, i32* %x1, align 4
  %73 = load i32, i32* %y1, align 4
  call void @walk(i32 %72, i32 %73)
  br label %for.inc72

for.inc72:                                        ; preds = %if.end71, %if.then26
  %74 = load i32, i32* %i, align 4
  %inc = add nsw i32 %74, 1
  store i32 %inc, i32* %i, align 4
  br label %for.cond9

for.end73:                                        ; preds = %land.end
  ret void
}

; Function Attrs: argmemonly nounwind willreturn
declare void @llvm.memcpy.p0i8.p0i8.i32(i8* noalias nocapture writeonly %0, i8* noalias nocapture readonly %1, i32 %2, i1 immarg %3) #2

; Function Attrs: noinline nounwind optnone
define hidden i32 @solve(i32 %x, i32 %y, i32 %tox, i32 %toy) #0 {
entry:
  %retval = alloca i32, align 4
  %x.addr = alloca i32, align 4
  %y.addr = alloca i32, align 4
  %tox.addr = alloca i32, align 4
  %toy.addr = alloca i32, align 4
  %i = alloca i32, align 4
  %t = alloca i32, align 4
  %x1 = alloca i32, align 4
  %y1 = alloca i32, align 4
  store i32 %x, i32* %x.addr, align 4
  store i32 %y, i32* %y.addr, align 4
  store i32 %tox, i32* %tox.addr, align 4
  store i32 %toy, i32* %toy.addr, align 4
  %0 = load i8**, i8*** @cell, align 4
  %1 = load i32, i32* %y.addr, align 4
  %arrayidx = getelementptr inbounds i8*, i8** %0, i32 %1
  %2 = load i8*, i8** %arrayidx, align 4
  %3 = load i32, i32* %x.addr, align 4
  %arrayidx1 = getelementptr inbounds i8, i8* %2, i32 %3
  %4 = load i8, i8* %arrayidx1, align 1
  %conv = zext i8 %4 to i32
  %or = or i32 %conv, 16
  %conv2 = trunc i32 %or to i8
  store i8 %conv2, i8* %arrayidx1, align 1
  %5 = load i32, i32* %x.addr, align 4
  %6 = load i32, i32* %tox.addr, align 4
  %cmp = icmp eq i32 %5, %6
  br i1 %cmp, label %land.lhs.true, label %if.end

land.lhs.true:                                    ; preds = %entry
  %7 = load i32, i32* %y.addr, align 4
  %8 = load i32, i32* %toy.addr, align 4
  %cmp4 = icmp eq i32 %7, %8
  br i1 %cmp4, label %if.then, label %if.end

if.then:                                          ; preds = %land.lhs.true
  store i32 1, i32* %retval, align 4
  br label %return

if.end:                                           ; preds = %land.lhs.true, %entry
  store i32 0, i32* %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.end
  %9 = load i32, i32* %i, align 4
  %cmp6 = icmp sle i32 %9, 3
  br i1 %cmp6, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %10 = load i32, i32* %x.addr, align 4
  %11 = load i32, i32* %i, align 4
  %arrayidx8 = getelementptr inbounds [4 x [2 x i32]], [4 x [2 x i32]]* @dirs, i32 0, i32 %11
  %arrayidx9 = getelementptr inbounds [2 x i32], [2 x i32]* %arrayidx8, i32 0, i32 0
  %12 = load i32, i32* %arrayidx9, align 8
  %add = add nsw i32 %10, %12
  store i32 %add, i32* %x1, align 4
  %13 = load i32, i32* %y.addr, align 4
  %14 = load i32, i32* %i, align 4
  %arrayidx10 = getelementptr inbounds [4 x [2 x i32]], [4 x [2 x i32]]* @dirs, i32 0, i32 %14
  %arrayidx11 = getelementptr inbounds [2 x i32], [2 x i32]* %arrayidx10, i32 0, i32 1
  %15 = load i32, i32* %arrayidx11, align 4
  %add12 = add nsw i32 %13, %15
  store i32 %add12, i32* %y1, align 4
  %16 = load i8**, i8*** @cell, align 4
  %17 = load i32, i32* %y1, align 4
  %arrayidx13 = getelementptr inbounds i8*, i8** %16, i32 %17
  %18 = load i8*, i8** %arrayidx13, align 4
  %19 = load i32, i32* %x1, align 4
  %arrayidx14 = getelementptr inbounds i8, i8* %18, i32 %19
  %20 = load i8, i8* %arrayidx14, align 1
  %tobool = icmp ne i8 %20, 0
  br i1 %tobool, label %if.then15, label %if.end16

if.then15:                                        ; preds = %for.body
  br label %for.inc

if.end16:                                         ; preds = %for.body
  %21 = load i32, i32* %x1, align 4
  %22 = load i32, i32* %x.addr, align 4
  %cmp17 = icmp eq i32 %21, %22
  br i1 %cmp17, label %if.then19, label %if.else

if.then19:                                        ; preds = %if.end16
  %23 = load i32, i32* %y.addr, align 4
  %24 = load i32, i32* %y1, align 4
  %add20 = add nsw i32 %23, %24
  %div = sdiv i32 %add20, 2
  store i32 %div, i32* %t, align 4
  %25 = load i8**, i8*** @cell, align 4
  %26 = load i32, i32* %t, align 4
  %arrayidx21 = getelementptr inbounds i8*, i8** %25, i32 %26
  %27 = load i8*, i8** %arrayidx21, align 4
  %28 = load i32, i32* %x.addr, align 4
  %arrayidx22 = getelementptr inbounds i8, i8* %27, i32 %28
  %29 = load i8, i8* %arrayidx22, align 1
  %conv23 = zext i8 %29 to i32
  %tobool24 = icmp ne i32 %conv23, 0
  br i1 %tobool24, label %if.then26, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %if.then19
  %30 = load i32, i32* %x1, align 4
  %31 = load i32, i32* %y1, align 4
  %32 = load i32, i32* %tox.addr, align 4
  %33 = load i32, i32* %toy.addr, align 4
  %call = call i32 @solve(i32 %30, i32 %31, i32 %32, i32 %33)
  %tobool25 = icmp ne i32 %call, 0
  br i1 %tobool25, label %if.end27, label %if.then26

if.then26:                                        ; preds = %lor.lhs.false, %if.then19
  br label %for.inc

if.end27:                                         ; preds = %lor.lhs.false
  %34 = load i8**, i8*** @cell, align 4
  %35 = load i32, i32* %t, align 4
  %sub = sub nsw i32 %35, 1
  %arrayidx28 = getelementptr inbounds i8*, i8** %34, i32 %sub
  %36 = load i8*, i8** %arrayidx28, align 4
  %37 = load i32, i32* %x.addr, align 4
  %arrayidx29 = getelementptr inbounds i8, i8* %36, i32 %37
  %38 = load i8, i8* %arrayidx29, align 1
  %conv30 = zext i8 %38 to i32
  %or31 = or i32 %conv30, 2
  %conv32 = trunc i32 %or31 to i8
  store i8 %conv32, i8* %arrayidx29, align 1
  %39 = load i8**, i8*** @cell, align 4
  %40 = load i32, i32* %t, align 4
  %arrayidx33 = getelementptr inbounds i8*, i8** %39, i32 %40
  %41 = load i8*, i8** %arrayidx33, align 4
  %42 = load i32, i32* %x.addr, align 4
  %arrayidx34 = getelementptr inbounds i8, i8* %41, i32 %42
  %43 = load i8, i8* %arrayidx34, align 1
  %conv35 = zext i8 %43 to i32
  %or36 = or i32 %conv35, 19
  %conv37 = trunc i32 %or36 to i8
  store i8 %conv37, i8* %arrayidx34, align 1
  %44 = load i8**, i8*** @cell, align 4
  %45 = load i32, i32* %t, align 4
  %add38 = add nsw i32 %45, 1
  %arrayidx39 = getelementptr inbounds i8*, i8** %44, i32 %add38
  %46 = load i8*, i8** %arrayidx39, align 4
  %47 = load i32, i32* %x.addr, align 4
  %arrayidx40 = getelementptr inbounds i8, i8* %46, i32 %47
  %48 = load i8, i8* %arrayidx40, align 1
  %conv41 = zext i8 %48 to i32
  %or42 = or i32 %conv41, 1
  %conv43 = trunc i32 %or42 to i8
  store i8 %conv43, i8* %arrayidx40, align 1
  br label %if.end76

if.else:                                          ; preds = %if.end16
  %49 = load i32, i32* %y1, align 4
  %50 = load i32, i32* %y.addr, align 4
  %cmp44 = icmp eq i32 %49, %50
  br i1 %cmp44, label %if.then46, label %if.end75

if.then46:                                        ; preds = %if.else
  %51 = load i32, i32* %x.addr, align 4
  %52 = load i32, i32* %x1, align 4
  %add47 = add nsw i32 %51, %52
  %div48 = sdiv i32 %add47, 2
  store i32 %div48, i32* %t, align 4
  %53 = load i8**, i8*** @cell, align 4
  %54 = load i32, i32* %y.addr, align 4
  %arrayidx49 = getelementptr inbounds i8*, i8** %53, i32 %54
  %55 = load i8*, i8** %arrayidx49, align 4
  %56 = load i32, i32* %t, align 4
  %arrayidx50 = getelementptr inbounds i8, i8* %55, i32 %56
  %57 = load i8, i8* %arrayidx50, align 1
  %conv51 = zext i8 %57 to i32
  %tobool52 = icmp ne i32 %conv51, 0
  br i1 %tobool52, label %if.then56, label %lor.lhs.false53

lor.lhs.false53:                                  ; preds = %if.then46
  %58 = load i32, i32* %x1, align 4
  %59 = load i32, i32* %y1, align 4
  %60 = load i32, i32* %tox.addr, align 4
  %61 = load i32, i32* %toy.addr, align 4
  %call54 = call i32 @solve(i32 %58, i32 %59, i32 %60, i32 %61)
  %tobool55 = icmp ne i32 %call54, 0
  br i1 %tobool55, label %if.end57, label %if.then56

if.then56:                                        ; preds = %lor.lhs.false53, %if.then46
  br label %for.inc

if.end57:                                         ; preds = %lor.lhs.false53
  %62 = load i8**, i8*** @cell, align 4
  %63 = load i32, i32* %y.addr, align 4
  %arrayidx58 = getelementptr inbounds i8*, i8** %62, i32 %63
  %64 = load i8*, i8** %arrayidx58, align 4
  %65 = load i32, i32* %t, align 4
  %sub59 = sub nsw i32 %65, 1
  %arrayidx60 = getelementptr inbounds i8, i8* %64, i32 %sub59
  %66 = load i8, i8* %arrayidx60, align 1
  %conv61 = zext i8 %66 to i32
  %or62 = or i32 %conv61, 8
  %conv63 = trunc i32 %or62 to i8
  store i8 %conv63, i8* %arrayidx60, align 1
  %67 = load i8**, i8*** @cell, align 4
  %68 = load i32, i32* %y.addr, align 4
  %arrayidx64 = getelementptr inbounds i8*, i8** %67, i32 %68
  %69 = load i8*, i8** %arrayidx64, align 4
  %70 = load i32, i32* %t, align 4
  %arrayidx65 = getelementptr inbounds i8, i8* %69, i32 %70
  %71 = load i8, i8* %arrayidx65, align 1
  %conv66 = zext i8 %71 to i32
  %or67 = or i32 %conv66, 28
  %conv68 = trunc i32 %or67 to i8
  store i8 %conv68, i8* %arrayidx65, align 1
  %72 = load i8**, i8*** @cell, align 4
  %73 = load i32, i32* %y.addr, align 4
  %arrayidx69 = getelementptr inbounds i8*, i8** %72, i32 %73
  %74 = load i8*, i8** %arrayidx69, align 4
  %75 = load i32, i32* %t, align 4
  %add70 = add nsw i32 %75, 1
  %arrayidx71 = getelementptr inbounds i8, i8* %74, i32 %add70
  %76 = load i8, i8* %arrayidx71, align 1
  %conv72 = zext i8 %76 to i32
  %or73 = or i32 %conv72, 4
  %conv74 = trunc i32 %or73 to i8
  store i8 %conv74, i8* %arrayidx71, align 1
  br label %if.end75

if.end75:                                         ; preds = %if.end57, %if.else
  br label %if.end76

if.end76:                                         ; preds = %if.end75, %if.end27
  store i32 1, i32* %retval, align 4
  br label %return

for.inc:                                          ; preds = %if.then56, %if.then26, %if.then15
  %77 = load i32, i32* %i, align 4
  %inc = add nsw i32 %77, 1
  store i32 %inc, i32* %i, align 4
  br label %for.cond

for.end:                                          ; preds = %for.cond
  %78 = load i8**, i8*** @cell, align 4
  %79 = load i32, i32* %y.addr, align 4
  %arrayidx77 = getelementptr inbounds i8*, i8** %78, i32 %79
  %80 = load i8*, i8** %arrayidx77, align 4
  %81 = load i32, i32* %x.addr, align 4
  %arrayidx78 = getelementptr inbounds i8, i8* %80, i32 %81
  %82 = load i8, i8* %arrayidx78, align 1
  %conv79 = zext i8 %82 to i32
  %and = and i32 %conv79, -17
  %conv80 = trunc i32 %and to i8
  store i8 %conv80, i8* %arrayidx78, align 1
  store i32 0, i32* %retval, align 4
  br label %return

return:                                           ; preds = %for.end, %if.end76, %if.then
  %83 = load i32, i32* %retval, align 4
  ret i32 %83
}

; Function Attrs: noinline nounwind optnone
define hidden void @make_maze() #0 {
entry:
  %i = alloca i32, align 4
  %j = alloca i32, align 4
  %h2 = alloca i32, align 4
  %w2 = alloca i32, align 4
  %p = alloca i8**, align 4
  %0 = load i32, i32* @h, align 4
  %mul = mul nsw i32 2, %0
  %add = add nsw i32 %mul, 2
  store i32 %add, i32* %h2, align 4
  %1 = load i32, i32* @w, align 4
  %mul1 = mul nsw i32 2, %1
  %add2 = add nsw i32 %mul1, 2
  store i32 %add2, i32* %w2, align 4
  %2 = load i32, i32* %h2, align 4
  %add3 = add nsw i32 %2, 2
  %mul4 = mul i32 4, %add3
  %3 = load i32, i32* %w2, align 4
  %4 = load i32, i32* %h2, align 4
  %mul5 = mul nsw i32 %3, %4
  %add6 = add i32 %mul4, %mul5
  %add7 = add i32 %add6, 1
  %call = call noalias i8* @calloc(i32 %add7, i32 1)
  %5 = bitcast i8* %call to i8**
  store i8** %5, i8*** %p, align 4
  %6 = load i8**, i8*** %p, align 4
  %7 = load i32, i32* %h2, align 4
  %add.ptr = getelementptr inbounds i8*, i8** %6, i32 %7
  %add.ptr8 = getelementptr inbounds i8*, i8** %add.ptr, i32 2
  %8 = bitcast i8** %add.ptr8 to i8*
  %add.ptr9 = getelementptr inbounds i8, i8* %8, i32 1
  %9 = load i8**, i8*** %p, align 4
  %arrayidx = getelementptr inbounds i8*, i8** %9, i32 1
  store i8* %add.ptr9, i8** %arrayidx, align 4
  store i32 2, i32* %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %10 = load i32, i32* %i, align 4
  %11 = load i32, i32* %h2, align 4
  %cmp = icmp sle i32 %10, %11
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %12 = load i8**, i8*** %p, align 4
  %13 = load i32, i32* %i, align 4
  %sub = sub nsw i32 %13, 1
  %arrayidx10 = getelementptr inbounds i8*, i8** %12, i32 %sub
  %14 = load i8*, i8** %arrayidx10, align 4
  %15 = load i32, i32* %w2, align 4
  %add.ptr11 = getelementptr inbounds i8, i8* %14, i32 %15
  %16 = load i8**, i8*** %p, align 4
  %17 = load i32, i32* %i, align 4
  %arrayidx12 = getelementptr inbounds i8*, i8** %16, i32 %17
  store i8* %add.ptr11, i8** %arrayidx12, align 4
  br label %for.inc

for.inc:                                          ; preds = %for.body
  %18 = load i32, i32* %i, align 4
  %inc = add nsw i32 %18, 1
  store i32 %inc, i32* %i, align 4
  br label %for.cond

for.end:                                          ; preds = %for.cond
  %19 = load i8**, i8*** %p, align 4
  %20 = load i32, i32* %h2, align 4
  %arrayidx13 = getelementptr inbounds i8*, i8** %19, i32 %20
  %21 = load i8*, i8** %arrayidx13, align 4
  %22 = load i8**, i8*** %p, align 4
  %arrayidx14 = getelementptr inbounds i8*, i8** %22, i32 0
  store i8* %21, i8** %arrayidx14, align 4
  %23 = load i8**, i8*** %p, align 4
  %arrayidx15 = getelementptr inbounds i8*, i8** %23, i32 1
  store i8** %arrayidx15, i8*** @cell, align 4
  store i32 -1, i32* %i, align 4
  br label %for.cond16

for.cond16:                                       ; preds = %for.inc26, %for.end
  %24 = load i32, i32* %i, align 4
  %25 = load i32, i32* @h, align 4
  %mul17 = mul nsw i32 2, %25
  %add18 = add nsw i32 %mul17, 1
  %cmp19 = icmp sle i32 %24, %add18
  br i1 %cmp19, label %for.body20, label %for.end28

for.body20:                                       ; preds = %for.cond16
  %26 = load i8**, i8*** @cell, align 4
  %27 = load i32, i32* %i, align 4
  %arrayidx21 = getelementptr inbounds i8*, i8** %26, i32 %27
  %28 = load i8*, i8** %arrayidx21, align 4
  %29 = load i32, i32* %w2, align 4
  %sub22 = sub nsw i32 %29, 1
  %arrayidx23 = getelementptr inbounds i8, i8* %28, i32 %sub22
  store i8 16, i8* %arrayidx23, align 1
  %30 = load i8**, i8*** @cell, align 4
  %31 = load i32, i32* %i, align 4
  %arrayidx24 = getelementptr inbounds i8*, i8** %30, i32 %31
  %32 = load i8*, i8** %arrayidx24, align 4
  %arrayidx25 = getelementptr inbounds i8, i8* %32, i32 -1
  store i8 16, i8* %arrayidx25, align 1
  br label %for.inc26

for.inc26:                                        ; preds = %for.body20
  %33 = load i32, i32* %i, align 4
  %inc27 = add nsw i32 %33, 1
  store i32 %inc27, i32* %i, align 4
  br label %for.cond16

for.end28:                                        ; preds = %for.cond16
  store i32 0, i32* %j, align 4
  br label %for.cond29

for.cond29:                                       ; preds = %for.inc38, %for.end28
  %34 = load i32, i32* %j, align 4
  %35 = load i32, i32* @w, align 4
  %mul30 = mul nsw i32 2, %35
  %cmp31 = icmp sle i32 %34, %mul30
  br i1 %cmp31, label %for.body32, label %for.end40

for.body32:                                       ; preds = %for.cond29
  %36 = load i8**, i8*** @cell, align 4
  %37 = load i32, i32* %h2, align 4
  %sub33 = sub nsw i32 %37, 1
  %arrayidx34 = getelementptr inbounds i8*, i8** %36, i32 %sub33
  %38 = load i8*, i8** %arrayidx34, align 4
  %39 = load i32, i32* %j, align 4
  %arrayidx35 = getelementptr inbounds i8, i8* %38, i32 %39
  store i8 16, i8* %arrayidx35, align 1
  %40 = load i8**, i8*** @cell, align 4
  %arrayidx36 = getelementptr inbounds i8*, i8** %40, i32 -1
  %41 = load i8*, i8** %arrayidx36, align 4
  %42 = load i32, i32* %j, align 4
  %arrayidx37 = getelementptr inbounds i8, i8* %41, i32 %42
  store i8 16, i8* %arrayidx37, align 1
  br label %for.inc38

for.inc38:                                        ; preds = %for.body32
  %43 = load i32, i32* %j, align 4
  %inc39 = add nsw i32 %43, 1
  store i32 %inc39, i32* %j, align 4
  br label %for.cond29

for.end40:                                        ; preds = %for.cond29
  store i32 0, i32* %i, align 4
  br label %for.cond41

for.cond41:                                       ; preds = %for.inc55, %for.end40
  %44 = load i32, i32* %i, align 4
  %45 = load i32, i32* @h, align 4
  %cmp42 = icmp sle i32 %44, %45
  br i1 %cmp42, label %for.body43, label %for.end57

for.body43:                                       ; preds = %for.cond41
  store i32 0, i32* %j, align 4
  br label %for.cond44

for.cond44:                                       ; preds = %for.inc52, %for.body43
  %46 = load i32, i32* %j, align 4
  %47 = load i32, i32* @w, align 4
  %mul45 = mul nsw i32 2, %47
  %cmp46 = icmp sle i32 %46, %mul45
  br i1 %cmp46, label %for.body47, label %for.end54

for.body47:                                       ; preds = %for.cond44
  %48 = load i8**, i8*** @cell, align 4
  %49 = load i32, i32* %i, align 4
  %mul48 = mul nsw i32 2, %49
  %arrayidx49 = getelementptr inbounds i8*, i8** %48, i32 %mul48
  %50 = load i8*, i8** %arrayidx49, align 4
  %51 = load i32, i32* %j, align 4
  %arrayidx50 = getelementptr inbounds i8, i8* %50, i32 %51
  %52 = load i8, i8* %arrayidx50, align 1
  %conv = zext i8 %52 to i32
  %or = or i32 %conv, 12
  %conv51 = trunc i32 %or to i8
  store i8 %conv51, i8* %arrayidx50, align 1
  br label %for.inc52

for.inc52:                                        ; preds = %for.body47
  %53 = load i32, i32* %j, align 4
  %inc53 = add nsw i32 %53, 1
  store i32 %inc53, i32* %j, align 4
  br label %for.cond44

for.end54:                                        ; preds = %for.cond44
  br label %for.inc55

for.inc55:                                        ; preds = %for.end54
  %54 = load i32, i32* %i, align 4
  %inc56 = add nsw i32 %54, 1
  store i32 %inc56, i32* %i, align 4
  br label %for.cond41

for.end57:                                        ; preds = %for.cond41
  store i32 0, i32* %i, align 4
  br label %for.cond58

for.cond58:                                       ; preds = %for.inc76, %for.end57
  %55 = load i32, i32* %i, align 4
  %56 = load i32, i32* @h, align 4
  %mul59 = mul nsw i32 2, %56
  %cmp60 = icmp sle i32 %55, %mul59
  br i1 %cmp60, label %for.body62, label %for.end78

for.body62:                                       ; preds = %for.cond58
  store i32 0, i32* %j, align 4
  br label %for.cond63

for.cond63:                                       ; preds = %for.inc73, %for.body62
  %57 = load i32, i32* %j, align 4
  %58 = load i32, i32* @w, align 4
  %cmp64 = icmp sle i32 %57, %58
  br i1 %cmp64, label %for.body66, label %for.end75

for.body66:                                       ; preds = %for.cond63
  %59 = load i8**, i8*** @cell, align 4
  %60 = load i32, i32* %i, align 4
  %arrayidx67 = getelementptr inbounds i8*, i8** %59, i32 %60
  %61 = load i8*, i8** %arrayidx67, align 4
  %62 = load i32, i32* %j, align 4
  %mul68 = mul nsw i32 2, %62
  %arrayidx69 = getelementptr inbounds i8, i8* %61, i32 %mul68
  %63 = load i8, i8* %arrayidx69, align 1
  %conv70 = zext i8 %63 to i32
  %or71 = or i32 %conv70, 3
  %conv72 = trunc i32 %or71 to i8
  store i8 %conv72, i8* %arrayidx69, align 1
  br label %for.inc73

for.inc73:                                        ; preds = %for.body66
  %64 = load i32, i32* %j, align 4
  %inc74 = add nsw i32 %64, 1
  store i32 %inc74, i32* %j, align 4
  br label %for.cond63

for.end75:                                        ; preds = %for.cond63
  br label %for.inc76

for.inc76:                                        ; preds = %for.end75
  %65 = load i32, i32* %i, align 4
  %inc77 = add nsw i32 %65, 1
  store i32 %inc77, i32* %i, align 4
  br label %for.cond58

for.end78:                                        ; preds = %for.cond58
  store i32 0, i32* %j, align 4
  br label %for.cond79

for.cond79:                                       ; preds = %for.inc94, %for.end78
  %66 = load i32, i32* %j, align 4
  %67 = load i32, i32* @w, align 4
  %mul80 = mul nsw i32 2, %67
  %cmp81 = icmp sle i32 %66, %mul80
  br i1 %cmp81, label %for.body83, label %for.end96

for.body83:                                       ; preds = %for.cond79
  %68 = load i8**, i8*** @cell, align 4
  %arrayidx84 = getelementptr inbounds i8*, i8** %68, i32 0
  %69 = load i8*, i8** %arrayidx84, align 4
  %70 = load i32, i32* %j, align 4
  %arrayidx85 = getelementptr inbounds i8, i8* %69, i32 %70
  %71 = load i8, i8* %arrayidx85, align 1
  %conv86 = zext i8 %71 to i32
  %and = and i32 %conv86, -2
  %conv87 = trunc i32 %and to i8
  store i8 %conv87, i8* %arrayidx85, align 1
  %72 = load i8**, i8*** @cell, align 4
  %73 = load i32, i32* @h, align 4
  %mul88 = mul nsw i32 2, %73
  %arrayidx89 = getelementptr inbounds i8*, i8** %72, i32 %mul88
  %74 = load i8*, i8** %arrayidx89, align 4
  %75 = load i32, i32* %j, align 4
  %arrayidx90 = getelementptr inbounds i8, i8* %74, i32 %75
  %76 = load i8, i8* %arrayidx90, align 1
  %conv91 = zext i8 %76 to i32
  %and92 = and i32 %conv91, -3
  %conv93 = trunc i32 %and92 to i8
  store i8 %conv93, i8* %arrayidx90, align 1
  br label %for.inc94

for.inc94:                                        ; preds = %for.body83
  %77 = load i32, i32* %j, align 4
  %inc95 = add nsw i32 %77, 1
  store i32 %inc95, i32* %j, align 4
  br label %for.cond79

for.end96:                                        ; preds = %for.cond79
  store i32 0, i32* %i, align 4
  br label %for.cond97

for.cond97:                                       ; preds = %for.inc113, %for.end96
  %78 = load i32, i32* %i, align 4
  %79 = load i32, i32* @h, align 4
  %mul98 = mul nsw i32 2, %79
  %cmp99 = icmp sle i32 %78, %mul98
  br i1 %cmp99, label %for.body101, label %for.end115

for.body101:                                      ; preds = %for.cond97
  %80 = load i8**, i8*** @cell, align 4
  %81 = load i32, i32* %i, align 4
  %arrayidx102 = getelementptr inbounds i8*, i8** %80, i32 %81
  %82 = load i8*, i8** %arrayidx102, align 4
  %arrayidx103 = getelementptr inbounds i8, i8* %82, i32 0
  %83 = load i8, i8* %arrayidx103, align 1
  %conv104 = zext i8 %83 to i32
  %and105 = and i32 %conv104, -5
  %conv106 = trunc i32 %and105 to i8
  store i8 %conv106, i8* %arrayidx103, align 1
  %84 = load i8**, i8*** @cell, align 4
  %85 = load i32, i32* %i, align 4
  %arrayidx107 = getelementptr inbounds i8*, i8** %84, i32 %85
  %86 = load i8*, i8** %arrayidx107, align 4
  %87 = load i32, i32* @w, align 4
  %mul108 = mul nsw i32 2, %87
  %arrayidx109 = getelementptr inbounds i8, i8* %86, i32 %mul108
  %88 = load i8, i8* %arrayidx109, align 1
  %conv110 = zext i8 %88 to i32
  %and111 = and i32 %conv110, -9
  %conv112 = trunc i32 %and111 to i8
  store i8 %conv112, i8* %arrayidx109, align 1
  br label %for.inc113

for.inc113:                                       ; preds = %for.body101
  %89 = load i32, i32* %i, align 4
  %inc114 = add nsw i32 %89, 1
  store i32 %inc114, i32* %i, align 4
  br label %for.cond97

for.end115:                                       ; preds = %for.cond97
  %90 = load i32, i32* @w, align 4
  %91 = load i32, i32* @h, align 4
  %mul116 = mul nsw i32 %90, %91
  store i32 %mul116, i32* @avail, align 4
  %call117 = call i32 @irand(i32 2)
  %mul118 = mul nsw i32 %call117, 2
  %add119 = add nsw i32 %mul118, 1
  %92 = load i32, i32* @h, align 4
  %call120 = call i32 @irand(i32 %92)
  %mul121 = mul nsw i32 %call120, 2
  %add122 = add nsw i32 %mul121, 1
  call void @walk(i32 %add119, i32 %add122)
  store i32 0, i32* %i, align 4
  br label %for.cond123

for.cond123:                                      ; preds = %for.inc141, %for.end115
  %93 = load i32, i32* %i, align 4
  %94 = load i32, i32* @h, align 4
  %mul124 = mul nsw i32 2, %94
  %cmp125 = icmp sle i32 %93, %mul124
  br i1 %cmp125, label %for.body127, label %for.end143

for.body127:                                      ; preds = %for.cond123
  store i32 0, i32* %j, align 4
  br label %for.cond128

for.cond128:                                      ; preds = %for.inc138, %for.body127
  %95 = load i32, i32* %j, align 4
  %96 = load i32, i32* @w, align 4
  %mul129 = mul nsw i32 2, %96
  %cmp130 = icmp sle i32 %95, %mul129
  br i1 %cmp130, label %for.body132, label %for.end140

for.body132:                                      ; preds = %for.cond128
  %97 = load i8**, i8*** @cell, align 4
  %98 = load i32, i32* %i, align 4
  %arrayidx133 = getelementptr inbounds i8*, i8** %97, i32 %98
  %99 = load i8*, i8** %arrayidx133, align 4
  %100 = load i32, i32* %j, align 4
  %arrayidx134 = getelementptr inbounds i8, i8* %99, i32 %100
  %101 = load i8, i8* %arrayidx134, align 1
  %conv135 = zext i8 %101 to i32
  %and136 = and i32 %conv135, -17
  %conv137 = trunc i32 %and136 to i8
  store i8 %conv137, i8* %arrayidx134, align 1
  br label %for.inc138

for.inc138:                                       ; preds = %for.body132
  %102 = load i32, i32* %j, align 4
  %inc139 = add nsw i32 %102, 1
  store i32 %inc139, i32* %j, align 4
  br label %for.cond128

for.end140:                                       ; preds = %for.cond128
  br label %for.inc141

for.inc141:                                       ; preds = %for.end140
  %103 = load i32, i32* %i, align 4
  %inc142 = add nsw i32 %103, 1
  store i32 %inc142, i32* %i, align 4
  br label %for.cond123

for.end143:                                       ; preds = %for.cond123
  %104 = load i32, i32* @w, align 4
  %mul144 = mul nsw i32 2, %104
  %sub145 = sub nsw i32 %mul144, 1
  %105 = load i32, i32* @h, align 4
  %mul146 = mul nsw i32 2, %105
  %sub147 = sub nsw i32 %mul146, 1
  %call148 = call i32 @solve(i32 1, i32 1, i32 %sub145, i32 %sub147)
  call void @show()
  ret void
}

declare noalias i8* @calloc(i32 %0, i32 %1) #1

; Function Attrs: noinline nounwind optnone
define hidden i32 @__main_argc_argv(i32 %c, i8** %v) #0 {
entry:
  %retval = alloca i32, align 4
  %c.addr = alloca i32, align 4
  %v.addr = alloca i8**, align 4
  store i32 0, i32* %retval, align 4
  store i32 %c, i32* %c.addr, align 4
  store i8** %v, i8*** %v.addr, align 4
  %call = call i8* @setlocale(i32 6, i8* getelementptr inbounds ([1 x i8], [1 x i8]* @.str.3, i32 0, i32 0))
  %0 = load i32, i32* %c.addr, align 4
  %cmp = icmp slt i32 %0, 2
  br i1 %cmp, label %if.then, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %entry
  %1 = load i8**, i8*** %v.addr, align 4
  %arrayidx = getelementptr inbounds i8*, i8** %1, i32 1
  %2 = load i8*, i8** %arrayidx, align 4
  %call1 = call i32 @atoi(i8* %2)
  store i32 %call1, i32* @w, align 4
  %cmp2 = icmp sle i32 %call1, 0
  br i1 %cmp2, label %if.then, label %if.end

if.then:                                          ; preds = %lor.lhs.false, %entry
  store i32 16, i32* @w, align 4
  br label %if.end

if.end:                                           ; preds = %if.then, %lor.lhs.false
  %3 = load i32, i32* %c.addr, align 4
  %cmp3 = icmp slt i32 %3, 3
  br i1 %cmp3, label %if.then8, label %lor.lhs.false4

lor.lhs.false4:                                   ; preds = %if.end
  %4 = load i8**, i8*** %v.addr, align 4
  %arrayidx5 = getelementptr inbounds i8*, i8** %4, i32 2
  %5 = load i8*, i8** %arrayidx5, align 4
  %call6 = call i32 @atoi(i8* %5)
  store i32 %call6, i32* @h, align 4
  %cmp7 = icmp sle i32 %call6, 0
  br i1 %cmp7, label %if.then8, label %if.end9

if.then8:                                         ; preds = %lor.lhs.false4, %if.end
  store i32 8, i32* @h, align 4
  br label %if.end9

if.end9:                                          ; preds = %if.then8, %lor.lhs.false4
  call void @make_maze()
  ret i32 0
}

declare i8* @setlocale(i32 %0, i8* %1) #1

declare i32 @atoi(i8* %0) #1

attributes #0 = { noinline nounwind optnone "correctly-rounded-divide-sqrt-fp-math"="false" "disable-tail-calls"="false" "frame-pointer"="none" "less-precise-fpmad"="false" "min-legal-vector-width"="0" "no-infs-fp-math"="false" "no-jump-tables"="false" "no-nans-fp-math"="false" "no-signed-zeros-fp-math"="false" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="generic" "unsafe-fp-math"="false" "use-soft-float"="false" }
attributes #1 = { "correctly-rounded-divide-sqrt-fp-math"="false" "disable-tail-calls"="false" "frame-pointer"="none" "less-precise-fpmad"="false" "no-infs-fp-math"="false" "no-nans-fp-math"="false" "no-signed-zeros-fp-math"="false" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="generic" "unsafe-fp-math"="false" "use-soft-float"="false" }
attributes #2 = { argmemonly nounwind willreturn }

!llvm.module.flags = !{!0}
!llvm.ident = !{!1}

!0 = !{i32 1, !"wchar_size", i32 4}
!1 = !{!"clang version 11.0.0 (https://github.com/Jacarte/llvm-project.git 0f6dea67136cc1e0b3d200eb2bb165628970c44b)"}

; extracted candidates

; *****
; For LLVM instruction:
;  %1 = load i32, i32* %y.addr, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %3 = load i32, i32* %x.addr, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %4 = load i8, i8* %arrayidx1, align 1
; Looking for a replacement for:
%0:i8 = var
infer %0 (demandedBits=11101111)

; *****
; For LLVM instruction:
;  %conv = zext i8 %4 to i32
; Looking for a replacement for:
%0:i8 = var
%1:i32 = zext %0
infer %1 (demandedBits=00000000000000000000000011101111)

; *****
; For LLVM instruction:
;  %or = or i32 %conv, 16
; Looking for a replacement for:
%0:i8 = var
%1:i32 = zext %0
%2:i32 = or 16:i32, %1
infer %2 (demandedBits=00000000000000000000000011111111)

; *****
; For LLVM instruction:
;  %conv2 = trunc i32 %or to i8
; Looking for a replacement for:
%0:i8 = var
%1:i32 = zext %0
%2:i32 = or 16:i32, %1
%3:i8 = trunc %2
infer %3

; *****
; For LLVM instruction:
;  %5 = load i32, i32* %x.addr, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %6 = load i32, i32* %tox.addr, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %cmp = icmp eq i32 %5, %6
; Looking for a replacement for:
%0:i32 = var
%1:i32 = var
%2:i1 = eq %0, %1
infer %2

; *****
; For LLVM instruction:
;  %7 = load i32, i32* %y.addr, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %8 = load i32, i32* %toy.addr, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %cmp4 = icmp eq i32 %7, %8
; Looking for a replacement for:
%0:i32 = var
%1:i32 = var
%2:i1 = eq %0, %1
infer %2

; *****
; For LLVM instruction:
;  %9 = load i32, i32* %i, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %cmp6 = icmp sle i32 %9, 3
; Looking for a replacement for:
%0:i32 = var
%1:i1 = sle %0, 3:i32
infer %1

; *****
; For LLVM instruction:
;  %10 = load i32, i32* %x.addr, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %11 = load i32, i32* %i, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %12 = load i32, i32* %arrayidx9, align 8
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %add = add nsw i32 %10, %12
; Looking for a replacement for:
%0:i32 = var
%1:i32 = var
%2:i32 = addnsw %0, %1
infer %2

; *****
; For LLVM instruction:
;  %13 = load i32, i32* %y.addr, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %14 = load i32, i32* %i, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %15 = load i32, i32* %arrayidx11, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %add12 = add nsw i32 %13, %15
; Looking for a replacement for:
%0:i32 = var
%1:i32 = var
%2:i32 = addnsw %0, %1
infer %2

; *****
; For LLVM instruction:
;  %17 = load i32, i32* %y1, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %19 = load i32, i32* %x1, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %20 = load i8, i8* %arrayidx14, align 1
; Looking for a replacement for:
%0:i8 = var
infer %0

; *****
; For LLVM instruction:
;  %tobool = icmp ne i8 %20, 0
; Looking for a replacement for:
%0:i8 = var
%1:i1 = ne 0:i8, %0
infer %1

; *****
; For LLVM instruction:
;  %21 = load i32, i32* %x1, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %22 = load i32, i32* %x.addr, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %cmp17 = icmp eq i32 %21, %22
; Looking for a replacement for:
%0:i32 = var
%1:i32 = var
%2:i1 = eq %0, %1
infer %2

; *****
; For LLVM instruction:
;  %23 = load i32, i32* %y.addr, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %24 = load i32, i32* %y1, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %add20 = add nsw i32 %23, %24
; Looking for a replacement for:
%0:i32 = var
%1:i32 = var
%2:i32 = addnsw %0, %1
infer %2

; *****
; For LLVM instruction:
;  %div = sdiv i32 %add20, 2
; Looking for a replacement for:
%0:i32 = var
%1:i32 = var
%2:i32 = addnsw %0, %1
%3:i32 = sdiv %2, 2:i32
infer %3

; *****
; For LLVM instruction:
;  %26 = load i32, i32* %t, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %28 = load i32, i32* %x.addr, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %29 = load i8, i8* %arrayidx22, align 1
; Looking for a replacement for:
%0:i8 = var
infer %0

; *****
; For LLVM instruction:
;  %conv23 = zext i8 %29 to i32
; Looking for a replacement for:
%0:i8 = var
%1:i32 = zext %0
infer %1

; *****
; For LLVM instruction:
;  %tobool24 = icmp ne i32 %conv23, 0
; Looking for a replacement for:
%0:i8 = var
%1:i32 = zext %0
%2:i1 = ne 0:i32, %1
infer %2

; *****
; For LLVM instruction:
;  %30 = load i32, i32* %x1, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %31 = load i32, i32* %y1, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %32 = load i32, i32* %tox.addr, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %33 = load i32, i32* %toy.addr, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %call = call i32 @solve(i32 %30, i32 %31, i32 %32, i32 %33)
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %tobool25 = icmp ne i32 %call, 0
; Looking for a replacement for:
%0:i32 = var
%1:i1 = ne 0:i32, %0
infer %1

; *****
; For LLVM instruction:
;  %35 = load i32, i32* %t, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %sub = sub nsw i32 %35, 1
; Looking for a replacement for:
%0:i32 = var
%1:i32 = subnsw %0, 1:i32
infer %1

; *****
; For LLVM instruction:
;  %37 = load i32, i32* %x.addr, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %38 = load i8, i8* %arrayidx29, align 1
; Looking for a replacement for:
%0:i8 = var
infer %0 (demandedBits=11111101)

; *****
; For LLVM instruction:
;  %conv30 = zext i8 %38 to i32
; Looking for a replacement for:
%0:i8 = var
%1:i32 = zext %0
infer %1 (demandedBits=00000000000000000000000011111101)

; *****
; For LLVM instruction:
;  %or31 = or i32 %conv30, 2
; Looking for a replacement for:
%0:i8 = var
%1:i32 = zext %0
%2:i32 = or 2:i32, %1
infer %2 (demandedBits=00000000000000000000000011111111)

; *****
; For LLVM instruction:
;  %conv32 = trunc i32 %or31 to i8
; Looking for a replacement for:
%0:i8 = var
%1:i32 = zext %0
%2:i32 = or 2:i32, %1
%3:i8 = trunc %2
infer %3

; *****
; For LLVM instruction:
;  %40 = load i32, i32* %t, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %42 = load i32, i32* %x.addr, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %43 = load i8, i8* %arrayidx34, align 1
; Looking for a replacement for:
%0:i8 = var
infer %0 (demandedBits=11101100)

; *****
; For LLVM instruction:
;  %conv35 = zext i8 %43 to i32
; Looking for a replacement for:
%0:i8 = var
%1:i32 = zext %0
infer %1 (demandedBits=00000000000000000000000011101100)

; *****
; For LLVM instruction:
;  %or36 = or i32 %conv35, 19
; Looking for a replacement for:
%0:i8 = var
%1:i32 = zext %0
%2:i32 = or 19:i32, %1
infer %2 (demandedBits=00000000000000000000000011111111)

; *****
; For LLVM instruction:
;  %conv37 = trunc i32 %or36 to i8
; Looking for a replacement for:
%0:i8 = var
%1:i32 = zext %0
%2:i32 = or 19:i32, %1
%3:i8 = trunc %2
infer %3

; *****
; For LLVM instruction:
;  %45 = load i32, i32* %t, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %add38 = add nsw i32 %45, 1
; Looking for a replacement for:
%0:i32 = var
%1:i32 = addnsw 1:i32, %0
infer %1

; *****
; For LLVM instruction:
;  %47 = load i32, i32* %x.addr, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %48 = load i8, i8* %arrayidx40, align 1
; Looking for a replacement for:
%0:i8 = var
infer %0 (demandedBits=11111110)

; *****
; For LLVM instruction:
;  %conv41 = zext i8 %48 to i32
; Looking for a replacement for:
%0:i8 = var
%1:i32 = zext %0
infer %1 (demandedBits=00000000000000000000000011111110)

; *****
; For LLVM instruction:
;  %or42 = or i32 %conv41, 1
; Looking for a replacement for:
%0:i8 = var
%1:i32 = zext %0
%2:i32 = or 1:i32, %1
infer %2 (demandedBits=00000000000000000000000011111111)

; *****
; For LLVM instruction:
;  %conv43 = trunc i32 %or42 to i8
; Looking for a replacement for:
%0:i8 = var
%1:i32 = zext %0
%2:i32 = or 1:i32, %1
%3:i8 = trunc %2
infer %3

; *****
; For LLVM instruction:
;  %49 = load i32, i32* %y1, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %50 = load i32, i32* %y.addr, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %cmp44 = icmp eq i32 %49, %50
; Looking for a replacement for:
%0:i32 = var
%1:i32 = var
%2:i1 = eq %0, %1
infer %2

; *****
; For LLVM instruction:
;  %51 = load i32, i32* %x.addr, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %52 = load i32, i32* %x1, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %add47 = add nsw i32 %51, %52
; Looking for a replacement for:
%0:i32 = var
%1:i32 = var
%2:i32 = addnsw %0, %1
infer %2

; *****
; For LLVM instruction:
;  %div48 = sdiv i32 %add47, 2
; Looking for a replacement for:
%0:i32 = var
%1:i32 = var
%2:i32 = addnsw %0, %1
%3:i32 = sdiv %2, 2:i32
infer %3

; *****
; For LLVM instruction:
;  %54 = load i32, i32* %y.addr, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %56 = load i32, i32* %t, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %57 = load i8, i8* %arrayidx50, align 1
; Looking for a replacement for:
%0:i8 = var
infer %0

; *****
; For LLVM instruction:
;  %conv51 = zext i8 %57 to i32
; Looking for a replacement for:
%0:i8 = var
%1:i32 = zext %0
infer %1

; *****
; For LLVM instruction:
;  %tobool52 = icmp ne i32 %conv51, 0
; Looking for a replacement for:
%0:i8 = var
%1:i32 = zext %0
%2:i1 = ne 0:i32, %1
infer %2

; *****
; For LLVM instruction:
;  %58 = load i32, i32* %x1, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %59 = load i32, i32* %y1, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %60 = load i32, i32* %tox.addr, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %61 = load i32, i32* %toy.addr, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %call54 = call i32 @solve(i32 %58, i32 %59, i32 %60, i32 %61)
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %tobool55 = icmp ne i32 %call54, 0
; Looking for a replacement for:
%0:i32 = var
%1:i1 = ne 0:i32, %0
infer %1

; *****
; For LLVM instruction:
;  %63 = load i32, i32* %y.addr, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %65 = load i32, i32* %t, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %sub59 = sub nsw i32 %65, 1
; Looking for a replacement for:
%0:i32 = var
%1:i32 = subnsw %0, 1:i32
infer %1

; *****
; For LLVM instruction:
;  %66 = load i8, i8* %arrayidx60, align 1
; Looking for a replacement for:
%0:i8 = var
infer %0 (demandedBits=11110111)

; *****
; For LLVM instruction:
;  %conv61 = zext i8 %66 to i32
; Looking for a replacement for:
%0:i8 = var
%1:i32 = zext %0
infer %1 (demandedBits=00000000000000000000000011110111)

; *****
; For LLVM instruction:
;  %or62 = or i32 %conv61, 8
; Looking for a replacement for:
%0:i8 = var
%1:i32 = zext %0
%2:i32 = or 8:i32, %1
infer %2 (demandedBits=00000000000000000000000011111111)

; *****
; For LLVM instruction:
;  %conv63 = trunc i32 %or62 to i8
; Looking for a replacement for:
%0:i8 = var
%1:i32 = zext %0
%2:i32 = or 8:i32, %1
%3:i8 = trunc %2
infer %3

; *****
; For LLVM instruction:
;  %68 = load i32, i32* %y.addr, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %70 = load i32, i32* %t, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %71 = load i8, i8* %arrayidx65, align 1
; Looking for a replacement for:
%0:i8 = var
infer %0 (demandedBits=11100011)

; *****
; For LLVM instruction:
;  %conv66 = zext i8 %71 to i32
; Looking for a replacement for:
%0:i8 = var
%1:i32 = zext %0
infer %1 (demandedBits=00000000000000000000000011100011)

; *****
; For LLVM instruction:
;  %or67 = or i32 %conv66, 28
; Looking for a replacement for:
%0:i8 = var
%1:i32 = zext %0
%2:i32 = or 28:i32, %1
infer %2 (demandedBits=00000000000000000000000011111111)

; *****
; For LLVM instruction:
;  %conv68 = trunc i32 %or67 to i8
; Looking for a replacement for:
%0:i8 = var
%1:i32 = zext %0
%2:i32 = or 28:i32, %1
%3:i8 = trunc %2
infer %3

; *****
; For LLVM instruction:
;  %73 = load i32, i32* %y.addr, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %75 = load i32, i32* %t, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %add70 = add nsw i32 %75, 1
; Looking for a replacement for:
%0:i32 = var
%1:i32 = addnsw 1:i32, %0
infer %1

; *****
; For LLVM instruction:
;  %76 = load i8, i8* %arrayidx71, align 1
; Looking for a replacement for:
%0:i8 = var
infer %0 (demandedBits=11111011)

; *****
; For LLVM instruction:
;  %conv72 = zext i8 %76 to i32
; Looking for a replacement for:
%0:i8 = var
%1:i32 = zext %0
infer %1 (demandedBits=00000000000000000000000011111011)

; *****
; For LLVM instruction:
;  %or73 = or i32 %conv72, 4
; Looking for a replacement for:
%0:i8 = var
%1:i32 = zext %0
%2:i32 = or 4:i32, %1
infer %2 (demandedBits=00000000000000000000000011111111)

; *****
; For LLVM instruction:
;  %conv74 = trunc i32 %or73 to i8
; Looking for a replacement for:
%0:i8 = var
%1:i32 = zext %0
%2:i32 = or 4:i32, %1
%3:i8 = trunc %2
infer %3

; *****
; For LLVM instruction:
;  %77 = load i32, i32* %i, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %inc = add nsw i32 %77, 1
; Looking for a replacement for:
%0:i32 = var
%1:i32 = addnsw 1:i32, %0
infer %1

; *****
; For LLVM instruction:
;  %79 = load i32, i32* %y.addr, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %81 = load i32, i32* %x.addr, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %82 = load i8, i8* %arrayidx78, align 1
; Looking for a replacement for:
%0:i8 = var
infer %0 (demandedBits=11101111)

; *****
; For LLVM instruction:
;  %conv79 = zext i8 %82 to i32
; Looking for a replacement for:
%0:i8 = var
%1:i32 = zext %0
infer %1 (demandedBits=00000000000000000000000011101111)

; *****
; For LLVM instruction:
;  %and = and i32 %conv79, -17
; Looking for a replacement for:
%0:i8 = var
%1:i32 = zext %0
%2:i32 = and 4294967279:i32, %1
infer %2 (demandedBits=00000000000000000000000011111111)

; *****
; For LLVM instruction:
;  %conv80 = trunc i32 %and to i8
; Looking for a replacement for:
%0:i8 = var
%1:i32 = zext %0
%2:i32 = and 4294967279:i32, %1
%3:i8 = trunc %2
infer %3

; *****
; For LLVM instruction:
;  %83 = load i32, i32* %retval, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0
got 2 candidates from LHS

-------------------------------------------------
%0:i32 = var
%1:i1 = sle %0, 3:i32
infer %1


--------------------------------
guess 0

%0:i1 = var ; reservedconst_1

Cost = 0
first query is SAT, returning the model:
reservedconst_1: -1
0 th attempt: second query is SAT-- constant doesn't work
first query is SAT, returning the model:
reservedconst_1: 0
1 th attempt: second query is SAT-- constant doesn't work
first query is UNSAT-- no more guesses
Dataflow Pruned 0/0
There are 1 Guesses
There are 0 RHSs before deduplication
There are 0 RHSs after deduplication
got 2 candidates from LHS

-------------------------------------------------
%0:i8 = var
%1:i1 = ne 0:i8, %0
infer %1


--------------------------------
guess 0

%0:i1 = var ; reservedconst_1

Cost = 0
first query is SAT, returning the model:
reservedconst_1: 0
0 th attempt: second query is SAT-- constant doesn't work
first query is SAT, returning the model:
reservedconst_1: -1
1 th attempt: second query is SAT-- constant doesn't work
first query is UNSAT-- no more guesses
Dataflow Pruned 0/0
There are 1 Guesses
There are 0 RHSs before deduplication
There are 0 RHSs after deduplication
got 3 candidates from LHS

-------------------------------------------------
%0:i8 = var
%1:i32 = zext %0
%2:i1 = ne 0:i32, %1
infer %2


--------------------------------
guess 0

%0:i1 = var ; reservedconst_1

Cost = 0
first query is SAT, returning the model:
reservedconst_1: 0
0 th attempt: second query is SAT-- constant doesn't work
first query is SAT, returning the model:
reservedconst_1: -1
1 th attempt: second query is SAT-- constant doesn't work
first query is UNSAT-- no more guesses
Dataflow Pruned 0/0
There are 1 Guesses
There are 0 RHSs before deduplication
There are 0 RHSs after deduplication
got 3 candidates from LHS

-------------------------------------------------
%0:i8 = var
%1:i32 = zext %0
%2:i32 = or 2:i32, %1
infer %2 (demandedBits=00000000000000000000000011111111)


--------------------------------
guess 0

%0:i32 = var ; reservedconst_1

Cost = 0
first query is SAT, returning the model:
reservedconst_1: 2
0 th attempt: second query is SAT-- constant doesn't work
first query is SAT, returning the model:
reservedconst_1: 223
1 th attempt: second query is SAT-- constant doesn't work
first query is UNSAT-- no more guesses

--------------------------------
guess 1

%0:i8 = var
%1:i32 = zext %0

Cost = 1
second query is SAT-- constant doesn't work
Dataflow Pruned 0/0
There are 2 Guesses
There are 0 RHSs before deduplication
There are 0 RHSs after deduplication
got 4 candidates from LHS

-------------------------------------------------
%0:i8 = var
%1:i32 = zext %0
%2:i32 = or 2:i32, %1
%3:i8 = trunc %2
infer %3


--------------------------------
guess 0

%0:i8 = var ; reservedconst_1

Cost = 0
first query is SAT, returning the model:
reservedconst_1: 2
0 th attempt: second query is SAT-- constant doesn't work
first query is SAT, returning the model:
reservedconst_1: -33
1 th attempt: second query is SAT-- constant doesn't work
first query is UNSAT-- no more guesses

--------------------------------
guess 1

%0:i8 = var

Cost = 0
second query is SAT-- constant doesn't work
Dataflow Pruned 0/0
There are 2 Guesses
There are 0 RHSs before deduplication
There are 0 RHSs after deduplication
got 1 candidates from LHS

-------------------------------------------------
%0:i8 = var
infer %0 (demandedBits=11101100)


--------------------------------
guess 0

%0:i8 = var ; reservedconst_1

Cost = 0
first query is SAT, returning the model:
reservedconst_1: 0
0 th attempt: second query is SAT-- constant doesn't work
first query is SAT, returning the model:
reservedconst_1: -20
1 th attempt: second query is SAT-- constant doesn't work
first query is UNSAT-- no more guesses
Dataflow Pruned 0/0
There are 1 Guesses
There are 0 RHSs before deduplication
There are 0 RHSs after deduplication
got 2 candidates from LHS

-------------------------------------------------
%0:i8 = var
%1:i32 = zext %0
infer %1 (demandedBits=00000000000000000000000011101100)


--------------------------------
guess 0

%0:i32 = var ; reservedconst_1

Cost = 0
first query is SAT, returning the model:
reservedconst_1: 0
0 th attempt: second query is SAT-- constant doesn't work
first query is SAT, returning the model:
reservedconst_1: 236
1 th attempt: second query is SAT-- constant doesn't work
first query is UNSAT-- no more guesses
Dataflow Pruned 0/0
There are 1 Guesses
There are 0 RHSs before deduplication
There are 0 RHSs after deduplication
got 3 candidates from LHS

-------------------------------------------------
%0:i8 = var
%1:i32 = zext %0
%2:i32 = or 19:i32, %1
infer %2 (demandedBits=00000000000000000000000011111111)


--------------------------------
guess 0

%0:i32 = var ; reservedconst_1

Cost = 0
first query is SAT, returning the model:
reservedconst_1: 19
0 th attempt: second query is SAT-- constant doesn't work
first query is SAT, returning the model:
reservedconst_1: 255
1 th attempt: second query is SAT-- constant doesn't work
first query is UNSAT-- no more guesses

--------------------------------
guess 1

%0:i8 = var
%1:i32 = zext %0

Cost = 1
second query is SAT-- constant doesn't work
Dataflow Pruned 0/0
There are 2 Guesses
There are 0 RHSs before deduplication
There are 0 RHSs after deduplication
got 4 candidates from LHS

-------------------------------------------------
%0:i8 = var
%1:i32 = zext %0
%2:i32 = or 19:i32, %1
%3:i8 = trunc %2
infer %3


--------------------------------
guess 0

%0:i8 = var ; reservedconst_1

Cost = 0
first query is SAT, returning the model:
reservedconst_1: 19
0 th attempt: second query is SAT-- constant doesn't work
first query is SAT, returning the model:
reservedconst_1: -1
1 th attempt: second query is SAT-- constant doesn't work
first query is UNSAT-- no more guesses

--------------------------------
guess 1

%0:i8 = var

Cost = 0
second query is SAT-- constant doesn't work
Dataflow Pruned 0/0
There are 2 Guesses
There are 0 RHSs before deduplication
There are 0 RHSs after deduplication
got 3 candidates from LHS

-------------------------------------------------
%0:i8 = var
%1:i32 = zext %0
%2:i32 = or 1:i32, %1
infer %2 (demandedBits=00000000000000000000000011111111)


--------------------------------
guess 0

%0:i32 = var ; reservedconst_1

Cost = 0
first query is SAT, returning the model:
reservedconst_1: 1
0 th attempt: second query is SAT-- constant doesn't work
first query is SAT, returning the model:
reservedconst_1: 255
1 th attempt: second query is SAT-- constant doesn't work
first query is UNSAT-- no more guesses

--------------------------------
guess 1

%0:i8 = var
%1:i32 = zext %0

Cost = 1
second query is SAT-- constant doesn't work
Dataflow Pruned 0/0
There are 2 Guesses
There are 0 RHSs before deduplication
There are 0 RHSs after deduplication
got 4 candidates from LHS

-------------------------------------------------
%0:i8 = var
%1:i32 = zext %0
%2:i32 = or 1:i32, %1
%3:i8 = trunc %2
infer %3


--------------------------------
guess 0

%0:i8 = var ; reservedconst_1

Cost = 0
first query is SAT, returning the model:
reservedconst_1: 1
0 th attempt: second query is SAT-- constant doesn't work
first query is SAT, returning the model:
reservedconst_1: -1
1 th attempt: second query is SAT-- constant doesn't work
first query is UNSAT-- no more guesses

--------------------------------
guess 1

%0:i8 = var

Cost = 0
second query is SAT-- constant doesn't work
Dataflow Pruned 0/0
There are 2 Guesses
There are 0 RHSs before deduplication
There are 0 RHSs after deduplication
got 3 candidates from LHS

-------------------------------------------------
%0:i8 = var
%1:i32 = zext %0
%2:i32 = or 8:i32, %1
infer %2 (demandedBits=00000000000000000000000011111111)


--------------------------------
guess 0

%0:i32 = var ; reservedconst_1

Cost = 0
first query is SAT, returning the model:
reservedconst_1: 8
0 th attempt: second query is SAT-- constant doesn't work
first query is SAT, returning the model:
reservedconst_1: 223
1 th attempt: second query is SAT-- constant doesn't work
first query is UNSAT-- no more guesses

--------------------------------
guess 1

%0:i8 = var
%1:i32 = zext %0

Cost = 1
second query is SAT-- constant doesn't work
Dataflow Pruned 0/0
There are 2 Guesses
There are 0 RHSs before deduplication
There are 0 RHSs after deduplication
got 4 candidates from LHS

-------------------------------------------------
%0:i8 = var
%1:i32 = zext %0
%2:i32 = or 8:i32, %1
%3:i8 = trunc %2
infer %3


--------------------------------
guess 0

%0:i8 = var ; reservedconst_1

Cost = 0
first query is SAT, returning the model:
reservedconst_1: 8
0 th attempt: second query is SAT-- constant doesn't work
first query is SAT, returning the model:
reservedconst_1: -33
1 th attempt: second query is SAT-- constant doesn't work
first query is UNSAT-- no more guesses

--------------------------------
guess 1

%0:i8 = var

Cost = 0
second query is SAT-- constant doesn't work
Dataflow Pruned 0/0
There are 2 Guesses
There are 0 RHSs before deduplication
There are 0 RHSs after deduplication
got 1 candidates from LHS

-------------------------------------------------
%0:i8 = var
infer %0 (demandedBits=11100011)


--------------------------------
guess 0

%0:i8 = var ; reservedconst_1

Cost = 0
first query is SAT, returning the model:
reservedconst_1: 0
0 th attempt: second query is SAT-- constant doesn't work
first query is SAT, returning the model:
reservedconst_1: -29
1 th attempt: second query is SAT-- constant doesn't work
first query is UNSAT-- no more guesses
Dataflow Pruned 0/0
There are 1 Guesses
There are 0 RHSs before deduplication
There are 0 RHSs after deduplication
got 2 candidates from LHS

-------------------------------------------------
%0:i8 = var
%1:i32 = zext %0
infer %1 (demandedBits=00000000000000000000000011100011)


--------------------------------
guess 0

%0:i32 = var ; reservedconst_1

Cost = 0
first query is SAT, returning the model:
reservedconst_1: 0
0 th attempt: second query is SAT-- constant doesn't work
first query is SAT, returning the model:
reservedconst_1: 227
1 th attempt: second query is SAT-- constant doesn't work
first query is UNSAT-- no more guesses
Dataflow Pruned 0/0
There are 1 Guesses
There are 0 RHSs before deduplication
There are 0 RHSs after deduplication
got 3 candidates from LHS

-------------------------------------------------
%0:i8 = var
%1:i32 = zext %0
%2:i32 = or 28:i32, %1
infer %2 (demandedBits=00000000000000000000000011111111)


--------------------------------
guess 0

%0:i32 = var ; reservedconst_1

Cost = 0
first query is SAT, returning the model:
reservedconst_1: 28
0 th attempt: second query is SAT-- constant doesn't work
first query is SAT, returning the model:
reservedconst_1: 255
1 th attempt: second query is SAT-- constant doesn't work
first query is UNSAT-- no more guesses

--------------------------------
guess 1

%0:i8 = var
%1:i32 = zext %0

Cost = 1
second query is SAT-- constant doesn't work
Dataflow Pruned 0/0
There are 2 Guesses
There are 0 RHSs before deduplication
There are 0 RHSs after deduplication
got 4 candidates from LHS

-------------------------------------------------
%0:i8 = var
%1:i32 = zext %0
%2:i32 = or 28:i32, %1
%3:i8 = trunc %2
infer %3


--------------------------------
guess 0

%0:i8 = var ; reservedconst_1

Cost = 0
first query is SAT, returning the model:
reservedconst_1: 28
0 th attempt: second query is SAT-- constant doesn't work
first query is SAT, returning the model:
reservedconst_1: -1
1 th attempt: second query is SAT-- constant doesn't work
first query is UNSAT-- no more guesses

--------------------------------
guess 1

%0:i8 = var

Cost = 0
second query is SAT-- constant doesn't work
Dataflow Pruned 0/0
There are 2 Guesses
There are 0 RHSs before deduplication
There are 0 RHSs after deduplication
got 3 candidates from LHS

-------------------------------------------------
%0:i8 = var
%1:i32 = zext %0
%2:i32 = or 4:i32, %1
infer %2 (demandedBits=00000000000000000000000011111111)


--------------------------------
guess 0

%0:i32 = var ; reservedconst_1

Cost = 0
first query is SAT, returning the model:
reservedconst_1: 4
0 th attempt: second query is SAT-- constant doesn't work
first query is SAT, returning the model:
reservedconst_1: 223
1 th attempt: second query is SAT-- constant doesn't work
first query is UNSAT-- no more guesses

--------------------------------
guess 1

%0:i8 = var
%1:i32 = zext %0

Cost = 1
second query is SAT-- constant doesn't work
Dataflow Pruned 0/0
There are 2 Guesses
There are 0 RHSs before deduplication
There are 0 RHSs after deduplication
got 4 candidates from LHS

-------------------------------------------------
%0:i8 = var
%1:i32 = zext %0
%2:i32 = or 4:i32, %1
%3:i8 = trunc %2
infer %3


--------------------------------
guess 0

%0:i8 = var ; reservedconst_1

Cost = 0
first query is SAT, returning the model:
reservedconst_1: 4
0 th attempt: second query is SAT-- constant doesn't work
first query is SAT, returning the model:
reservedconst_1: -33
1 th attempt: second query is SAT-- constant doesn't work
first query is UNSAT-- no more guesses

--------------------------------
guess 1

%0:i8 = var

Cost = 0
second query is SAT-- constant doesn't work
Dataflow Pruned 0/0
There are 2 Guesses
There are 0 RHSs before deduplication
There are 0 RHSs after deduplication
got 3 candidates from LHS

-------------------------------------------------
%0:i8 = var
%1:i32 = zext %0
%2:i32 = and 4294967279:i32, %1
infer %2 (demandedBits=00000000000000000000000011111111)


--------------------------------
guess 0

%0:i32 = var ; reservedconst_1

Cost = 0
first query is SAT, returning the model:
reservedconst_1: 0
0 th attempt: second query is SAT-- constant doesn't work
first query is SAT, returning the model:
reservedconst_1: 207
1 th attempt: second query is SAT-- constant doesn't work
first query is UNSAT-- no more guesses

--------------------------------
guess 1

%0:i8 = var
%1:i32 = zext %0

Cost = 1
second query is SAT-- constant doesn't work
Dataflow Pruned 0/0
There are 2 Guesses
There are 0 RHSs before deduplication
There are 0 RHSs after deduplication
got 4 candidates from LHS

-------------------------------------------------
%0:i8 = var
%1:i32 = zext %0
%2:i32 = and 4294967279:i32, %1
%3:i8 = trunc %2
infer %3


--------------------------------
guess 0

%0:i8 = var ; reservedconst_1

Cost = 0
first query is SAT, returning the model:
reservedconst_1: 0
0 th attempt: second query is SAT-- constant doesn't work
first query is SAT, returning the model:
reservedconst_1: -49
1 th attempt: second query is SAT-- constant doesn't work
first query is UNSAT-- no more guesses

--------------------------------
guess 1

%0:i8 = var

Cost = 0
second query is SAT-- constant doesn't work
Dataflow Pruned 0/0
There are 2 Guesses
There are 0 RHSs before deduplication
There are 0 RHSs after deduplication
#########################################################
; exiting Souper's runOnFunction() for solve()

; entering Souper's runOnFunction() for make_maze()

; ModuleID = './Maze_generation.c.bc'
source_filename = "./Maze_generation.c"
target datalayout = "e-m:e-p:32:32-i64:64-n32:64-S128"
target triple = "wasm32-unknown-wasi"

@glyph = hidden global [30 x i32] [i32 12288, i32 9474, i32 9474, i32 9474, i32 9472, i32 9496, i32 9488, i32 9508, i32 9472, i32 9492, i32 9484, i32 9500, i32 9472, i32 9524, i32 9516, i32 9532, i32 12288, i32 9478, i32 9478, i32 9478, i32 9476, i32 9583, i32 9582, i32 32, i32 9476, i32 9584, i32 9581, i32 32, i32 9476, i32 0], align 16
@h = hidden global i32 0, align 4
@w = hidden global i32 0, align 4
@cell = hidden global i8** null, align 4
@.str = private unnamed_addr constant [6 x i8] c"\1B[31m\00", align 1
@.str.1 = private unnamed_addr constant [4 x i8] c"%lc\00", align 1
@.str.2 = private unnamed_addr constant [4 x i8] c"\1B[m\00", align 1
@__const.walk.d = private unnamed_addr constant [4 x i32] [i32 0, i32 1, i32 2, i32 3], align 16
@avail = hidden global i32 0, align 4
@dirs = internal global [4 x [2 x i32]] [[2 x i32] [i32 -2, i32 0], [2 x i32] [i32 0, i32 2], [2 x i32] [i32 2, i32 0], [2 x i32] [i32 0, i32 -2]], align 16
@.str.3 = private unnamed_addr constant [1 x i8] zeroinitializer, align 1

; Function Attrs: noinline nounwind optnone
define hidden i32 @irand(i32 %n) #0 {
entry:
  %n.addr = alloca i32, align 4
  %r = alloca i32, align 4
  %rmax = alloca i32, align 4
  store i32 %n, i32* %n.addr, align 4
  %0 = load i32, i32* %n.addr, align 4
  %1 = load i32, i32* %n.addr, align 4
  %div = sdiv i32 2147483647, %1
  %mul = mul nsw i32 %0, %div
  store i32 %mul, i32* %rmax, align 4
  br label %while.cond

while.cond:                                       ; preds = %while.body, %entry
  %call = call i32 @rand()
  store i32 %call, i32* %r, align 4
  %2 = load i32, i32* %rmax, align 4
  %cmp = icmp sge i32 %call, %2
  br i1 %cmp, label %while.body, label %while.end

while.body:                                       ; preds = %while.cond
  br label %while.cond

while.end:                                        ; preds = %while.cond
  %3 = load i32, i32* %r, align 4
  %4 = load i32, i32* %n.addr, align 4
  %div1 = sdiv i32 2147483647, %4
  %div2 = sdiv i32 %3, %div1
  ret i32 %div2
}

declare i32 @rand() #1

; Function Attrs: noinline nounwind optnone
define hidden void @show() #0 {
entry:
  %i = alloca i32, align 4
  %j = alloca i32, align 4
  %c = alloca i32, align 4
  store i32 0, i32* %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc16, %entry
  %0 = load i32, i32* %i, align 4
  %1 = load i32, i32* @h, align 4
  %mul = mul nsw i32 2, %1
  %cmp = icmp sle i32 %0, %mul
  br i1 %cmp, label %for.body, label %for.end18

for.body:                                         ; preds = %for.cond
  store i32 0, i32* %j, align 4
  br label %for.cond1

for.cond1:                                        ; preds = %for.inc, %for.body
  %2 = load i32, i32* %j, align 4
  %3 = load i32, i32* @w, align 4
  %mul2 = mul nsw i32 2, %3
  %cmp3 = icmp sle i32 %2, %mul2
  br i1 %cmp3, label %for.body4, label %for.end

for.body4:                                        ; preds = %for.cond1
  %4 = load i8**, i8*** @cell, align 4
  %5 = load i32, i32* %i, align 4
  %arrayidx = getelementptr inbounds i8*, i8** %4, i32 %5
  %6 = load i8*, i8** %arrayidx, align 4
  %7 = load i32, i32* %j, align 4
  %arrayidx5 = getelementptr inbounds i8, i8* %6, i32 %7
  %8 = load i8, i8* %arrayidx5, align 1
  %conv = zext i8 %8 to i32
  store i32 %conv, i32* %c, align 4
  %9 = load i32, i32* %c, align 4
  %cmp6 = icmp sgt i32 %9, 16
  br i1 %cmp6, label %if.then, label %if.end

if.then:                                          ; preds = %for.body4
  %call = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([6 x i8], [6 x i8]* @.str, i32 0, i32 0))
  br label %if.end

if.end:                                           ; preds = %if.then, %for.body4
  %10 = load i32, i32* %c, align 4
  %arrayidx8 = getelementptr inbounds [30 x i32], [30 x i32]* @glyph, i32 0, i32 %10
  %11 = load i32, i32* %arrayidx8, align 4
  %call9 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([4 x i8], [4 x i8]* @.str.1, i32 0, i32 0), i32 %11)
  %12 = load i32, i32* %c, align 4
  %cmp10 = icmp sgt i32 %12, 16
  br i1 %cmp10, label %if.then12, label %if.end14

if.then12:                                        ; preds = %if.end
  %call13 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([4 x i8], [4 x i8]* @.str.2, i32 0, i32 0))
  br label %if.end14

if.end14:                                         ; preds = %if.then12, %if.end
  br label %for.inc

for.inc:                                          ; preds = %if.end14
  %13 = load i32, i32* %j, align 4
  %inc = add nsw i32 %13, 1
  store i32 %inc, i32* %j, align 4
  br label %for.cond1

for.end:                                          ; preds = %for.cond1
  %call15 = call i32 @putchar(i32 10)
  br label %for.inc16

for.inc16:                                        ; preds = %for.end
  %14 = load i32, i32* %i, align 4
  %inc17 = add nsw i32 %14, 1
  store i32 %inc17, i32* %i, align 4
  br label %for.cond

for.end18:                                        ; preds = %for.cond
  ret void
}

declare i32 @printf(i8* %0, ...) #1

declare i32 @putchar(i32 %0) #1

; Function Attrs: noinline nounwind optnone
define hidden void @walk(i32 %x, i32 %y) #0 {
entry:
  %x.addr = alloca i32, align 4
  %y.addr = alloca i32, align 4
  %i = alloca i32, align 4
  %t = alloca i32, align 4
  %x1 = alloca i32, align 4
  %y1 = alloca i32, align 4
  %d = alloca [4 x i32], align 16
  store i32 %x, i32* %x.addr, align 4
  store i32 %y, i32* %y.addr, align 4
  %0 = bitcast [4 x i32]* %d to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 16 %0, i8* align 16 bitcast ([4 x i32]* @__const.walk.d to i8*), i32 16, i1 false)
  %1 = load i8**, i8*** @cell, align 4
  %2 = load i32, i32* %y.addr, align 4
  %arrayidx = getelementptr inbounds i8*, i8** %1, i32 %2
  %3 = load i8*, i8** %arrayidx, align 4
  %4 = load i32, i32* %x.addr, align 4
  %arrayidx1 = getelementptr inbounds i8, i8* %3, i32 %4
  %5 = load i8, i8* %arrayidx1, align 1
  %conv = zext i8 %5 to i32
  %or = or i32 %conv, 16
  %conv2 = trunc i32 %or to i8
  store i8 %conv2, i8* %arrayidx1, align 1
  %6 = load i32, i32* @avail, align 4
  %dec = add nsw i32 %6, -1
  store i32 %dec, i32* @avail, align 4
  store i32 3, i32* %x1, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %7 = load i32, i32* %x1, align 4
  %tobool = icmp ne i32 %7, 0
  br i1 %tobool, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %8 = load i32, i32* %x1, align 4
  %9 = load i32, i32* %x1, align 4
  %add = add nsw i32 %9, 1
  %call = call i32 @irand(i32 %add)
  store i32 %call, i32* %y1, align 4
  %cmp = icmp ne i32 %8, %call
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %for.body
  %10 = load i32, i32* %x1, align 4
  %arrayidx4 = getelementptr inbounds [4 x i32], [4 x i32]* %d, i32 0, i32 %10
  %11 = load i32, i32* %arrayidx4, align 4
  store i32 %11, i32* %i, align 4
  %12 = load i32, i32* %y1, align 4
  %arrayidx5 = getelementptr inbounds [4 x i32], [4 x i32]* %d, i32 0, i32 %12
  %13 = load i32, i32* %arrayidx5, align 4
  %14 = load i32, i32* %x1, align 4
  %arrayidx6 = getelementptr inbounds [4 x i32], [4 x i32]* %d, i32 0, i32 %14
  store i32 %13, i32* %arrayidx6, align 4
  %15 = load i32, i32* %i, align 4
  %16 = load i32, i32* %y1, align 4
  %arrayidx7 = getelementptr inbounds [4 x i32], [4 x i32]* %d, i32 0, i32 %16
  store i32 %15, i32* %arrayidx7, align 4
  br label %if.end

if.end:                                           ; preds = %if.then, %for.body
  br label %for.inc

for.inc:                                          ; preds = %if.end
  %17 = load i32, i32* %x1, align 4
  %dec8 = add nsw i32 %17, -1
  store i32 %dec8, i32* %x1, align 4
  br label %for.cond

for.end:                                          ; preds = %for.cond
  store i32 0, i32* %i, align 4
  br label %for.cond9

for.cond9:                                        ; preds = %for.inc72, %for.end
  %18 = load i32, i32* @avail, align 4
  %tobool10 = icmp ne i32 %18, 0
  br i1 %tobool10, label %land.rhs, label %land.end

land.rhs:                                         ; preds = %for.cond9
  %19 = load i32, i32* %i, align 4
  %cmp11 = icmp slt i32 %19, 4
  br label %land.end

land.end:                                         ; preds = %land.rhs, %for.cond9
  %20 = phi i1 [ false, %for.cond9 ], [ %cmp11, %land.rhs ]
  br i1 %20, label %for.body13, label %for.end73

for.body13:                                       ; preds = %land.end
  %21 = load i32, i32* %x.addr, align 4
  %22 = load i32, i32* %i, align 4
  %arrayidx14 = getelementptr inbounds [4 x i32], [4 x i32]* %d, i32 0, i32 %22
  %23 = load i32, i32* %arrayidx14, align 4
  %arrayidx15 = getelementptr inbounds [4 x [2 x i32]], [4 x [2 x i32]]* @dirs, i32 0, i32 %23
  %arrayidx16 = getelementptr inbounds [2 x i32], [2 x i32]* %arrayidx15, i32 0, i32 0
  %24 = load i32, i32* %arrayidx16, align 8
  %add17 = add nsw i32 %21, %24
  store i32 %add17, i32* %x1, align 4
  %25 = load i32, i32* %y.addr, align 4
  %26 = load i32, i32* %i, align 4
  %arrayidx18 = getelementptr inbounds [4 x i32], [4 x i32]* %d, i32 0, i32 %26
  %27 = load i32, i32* %arrayidx18, align 4
  %arrayidx19 = getelementptr inbounds [4 x [2 x i32]], [4 x [2 x i32]]* @dirs, i32 0, i32 %27
  %arrayidx20 = getelementptr inbounds [2 x i32], [2 x i32]* %arrayidx19, i32 0, i32 1
  %28 = load i32, i32* %arrayidx20, align 4
  %add21 = add nsw i32 %25, %28
  store i32 %add21, i32* %y1, align 4
  %29 = load i8**, i8*** @cell, align 4
  %30 = load i32, i32* %y1, align 4
  %arrayidx22 = getelementptr inbounds i8*, i8** %29, i32 %30
  %31 = load i8*, i8** %arrayidx22, align 4
  %32 = load i32, i32* %x1, align 4
  %arrayidx23 = getelementptr inbounds i8, i8* %31, i32 %32
  %33 = load i8, i8* %arrayidx23, align 1
  %conv24 = zext i8 %33 to i32
  %and = and i32 %conv24, 16
  %tobool25 = icmp ne i32 %and, 0
  br i1 %tobool25, label %if.then26, label %if.end27

if.then26:                                        ; preds = %for.body13
  br label %for.inc72

if.end27:                                         ; preds = %for.body13
  %34 = load i32, i32* %x1, align 4
  %35 = load i32, i32* %x.addr, align 4
  %cmp28 = icmp eq i32 %34, %35
  br i1 %cmp28, label %if.then30, label %if.else

if.then30:                                        ; preds = %if.end27
  %36 = load i32, i32* %y.addr, align 4
  %37 = load i32, i32* %y1, align 4
  %add31 = add nsw i32 %36, %37
  %div = sdiv i32 %add31, 2
  store i32 %div, i32* %t, align 4
  %38 = load i8**, i8*** @cell, align 4
  %39 = load i32, i32* %t, align 4
  %arrayidx32 = getelementptr inbounds i8*, i8** %38, i32 %39
  %40 = load i8*, i8** %arrayidx32, align 4
  %41 = load i32, i32* %x.addr, align 4
  %add33 = add nsw i32 %41, 1
  %arrayidx34 = getelementptr inbounds i8, i8* %40, i32 %add33
  %42 = load i8, i8* %arrayidx34, align 1
  %conv35 = zext i8 %42 to i32
  %and36 = and i32 %conv35, -5
  %conv37 = trunc i32 %and36 to i8
  store i8 %conv37, i8* %arrayidx34, align 1
  %43 = load i8**, i8*** @cell, align 4
  %44 = load i32, i32* %t, align 4
  %arrayidx38 = getelementptr inbounds i8*, i8** %43, i32 %44
  %45 = load i8*, i8** %arrayidx38, align 4
  %46 = load i32, i32* %x.addr, align 4
  %arrayidx39 = getelementptr inbounds i8, i8* %45, i32 %46
  %47 = load i8, i8* %arrayidx39, align 1
  %conv40 = zext i8 %47 to i32
  %and41 = and i32 %conv40, -13
  %conv42 = trunc i32 %and41 to i8
  store i8 %conv42, i8* %arrayidx39, align 1
  %48 = load i8**, i8*** @cell, align 4
  %49 = load i32, i32* %t, align 4
  %arrayidx43 = getelementptr inbounds i8*, i8** %48, i32 %49
  %50 = load i8*, i8** %arrayidx43, align 4
  %51 = load i32, i32* %x.addr, align 4
  %sub = sub nsw i32 %51, 1
  %arrayidx44 = getelementptr inbounds i8, i8* %50, i32 %sub
  %52 = load i8, i8* %arrayidx44, align 1
  %conv45 = zext i8 %52 to i32
  %and46 = and i32 %conv45, -9
  %conv47 = trunc i32 %and46 to i8
  store i8 %conv47, i8* %arrayidx44, align 1
  br label %if.end71

if.else:                                          ; preds = %if.end27
  %53 = load i32, i32* %y1, align 4
  %54 = load i32, i32* %y.addr, align 4
  %cmp48 = icmp eq i32 %53, %54
  br i1 %cmp48, label %if.then50, label %if.end70

if.then50:                                        ; preds = %if.else
  %55 = load i32, i32* %x.addr, align 4
  %56 = load i32, i32* %x1, align 4
  %add51 = add nsw i32 %55, %56
  %div52 = sdiv i32 %add51, 2
  store i32 %div52, i32* %t, align 4
  %57 = load i8**, i8*** @cell, align 4
  %58 = load i32, i32* %y.addr, align 4
  %sub53 = sub nsw i32 %58, 1
  %arrayidx54 = getelementptr inbounds i8*, i8** %57, i32 %sub53
  %59 = load i8*, i8** %arrayidx54, align 4
  %60 = load i32, i32* %t, align 4
  %arrayidx55 = getelementptr inbounds i8, i8* %59, i32 %60
  %61 = load i8, i8* %arrayidx55, align 1
  %conv56 = zext i8 %61 to i32
  %and57 = and i32 %conv56, -3
  %conv58 = trunc i32 %and57 to i8
  store i8 %conv58, i8* %arrayidx55, align 1
  %62 = load i8**, i8*** @cell, align 4
  %63 = load i32, i32* %y.addr, align 4
  %arrayidx59 = getelementptr inbounds i8*, i8** %62, i32 %63
  %64 = load i8*, i8** %arrayidx59, align 4
  %65 = load i32, i32* %t, align 4
  %arrayidx60 = getelementptr inbounds i8, i8* %64, i32 %65
  %66 = load i8, i8* %arrayidx60, align 1
  %conv61 = zext i8 %66 to i32
  %and62 = and i32 %conv61, -4
  %conv63 = trunc i32 %and62 to i8
  store i8 %conv63, i8* %arrayidx60, align 1
  %67 = load i8**, i8*** @cell, align 4
  %68 = load i32, i32* %y.addr, align 4
  %add64 = add nsw i32 %68, 1
  %arrayidx65 = getelementptr inbounds i8*, i8** %67, i32 %add64
  %69 = load i8*, i8** %arrayidx65, align 4
  %70 = load i32, i32* %t, align 4
  %arrayidx66 = getelementptr inbounds i8, i8* %69, i32 %70
  %71 = load i8, i8* %arrayidx66, align 1
  %conv67 = zext i8 %71 to i32
  %and68 = and i32 %conv67, -2
  %conv69 = trunc i32 %and68 to i8
  store i8 %conv69, i8* %arrayidx66, align 1
  br label %if.end70

if.end70:                                         ; preds = %if.then50, %if.else
  br label %if.end71

if.end71:                                         ; preds = %if.end70, %if.then30
  %72 = load i32, i32* %x1, align 4
  %73 = load i32, i32* %y1, align 4
  call void @walk(i32 %72, i32 %73)
  br label %for.inc72

for.inc72:                                        ; preds = %if.end71, %if.then26
  %74 = load i32, i32* %i, align 4
  %inc = add nsw i32 %74, 1
  store i32 %inc, i32* %i, align 4
  br label %for.cond9

for.end73:                                        ; preds = %land.end
  ret void
}

; Function Attrs: argmemonly nounwind willreturn
declare void @llvm.memcpy.p0i8.p0i8.i32(i8* noalias nocapture writeonly %0, i8* noalias nocapture readonly %1, i32 %2, i1 immarg %3) #2

; Function Attrs: noinline nounwind optnone
define hidden i32 @solve(i32 %x, i32 %y, i32 %tox, i32 %toy) #0 {
entry:
  %retval = alloca i32, align 4
  %x.addr = alloca i32, align 4
  %y.addr = alloca i32, align 4
  %tox.addr = alloca i32, align 4
  %toy.addr = alloca i32, align 4
  %i = alloca i32, align 4
  %t = alloca i32, align 4
  %x1 = alloca i32, align 4
  %y1 = alloca i32, align 4
  store i32 %x, i32* %x.addr, align 4
  store i32 %y, i32* %y.addr, align 4
  store i32 %tox, i32* %tox.addr, align 4
  store i32 %toy, i32* %toy.addr, align 4
  %0 = load i8**, i8*** @cell, align 4
  %1 = load i32, i32* %y.addr, align 4
  %arrayidx = getelementptr inbounds i8*, i8** %0, i32 %1
  %2 = load i8*, i8** %arrayidx, align 4
  %3 = load i32, i32* %x.addr, align 4
  %arrayidx1 = getelementptr inbounds i8, i8* %2, i32 %3
  %4 = load i8, i8* %arrayidx1, align 1
  %conv = zext i8 %4 to i32
  %or = or i32 %conv, 16
  %conv2 = trunc i32 %or to i8
  store i8 %conv2, i8* %arrayidx1, align 1
  %5 = load i32, i32* %x.addr, align 4
  %6 = load i32, i32* %tox.addr, align 4
  %cmp = icmp eq i32 %5, %6
  br i1 %cmp, label %land.lhs.true, label %if.end

land.lhs.true:                                    ; preds = %entry
  %7 = load i32, i32* %y.addr, align 4
  %8 = load i32, i32* %toy.addr, align 4
  %cmp4 = icmp eq i32 %7, %8
  br i1 %cmp4, label %if.then, label %if.end

if.then:                                          ; preds = %land.lhs.true
  store i32 1, i32* %retval, align 4
  br label %return

if.end:                                           ; preds = %land.lhs.true, %entry
  store i32 0, i32* %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.end
  %9 = load i32, i32* %i, align 4
  %cmp6 = icmp sle i32 %9, 3
  br i1 %cmp6, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %10 = load i32, i32* %x.addr, align 4
  %11 = load i32, i32* %i, align 4
  %arrayidx8 = getelementptr inbounds [4 x [2 x i32]], [4 x [2 x i32]]* @dirs, i32 0, i32 %11
  %arrayidx9 = getelementptr inbounds [2 x i32], [2 x i32]* %arrayidx8, i32 0, i32 0
  %12 = load i32, i32* %arrayidx9, align 8
  %add = add nsw i32 %10, %12
  store i32 %add, i32* %x1, align 4
  %13 = load i32, i32* %y.addr, align 4
  %14 = load i32, i32* %i, align 4
  %arrayidx10 = getelementptr inbounds [4 x [2 x i32]], [4 x [2 x i32]]* @dirs, i32 0, i32 %14
  %arrayidx11 = getelementptr inbounds [2 x i32], [2 x i32]* %arrayidx10, i32 0, i32 1
  %15 = load i32, i32* %arrayidx11, align 4
  %add12 = add nsw i32 %13, %15
  store i32 %add12, i32* %y1, align 4
  %16 = load i8**, i8*** @cell, align 4
  %17 = load i32, i32* %y1, align 4
  %arrayidx13 = getelementptr inbounds i8*, i8** %16, i32 %17
  %18 = load i8*, i8** %arrayidx13, align 4
  %19 = load i32, i32* %x1, align 4
  %arrayidx14 = getelementptr inbounds i8, i8* %18, i32 %19
  %20 = load i8, i8* %arrayidx14, align 1
  %tobool = icmp ne i8 %20, 0
  br i1 %tobool, label %if.then15, label %if.end16

if.then15:                                        ; preds = %for.body
  br label %for.inc

if.end16:                                         ; preds = %for.body
  %21 = load i32, i32* %x1, align 4
  %22 = load i32, i32* %x.addr, align 4
  %cmp17 = icmp eq i32 %21, %22
  br i1 %cmp17, label %if.then19, label %if.else

if.then19:                                        ; preds = %if.end16
  %23 = load i32, i32* %y.addr, align 4
  %24 = load i32, i32* %y1, align 4
  %add20 = add nsw i32 %23, %24
  %div = sdiv i32 %add20, 2
  store i32 %div, i32* %t, align 4
  %25 = load i8**, i8*** @cell, align 4
  %26 = load i32, i32* %t, align 4
  %arrayidx21 = getelementptr inbounds i8*, i8** %25, i32 %26
  %27 = load i8*, i8** %arrayidx21, align 4
  %28 = load i32, i32* %x.addr, align 4
  %arrayidx22 = getelementptr inbounds i8, i8* %27, i32 %28
  %29 = load i8, i8* %arrayidx22, align 1
  %conv23 = zext i8 %29 to i32
  %tobool24 = icmp ne i32 %conv23, 0
  br i1 %tobool24, label %if.then26, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %if.then19
  %30 = load i32, i32* %x1, align 4
  %31 = load i32, i32* %y1, align 4
  %32 = load i32, i32* %tox.addr, align 4
  %33 = load i32, i32* %toy.addr, align 4
  %call = call i32 @solve(i32 %30, i32 %31, i32 %32, i32 %33)
  %tobool25 = icmp ne i32 %call, 0
  br i1 %tobool25, label %if.end27, label %if.then26

if.then26:                                        ; preds = %lor.lhs.false, %if.then19
  br label %for.inc

if.end27:                                         ; preds = %lor.lhs.false
  %34 = load i8**, i8*** @cell, align 4
  %35 = load i32, i32* %t, align 4
  %sub = sub nsw i32 %35, 1
  %arrayidx28 = getelementptr inbounds i8*, i8** %34, i32 %sub
  %36 = load i8*, i8** %arrayidx28, align 4
  %37 = load i32, i32* %x.addr, align 4
  %arrayidx29 = getelementptr inbounds i8, i8* %36, i32 %37
  %38 = load i8, i8* %arrayidx29, align 1
  %conv30 = zext i8 %38 to i32
  %or31 = or i32 %conv30, 2
  %conv32 = trunc i32 %or31 to i8
  store i8 %conv32, i8* %arrayidx29, align 1
  %39 = load i8**, i8*** @cell, align 4
  %40 = load i32, i32* %t, align 4
  %arrayidx33 = getelementptr inbounds i8*, i8** %39, i32 %40
  %41 = load i8*, i8** %arrayidx33, align 4
  %42 = load i32, i32* %x.addr, align 4
  %arrayidx34 = getelementptr inbounds i8, i8* %41, i32 %42
  %43 = load i8, i8* %arrayidx34, align 1
  %conv35 = zext i8 %43 to i32
  %or36 = or i32 %conv35, 19
  %conv37 = trunc i32 %or36 to i8
  store i8 %conv37, i8* %arrayidx34, align 1
  %44 = load i8**, i8*** @cell, align 4
  %45 = load i32, i32* %t, align 4
  %add38 = add nsw i32 %45, 1
  %arrayidx39 = getelementptr inbounds i8*, i8** %44, i32 %add38
  %46 = load i8*, i8** %arrayidx39, align 4
  %47 = load i32, i32* %x.addr, align 4
  %arrayidx40 = getelementptr inbounds i8, i8* %46, i32 %47
  %48 = load i8, i8* %arrayidx40, align 1
  %conv41 = zext i8 %48 to i32
  %or42 = or i32 %conv41, 1
  %conv43 = trunc i32 %or42 to i8
  store i8 %conv43, i8* %arrayidx40, align 1
  br label %if.end76

if.else:                                          ; preds = %if.end16
  %49 = load i32, i32* %y1, align 4
  %50 = load i32, i32* %y.addr, align 4
  %cmp44 = icmp eq i32 %49, %50
  br i1 %cmp44, label %if.then46, label %if.end75

if.then46:                                        ; preds = %if.else
  %51 = load i32, i32* %x.addr, align 4
  %52 = load i32, i32* %x1, align 4
  %add47 = add nsw i32 %51, %52
  %div48 = sdiv i32 %add47, 2
  store i32 %div48, i32* %t, align 4
  %53 = load i8**, i8*** @cell, align 4
  %54 = load i32, i32* %y.addr, align 4
  %arrayidx49 = getelementptr inbounds i8*, i8** %53, i32 %54
  %55 = load i8*, i8** %arrayidx49, align 4
  %56 = load i32, i32* %t, align 4
  %arrayidx50 = getelementptr inbounds i8, i8* %55, i32 %56
  %57 = load i8, i8* %arrayidx50, align 1
  %conv51 = zext i8 %57 to i32
  %tobool52 = icmp ne i32 %conv51, 0
  br i1 %tobool52, label %if.then56, label %lor.lhs.false53

lor.lhs.false53:                                  ; preds = %if.then46
  %58 = load i32, i32* %x1, align 4
  %59 = load i32, i32* %y1, align 4
  %60 = load i32, i32* %tox.addr, align 4
  %61 = load i32, i32* %toy.addr, align 4
  %call54 = call i32 @solve(i32 %58, i32 %59, i32 %60, i32 %61)
  %tobool55 = icmp ne i32 %call54, 0
  br i1 %tobool55, label %if.end57, label %if.then56

if.then56:                                        ; preds = %lor.lhs.false53, %if.then46
  br label %for.inc

if.end57:                                         ; preds = %lor.lhs.false53
  %62 = load i8**, i8*** @cell, align 4
  %63 = load i32, i32* %y.addr, align 4
  %arrayidx58 = getelementptr inbounds i8*, i8** %62, i32 %63
  %64 = load i8*, i8** %arrayidx58, align 4
  %65 = load i32, i32* %t, align 4
  %sub59 = sub nsw i32 %65, 1
  %arrayidx60 = getelementptr inbounds i8, i8* %64, i32 %sub59
  %66 = load i8, i8* %arrayidx60, align 1
  %conv61 = zext i8 %66 to i32
  %or62 = or i32 %conv61, 8
  %conv63 = trunc i32 %or62 to i8
  store i8 %conv63, i8* %arrayidx60, align 1
  %67 = load i8**, i8*** @cell, align 4
  %68 = load i32, i32* %y.addr, align 4
  %arrayidx64 = getelementptr inbounds i8*, i8** %67, i32 %68
  %69 = load i8*, i8** %arrayidx64, align 4
  %70 = load i32, i32* %t, align 4
  %arrayidx65 = getelementptr inbounds i8, i8* %69, i32 %70
  %71 = load i8, i8* %arrayidx65, align 1
  %conv66 = zext i8 %71 to i32
  %or67 = or i32 %conv66, 28
  %conv68 = trunc i32 %or67 to i8
  store i8 %conv68, i8* %arrayidx65, align 1
  %72 = load i8**, i8*** @cell, align 4
  %73 = load i32, i32* %y.addr, align 4
  %arrayidx69 = getelementptr inbounds i8*, i8** %72, i32 %73
  %74 = load i8*, i8** %arrayidx69, align 4
  %75 = load i32, i32* %t, align 4
  %add70 = add nsw i32 %75, 1
  %arrayidx71 = getelementptr inbounds i8, i8* %74, i32 %add70
  %76 = load i8, i8* %arrayidx71, align 1
  %conv72 = zext i8 %76 to i32
  %or73 = or i32 %conv72, 4
  %conv74 = trunc i32 %or73 to i8
  store i8 %conv74, i8* %arrayidx71, align 1
  br label %if.end75

if.end75:                                         ; preds = %if.end57, %if.else
  br label %if.end76

if.end76:                                         ; preds = %if.end75, %if.end27
  store i32 1, i32* %retval, align 4
  br label %return

for.inc:                                          ; preds = %if.then56, %if.then26, %if.then15
  %77 = load i32, i32* %i, align 4
  %inc = add nsw i32 %77, 1
  store i32 %inc, i32* %i, align 4
  br label %for.cond

for.end:                                          ; preds = %for.cond
  %78 = load i8**, i8*** @cell, align 4
  %79 = load i32, i32* %y.addr, align 4
  %arrayidx77 = getelementptr inbounds i8*, i8** %78, i32 %79
  %80 = load i8*, i8** %arrayidx77, align 4
  %81 = load i32, i32* %x.addr, align 4
  %arrayidx78 = getelementptr inbounds i8, i8* %80, i32 %81
  %82 = load i8, i8* %arrayidx78, align 1
  %conv79 = zext i8 %82 to i32
  %and = and i32 %conv79, -17
  %conv80 = trunc i32 %and to i8
  store i8 %conv80, i8* %arrayidx78, align 1
  store i32 0, i32* %retval, align 4
  br label %return

return:                                           ; preds = %for.end, %if.end76, %if.then
  %83 = load i32, i32* %retval, align 4
  ret i32 %83
}

; Function Attrs: noinline nounwind optnone
define hidden void @make_maze() #0 {
entry:
  %i = alloca i32, align 4
  %j = alloca i32, align 4
  %h2 = alloca i32, align 4
  %w2 = alloca i32, align 4
  %p = alloca i8**, align 4
  %0 = load i32, i32* @h, align 4
  %mul = mul nsw i32 2, %0
  %add = add nsw i32 %mul, 2
  store i32 %add, i32* %h2, align 4
  %1 = load i32, i32* @w, align 4
  %mul1 = mul nsw i32 2, %1
  %add2 = add nsw i32 %mul1, 2
  store i32 %add2, i32* %w2, align 4
  %2 = load i32, i32* %h2, align 4
  %add3 = add nsw i32 %2, 2
  %mul4 = mul i32 4, %add3
  %3 = load i32, i32* %w2, align 4
  %4 = load i32, i32* %h2, align 4
  %mul5 = mul nsw i32 %3, %4
  %add6 = add i32 %mul4, %mul5
  %add7 = add i32 %add6, 1
  %call = call noalias i8* @calloc(i32 %add7, i32 1)
  %5 = bitcast i8* %call to i8**
  store i8** %5, i8*** %p, align 4
  %6 = load i8**, i8*** %p, align 4
  %7 = load i32, i32* %h2, align 4
  %add.ptr = getelementptr inbounds i8*, i8** %6, i32 %7
  %add.ptr8 = getelementptr inbounds i8*, i8** %add.ptr, i32 2
  %8 = bitcast i8** %add.ptr8 to i8*
  %add.ptr9 = getelementptr inbounds i8, i8* %8, i32 1
  %9 = load i8**, i8*** %p, align 4
  %arrayidx = getelementptr inbounds i8*, i8** %9, i32 1
  store i8* %add.ptr9, i8** %arrayidx, align 4
  store i32 2, i32* %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %10 = load i32, i32* %i, align 4
  %11 = load i32, i32* %h2, align 4
  %cmp = icmp sle i32 %10, %11
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %12 = load i8**, i8*** %p, align 4
  %13 = load i32, i32* %i, align 4
  %sub = sub nsw i32 %13, 1
  %arrayidx10 = getelementptr inbounds i8*, i8** %12, i32 %sub
  %14 = load i8*, i8** %arrayidx10, align 4
  %15 = load i32, i32* %w2, align 4
  %add.ptr11 = getelementptr inbounds i8, i8* %14, i32 %15
  %16 = load i8**, i8*** %p, align 4
  %17 = load i32, i32* %i, align 4
  %arrayidx12 = getelementptr inbounds i8*, i8** %16, i32 %17
  store i8* %add.ptr11, i8** %arrayidx12, align 4
  br label %for.inc

for.inc:                                          ; preds = %for.body
  %18 = load i32, i32* %i, align 4
  %inc = add nsw i32 %18, 1
  store i32 %inc, i32* %i, align 4
  br label %for.cond

for.end:                                          ; preds = %for.cond
  %19 = load i8**, i8*** %p, align 4
  %20 = load i32, i32* %h2, align 4
  %arrayidx13 = getelementptr inbounds i8*, i8** %19, i32 %20
  %21 = load i8*, i8** %arrayidx13, align 4
  %22 = load i8**, i8*** %p, align 4
  %arrayidx14 = getelementptr inbounds i8*, i8** %22, i32 0
  store i8* %21, i8** %arrayidx14, align 4
  %23 = load i8**, i8*** %p, align 4
  %arrayidx15 = getelementptr inbounds i8*, i8** %23, i32 1
  store i8** %arrayidx15, i8*** @cell, align 4
  store i32 -1, i32* %i, align 4
  br label %for.cond16

for.cond16:                                       ; preds = %for.inc26, %for.end
  %24 = load i32, i32* %i, align 4
  %25 = load i32, i32* @h, align 4
  %mul17 = mul nsw i32 2, %25
  %add18 = add nsw i32 %mul17, 1
  %cmp19 = icmp sle i32 %24, %add18
  br i1 %cmp19, label %for.body20, label %for.end28

for.body20:                                       ; preds = %for.cond16
  %26 = load i8**, i8*** @cell, align 4
  %27 = load i32, i32* %i, align 4
  %arrayidx21 = getelementptr inbounds i8*, i8** %26, i32 %27
  %28 = load i8*, i8** %arrayidx21, align 4
  %29 = load i32, i32* %w2, align 4
  %sub22 = sub nsw i32 %29, 1
  %arrayidx23 = getelementptr inbounds i8, i8* %28, i32 %sub22
  store i8 16, i8* %arrayidx23, align 1
  %30 = load i8**, i8*** @cell, align 4
  %31 = load i32, i32* %i, align 4
  %arrayidx24 = getelementptr inbounds i8*, i8** %30, i32 %31
  %32 = load i8*, i8** %arrayidx24, align 4
  %arrayidx25 = getelementptr inbounds i8, i8* %32, i32 -1
  store i8 16, i8* %arrayidx25, align 1
  br label %for.inc26

for.inc26:                                        ; preds = %for.body20
  %33 = load i32, i32* %i, align 4
  %inc27 = add nsw i32 %33, 1
  store i32 %inc27, i32* %i, align 4
  br label %for.cond16

for.end28:                                        ; preds = %for.cond16
  store i32 0, i32* %j, align 4
  br label %for.cond29

for.cond29:                                       ; preds = %for.inc38, %for.end28
  %34 = load i32, i32* %j, align 4
  %35 = load i32, i32* @w, align 4
  %mul30 = mul nsw i32 2, %35
  %cmp31 = icmp sle i32 %34, %mul30
  br i1 %cmp31, label %for.body32, label %for.end40

for.body32:                                       ; preds = %for.cond29
  %36 = load i8**, i8*** @cell, align 4
  %37 = load i32, i32* %h2, align 4
  %sub33 = sub nsw i32 %37, 1
  %arrayidx34 = getelementptr inbounds i8*, i8** %36, i32 %sub33
  %38 = load i8*, i8** %arrayidx34, align 4
  %39 = load i32, i32* %j, align 4
  %arrayidx35 = getelementptr inbounds i8, i8* %38, i32 %39
  store i8 16, i8* %arrayidx35, align 1
  %40 = load i8**, i8*** @cell, align 4
  %arrayidx36 = getelementptr inbounds i8*, i8** %40, i32 -1
  %41 = load i8*, i8** %arrayidx36, align 4
  %42 = load i32, i32* %j, align 4
  %arrayidx37 = getelementptr inbounds i8, i8* %41, i32 %42
  store i8 16, i8* %arrayidx37, align 1
  br label %for.inc38

for.inc38:                                        ; preds = %for.body32
  %43 = load i32, i32* %j, align 4
  %inc39 = add nsw i32 %43, 1
  store i32 %inc39, i32* %j, align 4
  br label %for.cond29

for.end40:                                        ; preds = %for.cond29
  store i32 0, i32* %i, align 4
  br label %for.cond41

for.cond41:                                       ; preds = %for.inc55, %for.end40
  %44 = load i32, i32* %i, align 4
  %45 = load i32, i32* @h, align 4
  %cmp42 = icmp sle i32 %44, %45
  br i1 %cmp42, label %for.body43, label %for.end57

for.body43:                                       ; preds = %for.cond41
  store i32 0, i32* %j, align 4
  br label %for.cond44

for.cond44:                                       ; preds = %for.inc52, %for.body43
  %46 = load i32, i32* %j, align 4
  %47 = load i32, i32* @w, align 4
  %mul45 = mul nsw i32 2, %47
  %cmp46 = icmp sle i32 %46, %mul45
  br i1 %cmp46, label %for.body47, label %for.end54

for.body47:                                       ; preds = %for.cond44
  %48 = load i8**, i8*** @cell, align 4
  %49 = load i32, i32* %i, align 4
  %mul48 = mul nsw i32 2, %49
  %arrayidx49 = getelementptr inbounds i8*, i8** %48, i32 %mul48
  %50 = load i8*, i8** %arrayidx49, align 4
  %51 = load i32, i32* %j, align 4
  %arrayidx50 = getelementptr inbounds i8, i8* %50, i32 %51
  %52 = load i8, i8* %arrayidx50, align 1
  %conv = zext i8 %52 to i32
  %or = or i32 %conv, 12
  %conv51 = trunc i32 %or to i8
  store i8 %conv51, i8* %arrayidx50, align 1
  br label %for.inc52

for.inc52:                                        ; preds = %for.body47
  %53 = load i32, i32* %j, align 4
  %inc53 = add nsw i32 %53, 1
  store i32 %inc53, i32* %j, align 4
  br label %for.cond44

for.end54:                                        ; preds = %for.cond44
  br label %for.inc55

for.inc55:                                        ; preds = %for.end54
  %54 = load i32, i32* %i, align 4
  %inc56 = add nsw i32 %54, 1
  store i32 %inc56, i32* %i, align 4
  br label %for.cond41

for.end57:                                        ; preds = %for.cond41
  store i32 0, i32* %i, align 4
  br label %for.cond58

for.cond58:                                       ; preds = %for.inc76, %for.end57
  %55 = load i32, i32* %i, align 4
  %56 = load i32, i32* @h, align 4
  %mul59 = mul nsw i32 2, %56
  %cmp60 = icmp sle i32 %55, %mul59
  br i1 %cmp60, label %for.body62, label %for.end78

for.body62:                                       ; preds = %for.cond58
  store i32 0, i32* %j, align 4
  br label %for.cond63

for.cond63:                                       ; preds = %for.inc73, %for.body62
  %57 = load i32, i32* %j, align 4
  %58 = load i32, i32* @w, align 4
  %cmp64 = icmp sle i32 %57, %58
  br i1 %cmp64, label %for.body66, label %for.end75

for.body66:                                       ; preds = %for.cond63
  %59 = load i8**, i8*** @cell, align 4
  %60 = load i32, i32* %i, align 4
  %arrayidx67 = getelementptr inbounds i8*, i8** %59, i32 %60
  %61 = load i8*, i8** %arrayidx67, align 4
  %62 = load i32, i32* %j, align 4
  %mul68 = mul nsw i32 2, %62
  %arrayidx69 = getelementptr inbounds i8, i8* %61, i32 %mul68
  %63 = load i8, i8* %arrayidx69, align 1
  %conv70 = zext i8 %63 to i32
  %or71 = or i32 %conv70, 3
  %conv72 = trunc i32 %or71 to i8
  store i8 %conv72, i8* %arrayidx69, align 1
  br label %for.inc73

for.inc73:                                        ; preds = %for.body66
  %64 = load i32, i32* %j, align 4
  %inc74 = add nsw i32 %64, 1
  store i32 %inc74, i32* %j, align 4
  br label %for.cond63

for.end75:                                        ; preds = %for.cond63
  br label %for.inc76

for.inc76:                                        ; preds = %for.end75
  %65 = load i32, i32* %i, align 4
  %inc77 = add nsw i32 %65, 1
  store i32 %inc77, i32* %i, align 4
  br label %for.cond58

for.end78:                                        ; preds = %for.cond58
  store i32 0, i32* %j, align 4
  br label %for.cond79

for.cond79:                                       ; preds = %for.inc94, %for.end78
  %66 = load i32, i32* %j, align 4
  %67 = load i32, i32* @w, align 4
  %mul80 = mul nsw i32 2, %67
  %cmp81 = icmp sle i32 %66, %mul80
  br i1 %cmp81, label %for.body83, label %for.end96

for.body83:                                       ; preds = %for.cond79
  %68 = load i8**, i8*** @cell, align 4
  %arrayidx84 = getelementptr inbounds i8*, i8** %68, i32 0
  %69 = load i8*, i8** %arrayidx84, align 4
  %70 = load i32, i32* %j, align 4
  %arrayidx85 = getelementptr inbounds i8, i8* %69, i32 %70
  %71 = load i8, i8* %arrayidx85, align 1
  %conv86 = zext i8 %71 to i32
  %and = and i32 %conv86, -2
  %conv87 = trunc i32 %and to i8
  store i8 %conv87, i8* %arrayidx85, align 1
  %72 = load i8**, i8*** @cell, align 4
  %73 = load i32, i32* @h, align 4
  %mul88 = mul nsw i32 2, %73
  %arrayidx89 = getelementptr inbounds i8*, i8** %72, i32 %mul88
  %74 = load i8*, i8** %arrayidx89, align 4
  %75 = load i32, i32* %j, align 4
  %arrayidx90 = getelementptr inbounds i8, i8* %74, i32 %75
  %76 = load i8, i8* %arrayidx90, align 1
  %conv91 = zext i8 %76 to i32
  %and92 = and i32 %conv91, -3
  %conv93 = trunc i32 %and92 to i8
  store i8 %conv93, i8* %arrayidx90, align 1
  br label %for.inc94

for.inc94:                                        ; preds = %for.body83
  %77 = load i32, i32* %j, align 4
  %inc95 = add nsw i32 %77, 1
  store i32 %inc95, i32* %j, align 4
  br label %for.cond79

for.end96:                                        ; preds = %for.cond79
  store i32 0, i32* %i, align 4
  br label %for.cond97

for.cond97:                                       ; preds = %for.inc113, %for.end96
  %78 = load i32, i32* %i, align 4
  %79 = load i32, i32* @h, align 4
  %mul98 = mul nsw i32 2, %79
  %cmp99 = icmp sle i32 %78, %mul98
  br i1 %cmp99, label %for.body101, label %for.end115

for.body101:                                      ; preds = %for.cond97
  %80 = load i8**, i8*** @cell, align 4
  %81 = load i32, i32* %i, align 4
  %arrayidx102 = getelementptr inbounds i8*, i8** %80, i32 %81
  %82 = load i8*, i8** %arrayidx102, align 4
  %arrayidx103 = getelementptr inbounds i8, i8* %82, i32 0
  %83 = load i8, i8* %arrayidx103, align 1
  %conv104 = zext i8 %83 to i32
  %and105 = and i32 %conv104, -5
  %conv106 = trunc i32 %and105 to i8
  store i8 %conv106, i8* %arrayidx103, align 1
  %84 = load i8**, i8*** @cell, align 4
  %85 = load i32, i32* %i, align 4
  %arrayidx107 = getelementptr inbounds i8*, i8** %84, i32 %85
  %86 = load i8*, i8** %arrayidx107, align 4
  %87 = load i32, i32* @w, align 4
  %mul108 = mul nsw i32 2, %87
  %arrayidx109 = getelementptr inbounds i8, i8* %86, i32 %mul108
  %88 = load i8, i8* %arrayidx109, align 1
  %conv110 = zext i8 %88 to i32
  %and111 = and i32 %conv110, -9
  %conv112 = trunc i32 %and111 to i8
  store i8 %conv112, i8* %arrayidx109, align 1
  br label %for.inc113

for.inc113:                                       ; preds = %for.body101
  %89 = load i32, i32* %i, align 4
  %inc114 = add nsw i32 %89, 1
  store i32 %inc114, i32* %i, align 4
  br label %for.cond97

for.end115:                                       ; preds = %for.cond97
  %90 = load i32, i32* @w, align 4
  %91 = load i32, i32* @h, align 4
  %mul116 = mul nsw i32 %90, %91
  store i32 %mul116, i32* @avail, align 4
  %call117 = call i32 @irand(i32 2)
  %mul118 = mul nsw i32 %call117, 2
  %add119 = add nsw i32 %mul118, 1
  %92 = load i32, i32* @h, align 4
  %call120 = call i32 @irand(i32 %92)
  %mul121 = mul nsw i32 %call120, 2
  %add122 = add nsw i32 %mul121, 1
  call void @walk(i32 %add119, i32 %add122)
  store i32 0, i32* %i, align 4
  br label %for.cond123

for.cond123:                                      ; preds = %for.inc141, %for.end115
  %93 = load i32, i32* %i, align 4
  %94 = load i32, i32* @h, align 4
  %mul124 = mul nsw i32 2, %94
  %cmp125 = icmp sle i32 %93, %mul124
  br i1 %cmp125, label %for.body127, label %for.end143

for.body127:                                      ; preds = %for.cond123
  store i32 0, i32* %j, align 4
  br label %for.cond128

for.cond128:                                      ; preds = %for.inc138, %for.body127
  %95 = load i32, i32* %j, align 4
  %96 = load i32, i32* @w, align 4
  %mul129 = mul nsw i32 2, %96
  %cmp130 = icmp sle i32 %95, %mul129
  br i1 %cmp130, label %for.body132, label %for.end140

for.body132:                                      ; preds = %for.cond128
  %97 = load i8**, i8*** @cell, align 4
  %98 = load i32, i32* %i, align 4
  %arrayidx133 = getelementptr inbounds i8*, i8** %97, i32 %98
  %99 = load i8*, i8** %arrayidx133, align 4
  %100 = load i32, i32* %j, align 4
  %arrayidx134 = getelementptr inbounds i8, i8* %99, i32 %100
  %101 = load i8, i8* %arrayidx134, align 1
  %conv135 = zext i8 %101 to i32
  %and136 = and i32 %conv135, -17
  %conv137 = trunc i32 %and136 to i8
  store i8 %conv137, i8* %arrayidx134, align 1
  br label %for.inc138

for.inc138:                                       ; preds = %for.body132
  %102 = load i32, i32* %j, align 4
  %inc139 = add nsw i32 %102, 1
  store i32 %inc139, i32* %j, align 4
  br label %for.cond128

for.end140:                                       ; preds = %for.cond128
  br label %for.inc141

for.inc141:                                       ; preds = %for.end140
  %103 = load i32, i32* %i, align 4
  %inc142 = add nsw i32 %103, 1
  store i32 %inc142, i32* %i, align 4
  br label %for.cond123

for.end143:                                       ; preds = %for.cond123
  %104 = load i32, i32* @w, align 4
  %mul144 = mul nsw i32 2, %104
  %sub145 = sub nsw i32 %mul144, 1
  %105 = load i32, i32* @h, align 4
  %mul146 = mul nsw i32 2, %105
  %sub147 = sub nsw i32 %mul146, 1
  %call148 = call i32 @solve(i32 1, i32 1, i32 %sub145, i32 %sub147)
  call void @show()
  ret void
}

declare noalias i8* @calloc(i32 %0, i32 %1) #1

; Function Attrs: noinline nounwind optnone
define hidden i32 @__main_argc_argv(i32 %c, i8** %v) #0 {
entry:
  %retval = alloca i32, align 4
  %c.addr = alloca i32, align 4
  %v.addr = alloca i8**, align 4
  store i32 0, i32* %retval, align 4
  store i32 %c, i32* %c.addr, align 4
  store i8** %v, i8*** %v.addr, align 4
  %call = call i8* @setlocale(i32 6, i8* getelementptr inbounds ([1 x i8], [1 x i8]* @.str.3, i32 0, i32 0))
  %0 = load i32, i32* %c.addr, align 4
  %cmp = icmp slt i32 %0, 2
  br i1 %cmp, label %if.then, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %entry
  %1 = load i8**, i8*** %v.addr, align 4
  %arrayidx = getelementptr inbounds i8*, i8** %1, i32 1
  %2 = load i8*, i8** %arrayidx, align 4
  %call1 = call i32 @atoi(i8* %2)
  store i32 %call1, i32* @w, align 4
  %cmp2 = icmp sle i32 %call1, 0
  br i1 %cmp2, label %if.then, label %if.end

if.then:                                          ; preds = %lor.lhs.false, %entry
  store i32 16, i32* @w, align 4
  br label %if.end

if.end:                                           ; preds = %if.then, %lor.lhs.false
  %3 = load i32, i32* %c.addr, align 4
  %cmp3 = icmp slt i32 %3, 3
  br i1 %cmp3, label %if.then8, label %lor.lhs.false4

lor.lhs.false4:                                   ; preds = %if.end
  %4 = load i8**, i8*** %v.addr, align 4
  %arrayidx5 = getelementptr inbounds i8*, i8** %4, i32 2
  %5 = load i8*, i8** %arrayidx5, align 4
  %call6 = call i32 @atoi(i8* %5)
  store i32 %call6, i32* @h, align 4
  %cmp7 = icmp sle i32 %call6, 0
  br i1 %cmp7, label %if.then8, label %if.end9

if.then8:                                         ; preds = %lor.lhs.false4, %if.end
  store i32 8, i32* @h, align 4
  br label %if.end9

if.end9:                                          ; preds = %if.then8, %lor.lhs.false4
  call void @make_maze()
  ret i32 0
}

declare i8* @setlocale(i32 %0, i8* %1) #1

declare i32 @atoi(i8* %0) #1

attributes #0 = { noinline nounwind optnone "correctly-rounded-divide-sqrt-fp-math"="false" "disable-tail-calls"="false" "frame-pointer"="none" "less-precise-fpmad"="false" "min-legal-vector-width"="0" "no-infs-fp-math"="false" "no-jump-tables"="false" "no-nans-fp-math"="false" "no-signed-zeros-fp-math"="false" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="generic" "unsafe-fp-math"="false" "use-soft-float"="false" }
attributes #1 = { "correctly-rounded-divide-sqrt-fp-math"="false" "disable-tail-calls"="false" "frame-pointer"="none" "less-precise-fpmad"="false" "no-infs-fp-math"="false" "no-nans-fp-math"="false" "no-signed-zeros-fp-math"="false" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="generic" "unsafe-fp-math"="false" "use-soft-float"="false" }
attributes #2 = { argmemonly nounwind willreturn }

!llvm.module.flags = !{!0}
!llvm.ident = !{!1}

!0 = !{i32 1, !"wchar_size", i32 4}
!1 = !{!"clang version 11.0.0 (https://github.com/Jacarte/llvm-project.git 0f6dea67136cc1e0b3d200eb2bb165628970c44b)"}

; extracted candidates

; *****
; For LLVM instruction:
;  %0 = load i32, i32* @h, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %mul = mul nsw i32 2, %0
; Looking for a replacement for:
%0:i32 = var
%1:i32 = mulnsw 2:i32, %0
infer %1

; *****
; For LLVM instruction:
;  %add = add nsw i32 %mul, 2
; Looking for a replacement for:
%0:i32 = var
%1:i32 = mulnsw 2:i32, %0
%2:i32 = addnsw 2:i32, %1
infer %2

; *****
; For LLVM instruction:
;  %1 = load i32, i32* @w, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %mul1 = mul nsw i32 2, %1
; Looking for a replacement for:
%0:i32 = var
%1:i32 = mulnsw 2:i32, %0
infer %1

; *****
; For LLVM instruction:
;  %add2 = add nsw i32 %mul1, 2
; Looking for a replacement for:
%0:i32 = var
%1:i32 = mulnsw 2:i32, %0
%2:i32 = addnsw 2:i32, %1
infer %2

; *****
; For LLVM instruction:
;  %2 = load i32, i32* %h2, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %add3 = add nsw i32 %2, 2
; Looking for a replacement for:
%0:i32 = var
%1:i32 = addnsw 2:i32, %0
infer %1

; *****
; For LLVM instruction:
;  %mul4 = mul i32 4, %add3
; Looking for a replacement for:
%0:i32 = var
%1:i32 = addnsw 2:i32, %0
%2:i32 = mul 4:i32, %1
infer %2

; *****
; For LLVM instruction:
;  %3 = load i32, i32* %w2, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %4 = load i32, i32* %h2, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %mul5 = mul nsw i32 %3, %4
; Looking for a replacement for:
%0:i32 = var
%1:i32 = var
%2:i32 = mulnsw %0, %1
infer %2

; *****
; For LLVM instruction:
;  %add6 = add i32 %mul4, %mul5
; Looking for a replacement for:
%0:i32 = var
%1:i32 = addnsw 2:i32, %0
%2:i32 = mul 4:i32, %1
%3:i32 = var
%4:i32 = var
%5:i32 = mulnsw %3, %4
%6:i32 = add %2, %5
infer %6

; *****
; For LLVM instruction:
;  %add7 = add i32 %add6, 1
; Looking for a replacement for:
%0:i32 = var
%1:i32 = addnsw 2:i32, %0
%2:i32 = mul 4:i32, %1
%3:i32 = var
%4:i32 = var
%5:i32 = mulnsw %3, %4
%6:i32 = add %2, %5
%7:i32 = add 1:i32, %6
infer %7

; *****
; For LLVM instruction:
;  %7 = load i32, i32* %h2, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %10 = load i32, i32* %i, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %11 = load i32, i32* %h2, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %cmp = icmp sle i32 %10, %11
; Looking for a replacement for:
%0:i32 = var
%1:i32 = var
%2:i1 = sle %0, %1
infer %2

; *****
; For LLVM instruction:
;  %13 = load i32, i32* %i, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %sub = sub nsw i32 %13, 1
; Looking for a replacement for:
%0:i32 = var
%1:i32 = subnsw %0, 1:i32
infer %1

; *****
; For LLVM instruction:
;  %15 = load i32, i32* %w2, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %17 = load i32, i32* %i, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %18 = load i32, i32* %i, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %inc = add nsw i32 %18, 1
; Looking for a replacement for:
%0:i32 = var
%1:i32 = addnsw 1:i32, %0
infer %1

; *****
; For LLVM instruction:
;  %20 = load i32, i32* %h2, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %24 = load i32, i32* %i, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %25 = load i32, i32* @h, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %mul17 = mul nsw i32 2, %25
; Looking for a replacement for:
%0:i32 = var
%1:i32 = mulnsw 2:i32, %0
infer %1

; *****
; For LLVM instruction:
;  %add18 = add nsw i32 %mul17, 1
; Looking for a replacement for:
%0:i32 = var
%1:i32 = mulnsw 2:i32, %0
%2:i32 = addnsw 1:i32, %1
infer %2

; *****
; For LLVM instruction:
;  %cmp19 = icmp sle i32 %24, %add18
; Looking for a replacement for:
%0:i32 = var
%1:i32 = var
%2:i32 = mulnsw 2:i32, %1
%3:i32 = addnsw 1:i32, %2
%4:i1 = sle %0, %3
infer %4

; *****
; For LLVM instruction:
;  %27 = load i32, i32* %i, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %29 = load i32, i32* %w2, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %sub22 = sub nsw i32 %29, 1
; Looking for a replacement for:
%0:i32 = var
%1:i32 = subnsw %0, 1:i32
infer %1

; *****
; For LLVM instruction:
;  %31 = load i32, i32* %i, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %33 = load i32, i32* %i, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %inc27 = add nsw i32 %33, 1
; Looking for a replacement for:
%0:i32 = var
%1:i32 = addnsw 1:i32, %0
infer %1

; *****
; For LLVM instruction:
;  %34 = load i32, i32* %j, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %35 = load i32, i32* @w, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %mul30 = mul nsw i32 2, %35
; Looking for a replacement for:
%0:i32 = var
%1:i32 = mulnsw 2:i32, %0
infer %1

; *****
; For LLVM instruction:
;  %cmp31 = icmp sle i32 %34, %mul30
; Looking for a replacement for:
%0:i32 = var
%1:i32 = var
%2:i32 = mulnsw 2:i32, %1
%3:i1 = sle %0, %2
infer %3

; *****
; For LLVM instruction:
;  %37 = load i32, i32* %h2, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %sub33 = sub nsw i32 %37, 1
; Looking for a replacement for:
%0:i32 = var
%1:i32 = subnsw %0, 1:i32
infer %1

; *****
; For LLVM instruction:
;  %39 = load i32, i32* %j, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %42 = load i32, i32* %j, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %43 = load i32, i32* %j, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %inc39 = add nsw i32 %43, 1
; Looking for a replacement for:
%0:i32 = var
%1:i32 = addnsw 1:i32, %0
infer %1

; *****
; For LLVM instruction:
;  %44 = load i32, i32* %i, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %45 = load i32, i32* @h, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %cmp42 = icmp sle i32 %44, %45
; Looking for a replacement for:
%0:i32 = var
%1:i32 = var
%2:i1 = sle %0, %1
infer %2

; *****
; For LLVM instruction:
;  %46 = load i32, i32* %j, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %47 = load i32, i32* @w, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %mul45 = mul nsw i32 2, %47
; Looking for a replacement for:
%0:i32 = var
%1:i32 = mulnsw 2:i32, %0
infer %1

; *****
; For LLVM instruction:
;  %cmp46 = icmp sle i32 %46, %mul45
; Looking for a replacement for:
%0:i32 = var
%1:i32 = var
%2:i32 = mulnsw 2:i32, %1
%3:i1 = sle %0, %2
infer %3

; *****
; For LLVM instruction:
;  %49 = load i32, i32* %i, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %mul48 = mul nsw i32 2, %49
; Looking for a replacement for:
%0:i32 = var
%1:i32 = mulnsw 2:i32, %0
infer %1

; *****
; For LLVM instruction:
;  %51 = load i32, i32* %j, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %52 = load i8, i8* %arrayidx50, align 1
; Looking for a replacement for:
%0:i8 = var
infer %0 (demandedBits=11110011)

; *****
; For LLVM instruction:
;  %conv = zext i8 %52 to i32
; Looking for a replacement for:
%0:i8 = var
%1:i32 = zext %0
infer %1 (demandedBits=00000000000000000000000011110011)

; *****
; For LLVM instruction:
;  %or = or i32 %conv, 12
; Looking for a replacement for:
%0:i8 = var
%1:i32 = zext %0
%2:i32 = or 12:i32, %1
infer %2 (demandedBits=00000000000000000000000011111111)

; *****
; For LLVM instruction:
;  %conv51 = trunc i32 %or to i8
; Looking for a replacement for:
%0:i8 = var
%1:i32 = zext %0
%2:i32 = or 12:i32, %1
%3:i8 = trunc %2
infer %3

; *****
; For LLVM instruction:
;  %53 = load i32, i32* %j, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %inc53 = add nsw i32 %53, 1
; Looking for a replacement for:
%0:i32 = var
%1:i32 = addnsw 1:i32, %0
infer %1

; *****
; For LLVM instruction:
;  %54 = load i32, i32* %i, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %inc56 = add nsw i32 %54, 1
; Looking for a replacement for:
%0:i32 = var
%1:i32 = addnsw 1:i32, %0
infer %1

; *****
; For LLVM instruction:
;  %55 = load i32, i32* %i, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %56 = load i32, i32* @h, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %mul59 = mul nsw i32 2, %56
; Looking for a replacement for:
%0:i32 = var
%1:i32 = mulnsw 2:i32, %0
infer %1

; *****
; For LLVM instruction:
;  %cmp60 = icmp sle i32 %55, %mul59
; Looking for a replacement for:
%0:i32 = var
%1:i32 = var
%2:i32 = mulnsw 2:i32, %1
%3:i1 = sle %0, %2
infer %3

; *****
; For LLVM instruction:
;  %57 = load i32, i32* %j, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %58 = load i32, i32* @w, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %cmp64 = icmp sle i32 %57, %58
; Looking for a replacement for:
%0:i32 = var
%1:i32 = var
%2:i1 = sle %0, %1
infer %2

; *****
; For LLVM instruction:
;  %60 = load i32, i32* %i, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %62 = load i32, i32* %j, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %mul68 = mul nsw i32 2, %62
; Looking for a replacement for:
%0:i32 = var
%1:i32 = mulnsw 2:i32, %0
infer %1

; *****
; For LLVM instruction:
;  %63 = load i8, i8* %arrayidx69, align 1
; Looking for a replacement for:
%0:i8 = var
infer %0 (demandedBits=11111100)

; *****
; For LLVM instruction:
;  %conv70 = zext i8 %63 to i32
; Looking for a replacement for:
%0:i8 = var
%1:i32 = zext %0
infer %1 (demandedBits=00000000000000000000000011111100)

; *****
; For LLVM instruction:
;  %or71 = or i32 %conv70, 3
; Looking for a replacement for:
%0:i8 = var
%1:i32 = zext %0
%2:i32 = or 3:i32, %1
infer %2 (demandedBits=00000000000000000000000011111111)

; *****
; For LLVM instruction:
;  %conv72 = trunc i32 %or71 to i8
; Looking for a replacement for:
%0:i8 = var
%1:i32 = zext %0
%2:i32 = or 3:i32, %1
%3:i8 = trunc %2
infer %3

; *****
; For LLVM instruction:
;  %64 = load i32, i32* %j, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %inc74 = add nsw i32 %64, 1
; Looking for a replacement for:
%0:i32 = var
%1:i32 = addnsw 1:i32, %0
infer %1

; *****
; For LLVM instruction:
;  %65 = load i32, i32* %i, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %inc77 = add nsw i32 %65, 1
; Looking for a replacement for:
%0:i32 = var
%1:i32 = addnsw 1:i32, %0
infer %1

; *****
; For LLVM instruction:
;  %66 = load i32, i32* %j, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %67 = load i32, i32* @w, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %mul80 = mul nsw i32 2, %67
; Looking for a replacement for:
%0:i32 = var
%1:i32 = mulnsw 2:i32, %0
infer %1

; *****
; For LLVM instruction:
;  %cmp81 = icmp sle i32 %66, %mul80
; Looking for a replacement for:
%0:i32 = var
%1:i32 = var
%2:i32 = mulnsw 2:i32, %1
%3:i1 = sle %0, %2
infer %3

; *****
; For LLVM instruction:
;  %70 = load i32, i32* %j, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %71 = load i8, i8* %arrayidx85, align 1
; Looking for a replacement for:
%0:i8 = var
infer %0 (demandedBits=11111110)

; *****
; For LLVM instruction:
;  %conv86 = zext i8 %71 to i32
; Looking for a replacement for:
%0:i8 = var
%1:i32 = zext %0
infer %1 (demandedBits=00000000000000000000000011111110)

; *****
; For LLVM instruction:
;  %and = and i32 %conv86, -2
; Looking for a replacement for:
%0:i8 = var
%1:i32 = zext %0
%2:i32 = and 4294967294:i32, %1
infer %2 (demandedBits=00000000000000000000000011111111)

; *****
; For LLVM instruction:
;  %conv87 = trunc i32 %and to i8
; Looking for a replacement for:
%0:i8 = var
%1:i32 = zext %0
%2:i32 = and 4294967294:i32, %1
%3:i8 = trunc %2
infer %3

; *****
; For LLVM instruction:
;  %73 = load i32, i32* @h, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %mul88 = mul nsw i32 2, %73
; Looking for a replacement for:
%0:i32 = var
%1:i32 = mulnsw 2:i32, %0
infer %1

; *****
; For LLVM instruction:
;  %75 = load i32, i32* %j, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %76 = load i8, i8* %arrayidx90, align 1
; Looking for a replacement for:
%0:i8 = var
infer %0 (demandedBits=11111101)

; *****
; For LLVM instruction:
;  %conv91 = zext i8 %76 to i32
; Looking for a replacement for:
%0:i8 = var
%1:i32 = zext %0
infer %1 (demandedBits=00000000000000000000000011111101)

; *****
; For LLVM instruction:
;  %and92 = and i32 %conv91, -3
; Looking for a replacement for:
%0:i8 = var
%1:i32 = zext %0
%2:i32 = and 4294967293:i32, %1
infer %2 (demandedBits=00000000000000000000000011111111)

; *****
; For LLVM instruction:
;  %conv93 = trunc i32 %and92 to i8
; Looking for a replacement for:
%0:i8 = var
%1:i32 = zext %0
%2:i32 = and 4294967293:i32, %1
%3:i8 = trunc %2
infer %3

; *****
; For LLVM instruction:
;  %77 = load i32, i32* %j, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %inc95 = add nsw i32 %77, 1
; Looking for a replacement for:
%0:i32 = var
%1:i32 = addnsw 1:i32, %0
infer %1

; *****
; For LLVM instruction:
;  %78 = load i32, i32* %i, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %79 = load i32, i32* @h, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %mul98 = mul nsw i32 2, %79
; Looking for a replacement for:
%0:i32 = var
%1:i32 = mulnsw 2:i32, %0
infer %1

; *****
; For LLVM instruction:
;  %cmp99 = icmp sle i32 %78, %mul98
; Looking for a replacement for:
%0:i32 = var
%1:i32 = var
%2:i32 = mulnsw 2:i32, %1
%3:i1 = sle %0, %2
infer %3

; *****
; For LLVM instruction:
;  %81 = load i32, i32* %i, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %83 = load i8, i8* %arrayidx103, align 1
; Looking for a replacement for:
%0:i8 = var
infer %0 (demandedBits=11111011)

; *****
; For LLVM instruction:
;  %conv104 = zext i8 %83 to i32
; Looking for a replacement for:
%0:i8 = var
%1:i32 = zext %0
infer %1 (demandedBits=00000000000000000000000011111011)

; *****
; For LLVM instruction:
;  %and105 = and i32 %conv104, -5
; Looking for a replacement for:
%0:i8 = var
%1:i32 = zext %0
%2:i32 = and 4294967291:i32, %1
infer %2 (demandedBits=00000000000000000000000011111111)

; *****
; For LLVM instruction:
;  %conv106 = trunc i32 %and105 to i8
; Looking for a replacement for:
%0:i8 = var
%1:i32 = zext %0
%2:i32 = and 4294967291:i32, %1
%3:i8 = trunc %2
infer %3

; *****
; For LLVM instruction:
;  %85 = load i32, i32* %i, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %87 = load i32, i32* @w, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %mul108 = mul nsw i32 2, %87
; Looking for a replacement for:
%0:i32 = var
%1:i32 = mulnsw 2:i32, %0
infer %1

; *****
; For LLVM instruction:
;  %88 = load i8, i8* %arrayidx109, align 1
; Looking for a replacement for:
%0:i8 = var
infer %0 (demandedBits=11110111)

; *****
; For LLVM instruction:
;  %conv110 = zext i8 %88 to i32
; Looking for a replacement for:
%0:i8 = var
%1:i32 = zext %0
infer %1 (demandedBits=00000000000000000000000011110111)

; *****
; For LLVM instruction:
;  %and111 = and i32 %conv110, -9
; Looking for a replacement for:
%0:i8 = var
%1:i32 = zext %0
%2:i32 = and 4294967287:i32, %1
infer %2 (demandedBits=00000000000000000000000011111111)

; *****
; For LLVM instruction:
;  %conv112 = trunc i32 %and111 to i8
; Looking for a replacement for:
%0:i8 = var
%1:i32 = zext %0
%2:i32 = and 4294967287:i32, %1
%3:i8 = trunc %2
infer %3

; *****
; For LLVM instruction:
;  %89 = load i32, i32* %i, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %inc114 = add nsw i32 %89, 1
; Looking for a replacement for:
%0:i32 = var
%1:i32 = addnsw 1:i32, %0
infer %1

; *****
; For LLVM instruction:
;  %90 = load i32, i32* @w, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %91 = load i32, i32* @h, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %mul116 = mul nsw i32 %90, %91
; Looking for a replacement for:
%0:i32 = var
%1:i32 = var
%2:i32 = mulnsw %0, %1
infer %2

; *****
; For LLVM instruction:
;  %call117 = call i32 @irand(i32 2)
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %mul118 = mul nsw i32 %call117, 2
; Looking for a replacement for:
%0:i32 = var
%1:i32 = mulnsw 2:i32, %0
infer %1

; *****
; For LLVM instruction:
;  %add119 = add nsw i32 %mul118, 1
; Looking for a replacement for:
%0:i32 = var
%1:i32 = mulnsw 2:i32, %0
%2:i32 = addnsw 1:i32, %1
infer %2

; *****
; For LLVM instruction:
;  %92 = load i32, i32* @h, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %call120 = call i32 @irand(i32 %92)
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %mul121 = mul nsw i32 %call120, 2
; Looking for a replacement for:
%0:i32 = var
%1:i32 = mulnsw 2:i32, %0
infer %1

; *****
; For LLVM instruction:
;  %add122 = add nsw i32 %mul121, 1
; Looking for a replacement for:
%0:i32 = var
%1:i32 = mulnsw 2:i32, %0
%2:i32 = addnsw 1:i32, %1
infer %2

; *****
; For LLVM instruction:
;  %93 = load i32, i32* %i, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %94 = load i32, i32* @h, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %mul124 = mul nsw i32 2, %94
; Looking for a replacement for:
%0:i32 = var
%1:i32 = mulnsw 2:i32, %0
infer %1

; *****
; For LLVM instruction:
;  %cmp125 = icmp sle i32 %93, %mul124
; Looking for a replacement for:
%0:i32 = var
%1:i32 = var
%2:i32 = mulnsw 2:i32, %1
%3:i1 = sle %0, %2
infer %3

; *****
; For LLVM instruction:
;  %95 = load i32, i32* %j, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %96 = load i32, i32* @w, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %mul129 = mul nsw i32 2, %96
; Looking for a replacement for:
%0:i32 = var
%1:i32 = mulnsw 2:i32, %0
infer %1

; *****
; For LLVM instruction:
;  %cmp130 = icmp sle i32 %95, %mul129
; Looking for a replacement for:
%0:i32 = var
%1:i32 = var
%2:i32 = mulnsw 2:i32, %1
%3:i1 = sle %0, %2
infer %3

; *****
; For LLVM instruction:
;  %98 = load i32, i32* %i, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %100 = load i32, i32* %j, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %101 = load i8, i8* %arrayidx134, align 1
; Looking for a replacement for:
%0:i8 = var
infer %0 (demandedBits=11101111)

; *****
; For LLVM instruction:
;  %conv135 = zext i8 %101 to i32
; Looking for a replacement for:
%0:i8 = var
%1:i32 = zext %0
infer %1 (demandedBits=00000000000000000000000011101111)

; *****
; For LLVM instruction:
;  %and136 = and i32 %conv135, -17
; Looking for a replacement for:
%0:i8 = var
%1:i32 = zext %0
%2:i32 = and 4294967279:i32, %1
infer %2 (demandedBits=00000000000000000000000011111111)

; *****
; For LLVM instruction:
;  %conv137 = trunc i32 %and136 to i8
; Looking for a replacement for:
%0:i8 = var
%1:i32 = zext %0
%2:i32 = and 4294967279:i32, %1
%3:i8 = trunc %2
infer %3

; *****
; For LLVM instruction:
;  %102 = load i32, i32* %j, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %inc139 = add nsw i32 %102, 1
; Looking for a replacement for:
%0:i32 = var
%1:i32 = addnsw 1:i32, %0
infer %1

; *****
; For LLVM instruction:
;  %103 = load i32, i32* %i, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %inc142 = add nsw i32 %103, 1
; Looking for a replacement for:
%0:i32 = var
%1:i32 = addnsw 1:i32, %0
infer %1

; *****
; For LLVM instruction:
;  %104 = load i32, i32* @w, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %mul144 = mul nsw i32 2, %104
; Looking for a replacement for:
%0:i32 = var
%1:i32 = mulnsw 2:i32, %0
infer %1

; *****
; For LLVM instruction:
;  %sub145 = sub nsw i32 %mul144, 1
; Looking for a replacement for:
%0:i32 = var
%1:i32 = mulnsw 2:i32, %0
%2:i32 = subnsw %1, 1:i32
infer %2

; *****
; For LLVM instruction:
;  %105 = load i32, i32* @h, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %mul146 = mul nsw i32 2, %105
; Looking for a replacement for:
%0:i32 = var
%1:i32 = mulnsw 2:i32, %0
infer %1

; *****
; For LLVM instruction:
;  %sub147 = sub nsw i32 %mul146, 1
; Looking for a replacement for:
%0:i32 = var
%1:i32 = mulnsw 2:i32, %0
%2:i32 = subnsw %1, 1:i32
infer %2
got 3 candidates from LHS

-------------------------------------------------
%0:i32 = var
%1:i32 = mulnsw 2:i32, %0
%2:i32 = addnsw 2:i32, %1
infer %2


--------------------------------
guess 0

%0:i32 = var ; reservedconst_1

Cost = 0
first query is SAT, returning the model:
reservedconst_1: 2
0 th attempt: second query is SAT-- constant doesn't work
first query is SAT, returning the model:
reservedconst_1: 536870914
1 th attempt: second query is SAT-- constant doesn't work
first query is UNSAT-- no more guesses

--------------------------------
guess 1

%0:i32 = var

Cost = 0
second query is SAT-- constant doesn't work

--------------------------------
guess 2

%0:i32 = var
%1:i32 = mulnsw 2:i32, %0

Cost = 1
second query is SAT-- constant doesn't work
Dataflow Pruned 0/0
There are 3 Guesses
There are 0 RHSs before deduplication
There are 0 RHSs after deduplication
got 2 candidates from LHS

-------------------------------------------------
%0:i32 = var
%1:i32 = addnsw 2:i32, %0
infer %1


--------------------------------
guess 0

%0:i32 = var ; reservedconst_1

Cost = 0
first query is SAT, returning the model:
reservedconst_1: 2
0 th attempt: second query is SAT-- constant doesn't work
first query is SAT, returning the model:
reservedconst_1: 1073741826
1 th attempt: second query is SAT-- constant doesn't work
first query is UNSAT-- no more guesses

--------------------------------
guess 1

%0:i32 = var

Cost = 0
second query is SAT-- constant doesn't work
Dataflow Pruned 0/0
There are 2 Guesses
There are 0 RHSs before deduplication
There are 0 RHSs after deduplication
got 3 candidates from LHS

-------------------------------------------------
%0:i32 = var
%1:i32 = addnsw 2:i32, %0
%2:i32 = mul 4:i32, %1
infer %2


--------------------------------
guess 0

%0:i32 = var ; reservedconst_1

Cost = 0
first query is SAT, returning the model:
reservedconst_1: 8
0 th attempt: second query is SAT-- constant doesn't work
first query is SAT, returning the model:
reservedconst_1: -2147483640
1 th attempt: second query is SAT-- constant doesn't work
first query is UNSAT-- no more guesses

--------------------------------
guess 1

%0:i32 = var

Cost = 0
second query is SAT-- constant doesn't work

--------------------------------
guess 2

%0:i32 = var
%1:i32 = addnsw 2:i32, %0

Cost = 1
second query is SAT-- constant doesn't work
Dataflow Pruned 0/0
There are 3 Guesses
There are 0 RHSs before deduplication
There are 0 RHSs after deduplication
got 3 candidates from LHS

-------------------------------------------------
%0:i32 = var
%1:i32 = var
%2:i32 = mulnsw %0, %1
infer %2


--------------------------------
guess 0

%0:i32 = var ; reservedconst_1

Cost = 0
first query is SAT, returning the model:
reservedconst_1: 0
ConstantSynthesis: solver returns error on second query

--------------------------------
guess 1

%0:i32 = var

Cost = 0
second query is SAT-- constant doesn't work

--------------------------------
guess 2

%0:i32 = var

Cost = 0
verification query failed!
Dataflow Pruned 0/0
There are 3 Guesses
There are 0 RHSs before deduplication
There are 0 RHSs after deduplication
got 7 candidates from LHS

-------------------------------------------------
%0:i32 = var
%1:i32 = addnsw 2:i32, %0
%2:i32 = mul 4:i32, %1
%3:i32 = var
%4:i32 = var
%5:i32 = mulnsw %3, %4
%6:i32 = add %2, %5
infer %6


--------------------------------
guess 0

%0:i32 = var ; reservedconst_1

Cost = 0
first query is SAT, returning the model:
reservedconst_1: 8
ConstantSynthesis: solver returns error on second query

--------------------------------
guess 1

%0:i32 = var

Cost = 0
verification query failed!
Dataflow Pruned 0/0
There are 7 Guesses
There are 0 RHSs before deduplication
There are 0 RHSs after deduplication
got 8 candidates from LHS

-------------------------------------------------
%0:i32 = var
%1:i32 = addnsw 2:i32, %0
%2:i32 = mul 4:i32, %1
%3:i32 = var
%4:i32 = var
%5:i32 = mulnsw %3, %4
%6:i32 = add %2, %5
%7:i32 = add 1:i32, %6
infer %7


--------------------------------
guess 0

%0:i32 = var ; reservedconst_1

Cost = 0
first query is SAT, returning the model:
reservedconst_1: 9
ConstantSynthesis: solver returns error on second query

--------------------------------
guess 1

%0:i32 = var

Cost = 0
second query is SAT-- constant doesn't work

--------------------------------
guess 2

%0:i32 = var

Cost = 0
verification query failed!
Dataflow Pruned 0/0
There are 8 Guesses
There are 0 RHSs before deduplication
There are 0 RHSs after deduplication
got 3 candidates from LHS

-------------------------------------------------
%0:i32 = var
%1:i32 = mulnsw 2:i32, %0
%2:i32 = addnsw 1:i32, %1
infer %2


--------------------------------
guess 0

%0:i32 = var ; reservedconst_1

Cost = 0
first query is SAT, returning the model:
reservedconst_1: 1
0 th attempt: second query is SAT-- constant doesn't work
first query is SAT, returning the model:
reservedconst_1: 1073741825
1 th attempt: second query is SAT-- constant doesn't work
first query is UNSAT-- no more guesses

--------------------------------
guess 1

%0:i32 = var

Cost = 0
second query is SAT-- constant doesn't work

--------------------------------
guess 2

%0:i32 = var
%1:i32 = mulnsw 2:i32, %0

Cost = 1
second query is SAT-- constant doesn't work
Dataflow Pruned 0/0
There are 3 Guesses
There are 0 RHSs before deduplication
There are 0 RHSs after deduplication
got 5 candidates from LHS

-------------------------------------------------
%0:i32 = var
%1:i32 = var
%2:i32 = mulnsw 2:i32, %1
%3:i32 = addnsw 1:i32, %2
%4:i1 = sle %0, %3
infer %4


--------------------------------
guess 0

%0:i1 = var ; reservedconst_1

Cost = 0
first query is SAT, returning the model:
reservedconst_1: -1
0 th attempt: second query is SAT-- constant doesn't work
first query is SAT, returning the model:
reservedconst_1: 0
1 th attempt: second query is SAT-- constant doesn't work
first query is UNSAT-- no more guesses
Dataflow Pruned 0/0
There are 1 Guesses
There are 0 RHSs before deduplication
There are 0 RHSs after deduplication
got 3 candidates from LHS

-------------------------------------------------
%0:i8 = var
%1:i32 = zext %0
%2:i32 = or 12:i32, %1
infer %2 (demandedBits=00000000000000000000000011111111)


--------------------------------
guess 0

%0:i32 = var ; reservedconst_1

Cost = 0
first query is SAT, returning the model:
reservedconst_1: 12
0 th attempt: second query is SAT-- constant doesn't work
first query is SAT, returning the model:
reservedconst_1: 255
1 th attempt: second query is SAT-- constant doesn't work
first query is UNSAT-- no more guesses

--------------------------------
guess 1

%0:i8 = var
%1:i32 = zext %0

Cost = 1
second query is SAT-- constant doesn't work
Dataflow Pruned 0/0
There are 2 Guesses
There are 0 RHSs before deduplication
There are 0 RHSs after deduplication
got 4 candidates from LHS

-------------------------------------------------
%0:i8 = var
%1:i32 = zext %0
%2:i32 = or 12:i32, %1
%3:i8 = trunc %2
infer %3


--------------------------------
guess 0

%0:i8 = var ; reservedconst_1

Cost = 0
first query is SAT, returning the model:
reservedconst_1: 12
0 th attempt: second query is SAT-- constant doesn't work
first query is SAT, returning the model:
reservedconst_1: -1
1 th attempt: second query is SAT-- constant doesn't work
first query is UNSAT-- no more guesses

--------------------------------
guess 1

%0:i8 = var

Cost = 0
second query is SAT-- constant doesn't work
Dataflow Pruned 0/0
There are 2 Guesses
There are 0 RHSs before deduplication
There are 0 RHSs after deduplication
got 3 candidates from LHS

-------------------------------------------------
%0:i8 = var
%1:i32 = zext %0
%2:i32 = or 3:i32, %1
infer %2 (demandedBits=00000000000000000000000011111111)


--------------------------------
guess 0

%0:i32 = var ; reservedconst_1

Cost = 0
first query is SAT, returning the model:
reservedconst_1: 3
0 th attempt: second query is SAT-- constant doesn't work
first query is SAT, returning the model:
reservedconst_1: 255
1 th attempt: second query is SAT-- constant doesn't work
first query is UNSAT-- no more guesses

--------------------------------
guess 1

%0:i8 = var
%1:i32 = zext %0

Cost = 1
second query is SAT-- constant doesn't work
Dataflow Pruned 0/0
There are 2 Guesses
There are 0 RHSs before deduplication
There are 0 RHSs after deduplication
got 4 candidates from LHS

-------------------------------------------------
%0:i8 = var
%1:i32 = zext %0
%2:i32 = or 3:i32, %1
%3:i8 = trunc %2
infer %3


--------------------------------
guess 0

%0:i8 = var ; reservedconst_1

Cost = 0
first query is SAT, returning the model:
reservedconst_1: 3
0 th attempt: second query is SAT-- constant doesn't work
first query is SAT, returning the model:
reservedconst_1: -1
1 th attempt: second query is SAT-- constant doesn't work
first query is UNSAT-- no more guesses

--------------------------------
guess 1

%0:i8 = var

Cost = 0
second query is SAT-- constant doesn't work
Dataflow Pruned 0/0
There are 2 Guesses
There are 0 RHSs before deduplication
There are 0 RHSs after deduplication
got 3 candidates from LHS

-------------------------------------------------
%0:i32 = var
%1:i32 = mulnsw 2:i32, %0
%2:i32 = subnsw %1, 1:i32
infer %2


--------------------------------
guess 0

%0:i32 = var ; reservedconst_1

Cost = 0
first query is SAT, returning the model:
reservedconst_1: -1
0 th attempt: second query is SAT-- constant doesn't work
first query is SAT, returning the model:
reservedconst_1: 536870911
1 th attempt: second query is SAT-- constant doesn't work
first query is UNSAT-- no more guesses

--------------------------------
guess 1

%0:i32 = var

Cost = 0
second query is SAT-- constant doesn't work

--------------------------------
guess 2

%0:i32 = var
%1:i32 = mulnsw 2:i32, %0

Cost = 1
second query is SAT-- constant doesn't work
Dataflow Pruned 0/0
There are 3 Guesses
There are 0 RHSs before deduplication
There are 0 RHSs after deduplication
#########################################################
; exiting Souper's runOnFunction() for make_maze()

; entering Souper's runOnFunction() for __main_argc_argv()

; ModuleID = './Maze_generation.c.bc'
source_filename = "./Maze_generation.c"
target datalayout = "e-m:e-p:32:32-i64:64-n32:64-S128"
target triple = "wasm32-unknown-wasi"

@glyph = hidden global [30 x i32] [i32 12288, i32 9474, i32 9474, i32 9474, i32 9472, i32 9496, i32 9488, i32 9508, i32 9472, i32 9492, i32 9484, i32 9500, i32 9472, i32 9524, i32 9516, i32 9532, i32 12288, i32 9478, i32 9478, i32 9478, i32 9476, i32 9583, i32 9582, i32 32, i32 9476, i32 9584, i32 9581, i32 32, i32 9476, i32 0], align 16
@h = hidden global i32 0, align 4
@w = hidden global i32 0, align 4
@cell = hidden global i8** null, align 4
@.str = private unnamed_addr constant [6 x i8] c"\1B[31m\00", align 1
@.str.1 = private unnamed_addr constant [4 x i8] c"%lc\00", align 1
@.str.2 = private unnamed_addr constant [4 x i8] c"\1B[m\00", align 1
@__const.walk.d = private unnamed_addr constant [4 x i32] [i32 0, i32 1, i32 2, i32 3], align 16
@avail = hidden global i32 0, align 4
@dirs = internal global [4 x [2 x i32]] [[2 x i32] [i32 -2, i32 0], [2 x i32] [i32 0, i32 2], [2 x i32] [i32 2, i32 0], [2 x i32] [i32 0, i32 -2]], align 16
@.str.3 = private unnamed_addr constant [1 x i8] zeroinitializer, align 1

; Function Attrs: noinline nounwind optnone
define hidden i32 @irand(i32 %n) #0 {
entry:
  %n.addr = alloca i32, align 4
  %r = alloca i32, align 4
  %rmax = alloca i32, align 4
  store i32 %n, i32* %n.addr, align 4
  %0 = load i32, i32* %n.addr, align 4
  %1 = load i32, i32* %n.addr, align 4
  %div = sdiv i32 2147483647, %1
  %mul = mul nsw i32 %0, %div
  store i32 %mul, i32* %rmax, align 4
  br label %while.cond

while.cond:                                       ; preds = %while.body, %entry
  %call = call i32 @rand()
  store i32 %call, i32* %r, align 4
  %2 = load i32, i32* %rmax, align 4
  %cmp = icmp sge i32 %call, %2
  br i1 %cmp, label %while.body, label %while.end

while.body:                                       ; preds = %while.cond
  br label %while.cond

while.end:                                        ; preds = %while.cond
  %3 = load i32, i32* %r, align 4
  %4 = load i32, i32* %n.addr, align 4
  %div1 = sdiv i32 2147483647, %4
  %div2 = sdiv i32 %3, %div1
  ret i32 %div2
}

declare i32 @rand() #1

; Function Attrs: noinline nounwind optnone
define hidden void @show() #0 {
entry:
  %i = alloca i32, align 4
  %j = alloca i32, align 4
  %c = alloca i32, align 4
  store i32 0, i32* %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc16, %entry
  %0 = load i32, i32* %i, align 4
  %1 = load i32, i32* @h, align 4
  %mul = mul nsw i32 2, %1
  %cmp = icmp sle i32 %0, %mul
  br i1 %cmp, label %for.body, label %for.end18

for.body:                                         ; preds = %for.cond
  store i32 0, i32* %j, align 4
  br label %for.cond1

for.cond1:                                        ; preds = %for.inc, %for.body
  %2 = load i32, i32* %j, align 4
  %3 = load i32, i32* @w, align 4
  %mul2 = mul nsw i32 2, %3
  %cmp3 = icmp sle i32 %2, %mul2
  br i1 %cmp3, label %for.body4, label %for.end

for.body4:                                        ; preds = %for.cond1
  %4 = load i8**, i8*** @cell, align 4
  %5 = load i32, i32* %i, align 4
  %arrayidx = getelementptr inbounds i8*, i8** %4, i32 %5
  %6 = load i8*, i8** %arrayidx, align 4
  %7 = load i32, i32* %j, align 4
  %arrayidx5 = getelementptr inbounds i8, i8* %6, i32 %7
  %8 = load i8, i8* %arrayidx5, align 1
  %conv = zext i8 %8 to i32
  store i32 %conv, i32* %c, align 4
  %9 = load i32, i32* %c, align 4
  %cmp6 = icmp sgt i32 %9, 16
  br i1 %cmp6, label %if.then, label %if.end

if.then:                                          ; preds = %for.body4
  %call = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([6 x i8], [6 x i8]* @.str, i32 0, i32 0))
  br label %if.end

if.end:                                           ; preds = %if.then, %for.body4
  %10 = load i32, i32* %c, align 4
  %arrayidx8 = getelementptr inbounds [30 x i32], [30 x i32]* @glyph, i32 0, i32 %10
  %11 = load i32, i32* %arrayidx8, align 4
  %call9 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([4 x i8], [4 x i8]* @.str.1, i32 0, i32 0), i32 %11)
  %12 = load i32, i32* %c, align 4
  %cmp10 = icmp sgt i32 %12, 16
  br i1 %cmp10, label %if.then12, label %if.end14

if.then12:                                        ; preds = %if.end
  %call13 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([4 x i8], [4 x i8]* @.str.2, i32 0, i32 0))
  br label %if.end14

if.end14:                                         ; preds = %if.then12, %if.end
  br label %for.inc

for.inc:                                          ; preds = %if.end14
  %13 = load i32, i32* %j, align 4
  %inc = add nsw i32 %13, 1
  store i32 %inc, i32* %j, align 4
  br label %for.cond1

for.end:                                          ; preds = %for.cond1
  %call15 = call i32 @putchar(i32 10)
  br label %for.inc16

for.inc16:                                        ; preds = %for.end
  %14 = load i32, i32* %i, align 4
  %inc17 = add nsw i32 %14, 1
  store i32 %inc17, i32* %i, align 4
  br label %for.cond

for.end18:                                        ; preds = %for.cond
  ret void
}

declare i32 @printf(i8* %0, ...) #1

declare i32 @putchar(i32 %0) #1

; Function Attrs: noinline nounwind optnone
define hidden void @walk(i32 %x, i32 %y) #0 {
entry:
  %x.addr = alloca i32, align 4
  %y.addr = alloca i32, align 4
  %i = alloca i32, align 4
  %t = alloca i32, align 4
  %x1 = alloca i32, align 4
  %y1 = alloca i32, align 4
  %d = alloca [4 x i32], align 16
  store i32 %x, i32* %x.addr, align 4
  store i32 %y, i32* %y.addr, align 4
  %0 = bitcast [4 x i32]* %d to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 16 %0, i8* align 16 bitcast ([4 x i32]* @__const.walk.d to i8*), i32 16, i1 false)
  %1 = load i8**, i8*** @cell, align 4
  %2 = load i32, i32* %y.addr, align 4
  %arrayidx = getelementptr inbounds i8*, i8** %1, i32 %2
  %3 = load i8*, i8** %arrayidx, align 4
  %4 = load i32, i32* %x.addr, align 4
  %arrayidx1 = getelementptr inbounds i8, i8* %3, i32 %4
  %5 = load i8, i8* %arrayidx1, align 1
  %conv = zext i8 %5 to i32
  %or = or i32 %conv, 16
  %conv2 = trunc i32 %or to i8
  store i8 %conv2, i8* %arrayidx1, align 1
  %6 = load i32, i32* @avail, align 4
  %dec = add nsw i32 %6, -1
  store i32 %dec, i32* @avail, align 4
  store i32 3, i32* %x1, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %7 = load i32, i32* %x1, align 4
  %tobool = icmp ne i32 %7, 0
  br i1 %tobool, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %8 = load i32, i32* %x1, align 4
  %9 = load i32, i32* %x1, align 4
  %add = add nsw i32 %9, 1
  %call = call i32 @irand(i32 %add)
  store i32 %call, i32* %y1, align 4
  %cmp = icmp ne i32 %8, %call
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %for.body
  %10 = load i32, i32* %x1, align 4
  %arrayidx4 = getelementptr inbounds [4 x i32], [4 x i32]* %d, i32 0, i32 %10
  %11 = load i32, i32* %arrayidx4, align 4
  store i32 %11, i32* %i, align 4
  %12 = load i32, i32* %y1, align 4
  %arrayidx5 = getelementptr inbounds [4 x i32], [4 x i32]* %d, i32 0, i32 %12
  %13 = load i32, i32* %arrayidx5, align 4
  %14 = load i32, i32* %x1, align 4
  %arrayidx6 = getelementptr inbounds [4 x i32], [4 x i32]* %d, i32 0, i32 %14
  store i32 %13, i32* %arrayidx6, align 4
  %15 = load i32, i32* %i, align 4
  %16 = load i32, i32* %y1, align 4
  %arrayidx7 = getelementptr inbounds [4 x i32], [4 x i32]* %d, i32 0, i32 %16
  store i32 %15, i32* %arrayidx7, align 4
  br label %if.end

if.end:                                           ; preds = %if.then, %for.body
  br label %for.inc

for.inc:                                          ; preds = %if.end
  %17 = load i32, i32* %x1, align 4
  %dec8 = add nsw i32 %17, -1
  store i32 %dec8, i32* %x1, align 4
  br label %for.cond

for.end:                                          ; preds = %for.cond
  store i32 0, i32* %i, align 4
  br label %for.cond9

for.cond9:                                        ; preds = %for.inc72, %for.end
  %18 = load i32, i32* @avail, align 4
  %tobool10 = icmp ne i32 %18, 0
  br i1 %tobool10, label %land.rhs, label %land.end

land.rhs:                                         ; preds = %for.cond9
  %19 = load i32, i32* %i, align 4
  %cmp11 = icmp slt i32 %19, 4
  br label %land.end

land.end:                                         ; preds = %land.rhs, %for.cond9
  %20 = phi i1 [ false, %for.cond9 ], [ %cmp11, %land.rhs ]
  br i1 %20, label %for.body13, label %for.end73

for.body13:                                       ; preds = %land.end
  %21 = load i32, i32* %x.addr, align 4
  %22 = load i32, i32* %i, align 4
  %arrayidx14 = getelementptr inbounds [4 x i32], [4 x i32]* %d, i32 0, i32 %22
  %23 = load i32, i32* %arrayidx14, align 4
  %arrayidx15 = getelementptr inbounds [4 x [2 x i32]], [4 x [2 x i32]]* @dirs, i32 0, i32 %23
  %arrayidx16 = getelementptr inbounds [2 x i32], [2 x i32]* %arrayidx15, i32 0, i32 0
  %24 = load i32, i32* %arrayidx16, align 8
  %add17 = add nsw i32 %21, %24
  store i32 %add17, i32* %x1, align 4
  %25 = load i32, i32* %y.addr, align 4
  %26 = load i32, i32* %i, align 4
  %arrayidx18 = getelementptr inbounds [4 x i32], [4 x i32]* %d, i32 0, i32 %26
  %27 = load i32, i32* %arrayidx18, align 4
  %arrayidx19 = getelementptr inbounds [4 x [2 x i32]], [4 x [2 x i32]]* @dirs, i32 0, i32 %27
  %arrayidx20 = getelementptr inbounds [2 x i32], [2 x i32]* %arrayidx19, i32 0, i32 1
  %28 = load i32, i32* %arrayidx20, align 4
  %add21 = add nsw i32 %25, %28
  store i32 %add21, i32* %y1, align 4
  %29 = load i8**, i8*** @cell, align 4
  %30 = load i32, i32* %y1, align 4
  %arrayidx22 = getelementptr inbounds i8*, i8** %29, i32 %30
  %31 = load i8*, i8** %arrayidx22, align 4
  %32 = load i32, i32* %x1, align 4
  %arrayidx23 = getelementptr inbounds i8, i8* %31, i32 %32
  %33 = load i8, i8* %arrayidx23, align 1
  %conv24 = zext i8 %33 to i32
  %and = and i32 %conv24, 16
  %tobool25 = icmp ne i32 %and, 0
  br i1 %tobool25, label %if.then26, label %if.end27

if.then26:                                        ; preds = %for.body13
  br label %for.inc72

if.end27:                                         ; preds = %for.body13
  %34 = load i32, i32* %x1, align 4
  %35 = load i32, i32* %x.addr, align 4
  %cmp28 = icmp eq i32 %34, %35
  br i1 %cmp28, label %if.then30, label %if.else

if.then30:                                        ; preds = %if.end27
  %36 = load i32, i32* %y.addr, align 4
  %37 = load i32, i32* %y1, align 4
  %add31 = add nsw i32 %36, %37
  %div = sdiv i32 %add31, 2
  store i32 %div, i32* %t, align 4
  %38 = load i8**, i8*** @cell, align 4
  %39 = load i32, i32* %t, align 4
  %arrayidx32 = getelementptr inbounds i8*, i8** %38, i32 %39
  %40 = load i8*, i8** %arrayidx32, align 4
  %41 = load i32, i32* %x.addr, align 4
  %add33 = add nsw i32 %41, 1
  %arrayidx34 = getelementptr inbounds i8, i8* %40, i32 %add33
  %42 = load i8, i8* %arrayidx34, align 1
  %conv35 = zext i8 %42 to i32
  %and36 = and i32 %conv35, -5
  %conv37 = trunc i32 %and36 to i8
  store i8 %conv37, i8* %arrayidx34, align 1
  %43 = load i8**, i8*** @cell, align 4
  %44 = load i32, i32* %t, align 4
  %arrayidx38 = getelementptr inbounds i8*, i8** %43, i32 %44
  %45 = load i8*, i8** %arrayidx38, align 4
  %46 = load i32, i32* %x.addr, align 4
  %arrayidx39 = getelementptr inbounds i8, i8* %45, i32 %46
  %47 = load i8, i8* %arrayidx39, align 1
  %conv40 = zext i8 %47 to i32
  %and41 = and i32 %conv40, -13
  %conv42 = trunc i32 %and41 to i8
  store i8 %conv42, i8* %arrayidx39, align 1
  %48 = load i8**, i8*** @cell, align 4
  %49 = load i32, i32* %t, align 4
  %arrayidx43 = getelementptr inbounds i8*, i8** %48, i32 %49
  %50 = load i8*, i8** %arrayidx43, align 4
  %51 = load i32, i32* %x.addr, align 4
  %sub = sub nsw i32 %51, 1
  %arrayidx44 = getelementptr inbounds i8, i8* %50, i32 %sub
  %52 = load i8, i8* %arrayidx44, align 1
  %conv45 = zext i8 %52 to i32
  %and46 = and i32 %conv45, -9
  %conv47 = trunc i32 %and46 to i8
  store i8 %conv47, i8* %arrayidx44, align 1
  br label %if.end71

if.else:                                          ; preds = %if.end27
  %53 = load i32, i32* %y1, align 4
  %54 = load i32, i32* %y.addr, align 4
  %cmp48 = icmp eq i32 %53, %54
  br i1 %cmp48, label %if.then50, label %if.end70

if.then50:                                        ; preds = %if.else
  %55 = load i32, i32* %x.addr, align 4
  %56 = load i32, i32* %x1, align 4
  %add51 = add nsw i32 %55, %56
  %div52 = sdiv i32 %add51, 2
  store i32 %div52, i32* %t, align 4
  %57 = load i8**, i8*** @cell, align 4
  %58 = load i32, i32* %y.addr, align 4
  %sub53 = sub nsw i32 %58, 1
  %arrayidx54 = getelementptr inbounds i8*, i8** %57, i32 %sub53
  %59 = load i8*, i8** %arrayidx54, align 4
  %60 = load i32, i32* %t, align 4
  %arrayidx55 = getelementptr inbounds i8, i8* %59, i32 %60
  %61 = load i8, i8* %arrayidx55, align 1
  %conv56 = zext i8 %61 to i32
  %and57 = and i32 %conv56, -3
  %conv58 = trunc i32 %and57 to i8
  store i8 %conv58, i8* %arrayidx55, align 1
  %62 = load i8**, i8*** @cell, align 4
  %63 = load i32, i32* %y.addr, align 4
  %arrayidx59 = getelementptr inbounds i8*, i8** %62, i32 %63
  %64 = load i8*, i8** %arrayidx59, align 4
  %65 = load i32, i32* %t, align 4
  %arrayidx60 = getelementptr inbounds i8, i8* %64, i32 %65
  %66 = load i8, i8* %arrayidx60, align 1
  %conv61 = zext i8 %66 to i32
  %and62 = and i32 %conv61, -4
  %conv63 = trunc i32 %and62 to i8
  store i8 %conv63, i8* %arrayidx60, align 1
  %67 = load i8**, i8*** @cell, align 4
  %68 = load i32, i32* %y.addr, align 4
  %add64 = add nsw i32 %68, 1
  %arrayidx65 = getelementptr inbounds i8*, i8** %67, i32 %add64
  %69 = load i8*, i8** %arrayidx65, align 4
  %70 = load i32, i32* %t, align 4
  %arrayidx66 = getelementptr inbounds i8, i8* %69, i32 %70
  %71 = load i8, i8* %arrayidx66, align 1
  %conv67 = zext i8 %71 to i32
  %and68 = and i32 %conv67, -2
  %conv69 = trunc i32 %and68 to i8
  store i8 %conv69, i8* %arrayidx66, align 1
  br label %if.end70

if.end70:                                         ; preds = %if.then50, %if.else
  br label %if.end71

if.end71:                                         ; preds = %if.end70, %if.then30
  %72 = load i32, i32* %x1, align 4
  %73 = load i32, i32* %y1, align 4
  call void @walk(i32 %72, i32 %73)
  br label %for.inc72

for.inc72:                                        ; preds = %if.end71, %if.then26
  %74 = load i32, i32* %i, align 4
  %inc = add nsw i32 %74, 1
  store i32 %inc, i32* %i, align 4
  br label %for.cond9

for.end73:                                        ; preds = %land.end
  ret void
}

; Function Attrs: argmemonly nounwind willreturn
declare void @llvm.memcpy.p0i8.p0i8.i32(i8* noalias nocapture writeonly %0, i8* noalias nocapture readonly %1, i32 %2, i1 immarg %3) #2

; Function Attrs: noinline nounwind optnone
define hidden i32 @solve(i32 %x, i32 %y, i32 %tox, i32 %toy) #0 {
entry:
  %retval = alloca i32, align 4
  %x.addr = alloca i32, align 4
  %y.addr = alloca i32, align 4
  %tox.addr = alloca i32, align 4
  %toy.addr = alloca i32, align 4
  %i = alloca i32, align 4
  %t = alloca i32, align 4
  %x1 = alloca i32, align 4
  %y1 = alloca i32, align 4
  store i32 %x, i32* %x.addr, align 4
  store i32 %y, i32* %y.addr, align 4
  store i32 %tox, i32* %tox.addr, align 4
  store i32 %toy, i32* %toy.addr, align 4
  %0 = load i8**, i8*** @cell, align 4
  %1 = load i32, i32* %y.addr, align 4
  %arrayidx = getelementptr inbounds i8*, i8** %0, i32 %1
  %2 = load i8*, i8** %arrayidx, align 4
  %3 = load i32, i32* %x.addr, align 4
  %arrayidx1 = getelementptr inbounds i8, i8* %2, i32 %3
  %4 = load i8, i8* %arrayidx1, align 1
  %conv = zext i8 %4 to i32
  %or = or i32 %conv, 16
  %conv2 = trunc i32 %or to i8
  store i8 %conv2, i8* %arrayidx1, align 1
  %5 = load i32, i32* %x.addr, align 4
  %6 = load i32, i32* %tox.addr, align 4
  %cmp = icmp eq i32 %5, %6
  br i1 %cmp, label %land.lhs.true, label %if.end

land.lhs.true:                                    ; preds = %entry
  %7 = load i32, i32* %y.addr, align 4
  %8 = load i32, i32* %toy.addr, align 4
  %cmp4 = icmp eq i32 %7, %8
  br i1 %cmp4, label %if.then, label %if.end

if.then:                                          ; preds = %land.lhs.true
  store i32 1, i32* %retval, align 4
  br label %return

if.end:                                           ; preds = %land.lhs.true, %entry
  store i32 0, i32* %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.end
  %9 = load i32, i32* %i, align 4
  %cmp6 = icmp sle i32 %9, 3
  br i1 %cmp6, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %10 = load i32, i32* %x.addr, align 4
  %11 = load i32, i32* %i, align 4
  %arrayidx8 = getelementptr inbounds [4 x [2 x i32]], [4 x [2 x i32]]* @dirs, i32 0, i32 %11
  %arrayidx9 = getelementptr inbounds [2 x i32], [2 x i32]* %arrayidx8, i32 0, i32 0
  %12 = load i32, i32* %arrayidx9, align 8
  %add = add nsw i32 %10, %12
  store i32 %add, i32* %x1, align 4
  %13 = load i32, i32* %y.addr, align 4
  %14 = load i32, i32* %i, align 4
  %arrayidx10 = getelementptr inbounds [4 x [2 x i32]], [4 x [2 x i32]]* @dirs, i32 0, i32 %14
  %arrayidx11 = getelementptr inbounds [2 x i32], [2 x i32]* %arrayidx10, i32 0, i32 1
  %15 = load i32, i32* %arrayidx11, align 4
  %add12 = add nsw i32 %13, %15
  store i32 %add12, i32* %y1, align 4
  %16 = load i8**, i8*** @cell, align 4
  %17 = load i32, i32* %y1, align 4
  %arrayidx13 = getelementptr inbounds i8*, i8** %16, i32 %17
  %18 = load i8*, i8** %arrayidx13, align 4
  %19 = load i32, i32* %x1, align 4
  %arrayidx14 = getelementptr inbounds i8, i8* %18, i32 %19
  %20 = load i8, i8* %arrayidx14, align 1
  %tobool = icmp ne i8 %20, 0
  br i1 %tobool, label %if.then15, label %if.end16

if.then15:                                        ; preds = %for.body
  br label %for.inc

if.end16:                                         ; preds = %for.body
  %21 = load i32, i32* %x1, align 4
  %22 = load i32, i32* %x.addr, align 4
  %cmp17 = icmp eq i32 %21, %22
  br i1 %cmp17, label %if.then19, label %if.else

if.then19:                                        ; preds = %if.end16
  %23 = load i32, i32* %y.addr, align 4
  %24 = load i32, i32* %y1, align 4
  %add20 = add nsw i32 %23, %24
  %div = sdiv i32 %add20, 2
  store i32 %div, i32* %t, align 4
  %25 = load i8**, i8*** @cell, align 4
  %26 = load i32, i32* %t, align 4
  %arrayidx21 = getelementptr inbounds i8*, i8** %25, i32 %26
  %27 = load i8*, i8** %arrayidx21, align 4
  %28 = load i32, i32* %x.addr, align 4
  %arrayidx22 = getelementptr inbounds i8, i8* %27, i32 %28
  %29 = load i8, i8* %arrayidx22, align 1
  %conv23 = zext i8 %29 to i32
  %tobool24 = icmp ne i32 %conv23, 0
  br i1 %tobool24, label %if.then26, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %if.then19
  %30 = load i32, i32* %x1, align 4
  %31 = load i32, i32* %y1, align 4
  %32 = load i32, i32* %tox.addr, align 4
  %33 = load i32, i32* %toy.addr, align 4
  %call = call i32 @solve(i32 %30, i32 %31, i32 %32, i32 %33)
  %tobool25 = icmp ne i32 %call, 0
  br i1 %tobool25, label %if.end27, label %if.then26

if.then26:                                        ; preds = %lor.lhs.false, %if.then19
  br label %for.inc

if.end27:                                         ; preds = %lor.lhs.false
  %34 = load i8**, i8*** @cell, align 4
  %35 = load i32, i32* %t, align 4
  %sub = sub nsw i32 %35, 1
  %arrayidx28 = getelementptr inbounds i8*, i8** %34, i32 %sub
  %36 = load i8*, i8** %arrayidx28, align 4
  %37 = load i32, i32* %x.addr, align 4
  %arrayidx29 = getelementptr inbounds i8, i8* %36, i32 %37
  %38 = load i8, i8* %arrayidx29, align 1
  %conv30 = zext i8 %38 to i32
  %or31 = or i32 %conv30, 2
  %conv32 = trunc i32 %or31 to i8
  store i8 %conv32, i8* %arrayidx29, align 1
  %39 = load i8**, i8*** @cell, align 4
  %40 = load i32, i32* %t, align 4
  %arrayidx33 = getelementptr inbounds i8*, i8** %39, i32 %40
  %41 = load i8*, i8** %arrayidx33, align 4
  %42 = load i32, i32* %x.addr, align 4
  %arrayidx34 = getelementptr inbounds i8, i8* %41, i32 %42
  %43 = load i8, i8* %arrayidx34, align 1
  %conv35 = zext i8 %43 to i32
  %or36 = or i32 %conv35, 19
  %conv37 = trunc i32 %or36 to i8
  store i8 %conv37, i8* %arrayidx34, align 1
  %44 = load i8**, i8*** @cell, align 4
  %45 = load i32, i32* %t, align 4
  %add38 = add nsw i32 %45, 1
  %arrayidx39 = getelementptr inbounds i8*, i8** %44, i32 %add38
  %46 = load i8*, i8** %arrayidx39, align 4
  %47 = load i32, i32* %x.addr, align 4
  %arrayidx40 = getelementptr inbounds i8, i8* %46, i32 %47
  %48 = load i8, i8* %arrayidx40, align 1
  %conv41 = zext i8 %48 to i32
  %or42 = or i32 %conv41, 1
  %conv43 = trunc i32 %or42 to i8
  store i8 %conv43, i8* %arrayidx40, align 1
  br label %if.end76

if.else:                                          ; preds = %if.end16
  %49 = load i32, i32* %y1, align 4
  %50 = load i32, i32* %y.addr, align 4
  %cmp44 = icmp eq i32 %49, %50
  br i1 %cmp44, label %if.then46, label %if.end75

if.then46:                                        ; preds = %if.else
  %51 = load i32, i32* %x.addr, align 4
  %52 = load i32, i32* %x1, align 4
  %add47 = add nsw i32 %51, %52
  %div48 = sdiv i32 %add47, 2
  store i32 %div48, i32* %t, align 4
  %53 = load i8**, i8*** @cell, align 4
  %54 = load i32, i32* %y.addr, align 4
  %arrayidx49 = getelementptr inbounds i8*, i8** %53, i32 %54
  %55 = load i8*, i8** %arrayidx49, align 4
  %56 = load i32, i32* %t, align 4
  %arrayidx50 = getelementptr inbounds i8, i8* %55, i32 %56
  %57 = load i8, i8* %arrayidx50, align 1
  %conv51 = zext i8 %57 to i32
  %tobool52 = icmp ne i32 %conv51, 0
  br i1 %tobool52, label %if.then56, label %lor.lhs.false53

lor.lhs.false53:                                  ; preds = %if.then46
  %58 = load i32, i32* %x1, align 4
  %59 = load i32, i32* %y1, align 4
  %60 = load i32, i32* %tox.addr, align 4
  %61 = load i32, i32* %toy.addr, align 4
  %call54 = call i32 @solve(i32 %58, i32 %59, i32 %60, i32 %61)
  %tobool55 = icmp ne i32 %call54, 0
  br i1 %tobool55, label %if.end57, label %if.then56

if.then56:                                        ; preds = %lor.lhs.false53, %if.then46
  br label %for.inc

if.end57:                                         ; preds = %lor.lhs.false53
  %62 = load i8**, i8*** @cell, align 4
  %63 = load i32, i32* %y.addr, align 4
  %arrayidx58 = getelementptr inbounds i8*, i8** %62, i32 %63
  %64 = load i8*, i8** %arrayidx58, align 4
  %65 = load i32, i32* %t, align 4
  %sub59 = sub nsw i32 %65, 1
  %arrayidx60 = getelementptr inbounds i8, i8* %64, i32 %sub59
  %66 = load i8, i8* %arrayidx60, align 1
  %conv61 = zext i8 %66 to i32
  %or62 = or i32 %conv61, 8
  %conv63 = trunc i32 %or62 to i8
  store i8 %conv63, i8* %arrayidx60, align 1
  %67 = load i8**, i8*** @cell, align 4
  %68 = load i32, i32* %y.addr, align 4
  %arrayidx64 = getelementptr inbounds i8*, i8** %67, i32 %68
  %69 = load i8*, i8** %arrayidx64, align 4
  %70 = load i32, i32* %t, align 4
  %arrayidx65 = getelementptr inbounds i8, i8* %69, i32 %70
  %71 = load i8, i8* %arrayidx65, align 1
  %conv66 = zext i8 %71 to i32
  %or67 = or i32 %conv66, 28
  %conv68 = trunc i32 %or67 to i8
  store i8 %conv68, i8* %arrayidx65, align 1
  %72 = load i8**, i8*** @cell, align 4
  %73 = load i32, i32* %y.addr, align 4
  %arrayidx69 = getelementptr inbounds i8*, i8** %72, i32 %73
  %74 = load i8*, i8** %arrayidx69, align 4
  %75 = load i32, i32* %t, align 4
  %add70 = add nsw i32 %75, 1
  %arrayidx71 = getelementptr inbounds i8, i8* %74, i32 %add70
  %76 = load i8, i8* %arrayidx71, align 1
  %conv72 = zext i8 %76 to i32
  %or73 = or i32 %conv72, 4
  %conv74 = trunc i32 %or73 to i8
  store i8 %conv74, i8* %arrayidx71, align 1
  br label %if.end75

if.end75:                                         ; preds = %if.end57, %if.else
  br label %if.end76

if.end76:                                         ; preds = %if.end75, %if.end27
  store i32 1, i32* %retval, align 4
  br label %return

for.inc:                                          ; preds = %if.then56, %if.then26, %if.then15
  %77 = load i32, i32* %i, align 4
  %inc = add nsw i32 %77, 1
  store i32 %inc, i32* %i, align 4
  br label %for.cond

for.end:                                          ; preds = %for.cond
  %78 = load i8**, i8*** @cell, align 4
  %79 = load i32, i32* %y.addr, align 4
  %arrayidx77 = getelementptr inbounds i8*, i8** %78, i32 %79
  %80 = load i8*, i8** %arrayidx77, align 4
  %81 = load i32, i32* %x.addr, align 4
  %arrayidx78 = getelementptr inbounds i8, i8* %80, i32 %81
  %82 = load i8, i8* %arrayidx78, align 1
  %conv79 = zext i8 %82 to i32
  %and = and i32 %conv79, -17
  %conv80 = trunc i32 %and to i8
  store i8 %conv80, i8* %arrayidx78, align 1
  store i32 0, i32* %retval, align 4
  br label %return

return:                                           ; preds = %for.end, %if.end76, %if.then
  %83 = load i32, i32* %retval, align 4
  ret i32 %83
}

; Function Attrs: noinline nounwind optnone
define hidden void @make_maze() #0 {
entry:
  %i = alloca i32, align 4
  %j = alloca i32, align 4
  %h2 = alloca i32, align 4
  %w2 = alloca i32, align 4
  %p = alloca i8**, align 4
  %0 = load i32, i32* @h, align 4
  %mul = mul nsw i32 2, %0
  %add = add nsw i32 %mul, 2
  store i32 %add, i32* %h2, align 4
  %1 = load i32, i32* @w, align 4
  %mul1 = mul nsw i32 2, %1
  %add2 = add nsw i32 %mul1, 2
  store i32 %add2, i32* %w2, align 4
  %2 = load i32, i32* %h2, align 4
  %add3 = add nsw i32 %2, 2
  %mul4 = mul i32 4, %add3
  %3 = load i32, i32* %w2, align 4
  %4 = load i32, i32* %h2, align 4
  %mul5 = mul nsw i32 %3, %4
  %add6 = add i32 %mul4, %mul5
  %add7 = add i32 %add6, 1
  %call = call noalias i8* @calloc(i32 %add7, i32 1)
  %5 = bitcast i8* %call to i8**
  store i8** %5, i8*** %p, align 4
  %6 = load i8**, i8*** %p, align 4
  %7 = load i32, i32* %h2, align 4
  %add.ptr = getelementptr inbounds i8*, i8** %6, i32 %7
  %add.ptr8 = getelementptr inbounds i8*, i8** %add.ptr, i32 2
  %8 = bitcast i8** %add.ptr8 to i8*
  %add.ptr9 = getelementptr inbounds i8, i8* %8, i32 1
  %9 = load i8**, i8*** %p, align 4
  %arrayidx = getelementptr inbounds i8*, i8** %9, i32 1
  store i8* %add.ptr9, i8** %arrayidx, align 4
  store i32 2, i32* %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %10 = load i32, i32* %i, align 4
  %11 = load i32, i32* %h2, align 4
  %cmp = icmp sle i32 %10, %11
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %12 = load i8**, i8*** %p, align 4
  %13 = load i32, i32* %i, align 4
  %sub = sub nsw i32 %13, 1
  %arrayidx10 = getelementptr inbounds i8*, i8** %12, i32 %sub
  %14 = load i8*, i8** %arrayidx10, align 4
  %15 = load i32, i32* %w2, align 4
  %add.ptr11 = getelementptr inbounds i8, i8* %14, i32 %15
  %16 = load i8**, i8*** %p, align 4
  %17 = load i32, i32* %i, align 4
  %arrayidx12 = getelementptr inbounds i8*, i8** %16, i32 %17
  store i8* %add.ptr11, i8** %arrayidx12, align 4
  br label %for.inc

for.inc:                                          ; preds = %for.body
  %18 = load i32, i32* %i, align 4
  %inc = add nsw i32 %18, 1
  store i32 %inc, i32* %i, align 4
  br label %for.cond

for.end:                                          ; preds = %for.cond
  %19 = load i8**, i8*** %p, align 4
  %20 = load i32, i32* %h2, align 4
  %arrayidx13 = getelementptr inbounds i8*, i8** %19, i32 %20
  %21 = load i8*, i8** %arrayidx13, align 4
  %22 = load i8**, i8*** %p, align 4
  %arrayidx14 = getelementptr inbounds i8*, i8** %22, i32 0
  store i8* %21, i8** %arrayidx14, align 4
  %23 = load i8**, i8*** %p, align 4
  %arrayidx15 = getelementptr inbounds i8*, i8** %23, i32 1
  store i8** %arrayidx15, i8*** @cell, align 4
  store i32 -1, i32* %i, align 4
  br label %for.cond16

for.cond16:                                       ; preds = %for.inc26, %for.end
  %24 = load i32, i32* %i, align 4
  %25 = load i32, i32* @h, align 4
  %mul17 = mul nsw i32 2, %25
  %add18 = add nsw i32 %mul17, 1
  %cmp19 = icmp sle i32 %24, %add18
  br i1 %cmp19, label %for.body20, label %for.end28

for.body20:                                       ; preds = %for.cond16
  %26 = load i8**, i8*** @cell, align 4
  %27 = load i32, i32* %i, align 4
  %arrayidx21 = getelementptr inbounds i8*, i8** %26, i32 %27
  %28 = load i8*, i8** %arrayidx21, align 4
  %29 = load i32, i32* %w2, align 4
  %sub22 = sub nsw i32 %29, 1
  %arrayidx23 = getelementptr inbounds i8, i8* %28, i32 %sub22
  store i8 16, i8* %arrayidx23, align 1
  %30 = load i8**, i8*** @cell, align 4
  %31 = load i32, i32* %i, align 4
  %arrayidx24 = getelementptr inbounds i8*, i8** %30, i32 %31
  %32 = load i8*, i8** %arrayidx24, align 4
  %arrayidx25 = getelementptr inbounds i8, i8* %32, i32 -1
  store i8 16, i8* %arrayidx25, align 1
  br label %for.inc26

for.inc26:                                        ; preds = %for.body20
  %33 = load i32, i32* %i, align 4
  %inc27 = add nsw i32 %33, 1
  store i32 %inc27, i32* %i, align 4
  br label %for.cond16

for.end28:                                        ; preds = %for.cond16
  store i32 0, i32* %j, align 4
  br label %for.cond29

for.cond29:                                       ; preds = %for.inc38, %for.end28
  %34 = load i32, i32* %j, align 4
  %35 = load i32, i32* @w, align 4
  %mul30 = mul nsw i32 2, %35
  %cmp31 = icmp sle i32 %34, %mul30
  br i1 %cmp31, label %for.body32, label %for.end40

for.body32:                                       ; preds = %for.cond29
  %36 = load i8**, i8*** @cell, align 4
  %37 = load i32, i32* %h2, align 4
  %sub33 = sub nsw i32 %37, 1
  %arrayidx34 = getelementptr inbounds i8*, i8** %36, i32 %sub33
  %38 = load i8*, i8** %arrayidx34, align 4
  %39 = load i32, i32* %j, align 4
  %arrayidx35 = getelementptr inbounds i8, i8* %38, i32 %39
  store i8 16, i8* %arrayidx35, align 1
  %40 = load i8**, i8*** @cell, align 4
  %arrayidx36 = getelementptr inbounds i8*, i8** %40, i32 -1
  %41 = load i8*, i8** %arrayidx36, align 4
  %42 = load i32, i32* %j, align 4
  %arrayidx37 = getelementptr inbounds i8, i8* %41, i32 %42
  store i8 16, i8* %arrayidx37, align 1
  br label %for.inc38

for.inc38:                                        ; preds = %for.body32
  %43 = load i32, i32* %j, align 4
  %inc39 = add nsw i32 %43, 1
  store i32 %inc39, i32* %j, align 4
  br label %for.cond29

for.end40:                                        ; preds = %for.cond29
  store i32 0, i32* %i, align 4
  br label %for.cond41

for.cond41:                                       ; preds = %for.inc55, %for.end40
  %44 = load i32, i32* %i, align 4
  %45 = load i32, i32* @h, align 4
  %cmp42 = icmp sle i32 %44, %45
  br i1 %cmp42, label %for.body43, label %for.end57

for.body43:                                       ; preds = %for.cond41
  store i32 0, i32* %j, align 4
  br label %for.cond44

for.cond44:                                       ; preds = %for.inc52, %for.body43
  %46 = load i32, i32* %j, align 4
  %47 = load i32, i32* @w, align 4
  %mul45 = mul nsw i32 2, %47
  %cmp46 = icmp sle i32 %46, %mul45
  br i1 %cmp46, label %for.body47, label %for.end54

for.body47:                                       ; preds = %for.cond44
  %48 = load i8**, i8*** @cell, align 4
  %49 = load i32, i32* %i, align 4
  %mul48 = mul nsw i32 2, %49
  %arrayidx49 = getelementptr inbounds i8*, i8** %48, i32 %mul48
  %50 = load i8*, i8** %arrayidx49, align 4
  %51 = load i32, i32* %j, align 4
  %arrayidx50 = getelementptr inbounds i8, i8* %50, i32 %51
  %52 = load i8, i8* %arrayidx50, align 1
  %conv = zext i8 %52 to i32
  %or = or i32 %conv, 12
  %conv51 = trunc i32 %or to i8
  store i8 %conv51, i8* %arrayidx50, align 1
  br label %for.inc52

for.inc52:                                        ; preds = %for.body47
  %53 = load i32, i32* %j, align 4
  %inc53 = add nsw i32 %53, 1
  store i32 %inc53, i32* %j, align 4
  br label %for.cond44

for.end54:                                        ; preds = %for.cond44
  br label %for.inc55

for.inc55:                                        ; preds = %for.end54
  %54 = load i32, i32* %i, align 4
  %inc56 = add nsw i32 %54, 1
  store i32 %inc56, i32* %i, align 4
  br label %for.cond41

for.end57:                                        ; preds = %for.cond41
  store i32 0, i32* %i, align 4
  br label %for.cond58

for.cond58:                                       ; preds = %for.inc76, %for.end57
  %55 = load i32, i32* %i, align 4
  %56 = load i32, i32* @h, align 4
  %mul59 = mul nsw i32 2, %56
  %cmp60 = icmp sle i32 %55, %mul59
  br i1 %cmp60, label %for.body62, label %for.end78

for.body62:                                       ; preds = %for.cond58
  store i32 0, i32* %j, align 4
  br label %for.cond63

for.cond63:                                       ; preds = %for.inc73, %for.body62
  %57 = load i32, i32* %j, align 4
  %58 = load i32, i32* @w, align 4
  %cmp64 = icmp sle i32 %57, %58
  br i1 %cmp64, label %for.body66, label %for.end75

for.body66:                                       ; preds = %for.cond63
  %59 = load i8**, i8*** @cell, align 4
  %60 = load i32, i32* %i, align 4
  %arrayidx67 = getelementptr inbounds i8*, i8** %59, i32 %60
  %61 = load i8*, i8** %arrayidx67, align 4
  %62 = load i32, i32* %j, align 4
  %mul68 = mul nsw i32 2, %62
  %arrayidx69 = getelementptr inbounds i8, i8* %61, i32 %mul68
  %63 = load i8, i8* %arrayidx69, align 1
  %conv70 = zext i8 %63 to i32
  %or71 = or i32 %conv70, 3
  %conv72 = trunc i32 %or71 to i8
  store i8 %conv72, i8* %arrayidx69, align 1
  br label %for.inc73

for.inc73:                                        ; preds = %for.body66
  %64 = load i32, i32* %j, align 4
  %inc74 = add nsw i32 %64, 1
  store i32 %inc74, i32* %j, align 4
  br label %for.cond63

for.end75:                                        ; preds = %for.cond63
  br label %for.inc76

for.inc76:                                        ; preds = %for.end75
  %65 = load i32, i32* %i, align 4
  %inc77 = add nsw i32 %65, 1
  store i32 %inc77, i32* %i, align 4
  br label %for.cond58

for.end78:                                        ; preds = %for.cond58
  store i32 0, i32* %j, align 4
  br label %for.cond79

for.cond79:                                       ; preds = %for.inc94, %for.end78
  %66 = load i32, i32* %j, align 4
  %67 = load i32, i32* @w, align 4
  %mul80 = mul nsw i32 2, %67
  %cmp81 = icmp sle i32 %66, %mul80
  br i1 %cmp81, label %for.body83, label %for.end96

for.body83:                                       ; preds = %for.cond79
  %68 = load i8**, i8*** @cell, align 4
  %arrayidx84 = getelementptr inbounds i8*, i8** %68, i32 0
  %69 = load i8*, i8** %arrayidx84, align 4
  %70 = load i32, i32* %j, align 4
  %arrayidx85 = getelementptr inbounds i8, i8* %69, i32 %70
  %71 = load i8, i8* %arrayidx85, align 1
  %conv86 = zext i8 %71 to i32
  %and = and i32 %conv86, -2
  %conv87 = trunc i32 %and to i8
  store i8 %conv87, i8* %arrayidx85, align 1
  %72 = load i8**, i8*** @cell, align 4
  %73 = load i32, i32* @h, align 4
  %mul88 = mul nsw i32 2, %73
  %arrayidx89 = getelementptr inbounds i8*, i8** %72, i32 %mul88
  %74 = load i8*, i8** %arrayidx89, align 4
  %75 = load i32, i32* %j, align 4
  %arrayidx90 = getelementptr inbounds i8, i8* %74, i32 %75
  %76 = load i8, i8* %arrayidx90, align 1
  %conv91 = zext i8 %76 to i32
  %and92 = and i32 %conv91, -3
  %conv93 = trunc i32 %and92 to i8
  store i8 %conv93, i8* %arrayidx90, align 1
  br label %for.inc94

for.inc94:                                        ; preds = %for.body83
  %77 = load i32, i32* %j, align 4
  %inc95 = add nsw i32 %77, 1
  store i32 %inc95, i32* %j, align 4
  br label %for.cond79

for.end96:                                        ; preds = %for.cond79
  store i32 0, i32* %i, align 4
  br label %for.cond97

for.cond97:                                       ; preds = %for.inc113, %for.end96
  %78 = load i32, i32* %i, align 4
  %79 = load i32, i32* @h, align 4
  %mul98 = mul nsw i32 2, %79
  %cmp99 = icmp sle i32 %78, %mul98
  br i1 %cmp99, label %for.body101, label %for.end115

for.body101:                                      ; preds = %for.cond97
  %80 = load i8**, i8*** @cell, align 4
  %81 = load i32, i32* %i, align 4
  %arrayidx102 = getelementptr inbounds i8*, i8** %80, i32 %81
  %82 = load i8*, i8** %arrayidx102, align 4
  %arrayidx103 = getelementptr inbounds i8, i8* %82, i32 0
  %83 = load i8, i8* %arrayidx103, align 1
  %conv104 = zext i8 %83 to i32
  %and105 = and i32 %conv104, -5
  %conv106 = trunc i32 %and105 to i8
  store i8 %conv106, i8* %arrayidx103, align 1
  %84 = load i8**, i8*** @cell, align 4
  %85 = load i32, i32* %i, align 4
  %arrayidx107 = getelementptr inbounds i8*, i8** %84, i32 %85
  %86 = load i8*, i8** %arrayidx107, align 4
  %87 = load i32, i32* @w, align 4
  %mul108 = mul nsw i32 2, %87
  %arrayidx109 = getelementptr inbounds i8, i8* %86, i32 %mul108
  %88 = load i8, i8* %arrayidx109, align 1
  %conv110 = zext i8 %88 to i32
  %and111 = and i32 %conv110, -9
  %conv112 = trunc i32 %and111 to i8
  store i8 %conv112, i8* %arrayidx109, align 1
  br label %for.inc113

for.inc113:                                       ; preds = %for.body101
  %89 = load i32, i32* %i, align 4
  %inc114 = add nsw i32 %89, 1
  store i32 %inc114, i32* %i, align 4
  br label %for.cond97

for.end115:                                       ; preds = %for.cond97
  %90 = load i32, i32* @w, align 4
  %91 = load i32, i32* @h, align 4
  %mul116 = mul nsw i32 %90, %91
  store i32 %mul116, i32* @avail, align 4
  %call117 = call i32 @irand(i32 2)
  %mul118 = mul nsw i32 %call117, 2
  %add119 = add nsw i32 %mul118, 1
  %92 = load i32, i32* @h, align 4
  %call120 = call i32 @irand(i32 %92)
  %mul121 = mul nsw i32 %call120, 2
  %add122 = add nsw i32 %mul121, 1
  call void @walk(i32 %add119, i32 %add122)
  store i32 0, i32* %i, align 4
  br label %for.cond123

for.cond123:                                      ; preds = %for.inc141, %for.end115
  %93 = load i32, i32* %i, align 4
  %94 = load i32, i32* @h, align 4
  %mul124 = mul nsw i32 2, %94
  %cmp125 = icmp sle i32 %93, %mul124
  br i1 %cmp125, label %for.body127, label %for.end143

for.body127:                                      ; preds = %for.cond123
  store i32 0, i32* %j, align 4
  br label %for.cond128

for.cond128:                                      ; preds = %for.inc138, %for.body127
  %95 = load i32, i32* %j, align 4
  %96 = load i32, i32* @w, align 4
  %mul129 = mul nsw i32 2, %96
  %cmp130 = icmp sle i32 %95, %mul129
  br i1 %cmp130, label %for.body132, label %for.end140

for.body132:                                      ; preds = %for.cond128
  %97 = load i8**, i8*** @cell, align 4
  %98 = load i32, i32* %i, align 4
  %arrayidx133 = getelementptr inbounds i8*, i8** %97, i32 %98
  %99 = load i8*, i8** %arrayidx133, align 4
  %100 = load i32, i32* %j, align 4
  %arrayidx134 = getelementptr inbounds i8, i8* %99, i32 %100
  %101 = load i8, i8* %arrayidx134, align 1
  %conv135 = zext i8 %101 to i32
  %and136 = and i32 %conv135, -17
  %conv137 = trunc i32 %and136 to i8
  store i8 %conv137, i8* %arrayidx134, align 1
  br label %for.inc138

for.inc138:                                       ; preds = %for.body132
  %102 = load i32, i32* %j, align 4
  %inc139 = add nsw i32 %102, 1
  store i32 %inc139, i32* %j, align 4
  br label %for.cond128

for.end140:                                       ; preds = %for.cond128
  br label %for.inc141

for.inc141:                                       ; preds = %for.end140
  %103 = load i32, i32* %i, align 4
  %inc142 = add nsw i32 %103, 1
  store i32 %inc142, i32* %i, align 4
  br label %for.cond123

for.end143:                                       ; preds = %for.cond123
  %104 = load i32, i32* @w, align 4
  %mul144 = mul nsw i32 2, %104
  %sub145 = sub nsw i32 %mul144, 1
  %105 = load i32, i32* @h, align 4
  %mul146 = mul nsw i32 2, %105
  %sub147 = sub nsw i32 %mul146, 1
  %call148 = call i32 @solve(i32 1, i32 1, i32 %sub145, i32 %sub147)
  call void @show()
  ret void
}

declare noalias i8* @calloc(i32 %0, i32 %1) #1

; Function Attrs: noinline nounwind optnone
define hidden i32 @__main_argc_argv(i32 %c, i8** %v) #0 {
entry:
  %retval = alloca i32, align 4
  %c.addr = alloca i32, align 4
  %v.addr = alloca i8**, align 4
  store i32 0, i32* %retval, align 4
  store i32 %c, i32* %c.addr, align 4
  store i8** %v, i8*** %v.addr, align 4
  %call = call i8* @setlocale(i32 6, i8* getelementptr inbounds ([1 x i8], [1 x i8]* @.str.3, i32 0, i32 0))
  %0 = load i32, i32* %c.addr, align 4
  %cmp = icmp slt i32 %0, 2
  br i1 %cmp, label %if.then, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %entry
  %1 = load i8**, i8*** %v.addr, align 4
  %arrayidx = getelementptr inbounds i8*, i8** %1, i32 1
  %2 = load i8*, i8** %arrayidx, align 4
  %call1 = call i32 @atoi(i8* %2)
  store i32 %call1, i32* @w, align 4
  %cmp2 = icmp sle i32 %call1, 0
  br i1 %cmp2, label %if.then, label %if.end

if.then:                                          ; preds = %lor.lhs.false, %entry
  store i32 16, i32* @w, align 4
  br label %if.end

if.end:                                           ; preds = %if.then, %lor.lhs.false
  %3 = load i32, i32* %c.addr, align 4
  %cmp3 = icmp slt i32 %3, 3
  br i1 %cmp3, label %if.then8, label %lor.lhs.false4

lor.lhs.false4:                                   ; preds = %if.end
  %4 = load i8**, i8*** %v.addr, align 4
  %arrayidx5 = getelementptr inbounds i8*, i8** %4, i32 2
  %5 = load i8*, i8** %arrayidx5, align 4
  %call6 = call i32 @atoi(i8* %5)
  store i32 %call6, i32* @h, align 4
  %cmp7 = icmp sle i32 %call6, 0
  br i1 %cmp7, label %if.then8, label %if.end9

if.then8:                                         ; preds = %lor.lhs.false4, %if.end
  store i32 8, i32* @h, align 4
  br label %if.end9

if.end9:                                          ; preds = %if.then8, %lor.lhs.false4
  call void @make_maze()
  ret i32 0
}

declare i8* @setlocale(i32 %0, i8* %1) #1

declare i32 @atoi(i8* %0) #1

attributes #0 = { noinline nounwind optnone "correctly-rounded-divide-sqrt-fp-math"="false" "disable-tail-calls"="false" "frame-pointer"="none" "less-precise-fpmad"="false" "min-legal-vector-width"="0" "no-infs-fp-math"="false" "no-jump-tables"="false" "no-nans-fp-math"="false" "no-signed-zeros-fp-math"="false" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="generic" "unsafe-fp-math"="false" "use-soft-float"="false" }
attributes #1 = { "correctly-rounded-divide-sqrt-fp-math"="false" "disable-tail-calls"="false" "frame-pointer"="none" "less-precise-fpmad"="false" "no-infs-fp-math"="false" "no-nans-fp-math"="false" "no-signed-zeros-fp-math"="false" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="generic" "unsafe-fp-math"="false" "use-soft-float"="false" }
attributes #2 = { argmemonly nounwind willreturn }

!llvm.module.flags = !{!0}
!llvm.ident = !{!1}

!0 = !{i32 1, !"wchar_size", i32 4}
!1 = !{!"clang version 11.0.0 (https://github.com/Jacarte/llvm-project.git 0f6dea67136cc1e0b3d200eb2bb165628970c44b)"}

; extracted candidates

; *****
; For LLVM instruction:
;  %0 = load i32, i32* %c.addr, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %cmp = icmp slt i32 %0, 2
; Looking for a replacement for:
%0:i32 = var
%1:i1 = slt %0, 2:i32
infer %1

; *****
; For LLVM instruction:
;  %call1 = call i32 @atoi(i8* %2)
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %cmp2 = icmp sle i32 %call1, 0
; Looking for a replacement for:
%0:i32 = var
%1:i1 = sle %0, 0:i32
infer %1

; *****
; For LLVM instruction:
;  %3 = load i32, i32* %c.addr, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %cmp3 = icmp slt i32 %3, 3
; Looking for a replacement for:
%0:i32 = var
%1:i1 = slt %0, 3:i32
infer %1

; *****
; For LLVM instruction:
;  %call6 = call i32 @atoi(i8* %5)
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %cmp7 = icmp sle i32 %call6, 0
; Looking for a replacement for:
%0:i32 = var
%1:i1 = sle %0, 0:i32
infer %1
got 2 candidates from LHS

-------------------------------------------------
%0:i32 = var
%1:i1 = slt %0, 2:i32
infer %1


--------------------------------
guess 0

%0:i1 = var ; reservedconst_1

Cost = 0
first query is SAT, returning the model:
reservedconst_1: -1
0 th attempt: second query is SAT-- constant doesn't work
first query is SAT, returning the model:
reservedconst_1: 0
1 th attempt: second query is SAT-- constant doesn't work
first query is UNSAT-- no more guesses
Dataflow Pruned 0/0
There are 1 Guesses
There are 0 RHSs before deduplication
There are 0 RHSs after deduplication
got 2 candidates from LHS

-------------------------------------------------
%0:i32 = var
%1:i1 = sle %0, 0:i32
infer %1


--------------------------------
guess 0

%0:i1 = var ; reservedconst_1

Cost = 0
first query is SAT, returning the model:
reservedconst_1: -1
0 th attempt: second query is SAT-- constant doesn't work
first query is SAT, returning the model:
reservedconst_1: 0
1 th attempt: second query is SAT-- constant doesn't work
first query is UNSAT-- no more guesses
Dataflow Pruned 0/0
There are 1 Guesses
There are 0 RHSs before deduplication
There are 0 RHSs after deduplication
got 2 candidates from LHS

-------------------------------------------------
%0:i32 = var
%1:i1 = slt %0, 3:i32
infer %1


--------------------------------
guess 0

%0:i1 = var ; reservedconst_1

Cost = 0
first query is SAT, returning the model:
reservedconst_1: -1
0 th attempt: second query is SAT-- constant doesn't work
first query is SAT, returning the model:
reservedconst_1: 0
1 th attempt: second query is SAT-- constant doesn't work
first query is UNSAT-- no more guesses
Dataflow Pruned 0/0
There are 1 Guesses
There are 0 RHSs before deduplication
There are 0 RHSs after deduplication
#########################################################
; exiting Souper's runOnFunction() for __main_argc_argv()
Total of 0 replacements done on this module
Total of 0 replacements candidates on this module
