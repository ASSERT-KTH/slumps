
Entering the Souper pass's runOnModule()


; entering Souper's runOnFunction() for find()

; ModuleID = './Imaginary_base_numbers.c.bc'
source_filename = "./Imaginary_base_numbers.c"
target datalayout = "e-m:e-p:32:32-i64:64-n32:64-S128"
target triple = "wasm32-unknown-wasi"

%struct.Complex = type { double, double }
%struct.QuaterImaginary = type { i8*, i32 }

@.str = private unnamed_addr constant [17 x i8] c"(%3.0f + %3.0fi)\00", align 1
@TWO_I = hidden constant %struct.Complex { double 0.000000e+00, double 2.000000e+00 }, align 8
@INV_TWO_I = hidden constant %struct.Complex { double 0.000000e+00, double -5.000000e-01 }, align 8
@.str.1 = private unnamed_addr constant [4 x i8] c"%8s\00", align 1
@.str.2 = private unnamed_addr constant [9 x i8] c" ERROR  \00", align 1
@.str.3 = private unnamed_addr constant [2 x i8] c"0\00", align 1
@.str.4 = private unnamed_addr constant [5 x i8] c" -> \00", align 1
@.str.5 = private unnamed_addr constant [6 x i8] c"     \00", align 1
@.str.6 = private unnamed_addr constant [2 x i8] c"\0A\00", align 1
@llvm.used = appending global [1 x i8*] [i8* bitcast (i32 ()* @__main_void to i8*)], section "llvm.metadata"

@__main_void = alias i32 (), i32 ()* @main

; Function Attrs: noinline nounwind optnone
define hidden i32 @find(i8* %s, i8 signext %c) #0 {
entry:
  %retval = alloca i32, align 4
  %s.addr = alloca i8*, align 4
  %c.addr = alloca i8, align 1
  %i = alloca i8*, align 4
  store i8* %s, i8** %s.addr, align 4
  store i8 %c, i8* %c.addr, align 1
  %0 = load i8*, i8** %s.addr, align 4
  store i8* %0, i8** %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %1 = load i8*, i8** %i, align 4
  %2 = load i8, i8* %1, align 1
  %conv = sext i8 %2 to i32
  %cmp = icmp ne i32 %conv, 0
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %3 = load i8*, i8** %i, align 4
  %4 = load i8, i8* %3, align 1
  %conv2 = sext i8 %4 to i32
  %5 = load i8, i8* %c.addr, align 1
  %conv3 = sext i8 %5 to i32
  %cmp4 = icmp eq i32 %conv2, %conv3
  br i1 %cmp4, label %if.then, label %if.end

if.then:                                          ; preds = %for.body
  %6 = load i8*, i8** %i, align 4
  %7 = load i8*, i8** %s.addr, align 4
  %sub.ptr.lhs.cast = ptrtoint i8* %6 to i32
  %sub.ptr.rhs.cast = ptrtoint i8* %7 to i32
  %sub.ptr.sub = sub i32 %sub.ptr.lhs.cast, %sub.ptr.rhs.cast
  store i32 %sub.ptr.sub, i32* %retval, align 4
  br label %return

if.end:                                           ; preds = %for.body
  br label %for.inc

for.inc:                                          ; preds = %if.end
  %8 = load i8*, i8** %i, align 4
  %incdec.ptr = getelementptr inbounds i8, i8* %8, i32 1
  store i8* %incdec.ptr, i8** %i, align 4
  br label %for.cond

for.end:                                          ; preds = %for.cond
  store i32 -1, i32* %retval, align 4
  br label %return

return:                                           ; preds = %for.end, %if.then
  %9 = load i32, i32* %retval, align 4
  ret i32 %9
}

; Function Attrs: noinline nounwind optnone
define hidden void @reverse(i8* %b, i8* %e) #0 {
entry:
  %b.addr = alloca i8*, align 4
  %e.addr = alloca i8*, align 4
  %t = alloca i8, align 1
  store i8* %b, i8** %b.addr, align 4
  store i8* %e, i8** %e.addr, align 4
  %0 = load i8*, i8** %e.addr, align 4
  %incdec.ptr = getelementptr inbounds i8, i8* %0, i32 -1
  store i8* %incdec.ptr, i8** %e.addr, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %1 = load i8*, i8** %b.addr, align 4
  %2 = load i8*, i8** %e.addr, align 4
  %cmp = icmp ult i8* %1, %2
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %3 = load i8*, i8** %b.addr, align 4
  %4 = load i8, i8* %3, align 1
  store i8 %4, i8* %t, align 1
  %5 = load i8*, i8** %e.addr, align 4
  %6 = load i8, i8* %5, align 1
  %7 = load i8*, i8** %b.addr, align 4
  store i8 %6, i8* %7, align 1
  %8 = load i8, i8* %t, align 1
  %9 = load i8*, i8** %e.addr, align 4
  store i8 %8, i8* %9, align 1
  br label %for.inc

for.inc:                                          ; preds = %for.body
  %10 = load i8*, i8** %b.addr, align 4
  %incdec.ptr1 = getelementptr inbounds i8, i8* %10, i32 1
  store i8* %incdec.ptr1, i8** %b.addr, align 4
  %11 = load i8*, i8** %e.addr, align 4
  %incdec.ptr2 = getelementptr inbounds i8, i8* %11, i32 -1
  store i8* %incdec.ptr2, i8** %e.addr, align 4
  br label %for.cond

for.end:                                          ; preds = %for.cond
  ret void
}

; Function Attrs: noinline nounwind optnone
define hidden void @printComplex(%struct.Complex* byval(%struct.Complex) align 8 %c) #0 {
entry:
  %rel = getelementptr inbounds %struct.Complex, %struct.Complex* %c, i32 0, i32 0
  %0 = load double, double* %rel, align 8
  %img = getelementptr inbounds %struct.Complex, %struct.Complex* %c, i32 0, i32 1
  %1 = load double, double* %img, align 8
  %call = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([17 x i8], [17 x i8]* @.str, i32 0, i32 0), double %0, double %1)
  ret void
}

declare i32 @printf(i8* %0, ...) #1

; Function Attrs: noinline nounwind optnone
define hidden void @makeComplex(%struct.Complex* noalias sret align 8 %agg.result, double %rel, double %img) #0 {
entry:
  %rel.addr = alloca double, align 8
  %img.addr = alloca double, align 8
  store double %rel, double* %rel.addr, align 8
  store double %img, double* %img.addr, align 8
  %rel1 = getelementptr inbounds %struct.Complex, %struct.Complex* %agg.result, i32 0, i32 0
  %0 = load double, double* %rel.addr, align 8
  store double %0, double* %rel1, align 8
  %img2 = getelementptr inbounds %struct.Complex, %struct.Complex* %agg.result, i32 0, i32 1
  %1 = load double, double* %img.addr, align 8
  store double %1, double* %img2, align 8
  ret void
}

; Function Attrs: noinline nounwind optnone
define hidden void @addComplex(%struct.Complex* noalias sret align 8 %agg.result, %struct.Complex* byval(%struct.Complex) align 8 %a, %struct.Complex* byval(%struct.Complex) align 8 %b) #0 {
entry:
  %rel = getelementptr inbounds %struct.Complex, %struct.Complex* %agg.result, i32 0, i32 0
  %rel1 = getelementptr inbounds %struct.Complex, %struct.Complex* %a, i32 0, i32 0
  %0 = load double, double* %rel1, align 8
  %rel2 = getelementptr inbounds %struct.Complex, %struct.Complex* %b, i32 0, i32 0
  %1 = load double, double* %rel2, align 8
  %add = fadd double %0, %1
  store double %add, double* %rel, align 8
  %img = getelementptr inbounds %struct.Complex, %struct.Complex* %agg.result, i32 0, i32 1
  %img3 = getelementptr inbounds %struct.Complex, %struct.Complex* %a, i32 0, i32 1
  %2 = load double, double* %img3, align 8
  %img4 = getelementptr inbounds %struct.Complex, %struct.Complex* %b, i32 0, i32 1
  %3 = load double, double* %img4, align 8
  %add5 = fadd double %2, %3
  store double %add5, double* %img, align 8
  ret void
}

; Function Attrs: noinline nounwind optnone
define hidden void @mulComplex(%struct.Complex* noalias sret align 8 %agg.result, %struct.Complex* byval(%struct.Complex) align 8 %a, %struct.Complex* byval(%struct.Complex) align 8 %b) #0 {
entry:
  %rel = getelementptr inbounds %struct.Complex, %struct.Complex* %agg.result, i32 0, i32 0
  %rel1 = getelementptr inbounds %struct.Complex, %struct.Complex* %a, i32 0, i32 0
  %0 = load double, double* %rel1, align 8
  %rel2 = getelementptr inbounds %struct.Complex, %struct.Complex* %b, i32 0, i32 0
  %1 = load double, double* %rel2, align 8
  %mul = fmul double %0, %1
  %img = getelementptr inbounds %struct.Complex, %struct.Complex* %a, i32 0, i32 1
  %2 = load double, double* %img, align 8
  %img3 = getelementptr inbounds %struct.Complex, %struct.Complex* %b, i32 0, i32 1
  %3 = load double, double* %img3, align 8
  %mul4 = fmul double %2, %3
  %sub = fsub double %mul, %mul4
  store double %sub, double* %rel, align 8
  %img5 = getelementptr inbounds %struct.Complex, %struct.Complex* %agg.result, i32 0, i32 1
  %rel6 = getelementptr inbounds %struct.Complex, %struct.Complex* %a, i32 0, i32 0
  %4 = load double, double* %rel6, align 8
  %img7 = getelementptr inbounds %struct.Complex, %struct.Complex* %b, i32 0, i32 1
  %5 = load double, double* %img7, align 8
  %mul8 = fmul double %4, %5
  %img9 = getelementptr inbounds %struct.Complex, %struct.Complex* %a, i32 0, i32 1
  %6 = load double, double* %img9, align 8
  %rel10 = getelementptr inbounds %struct.Complex, %struct.Complex* %b, i32 0, i32 0
  %7 = load double, double* %rel10, align 8
  %mul11 = fmul double %6, %7
  %sub12 = fsub double %mul8, %mul11
  store double %sub12, double* %img5, align 8
  ret void
}

; Function Attrs: noinline nounwind optnone
define hidden void @mulComplexD(%struct.Complex* noalias sret align 8 %agg.result, %struct.Complex* byval(%struct.Complex) align 8 %a, double %b) #0 {
entry:
  %b.addr = alloca double, align 8
  store double %b, double* %b.addr, align 8
  %rel = getelementptr inbounds %struct.Complex, %struct.Complex* %agg.result, i32 0, i32 0
  %rel1 = getelementptr inbounds %struct.Complex, %struct.Complex* %a, i32 0, i32 0
  %0 = load double, double* %rel1, align 8
  %1 = load double, double* %b.addr, align 8
  %mul = fmul double %0, %1
  store double %mul, double* %rel, align 8
  %img = getelementptr inbounds %struct.Complex, %struct.Complex* %agg.result, i32 0, i32 1
  %img2 = getelementptr inbounds %struct.Complex, %struct.Complex* %a, i32 0, i32 1
  %2 = load double, double* %img2, align 8
  %3 = load double, double* %b.addr, align 8
  %mul3 = fmul double %2, %3
  store double %mul3, double* %img, align 8
  ret void
}

; Function Attrs: noinline nounwind optnone
define hidden void @negComplex(%struct.Complex* noalias sret align 8 %agg.result, %struct.Complex* byval(%struct.Complex) align 8 %a) #0 {
entry:
  call void @mulComplexD(%struct.Complex* sret align 8 %agg.result, %struct.Complex* byval(%struct.Complex) align 8 %a, double -1.000000e+00)
  ret void
}

; Function Attrs: noinline nounwind optnone
define hidden void @divComplex(%struct.Complex* noalias sret align 8 %agg.result, %struct.Complex* byval(%struct.Complex) align 8 %a, %struct.Complex* byval(%struct.Complex) align 8 %b) #0 {
entry:
  %re = alloca double, align 8
  %im = alloca double, align 8
  %d = alloca double, align 8
  %rel = getelementptr inbounds %struct.Complex, %struct.Complex* %a, i32 0, i32 0
  %0 = load double, double* %rel, align 8
  %rel1 = getelementptr inbounds %struct.Complex, %struct.Complex* %b, i32 0, i32 0
  %1 = load double, double* %rel1, align 8
  %mul = fmul double %0, %1
  %img = getelementptr inbounds %struct.Complex, %struct.Complex* %a, i32 0, i32 1
  %2 = load double, double* %img, align 8
  %img2 = getelementptr inbounds %struct.Complex, %struct.Complex* %b, i32 0, i32 1
  %3 = load double, double* %img2, align 8
  %mul3 = fmul double %2, %3
  %add = fadd double %mul, %mul3
  store double %add, double* %re, align 8
  %img4 = getelementptr inbounds %struct.Complex, %struct.Complex* %a, i32 0, i32 1
  %4 = load double, double* %img4, align 8
  %rel5 = getelementptr inbounds %struct.Complex, %struct.Complex* %b, i32 0, i32 0
  %5 = load double, double* %rel5, align 8
  %mul6 = fmul double %4, %5
  %rel7 = getelementptr inbounds %struct.Complex, %struct.Complex* %a, i32 0, i32 0
  %6 = load double, double* %rel7, align 8
  %img8 = getelementptr inbounds %struct.Complex, %struct.Complex* %b, i32 0, i32 1
  %7 = load double, double* %img8, align 8
  %mul9 = fmul double %6, %7
  %sub = fsub double %mul6, %mul9
  store double %sub, double* %im, align 8
  %rel10 = getelementptr inbounds %struct.Complex, %struct.Complex* %b, i32 0, i32 0
  %8 = load double, double* %rel10, align 8
  %rel11 = getelementptr inbounds %struct.Complex, %struct.Complex* %b, i32 0, i32 0
  %9 = load double, double* %rel11, align 8
  %mul12 = fmul double %8, %9
  %img13 = getelementptr inbounds %struct.Complex, %struct.Complex* %b, i32 0, i32 1
  %10 = load double, double* %img13, align 8
  %img14 = getelementptr inbounds %struct.Complex, %struct.Complex* %b, i32 0, i32 1
  %11 = load double, double* %img14, align 8
  %mul15 = fmul double %10, %11
  %add16 = fadd double %mul12, %mul15
  store double %add16, double* %d, align 8
  %rel17 = getelementptr inbounds %struct.Complex, %struct.Complex* %agg.result, i32 0, i32 0
  %12 = load double, double* %re, align 8
  %13 = load double, double* %d, align 8
  %div = fdiv double %12, %13
  store double %div, double* %rel17, align 8
  %img18 = getelementptr inbounds %struct.Complex, %struct.Complex* %agg.result, i32 0, i32 1
  %14 = load double, double* %im, align 8
  %15 = load double, double* %d, align 8
  %div19 = fdiv double %14, %15
  store double %div19, double* %img18, align 8
  ret void
}

; Function Attrs: noinline nounwind optnone
define hidden void @inv(%struct.Complex* noalias sret align 8 %agg.result, %struct.Complex* byval(%struct.Complex) align 8 %c) #0 {
entry:
  %d = alloca double, align 8
  %rel = getelementptr inbounds %struct.Complex, %struct.Complex* %c, i32 0, i32 0
  %0 = load double, double* %rel, align 8
  %rel1 = getelementptr inbounds %struct.Complex, %struct.Complex* %c, i32 0, i32 0
  %1 = load double, double* %rel1, align 8
  %mul = fmul double %0, %1
  %img = getelementptr inbounds %struct.Complex, %struct.Complex* %c, i32 0, i32 1
  %2 = load double, double* %img, align 8
  %img2 = getelementptr inbounds %struct.Complex, %struct.Complex* %c, i32 0, i32 1
  %3 = load double, double* %img2, align 8
  %mul3 = fmul double %2, %3
  %add = fadd double %mul, %mul3
  store double %add, double* %d, align 8
  %rel4 = getelementptr inbounds %struct.Complex, %struct.Complex* %agg.result, i32 0, i32 0
  %rel5 = getelementptr inbounds %struct.Complex, %struct.Complex* %c, i32 0, i32 0
  %4 = load double, double* %rel5, align 8
  %5 = load double, double* %d, align 8
  %div = fdiv double %4, %5
  store double %div, double* %rel4, align 8
  %img6 = getelementptr inbounds %struct.Complex, %struct.Complex* %agg.result, i32 0, i32 1
  %img7 = getelementptr inbounds %struct.Complex, %struct.Complex* %c, i32 0, i32 1
  %6 = load double, double* %img7, align 8
  %fneg = fneg double %6
  %7 = load double, double* %d, align 8
  %div8 = fdiv double %fneg, %7
  store double %div8, double* %img6, align 8
  ret void
}

; Function Attrs: noinline nounwind optnone
define hidden void @makeQuaterImaginary(%struct.QuaterImaginary* noalias sret align 4 %agg.result, i8* %s) #0 {
entry:
  %s.addr = alloca i8*, align 4
  %i = alloca i32, align 4
  %valid1 = alloca i32, align 4
  %cnt = alloca i32, align 4
  store i8* %s, i8** %s.addr, align 4
  %b2i = getelementptr inbounds %struct.QuaterImaginary, %struct.QuaterImaginary* %agg.result, i32 0, i32 0
  %0 = load i8*, i8** %s.addr, align 4
  store i8* %0, i8** %b2i, align 4
  %valid = getelementptr inbounds %struct.QuaterImaginary, %struct.QuaterImaginary* %agg.result, i32 0, i32 1
  store i32 0, i32* %valid, align 4
  store i32 1, i32* %valid1, align 4
  store i32 0, i32* %cnt, align 4
  %1 = load i8*, i8** %s.addr, align 4
  %2 = load i8, i8* %1, align 1
  %conv = sext i8 %2 to i32
  %cmp = icmp ne i32 %conv, 0
  br i1 %cmp, label %if.then, label %if.end26

if.then:                                          ; preds = %entry
  store i32 0, i32* %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.then
  %3 = load i8*, i8** %s.addr, align 4
  %4 = load i32, i32* %i, align 4
  %arrayidx = getelementptr inbounds i8, i8* %3, i32 %4
  %5 = load i8, i8* %arrayidx, align 1
  %conv3 = sext i8 %5 to i32
  %cmp4 = icmp ne i32 %conv3, 0
  br i1 %cmp4, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %6 = load i8*, i8** %s.addr, align 4
  %7 = load i32, i32* %i, align 4
  %arrayidx6 = getelementptr inbounds i8, i8* %6, i32 %7
  %8 = load i8, i8* %arrayidx6, align 1
  %conv7 = sext i8 %8 to i32
  %cmp8 = icmp slt i32 %conv7, 48
  br i1 %cmp8, label %if.then14, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %for.body
  %9 = load i8*, i8** %s.addr, align 4
  %10 = load i32, i32* %i, align 4
  %arrayidx10 = getelementptr inbounds i8, i8* %9, i32 %10
  %11 = load i8, i8* %arrayidx10, align 1
  %conv11 = sext i8 %11 to i32
  %cmp12 = icmp slt i32 51, %conv11
  br i1 %cmp12, label %if.then14, label %if.end20

if.then14:                                        ; preds = %lor.lhs.false, %for.body
  %12 = load i8*, i8** %s.addr, align 4
  %13 = load i32, i32* %i, align 4
  %arrayidx15 = getelementptr inbounds i8, i8* %12, i32 %13
  %14 = load i8, i8* %arrayidx15, align 1
  %conv16 = sext i8 %14 to i32
  %cmp17 = icmp eq i32 %conv16, 46
  br i1 %cmp17, label %if.then19, label %if.else

if.then19:                                        ; preds = %if.then14
  %15 = load i32, i32* %cnt, align 4
  %inc = add i32 %15, 1
  store i32 %inc, i32* %cnt, align 4
  br label %if.end

if.else:                                          ; preds = %if.then14
  store i32 0, i32* %valid1, align 4
  br label %for.end

if.end:                                           ; preds = %if.then19
  br label %if.end20

if.end20:                                         ; preds = %if.end, %lor.lhs.false
  br label %for.inc

for.inc:                                          ; preds = %if.end20
  %16 = load i32, i32* %i, align 4
  %inc21 = add i32 %16, 1
  store i32 %inc21, i32* %i, align 4
  br label %for.cond

for.end:                                          ; preds = %if.else, %for.cond
  %17 = load i32, i32* %valid1, align 4
  %tobool = icmp ne i32 %17, 0
  br i1 %tobool, label %land.lhs.true, label %if.end25

land.lhs.true:                                    ; preds = %for.end
  %18 = load i32, i32* %cnt, align 4
  %cmp22 = icmp ugt i32 %18, 1
  br i1 %cmp22, label %if.then24, label %if.end25

if.then24:                                        ; preds = %land.lhs.true
  store i32 0, i32* %valid1, align 4
  br label %if.end25

if.end25:                                         ; preds = %if.then24, %land.lhs.true, %for.end
  br label %if.end26

if.end26:                                         ; preds = %if.end25, %entry
  %19 = load i32, i32* %valid1, align 4
  %valid27 = getelementptr inbounds %struct.QuaterImaginary, %struct.QuaterImaginary* %agg.result, i32 0, i32 1
  store i32 %19, i32* %valid27, align 4
  ret void
}

; Function Attrs: noinline nounwind optnone
define hidden void @printQuaterImaginary(%struct.QuaterImaginary* byval(%struct.QuaterImaginary) align 4 %qi) #0 {
entry:
  %valid = getelementptr inbounds %struct.QuaterImaginary, %struct.QuaterImaginary* %qi, i32 0, i32 1
  %0 = load i32, i32* %valid, align 4
  %tobool = icmp ne i32 %0, 0
  br i1 %tobool, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  %b2i = getelementptr inbounds %struct.QuaterImaginary, %struct.QuaterImaginary* %qi, i32 0, i32 0
  %1 = load i8*, i8** %b2i, align 4
  %call = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([4 x i8], [4 x i8]* @.str.1, i32 0, i32 0), i8* %1)
  br label %if.end

if.else:                                          ; preds = %entry
  %call1 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([9 x i8], [9 x i8]* @.str.2, i32 0, i32 0))
  br label %if.end

if.end:                                           ; preds = %if.else, %if.then
  ret void
}

; Function Attrs: noinline nounwind optnone
define hidden void @qi2c(%struct.Complex* noalias sret align 8 %agg.result, %struct.QuaterImaginary* byval(%struct.QuaterImaginary) align 4 %qi) #0 {
entry:
  %len = alloca i32, align 4
  %pointPos = alloca i32, align 4
  %posLen = alloca i32, align 4
  %prod = alloca %struct.Complex, align 8
  %j = alloca i32, align 4
  %k = alloca double, align 8
  %tmp = alloca %struct.Complex, align 8
  %agg.tmp = alloca %struct.Complex, align 8
  %tmp10 = alloca %struct.Complex, align 8
  %k18 = alloca double, align 8
  %tmp27 = alloca %struct.Complex, align 8
  %agg.tmp28 = alloca %struct.Complex, align 8
  %tmp30 = alloca %struct.Complex, align 8
  %b2i = getelementptr inbounds %struct.QuaterImaginary, %struct.QuaterImaginary* %qi, i32 0, i32 0
  %0 = load i8*, i8** %b2i, align 4
  %call = call i32 @strlen(i8* %0) #5
  store i32 %call, i32* %len, align 4
  %b2i1 = getelementptr inbounds %struct.QuaterImaginary, %struct.QuaterImaginary* %qi, i32 0, i32 0
  %1 = load i8*, i8** %b2i1, align 4
  %call2 = call i32 @find(i8* %1, i8 signext 46)
  store i32 %call2, i32* %pointPos, align 4
  %2 = load i32, i32* %pointPos, align 4
  %cmp = icmp sgt i32 %2, 0
  br i1 %cmp, label %cond.true, label %cond.false

cond.true:                                        ; preds = %entry
  %3 = load i32, i32* %pointPos, align 4
  br label %cond.end

cond.false:                                       ; preds = %entry
  %4 = load i32, i32* %len, align 4
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi i32 [ %3, %cond.true ], [ %4, %cond.false ]
  store i32 %cond, i32* %posLen, align 4
  call void @makeComplex(%struct.Complex* sret align 8 %agg.result, double 0.000000e+00, double 0.000000e+00)
  call void @makeComplex(%struct.Complex* sret align 8 %prod, double 1.000000e+00, double 0.000000e+00)
  store i32 0, i32* %j, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %cond.end
  %5 = load i32, i32* %j, align 4
  %6 = load i32, i32* %posLen, align 4
  %cmp3 = icmp ult i32 %5, %6
  br i1 %cmp3, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %b2i4 = getelementptr inbounds %struct.QuaterImaginary, %struct.QuaterImaginary* %qi, i32 0, i32 0
  %7 = load i8*, i8** %b2i4, align 4
  %8 = load i32, i32* %posLen, align 4
  %sub = sub i32 %8, 1
  %9 = load i32, i32* %j, align 4
  %sub5 = sub i32 %sub, %9
  %arrayidx = getelementptr inbounds i8, i8* %7, i32 %sub5
  %10 = load i8, i8* %arrayidx, align 1
  %conv = sext i8 %10 to i32
  %sub6 = sub nsw i32 %conv, 48
  %conv7 = sitofp i32 %sub6 to double
  store double %conv7, double* %k, align 8
  %11 = load double, double* %k, align 8
  %cmp8 = fcmp ogt double %11, 0.000000e+00
  br i1 %cmp8, label %if.then, label %if.end

if.then:                                          ; preds = %for.body
  %12 = load double, double* %k, align 8
  call void @mulComplexD(%struct.Complex* sret align 8 %agg.tmp, %struct.Complex* byval(%struct.Complex) align 8 %prod, double %12)
  call void @addComplex(%struct.Complex* sret align 8 %tmp, %struct.Complex* byval(%struct.Complex) align 8 %agg.result, %struct.Complex* byval(%struct.Complex) align 8 %agg.tmp)
  %13 = bitcast %struct.Complex* %agg.result to i8*
  %14 = bitcast %struct.Complex* %tmp to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 8 %13, i8* align 8 %14, i32 16, i1 false)
  br label %if.end

if.end:                                           ; preds = %if.then, %for.body
  call void @mulComplex(%struct.Complex* sret align 8 %tmp10, %struct.Complex* byval(%struct.Complex) align 8 %prod, %struct.Complex* byval(%struct.Complex) align 8 @TWO_I)
  %15 = bitcast %struct.Complex* %prod to i8*
  %16 = bitcast %struct.Complex* %tmp10 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 8 %15, i8* align 8 %16, i32 16, i1 false)
  br label %for.inc

for.inc:                                          ; preds = %if.end
  %17 = load i32, i32* %j, align 4
  %inc = add i32 %17, 1
  store i32 %inc, i32* %j, align 4
  br label %for.cond

for.end:                                          ; preds = %for.cond
  %18 = load i32, i32* %pointPos, align 4
  %cmp11 = icmp ne i32 %18, -1
  br i1 %cmp11, label %if.then13, label %if.end34

if.then13:                                        ; preds = %for.end
  %19 = bitcast %struct.Complex* %prod to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 8 %19, i8* align 8 bitcast (%struct.Complex* @INV_TWO_I to i8*), i32 16, i1 false)
  %20 = load i32, i32* %posLen, align 4
  %add = add i32 %20, 1
  store i32 %add, i32* %j, align 4
  br label %for.cond14

for.cond14:                                       ; preds = %for.inc31, %if.then13
  %21 = load i32, i32* %j, align 4
  %22 = load i32, i32* %len, align 4
  %cmp15 = icmp ult i32 %21, %22
  br i1 %cmp15, label %for.body17, label %for.end33

for.body17:                                       ; preds = %for.cond14
  %b2i19 = getelementptr inbounds %struct.QuaterImaginary, %struct.QuaterImaginary* %qi, i32 0, i32 0
  %23 = load i8*, i8** %b2i19, align 4
  %24 = load i32, i32* %j, align 4
  %arrayidx20 = getelementptr inbounds i8, i8* %23, i32 %24
  %25 = load i8, i8* %arrayidx20, align 1
  %conv21 = sext i8 %25 to i32
  %sub22 = sub nsw i32 %conv21, 48
  %conv23 = sitofp i32 %sub22 to double
  store double %conv23, double* %k18, align 8
  %26 = load double, double* %k18, align 8
  %cmp24 = fcmp ogt double %26, 0.000000e+00
  br i1 %cmp24, label %if.then26, label %if.end29

if.then26:                                        ; preds = %for.body17
  %27 = load double, double* %k18, align 8
  call void @mulComplexD(%struct.Complex* sret align 8 %agg.tmp28, %struct.Complex* byval(%struct.Complex) align 8 %prod, double %27)
  call void @addComplex(%struct.Complex* sret align 8 %tmp27, %struct.Complex* byval(%struct.Complex) align 8 %agg.result, %struct.Complex* byval(%struct.Complex) align 8 %agg.tmp28)
  %28 = bitcast %struct.Complex* %agg.result to i8*
  %29 = bitcast %struct.Complex* %tmp27 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 8 %28, i8* align 8 %29, i32 16, i1 false)
  br label %if.end29

if.end29:                                         ; preds = %if.then26, %for.body17
  call void @mulComplex(%struct.Complex* sret align 8 %tmp30, %struct.Complex* byval(%struct.Complex) align 8 %prod, %struct.Complex* byval(%struct.Complex) align 8 @INV_TWO_I)
  %30 = bitcast %struct.Complex* %prod to i8*
  %31 = bitcast %struct.Complex* %tmp30 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 8 %30, i8* align 8 %31, i32 16, i1 false)
  br label %for.inc31

for.inc31:                                        ; preds = %if.end29
  %32 = load i32, i32* %j, align 4
  %inc32 = add i32 %32, 1
  store i32 %inc32, i32* %j, align 4
  br label %for.cond14

for.end33:                                        ; preds = %for.cond14
  br label %if.end34

if.end34:                                         ; preds = %for.end33, %for.end
  ret void
}

; Function Attrs: nounwind readonly
declare i32 @strlen(i8* %0) #2

; Function Attrs: argmemonly nounwind willreturn
declare void @llvm.memcpy.p0i8.p0i8.i32(i8* noalias nocapture writeonly %0, i8* noalias nocapture readonly %1, i32 %2, i1 immarg %3) #3

; Function Attrs: noinline nounwind optnone
define hidden void @c2qi(%struct.QuaterImaginary* noalias sret align 4 %agg.result, %struct.Complex* byval(%struct.Complex) align 8 %c, i8* %out) #0 {
entry:
  %out.addr = alloca i8*, align 4
  %p = alloca i8*, align 4
  %re = alloca i32, align 4
  %im = alloca i32, align 4
  %fi = alloca i32, align 4
  %rem = alloca i32, align 4
  %index = alloca i32, align 4
  %fc = alloca %struct.Complex, align 8
  %.compoundliteral = alloca %struct.Complex, align 8
  %.compoundliteral21 = alloca %struct.Complex, align 8
  %f = alloca double, align 8
  %rem31 = alloca i32, align 4
  %i = alloca i32, align 4
  store i8* %out, i8** %out.addr, align 4
  %0 = load i8*, i8** %out.addr, align 4
  store i8* %0, i8** %p, align 4
  %1 = load i8*, i8** %p, align 4
  store i8 0, i8* %1, align 1
  %rel = getelementptr inbounds %struct.Complex, %struct.Complex* %c, i32 0, i32 0
  %2 = load double, double* %rel, align 8
  %cmp = fcmp oeq double %2, 0.000000e+00
  br i1 %cmp, label %land.lhs.true, label %if.end

land.lhs.true:                                    ; preds = %entry
  %img = getelementptr inbounds %struct.Complex, %struct.Complex* %c, i32 0, i32 1
  %3 = load double, double* %img, align 8
  %cmp1 = fcmp oeq double %3, 0.000000e+00
  br i1 %cmp1, label %if.then, label %if.end

if.then:                                          ; preds = %land.lhs.true
  call void @makeQuaterImaginary(%struct.QuaterImaginary* sret align 4 %agg.result, i8* getelementptr inbounds ([2 x i8], [2 x i8]* @.str.3, i32 0, i32 0))
  br label %return

if.end:                                           ; preds = %land.lhs.true, %entry
  %rel2 = getelementptr inbounds %struct.Complex, %struct.Complex* %c, i32 0, i32 0
  %4 = load double, double* %rel2, align 8
  %conv = fptosi double %4 to i32
  store i32 %conv, i32* %re, align 4
  %img3 = getelementptr inbounds %struct.Complex, %struct.Complex* %c, i32 0, i32 1
  %5 = load double, double* %img3, align 8
  %conv4 = fptosi double %5 to i32
  store i32 %conv4, i32* %im, align 4
  store i32 -1, i32* %fi, align 4
  br label %while.cond

while.cond:                                       ; preds = %if.end11, %if.end
  %6 = load i32, i32* %re, align 4
  %cmp5 = icmp ne i32 %6, 0
  br i1 %cmp5, label %while.body, label %while.end

while.body:                                       ; preds = %while.cond
  %7 = load i32, i32* %re, align 4
  %rem7 = srem i32 %7, -4
  store i32 %rem7, i32* %rem, align 4
  %8 = load i32, i32* %re, align 4
  %div = sdiv i32 %8, -4
  store i32 %div, i32* %re, align 4
  %9 = load i32, i32* %rem, align 4
  %cmp8 = icmp slt i32 %9, 0
  br i1 %cmp8, label %if.then10, label %if.end11

if.then10:                                        ; preds = %while.body
  %10 = load i32, i32* %rem, align 4
  %add = add nsw i32 %10, 4
  store i32 %add, i32* %rem, align 4
  %11 = load i32, i32* %re, align 4
  %inc = add nsw i32 %11, 1
  store i32 %inc, i32* %re, align 4
  br label %if.end11

if.end11:                                         ; preds = %if.then10, %while.body
  %12 = load i32, i32* %rem, align 4
  %add12 = add nsw i32 %12, 48
  %conv13 = trunc i32 %add12 to i8
  %13 = load i8*, i8** %p, align 4
  %incdec.ptr = getelementptr inbounds i8, i8* %13, i32 1
  store i8* %incdec.ptr, i8** %p, align 4
  store i8 %conv13, i8* %13, align 1
  %14 = load i8*, i8** %p, align 4
  %incdec.ptr14 = getelementptr inbounds i8, i8* %14, i32 1
  store i8* %incdec.ptr14, i8** %p, align 4
  store i8 48, i8* %14, align 1
  %15 = load i8*, i8** %p, align 4
  store i8 0, i8* %15, align 1
  br label %while.cond

while.end:                                        ; preds = %while.cond
  %16 = load i32, i32* %im, align 4
  %cmp15 = icmp ne i32 %16, 0
  br i1 %cmp15, label %if.then17, label %if.end53

if.then17:                                        ; preds = %while.end
  store i32 1, i32* %index, align 4
  %rel18 = getelementptr inbounds %struct.Complex, %struct.Complex* %.compoundliteral, i32 0, i32 0
  store double 0.000000e+00, double* %rel18, align 8
  %img19 = getelementptr inbounds %struct.Complex, %struct.Complex* %.compoundliteral, i32 0, i32 1
  %img20 = getelementptr inbounds %struct.Complex, %struct.Complex* %c, i32 0, i32 1
  %17 = load double, double* %img20, align 8
  store double %17, double* %img19, align 8
  %rel22 = getelementptr inbounds %struct.Complex, %struct.Complex* %.compoundliteral21, i32 0, i32 0
  store double 0.000000e+00, double* %rel22, align 8
  %img23 = getelementptr inbounds %struct.Complex, %struct.Complex* %.compoundliteral21, i32 0, i32 1
  store double 2.000000e+00, double* %img23, align 8
  call void @divComplex(%struct.Complex* sret align 8 %fc, %struct.Complex* byval(%struct.Complex) align 8 %.compoundliteral, %struct.Complex* byval(%struct.Complex) align 8 %.compoundliteral21)
  %rel24 = getelementptr inbounds %struct.Complex, %struct.Complex* %fc, i32 0, i32 0
  %18 = load double, double* %rel24, align 8
  store double %18, double* %f, align 8
  %19 = load double, double* %f, align 8
  %20 = call double @llvm.ceil.f64(double %19)
  %conv25 = fptosi double %20 to i32
  store i32 %conv25, i32* %im, align 4
  %21 = load double, double* %f, align 8
  %22 = load i32, i32* %im, align 4
  %conv26 = sitofp i32 %22 to double
  %sub = fsub double %21, %conv26
  %mul = fmul double -4.000000e+00, %sub
  store double %mul, double* %f, align 8
  br label %while.cond27

while.cond27:                                     ; preds = %if.end49, %if.then17
  %23 = load i32, i32* %im, align 4
  %cmp28 = icmp ne i32 %23, 0
  br i1 %cmp28, label %while.body30, label %while.end51

while.body30:                                     ; preds = %while.cond27
  %24 = load i32, i32* %im, align 4
  %rem32 = srem i32 %24, -4
  store i32 %rem32, i32* %rem31, align 4
  %25 = load i32, i32* %im, align 4
  %div33 = sdiv i32 %25, -4
  store i32 %div33, i32* %im, align 4
  %26 = load i32, i32* %rem31, align 4
  %cmp34 = icmp slt i32 %26, 0
  br i1 %cmp34, label %if.then36, label %if.end39

if.then36:                                        ; preds = %while.body30
  %27 = load i32, i32* %rem31, align 4
  %add37 = add nsw i32 %27, 4
  store i32 %add37, i32* %rem31, align 4
  %28 = load i32, i32* %im, align 4
  %inc38 = add nsw i32 %28, 1
  store i32 %inc38, i32* %im, align 4
  br label %if.end39

if.end39:                                         ; preds = %if.then36, %while.body30
  %29 = load i32, i32* %index, align 4
  %30 = load i8*, i8** %p, align 4
  %31 = load i8*, i8** %out.addr, align 4
  %sub.ptr.lhs.cast = ptrtoint i8* %30 to i32
  %sub.ptr.rhs.cast = ptrtoint i8* %31 to i32
  %sub.ptr.sub = sub i32 %sub.ptr.lhs.cast, %sub.ptr.rhs.cast
  %cmp40 = icmp ult i32 %29, %sub.ptr.sub
  br i1 %cmp40, label %if.then42, label %if.else

if.then42:                                        ; preds = %if.end39
  %32 = load i32, i32* %rem31, align 4
  %add43 = add nsw i32 %32, 48
  %conv44 = trunc i32 %add43 to i8
  %33 = load i8*, i8** %out.addr, align 4
  %34 = load i32, i32* %index, align 4
  %arrayidx = getelementptr inbounds i8, i8* %33, i32 %34
  store i8 %conv44, i8* %arrayidx, align 1
  br label %if.end49

if.else:                                          ; preds = %if.end39
  %35 = load i8*, i8** %p, align 4
  %incdec.ptr45 = getelementptr inbounds i8, i8* %35, i32 1
  store i8* %incdec.ptr45, i8** %p, align 4
  store i8 48, i8* %35, align 1
  %36 = load i32, i32* %rem31, align 4
  %add46 = add nsw i32 %36, 48
  %conv47 = trunc i32 %add46 to i8
  %37 = load i8*, i8** %p, align 4
  %incdec.ptr48 = getelementptr inbounds i8, i8* %37, i32 1
  store i8* %incdec.ptr48, i8** %p, align 4
  store i8 %conv47, i8* %37, align 1
  %38 = load i8*, i8** %p, align 4
  store i8 0, i8* %38, align 1
  br label %if.end49

if.end49:                                         ; preds = %if.else, %if.then42
  %39 = load i32, i32* %index, align 4
  %add50 = add i32 %39, 2
  store i32 %add50, i32* %index, align 4
  br label %while.cond27

while.end51:                                      ; preds = %while.cond27
  %40 = load double, double* %f, align 8
  %conv52 = fptosi double %40 to i32
  store i32 %conv52, i32* %fi, align 4
  br label %if.end53

if.end53:                                         ; preds = %while.end51, %while.end
  %41 = load i8*, i8** %out.addr, align 4
  %42 = load i8*, i8** %p, align 4
  call void @reverse(i8* %41, i8* %42)
  %43 = load i32, i32* %fi, align 4
  %cmp54 = icmp ne i32 %43, -1
  br i1 %cmp54, label %if.then56, label %if.end61

if.then56:                                        ; preds = %if.end53
  %44 = load i8*, i8** %p, align 4
  %incdec.ptr57 = getelementptr inbounds i8, i8* %44, i32 1
  store i8* %incdec.ptr57, i8** %p, align 4
  store i8 46, i8* %44, align 1
  %45 = load i32, i32* %fi, align 4
  %add58 = add nsw i32 %45, 48
  %conv59 = trunc i32 %add58 to i8
  %46 = load i8*, i8** %p, align 4
  %incdec.ptr60 = getelementptr inbounds i8, i8* %46, i32 1
  store i8* %incdec.ptr60, i8** %p, align 4
  store i8 %conv59, i8* %46, align 1
  %47 = load i8*, i8** %p, align 4
  store i8 0, i8* %47, align 1
  br label %if.end61

if.end61:                                         ; preds = %if.then56, %if.end53
  br label %while.cond62

while.cond62:                                     ; preds = %for.end, %if.end61
  %48 = load i8*, i8** %out.addr, align 4
  %arrayidx63 = getelementptr inbounds i8, i8* %48, i32 0
  %49 = load i8, i8* %arrayidx63, align 1
  %conv64 = sext i8 %49 to i32
  %cmp65 = icmp eq i32 %conv64, 48
  br i1 %cmp65, label %land.rhs, label %land.end

land.rhs:                                         ; preds = %while.cond62
  %50 = load i8*, i8** %out.addr, align 4
  %arrayidx67 = getelementptr inbounds i8, i8* %50, i32 1
  %51 = load i8, i8* %arrayidx67, align 1
  %conv68 = sext i8 %51 to i32
  %cmp69 = icmp ne i32 %conv68, 46
  br label %land.end

land.end:                                         ; preds = %land.rhs, %while.cond62
  %52 = phi i1 [ false, %while.cond62 ], [ %cmp69, %land.rhs ]
  br i1 %52, label %while.body71, label %while.end80

while.body71:                                     ; preds = %land.end
  store i32 0, i32* %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %while.body71
  %53 = load i8*, i8** %out.addr, align 4
  %54 = load i32, i32* %i, align 4
  %arrayidx72 = getelementptr inbounds i8, i8* %53, i32 %54
  %55 = load i8, i8* %arrayidx72, align 1
  %conv73 = sext i8 %55 to i32
  %cmp74 = icmp ne i32 %conv73, 0
  br i1 %cmp74, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %56 = load i8*, i8** %out.addr, align 4
  %57 = load i32, i32* %i, align 4
  %add76 = add i32 %57, 1
  %arrayidx77 = getelementptr inbounds i8, i8* %56, i32 %add76
  %58 = load i8, i8* %arrayidx77, align 1
  %59 = load i8*, i8** %out.addr, align 4
  %60 = load i32, i32* %i, align 4
  %arrayidx78 = getelementptr inbounds i8, i8* %59, i32 %60
  store i8 %58, i8* %arrayidx78, align 1
  br label %for.inc

for.inc:                                          ; preds = %for.body
  %61 = load i32, i32* %i, align 4
  %inc79 = add i32 %61, 1
  store i32 %inc79, i32* %i, align 4
  br label %for.cond

for.end:                                          ; preds = %for.cond
  br label %while.cond62

while.end80:                                      ; preds = %land.end
  %62 = load i8*, i8** %out.addr, align 4
  %63 = load i8, i8* %62, align 1
  %conv81 = sext i8 %63 to i32
  %cmp82 = icmp eq i32 %conv81, 46
  br i1 %cmp82, label %if.then84, label %if.end86

if.then84:                                        ; preds = %while.end80
  %64 = load i8*, i8** %out.addr, align 4
  %65 = load i8*, i8** %p, align 4
  call void @reverse(i8* %64, i8* %65)
  %66 = load i8*, i8** %p, align 4
  %incdec.ptr85 = getelementptr inbounds i8, i8* %66, i32 1
  store i8* %incdec.ptr85, i8** %p, align 4
  store i8 48, i8* %66, align 1
  %67 = load i8*, i8** %p, align 4
  store i8 0, i8* %67, align 1
  %68 = load i8*, i8** %out.addr, align 4
  %69 = load i8*, i8** %p, align 4
  call void @reverse(i8* %68, i8* %69)
  br label %if.end86

if.end86:                                         ; preds = %if.then84, %while.end80
  %70 = load i8*, i8** %out.addr, align 4
  call void @makeQuaterImaginary(%struct.QuaterImaginary* sret align 4 %agg.result, i8* %70)
  br label %return

return:                                           ; preds = %if.end86, %if.then
  ret void
}

; Function Attrs: nounwind readnone speculatable willreturn
declare double @llvm.ceil.f64(double %0) #4

; Function Attrs: noinline nounwind optnone
define hidden i32 @main() #0 {
entry:
  %retval = alloca i32, align 4
  %buffer = alloca [16 x i8], align 16
  %i = alloca i32, align 4
  %c1 = alloca %struct.Complex, align 8
  %qi = alloca %struct.QuaterImaginary, align 4
  %c2 = alloca %struct.Complex, align 8
  %tmp = alloca %struct.Complex, align 8
  %tmp3 = alloca %struct.QuaterImaginary, align 4
  %tmp5 = alloca %struct.Complex, align 8
  %c114 = alloca %struct.Complex, align 8
  %qi18 = alloca %struct.QuaterImaginary, align 4
  %c220 = alloca %struct.Complex, align 8
  %tmp24 = alloca %struct.Complex, align 8
  %tmp25 = alloca %struct.QuaterImaginary, align 4
  %tmp27 = alloca %struct.Complex, align 8
  store i32 0, i32* %retval, align 4
  store i32 1, i32* %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %0 = load i32, i32* %i, align 4
  %cmp = icmp sle i32 %0, 16
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %rel = getelementptr inbounds %struct.Complex, %struct.Complex* %c1, i32 0, i32 0
  %1 = load i32, i32* %i, align 4
  %conv = sitofp i32 %1 to double
  store double %conv, double* %rel, align 8
  %img = getelementptr inbounds %struct.Complex, %struct.Complex* %c1, i32 0, i32 1
  store double 0.000000e+00, double* %img, align 8
  %arraydecay = getelementptr inbounds [16 x i8], [16 x i8]* %buffer, i32 0, i32 0
  call void @c2qi(%struct.QuaterImaginary* sret align 4 %qi, %struct.Complex* byval(%struct.Complex) align 8 %c1, i8* %arraydecay)
  call void @qi2c(%struct.Complex* sret align 8 %c2, %struct.QuaterImaginary* byval(%struct.QuaterImaginary) align 4 %qi)
  call void @printComplex(%struct.Complex* byval(%struct.Complex) align 8 %c1)
  %call = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.4, i32 0, i32 0))
  call void @printQuaterImaginary(%struct.QuaterImaginary* byval(%struct.QuaterImaginary) align 4 %qi)
  %call1 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.4, i32 0, i32 0))
  call void @printComplex(%struct.Complex* byval(%struct.Complex) align 8 %c2)
  %call2 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([6 x i8], [6 x i8]* @.str.5, i32 0, i32 0))
  call void @negComplex(%struct.Complex* sret align 8 %tmp, %struct.Complex* byval(%struct.Complex) align 8 %c1)
  %2 = bitcast %struct.Complex* %c1 to i8*
  %3 = bitcast %struct.Complex* %tmp to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 8 %2, i8* align 8 %3, i32 16, i1 false)
  %arraydecay4 = getelementptr inbounds [16 x i8], [16 x i8]* %buffer, i32 0, i32 0
  call void @c2qi(%struct.QuaterImaginary* sret align 4 %tmp3, %struct.Complex* byval(%struct.Complex) align 8 %c1, i8* %arraydecay4)
  %4 = bitcast %struct.QuaterImaginary* %qi to i8*
  %5 = bitcast %struct.QuaterImaginary* %tmp3 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 4 %4, i8* align 4 %5, i32 8, i1 false)
  call void @qi2c(%struct.Complex* sret align 8 %tmp5, %struct.QuaterImaginary* byval(%struct.QuaterImaginary) align 4 %qi)
  %6 = bitcast %struct.Complex* %c2 to i8*
  %7 = bitcast %struct.Complex* %tmp5 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 8 %6, i8* align 8 %7, i32 16, i1 false)
  call void @printComplex(%struct.Complex* byval(%struct.Complex) align 8 %c1)
  %call6 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.4, i32 0, i32 0))
  call void @printQuaterImaginary(%struct.QuaterImaginary* byval(%struct.QuaterImaginary) align 4 %qi)
  %call7 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.4, i32 0, i32 0))
  call void @printComplex(%struct.Complex* byval(%struct.Complex) align 8 %c2)
  %call8 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([2 x i8], [2 x i8]* @.str.6, i32 0, i32 0))
  br label %for.inc

for.inc:                                          ; preds = %for.body
  %8 = load i32, i32* %i, align 4
  %inc = add nsw i32 %8, 1
  store i32 %inc, i32* %i, align 4
  br label %for.cond

for.end:                                          ; preds = %for.cond
  %call9 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([2 x i8], [2 x i8]* @.str.6, i32 0, i32 0))
  store i32 1, i32* %i, align 4
  br label %for.cond10

for.cond10:                                       ; preds = %for.inc31, %for.end
  %9 = load i32, i32* %i, align 4
  %cmp11 = icmp sle i32 %9, 16
  br i1 %cmp11, label %for.body13, label %for.end33

for.body13:                                       ; preds = %for.cond10
  %rel15 = getelementptr inbounds %struct.Complex, %struct.Complex* %c114, i32 0, i32 0
  store double 0.000000e+00, double* %rel15, align 8
  %img16 = getelementptr inbounds %struct.Complex, %struct.Complex* %c114, i32 0, i32 1
  %10 = load i32, i32* %i, align 4
  %conv17 = sitofp i32 %10 to double
  store double %conv17, double* %img16, align 8
  %arraydecay19 = getelementptr inbounds [16 x i8], [16 x i8]* %buffer, i32 0, i32 0
  call void @c2qi(%struct.QuaterImaginary* sret align 4 %qi18, %struct.Complex* byval(%struct.Complex) align 8 %c114, i8* %arraydecay19)
  call void @qi2c(%struct.Complex* sret align 8 %c220, %struct.QuaterImaginary* byval(%struct.QuaterImaginary) align 4 %qi18)
  call void @printComplex(%struct.Complex* byval(%struct.Complex) align 8 %c114)
  %call21 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.4, i32 0, i32 0))
  call void @printQuaterImaginary(%struct.QuaterImaginary* byval(%struct.QuaterImaginary) align 4 %qi18)
  %call22 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.4, i32 0, i32 0))
  call void @printComplex(%struct.Complex* byval(%struct.Complex) align 8 %c220)
  %call23 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([6 x i8], [6 x i8]* @.str.5, i32 0, i32 0))
  call void @negComplex(%struct.Complex* sret align 8 %tmp24, %struct.Complex* byval(%struct.Complex) align 8 %c114)
  %11 = bitcast %struct.Complex* %c114 to i8*
  %12 = bitcast %struct.Complex* %tmp24 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 8 %11, i8* align 8 %12, i32 16, i1 false)
  %arraydecay26 = getelementptr inbounds [16 x i8], [16 x i8]* %buffer, i32 0, i32 0
  call void @c2qi(%struct.QuaterImaginary* sret align 4 %tmp25, %struct.Complex* byval(%struct.Complex) align 8 %c114, i8* %arraydecay26)
  %13 = bitcast %struct.QuaterImaginary* %qi18 to i8*
  %14 = bitcast %struct.QuaterImaginary* %tmp25 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 4 %13, i8* align 4 %14, i32 8, i1 false)
  call void @qi2c(%struct.Complex* sret align 8 %tmp27, %struct.QuaterImaginary* byval(%struct.QuaterImaginary) align 4 %qi18)
  %15 = bitcast %struct.Complex* %c220 to i8*
  %16 = bitcast %struct.Complex* %tmp27 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 8 %15, i8* align 8 %16, i32 16, i1 false)
  call void @printComplex(%struct.Complex* byval(%struct.Complex) align 8 %c114)
  %call28 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.4, i32 0, i32 0))
  call void @printQuaterImaginary(%struct.QuaterImaginary* byval(%struct.QuaterImaginary) align 4 %qi18)
  %call29 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.4, i32 0, i32 0))
  call void @printComplex(%struct.Complex* byval(%struct.Complex) align 8 %c220)
  %call30 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([2 x i8], [2 x i8]* @.str.6, i32 0, i32 0))
  br label %for.inc31

for.inc31:                                        ; preds = %for.body13
  %17 = load i32, i32* %i, align 4
  %inc32 = add nsw i32 %17, 1
  store i32 %inc32, i32* %i, align 4
  br label %for.cond10

for.end33:                                        ; preds = %for.cond10
  ret i32 0
}

attributes #0 = { noinline nounwind optnone "correctly-rounded-divide-sqrt-fp-math"="false" "disable-tail-calls"="false" "frame-pointer"="none" "less-precise-fpmad"="false" "min-legal-vector-width"="0" "no-infs-fp-math"="false" "no-jump-tables"="false" "no-nans-fp-math"="false" "no-signed-zeros-fp-math"="false" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="generic" "unsafe-fp-math"="false" "use-soft-float"="false" }
attributes #1 = { "correctly-rounded-divide-sqrt-fp-math"="false" "disable-tail-calls"="false" "frame-pointer"="none" "less-precise-fpmad"="false" "no-infs-fp-math"="false" "no-nans-fp-math"="false" "no-signed-zeros-fp-math"="false" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="generic" "unsafe-fp-math"="false" "use-soft-float"="false" }
attributes #2 = { nounwind readonly "correctly-rounded-divide-sqrt-fp-math"="false" "disable-tail-calls"="false" "frame-pointer"="none" "less-precise-fpmad"="false" "no-infs-fp-math"="false" "no-nans-fp-math"="false" "no-signed-zeros-fp-math"="false" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="generic" "unsafe-fp-math"="false" "use-soft-float"="false" }
attributes #3 = { argmemonly nounwind willreturn }
attributes #4 = { nounwind readnone speculatable willreturn }
attributes #5 = { nounwind readonly }

!llvm.module.flags = !{!0}
!llvm.ident = !{!1}

!0 = !{i32 1, !"wchar_size", i32 4}
!1 = !{!"clang version 11.0.0 (https://github.com/Jacarte/llvm-project.git 0f6dea67136cc1e0b3d200eb2bb165628970c44b)"}

; extracted candidates

; *****
; For LLVM instruction:
;  %2 = load i8, i8* %1, align 1
; Looking for a replacement for:
%0:i8 = var
infer %0

; *****
; For LLVM instruction:
;  %conv = sext i8 %2 to i32
; Looking for a replacement for:
%0:i8 = var
%1:i32 = sext %0
infer %1

; *****
; For LLVM instruction:
;  %cmp = icmp ne i32 %conv, 0
; Looking for a replacement for:
%0:i8 = var
%1:i32 = sext %0
%2:i1 = ne 0:i32, %1
infer %2

; *****
; For LLVM instruction:
;  %4 = load i8, i8* %3, align 1
; Looking for a replacement for:
%0:i8 = var
infer %0

; *****
; For LLVM instruction:
;  %conv2 = sext i8 %4 to i32
; Looking for a replacement for:
%0:i8 = var
%1:i32 = sext %0
infer %1

; *****
; For LLVM instruction:
;  %5 = load i8, i8* %c.addr, align 1
; Looking for a replacement for:
%0:i8 = var
infer %0

; *****
; For LLVM instruction:
;  %conv3 = sext i8 %5 to i32
; Looking for a replacement for:
%0:i8 = var
%1:i32 = sext %0
infer %1

; *****
; For LLVM instruction:
;  %cmp4 = icmp eq i32 %conv2, %conv3
; Looking for a replacement for:
%0:i8 = var
%1:i32 = sext %0
%2:i8 = var
%3:i32 = sext %2
%4:i1 = eq %1, %3
infer %4

; *****
; For LLVM instruction:
;  %sub.ptr.lhs.cast = ptrtoint i8* %6 to i32
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %sub.ptr.rhs.cast = ptrtoint i8* %7 to i32
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %sub.ptr.sub = sub i32 %sub.ptr.lhs.cast, %sub.ptr.rhs.cast
; Looking for a replacement for:
%0:i32 = var
%1:i32 = var
%2:i32 = sub %0, %1
infer %2

; *****
; For LLVM instruction:
;  %9 = load i32, i32* %retval, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0
got 1 candidates from LHS

-------------------------------------------------
%0:i8 = var
infer %0


--------------------------------
guess 0

%0:i8 = var ; reservedconst_1

Cost = 0
first query is SAT, returning the model:
reservedconst_1: 0
0 th attempt: second query is SAT-- constant doesn't work
first query is SAT, returning the model:
reservedconst_1: -1
1 th attempt: second query is SAT-- constant doesn't work
first query is UNSAT-- no more guesses
Dataflow Pruned 0/0
There are 1 Guesses
There are 0 RHSs before deduplication
There are 0 RHSs after deduplication
got 2 candidates from LHS

-------------------------------------------------
%0:i8 = var
%1:i32 = sext %0
infer %1


--------------------------------
guess 0

%0:i32 = var ; reservedconst_1

Cost = 0
first query is SAT, returning the model:
reservedconst_1: 0
0 th attempt: second query is SAT-- constant doesn't work
first query is SAT, returning the model:
reservedconst_1: -1
1 th attempt: second query is SAT-- constant doesn't work
first query is UNSAT-- no more guesses
Dataflow Pruned 0/0
There are 1 Guesses
There are 0 RHSs before deduplication
There are 0 RHSs after deduplication
got 3 candidates from LHS

-------------------------------------------------
%0:i8 = var
%1:i32 = sext %0
%2:i1 = ne 0:i32, %1
infer %2


--------------------------------
guess 0

%0:i1 = var ; reservedconst_1

Cost = 0
first query is SAT, returning the model:
reservedconst_1: 0
0 th attempt: second query is SAT-- constant doesn't work
first query is SAT, returning the model:
reservedconst_1: -1
1 th attempt: second query is SAT-- constant doesn't work
first query is UNSAT-- no more guesses
Dataflow Pruned 0/0
There are 1 Guesses
There are 0 RHSs before deduplication
There are 0 RHSs after deduplication
got 5 candidates from LHS

-------------------------------------------------
%0:i8 = var
%1:i32 = sext %0
%2:i8 = var
%3:i32 = sext %2
%4:i1 = eq %1, %3
infer %4


--------------------------------
guess 0

%0:i1 = var ; reservedconst_1

Cost = 0
first query is SAT, returning the model:
reservedconst_1: -1
0 th attempt: second query is SAT-- constant doesn't work
first query is SAT, returning the model:
reservedconst_1: 0
1 th attempt: second query is SAT-- constant doesn't work
first query is UNSAT-- no more guesses
Dataflow Pruned 0/0
There are 1 Guesses
There are 0 RHSs before deduplication
There are 0 RHSs after deduplication
got 1 candidates from LHS

-------------------------------------------------
%0:i32 = var
infer %0


--------------------------------
guess 0

%0:i32 = var ; reservedconst_1

Cost = 0
first query is SAT, returning the model:
reservedconst_1: 0
0 th attempt: second query is SAT-- constant doesn't work
first query is SAT, returning the model:
reservedconst_1: -1
1 th attempt: second query is SAT-- constant doesn't work
first query is UNSAT-- no more guesses
Dataflow Pruned 0/0
There are 1 Guesses
There are 0 RHSs before deduplication
There are 0 RHSs after deduplication
got 3 candidates from LHS

-------------------------------------------------
%0:i32 = var
%1:i32 = var
%2:i32 = sub %0, %1
infer %2


--------------------------------
guess 0

%0:i32 = var ; reservedconst_1

Cost = 0
first query is SAT, returning the model:
reservedconst_1: 0
0 th attempt: second query is SAT-- constant doesn't work
first query is SAT, returning the model:
reservedconst_1: -1
1 th attempt: second query is SAT-- constant doesn't work
first query is UNSAT-- no more guesses

--------------------------------
guess 1

%0:i32 = var

Cost = 0
second query is SAT-- constant doesn't work

--------------------------------
guess 2

%0:i32 = var

Cost = 0
second query is SAT-- constant doesn't work
Dataflow Pruned 0/0
There are 3 Guesses
There are 0 RHSs before deduplication
There are 0 RHSs after deduplication
#########################################################
; exiting Souper's runOnFunction() for find()

; entering Souper's runOnFunction() for reverse()

; ModuleID = './Imaginary_base_numbers.c.bc'
source_filename = "./Imaginary_base_numbers.c"
target datalayout = "e-m:e-p:32:32-i64:64-n32:64-S128"
target triple = "wasm32-unknown-wasi"

%struct.Complex = type { double, double }
%struct.QuaterImaginary = type { i8*, i32 }

@.str = private unnamed_addr constant [17 x i8] c"(%3.0f + %3.0fi)\00", align 1
@TWO_I = hidden constant %struct.Complex { double 0.000000e+00, double 2.000000e+00 }, align 8
@INV_TWO_I = hidden constant %struct.Complex { double 0.000000e+00, double -5.000000e-01 }, align 8
@.str.1 = private unnamed_addr constant [4 x i8] c"%8s\00", align 1
@.str.2 = private unnamed_addr constant [9 x i8] c" ERROR  \00", align 1
@.str.3 = private unnamed_addr constant [2 x i8] c"0\00", align 1
@.str.4 = private unnamed_addr constant [5 x i8] c" -> \00", align 1
@.str.5 = private unnamed_addr constant [6 x i8] c"     \00", align 1
@.str.6 = private unnamed_addr constant [2 x i8] c"\0A\00", align 1
@llvm.used = appending global [1 x i8*] [i8* bitcast (i32 ()* @__main_void to i8*)], section "llvm.metadata"

@__main_void = alias i32 (), i32 ()* @main

; Function Attrs: noinline nounwind optnone
define hidden i32 @find(i8* %s, i8 signext %c) #0 {
entry:
  %retval = alloca i32, align 4
  %s.addr = alloca i8*, align 4
  %c.addr = alloca i8, align 1
  %i = alloca i8*, align 4
  store i8* %s, i8** %s.addr, align 4
  store i8 %c, i8* %c.addr, align 1
  %0 = load i8*, i8** %s.addr, align 4
  store i8* %0, i8** %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %1 = load i8*, i8** %i, align 4
  %2 = load i8, i8* %1, align 1
  %conv = sext i8 %2 to i32
  %cmp = icmp ne i32 %conv, 0
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %3 = load i8*, i8** %i, align 4
  %4 = load i8, i8* %3, align 1
  %conv2 = sext i8 %4 to i32
  %5 = load i8, i8* %c.addr, align 1
  %conv3 = sext i8 %5 to i32
  %cmp4 = icmp eq i32 %conv2, %conv3
  br i1 %cmp4, label %if.then, label %if.end

if.then:                                          ; preds = %for.body
  %6 = load i8*, i8** %i, align 4
  %7 = load i8*, i8** %s.addr, align 4
  %sub.ptr.lhs.cast = ptrtoint i8* %6 to i32
  %sub.ptr.rhs.cast = ptrtoint i8* %7 to i32
  %sub.ptr.sub = sub i32 %sub.ptr.lhs.cast, %sub.ptr.rhs.cast
  store i32 %sub.ptr.sub, i32* %retval, align 4
  br label %return

if.end:                                           ; preds = %for.body
  br label %for.inc

for.inc:                                          ; preds = %if.end
  %8 = load i8*, i8** %i, align 4
  %incdec.ptr = getelementptr inbounds i8, i8* %8, i32 1
  store i8* %incdec.ptr, i8** %i, align 4
  br label %for.cond

for.end:                                          ; preds = %for.cond
  store i32 -1, i32* %retval, align 4
  br label %return

return:                                           ; preds = %for.end, %if.then
  %9 = load i32, i32* %retval, align 4
  ret i32 %9
}

; Function Attrs: noinline nounwind optnone
define hidden void @reverse(i8* %b, i8* %e) #0 {
entry:
  %b.addr = alloca i8*, align 4
  %e.addr = alloca i8*, align 4
  %t = alloca i8, align 1
  store i8* %b, i8** %b.addr, align 4
  store i8* %e, i8** %e.addr, align 4
  %0 = load i8*, i8** %e.addr, align 4
  %incdec.ptr = getelementptr inbounds i8, i8* %0, i32 -1
  store i8* %incdec.ptr, i8** %e.addr, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %1 = load i8*, i8** %b.addr, align 4
  %2 = load i8*, i8** %e.addr, align 4
  %cmp = icmp ult i8* %1, %2
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %3 = load i8*, i8** %b.addr, align 4
  %4 = load i8, i8* %3, align 1
  store i8 %4, i8* %t, align 1
  %5 = load i8*, i8** %e.addr, align 4
  %6 = load i8, i8* %5, align 1
  %7 = load i8*, i8** %b.addr, align 4
  store i8 %6, i8* %7, align 1
  %8 = load i8, i8* %t, align 1
  %9 = load i8*, i8** %e.addr, align 4
  store i8 %8, i8* %9, align 1
  br label %for.inc

for.inc:                                          ; preds = %for.body
  %10 = load i8*, i8** %b.addr, align 4
  %incdec.ptr1 = getelementptr inbounds i8, i8* %10, i32 1
  store i8* %incdec.ptr1, i8** %b.addr, align 4
  %11 = load i8*, i8** %e.addr, align 4
  %incdec.ptr2 = getelementptr inbounds i8, i8* %11, i32 -1
  store i8* %incdec.ptr2, i8** %e.addr, align 4
  br label %for.cond

for.end:                                          ; preds = %for.cond
  ret void
}

; Function Attrs: noinline nounwind optnone
define hidden void @printComplex(%struct.Complex* byval(%struct.Complex) align 8 %c) #0 {
entry:
  %rel = getelementptr inbounds %struct.Complex, %struct.Complex* %c, i32 0, i32 0
  %0 = load double, double* %rel, align 8
  %img = getelementptr inbounds %struct.Complex, %struct.Complex* %c, i32 0, i32 1
  %1 = load double, double* %img, align 8
  %call = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([17 x i8], [17 x i8]* @.str, i32 0, i32 0), double %0, double %1)
  ret void
}

declare i32 @printf(i8* %0, ...) #1

; Function Attrs: noinline nounwind optnone
define hidden void @makeComplex(%struct.Complex* noalias sret align 8 %agg.result, double %rel, double %img) #0 {
entry:
  %rel.addr = alloca double, align 8
  %img.addr = alloca double, align 8
  store double %rel, double* %rel.addr, align 8
  store double %img, double* %img.addr, align 8
  %rel1 = getelementptr inbounds %struct.Complex, %struct.Complex* %agg.result, i32 0, i32 0
  %0 = load double, double* %rel.addr, align 8
  store double %0, double* %rel1, align 8
  %img2 = getelementptr inbounds %struct.Complex, %struct.Complex* %agg.result, i32 0, i32 1
  %1 = load double, double* %img.addr, align 8
  store double %1, double* %img2, align 8
  ret void
}

; Function Attrs: noinline nounwind optnone
define hidden void @addComplex(%struct.Complex* noalias sret align 8 %agg.result, %struct.Complex* byval(%struct.Complex) align 8 %a, %struct.Complex* byval(%struct.Complex) align 8 %b) #0 {
entry:
  %rel = getelementptr inbounds %struct.Complex, %struct.Complex* %agg.result, i32 0, i32 0
  %rel1 = getelementptr inbounds %struct.Complex, %struct.Complex* %a, i32 0, i32 0
  %0 = load double, double* %rel1, align 8
  %rel2 = getelementptr inbounds %struct.Complex, %struct.Complex* %b, i32 0, i32 0
  %1 = load double, double* %rel2, align 8
  %add = fadd double %0, %1
  store double %add, double* %rel, align 8
  %img = getelementptr inbounds %struct.Complex, %struct.Complex* %agg.result, i32 0, i32 1
  %img3 = getelementptr inbounds %struct.Complex, %struct.Complex* %a, i32 0, i32 1
  %2 = load double, double* %img3, align 8
  %img4 = getelementptr inbounds %struct.Complex, %struct.Complex* %b, i32 0, i32 1
  %3 = load double, double* %img4, align 8
  %add5 = fadd double %2, %3
  store double %add5, double* %img, align 8
  ret void
}

; Function Attrs: noinline nounwind optnone
define hidden void @mulComplex(%struct.Complex* noalias sret align 8 %agg.result, %struct.Complex* byval(%struct.Complex) align 8 %a, %struct.Complex* byval(%struct.Complex) align 8 %b) #0 {
entry:
  %rel = getelementptr inbounds %struct.Complex, %struct.Complex* %agg.result, i32 0, i32 0
  %rel1 = getelementptr inbounds %struct.Complex, %struct.Complex* %a, i32 0, i32 0
  %0 = load double, double* %rel1, align 8
  %rel2 = getelementptr inbounds %struct.Complex, %struct.Complex* %b, i32 0, i32 0
  %1 = load double, double* %rel2, align 8
  %mul = fmul double %0, %1
  %img = getelementptr inbounds %struct.Complex, %struct.Complex* %a, i32 0, i32 1
  %2 = load double, double* %img, align 8
  %img3 = getelementptr inbounds %struct.Complex, %struct.Complex* %b, i32 0, i32 1
  %3 = load double, double* %img3, align 8
  %mul4 = fmul double %2, %3
  %sub = fsub double %mul, %mul4
  store double %sub, double* %rel, align 8
  %img5 = getelementptr inbounds %struct.Complex, %struct.Complex* %agg.result, i32 0, i32 1
  %rel6 = getelementptr inbounds %struct.Complex, %struct.Complex* %a, i32 0, i32 0
  %4 = load double, double* %rel6, align 8
  %img7 = getelementptr inbounds %struct.Complex, %struct.Complex* %b, i32 0, i32 1
  %5 = load double, double* %img7, align 8
  %mul8 = fmul double %4, %5
  %img9 = getelementptr inbounds %struct.Complex, %struct.Complex* %a, i32 0, i32 1
  %6 = load double, double* %img9, align 8
  %rel10 = getelementptr inbounds %struct.Complex, %struct.Complex* %b, i32 0, i32 0
  %7 = load double, double* %rel10, align 8
  %mul11 = fmul double %6, %7
  %sub12 = fsub double %mul8, %mul11
  store double %sub12, double* %img5, align 8
  ret void
}

; Function Attrs: noinline nounwind optnone
define hidden void @mulComplexD(%struct.Complex* noalias sret align 8 %agg.result, %struct.Complex* byval(%struct.Complex) align 8 %a, double %b) #0 {
entry:
  %b.addr = alloca double, align 8
  store double %b, double* %b.addr, align 8
  %rel = getelementptr inbounds %struct.Complex, %struct.Complex* %agg.result, i32 0, i32 0
  %rel1 = getelementptr inbounds %struct.Complex, %struct.Complex* %a, i32 0, i32 0
  %0 = load double, double* %rel1, align 8
  %1 = load double, double* %b.addr, align 8
  %mul = fmul double %0, %1
  store double %mul, double* %rel, align 8
  %img = getelementptr inbounds %struct.Complex, %struct.Complex* %agg.result, i32 0, i32 1
  %img2 = getelementptr inbounds %struct.Complex, %struct.Complex* %a, i32 0, i32 1
  %2 = load double, double* %img2, align 8
  %3 = load double, double* %b.addr, align 8
  %mul3 = fmul double %2, %3
  store double %mul3, double* %img, align 8
  ret void
}

; Function Attrs: noinline nounwind optnone
define hidden void @negComplex(%struct.Complex* noalias sret align 8 %agg.result, %struct.Complex* byval(%struct.Complex) align 8 %a) #0 {
entry:
  call void @mulComplexD(%struct.Complex* sret align 8 %agg.result, %struct.Complex* byval(%struct.Complex) align 8 %a, double -1.000000e+00)
  ret void
}

; Function Attrs: noinline nounwind optnone
define hidden void @divComplex(%struct.Complex* noalias sret align 8 %agg.result, %struct.Complex* byval(%struct.Complex) align 8 %a, %struct.Complex* byval(%struct.Complex) align 8 %b) #0 {
entry:
  %re = alloca double, align 8
  %im = alloca double, align 8
  %d = alloca double, align 8
  %rel = getelementptr inbounds %struct.Complex, %struct.Complex* %a, i32 0, i32 0
  %0 = load double, double* %rel, align 8
  %rel1 = getelementptr inbounds %struct.Complex, %struct.Complex* %b, i32 0, i32 0
  %1 = load double, double* %rel1, align 8
  %mul = fmul double %0, %1
  %img = getelementptr inbounds %struct.Complex, %struct.Complex* %a, i32 0, i32 1
  %2 = load double, double* %img, align 8
  %img2 = getelementptr inbounds %struct.Complex, %struct.Complex* %b, i32 0, i32 1
  %3 = load double, double* %img2, align 8
  %mul3 = fmul double %2, %3
  %add = fadd double %mul, %mul3
  store double %add, double* %re, align 8
  %img4 = getelementptr inbounds %struct.Complex, %struct.Complex* %a, i32 0, i32 1
  %4 = load double, double* %img4, align 8
  %rel5 = getelementptr inbounds %struct.Complex, %struct.Complex* %b, i32 0, i32 0
  %5 = load double, double* %rel5, align 8
  %mul6 = fmul double %4, %5
  %rel7 = getelementptr inbounds %struct.Complex, %struct.Complex* %a, i32 0, i32 0
  %6 = load double, double* %rel7, align 8
  %img8 = getelementptr inbounds %struct.Complex, %struct.Complex* %b, i32 0, i32 1
  %7 = load double, double* %img8, align 8
  %mul9 = fmul double %6, %7
  %sub = fsub double %mul6, %mul9
  store double %sub, double* %im, align 8
  %rel10 = getelementptr inbounds %struct.Complex, %struct.Complex* %b, i32 0, i32 0
  %8 = load double, double* %rel10, align 8
  %rel11 = getelementptr inbounds %struct.Complex, %struct.Complex* %b, i32 0, i32 0
  %9 = load double, double* %rel11, align 8
  %mul12 = fmul double %8, %9
  %img13 = getelementptr inbounds %struct.Complex, %struct.Complex* %b, i32 0, i32 1
  %10 = load double, double* %img13, align 8
  %img14 = getelementptr inbounds %struct.Complex, %struct.Complex* %b, i32 0, i32 1
  %11 = load double, double* %img14, align 8
  %mul15 = fmul double %10, %11
  %add16 = fadd double %mul12, %mul15
  store double %add16, double* %d, align 8
  %rel17 = getelementptr inbounds %struct.Complex, %struct.Complex* %agg.result, i32 0, i32 0
  %12 = load double, double* %re, align 8
  %13 = load double, double* %d, align 8
  %div = fdiv double %12, %13
  store double %div, double* %rel17, align 8
  %img18 = getelementptr inbounds %struct.Complex, %struct.Complex* %agg.result, i32 0, i32 1
  %14 = load double, double* %im, align 8
  %15 = load double, double* %d, align 8
  %div19 = fdiv double %14, %15
  store double %div19, double* %img18, align 8
  ret void
}

; Function Attrs: noinline nounwind optnone
define hidden void @inv(%struct.Complex* noalias sret align 8 %agg.result, %struct.Complex* byval(%struct.Complex) align 8 %c) #0 {
entry:
  %d = alloca double, align 8
  %rel = getelementptr inbounds %struct.Complex, %struct.Complex* %c, i32 0, i32 0
  %0 = load double, double* %rel, align 8
  %rel1 = getelementptr inbounds %struct.Complex, %struct.Complex* %c, i32 0, i32 0
  %1 = load double, double* %rel1, align 8
  %mul = fmul double %0, %1
  %img = getelementptr inbounds %struct.Complex, %struct.Complex* %c, i32 0, i32 1
  %2 = load double, double* %img, align 8
  %img2 = getelementptr inbounds %struct.Complex, %struct.Complex* %c, i32 0, i32 1
  %3 = load double, double* %img2, align 8
  %mul3 = fmul double %2, %3
  %add = fadd double %mul, %mul3
  store double %add, double* %d, align 8
  %rel4 = getelementptr inbounds %struct.Complex, %struct.Complex* %agg.result, i32 0, i32 0
  %rel5 = getelementptr inbounds %struct.Complex, %struct.Complex* %c, i32 0, i32 0
  %4 = load double, double* %rel5, align 8
  %5 = load double, double* %d, align 8
  %div = fdiv double %4, %5
  store double %div, double* %rel4, align 8
  %img6 = getelementptr inbounds %struct.Complex, %struct.Complex* %agg.result, i32 0, i32 1
  %img7 = getelementptr inbounds %struct.Complex, %struct.Complex* %c, i32 0, i32 1
  %6 = load double, double* %img7, align 8
  %fneg = fneg double %6
  %7 = load double, double* %d, align 8
  %div8 = fdiv double %fneg, %7
  store double %div8, double* %img6, align 8
  ret void
}

; Function Attrs: noinline nounwind optnone
define hidden void @makeQuaterImaginary(%struct.QuaterImaginary* noalias sret align 4 %agg.result, i8* %s) #0 {
entry:
  %s.addr = alloca i8*, align 4
  %i = alloca i32, align 4
  %valid1 = alloca i32, align 4
  %cnt = alloca i32, align 4
  store i8* %s, i8** %s.addr, align 4
  %b2i = getelementptr inbounds %struct.QuaterImaginary, %struct.QuaterImaginary* %agg.result, i32 0, i32 0
  %0 = load i8*, i8** %s.addr, align 4
  store i8* %0, i8** %b2i, align 4
  %valid = getelementptr inbounds %struct.QuaterImaginary, %struct.QuaterImaginary* %agg.result, i32 0, i32 1
  store i32 0, i32* %valid, align 4
  store i32 1, i32* %valid1, align 4
  store i32 0, i32* %cnt, align 4
  %1 = load i8*, i8** %s.addr, align 4
  %2 = load i8, i8* %1, align 1
  %conv = sext i8 %2 to i32
  %cmp = icmp ne i32 %conv, 0
  br i1 %cmp, label %if.then, label %if.end26

if.then:                                          ; preds = %entry
  store i32 0, i32* %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.then
  %3 = load i8*, i8** %s.addr, align 4
  %4 = load i32, i32* %i, align 4
  %arrayidx = getelementptr inbounds i8, i8* %3, i32 %4
  %5 = load i8, i8* %arrayidx, align 1
  %conv3 = sext i8 %5 to i32
  %cmp4 = icmp ne i32 %conv3, 0
  br i1 %cmp4, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %6 = load i8*, i8** %s.addr, align 4
  %7 = load i32, i32* %i, align 4
  %arrayidx6 = getelementptr inbounds i8, i8* %6, i32 %7
  %8 = load i8, i8* %arrayidx6, align 1
  %conv7 = sext i8 %8 to i32
  %cmp8 = icmp slt i32 %conv7, 48
  br i1 %cmp8, label %if.then14, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %for.body
  %9 = load i8*, i8** %s.addr, align 4
  %10 = load i32, i32* %i, align 4
  %arrayidx10 = getelementptr inbounds i8, i8* %9, i32 %10
  %11 = load i8, i8* %arrayidx10, align 1
  %conv11 = sext i8 %11 to i32
  %cmp12 = icmp slt i32 51, %conv11
  br i1 %cmp12, label %if.then14, label %if.end20

if.then14:                                        ; preds = %lor.lhs.false, %for.body
  %12 = load i8*, i8** %s.addr, align 4
  %13 = load i32, i32* %i, align 4
  %arrayidx15 = getelementptr inbounds i8, i8* %12, i32 %13
  %14 = load i8, i8* %arrayidx15, align 1
  %conv16 = sext i8 %14 to i32
  %cmp17 = icmp eq i32 %conv16, 46
  br i1 %cmp17, label %if.then19, label %if.else

if.then19:                                        ; preds = %if.then14
  %15 = load i32, i32* %cnt, align 4
  %inc = add i32 %15, 1
  store i32 %inc, i32* %cnt, align 4
  br label %if.end

if.else:                                          ; preds = %if.then14
  store i32 0, i32* %valid1, align 4
  br label %for.end

if.end:                                           ; preds = %if.then19
  br label %if.end20

if.end20:                                         ; preds = %if.end, %lor.lhs.false
  br label %for.inc

for.inc:                                          ; preds = %if.end20
  %16 = load i32, i32* %i, align 4
  %inc21 = add i32 %16, 1
  store i32 %inc21, i32* %i, align 4
  br label %for.cond

for.end:                                          ; preds = %if.else, %for.cond
  %17 = load i32, i32* %valid1, align 4
  %tobool = icmp ne i32 %17, 0
  br i1 %tobool, label %land.lhs.true, label %if.end25

land.lhs.true:                                    ; preds = %for.end
  %18 = load i32, i32* %cnt, align 4
  %cmp22 = icmp ugt i32 %18, 1
  br i1 %cmp22, label %if.then24, label %if.end25

if.then24:                                        ; preds = %land.lhs.true
  store i32 0, i32* %valid1, align 4
  br label %if.end25

if.end25:                                         ; preds = %if.then24, %land.lhs.true, %for.end
  br label %if.end26

if.end26:                                         ; preds = %if.end25, %entry
  %19 = load i32, i32* %valid1, align 4
  %valid27 = getelementptr inbounds %struct.QuaterImaginary, %struct.QuaterImaginary* %agg.result, i32 0, i32 1
  store i32 %19, i32* %valid27, align 4
  ret void
}

; Function Attrs: noinline nounwind optnone
define hidden void @printQuaterImaginary(%struct.QuaterImaginary* byval(%struct.QuaterImaginary) align 4 %qi) #0 {
entry:
  %valid = getelementptr inbounds %struct.QuaterImaginary, %struct.QuaterImaginary* %qi, i32 0, i32 1
  %0 = load i32, i32* %valid, align 4
  %tobool = icmp ne i32 %0, 0
  br i1 %tobool, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  %b2i = getelementptr inbounds %struct.QuaterImaginary, %struct.QuaterImaginary* %qi, i32 0, i32 0
  %1 = load i8*, i8** %b2i, align 4
  %call = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([4 x i8], [4 x i8]* @.str.1, i32 0, i32 0), i8* %1)
  br label %if.end

if.else:                                          ; preds = %entry
  %call1 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([9 x i8], [9 x i8]* @.str.2, i32 0, i32 0))
  br label %if.end

if.end:                                           ; preds = %if.else, %if.then
  ret void
}

; Function Attrs: noinline nounwind optnone
define hidden void @qi2c(%struct.Complex* noalias sret align 8 %agg.result, %struct.QuaterImaginary* byval(%struct.QuaterImaginary) align 4 %qi) #0 {
entry:
  %len = alloca i32, align 4
  %pointPos = alloca i32, align 4
  %posLen = alloca i32, align 4
  %prod = alloca %struct.Complex, align 8
  %j = alloca i32, align 4
  %k = alloca double, align 8
  %tmp = alloca %struct.Complex, align 8
  %agg.tmp = alloca %struct.Complex, align 8
  %tmp10 = alloca %struct.Complex, align 8
  %k18 = alloca double, align 8
  %tmp27 = alloca %struct.Complex, align 8
  %agg.tmp28 = alloca %struct.Complex, align 8
  %tmp30 = alloca %struct.Complex, align 8
  %b2i = getelementptr inbounds %struct.QuaterImaginary, %struct.QuaterImaginary* %qi, i32 0, i32 0
  %0 = load i8*, i8** %b2i, align 4
  %call = call i32 @strlen(i8* %0) #5
  store i32 %call, i32* %len, align 4
  %b2i1 = getelementptr inbounds %struct.QuaterImaginary, %struct.QuaterImaginary* %qi, i32 0, i32 0
  %1 = load i8*, i8** %b2i1, align 4
  %call2 = call i32 @find(i8* %1, i8 signext 46)
  store i32 %call2, i32* %pointPos, align 4
  %2 = load i32, i32* %pointPos, align 4
  %cmp = icmp sgt i32 %2, 0
  br i1 %cmp, label %cond.true, label %cond.false

cond.true:                                        ; preds = %entry
  %3 = load i32, i32* %pointPos, align 4
  br label %cond.end

cond.false:                                       ; preds = %entry
  %4 = load i32, i32* %len, align 4
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi i32 [ %3, %cond.true ], [ %4, %cond.false ]
  store i32 %cond, i32* %posLen, align 4
  call void @makeComplex(%struct.Complex* sret align 8 %agg.result, double 0.000000e+00, double 0.000000e+00)
  call void @makeComplex(%struct.Complex* sret align 8 %prod, double 1.000000e+00, double 0.000000e+00)
  store i32 0, i32* %j, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %cond.end
  %5 = load i32, i32* %j, align 4
  %6 = load i32, i32* %posLen, align 4
  %cmp3 = icmp ult i32 %5, %6
  br i1 %cmp3, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %b2i4 = getelementptr inbounds %struct.QuaterImaginary, %struct.QuaterImaginary* %qi, i32 0, i32 0
  %7 = load i8*, i8** %b2i4, align 4
  %8 = load i32, i32* %posLen, align 4
  %sub = sub i32 %8, 1
  %9 = load i32, i32* %j, align 4
  %sub5 = sub i32 %sub, %9
  %arrayidx = getelementptr inbounds i8, i8* %7, i32 %sub5
  %10 = load i8, i8* %arrayidx, align 1
  %conv = sext i8 %10 to i32
  %sub6 = sub nsw i32 %conv, 48
  %conv7 = sitofp i32 %sub6 to double
  store double %conv7, double* %k, align 8
  %11 = load double, double* %k, align 8
  %cmp8 = fcmp ogt double %11, 0.000000e+00
  br i1 %cmp8, label %if.then, label %if.end

if.then:                                          ; preds = %for.body
  %12 = load double, double* %k, align 8
  call void @mulComplexD(%struct.Complex* sret align 8 %agg.tmp, %struct.Complex* byval(%struct.Complex) align 8 %prod, double %12)
  call void @addComplex(%struct.Complex* sret align 8 %tmp, %struct.Complex* byval(%struct.Complex) align 8 %agg.result, %struct.Complex* byval(%struct.Complex) align 8 %agg.tmp)
  %13 = bitcast %struct.Complex* %agg.result to i8*
  %14 = bitcast %struct.Complex* %tmp to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 8 %13, i8* align 8 %14, i32 16, i1 false)
  br label %if.end

if.end:                                           ; preds = %if.then, %for.body
  call void @mulComplex(%struct.Complex* sret align 8 %tmp10, %struct.Complex* byval(%struct.Complex) align 8 %prod, %struct.Complex* byval(%struct.Complex) align 8 @TWO_I)
  %15 = bitcast %struct.Complex* %prod to i8*
  %16 = bitcast %struct.Complex* %tmp10 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 8 %15, i8* align 8 %16, i32 16, i1 false)
  br label %for.inc

for.inc:                                          ; preds = %if.end
  %17 = load i32, i32* %j, align 4
  %inc = add i32 %17, 1
  store i32 %inc, i32* %j, align 4
  br label %for.cond

for.end:                                          ; preds = %for.cond
  %18 = load i32, i32* %pointPos, align 4
  %cmp11 = icmp ne i32 %18, -1
  br i1 %cmp11, label %if.then13, label %if.end34

if.then13:                                        ; preds = %for.end
  %19 = bitcast %struct.Complex* %prod to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 8 %19, i8* align 8 bitcast (%struct.Complex* @INV_TWO_I to i8*), i32 16, i1 false)
  %20 = load i32, i32* %posLen, align 4
  %add = add i32 %20, 1
  store i32 %add, i32* %j, align 4
  br label %for.cond14

for.cond14:                                       ; preds = %for.inc31, %if.then13
  %21 = load i32, i32* %j, align 4
  %22 = load i32, i32* %len, align 4
  %cmp15 = icmp ult i32 %21, %22
  br i1 %cmp15, label %for.body17, label %for.end33

for.body17:                                       ; preds = %for.cond14
  %b2i19 = getelementptr inbounds %struct.QuaterImaginary, %struct.QuaterImaginary* %qi, i32 0, i32 0
  %23 = load i8*, i8** %b2i19, align 4
  %24 = load i32, i32* %j, align 4
  %arrayidx20 = getelementptr inbounds i8, i8* %23, i32 %24
  %25 = load i8, i8* %arrayidx20, align 1
  %conv21 = sext i8 %25 to i32
  %sub22 = sub nsw i32 %conv21, 48
  %conv23 = sitofp i32 %sub22 to double
  store double %conv23, double* %k18, align 8
  %26 = load double, double* %k18, align 8
  %cmp24 = fcmp ogt double %26, 0.000000e+00
  br i1 %cmp24, label %if.then26, label %if.end29

if.then26:                                        ; preds = %for.body17
  %27 = load double, double* %k18, align 8
  call void @mulComplexD(%struct.Complex* sret align 8 %agg.tmp28, %struct.Complex* byval(%struct.Complex) align 8 %prod, double %27)
  call void @addComplex(%struct.Complex* sret align 8 %tmp27, %struct.Complex* byval(%struct.Complex) align 8 %agg.result, %struct.Complex* byval(%struct.Complex) align 8 %agg.tmp28)
  %28 = bitcast %struct.Complex* %agg.result to i8*
  %29 = bitcast %struct.Complex* %tmp27 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 8 %28, i8* align 8 %29, i32 16, i1 false)
  br label %if.end29

if.end29:                                         ; preds = %if.then26, %for.body17
  call void @mulComplex(%struct.Complex* sret align 8 %tmp30, %struct.Complex* byval(%struct.Complex) align 8 %prod, %struct.Complex* byval(%struct.Complex) align 8 @INV_TWO_I)
  %30 = bitcast %struct.Complex* %prod to i8*
  %31 = bitcast %struct.Complex* %tmp30 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 8 %30, i8* align 8 %31, i32 16, i1 false)
  br label %for.inc31

for.inc31:                                        ; preds = %if.end29
  %32 = load i32, i32* %j, align 4
  %inc32 = add i32 %32, 1
  store i32 %inc32, i32* %j, align 4
  br label %for.cond14

for.end33:                                        ; preds = %for.cond14
  br label %if.end34

if.end34:                                         ; preds = %for.end33, %for.end
  ret void
}

; Function Attrs: nounwind readonly
declare i32 @strlen(i8* %0) #2

; Function Attrs: argmemonly nounwind willreturn
declare void @llvm.memcpy.p0i8.p0i8.i32(i8* noalias nocapture writeonly %0, i8* noalias nocapture readonly %1, i32 %2, i1 immarg %3) #3

; Function Attrs: noinline nounwind optnone
define hidden void @c2qi(%struct.QuaterImaginary* noalias sret align 4 %agg.result, %struct.Complex* byval(%struct.Complex) align 8 %c, i8* %out) #0 {
entry:
  %out.addr = alloca i8*, align 4
  %p = alloca i8*, align 4
  %re = alloca i32, align 4
  %im = alloca i32, align 4
  %fi = alloca i32, align 4
  %rem = alloca i32, align 4
  %index = alloca i32, align 4
  %fc = alloca %struct.Complex, align 8
  %.compoundliteral = alloca %struct.Complex, align 8
  %.compoundliteral21 = alloca %struct.Complex, align 8
  %f = alloca double, align 8
  %rem31 = alloca i32, align 4
  %i = alloca i32, align 4
  store i8* %out, i8** %out.addr, align 4
  %0 = load i8*, i8** %out.addr, align 4
  store i8* %0, i8** %p, align 4
  %1 = load i8*, i8** %p, align 4
  store i8 0, i8* %1, align 1
  %rel = getelementptr inbounds %struct.Complex, %struct.Complex* %c, i32 0, i32 0
  %2 = load double, double* %rel, align 8
  %cmp = fcmp oeq double %2, 0.000000e+00
  br i1 %cmp, label %land.lhs.true, label %if.end

land.lhs.true:                                    ; preds = %entry
  %img = getelementptr inbounds %struct.Complex, %struct.Complex* %c, i32 0, i32 1
  %3 = load double, double* %img, align 8
  %cmp1 = fcmp oeq double %3, 0.000000e+00
  br i1 %cmp1, label %if.then, label %if.end

if.then:                                          ; preds = %land.lhs.true
  call void @makeQuaterImaginary(%struct.QuaterImaginary* sret align 4 %agg.result, i8* getelementptr inbounds ([2 x i8], [2 x i8]* @.str.3, i32 0, i32 0))
  br label %return

if.end:                                           ; preds = %land.lhs.true, %entry
  %rel2 = getelementptr inbounds %struct.Complex, %struct.Complex* %c, i32 0, i32 0
  %4 = load double, double* %rel2, align 8
  %conv = fptosi double %4 to i32
  store i32 %conv, i32* %re, align 4
  %img3 = getelementptr inbounds %struct.Complex, %struct.Complex* %c, i32 0, i32 1
  %5 = load double, double* %img3, align 8
  %conv4 = fptosi double %5 to i32
  store i32 %conv4, i32* %im, align 4
  store i32 -1, i32* %fi, align 4
  br label %while.cond

while.cond:                                       ; preds = %if.end11, %if.end
  %6 = load i32, i32* %re, align 4
  %cmp5 = icmp ne i32 %6, 0
  br i1 %cmp5, label %while.body, label %while.end

while.body:                                       ; preds = %while.cond
  %7 = load i32, i32* %re, align 4
  %rem7 = srem i32 %7, -4
  store i32 %rem7, i32* %rem, align 4
  %8 = load i32, i32* %re, align 4
  %div = sdiv i32 %8, -4
  store i32 %div, i32* %re, align 4
  %9 = load i32, i32* %rem, align 4
  %cmp8 = icmp slt i32 %9, 0
  br i1 %cmp8, label %if.then10, label %if.end11

if.then10:                                        ; preds = %while.body
  %10 = load i32, i32* %rem, align 4
  %add = add nsw i32 %10, 4
  store i32 %add, i32* %rem, align 4
  %11 = load i32, i32* %re, align 4
  %inc = add nsw i32 %11, 1
  store i32 %inc, i32* %re, align 4
  br label %if.end11

if.end11:                                         ; preds = %if.then10, %while.body
  %12 = load i32, i32* %rem, align 4
  %add12 = add nsw i32 %12, 48
  %conv13 = trunc i32 %add12 to i8
  %13 = load i8*, i8** %p, align 4
  %incdec.ptr = getelementptr inbounds i8, i8* %13, i32 1
  store i8* %incdec.ptr, i8** %p, align 4
  store i8 %conv13, i8* %13, align 1
  %14 = load i8*, i8** %p, align 4
  %incdec.ptr14 = getelementptr inbounds i8, i8* %14, i32 1
  store i8* %incdec.ptr14, i8** %p, align 4
  store i8 48, i8* %14, align 1
  %15 = load i8*, i8** %p, align 4
  store i8 0, i8* %15, align 1
  br label %while.cond

while.end:                                        ; preds = %while.cond
  %16 = load i32, i32* %im, align 4
  %cmp15 = icmp ne i32 %16, 0
  br i1 %cmp15, label %if.then17, label %if.end53

if.then17:                                        ; preds = %while.end
  store i32 1, i32* %index, align 4
  %rel18 = getelementptr inbounds %struct.Complex, %struct.Complex* %.compoundliteral, i32 0, i32 0
  store double 0.000000e+00, double* %rel18, align 8
  %img19 = getelementptr inbounds %struct.Complex, %struct.Complex* %.compoundliteral, i32 0, i32 1
  %img20 = getelementptr inbounds %struct.Complex, %struct.Complex* %c, i32 0, i32 1
  %17 = load double, double* %img20, align 8
  store double %17, double* %img19, align 8
  %rel22 = getelementptr inbounds %struct.Complex, %struct.Complex* %.compoundliteral21, i32 0, i32 0
  store double 0.000000e+00, double* %rel22, align 8
  %img23 = getelementptr inbounds %struct.Complex, %struct.Complex* %.compoundliteral21, i32 0, i32 1
  store double 2.000000e+00, double* %img23, align 8
  call void @divComplex(%struct.Complex* sret align 8 %fc, %struct.Complex* byval(%struct.Complex) align 8 %.compoundliteral, %struct.Complex* byval(%struct.Complex) align 8 %.compoundliteral21)
  %rel24 = getelementptr inbounds %struct.Complex, %struct.Complex* %fc, i32 0, i32 0
  %18 = load double, double* %rel24, align 8
  store double %18, double* %f, align 8
  %19 = load double, double* %f, align 8
  %20 = call double @llvm.ceil.f64(double %19)
  %conv25 = fptosi double %20 to i32
  store i32 %conv25, i32* %im, align 4
  %21 = load double, double* %f, align 8
  %22 = load i32, i32* %im, align 4
  %conv26 = sitofp i32 %22 to double
  %sub = fsub double %21, %conv26
  %mul = fmul double -4.000000e+00, %sub
  store double %mul, double* %f, align 8
  br label %while.cond27

while.cond27:                                     ; preds = %if.end49, %if.then17
  %23 = load i32, i32* %im, align 4
  %cmp28 = icmp ne i32 %23, 0
  br i1 %cmp28, label %while.body30, label %while.end51

while.body30:                                     ; preds = %while.cond27
  %24 = load i32, i32* %im, align 4
  %rem32 = srem i32 %24, -4
  store i32 %rem32, i32* %rem31, align 4
  %25 = load i32, i32* %im, align 4
  %div33 = sdiv i32 %25, -4
  store i32 %div33, i32* %im, align 4
  %26 = load i32, i32* %rem31, align 4
  %cmp34 = icmp slt i32 %26, 0
  br i1 %cmp34, label %if.then36, label %if.end39

if.then36:                                        ; preds = %while.body30
  %27 = load i32, i32* %rem31, align 4
  %add37 = add nsw i32 %27, 4
  store i32 %add37, i32* %rem31, align 4
  %28 = load i32, i32* %im, align 4
  %inc38 = add nsw i32 %28, 1
  store i32 %inc38, i32* %im, align 4
  br label %if.end39

if.end39:                                         ; preds = %if.then36, %while.body30
  %29 = load i32, i32* %index, align 4
  %30 = load i8*, i8** %p, align 4
  %31 = load i8*, i8** %out.addr, align 4
  %sub.ptr.lhs.cast = ptrtoint i8* %30 to i32
  %sub.ptr.rhs.cast = ptrtoint i8* %31 to i32
  %sub.ptr.sub = sub i32 %sub.ptr.lhs.cast, %sub.ptr.rhs.cast
  %cmp40 = icmp ult i32 %29, %sub.ptr.sub
  br i1 %cmp40, label %if.then42, label %if.else

if.then42:                                        ; preds = %if.end39
  %32 = load i32, i32* %rem31, align 4
  %add43 = add nsw i32 %32, 48
  %conv44 = trunc i32 %add43 to i8
  %33 = load i8*, i8** %out.addr, align 4
  %34 = load i32, i32* %index, align 4
  %arrayidx = getelementptr inbounds i8, i8* %33, i32 %34
  store i8 %conv44, i8* %arrayidx, align 1
  br label %if.end49

if.else:                                          ; preds = %if.end39
  %35 = load i8*, i8** %p, align 4
  %incdec.ptr45 = getelementptr inbounds i8, i8* %35, i32 1
  store i8* %incdec.ptr45, i8** %p, align 4
  store i8 48, i8* %35, align 1
  %36 = load i32, i32* %rem31, align 4
  %add46 = add nsw i32 %36, 48
  %conv47 = trunc i32 %add46 to i8
  %37 = load i8*, i8** %p, align 4
  %incdec.ptr48 = getelementptr inbounds i8, i8* %37, i32 1
  store i8* %incdec.ptr48, i8** %p, align 4
  store i8 %conv47, i8* %37, align 1
  %38 = load i8*, i8** %p, align 4
  store i8 0, i8* %38, align 1
  br label %if.end49

if.end49:                                         ; preds = %if.else, %if.then42
  %39 = load i32, i32* %index, align 4
  %add50 = add i32 %39, 2
  store i32 %add50, i32* %index, align 4
  br label %while.cond27

while.end51:                                      ; preds = %while.cond27
  %40 = load double, double* %f, align 8
  %conv52 = fptosi double %40 to i32
  store i32 %conv52, i32* %fi, align 4
  br label %if.end53

if.end53:                                         ; preds = %while.end51, %while.end
  %41 = load i8*, i8** %out.addr, align 4
  %42 = load i8*, i8** %p, align 4
  call void @reverse(i8* %41, i8* %42)
  %43 = load i32, i32* %fi, align 4
  %cmp54 = icmp ne i32 %43, -1
  br i1 %cmp54, label %if.then56, label %if.end61

if.then56:                                        ; preds = %if.end53
  %44 = load i8*, i8** %p, align 4
  %incdec.ptr57 = getelementptr inbounds i8, i8* %44, i32 1
  store i8* %incdec.ptr57, i8** %p, align 4
  store i8 46, i8* %44, align 1
  %45 = load i32, i32* %fi, align 4
  %add58 = add nsw i32 %45, 48
  %conv59 = trunc i32 %add58 to i8
  %46 = load i8*, i8** %p, align 4
  %incdec.ptr60 = getelementptr inbounds i8, i8* %46, i32 1
  store i8* %incdec.ptr60, i8** %p, align 4
  store i8 %conv59, i8* %46, align 1
  %47 = load i8*, i8** %p, align 4
  store i8 0, i8* %47, align 1
  br label %if.end61

if.end61:                                         ; preds = %if.then56, %if.end53
  br label %while.cond62

while.cond62:                                     ; preds = %for.end, %if.end61
  %48 = load i8*, i8** %out.addr, align 4
  %arrayidx63 = getelementptr inbounds i8, i8* %48, i32 0
  %49 = load i8, i8* %arrayidx63, align 1
  %conv64 = sext i8 %49 to i32
  %cmp65 = icmp eq i32 %conv64, 48
  br i1 %cmp65, label %land.rhs, label %land.end

land.rhs:                                         ; preds = %while.cond62
  %50 = load i8*, i8** %out.addr, align 4
  %arrayidx67 = getelementptr inbounds i8, i8* %50, i32 1
  %51 = load i8, i8* %arrayidx67, align 1
  %conv68 = sext i8 %51 to i32
  %cmp69 = icmp ne i32 %conv68, 46
  br label %land.end

land.end:                                         ; preds = %land.rhs, %while.cond62
  %52 = phi i1 [ false, %while.cond62 ], [ %cmp69, %land.rhs ]
  br i1 %52, label %while.body71, label %while.end80

while.body71:                                     ; preds = %land.end
  store i32 0, i32* %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %while.body71
  %53 = load i8*, i8** %out.addr, align 4
  %54 = load i32, i32* %i, align 4
  %arrayidx72 = getelementptr inbounds i8, i8* %53, i32 %54
  %55 = load i8, i8* %arrayidx72, align 1
  %conv73 = sext i8 %55 to i32
  %cmp74 = icmp ne i32 %conv73, 0
  br i1 %cmp74, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %56 = load i8*, i8** %out.addr, align 4
  %57 = load i32, i32* %i, align 4
  %add76 = add i32 %57, 1
  %arrayidx77 = getelementptr inbounds i8, i8* %56, i32 %add76
  %58 = load i8, i8* %arrayidx77, align 1
  %59 = load i8*, i8** %out.addr, align 4
  %60 = load i32, i32* %i, align 4
  %arrayidx78 = getelementptr inbounds i8, i8* %59, i32 %60
  store i8 %58, i8* %arrayidx78, align 1
  br label %for.inc

for.inc:                                          ; preds = %for.body
  %61 = load i32, i32* %i, align 4
  %inc79 = add i32 %61, 1
  store i32 %inc79, i32* %i, align 4
  br label %for.cond

for.end:                                          ; preds = %for.cond
  br label %while.cond62

while.end80:                                      ; preds = %land.end
  %62 = load i8*, i8** %out.addr, align 4
  %63 = load i8, i8* %62, align 1
  %conv81 = sext i8 %63 to i32
  %cmp82 = icmp eq i32 %conv81, 46
  br i1 %cmp82, label %if.then84, label %if.end86

if.then84:                                        ; preds = %while.end80
  %64 = load i8*, i8** %out.addr, align 4
  %65 = load i8*, i8** %p, align 4
  call void @reverse(i8* %64, i8* %65)
  %66 = load i8*, i8** %p, align 4
  %incdec.ptr85 = getelementptr inbounds i8, i8* %66, i32 1
  store i8* %incdec.ptr85, i8** %p, align 4
  store i8 48, i8* %66, align 1
  %67 = load i8*, i8** %p, align 4
  store i8 0, i8* %67, align 1
  %68 = load i8*, i8** %out.addr, align 4
  %69 = load i8*, i8** %p, align 4
  call void @reverse(i8* %68, i8* %69)
  br label %if.end86

if.end86:                                         ; preds = %if.then84, %while.end80
  %70 = load i8*, i8** %out.addr, align 4
  call void @makeQuaterImaginary(%struct.QuaterImaginary* sret align 4 %agg.result, i8* %70)
  br label %return

return:                                           ; preds = %if.end86, %if.then
  ret void
}

; Function Attrs: nounwind readnone speculatable willreturn
declare double @llvm.ceil.f64(double %0) #4

; Function Attrs: noinline nounwind optnone
define hidden i32 @main() #0 {
entry:
  %retval = alloca i32, align 4
  %buffer = alloca [16 x i8], align 16
  %i = alloca i32, align 4
  %c1 = alloca %struct.Complex, align 8
  %qi = alloca %struct.QuaterImaginary, align 4
  %c2 = alloca %struct.Complex, align 8
  %tmp = alloca %struct.Complex, align 8
  %tmp3 = alloca %struct.QuaterImaginary, align 4
  %tmp5 = alloca %struct.Complex, align 8
  %c114 = alloca %struct.Complex, align 8
  %qi18 = alloca %struct.QuaterImaginary, align 4
  %c220 = alloca %struct.Complex, align 8
  %tmp24 = alloca %struct.Complex, align 8
  %tmp25 = alloca %struct.QuaterImaginary, align 4
  %tmp27 = alloca %struct.Complex, align 8
  store i32 0, i32* %retval, align 4
  store i32 1, i32* %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %0 = load i32, i32* %i, align 4
  %cmp = icmp sle i32 %0, 16
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %rel = getelementptr inbounds %struct.Complex, %struct.Complex* %c1, i32 0, i32 0
  %1 = load i32, i32* %i, align 4
  %conv = sitofp i32 %1 to double
  store double %conv, double* %rel, align 8
  %img = getelementptr inbounds %struct.Complex, %struct.Complex* %c1, i32 0, i32 1
  store double 0.000000e+00, double* %img, align 8
  %arraydecay = getelementptr inbounds [16 x i8], [16 x i8]* %buffer, i32 0, i32 0
  call void @c2qi(%struct.QuaterImaginary* sret align 4 %qi, %struct.Complex* byval(%struct.Complex) align 8 %c1, i8* %arraydecay)
  call void @qi2c(%struct.Complex* sret align 8 %c2, %struct.QuaterImaginary* byval(%struct.QuaterImaginary) align 4 %qi)
  call void @printComplex(%struct.Complex* byval(%struct.Complex) align 8 %c1)
  %call = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.4, i32 0, i32 0))
  call void @printQuaterImaginary(%struct.QuaterImaginary* byval(%struct.QuaterImaginary) align 4 %qi)
  %call1 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.4, i32 0, i32 0))
  call void @printComplex(%struct.Complex* byval(%struct.Complex) align 8 %c2)
  %call2 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([6 x i8], [6 x i8]* @.str.5, i32 0, i32 0))
  call void @negComplex(%struct.Complex* sret align 8 %tmp, %struct.Complex* byval(%struct.Complex) align 8 %c1)
  %2 = bitcast %struct.Complex* %c1 to i8*
  %3 = bitcast %struct.Complex* %tmp to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 8 %2, i8* align 8 %3, i32 16, i1 false)
  %arraydecay4 = getelementptr inbounds [16 x i8], [16 x i8]* %buffer, i32 0, i32 0
  call void @c2qi(%struct.QuaterImaginary* sret align 4 %tmp3, %struct.Complex* byval(%struct.Complex) align 8 %c1, i8* %arraydecay4)
  %4 = bitcast %struct.QuaterImaginary* %qi to i8*
  %5 = bitcast %struct.QuaterImaginary* %tmp3 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 4 %4, i8* align 4 %5, i32 8, i1 false)
  call void @qi2c(%struct.Complex* sret align 8 %tmp5, %struct.QuaterImaginary* byval(%struct.QuaterImaginary) align 4 %qi)
  %6 = bitcast %struct.Complex* %c2 to i8*
  %7 = bitcast %struct.Complex* %tmp5 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 8 %6, i8* align 8 %7, i32 16, i1 false)
  call void @printComplex(%struct.Complex* byval(%struct.Complex) align 8 %c1)
  %call6 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.4, i32 0, i32 0))
  call void @printQuaterImaginary(%struct.QuaterImaginary* byval(%struct.QuaterImaginary) align 4 %qi)
  %call7 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.4, i32 0, i32 0))
  call void @printComplex(%struct.Complex* byval(%struct.Complex) align 8 %c2)
  %call8 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([2 x i8], [2 x i8]* @.str.6, i32 0, i32 0))
  br label %for.inc

for.inc:                                          ; preds = %for.body
  %8 = load i32, i32* %i, align 4
  %inc = add nsw i32 %8, 1
  store i32 %inc, i32* %i, align 4
  br label %for.cond

for.end:                                          ; preds = %for.cond
  %call9 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([2 x i8], [2 x i8]* @.str.6, i32 0, i32 0))
  store i32 1, i32* %i, align 4
  br label %for.cond10

for.cond10:                                       ; preds = %for.inc31, %for.end
  %9 = load i32, i32* %i, align 4
  %cmp11 = icmp sle i32 %9, 16
  br i1 %cmp11, label %for.body13, label %for.end33

for.body13:                                       ; preds = %for.cond10
  %rel15 = getelementptr inbounds %struct.Complex, %struct.Complex* %c114, i32 0, i32 0
  store double 0.000000e+00, double* %rel15, align 8
  %img16 = getelementptr inbounds %struct.Complex, %struct.Complex* %c114, i32 0, i32 1
  %10 = load i32, i32* %i, align 4
  %conv17 = sitofp i32 %10 to double
  store double %conv17, double* %img16, align 8
  %arraydecay19 = getelementptr inbounds [16 x i8], [16 x i8]* %buffer, i32 0, i32 0
  call void @c2qi(%struct.QuaterImaginary* sret align 4 %qi18, %struct.Complex* byval(%struct.Complex) align 8 %c114, i8* %arraydecay19)
  call void @qi2c(%struct.Complex* sret align 8 %c220, %struct.QuaterImaginary* byval(%struct.QuaterImaginary) align 4 %qi18)
  call void @printComplex(%struct.Complex* byval(%struct.Complex) align 8 %c114)
  %call21 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.4, i32 0, i32 0))
  call void @printQuaterImaginary(%struct.QuaterImaginary* byval(%struct.QuaterImaginary) align 4 %qi18)
  %call22 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.4, i32 0, i32 0))
  call void @printComplex(%struct.Complex* byval(%struct.Complex) align 8 %c220)
  %call23 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([6 x i8], [6 x i8]* @.str.5, i32 0, i32 0))
  call void @negComplex(%struct.Complex* sret align 8 %tmp24, %struct.Complex* byval(%struct.Complex) align 8 %c114)
  %11 = bitcast %struct.Complex* %c114 to i8*
  %12 = bitcast %struct.Complex* %tmp24 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 8 %11, i8* align 8 %12, i32 16, i1 false)
  %arraydecay26 = getelementptr inbounds [16 x i8], [16 x i8]* %buffer, i32 0, i32 0
  call void @c2qi(%struct.QuaterImaginary* sret align 4 %tmp25, %struct.Complex* byval(%struct.Complex) align 8 %c114, i8* %arraydecay26)
  %13 = bitcast %struct.QuaterImaginary* %qi18 to i8*
  %14 = bitcast %struct.QuaterImaginary* %tmp25 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 4 %13, i8* align 4 %14, i32 8, i1 false)
  call void @qi2c(%struct.Complex* sret align 8 %tmp27, %struct.QuaterImaginary* byval(%struct.QuaterImaginary) align 4 %qi18)
  %15 = bitcast %struct.Complex* %c220 to i8*
  %16 = bitcast %struct.Complex* %tmp27 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 8 %15, i8* align 8 %16, i32 16, i1 false)
  call void @printComplex(%struct.Complex* byval(%struct.Complex) align 8 %c114)
  %call28 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.4, i32 0, i32 0))
  call void @printQuaterImaginary(%struct.QuaterImaginary* byval(%struct.QuaterImaginary) align 4 %qi18)
  %call29 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.4, i32 0, i32 0))
  call void @printComplex(%struct.Complex* byval(%struct.Complex) align 8 %c220)
  %call30 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([2 x i8], [2 x i8]* @.str.6, i32 0, i32 0))
  br label %for.inc31

for.inc31:                                        ; preds = %for.body13
  %17 = load i32, i32* %i, align 4
  %inc32 = add nsw i32 %17, 1
  store i32 %inc32, i32* %i, align 4
  br label %for.cond10

for.end33:                                        ; preds = %for.cond10
  ret i32 0
}

attributes #0 = { noinline nounwind optnone "correctly-rounded-divide-sqrt-fp-math"="false" "disable-tail-calls"="false" "frame-pointer"="none" "less-precise-fpmad"="false" "min-legal-vector-width"="0" "no-infs-fp-math"="false" "no-jump-tables"="false" "no-nans-fp-math"="false" "no-signed-zeros-fp-math"="false" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="generic" "unsafe-fp-math"="false" "use-soft-float"="false" }
attributes #1 = { "correctly-rounded-divide-sqrt-fp-math"="false" "disable-tail-calls"="false" "frame-pointer"="none" "less-precise-fpmad"="false" "no-infs-fp-math"="false" "no-nans-fp-math"="false" "no-signed-zeros-fp-math"="false" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="generic" "unsafe-fp-math"="false" "use-soft-float"="false" }
attributes #2 = { nounwind readonly "correctly-rounded-divide-sqrt-fp-math"="false" "disable-tail-calls"="false" "frame-pointer"="none" "less-precise-fpmad"="false" "no-infs-fp-math"="false" "no-nans-fp-math"="false" "no-signed-zeros-fp-math"="false" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="generic" "unsafe-fp-math"="false" "use-soft-float"="false" }
attributes #3 = { argmemonly nounwind willreturn }
attributes #4 = { nounwind readnone speculatable willreturn }
attributes #5 = { nounwind readonly }

!llvm.module.flags = !{!0}
!llvm.ident = !{!1}

!0 = !{i32 1, !"wchar_size", i32 4}
!1 = !{!"clang version 11.0.0 (https://github.com/Jacarte/llvm-project.git 0f6dea67136cc1e0b3d200eb2bb165628970c44b)"}

; extracted candidates

; *****
; For LLVM instruction:
;  %cmp = icmp ult i8* %1, %2
; Looking for a replacement for:
%0:i32 = var
%1:i32 = var
%2:i1 = ult %0, %1
infer %2

; *****
; For LLVM instruction:
;  %4 = load i8, i8* %3, align 1
; Looking for a replacement for:
%0:i8 = var
infer %0

; *****
; For LLVM instruction:
;  %6 = load i8, i8* %5, align 1
; Looking for a replacement for:
%0:i8 = var
infer %0

; *****
; For LLVM instruction:
;  %8 = load i8, i8* %t, align 1
; Looking for a replacement for:
%0:i8 = var
infer %0
got 3 candidates from LHS

-------------------------------------------------
%0:i32 = var
%1:i32 = var
%2:i1 = ult %0, %1
infer %2


--------------------------------
guess 0

%0:i1 = var ; reservedconst_1

Cost = 0
first query is SAT, returning the model:
reservedconst_1: 0
0 th attempt: second query is SAT-- constant doesn't work
first query is SAT, returning the model:
reservedconst_1: -1
1 th attempt: second query is SAT-- constant doesn't work
first query is UNSAT-- no more guesses
Dataflow Pruned 0/0
There are 1 Guesses
There are 0 RHSs before deduplication
There are 0 RHSs after deduplication
#########################################################
; exiting Souper's runOnFunction() for reverse()

; entering Souper's runOnFunction() for printComplex()

; ModuleID = './Imaginary_base_numbers.c.bc'
source_filename = "./Imaginary_base_numbers.c"
target datalayout = "e-m:e-p:32:32-i64:64-n32:64-S128"
target triple = "wasm32-unknown-wasi"

%struct.Complex = type { double, double }
%struct.QuaterImaginary = type { i8*, i32 }

@.str = private unnamed_addr constant [17 x i8] c"(%3.0f + %3.0fi)\00", align 1
@TWO_I = hidden constant %struct.Complex { double 0.000000e+00, double 2.000000e+00 }, align 8
@INV_TWO_I = hidden constant %struct.Complex { double 0.000000e+00, double -5.000000e-01 }, align 8
@.str.1 = private unnamed_addr constant [4 x i8] c"%8s\00", align 1
@.str.2 = private unnamed_addr constant [9 x i8] c" ERROR  \00", align 1
@.str.3 = private unnamed_addr constant [2 x i8] c"0\00", align 1
@.str.4 = private unnamed_addr constant [5 x i8] c" -> \00", align 1
@.str.5 = private unnamed_addr constant [6 x i8] c"     \00", align 1
@.str.6 = private unnamed_addr constant [2 x i8] c"\0A\00", align 1
@llvm.used = appending global [1 x i8*] [i8* bitcast (i32 ()* @__main_void to i8*)], section "llvm.metadata"

@__main_void = alias i32 (), i32 ()* @main

; Function Attrs: noinline nounwind optnone
define hidden i32 @find(i8* %s, i8 signext %c) #0 {
entry:
  %retval = alloca i32, align 4
  %s.addr = alloca i8*, align 4
  %c.addr = alloca i8, align 1
  %i = alloca i8*, align 4
  store i8* %s, i8** %s.addr, align 4
  store i8 %c, i8* %c.addr, align 1
  %0 = load i8*, i8** %s.addr, align 4
  store i8* %0, i8** %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %1 = load i8*, i8** %i, align 4
  %2 = load i8, i8* %1, align 1
  %conv = sext i8 %2 to i32
  %cmp = icmp ne i32 %conv, 0
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %3 = load i8*, i8** %i, align 4
  %4 = load i8, i8* %3, align 1
  %conv2 = sext i8 %4 to i32
  %5 = load i8, i8* %c.addr, align 1
  %conv3 = sext i8 %5 to i32
  %cmp4 = icmp eq i32 %conv2, %conv3
  br i1 %cmp4, label %if.then, label %if.end

if.then:                                          ; preds = %for.body
  %6 = load i8*, i8** %i, align 4
  %7 = load i8*, i8** %s.addr, align 4
  %sub.ptr.lhs.cast = ptrtoint i8* %6 to i32
  %sub.ptr.rhs.cast = ptrtoint i8* %7 to i32
  %sub.ptr.sub = sub i32 %sub.ptr.lhs.cast, %sub.ptr.rhs.cast
  store i32 %sub.ptr.sub, i32* %retval, align 4
  br label %return

if.end:                                           ; preds = %for.body
  br label %for.inc

for.inc:                                          ; preds = %if.end
  %8 = load i8*, i8** %i, align 4
  %incdec.ptr = getelementptr inbounds i8, i8* %8, i32 1
  store i8* %incdec.ptr, i8** %i, align 4
  br label %for.cond

for.end:                                          ; preds = %for.cond
  store i32 -1, i32* %retval, align 4
  br label %return

return:                                           ; preds = %for.end, %if.then
  %9 = load i32, i32* %retval, align 4
  ret i32 %9
}

; Function Attrs: noinline nounwind optnone
define hidden void @reverse(i8* %b, i8* %e) #0 {
entry:
  %b.addr = alloca i8*, align 4
  %e.addr = alloca i8*, align 4
  %t = alloca i8, align 1
  store i8* %b, i8** %b.addr, align 4
  store i8* %e, i8** %e.addr, align 4
  %0 = load i8*, i8** %e.addr, align 4
  %incdec.ptr = getelementptr inbounds i8, i8* %0, i32 -1
  store i8* %incdec.ptr, i8** %e.addr, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %1 = load i8*, i8** %b.addr, align 4
  %2 = load i8*, i8** %e.addr, align 4
  %cmp = icmp ult i8* %1, %2
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %3 = load i8*, i8** %b.addr, align 4
  %4 = load i8, i8* %3, align 1
  store i8 %4, i8* %t, align 1
  %5 = load i8*, i8** %e.addr, align 4
  %6 = load i8, i8* %5, align 1
  %7 = load i8*, i8** %b.addr, align 4
  store i8 %6, i8* %7, align 1
  %8 = load i8, i8* %t, align 1
  %9 = load i8*, i8** %e.addr, align 4
  store i8 %8, i8* %9, align 1
  br label %for.inc

for.inc:                                          ; preds = %for.body
  %10 = load i8*, i8** %b.addr, align 4
  %incdec.ptr1 = getelementptr inbounds i8, i8* %10, i32 1
  store i8* %incdec.ptr1, i8** %b.addr, align 4
  %11 = load i8*, i8** %e.addr, align 4
  %incdec.ptr2 = getelementptr inbounds i8, i8* %11, i32 -1
  store i8* %incdec.ptr2, i8** %e.addr, align 4
  br label %for.cond

for.end:                                          ; preds = %for.cond
  ret void
}

; Function Attrs: noinline nounwind optnone
define hidden void @printComplex(%struct.Complex* byval(%struct.Complex) align 8 %c) #0 {
entry:
  %rel = getelementptr inbounds %struct.Complex, %struct.Complex* %c, i32 0, i32 0
  %0 = load double, double* %rel, align 8
  %img = getelementptr inbounds %struct.Complex, %struct.Complex* %c, i32 0, i32 1
  %1 = load double, double* %img, align 8
  %call = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([17 x i8], [17 x i8]* @.str, i32 0, i32 0), double %0, double %1)
  ret void
}

declare i32 @printf(i8* %0, ...) #1

; Function Attrs: noinline nounwind optnone
define hidden void @makeComplex(%struct.Complex* noalias sret align 8 %agg.result, double %rel, double %img) #0 {
entry:
  %rel.addr = alloca double, align 8
  %img.addr = alloca double, align 8
  store double %rel, double* %rel.addr, align 8
  store double %img, double* %img.addr, align 8
  %rel1 = getelementptr inbounds %struct.Complex, %struct.Complex* %agg.result, i32 0, i32 0
  %0 = load double, double* %rel.addr, align 8
  store double %0, double* %rel1, align 8
  %img2 = getelementptr inbounds %struct.Complex, %struct.Complex* %agg.result, i32 0, i32 1
  %1 = load double, double* %img.addr, align 8
  store double %1, double* %img2, align 8
  ret void
}

; Function Attrs: noinline nounwind optnone
define hidden void @addComplex(%struct.Complex* noalias sret align 8 %agg.result, %struct.Complex* byval(%struct.Complex) align 8 %a, %struct.Complex* byval(%struct.Complex) align 8 %b) #0 {
entry:
  %rel = getelementptr inbounds %struct.Complex, %struct.Complex* %agg.result, i32 0, i32 0
  %rel1 = getelementptr inbounds %struct.Complex, %struct.Complex* %a, i32 0, i32 0
  %0 = load double, double* %rel1, align 8
  %rel2 = getelementptr inbounds %struct.Complex, %struct.Complex* %b, i32 0, i32 0
  %1 = load double, double* %rel2, align 8
  %add = fadd double %0, %1
  store double %add, double* %rel, align 8
  %img = getelementptr inbounds %struct.Complex, %struct.Complex* %agg.result, i32 0, i32 1
  %img3 = getelementptr inbounds %struct.Complex, %struct.Complex* %a, i32 0, i32 1
  %2 = load double, double* %img3, align 8
  %img4 = getelementptr inbounds %struct.Complex, %struct.Complex* %b, i32 0, i32 1
  %3 = load double, double* %img4, align 8
  %add5 = fadd double %2, %3
  store double %add5, double* %img, align 8
  ret void
}

; Function Attrs: noinline nounwind optnone
define hidden void @mulComplex(%struct.Complex* noalias sret align 8 %agg.result, %struct.Complex* byval(%struct.Complex) align 8 %a, %struct.Complex* byval(%struct.Complex) align 8 %b) #0 {
entry:
  %rel = getelementptr inbounds %struct.Complex, %struct.Complex* %agg.result, i32 0, i32 0
  %rel1 = getelementptr inbounds %struct.Complex, %struct.Complex* %a, i32 0, i32 0
  %0 = load double, double* %rel1, align 8
  %rel2 = getelementptr inbounds %struct.Complex, %struct.Complex* %b, i32 0, i32 0
  %1 = load double, double* %rel2, align 8
  %mul = fmul double %0, %1
  %img = getelementptr inbounds %struct.Complex, %struct.Complex* %a, i32 0, i32 1
  %2 = load double, double* %img, align 8
  %img3 = getelementptr inbounds %struct.Complex, %struct.Complex* %b, i32 0, i32 1
  %3 = load double, double* %img3, align 8
  %mul4 = fmul double %2, %3
  %sub = fsub double %mul, %mul4
  store double %sub, double* %rel, align 8
  %img5 = getelementptr inbounds %struct.Complex, %struct.Complex* %agg.result, i32 0, i32 1
  %rel6 = getelementptr inbounds %struct.Complex, %struct.Complex* %a, i32 0, i32 0
  %4 = load double, double* %rel6, align 8
  %img7 = getelementptr inbounds %struct.Complex, %struct.Complex* %b, i32 0, i32 1
  %5 = load double, double* %img7, align 8
  %mul8 = fmul double %4, %5
  %img9 = getelementptr inbounds %struct.Complex, %struct.Complex* %a, i32 0, i32 1
  %6 = load double, double* %img9, align 8
  %rel10 = getelementptr inbounds %struct.Complex, %struct.Complex* %b, i32 0, i32 0
  %7 = load double, double* %rel10, align 8
  %mul11 = fmul double %6, %7
  %sub12 = fsub double %mul8, %mul11
  store double %sub12, double* %img5, align 8
  ret void
}

; Function Attrs: noinline nounwind optnone
define hidden void @mulComplexD(%struct.Complex* noalias sret align 8 %agg.result, %struct.Complex* byval(%struct.Complex) align 8 %a, double %b) #0 {
entry:
  %b.addr = alloca double, align 8
  store double %b, double* %b.addr, align 8
  %rel = getelementptr inbounds %struct.Complex, %struct.Complex* %agg.result, i32 0, i32 0
  %rel1 = getelementptr inbounds %struct.Complex, %struct.Complex* %a, i32 0, i32 0
  %0 = load double, double* %rel1, align 8
  %1 = load double, double* %b.addr, align 8
  %mul = fmul double %0, %1
  store double %mul, double* %rel, align 8
  %img = getelementptr inbounds %struct.Complex, %struct.Complex* %agg.result, i32 0, i32 1
  %img2 = getelementptr inbounds %struct.Complex, %struct.Complex* %a, i32 0, i32 1
  %2 = load double, double* %img2, align 8
  %3 = load double, double* %b.addr, align 8
  %mul3 = fmul double %2, %3
  store double %mul3, double* %img, align 8
  ret void
}

; Function Attrs: noinline nounwind optnone
define hidden void @negComplex(%struct.Complex* noalias sret align 8 %agg.result, %struct.Complex* byval(%struct.Complex) align 8 %a) #0 {
entry:
  call void @mulComplexD(%struct.Complex* sret align 8 %agg.result, %struct.Complex* byval(%struct.Complex) align 8 %a, double -1.000000e+00)
  ret void
}

; Function Attrs: noinline nounwind optnone
define hidden void @divComplex(%struct.Complex* noalias sret align 8 %agg.result, %struct.Complex* byval(%struct.Complex) align 8 %a, %struct.Complex* byval(%struct.Complex) align 8 %b) #0 {
entry:
  %re = alloca double, align 8
  %im = alloca double, align 8
  %d = alloca double, align 8
  %rel = getelementptr inbounds %struct.Complex, %struct.Complex* %a, i32 0, i32 0
  %0 = load double, double* %rel, align 8
  %rel1 = getelementptr inbounds %struct.Complex, %struct.Complex* %b, i32 0, i32 0
  %1 = load double, double* %rel1, align 8
  %mul = fmul double %0, %1
  %img = getelementptr inbounds %struct.Complex, %struct.Complex* %a, i32 0, i32 1
  %2 = load double, double* %img, align 8
  %img2 = getelementptr inbounds %struct.Complex, %struct.Complex* %b, i32 0, i32 1
  %3 = load double, double* %img2, align 8
  %mul3 = fmul double %2, %3
  %add = fadd double %mul, %mul3
  store double %add, double* %re, align 8
  %img4 = getelementptr inbounds %struct.Complex, %struct.Complex* %a, i32 0, i32 1
  %4 = load double, double* %img4, align 8
  %rel5 = getelementptr inbounds %struct.Complex, %struct.Complex* %b, i32 0, i32 0
  %5 = load double, double* %rel5, align 8
  %mul6 = fmul double %4, %5
  %rel7 = getelementptr inbounds %struct.Complex, %struct.Complex* %a, i32 0, i32 0
  %6 = load double, double* %rel7, align 8
  %img8 = getelementptr inbounds %struct.Complex, %struct.Complex* %b, i32 0, i32 1
  %7 = load double, double* %img8, align 8
  %mul9 = fmul double %6, %7
  %sub = fsub double %mul6, %mul9
  store double %sub, double* %im, align 8
  %rel10 = getelementptr inbounds %struct.Complex, %struct.Complex* %b, i32 0, i32 0
  %8 = load double, double* %rel10, align 8
  %rel11 = getelementptr inbounds %struct.Complex, %struct.Complex* %b, i32 0, i32 0
  %9 = load double, double* %rel11, align 8
  %mul12 = fmul double %8, %9
  %img13 = getelementptr inbounds %struct.Complex, %struct.Complex* %b, i32 0, i32 1
  %10 = load double, double* %img13, align 8
  %img14 = getelementptr inbounds %struct.Complex, %struct.Complex* %b, i32 0, i32 1
  %11 = load double, double* %img14, align 8
  %mul15 = fmul double %10, %11
  %add16 = fadd double %mul12, %mul15
  store double %add16, double* %d, align 8
  %rel17 = getelementptr inbounds %struct.Complex, %struct.Complex* %agg.result, i32 0, i32 0
  %12 = load double, double* %re, align 8
  %13 = load double, double* %d, align 8
  %div = fdiv double %12, %13
  store double %div, double* %rel17, align 8
  %img18 = getelementptr inbounds %struct.Complex, %struct.Complex* %agg.result, i32 0, i32 1
  %14 = load double, double* %im, align 8
  %15 = load double, double* %d, align 8
  %div19 = fdiv double %14, %15
  store double %div19, double* %img18, align 8
  ret void
}

; Function Attrs: noinline nounwind optnone
define hidden void @inv(%struct.Complex* noalias sret align 8 %agg.result, %struct.Complex* byval(%struct.Complex) align 8 %c) #0 {
entry:
  %d = alloca double, align 8
  %rel = getelementptr inbounds %struct.Complex, %struct.Complex* %c, i32 0, i32 0
  %0 = load double, double* %rel, align 8
  %rel1 = getelementptr inbounds %struct.Complex, %struct.Complex* %c, i32 0, i32 0
  %1 = load double, double* %rel1, align 8
  %mul = fmul double %0, %1
  %img = getelementptr inbounds %struct.Complex, %struct.Complex* %c, i32 0, i32 1
  %2 = load double, double* %img, align 8
  %img2 = getelementptr inbounds %struct.Complex, %struct.Complex* %c, i32 0, i32 1
  %3 = load double, double* %img2, align 8
  %mul3 = fmul double %2, %3
  %add = fadd double %mul, %mul3
  store double %add, double* %d, align 8
  %rel4 = getelementptr inbounds %struct.Complex, %struct.Complex* %agg.result, i32 0, i32 0
  %rel5 = getelementptr inbounds %struct.Complex, %struct.Complex* %c, i32 0, i32 0
  %4 = load double, double* %rel5, align 8
  %5 = load double, double* %d, align 8
  %div = fdiv double %4, %5
  store double %div, double* %rel4, align 8
  %img6 = getelementptr inbounds %struct.Complex, %struct.Complex* %agg.result, i32 0, i32 1
  %img7 = getelementptr inbounds %struct.Complex, %struct.Complex* %c, i32 0, i32 1
  %6 = load double, double* %img7, align 8
  %fneg = fneg double %6
  %7 = load double, double* %d, align 8
  %div8 = fdiv double %fneg, %7
  store double %div8, double* %img6, align 8
  ret void
}

; Function Attrs: noinline nounwind optnone
define hidden void @makeQuaterImaginary(%struct.QuaterImaginary* noalias sret align 4 %agg.result, i8* %s) #0 {
entry:
  %s.addr = alloca i8*, align 4
  %i = alloca i32, align 4
  %valid1 = alloca i32, align 4
  %cnt = alloca i32, align 4
  store i8* %s, i8** %s.addr, align 4
  %b2i = getelementptr inbounds %struct.QuaterImaginary, %struct.QuaterImaginary* %agg.result, i32 0, i32 0
  %0 = load i8*, i8** %s.addr, align 4
  store i8* %0, i8** %b2i, align 4
  %valid = getelementptr inbounds %struct.QuaterImaginary, %struct.QuaterImaginary* %agg.result, i32 0, i32 1
  store i32 0, i32* %valid, align 4
  store i32 1, i32* %valid1, align 4
  store i32 0, i32* %cnt, align 4
  %1 = load i8*, i8** %s.addr, align 4
  %2 = load i8, i8* %1, align 1
  %conv = sext i8 %2 to i32
  %cmp = icmp ne i32 %conv, 0
  br i1 %cmp, label %if.then, label %if.end26

if.then:                                          ; preds = %entry
  store i32 0, i32* %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.then
  %3 = load i8*, i8** %s.addr, align 4
  %4 = load i32, i32* %i, align 4
  %arrayidx = getelementptr inbounds i8, i8* %3, i32 %4
  %5 = load i8, i8* %arrayidx, align 1
  %conv3 = sext i8 %5 to i32
  %cmp4 = icmp ne i32 %conv3, 0
  br i1 %cmp4, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %6 = load i8*, i8** %s.addr, align 4
  %7 = load i32, i32* %i, align 4
  %arrayidx6 = getelementptr inbounds i8, i8* %6, i32 %7
  %8 = load i8, i8* %arrayidx6, align 1
  %conv7 = sext i8 %8 to i32
  %cmp8 = icmp slt i32 %conv7, 48
  br i1 %cmp8, label %if.then14, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %for.body
  %9 = load i8*, i8** %s.addr, align 4
  %10 = load i32, i32* %i, align 4
  %arrayidx10 = getelementptr inbounds i8, i8* %9, i32 %10
  %11 = load i8, i8* %arrayidx10, align 1
  %conv11 = sext i8 %11 to i32
  %cmp12 = icmp slt i32 51, %conv11
  br i1 %cmp12, label %if.then14, label %if.end20

if.then14:                                        ; preds = %lor.lhs.false, %for.body
  %12 = load i8*, i8** %s.addr, align 4
  %13 = load i32, i32* %i, align 4
  %arrayidx15 = getelementptr inbounds i8, i8* %12, i32 %13
  %14 = load i8, i8* %arrayidx15, align 1
  %conv16 = sext i8 %14 to i32
  %cmp17 = icmp eq i32 %conv16, 46
  br i1 %cmp17, label %if.then19, label %if.else

if.then19:                                        ; preds = %if.then14
  %15 = load i32, i32* %cnt, align 4
  %inc = add i32 %15, 1
  store i32 %inc, i32* %cnt, align 4
  br label %if.end

if.else:                                          ; preds = %if.then14
  store i32 0, i32* %valid1, align 4
  br label %for.end

if.end:                                           ; preds = %if.then19
  br label %if.end20

if.end20:                                         ; preds = %if.end, %lor.lhs.false
  br label %for.inc

for.inc:                                          ; preds = %if.end20
  %16 = load i32, i32* %i, align 4
  %inc21 = add i32 %16, 1
  store i32 %inc21, i32* %i, align 4
  br label %for.cond

for.end:                                          ; preds = %if.else, %for.cond
  %17 = load i32, i32* %valid1, align 4
  %tobool = icmp ne i32 %17, 0
  br i1 %tobool, label %land.lhs.true, label %if.end25

land.lhs.true:                                    ; preds = %for.end
  %18 = load i32, i32* %cnt, align 4
  %cmp22 = icmp ugt i32 %18, 1
  br i1 %cmp22, label %if.then24, label %if.end25

if.then24:                                        ; preds = %land.lhs.true
  store i32 0, i32* %valid1, align 4
  br label %if.end25

if.end25:                                         ; preds = %if.then24, %land.lhs.true, %for.end
  br label %if.end26

if.end26:                                         ; preds = %if.end25, %entry
  %19 = load i32, i32* %valid1, align 4
  %valid27 = getelementptr inbounds %struct.QuaterImaginary, %struct.QuaterImaginary* %agg.result, i32 0, i32 1
  store i32 %19, i32* %valid27, align 4
  ret void
}

; Function Attrs: noinline nounwind optnone
define hidden void @printQuaterImaginary(%struct.QuaterImaginary* byval(%struct.QuaterImaginary) align 4 %qi) #0 {
entry:
  %valid = getelementptr inbounds %struct.QuaterImaginary, %struct.QuaterImaginary* %qi, i32 0, i32 1
  %0 = load i32, i32* %valid, align 4
  %tobool = icmp ne i32 %0, 0
  br i1 %tobool, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  %b2i = getelementptr inbounds %struct.QuaterImaginary, %struct.QuaterImaginary* %qi, i32 0, i32 0
  %1 = load i8*, i8** %b2i, align 4
  %call = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([4 x i8], [4 x i8]* @.str.1, i32 0, i32 0), i8* %1)
  br label %if.end

if.else:                                          ; preds = %entry
  %call1 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([9 x i8], [9 x i8]* @.str.2, i32 0, i32 0))
  br label %if.end

if.end:                                           ; preds = %if.else, %if.then
  ret void
}

; Function Attrs: noinline nounwind optnone
define hidden void @qi2c(%struct.Complex* noalias sret align 8 %agg.result, %struct.QuaterImaginary* byval(%struct.QuaterImaginary) align 4 %qi) #0 {
entry:
  %len = alloca i32, align 4
  %pointPos = alloca i32, align 4
  %posLen = alloca i32, align 4
  %prod = alloca %struct.Complex, align 8
  %j = alloca i32, align 4
  %k = alloca double, align 8
  %tmp = alloca %struct.Complex, align 8
  %agg.tmp = alloca %struct.Complex, align 8
  %tmp10 = alloca %struct.Complex, align 8
  %k18 = alloca double, align 8
  %tmp27 = alloca %struct.Complex, align 8
  %agg.tmp28 = alloca %struct.Complex, align 8
  %tmp30 = alloca %struct.Complex, align 8
  %b2i = getelementptr inbounds %struct.QuaterImaginary, %struct.QuaterImaginary* %qi, i32 0, i32 0
  %0 = load i8*, i8** %b2i, align 4
  %call = call i32 @strlen(i8* %0) #5
  store i32 %call, i32* %len, align 4
  %b2i1 = getelementptr inbounds %struct.QuaterImaginary, %struct.QuaterImaginary* %qi, i32 0, i32 0
  %1 = load i8*, i8** %b2i1, align 4
  %call2 = call i32 @find(i8* %1, i8 signext 46)
  store i32 %call2, i32* %pointPos, align 4
  %2 = load i32, i32* %pointPos, align 4
  %cmp = icmp sgt i32 %2, 0
  br i1 %cmp, label %cond.true, label %cond.false

cond.true:                                        ; preds = %entry
  %3 = load i32, i32* %pointPos, align 4
  br label %cond.end

cond.false:                                       ; preds = %entry
  %4 = load i32, i32* %len, align 4
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi i32 [ %3, %cond.true ], [ %4, %cond.false ]
  store i32 %cond, i32* %posLen, align 4
  call void @makeComplex(%struct.Complex* sret align 8 %agg.result, double 0.000000e+00, double 0.000000e+00)
  call void @makeComplex(%struct.Complex* sret align 8 %prod, double 1.000000e+00, double 0.000000e+00)
  store i32 0, i32* %j, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %cond.end
  %5 = load i32, i32* %j, align 4
  %6 = load i32, i32* %posLen, align 4
  %cmp3 = icmp ult i32 %5, %6
  br i1 %cmp3, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %b2i4 = getelementptr inbounds %struct.QuaterImaginary, %struct.QuaterImaginary* %qi, i32 0, i32 0
  %7 = load i8*, i8** %b2i4, align 4
  %8 = load i32, i32* %posLen, align 4
  %sub = sub i32 %8, 1
  %9 = load i32, i32* %j, align 4
  %sub5 = sub i32 %sub, %9
  %arrayidx = getelementptr inbounds i8, i8* %7, i32 %sub5
  %10 = load i8, i8* %arrayidx, align 1
  %conv = sext i8 %10 to i32
  %sub6 = sub nsw i32 %conv, 48
  %conv7 = sitofp i32 %sub6 to double
  store double %conv7, double* %k, align 8
  %11 = load double, double* %k, align 8
  %cmp8 = fcmp ogt double %11, 0.000000e+00
  br i1 %cmp8, label %if.then, label %if.end

if.then:                                          ; preds = %for.body
  %12 = load double, double* %k, align 8
  call void @mulComplexD(%struct.Complex* sret align 8 %agg.tmp, %struct.Complex* byval(%struct.Complex) align 8 %prod, double %12)
  call void @addComplex(%struct.Complex* sret align 8 %tmp, %struct.Complex* byval(%struct.Complex) align 8 %agg.result, %struct.Complex* byval(%struct.Complex) align 8 %agg.tmp)
  %13 = bitcast %struct.Complex* %agg.result to i8*
  %14 = bitcast %struct.Complex* %tmp to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 8 %13, i8* align 8 %14, i32 16, i1 false)
  br label %if.end

if.end:                                           ; preds = %if.then, %for.body
  call void @mulComplex(%struct.Complex* sret align 8 %tmp10, %struct.Complex* byval(%struct.Complex) align 8 %prod, %struct.Complex* byval(%struct.Complex) align 8 @TWO_I)
  %15 = bitcast %struct.Complex* %prod to i8*
  %16 = bitcast %struct.Complex* %tmp10 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 8 %15, i8* align 8 %16, i32 16, i1 false)
  br label %for.inc

for.inc:                                          ; preds = %if.end
  %17 = load i32, i32* %j, align 4
  %inc = add i32 %17, 1
  store i32 %inc, i32* %j, align 4
  br label %for.cond

for.end:                                          ; preds = %for.cond
  %18 = load i32, i32* %pointPos, align 4
  %cmp11 = icmp ne i32 %18, -1
  br i1 %cmp11, label %if.then13, label %if.end34

if.then13:                                        ; preds = %for.end
  %19 = bitcast %struct.Complex* %prod to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 8 %19, i8* align 8 bitcast (%struct.Complex* @INV_TWO_I to i8*), i32 16, i1 false)
  %20 = load i32, i32* %posLen, align 4
  %add = add i32 %20, 1
  store i32 %add, i32* %j, align 4
  br label %for.cond14

for.cond14:                                       ; preds = %for.inc31, %if.then13
  %21 = load i32, i32* %j, align 4
  %22 = load i32, i32* %len, align 4
  %cmp15 = icmp ult i32 %21, %22
  br i1 %cmp15, label %for.body17, label %for.end33

for.body17:                                       ; preds = %for.cond14
  %b2i19 = getelementptr inbounds %struct.QuaterImaginary, %struct.QuaterImaginary* %qi, i32 0, i32 0
  %23 = load i8*, i8** %b2i19, align 4
  %24 = load i32, i32* %j, align 4
  %arrayidx20 = getelementptr inbounds i8, i8* %23, i32 %24
  %25 = load i8, i8* %arrayidx20, align 1
  %conv21 = sext i8 %25 to i32
  %sub22 = sub nsw i32 %conv21, 48
  %conv23 = sitofp i32 %sub22 to double
  store double %conv23, double* %k18, align 8
  %26 = load double, double* %k18, align 8
  %cmp24 = fcmp ogt double %26, 0.000000e+00
  br i1 %cmp24, label %if.then26, label %if.end29

if.then26:                                        ; preds = %for.body17
  %27 = load double, double* %k18, align 8
  call void @mulComplexD(%struct.Complex* sret align 8 %agg.tmp28, %struct.Complex* byval(%struct.Complex) align 8 %prod, double %27)
  call void @addComplex(%struct.Complex* sret align 8 %tmp27, %struct.Complex* byval(%struct.Complex) align 8 %agg.result, %struct.Complex* byval(%struct.Complex) align 8 %agg.tmp28)
  %28 = bitcast %struct.Complex* %agg.result to i8*
  %29 = bitcast %struct.Complex* %tmp27 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 8 %28, i8* align 8 %29, i32 16, i1 false)
  br label %if.end29

if.end29:                                         ; preds = %if.then26, %for.body17
  call void @mulComplex(%struct.Complex* sret align 8 %tmp30, %struct.Complex* byval(%struct.Complex) align 8 %prod, %struct.Complex* byval(%struct.Complex) align 8 @INV_TWO_I)
  %30 = bitcast %struct.Complex* %prod to i8*
  %31 = bitcast %struct.Complex* %tmp30 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 8 %30, i8* align 8 %31, i32 16, i1 false)
  br label %for.inc31

for.inc31:                                        ; preds = %if.end29
  %32 = load i32, i32* %j, align 4
  %inc32 = add i32 %32, 1
  store i32 %inc32, i32* %j, align 4
  br label %for.cond14

for.end33:                                        ; preds = %for.cond14
  br label %if.end34

if.end34:                                         ; preds = %for.end33, %for.end
  ret void
}

; Function Attrs: nounwind readonly
declare i32 @strlen(i8* %0) #2

; Function Attrs: argmemonly nounwind willreturn
declare void @llvm.memcpy.p0i8.p0i8.i32(i8* noalias nocapture writeonly %0, i8* noalias nocapture readonly %1, i32 %2, i1 immarg %3) #3

; Function Attrs: noinline nounwind optnone
define hidden void @c2qi(%struct.QuaterImaginary* noalias sret align 4 %agg.result, %struct.Complex* byval(%struct.Complex) align 8 %c, i8* %out) #0 {
entry:
  %out.addr = alloca i8*, align 4
  %p = alloca i8*, align 4
  %re = alloca i32, align 4
  %im = alloca i32, align 4
  %fi = alloca i32, align 4
  %rem = alloca i32, align 4
  %index = alloca i32, align 4
  %fc = alloca %struct.Complex, align 8
  %.compoundliteral = alloca %struct.Complex, align 8
  %.compoundliteral21 = alloca %struct.Complex, align 8
  %f = alloca double, align 8
  %rem31 = alloca i32, align 4
  %i = alloca i32, align 4
  store i8* %out, i8** %out.addr, align 4
  %0 = load i8*, i8** %out.addr, align 4
  store i8* %0, i8** %p, align 4
  %1 = load i8*, i8** %p, align 4
  store i8 0, i8* %1, align 1
  %rel = getelementptr inbounds %struct.Complex, %struct.Complex* %c, i32 0, i32 0
  %2 = load double, double* %rel, align 8
  %cmp = fcmp oeq double %2, 0.000000e+00
  br i1 %cmp, label %land.lhs.true, label %if.end

land.lhs.true:                                    ; preds = %entry
  %img = getelementptr inbounds %struct.Complex, %struct.Complex* %c, i32 0, i32 1
  %3 = load double, double* %img, align 8
  %cmp1 = fcmp oeq double %3, 0.000000e+00
  br i1 %cmp1, label %if.then, label %if.end

if.then:                                          ; preds = %land.lhs.true
  call void @makeQuaterImaginary(%struct.QuaterImaginary* sret align 4 %agg.result, i8* getelementptr inbounds ([2 x i8], [2 x i8]* @.str.3, i32 0, i32 0))
  br label %return

if.end:                                           ; preds = %land.lhs.true, %entry
  %rel2 = getelementptr inbounds %struct.Complex, %struct.Complex* %c, i32 0, i32 0
  %4 = load double, double* %rel2, align 8
  %conv = fptosi double %4 to i32
  store i32 %conv, i32* %re, align 4
  %img3 = getelementptr inbounds %struct.Complex, %struct.Complex* %c, i32 0, i32 1
  %5 = load double, double* %img3, align 8
  %conv4 = fptosi double %5 to i32
  store i32 %conv4, i32* %im, align 4
  store i32 -1, i32* %fi, align 4
  br label %while.cond

while.cond:                                       ; preds = %if.end11, %if.end
  %6 = load i32, i32* %re, align 4
  %cmp5 = icmp ne i32 %6, 0
  br i1 %cmp5, label %while.body, label %while.end

while.body:                                       ; preds = %while.cond
  %7 = load i32, i32* %re, align 4
  %rem7 = srem i32 %7, -4
  store i32 %rem7, i32* %rem, align 4
  %8 = load i32, i32* %re, align 4
  %div = sdiv i32 %8, -4
  store i32 %div, i32* %re, align 4
  %9 = load i32, i32* %rem, align 4
  %cmp8 = icmp slt i32 %9, 0
  br i1 %cmp8, label %if.then10, label %if.end11

if.then10:                                        ; preds = %while.body
  %10 = load i32, i32* %rem, align 4
  %add = add nsw i32 %10, 4
  store i32 %add, i32* %rem, align 4
  %11 = load i32, i32* %re, align 4
  %inc = add nsw i32 %11, 1
  store i32 %inc, i32* %re, align 4
  br label %if.end11

if.end11:                                         ; preds = %if.then10, %while.body
  %12 = load i32, i32* %rem, align 4
  %add12 = add nsw i32 %12, 48
  %conv13 = trunc i32 %add12 to i8
  %13 = load i8*, i8** %p, align 4
  %incdec.ptr = getelementptr inbounds i8, i8* %13, i32 1
  store i8* %incdec.ptr, i8** %p, align 4
  store i8 %conv13, i8* %13, align 1
  %14 = load i8*, i8** %p, align 4
  %incdec.ptr14 = getelementptr inbounds i8, i8* %14, i32 1
  store i8* %incdec.ptr14, i8** %p, align 4
  store i8 48, i8* %14, align 1
  %15 = load i8*, i8** %p, align 4
  store i8 0, i8* %15, align 1
  br label %while.cond

while.end:                                        ; preds = %while.cond
  %16 = load i32, i32* %im, align 4
  %cmp15 = icmp ne i32 %16, 0
  br i1 %cmp15, label %if.then17, label %if.end53

if.then17:                                        ; preds = %while.end
  store i32 1, i32* %index, align 4
  %rel18 = getelementptr inbounds %struct.Complex, %struct.Complex* %.compoundliteral, i32 0, i32 0
  store double 0.000000e+00, double* %rel18, align 8
  %img19 = getelementptr inbounds %struct.Complex, %struct.Complex* %.compoundliteral, i32 0, i32 1
  %img20 = getelementptr inbounds %struct.Complex, %struct.Complex* %c, i32 0, i32 1
  %17 = load double, double* %img20, align 8
  store double %17, double* %img19, align 8
  %rel22 = getelementptr inbounds %struct.Complex, %struct.Complex* %.compoundliteral21, i32 0, i32 0
  store double 0.000000e+00, double* %rel22, align 8
  %img23 = getelementptr inbounds %struct.Complex, %struct.Complex* %.compoundliteral21, i32 0, i32 1
  store double 2.000000e+00, double* %img23, align 8
  call void @divComplex(%struct.Complex* sret align 8 %fc, %struct.Complex* byval(%struct.Complex) align 8 %.compoundliteral, %struct.Complex* byval(%struct.Complex) align 8 %.compoundliteral21)
  %rel24 = getelementptr inbounds %struct.Complex, %struct.Complex* %fc, i32 0, i32 0
  %18 = load double, double* %rel24, align 8
  store double %18, double* %f, align 8
  %19 = load double, double* %f, align 8
  %20 = call double @llvm.ceil.f64(double %19)
  %conv25 = fptosi double %20 to i32
  store i32 %conv25, i32* %im, align 4
  %21 = load double, double* %f, align 8
  %22 = load i32, i32* %im, align 4
  %conv26 = sitofp i32 %22 to double
  %sub = fsub double %21, %conv26
  %mul = fmul double -4.000000e+00, %sub
  store double %mul, double* %f, align 8
  br label %while.cond27

while.cond27:                                     ; preds = %if.end49, %if.then17
  %23 = load i32, i32* %im, align 4
  %cmp28 = icmp ne i32 %23, 0
  br i1 %cmp28, label %while.body30, label %while.end51

while.body30:                                     ; preds = %while.cond27
  %24 = load i32, i32* %im, align 4
  %rem32 = srem i32 %24, -4
  store i32 %rem32, i32* %rem31, align 4
  %25 = load i32, i32* %im, align 4
  %div33 = sdiv i32 %25, -4
  store i32 %div33, i32* %im, align 4
  %26 = load i32, i32* %rem31, align 4
  %cmp34 = icmp slt i32 %26, 0
  br i1 %cmp34, label %if.then36, label %if.end39

if.then36:                                        ; preds = %while.body30
  %27 = load i32, i32* %rem31, align 4
  %add37 = add nsw i32 %27, 4
  store i32 %add37, i32* %rem31, align 4
  %28 = load i32, i32* %im, align 4
  %inc38 = add nsw i32 %28, 1
  store i32 %inc38, i32* %im, align 4
  br label %if.end39

if.end39:                                         ; preds = %if.then36, %while.body30
  %29 = load i32, i32* %index, align 4
  %30 = load i8*, i8** %p, align 4
  %31 = load i8*, i8** %out.addr, align 4
  %sub.ptr.lhs.cast = ptrtoint i8* %30 to i32
  %sub.ptr.rhs.cast = ptrtoint i8* %31 to i32
  %sub.ptr.sub = sub i32 %sub.ptr.lhs.cast, %sub.ptr.rhs.cast
  %cmp40 = icmp ult i32 %29, %sub.ptr.sub
  br i1 %cmp40, label %if.then42, label %if.else

if.then42:                                        ; preds = %if.end39
  %32 = load i32, i32* %rem31, align 4
  %add43 = add nsw i32 %32, 48
  %conv44 = trunc i32 %add43 to i8
  %33 = load i8*, i8** %out.addr, align 4
  %34 = load i32, i32* %index, align 4
  %arrayidx = getelementptr inbounds i8, i8* %33, i32 %34
  store i8 %conv44, i8* %arrayidx, align 1
  br label %if.end49

if.else:                                          ; preds = %if.end39
  %35 = load i8*, i8** %p, align 4
  %incdec.ptr45 = getelementptr inbounds i8, i8* %35, i32 1
  store i8* %incdec.ptr45, i8** %p, align 4
  store i8 48, i8* %35, align 1
  %36 = load i32, i32* %rem31, align 4
  %add46 = add nsw i32 %36, 48
  %conv47 = trunc i32 %add46 to i8
  %37 = load i8*, i8** %p, align 4
  %incdec.ptr48 = getelementptr inbounds i8, i8* %37, i32 1
  store i8* %incdec.ptr48, i8** %p, align 4
  store i8 %conv47, i8* %37, align 1
  %38 = load i8*, i8** %p, align 4
  store i8 0, i8* %38, align 1
  br label %if.end49

if.end49:                                         ; preds = %if.else, %if.then42
  %39 = load i32, i32* %index, align 4
  %add50 = add i32 %39, 2
  store i32 %add50, i32* %index, align 4
  br label %while.cond27

while.end51:                                      ; preds = %while.cond27
  %40 = load double, double* %f, align 8
  %conv52 = fptosi double %40 to i32
  store i32 %conv52, i32* %fi, align 4
  br label %if.end53

if.end53:                                         ; preds = %while.end51, %while.end
  %41 = load i8*, i8** %out.addr, align 4
  %42 = load i8*, i8** %p, align 4
  call void @reverse(i8* %41, i8* %42)
  %43 = load i32, i32* %fi, align 4
  %cmp54 = icmp ne i32 %43, -1
  br i1 %cmp54, label %if.then56, label %if.end61

if.then56:                                        ; preds = %if.end53
  %44 = load i8*, i8** %p, align 4
  %incdec.ptr57 = getelementptr inbounds i8, i8* %44, i32 1
  store i8* %incdec.ptr57, i8** %p, align 4
  store i8 46, i8* %44, align 1
  %45 = load i32, i32* %fi, align 4
  %add58 = add nsw i32 %45, 48
  %conv59 = trunc i32 %add58 to i8
  %46 = load i8*, i8** %p, align 4
  %incdec.ptr60 = getelementptr inbounds i8, i8* %46, i32 1
  store i8* %incdec.ptr60, i8** %p, align 4
  store i8 %conv59, i8* %46, align 1
  %47 = load i8*, i8** %p, align 4
  store i8 0, i8* %47, align 1
  br label %if.end61

if.end61:                                         ; preds = %if.then56, %if.end53
  br label %while.cond62

while.cond62:                                     ; preds = %for.end, %if.end61
  %48 = load i8*, i8** %out.addr, align 4
  %arrayidx63 = getelementptr inbounds i8, i8* %48, i32 0
  %49 = load i8, i8* %arrayidx63, align 1
  %conv64 = sext i8 %49 to i32
  %cmp65 = icmp eq i32 %conv64, 48
  br i1 %cmp65, label %land.rhs, label %land.end

land.rhs:                                         ; preds = %while.cond62
  %50 = load i8*, i8** %out.addr, align 4
  %arrayidx67 = getelementptr inbounds i8, i8* %50, i32 1
  %51 = load i8, i8* %arrayidx67, align 1
  %conv68 = sext i8 %51 to i32
  %cmp69 = icmp ne i32 %conv68, 46
  br label %land.end

land.end:                                         ; preds = %land.rhs, %while.cond62
  %52 = phi i1 [ false, %while.cond62 ], [ %cmp69, %land.rhs ]
  br i1 %52, label %while.body71, label %while.end80

while.body71:                                     ; preds = %land.end
  store i32 0, i32* %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %while.body71
  %53 = load i8*, i8** %out.addr, align 4
  %54 = load i32, i32* %i, align 4
  %arrayidx72 = getelementptr inbounds i8, i8* %53, i32 %54
  %55 = load i8, i8* %arrayidx72, align 1
  %conv73 = sext i8 %55 to i32
  %cmp74 = icmp ne i32 %conv73, 0
  br i1 %cmp74, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %56 = load i8*, i8** %out.addr, align 4
  %57 = load i32, i32* %i, align 4
  %add76 = add i32 %57, 1
  %arrayidx77 = getelementptr inbounds i8, i8* %56, i32 %add76
  %58 = load i8, i8* %arrayidx77, align 1
  %59 = load i8*, i8** %out.addr, align 4
  %60 = load i32, i32* %i, align 4
  %arrayidx78 = getelementptr inbounds i8, i8* %59, i32 %60
  store i8 %58, i8* %arrayidx78, align 1
  br label %for.inc

for.inc:                                          ; preds = %for.body
  %61 = load i32, i32* %i, align 4
  %inc79 = add i32 %61, 1
  store i32 %inc79, i32* %i, align 4
  br label %for.cond

for.end:                                          ; preds = %for.cond
  br label %while.cond62

while.end80:                                      ; preds = %land.end
  %62 = load i8*, i8** %out.addr, align 4
  %63 = load i8, i8* %62, align 1
  %conv81 = sext i8 %63 to i32
  %cmp82 = icmp eq i32 %conv81, 46
  br i1 %cmp82, label %if.then84, label %if.end86

if.then84:                                        ; preds = %while.end80
  %64 = load i8*, i8** %out.addr, align 4
  %65 = load i8*, i8** %p, align 4
  call void @reverse(i8* %64, i8* %65)
  %66 = load i8*, i8** %p, align 4
  %incdec.ptr85 = getelementptr inbounds i8, i8* %66, i32 1
  store i8* %incdec.ptr85, i8** %p, align 4
  store i8 48, i8* %66, align 1
  %67 = load i8*, i8** %p, align 4
  store i8 0, i8* %67, align 1
  %68 = load i8*, i8** %out.addr, align 4
  %69 = load i8*, i8** %p, align 4
  call void @reverse(i8* %68, i8* %69)
  br label %if.end86

if.end86:                                         ; preds = %if.then84, %while.end80
  %70 = load i8*, i8** %out.addr, align 4
  call void @makeQuaterImaginary(%struct.QuaterImaginary* sret align 4 %agg.result, i8* %70)
  br label %return

return:                                           ; preds = %if.end86, %if.then
  ret void
}

; Function Attrs: nounwind readnone speculatable willreturn
declare double @llvm.ceil.f64(double %0) #4

; Function Attrs: noinline nounwind optnone
define hidden i32 @main() #0 {
entry:
  %retval = alloca i32, align 4
  %buffer = alloca [16 x i8], align 16
  %i = alloca i32, align 4
  %c1 = alloca %struct.Complex, align 8
  %qi = alloca %struct.QuaterImaginary, align 4
  %c2 = alloca %struct.Complex, align 8
  %tmp = alloca %struct.Complex, align 8
  %tmp3 = alloca %struct.QuaterImaginary, align 4
  %tmp5 = alloca %struct.Complex, align 8
  %c114 = alloca %struct.Complex, align 8
  %qi18 = alloca %struct.QuaterImaginary, align 4
  %c220 = alloca %struct.Complex, align 8
  %tmp24 = alloca %struct.Complex, align 8
  %tmp25 = alloca %struct.QuaterImaginary, align 4
  %tmp27 = alloca %struct.Complex, align 8
  store i32 0, i32* %retval, align 4
  store i32 1, i32* %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %0 = load i32, i32* %i, align 4
  %cmp = icmp sle i32 %0, 16
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %rel = getelementptr inbounds %struct.Complex, %struct.Complex* %c1, i32 0, i32 0
  %1 = load i32, i32* %i, align 4
  %conv = sitofp i32 %1 to double
  store double %conv, double* %rel, align 8
  %img = getelementptr inbounds %struct.Complex, %struct.Complex* %c1, i32 0, i32 1
  store double 0.000000e+00, double* %img, align 8
  %arraydecay = getelementptr inbounds [16 x i8], [16 x i8]* %buffer, i32 0, i32 0
  call void @c2qi(%struct.QuaterImaginary* sret align 4 %qi, %struct.Complex* byval(%struct.Complex) align 8 %c1, i8* %arraydecay)
  call void @qi2c(%struct.Complex* sret align 8 %c2, %struct.QuaterImaginary* byval(%struct.QuaterImaginary) align 4 %qi)
  call void @printComplex(%struct.Complex* byval(%struct.Complex) align 8 %c1)
  %call = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.4, i32 0, i32 0))
  call void @printQuaterImaginary(%struct.QuaterImaginary* byval(%struct.QuaterImaginary) align 4 %qi)
  %call1 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.4, i32 0, i32 0))
  call void @printComplex(%struct.Complex* byval(%struct.Complex) align 8 %c2)
  %call2 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([6 x i8], [6 x i8]* @.str.5, i32 0, i32 0))
  call void @negComplex(%struct.Complex* sret align 8 %tmp, %struct.Complex* byval(%struct.Complex) align 8 %c1)
  %2 = bitcast %struct.Complex* %c1 to i8*
  %3 = bitcast %struct.Complex* %tmp to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 8 %2, i8* align 8 %3, i32 16, i1 false)
  %arraydecay4 = getelementptr inbounds [16 x i8], [16 x i8]* %buffer, i32 0, i32 0
  call void @c2qi(%struct.QuaterImaginary* sret align 4 %tmp3, %struct.Complex* byval(%struct.Complex) align 8 %c1, i8* %arraydecay4)
  %4 = bitcast %struct.QuaterImaginary* %qi to i8*
  %5 = bitcast %struct.QuaterImaginary* %tmp3 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 4 %4, i8* align 4 %5, i32 8, i1 false)
  call void @qi2c(%struct.Complex* sret align 8 %tmp5, %struct.QuaterImaginary* byval(%struct.QuaterImaginary) align 4 %qi)
  %6 = bitcast %struct.Complex* %c2 to i8*
  %7 = bitcast %struct.Complex* %tmp5 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 8 %6, i8* align 8 %7, i32 16, i1 false)
  call void @printComplex(%struct.Complex* byval(%struct.Complex) align 8 %c1)
  %call6 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.4, i32 0, i32 0))
  call void @printQuaterImaginary(%struct.QuaterImaginary* byval(%struct.QuaterImaginary) align 4 %qi)
  %call7 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.4, i32 0, i32 0))
  call void @printComplex(%struct.Complex* byval(%struct.Complex) align 8 %c2)
  %call8 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([2 x i8], [2 x i8]* @.str.6, i32 0, i32 0))
  br label %for.inc

for.inc:                                          ; preds = %for.body
  %8 = load i32, i32* %i, align 4
  %inc = add nsw i32 %8, 1
  store i32 %inc, i32* %i, align 4
  br label %for.cond

for.end:                                          ; preds = %for.cond
  %call9 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([2 x i8], [2 x i8]* @.str.6, i32 0, i32 0))
  store i32 1, i32* %i, align 4
  br label %for.cond10

for.cond10:                                       ; preds = %for.inc31, %for.end
  %9 = load i32, i32* %i, align 4
  %cmp11 = icmp sle i32 %9, 16
  br i1 %cmp11, label %for.body13, label %for.end33

for.body13:                                       ; preds = %for.cond10
  %rel15 = getelementptr inbounds %struct.Complex, %struct.Complex* %c114, i32 0, i32 0
  store double 0.000000e+00, double* %rel15, align 8
  %img16 = getelementptr inbounds %struct.Complex, %struct.Complex* %c114, i32 0, i32 1
  %10 = load i32, i32* %i, align 4
  %conv17 = sitofp i32 %10 to double
  store double %conv17, double* %img16, align 8
  %arraydecay19 = getelementptr inbounds [16 x i8], [16 x i8]* %buffer, i32 0, i32 0
  call void @c2qi(%struct.QuaterImaginary* sret align 4 %qi18, %struct.Complex* byval(%struct.Complex) align 8 %c114, i8* %arraydecay19)
  call void @qi2c(%struct.Complex* sret align 8 %c220, %struct.QuaterImaginary* byval(%struct.QuaterImaginary) align 4 %qi18)
  call void @printComplex(%struct.Complex* byval(%struct.Complex) align 8 %c114)
  %call21 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.4, i32 0, i32 0))
  call void @printQuaterImaginary(%struct.QuaterImaginary* byval(%struct.QuaterImaginary) align 4 %qi18)
  %call22 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.4, i32 0, i32 0))
  call void @printComplex(%struct.Complex* byval(%struct.Complex) align 8 %c220)
  %call23 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([6 x i8], [6 x i8]* @.str.5, i32 0, i32 0))
  call void @negComplex(%struct.Complex* sret align 8 %tmp24, %struct.Complex* byval(%struct.Complex) align 8 %c114)
  %11 = bitcast %struct.Complex* %c114 to i8*
  %12 = bitcast %struct.Complex* %tmp24 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 8 %11, i8* align 8 %12, i32 16, i1 false)
  %arraydecay26 = getelementptr inbounds [16 x i8], [16 x i8]* %buffer, i32 0, i32 0
  call void @c2qi(%struct.QuaterImaginary* sret align 4 %tmp25, %struct.Complex* byval(%struct.Complex) align 8 %c114, i8* %arraydecay26)
  %13 = bitcast %struct.QuaterImaginary* %qi18 to i8*
  %14 = bitcast %struct.QuaterImaginary* %tmp25 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 4 %13, i8* align 4 %14, i32 8, i1 false)
  call void @qi2c(%struct.Complex* sret align 8 %tmp27, %struct.QuaterImaginary* byval(%struct.QuaterImaginary) align 4 %qi18)
  %15 = bitcast %struct.Complex* %c220 to i8*
  %16 = bitcast %struct.Complex* %tmp27 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 8 %15, i8* align 8 %16, i32 16, i1 false)
  call void @printComplex(%struct.Complex* byval(%struct.Complex) align 8 %c114)
  %call28 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.4, i32 0, i32 0))
  call void @printQuaterImaginary(%struct.QuaterImaginary* byval(%struct.QuaterImaginary) align 4 %qi18)
  %call29 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.4, i32 0, i32 0))
  call void @printComplex(%struct.Complex* byval(%struct.Complex) align 8 %c220)
  %call30 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([2 x i8], [2 x i8]* @.str.6, i32 0, i32 0))
  br label %for.inc31

for.inc31:                                        ; preds = %for.body13
  %17 = load i32, i32* %i, align 4
  %inc32 = add nsw i32 %17, 1
  store i32 %inc32, i32* %i, align 4
  br label %for.cond10

for.end33:                                        ; preds = %for.cond10
  ret i32 0
}

attributes #0 = { noinline nounwind optnone "correctly-rounded-divide-sqrt-fp-math"="false" "disable-tail-calls"="false" "frame-pointer"="none" "less-precise-fpmad"="false" "min-legal-vector-width"="0" "no-infs-fp-math"="false" "no-jump-tables"="false" "no-nans-fp-math"="false" "no-signed-zeros-fp-math"="false" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="generic" "unsafe-fp-math"="false" "use-soft-float"="false" }
attributes #1 = { "correctly-rounded-divide-sqrt-fp-math"="false" "disable-tail-calls"="false" "frame-pointer"="none" "less-precise-fpmad"="false" "no-infs-fp-math"="false" "no-nans-fp-math"="false" "no-signed-zeros-fp-math"="false" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="generic" "unsafe-fp-math"="false" "use-soft-float"="false" }
attributes #2 = { nounwind readonly "correctly-rounded-divide-sqrt-fp-math"="false" "disable-tail-calls"="false" "frame-pointer"="none" "less-precise-fpmad"="false" "no-infs-fp-math"="false" "no-nans-fp-math"="false" "no-signed-zeros-fp-math"="false" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="generic" "unsafe-fp-math"="false" "use-soft-float"="false" }
attributes #3 = { argmemonly nounwind willreturn }
attributes #4 = { nounwind readnone speculatable willreturn }
attributes #5 = { nounwind readonly }

!llvm.module.flags = !{!0}
!llvm.ident = !{!1}

!0 = !{i32 1, !"wchar_size", i32 4}
!1 = !{!"clang version 11.0.0 (https://github.com/Jacarte/llvm-project.git 0f6dea67136cc1e0b3d200eb2bb165628970c44b)"}

; extracted candidates
#########################################################
; exiting Souper's runOnFunction() for printComplex()

; entering Souper's runOnFunction() for makeComplex()

; ModuleID = './Imaginary_base_numbers.c.bc'
source_filename = "./Imaginary_base_numbers.c"
target datalayout = "e-m:e-p:32:32-i64:64-n32:64-S128"
target triple = "wasm32-unknown-wasi"

%struct.Complex = type { double, double }
%struct.QuaterImaginary = type { i8*, i32 }

@.str = private unnamed_addr constant [17 x i8] c"(%3.0f + %3.0fi)\00", align 1
@TWO_I = hidden constant %struct.Complex { double 0.000000e+00, double 2.000000e+00 }, align 8
@INV_TWO_I = hidden constant %struct.Complex { double 0.000000e+00, double -5.000000e-01 }, align 8
@.str.1 = private unnamed_addr constant [4 x i8] c"%8s\00", align 1
@.str.2 = private unnamed_addr constant [9 x i8] c" ERROR  \00", align 1
@.str.3 = private unnamed_addr constant [2 x i8] c"0\00", align 1
@.str.4 = private unnamed_addr constant [5 x i8] c" -> \00", align 1
@.str.5 = private unnamed_addr constant [6 x i8] c"     \00", align 1
@.str.6 = private unnamed_addr constant [2 x i8] c"\0A\00", align 1
@llvm.used = appending global [1 x i8*] [i8* bitcast (i32 ()* @__main_void to i8*)], section "llvm.metadata"

@__main_void = alias i32 (), i32 ()* @main

; Function Attrs: noinline nounwind optnone
define hidden i32 @find(i8* %s, i8 signext %c) #0 {
entry:
  %retval = alloca i32, align 4
  %s.addr = alloca i8*, align 4
  %c.addr = alloca i8, align 1
  %i = alloca i8*, align 4
  store i8* %s, i8** %s.addr, align 4
  store i8 %c, i8* %c.addr, align 1
  %0 = load i8*, i8** %s.addr, align 4
  store i8* %0, i8** %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %1 = load i8*, i8** %i, align 4
  %2 = load i8, i8* %1, align 1
  %conv = sext i8 %2 to i32
  %cmp = icmp ne i32 %conv, 0
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %3 = load i8*, i8** %i, align 4
  %4 = load i8, i8* %3, align 1
  %conv2 = sext i8 %4 to i32
  %5 = load i8, i8* %c.addr, align 1
  %conv3 = sext i8 %5 to i32
  %cmp4 = icmp eq i32 %conv2, %conv3
  br i1 %cmp4, label %if.then, label %if.end

if.then:                                          ; preds = %for.body
  %6 = load i8*, i8** %i, align 4
  %7 = load i8*, i8** %s.addr, align 4
  %sub.ptr.lhs.cast = ptrtoint i8* %6 to i32
  %sub.ptr.rhs.cast = ptrtoint i8* %7 to i32
  %sub.ptr.sub = sub i32 %sub.ptr.lhs.cast, %sub.ptr.rhs.cast
  store i32 %sub.ptr.sub, i32* %retval, align 4
  br label %return

if.end:                                           ; preds = %for.body
  br label %for.inc

for.inc:                                          ; preds = %if.end
  %8 = load i8*, i8** %i, align 4
  %incdec.ptr = getelementptr inbounds i8, i8* %8, i32 1
  store i8* %incdec.ptr, i8** %i, align 4
  br label %for.cond

for.end:                                          ; preds = %for.cond
  store i32 -1, i32* %retval, align 4
  br label %return

return:                                           ; preds = %for.end, %if.then
  %9 = load i32, i32* %retval, align 4
  ret i32 %9
}

; Function Attrs: noinline nounwind optnone
define hidden void @reverse(i8* %b, i8* %e) #0 {
entry:
  %b.addr = alloca i8*, align 4
  %e.addr = alloca i8*, align 4
  %t = alloca i8, align 1
  store i8* %b, i8** %b.addr, align 4
  store i8* %e, i8** %e.addr, align 4
  %0 = load i8*, i8** %e.addr, align 4
  %incdec.ptr = getelementptr inbounds i8, i8* %0, i32 -1
  store i8* %incdec.ptr, i8** %e.addr, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %1 = load i8*, i8** %b.addr, align 4
  %2 = load i8*, i8** %e.addr, align 4
  %cmp = icmp ult i8* %1, %2
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %3 = load i8*, i8** %b.addr, align 4
  %4 = load i8, i8* %3, align 1
  store i8 %4, i8* %t, align 1
  %5 = load i8*, i8** %e.addr, align 4
  %6 = load i8, i8* %5, align 1
  %7 = load i8*, i8** %b.addr, align 4
  store i8 %6, i8* %7, align 1
  %8 = load i8, i8* %t, align 1
  %9 = load i8*, i8** %e.addr, align 4
  store i8 %8, i8* %9, align 1
  br label %for.inc

for.inc:                                          ; preds = %for.body
  %10 = load i8*, i8** %b.addr, align 4
  %incdec.ptr1 = getelementptr inbounds i8, i8* %10, i32 1
  store i8* %incdec.ptr1, i8** %b.addr, align 4
  %11 = load i8*, i8** %e.addr, align 4
  %incdec.ptr2 = getelementptr inbounds i8, i8* %11, i32 -1
  store i8* %incdec.ptr2, i8** %e.addr, align 4
  br label %for.cond

for.end:                                          ; preds = %for.cond
  ret void
}

; Function Attrs: noinline nounwind optnone
define hidden void @printComplex(%struct.Complex* byval(%struct.Complex) align 8 %c) #0 {
entry:
  %rel = getelementptr inbounds %struct.Complex, %struct.Complex* %c, i32 0, i32 0
  %0 = load double, double* %rel, align 8
  %img = getelementptr inbounds %struct.Complex, %struct.Complex* %c, i32 0, i32 1
  %1 = load double, double* %img, align 8
  %call = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([17 x i8], [17 x i8]* @.str, i32 0, i32 0), double %0, double %1)
  ret void
}

declare i32 @printf(i8* %0, ...) #1

; Function Attrs: noinline nounwind optnone
define hidden void @makeComplex(%struct.Complex* noalias sret align 8 %agg.result, double %rel, double %img) #0 {
entry:
  %rel.addr = alloca double, align 8
  %img.addr = alloca double, align 8
  store double %rel, double* %rel.addr, align 8
  store double %img, double* %img.addr, align 8
  %rel1 = getelementptr inbounds %struct.Complex, %struct.Complex* %agg.result, i32 0, i32 0
  %0 = load double, double* %rel.addr, align 8
  store double %0, double* %rel1, align 8
  %img2 = getelementptr inbounds %struct.Complex, %struct.Complex* %agg.result, i32 0, i32 1
  %1 = load double, double* %img.addr, align 8
  store double %1, double* %img2, align 8
  ret void
}

; Function Attrs: noinline nounwind optnone
define hidden void @addComplex(%struct.Complex* noalias sret align 8 %agg.result, %struct.Complex* byval(%struct.Complex) align 8 %a, %struct.Complex* byval(%struct.Complex) align 8 %b) #0 {
entry:
  %rel = getelementptr inbounds %struct.Complex, %struct.Complex* %agg.result, i32 0, i32 0
  %rel1 = getelementptr inbounds %struct.Complex, %struct.Complex* %a, i32 0, i32 0
  %0 = load double, double* %rel1, align 8
  %rel2 = getelementptr inbounds %struct.Complex, %struct.Complex* %b, i32 0, i32 0
  %1 = load double, double* %rel2, align 8
  %add = fadd double %0, %1
  store double %add, double* %rel, align 8
  %img = getelementptr inbounds %struct.Complex, %struct.Complex* %agg.result, i32 0, i32 1
  %img3 = getelementptr inbounds %struct.Complex, %struct.Complex* %a, i32 0, i32 1
  %2 = load double, double* %img3, align 8
  %img4 = getelementptr inbounds %struct.Complex, %struct.Complex* %b, i32 0, i32 1
  %3 = load double, double* %img4, align 8
  %add5 = fadd double %2, %3
  store double %add5, double* %img, align 8
  ret void
}

; Function Attrs: noinline nounwind optnone
define hidden void @mulComplex(%struct.Complex* noalias sret align 8 %agg.result, %struct.Complex* byval(%struct.Complex) align 8 %a, %struct.Complex* byval(%struct.Complex) align 8 %b) #0 {
entry:
  %rel = getelementptr inbounds %struct.Complex, %struct.Complex* %agg.result, i32 0, i32 0
  %rel1 = getelementptr inbounds %struct.Complex, %struct.Complex* %a, i32 0, i32 0
  %0 = load double, double* %rel1, align 8
  %rel2 = getelementptr inbounds %struct.Complex, %struct.Complex* %b, i32 0, i32 0
  %1 = load double, double* %rel2, align 8
  %mul = fmul double %0, %1
  %img = getelementptr inbounds %struct.Complex, %struct.Complex* %a, i32 0, i32 1
  %2 = load double, double* %img, align 8
  %img3 = getelementptr inbounds %struct.Complex, %struct.Complex* %b, i32 0, i32 1
  %3 = load double, double* %img3, align 8
  %mul4 = fmul double %2, %3
  %sub = fsub double %mul, %mul4
  store double %sub, double* %rel, align 8
  %img5 = getelementptr inbounds %struct.Complex, %struct.Complex* %agg.result, i32 0, i32 1
  %rel6 = getelementptr inbounds %struct.Complex, %struct.Complex* %a, i32 0, i32 0
  %4 = load double, double* %rel6, align 8
  %img7 = getelementptr inbounds %struct.Complex, %struct.Complex* %b, i32 0, i32 1
  %5 = load double, double* %img7, align 8
  %mul8 = fmul double %4, %5
  %img9 = getelementptr inbounds %struct.Complex, %struct.Complex* %a, i32 0, i32 1
  %6 = load double, double* %img9, align 8
  %rel10 = getelementptr inbounds %struct.Complex, %struct.Complex* %b, i32 0, i32 0
  %7 = load double, double* %rel10, align 8
  %mul11 = fmul double %6, %7
  %sub12 = fsub double %mul8, %mul11
  store double %sub12, double* %img5, align 8
  ret void
}

; Function Attrs: noinline nounwind optnone
define hidden void @mulComplexD(%struct.Complex* noalias sret align 8 %agg.result, %struct.Complex* byval(%struct.Complex) align 8 %a, double %b) #0 {
entry:
  %b.addr = alloca double, align 8
  store double %b, double* %b.addr, align 8
  %rel = getelementptr inbounds %struct.Complex, %struct.Complex* %agg.result, i32 0, i32 0
  %rel1 = getelementptr inbounds %struct.Complex, %struct.Complex* %a, i32 0, i32 0
  %0 = load double, double* %rel1, align 8
  %1 = load double, double* %b.addr, align 8
  %mul = fmul double %0, %1
  store double %mul, double* %rel, align 8
  %img = getelementptr inbounds %struct.Complex, %struct.Complex* %agg.result, i32 0, i32 1
  %img2 = getelementptr inbounds %struct.Complex, %struct.Complex* %a, i32 0, i32 1
  %2 = load double, double* %img2, align 8
  %3 = load double, double* %b.addr, align 8
  %mul3 = fmul double %2, %3
  store double %mul3, double* %img, align 8
  ret void
}

; Function Attrs: noinline nounwind optnone
define hidden void @negComplex(%struct.Complex* noalias sret align 8 %agg.result, %struct.Complex* byval(%struct.Complex) align 8 %a) #0 {
entry:
  call void @mulComplexD(%struct.Complex* sret align 8 %agg.result, %struct.Complex* byval(%struct.Complex) align 8 %a, double -1.000000e+00)
  ret void
}

; Function Attrs: noinline nounwind optnone
define hidden void @divComplex(%struct.Complex* noalias sret align 8 %agg.result, %struct.Complex* byval(%struct.Complex) align 8 %a, %struct.Complex* byval(%struct.Complex) align 8 %b) #0 {
entry:
  %re = alloca double, align 8
  %im = alloca double, align 8
  %d = alloca double, align 8
  %rel = getelementptr inbounds %struct.Complex, %struct.Complex* %a, i32 0, i32 0
  %0 = load double, double* %rel, align 8
  %rel1 = getelementptr inbounds %struct.Complex, %struct.Complex* %b, i32 0, i32 0
  %1 = load double, double* %rel1, align 8
  %mul = fmul double %0, %1
  %img = getelementptr inbounds %struct.Complex, %struct.Complex* %a, i32 0, i32 1
  %2 = load double, double* %img, align 8
  %img2 = getelementptr inbounds %struct.Complex, %struct.Complex* %b, i32 0, i32 1
  %3 = load double, double* %img2, align 8
  %mul3 = fmul double %2, %3
  %add = fadd double %mul, %mul3
  store double %add, double* %re, align 8
  %img4 = getelementptr inbounds %struct.Complex, %struct.Complex* %a, i32 0, i32 1
  %4 = load double, double* %img4, align 8
  %rel5 = getelementptr inbounds %struct.Complex, %struct.Complex* %b, i32 0, i32 0
  %5 = load double, double* %rel5, align 8
  %mul6 = fmul double %4, %5
  %rel7 = getelementptr inbounds %struct.Complex, %struct.Complex* %a, i32 0, i32 0
  %6 = load double, double* %rel7, align 8
  %img8 = getelementptr inbounds %struct.Complex, %struct.Complex* %b, i32 0, i32 1
  %7 = load double, double* %img8, align 8
  %mul9 = fmul double %6, %7
  %sub = fsub double %mul6, %mul9
  store double %sub, double* %im, align 8
  %rel10 = getelementptr inbounds %struct.Complex, %struct.Complex* %b, i32 0, i32 0
  %8 = load double, double* %rel10, align 8
  %rel11 = getelementptr inbounds %struct.Complex, %struct.Complex* %b, i32 0, i32 0
  %9 = load double, double* %rel11, align 8
  %mul12 = fmul double %8, %9
  %img13 = getelementptr inbounds %struct.Complex, %struct.Complex* %b, i32 0, i32 1
  %10 = load double, double* %img13, align 8
  %img14 = getelementptr inbounds %struct.Complex, %struct.Complex* %b, i32 0, i32 1
  %11 = load double, double* %img14, align 8
  %mul15 = fmul double %10, %11
  %add16 = fadd double %mul12, %mul15
  store double %add16, double* %d, align 8
  %rel17 = getelementptr inbounds %struct.Complex, %struct.Complex* %agg.result, i32 0, i32 0
  %12 = load double, double* %re, align 8
  %13 = load double, double* %d, align 8
  %div = fdiv double %12, %13
  store double %div, double* %rel17, align 8
  %img18 = getelementptr inbounds %struct.Complex, %struct.Complex* %agg.result, i32 0, i32 1
  %14 = load double, double* %im, align 8
  %15 = load double, double* %d, align 8
  %div19 = fdiv double %14, %15
  store double %div19, double* %img18, align 8
  ret void
}

; Function Attrs: noinline nounwind optnone
define hidden void @inv(%struct.Complex* noalias sret align 8 %agg.result, %struct.Complex* byval(%struct.Complex) align 8 %c) #0 {
entry:
  %d = alloca double, align 8
  %rel = getelementptr inbounds %struct.Complex, %struct.Complex* %c, i32 0, i32 0
  %0 = load double, double* %rel, align 8
  %rel1 = getelementptr inbounds %struct.Complex, %struct.Complex* %c, i32 0, i32 0
  %1 = load double, double* %rel1, align 8
  %mul = fmul double %0, %1
  %img = getelementptr inbounds %struct.Complex, %struct.Complex* %c, i32 0, i32 1
  %2 = load double, double* %img, align 8
  %img2 = getelementptr inbounds %struct.Complex, %struct.Complex* %c, i32 0, i32 1
  %3 = load double, double* %img2, align 8
  %mul3 = fmul double %2, %3
  %add = fadd double %mul, %mul3
  store double %add, double* %d, align 8
  %rel4 = getelementptr inbounds %struct.Complex, %struct.Complex* %agg.result, i32 0, i32 0
  %rel5 = getelementptr inbounds %struct.Complex, %struct.Complex* %c, i32 0, i32 0
  %4 = load double, double* %rel5, align 8
  %5 = load double, double* %d, align 8
  %div = fdiv double %4, %5
  store double %div, double* %rel4, align 8
  %img6 = getelementptr inbounds %struct.Complex, %struct.Complex* %agg.result, i32 0, i32 1
  %img7 = getelementptr inbounds %struct.Complex, %struct.Complex* %c, i32 0, i32 1
  %6 = load double, double* %img7, align 8
  %fneg = fneg double %6
  %7 = load double, double* %d, align 8
  %div8 = fdiv double %fneg, %7
  store double %div8, double* %img6, align 8
  ret void
}

; Function Attrs: noinline nounwind optnone
define hidden void @makeQuaterImaginary(%struct.QuaterImaginary* noalias sret align 4 %agg.result, i8* %s) #0 {
entry:
  %s.addr = alloca i8*, align 4
  %i = alloca i32, align 4
  %valid1 = alloca i32, align 4
  %cnt = alloca i32, align 4
  store i8* %s, i8** %s.addr, align 4
  %b2i = getelementptr inbounds %struct.QuaterImaginary, %struct.QuaterImaginary* %agg.result, i32 0, i32 0
  %0 = load i8*, i8** %s.addr, align 4
  store i8* %0, i8** %b2i, align 4
  %valid = getelementptr inbounds %struct.QuaterImaginary, %struct.QuaterImaginary* %agg.result, i32 0, i32 1
  store i32 0, i32* %valid, align 4
  store i32 1, i32* %valid1, align 4
  store i32 0, i32* %cnt, align 4
  %1 = load i8*, i8** %s.addr, align 4
  %2 = load i8, i8* %1, align 1
  %conv = sext i8 %2 to i32
  %cmp = icmp ne i32 %conv, 0
  br i1 %cmp, label %if.then, label %if.end26

if.then:                                          ; preds = %entry
  store i32 0, i32* %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.then
  %3 = load i8*, i8** %s.addr, align 4
  %4 = load i32, i32* %i, align 4
  %arrayidx = getelementptr inbounds i8, i8* %3, i32 %4
  %5 = load i8, i8* %arrayidx, align 1
  %conv3 = sext i8 %5 to i32
  %cmp4 = icmp ne i32 %conv3, 0
  br i1 %cmp4, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %6 = load i8*, i8** %s.addr, align 4
  %7 = load i32, i32* %i, align 4
  %arrayidx6 = getelementptr inbounds i8, i8* %6, i32 %7
  %8 = load i8, i8* %arrayidx6, align 1
  %conv7 = sext i8 %8 to i32
  %cmp8 = icmp slt i32 %conv7, 48
  br i1 %cmp8, label %if.then14, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %for.body
  %9 = load i8*, i8** %s.addr, align 4
  %10 = load i32, i32* %i, align 4
  %arrayidx10 = getelementptr inbounds i8, i8* %9, i32 %10
  %11 = load i8, i8* %arrayidx10, align 1
  %conv11 = sext i8 %11 to i32
  %cmp12 = icmp slt i32 51, %conv11
  br i1 %cmp12, label %if.then14, label %if.end20

if.then14:                                        ; preds = %lor.lhs.false, %for.body
  %12 = load i8*, i8** %s.addr, align 4
  %13 = load i32, i32* %i, align 4
  %arrayidx15 = getelementptr inbounds i8, i8* %12, i32 %13
  %14 = load i8, i8* %arrayidx15, align 1
  %conv16 = sext i8 %14 to i32
  %cmp17 = icmp eq i32 %conv16, 46
  br i1 %cmp17, label %if.then19, label %if.else

if.then19:                                        ; preds = %if.then14
  %15 = load i32, i32* %cnt, align 4
  %inc = add i32 %15, 1
  store i32 %inc, i32* %cnt, align 4
  br label %if.end

if.else:                                          ; preds = %if.then14
  store i32 0, i32* %valid1, align 4
  br label %for.end

if.end:                                           ; preds = %if.then19
  br label %if.end20

if.end20:                                         ; preds = %if.end, %lor.lhs.false
  br label %for.inc

for.inc:                                          ; preds = %if.end20
  %16 = load i32, i32* %i, align 4
  %inc21 = add i32 %16, 1
  store i32 %inc21, i32* %i, align 4
  br label %for.cond

for.end:                                          ; preds = %if.else, %for.cond
  %17 = load i32, i32* %valid1, align 4
  %tobool = icmp ne i32 %17, 0
  br i1 %tobool, label %land.lhs.true, label %if.end25

land.lhs.true:                                    ; preds = %for.end
  %18 = load i32, i32* %cnt, align 4
  %cmp22 = icmp ugt i32 %18, 1
  br i1 %cmp22, label %if.then24, label %if.end25

if.then24:                                        ; preds = %land.lhs.true
  store i32 0, i32* %valid1, align 4
  br label %if.end25

if.end25:                                         ; preds = %if.then24, %land.lhs.true, %for.end
  br label %if.end26

if.end26:                                         ; preds = %if.end25, %entry
  %19 = load i32, i32* %valid1, align 4
  %valid27 = getelementptr inbounds %struct.QuaterImaginary, %struct.QuaterImaginary* %agg.result, i32 0, i32 1
  store i32 %19, i32* %valid27, align 4
  ret void
}

; Function Attrs: noinline nounwind optnone
define hidden void @printQuaterImaginary(%struct.QuaterImaginary* byval(%struct.QuaterImaginary) align 4 %qi) #0 {
entry:
  %valid = getelementptr inbounds %struct.QuaterImaginary, %struct.QuaterImaginary* %qi, i32 0, i32 1
  %0 = load i32, i32* %valid, align 4
  %tobool = icmp ne i32 %0, 0
  br i1 %tobool, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  %b2i = getelementptr inbounds %struct.QuaterImaginary, %struct.QuaterImaginary* %qi, i32 0, i32 0
  %1 = load i8*, i8** %b2i, align 4
  %call = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([4 x i8], [4 x i8]* @.str.1, i32 0, i32 0), i8* %1)
  br label %if.end

if.else:                                          ; preds = %entry
  %call1 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([9 x i8], [9 x i8]* @.str.2, i32 0, i32 0))
  br label %if.end

if.end:                                           ; preds = %if.else, %if.then
  ret void
}

; Function Attrs: noinline nounwind optnone
define hidden void @qi2c(%struct.Complex* noalias sret align 8 %agg.result, %struct.QuaterImaginary* byval(%struct.QuaterImaginary) align 4 %qi) #0 {
entry:
  %len = alloca i32, align 4
  %pointPos = alloca i32, align 4
  %posLen = alloca i32, align 4
  %prod = alloca %struct.Complex, align 8
  %j = alloca i32, align 4
  %k = alloca double, align 8
  %tmp = alloca %struct.Complex, align 8
  %agg.tmp = alloca %struct.Complex, align 8
  %tmp10 = alloca %struct.Complex, align 8
  %k18 = alloca double, align 8
  %tmp27 = alloca %struct.Complex, align 8
  %agg.tmp28 = alloca %struct.Complex, align 8
  %tmp30 = alloca %struct.Complex, align 8
  %b2i = getelementptr inbounds %struct.QuaterImaginary, %struct.QuaterImaginary* %qi, i32 0, i32 0
  %0 = load i8*, i8** %b2i, align 4
  %call = call i32 @strlen(i8* %0) #5
  store i32 %call, i32* %len, align 4
  %b2i1 = getelementptr inbounds %struct.QuaterImaginary, %struct.QuaterImaginary* %qi, i32 0, i32 0
  %1 = load i8*, i8** %b2i1, align 4
  %call2 = call i32 @find(i8* %1, i8 signext 46)
  store i32 %call2, i32* %pointPos, align 4
  %2 = load i32, i32* %pointPos, align 4
  %cmp = icmp sgt i32 %2, 0
  br i1 %cmp, label %cond.true, label %cond.false

cond.true:                                        ; preds = %entry
  %3 = load i32, i32* %pointPos, align 4
  br label %cond.end

cond.false:                                       ; preds = %entry
  %4 = load i32, i32* %len, align 4
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi i32 [ %3, %cond.true ], [ %4, %cond.false ]
  store i32 %cond, i32* %posLen, align 4
  call void @makeComplex(%struct.Complex* sret align 8 %agg.result, double 0.000000e+00, double 0.000000e+00)
  call void @makeComplex(%struct.Complex* sret align 8 %prod, double 1.000000e+00, double 0.000000e+00)
  store i32 0, i32* %j, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %cond.end
  %5 = load i32, i32* %j, align 4
  %6 = load i32, i32* %posLen, align 4
  %cmp3 = icmp ult i32 %5, %6
  br i1 %cmp3, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %b2i4 = getelementptr inbounds %struct.QuaterImaginary, %struct.QuaterImaginary* %qi, i32 0, i32 0
  %7 = load i8*, i8** %b2i4, align 4
  %8 = load i32, i32* %posLen, align 4
  %sub = sub i32 %8, 1
  %9 = load i32, i32* %j, align 4
  %sub5 = sub i32 %sub, %9
  %arrayidx = getelementptr inbounds i8, i8* %7, i32 %sub5
  %10 = load i8, i8* %arrayidx, align 1
  %conv = sext i8 %10 to i32
  %sub6 = sub nsw i32 %conv, 48
  %conv7 = sitofp i32 %sub6 to double
  store double %conv7, double* %k, align 8
  %11 = load double, double* %k, align 8
  %cmp8 = fcmp ogt double %11, 0.000000e+00
  br i1 %cmp8, label %if.then, label %if.end

if.then:                                          ; preds = %for.body
  %12 = load double, double* %k, align 8
  call void @mulComplexD(%struct.Complex* sret align 8 %agg.tmp, %struct.Complex* byval(%struct.Complex) align 8 %prod, double %12)
  call void @addComplex(%struct.Complex* sret align 8 %tmp, %struct.Complex* byval(%struct.Complex) align 8 %agg.result, %struct.Complex* byval(%struct.Complex) align 8 %agg.tmp)
  %13 = bitcast %struct.Complex* %agg.result to i8*
  %14 = bitcast %struct.Complex* %tmp to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 8 %13, i8* align 8 %14, i32 16, i1 false)
  br label %if.end

if.end:                                           ; preds = %if.then, %for.body
  call void @mulComplex(%struct.Complex* sret align 8 %tmp10, %struct.Complex* byval(%struct.Complex) align 8 %prod, %struct.Complex* byval(%struct.Complex) align 8 @TWO_I)
  %15 = bitcast %struct.Complex* %prod to i8*
  %16 = bitcast %struct.Complex* %tmp10 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 8 %15, i8* align 8 %16, i32 16, i1 false)
  br label %for.inc

for.inc:                                          ; preds = %if.end
  %17 = load i32, i32* %j, align 4
  %inc = add i32 %17, 1
  store i32 %inc, i32* %j, align 4
  br label %for.cond

for.end:                                          ; preds = %for.cond
  %18 = load i32, i32* %pointPos, align 4
  %cmp11 = icmp ne i32 %18, -1
  br i1 %cmp11, label %if.then13, label %if.end34

if.then13:                                        ; preds = %for.end
  %19 = bitcast %struct.Complex* %prod to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 8 %19, i8* align 8 bitcast (%struct.Complex* @INV_TWO_I to i8*), i32 16, i1 false)
  %20 = load i32, i32* %posLen, align 4
  %add = add i32 %20, 1
  store i32 %add, i32* %j, align 4
  br label %for.cond14

for.cond14:                                       ; preds = %for.inc31, %if.then13
  %21 = load i32, i32* %j, align 4
  %22 = load i32, i32* %len, align 4
  %cmp15 = icmp ult i32 %21, %22
  br i1 %cmp15, label %for.body17, label %for.end33

for.body17:                                       ; preds = %for.cond14
  %b2i19 = getelementptr inbounds %struct.QuaterImaginary, %struct.QuaterImaginary* %qi, i32 0, i32 0
  %23 = load i8*, i8** %b2i19, align 4
  %24 = load i32, i32* %j, align 4
  %arrayidx20 = getelementptr inbounds i8, i8* %23, i32 %24
  %25 = load i8, i8* %arrayidx20, align 1
  %conv21 = sext i8 %25 to i32
  %sub22 = sub nsw i32 %conv21, 48
  %conv23 = sitofp i32 %sub22 to double
  store double %conv23, double* %k18, align 8
  %26 = load double, double* %k18, align 8
  %cmp24 = fcmp ogt double %26, 0.000000e+00
  br i1 %cmp24, label %if.then26, label %if.end29

if.then26:                                        ; preds = %for.body17
  %27 = load double, double* %k18, align 8
  call void @mulComplexD(%struct.Complex* sret align 8 %agg.tmp28, %struct.Complex* byval(%struct.Complex) align 8 %prod, double %27)
  call void @addComplex(%struct.Complex* sret align 8 %tmp27, %struct.Complex* byval(%struct.Complex) align 8 %agg.result, %struct.Complex* byval(%struct.Complex) align 8 %agg.tmp28)
  %28 = bitcast %struct.Complex* %agg.result to i8*
  %29 = bitcast %struct.Complex* %tmp27 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 8 %28, i8* align 8 %29, i32 16, i1 false)
  br label %if.end29

if.end29:                                         ; preds = %if.then26, %for.body17
  call void @mulComplex(%struct.Complex* sret align 8 %tmp30, %struct.Complex* byval(%struct.Complex) align 8 %prod, %struct.Complex* byval(%struct.Complex) align 8 @INV_TWO_I)
  %30 = bitcast %struct.Complex* %prod to i8*
  %31 = bitcast %struct.Complex* %tmp30 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 8 %30, i8* align 8 %31, i32 16, i1 false)
  br label %for.inc31

for.inc31:                                        ; preds = %if.end29
  %32 = load i32, i32* %j, align 4
  %inc32 = add i32 %32, 1
  store i32 %inc32, i32* %j, align 4
  br label %for.cond14

for.end33:                                        ; preds = %for.cond14
  br label %if.end34

if.end34:                                         ; preds = %for.end33, %for.end
  ret void
}

; Function Attrs: nounwind readonly
declare i32 @strlen(i8* %0) #2

; Function Attrs: argmemonly nounwind willreturn
declare void @llvm.memcpy.p0i8.p0i8.i32(i8* noalias nocapture writeonly %0, i8* noalias nocapture readonly %1, i32 %2, i1 immarg %3) #3

; Function Attrs: noinline nounwind optnone
define hidden void @c2qi(%struct.QuaterImaginary* noalias sret align 4 %agg.result, %struct.Complex* byval(%struct.Complex) align 8 %c, i8* %out) #0 {
entry:
  %out.addr = alloca i8*, align 4
  %p = alloca i8*, align 4
  %re = alloca i32, align 4
  %im = alloca i32, align 4
  %fi = alloca i32, align 4
  %rem = alloca i32, align 4
  %index = alloca i32, align 4
  %fc = alloca %struct.Complex, align 8
  %.compoundliteral = alloca %struct.Complex, align 8
  %.compoundliteral21 = alloca %struct.Complex, align 8
  %f = alloca double, align 8
  %rem31 = alloca i32, align 4
  %i = alloca i32, align 4
  store i8* %out, i8** %out.addr, align 4
  %0 = load i8*, i8** %out.addr, align 4
  store i8* %0, i8** %p, align 4
  %1 = load i8*, i8** %p, align 4
  store i8 0, i8* %1, align 1
  %rel = getelementptr inbounds %struct.Complex, %struct.Complex* %c, i32 0, i32 0
  %2 = load double, double* %rel, align 8
  %cmp = fcmp oeq double %2, 0.000000e+00
  br i1 %cmp, label %land.lhs.true, label %if.end

land.lhs.true:                                    ; preds = %entry
  %img = getelementptr inbounds %struct.Complex, %struct.Complex* %c, i32 0, i32 1
  %3 = load double, double* %img, align 8
  %cmp1 = fcmp oeq double %3, 0.000000e+00
  br i1 %cmp1, label %if.then, label %if.end

if.then:                                          ; preds = %land.lhs.true
  call void @makeQuaterImaginary(%struct.QuaterImaginary* sret align 4 %agg.result, i8* getelementptr inbounds ([2 x i8], [2 x i8]* @.str.3, i32 0, i32 0))
  br label %return

if.end:                                           ; preds = %land.lhs.true, %entry
  %rel2 = getelementptr inbounds %struct.Complex, %struct.Complex* %c, i32 0, i32 0
  %4 = load double, double* %rel2, align 8
  %conv = fptosi double %4 to i32
  store i32 %conv, i32* %re, align 4
  %img3 = getelementptr inbounds %struct.Complex, %struct.Complex* %c, i32 0, i32 1
  %5 = load double, double* %img3, align 8
  %conv4 = fptosi double %5 to i32
  store i32 %conv4, i32* %im, align 4
  store i32 -1, i32* %fi, align 4
  br label %while.cond

while.cond:                                       ; preds = %if.end11, %if.end
  %6 = load i32, i32* %re, align 4
  %cmp5 = icmp ne i32 %6, 0
  br i1 %cmp5, label %while.body, label %while.end

while.body:                                       ; preds = %while.cond
  %7 = load i32, i32* %re, align 4
  %rem7 = srem i32 %7, -4
  store i32 %rem7, i32* %rem, align 4
  %8 = load i32, i32* %re, align 4
  %div = sdiv i32 %8, -4
  store i32 %div, i32* %re, align 4
  %9 = load i32, i32* %rem, align 4
  %cmp8 = icmp slt i32 %9, 0
  br i1 %cmp8, label %if.then10, label %if.end11

if.then10:                                        ; preds = %while.body
  %10 = load i32, i32* %rem, align 4
  %add = add nsw i32 %10, 4
  store i32 %add, i32* %rem, align 4
  %11 = load i32, i32* %re, align 4
  %inc = add nsw i32 %11, 1
  store i32 %inc, i32* %re, align 4
  br label %if.end11

if.end11:                                         ; preds = %if.then10, %while.body
  %12 = load i32, i32* %rem, align 4
  %add12 = add nsw i32 %12, 48
  %conv13 = trunc i32 %add12 to i8
  %13 = load i8*, i8** %p, align 4
  %incdec.ptr = getelementptr inbounds i8, i8* %13, i32 1
  store i8* %incdec.ptr, i8** %p, align 4
  store i8 %conv13, i8* %13, align 1
  %14 = load i8*, i8** %p, align 4
  %incdec.ptr14 = getelementptr inbounds i8, i8* %14, i32 1
  store i8* %incdec.ptr14, i8** %p, align 4
  store i8 48, i8* %14, align 1
  %15 = load i8*, i8** %p, align 4
  store i8 0, i8* %15, align 1
  br label %while.cond

while.end:                                        ; preds = %while.cond
  %16 = load i32, i32* %im, align 4
  %cmp15 = icmp ne i32 %16, 0
  br i1 %cmp15, label %if.then17, label %if.end53

if.then17:                                        ; preds = %while.end
  store i32 1, i32* %index, align 4
  %rel18 = getelementptr inbounds %struct.Complex, %struct.Complex* %.compoundliteral, i32 0, i32 0
  store double 0.000000e+00, double* %rel18, align 8
  %img19 = getelementptr inbounds %struct.Complex, %struct.Complex* %.compoundliteral, i32 0, i32 1
  %img20 = getelementptr inbounds %struct.Complex, %struct.Complex* %c, i32 0, i32 1
  %17 = load double, double* %img20, align 8
  store double %17, double* %img19, align 8
  %rel22 = getelementptr inbounds %struct.Complex, %struct.Complex* %.compoundliteral21, i32 0, i32 0
  store double 0.000000e+00, double* %rel22, align 8
  %img23 = getelementptr inbounds %struct.Complex, %struct.Complex* %.compoundliteral21, i32 0, i32 1
  store double 2.000000e+00, double* %img23, align 8
  call void @divComplex(%struct.Complex* sret align 8 %fc, %struct.Complex* byval(%struct.Complex) align 8 %.compoundliteral, %struct.Complex* byval(%struct.Complex) align 8 %.compoundliteral21)
  %rel24 = getelementptr inbounds %struct.Complex, %struct.Complex* %fc, i32 0, i32 0
  %18 = load double, double* %rel24, align 8
  store double %18, double* %f, align 8
  %19 = load double, double* %f, align 8
  %20 = call double @llvm.ceil.f64(double %19)
  %conv25 = fptosi double %20 to i32
  store i32 %conv25, i32* %im, align 4
  %21 = load double, double* %f, align 8
  %22 = load i32, i32* %im, align 4
  %conv26 = sitofp i32 %22 to double
  %sub = fsub double %21, %conv26
  %mul = fmul double -4.000000e+00, %sub
  store double %mul, double* %f, align 8
  br label %while.cond27

while.cond27:                                     ; preds = %if.end49, %if.then17
  %23 = load i32, i32* %im, align 4
  %cmp28 = icmp ne i32 %23, 0
  br i1 %cmp28, label %while.body30, label %while.end51

while.body30:                                     ; preds = %while.cond27
  %24 = load i32, i32* %im, align 4
  %rem32 = srem i32 %24, -4
  store i32 %rem32, i32* %rem31, align 4
  %25 = load i32, i32* %im, align 4
  %div33 = sdiv i32 %25, -4
  store i32 %div33, i32* %im, align 4
  %26 = load i32, i32* %rem31, align 4
  %cmp34 = icmp slt i32 %26, 0
  br i1 %cmp34, label %if.then36, label %if.end39

if.then36:                                        ; preds = %while.body30
  %27 = load i32, i32* %rem31, align 4
  %add37 = add nsw i32 %27, 4
  store i32 %add37, i32* %rem31, align 4
  %28 = load i32, i32* %im, align 4
  %inc38 = add nsw i32 %28, 1
  store i32 %inc38, i32* %im, align 4
  br label %if.end39

if.end39:                                         ; preds = %if.then36, %while.body30
  %29 = load i32, i32* %index, align 4
  %30 = load i8*, i8** %p, align 4
  %31 = load i8*, i8** %out.addr, align 4
  %sub.ptr.lhs.cast = ptrtoint i8* %30 to i32
  %sub.ptr.rhs.cast = ptrtoint i8* %31 to i32
  %sub.ptr.sub = sub i32 %sub.ptr.lhs.cast, %sub.ptr.rhs.cast
  %cmp40 = icmp ult i32 %29, %sub.ptr.sub
  br i1 %cmp40, label %if.then42, label %if.else

if.then42:                                        ; preds = %if.end39
  %32 = load i32, i32* %rem31, align 4
  %add43 = add nsw i32 %32, 48
  %conv44 = trunc i32 %add43 to i8
  %33 = load i8*, i8** %out.addr, align 4
  %34 = load i32, i32* %index, align 4
  %arrayidx = getelementptr inbounds i8, i8* %33, i32 %34
  store i8 %conv44, i8* %arrayidx, align 1
  br label %if.end49

if.else:                                          ; preds = %if.end39
  %35 = load i8*, i8** %p, align 4
  %incdec.ptr45 = getelementptr inbounds i8, i8* %35, i32 1
  store i8* %incdec.ptr45, i8** %p, align 4
  store i8 48, i8* %35, align 1
  %36 = load i32, i32* %rem31, align 4
  %add46 = add nsw i32 %36, 48
  %conv47 = trunc i32 %add46 to i8
  %37 = load i8*, i8** %p, align 4
  %incdec.ptr48 = getelementptr inbounds i8, i8* %37, i32 1
  store i8* %incdec.ptr48, i8** %p, align 4
  store i8 %conv47, i8* %37, align 1
  %38 = load i8*, i8** %p, align 4
  store i8 0, i8* %38, align 1
  br label %if.end49

if.end49:                                         ; preds = %if.else, %if.then42
  %39 = load i32, i32* %index, align 4
  %add50 = add i32 %39, 2
  store i32 %add50, i32* %index, align 4
  br label %while.cond27

while.end51:                                      ; preds = %while.cond27
  %40 = load double, double* %f, align 8
  %conv52 = fptosi double %40 to i32
  store i32 %conv52, i32* %fi, align 4
  br label %if.end53

if.end53:                                         ; preds = %while.end51, %while.end
  %41 = load i8*, i8** %out.addr, align 4
  %42 = load i8*, i8** %p, align 4
  call void @reverse(i8* %41, i8* %42)
  %43 = load i32, i32* %fi, align 4
  %cmp54 = icmp ne i32 %43, -1
  br i1 %cmp54, label %if.then56, label %if.end61

if.then56:                                        ; preds = %if.end53
  %44 = load i8*, i8** %p, align 4
  %incdec.ptr57 = getelementptr inbounds i8, i8* %44, i32 1
  store i8* %incdec.ptr57, i8** %p, align 4
  store i8 46, i8* %44, align 1
  %45 = load i32, i32* %fi, align 4
  %add58 = add nsw i32 %45, 48
  %conv59 = trunc i32 %add58 to i8
  %46 = load i8*, i8** %p, align 4
  %incdec.ptr60 = getelementptr inbounds i8, i8* %46, i32 1
  store i8* %incdec.ptr60, i8** %p, align 4
  store i8 %conv59, i8* %46, align 1
  %47 = load i8*, i8** %p, align 4
  store i8 0, i8* %47, align 1
  br label %if.end61

if.end61:                                         ; preds = %if.then56, %if.end53
  br label %while.cond62

while.cond62:                                     ; preds = %for.end, %if.end61
  %48 = load i8*, i8** %out.addr, align 4
  %arrayidx63 = getelementptr inbounds i8, i8* %48, i32 0
  %49 = load i8, i8* %arrayidx63, align 1
  %conv64 = sext i8 %49 to i32
  %cmp65 = icmp eq i32 %conv64, 48
  br i1 %cmp65, label %land.rhs, label %land.end

land.rhs:                                         ; preds = %while.cond62
  %50 = load i8*, i8** %out.addr, align 4
  %arrayidx67 = getelementptr inbounds i8, i8* %50, i32 1
  %51 = load i8, i8* %arrayidx67, align 1
  %conv68 = sext i8 %51 to i32
  %cmp69 = icmp ne i32 %conv68, 46
  br label %land.end

land.end:                                         ; preds = %land.rhs, %while.cond62
  %52 = phi i1 [ false, %while.cond62 ], [ %cmp69, %land.rhs ]
  br i1 %52, label %while.body71, label %while.end80

while.body71:                                     ; preds = %land.end
  store i32 0, i32* %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %while.body71
  %53 = load i8*, i8** %out.addr, align 4
  %54 = load i32, i32* %i, align 4
  %arrayidx72 = getelementptr inbounds i8, i8* %53, i32 %54
  %55 = load i8, i8* %arrayidx72, align 1
  %conv73 = sext i8 %55 to i32
  %cmp74 = icmp ne i32 %conv73, 0
  br i1 %cmp74, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %56 = load i8*, i8** %out.addr, align 4
  %57 = load i32, i32* %i, align 4
  %add76 = add i32 %57, 1
  %arrayidx77 = getelementptr inbounds i8, i8* %56, i32 %add76
  %58 = load i8, i8* %arrayidx77, align 1
  %59 = load i8*, i8** %out.addr, align 4
  %60 = load i32, i32* %i, align 4
  %arrayidx78 = getelementptr inbounds i8, i8* %59, i32 %60
  store i8 %58, i8* %arrayidx78, align 1
  br label %for.inc

for.inc:                                          ; preds = %for.body
  %61 = load i32, i32* %i, align 4
  %inc79 = add i32 %61, 1
  store i32 %inc79, i32* %i, align 4
  br label %for.cond

for.end:                                          ; preds = %for.cond
  br label %while.cond62

while.end80:                                      ; preds = %land.end
  %62 = load i8*, i8** %out.addr, align 4
  %63 = load i8, i8* %62, align 1
  %conv81 = sext i8 %63 to i32
  %cmp82 = icmp eq i32 %conv81, 46
  br i1 %cmp82, label %if.then84, label %if.end86

if.then84:                                        ; preds = %while.end80
  %64 = load i8*, i8** %out.addr, align 4
  %65 = load i8*, i8** %p, align 4
  call void @reverse(i8* %64, i8* %65)
  %66 = load i8*, i8** %p, align 4
  %incdec.ptr85 = getelementptr inbounds i8, i8* %66, i32 1
  store i8* %incdec.ptr85, i8** %p, align 4
  store i8 48, i8* %66, align 1
  %67 = load i8*, i8** %p, align 4
  store i8 0, i8* %67, align 1
  %68 = load i8*, i8** %out.addr, align 4
  %69 = load i8*, i8** %p, align 4
  call void @reverse(i8* %68, i8* %69)
  br label %if.end86

if.end86:                                         ; preds = %if.then84, %while.end80
  %70 = load i8*, i8** %out.addr, align 4
  call void @makeQuaterImaginary(%struct.QuaterImaginary* sret align 4 %agg.result, i8* %70)
  br label %return

return:                                           ; preds = %if.end86, %if.then
  ret void
}

; Function Attrs: nounwind readnone speculatable willreturn
declare double @llvm.ceil.f64(double %0) #4

; Function Attrs: noinline nounwind optnone
define hidden i32 @main() #0 {
entry:
  %retval = alloca i32, align 4
  %buffer = alloca [16 x i8], align 16
  %i = alloca i32, align 4
  %c1 = alloca %struct.Complex, align 8
  %qi = alloca %struct.QuaterImaginary, align 4
  %c2 = alloca %struct.Complex, align 8
  %tmp = alloca %struct.Complex, align 8
  %tmp3 = alloca %struct.QuaterImaginary, align 4
  %tmp5 = alloca %struct.Complex, align 8
  %c114 = alloca %struct.Complex, align 8
  %qi18 = alloca %struct.QuaterImaginary, align 4
  %c220 = alloca %struct.Complex, align 8
  %tmp24 = alloca %struct.Complex, align 8
  %tmp25 = alloca %struct.QuaterImaginary, align 4
  %tmp27 = alloca %struct.Complex, align 8
  store i32 0, i32* %retval, align 4
  store i32 1, i32* %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %0 = load i32, i32* %i, align 4
  %cmp = icmp sle i32 %0, 16
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %rel = getelementptr inbounds %struct.Complex, %struct.Complex* %c1, i32 0, i32 0
  %1 = load i32, i32* %i, align 4
  %conv = sitofp i32 %1 to double
  store double %conv, double* %rel, align 8
  %img = getelementptr inbounds %struct.Complex, %struct.Complex* %c1, i32 0, i32 1
  store double 0.000000e+00, double* %img, align 8
  %arraydecay = getelementptr inbounds [16 x i8], [16 x i8]* %buffer, i32 0, i32 0
  call void @c2qi(%struct.QuaterImaginary* sret align 4 %qi, %struct.Complex* byval(%struct.Complex) align 8 %c1, i8* %arraydecay)
  call void @qi2c(%struct.Complex* sret align 8 %c2, %struct.QuaterImaginary* byval(%struct.QuaterImaginary) align 4 %qi)
  call void @printComplex(%struct.Complex* byval(%struct.Complex) align 8 %c1)
  %call = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.4, i32 0, i32 0))
  call void @printQuaterImaginary(%struct.QuaterImaginary* byval(%struct.QuaterImaginary) align 4 %qi)
  %call1 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.4, i32 0, i32 0))
  call void @printComplex(%struct.Complex* byval(%struct.Complex) align 8 %c2)
  %call2 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([6 x i8], [6 x i8]* @.str.5, i32 0, i32 0))
  call void @negComplex(%struct.Complex* sret align 8 %tmp, %struct.Complex* byval(%struct.Complex) align 8 %c1)
  %2 = bitcast %struct.Complex* %c1 to i8*
  %3 = bitcast %struct.Complex* %tmp to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 8 %2, i8* align 8 %3, i32 16, i1 false)
  %arraydecay4 = getelementptr inbounds [16 x i8], [16 x i8]* %buffer, i32 0, i32 0
  call void @c2qi(%struct.QuaterImaginary* sret align 4 %tmp3, %struct.Complex* byval(%struct.Complex) align 8 %c1, i8* %arraydecay4)
  %4 = bitcast %struct.QuaterImaginary* %qi to i8*
  %5 = bitcast %struct.QuaterImaginary* %tmp3 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 4 %4, i8* align 4 %5, i32 8, i1 false)
  call void @qi2c(%struct.Complex* sret align 8 %tmp5, %struct.QuaterImaginary* byval(%struct.QuaterImaginary) align 4 %qi)
  %6 = bitcast %struct.Complex* %c2 to i8*
  %7 = bitcast %struct.Complex* %tmp5 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 8 %6, i8* align 8 %7, i32 16, i1 false)
  call void @printComplex(%struct.Complex* byval(%struct.Complex) align 8 %c1)
  %call6 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.4, i32 0, i32 0))
  call void @printQuaterImaginary(%struct.QuaterImaginary* byval(%struct.QuaterImaginary) align 4 %qi)
  %call7 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.4, i32 0, i32 0))
  call void @printComplex(%struct.Complex* byval(%struct.Complex) align 8 %c2)
  %call8 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([2 x i8], [2 x i8]* @.str.6, i32 0, i32 0))
  br label %for.inc

for.inc:                                          ; preds = %for.body
  %8 = load i32, i32* %i, align 4
  %inc = add nsw i32 %8, 1
  store i32 %inc, i32* %i, align 4
  br label %for.cond

for.end:                                          ; preds = %for.cond
  %call9 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([2 x i8], [2 x i8]* @.str.6, i32 0, i32 0))
  store i32 1, i32* %i, align 4
  br label %for.cond10

for.cond10:                                       ; preds = %for.inc31, %for.end
  %9 = load i32, i32* %i, align 4
  %cmp11 = icmp sle i32 %9, 16
  br i1 %cmp11, label %for.body13, label %for.end33

for.body13:                                       ; preds = %for.cond10
  %rel15 = getelementptr inbounds %struct.Complex, %struct.Complex* %c114, i32 0, i32 0
  store double 0.000000e+00, double* %rel15, align 8
  %img16 = getelementptr inbounds %struct.Complex, %struct.Complex* %c114, i32 0, i32 1
  %10 = load i32, i32* %i, align 4
  %conv17 = sitofp i32 %10 to double
  store double %conv17, double* %img16, align 8
  %arraydecay19 = getelementptr inbounds [16 x i8], [16 x i8]* %buffer, i32 0, i32 0
  call void @c2qi(%struct.QuaterImaginary* sret align 4 %qi18, %struct.Complex* byval(%struct.Complex) align 8 %c114, i8* %arraydecay19)
  call void @qi2c(%struct.Complex* sret align 8 %c220, %struct.QuaterImaginary* byval(%struct.QuaterImaginary) align 4 %qi18)
  call void @printComplex(%struct.Complex* byval(%struct.Complex) align 8 %c114)
  %call21 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.4, i32 0, i32 0))
  call void @printQuaterImaginary(%struct.QuaterImaginary* byval(%struct.QuaterImaginary) align 4 %qi18)
  %call22 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.4, i32 0, i32 0))
  call void @printComplex(%struct.Complex* byval(%struct.Complex) align 8 %c220)
  %call23 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([6 x i8], [6 x i8]* @.str.5, i32 0, i32 0))
  call void @negComplex(%struct.Complex* sret align 8 %tmp24, %struct.Complex* byval(%struct.Complex) align 8 %c114)
  %11 = bitcast %struct.Complex* %c114 to i8*
  %12 = bitcast %struct.Complex* %tmp24 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 8 %11, i8* align 8 %12, i32 16, i1 false)
  %arraydecay26 = getelementptr inbounds [16 x i8], [16 x i8]* %buffer, i32 0, i32 0
  call void @c2qi(%struct.QuaterImaginary* sret align 4 %tmp25, %struct.Complex* byval(%struct.Complex) align 8 %c114, i8* %arraydecay26)
  %13 = bitcast %struct.QuaterImaginary* %qi18 to i8*
  %14 = bitcast %struct.QuaterImaginary* %tmp25 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 4 %13, i8* align 4 %14, i32 8, i1 false)
  call void @qi2c(%struct.Complex* sret align 8 %tmp27, %struct.QuaterImaginary* byval(%struct.QuaterImaginary) align 4 %qi18)
  %15 = bitcast %struct.Complex* %c220 to i8*
  %16 = bitcast %struct.Complex* %tmp27 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 8 %15, i8* align 8 %16, i32 16, i1 false)
  call void @printComplex(%struct.Complex* byval(%struct.Complex) align 8 %c114)
  %call28 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.4, i32 0, i32 0))
  call void @printQuaterImaginary(%struct.QuaterImaginary* byval(%struct.QuaterImaginary) align 4 %qi18)
  %call29 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.4, i32 0, i32 0))
  call void @printComplex(%struct.Complex* byval(%struct.Complex) align 8 %c220)
  %call30 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([2 x i8], [2 x i8]* @.str.6, i32 0, i32 0))
  br label %for.inc31

for.inc31:                                        ; preds = %for.body13
  %17 = load i32, i32* %i, align 4
  %inc32 = add nsw i32 %17, 1
  store i32 %inc32, i32* %i, align 4
  br label %for.cond10

for.end33:                                        ; preds = %for.cond10
  ret i32 0
}

attributes #0 = { noinline nounwind optnone "correctly-rounded-divide-sqrt-fp-math"="false" "disable-tail-calls"="false" "frame-pointer"="none" "less-precise-fpmad"="false" "min-legal-vector-width"="0" "no-infs-fp-math"="false" "no-jump-tables"="false" "no-nans-fp-math"="false" "no-signed-zeros-fp-math"="false" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="generic" "unsafe-fp-math"="false" "use-soft-float"="false" }
attributes #1 = { "correctly-rounded-divide-sqrt-fp-math"="false" "disable-tail-calls"="false" "frame-pointer"="none" "less-precise-fpmad"="false" "no-infs-fp-math"="false" "no-nans-fp-math"="false" "no-signed-zeros-fp-math"="false" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="generic" "unsafe-fp-math"="false" "use-soft-float"="false" }
attributes #2 = { nounwind readonly "correctly-rounded-divide-sqrt-fp-math"="false" "disable-tail-calls"="false" "frame-pointer"="none" "less-precise-fpmad"="false" "no-infs-fp-math"="false" "no-nans-fp-math"="false" "no-signed-zeros-fp-math"="false" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="generic" "unsafe-fp-math"="false" "use-soft-float"="false" }
attributes #3 = { argmemonly nounwind willreturn }
attributes #4 = { nounwind readnone speculatable willreturn }
attributes #5 = { nounwind readonly }

!llvm.module.flags = !{!0}
!llvm.ident = !{!1}

!0 = !{i32 1, !"wchar_size", i32 4}
!1 = !{!"clang version 11.0.0 (https://github.com/Jacarte/llvm-project.git 0f6dea67136cc1e0b3d200eb2bb165628970c44b)"}

; extracted candidates
#########################################################
; exiting Souper's runOnFunction() for makeComplex()

; entering Souper's runOnFunction() for addComplex()

; ModuleID = './Imaginary_base_numbers.c.bc'
source_filename = "./Imaginary_base_numbers.c"
target datalayout = "e-m:e-p:32:32-i64:64-n32:64-S128"
target triple = "wasm32-unknown-wasi"

%struct.Complex = type { double, double }
%struct.QuaterImaginary = type { i8*, i32 }

@.str = private unnamed_addr constant [17 x i8] c"(%3.0f + %3.0fi)\00", align 1
@TWO_I = hidden constant %struct.Complex { double 0.000000e+00, double 2.000000e+00 }, align 8
@INV_TWO_I = hidden constant %struct.Complex { double 0.000000e+00, double -5.000000e-01 }, align 8
@.str.1 = private unnamed_addr constant [4 x i8] c"%8s\00", align 1
@.str.2 = private unnamed_addr constant [9 x i8] c" ERROR  \00", align 1
@.str.3 = private unnamed_addr constant [2 x i8] c"0\00", align 1
@.str.4 = private unnamed_addr constant [5 x i8] c" -> \00", align 1
@.str.5 = private unnamed_addr constant [6 x i8] c"     \00", align 1
@.str.6 = private unnamed_addr constant [2 x i8] c"\0A\00", align 1
@llvm.used = appending global [1 x i8*] [i8* bitcast (i32 ()* @__main_void to i8*)], section "llvm.metadata"

@__main_void = alias i32 (), i32 ()* @main

; Function Attrs: noinline nounwind optnone
define hidden i32 @find(i8* %s, i8 signext %c) #0 {
entry:
  %retval = alloca i32, align 4
  %s.addr = alloca i8*, align 4
  %c.addr = alloca i8, align 1
  %i = alloca i8*, align 4
  store i8* %s, i8** %s.addr, align 4
  store i8 %c, i8* %c.addr, align 1
  %0 = load i8*, i8** %s.addr, align 4
  store i8* %0, i8** %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %1 = load i8*, i8** %i, align 4
  %2 = load i8, i8* %1, align 1
  %conv = sext i8 %2 to i32
  %cmp = icmp ne i32 %conv, 0
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %3 = load i8*, i8** %i, align 4
  %4 = load i8, i8* %3, align 1
  %conv2 = sext i8 %4 to i32
  %5 = load i8, i8* %c.addr, align 1
  %conv3 = sext i8 %5 to i32
  %cmp4 = icmp eq i32 %conv2, %conv3
  br i1 %cmp4, label %if.then, label %if.end

if.then:                                          ; preds = %for.body
  %6 = load i8*, i8** %i, align 4
  %7 = load i8*, i8** %s.addr, align 4
  %sub.ptr.lhs.cast = ptrtoint i8* %6 to i32
  %sub.ptr.rhs.cast = ptrtoint i8* %7 to i32
  %sub.ptr.sub = sub i32 %sub.ptr.lhs.cast, %sub.ptr.rhs.cast
  store i32 %sub.ptr.sub, i32* %retval, align 4
  br label %return

if.end:                                           ; preds = %for.body
  br label %for.inc

for.inc:                                          ; preds = %if.end
  %8 = load i8*, i8** %i, align 4
  %incdec.ptr = getelementptr inbounds i8, i8* %8, i32 1
  store i8* %incdec.ptr, i8** %i, align 4
  br label %for.cond

for.end:                                          ; preds = %for.cond
  store i32 -1, i32* %retval, align 4
  br label %return

return:                                           ; preds = %for.end, %if.then
  %9 = load i32, i32* %retval, align 4
  ret i32 %9
}

; Function Attrs: noinline nounwind optnone
define hidden void @reverse(i8* %b, i8* %e) #0 {
entry:
  %b.addr = alloca i8*, align 4
  %e.addr = alloca i8*, align 4
  %t = alloca i8, align 1
  store i8* %b, i8** %b.addr, align 4
  store i8* %e, i8** %e.addr, align 4
  %0 = load i8*, i8** %e.addr, align 4
  %incdec.ptr = getelementptr inbounds i8, i8* %0, i32 -1
  store i8* %incdec.ptr, i8** %e.addr, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %1 = load i8*, i8** %b.addr, align 4
  %2 = load i8*, i8** %e.addr, align 4
  %cmp = icmp ult i8* %1, %2
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %3 = load i8*, i8** %b.addr, align 4
  %4 = load i8, i8* %3, align 1
  store i8 %4, i8* %t, align 1
  %5 = load i8*, i8** %e.addr, align 4
  %6 = load i8, i8* %5, align 1
  %7 = load i8*, i8** %b.addr, align 4
  store i8 %6, i8* %7, align 1
  %8 = load i8, i8* %t, align 1
  %9 = load i8*, i8** %e.addr, align 4
  store i8 %8, i8* %9, align 1
  br label %for.inc

for.inc:                                          ; preds = %for.body
  %10 = load i8*, i8** %b.addr, align 4
  %incdec.ptr1 = getelementptr inbounds i8, i8* %10, i32 1
  store i8* %incdec.ptr1, i8** %b.addr, align 4
  %11 = load i8*, i8** %e.addr, align 4
  %incdec.ptr2 = getelementptr inbounds i8, i8* %11, i32 -1
  store i8* %incdec.ptr2, i8** %e.addr, align 4
  br label %for.cond

for.end:                                          ; preds = %for.cond
  ret void
}

; Function Attrs: noinline nounwind optnone
define hidden void @printComplex(%struct.Complex* byval(%struct.Complex) align 8 %c) #0 {
entry:
  %rel = getelementptr inbounds %struct.Complex, %struct.Complex* %c, i32 0, i32 0
  %0 = load double, double* %rel, align 8
  %img = getelementptr inbounds %struct.Complex, %struct.Complex* %c, i32 0, i32 1
  %1 = load double, double* %img, align 8
  %call = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([17 x i8], [17 x i8]* @.str, i32 0, i32 0), double %0, double %1)
  ret void
}

declare i32 @printf(i8* %0, ...) #1

; Function Attrs: noinline nounwind optnone
define hidden void @makeComplex(%struct.Complex* noalias sret align 8 %agg.result, double %rel, double %img) #0 {
entry:
  %rel.addr = alloca double, align 8
  %img.addr = alloca double, align 8
  store double %rel, double* %rel.addr, align 8
  store double %img, double* %img.addr, align 8
  %rel1 = getelementptr inbounds %struct.Complex, %struct.Complex* %agg.result, i32 0, i32 0
  %0 = load double, double* %rel.addr, align 8
  store double %0, double* %rel1, align 8
  %img2 = getelementptr inbounds %struct.Complex, %struct.Complex* %agg.result, i32 0, i32 1
  %1 = load double, double* %img.addr, align 8
  store double %1, double* %img2, align 8
  ret void
}

; Function Attrs: noinline nounwind optnone
define hidden void @addComplex(%struct.Complex* noalias sret align 8 %agg.result, %struct.Complex* byval(%struct.Complex) align 8 %a, %struct.Complex* byval(%struct.Complex) align 8 %b) #0 {
entry:
  %rel = getelementptr inbounds %struct.Complex, %struct.Complex* %agg.result, i32 0, i32 0
  %rel1 = getelementptr inbounds %struct.Complex, %struct.Complex* %a, i32 0, i32 0
  %0 = load double, double* %rel1, align 8
  %rel2 = getelementptr inbounds %struct.Complex, %struct.Complex* %b, i32 0, i32 0
  %1 = load double, double* %rel2, align 8
  %add = fadd double %0, %1
  store double %add, double* %rel, align 8
  %img = getelementptr inbounds %struct.Complex, %struct.Complex* %agg.result, i32 0, i32 1
  %img3 = getelementptr inbounds %struct.Complex, %struct.Complex* %a, i32 0, i32 1
  %2 = load double, double* %img3, align 8
  %img4 = getelementptr inbounds %struct.Complex, %struct.Complex* %b, i32 0, i32 1
  %3 = load double, double* %img4, align 8
  %add5 = fadd double %2, %3
  store double %add5, double* %img, align 8
  ret void
}

; Function Attrs: noinline nounwind optnone
define hidden void @mulComplex(%struct.Complex* noalias sret align 8 %agg.result, %struct.Complex* byval(%struct.Complex) align 8 %a, %struct.Complex* byval(%struct.Complex) align 8 %b) #0 {
entry:
  %rel = getelementptr inbounds %struct.Complex, %struct.Complex* %agg.result, i32 0, i32 0
  %rel1 = getelementptr inbounds %struct.Complex, %struct.Complex* %a, i32 0, i32 0
  %0 = load double, double* %rel1, align 8
  %rel2 = getelementptr inbounds %struct.Complex, %struct.Complex* %b, i32 0, i32 0
  %1 = load double, double* %rel2, align 8
  %mul = fmul double %0, %1
  %img = getelementptr inbounds %struct.Complex, %struct.Complex* %a, i32 0, i32 1
  %2 = load double, double* %img, align 8
  %img3 = getelementptr inbounds %struct.Complex, %struct.Complex* %b, i32 0, i32 1
  %3 = load double, double* %img3, align 8
  %mul4 = fmul double %2, %3
  %sub = fsub double %mul, %mul4
  store double %sub, double* %rel, align 8
  %img5 = getelementptr inbounds %struct.Complex, %struct.Complex* %agg.result, i32 0, i32 1
  %rel6 = getelementptr inbounds %struct.Complex, %struct.Complex* %a, i32 0, i32 0
  %4 = load double, double* %rel6, align 8
  %img7 = getelementptr inbounds %struct.Complex, %struct.Complex* %b, i32 0, i32 1
  %5 = load double, double* %img7, align 8
  %mul8 = fmul double %4, %5
  %img9 = getelementptr inbounds %struct.Complex, %struct.Complex* %a, i32 0, i32 1
  %6 = load double, double* %img9, align 8
  %rel10 = getelementptr inbounds %struct.Complex, %struct.Complex* %b, i32 0, i32 0
  %7 = load double, double* %rel10, align 8
  %mul11 = fmul double %6, %7
  %sub12 = fsub double %mul8, %mul11
  store double %sub12, double* %img5, align 8
  ret void
}

; Function Attrs: noinline nounwind optnone
define hidden void @mulComplexD(%struct.Complex* noalias sret align 8 %agg.result, %struct.Complex* byval(%struct.Complex) align 8 %a, double %b) #0 {
entry:
  %b.addr = alloca double, align 8
  store double %b, double* %b.addr, align 8
  %rel = getelementptr inbounds %struct.Complex, %struct.Complex* %agg.result, i32 0, i32 0
  %rel1 = getelementptr inbounds %struct.Complex, %struct.Complex* %a, i32 0, i32 0
  %0 = load double, double* %rel1, align 8
  %1 = load double, double* %b.addr, align 8
  %mul = fmul double %0, %1
  store double %mul, double* %rel, align 8
  %img = getelementptr inbounds %struct.Complex, %struct.Complex* %agg.result, i32 0, i32 1
  %img2 = getelementptr inbounds %struct.Complex, %struct.Complex* %a, i32 0, i32 1
  %2 = load double, double* %img2, align 8
  %3 = load double, double* %b.addr, align 8
  %mul3 = fmul double %2, %3
  store double %mul3, double* %img, align 8
  ret void
}

; Function Attrs: noinline nounwind optnone
define hidden void @negComplex(%struct.Complex* noalias sret align 8 %agg.result, %struct.Complex* byval(%struct.Complex) align 8 %a) #0 {
entry:
  call void @mulComplexD(%struct.Complex* sret align 8 %agg.result, %struct.Complex* byval(%struct.Complex) align 8 %a, double -1.000000e+00)
  ret void
}

; Function Attrs: noinline nounwind optnone
define hidden void @divComplex(%struct.Complex* noalias sret align 8 %agg.result, %struct.Complex* byval(%struct.Complex) align 8 %a, %struct.Complex* byval(%struct.Complex) align 8 %b) #0 {
entry:
  %re = alloca double, align 8
  %im = alloca double, align 8
  %d = alloca double, align 8
  %rel = getelementptr inbounds %struct.Complex, %struct.Complex* %a, i32 0, i32 0
  %0 = load double, double* %rel, align 8
  %rel1 = getelementptr inbounds %struct.Complex, %struct.Complex* %b, i32 0, i32 0
  %1 = load double, double* %rel1, align 8
  %mul = fmul double %0, %1
  %img = getelementptr inbounds %struct.Complex, %struct.Complex* %a, i32 0, i32 1
  %2 = load double, double* %img, align 8
  %img2 = getelementptr inbounds %struct.Complex, %struct.Complex* %b, i32 0, i32 1
  %3 = load double, double* %img2, align 8
  %mul3 = fmul double %2, %3
  %add = fadd double %mul, %mul3
  store double %add, double* %re, align 8
  %img4 = getelementptr inbounds %struct.Complex, %struct.Complex* %a, i32 0, i32 1
  %4 = load double, double* %img4, align 8
  %rel5 = getelementptr inbounds %struct.Complex, %struct.Complex* %b, i32 0, i32 0
  %5 = load double, double* %rel5, align 8
  %mul6 = fmul double %4, %5
  %rel7 = getelementptr inbounds %struct.Complex, %struct.Complex* %a, i32 0, i32 0
  %6 = load double, double* %rel7, align 8
  %img8 = getelementptr inbounds %struct.Complex, %struct.Complex* %b, i32 0, i32 1
  %7 = load double, double* %img8, align 8
  %mul9 = fmul double %6, %7
  %sub = fsub double %mul6, %mul9
  store double %sub, double* %im, align 8
  %rel10 = getelementptr inbounds %struct.Complex, %struct.Complex* %b, i32 0, i32 0
  %8 = load double, double* %rel10, align 8
  %rel11 = getelementptr inbounds %struct.Complex, %struct.Complex* %b, i32 0, i32 0
  %9 = load double, double* %rel11, align 8
  %mul12 = fmul double %8, %9
  %img13 = getelementptr inbounds %struct.Complex, %struct.Complex* %b, i32 0, i32 1
  %10 = load double, double* %img13, align 8
  %img14 = getelementptr inbounds %struct.Complex, %struct.Complex* %b, i32 0, i32 1
  %11 = load double, double* %img14, align 8
  %mul15 = fmul double %10, %11
  %add16 = fadd double %mul12, %mul15
  store double %add16, double* %d, align 8
  %rel17 = getelementptr inbounds %struct.Complex, %struct.Complex* %agg.result, i32 0, i32 0
  %12 = load double, double* %re, align 8
  %13 = load double, double* %d, align 8
  %div = fdiv double %12, %13
  store double %div, double* %rel17, align 8
  %img18 = getelementptr inbounds %struct.Complex, %struct.Complex* %agg.result, i32 0, i32 1
  %14 = load double, double* %im, align 8
  %15 = load double, double* %d, align 8
  %div19 = fdiv double %14, %15
  store double %div19, double* %img18, align 8
  ret void
}

; Function Attrs: noinline nounwind optnone
define hidden void @inv(%struct.Complex* noalias sret align 8 %agg.result, %struct.Complex* byval(%struct.Complex) align 8 %c) #0 {
entry:
  %d = alloca double, align 8
  %rel = getelementptr inbounds %struct.Complex, %struct.Complex* %c, i32 0, i32 0
  %0 = load double, double* %rel, align 8
  %rel1 = getelementptr inbounds %struct.Complex, %struct.Complex* %c, i32 0, i32 0
  %1 = load double, double* %rel1, align 8
  %mul = fmul double %0, %1
  %img = getelementptr inbounds %struct.Complex, %struct.Complex* %c, i32 0, i32 1
  %2 = load double, double* %img, align 8
  %img2 = getelementptr inbounds %struct.Complex, %struct.Complex* %c, i32 0, i32 1
  %3 = load double, double* %img2, align 8
  %mul3 = fmul double %2, %3
  %add = fadd double %mul, %mul3
  store double %add, double* %d, align 8
  %rel4 = getelementptr inbounds %struct.Complex, %struct.Complex* %agg.result, i32 0, i32 0
  %rel5 = getelementptr inbounds %struct.Complex, %struct.Complex* %c, i32 0, i32 0
  %4 = load double, double* %rel5, align 8
  %5 = load double, double* %d, align 8
  %div = fdiv double %4, %5
  store double %div, double* %rel4, align 8
  %img6 = getelementptr inbounds %struct.Complex, %struct.Complex* %agg.result, i32 0, i32 1
  %img7 = getelementptr inbounds %struct.Complex, %struct.Complex* %c, i32 0, i32 1
  %6 = load double, double* %img7, align 8
  %fneg = fneg double %6
  %7 = load double, double* %d, align 8
  %div8 = fdiv double %fneg, %7
  store double %div8, double* %img6, align 8
  ret void
}

; Function Attrs: noinline nounwind optnone
define hidden void @makeQuaterImaginary(%struct.QuaterImaginary* noalias sret align 4 %agg.result, i8* %s) #0 {
entry:
  %s.addr = alloca i8*, align 4
  %i = alloca i32, align 4
  %valid1 = alloca i32, align 4
  %cnt = alloca i32, align 4
  store i8* %s, i8** %s.addr, align 4
  %b2i = getelementptr inbounds %struct.QuaterImaginary, %struct.QuaterImaginary* %agg.result, i32 0, i32 0
  %0 = load i8*, i8** %s.addr, align 4
  store i8* %0, i8** %b2i, align 4
  %valid = getelementptr inbounds %struct.QuaterImaginary, %struct.QuaterImaginary* %agg.result, i32 0, i32 1
  store i32 0, i32* %valid, align 4
  store i32 1, i32* %valid1, align 4
  store i32 0, i32* %cnt, align 4
  %1 = load i8*, i8** %s.addr, align 4
  %2 = load i8, i8* %1, align 1
  %conv = sext i8 %2 to i32
  %cmp = icmp ne i32 %conv, 0
  br i1 %cmp, label %if.then, label %if.end26

if.then:                                          ; preds = %entry
  store i32 0, i32* %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.then
  %3 = load i8*, i8** %s.addr, align 4
  %4 = load i32, i32* %i, align 4
  %arrayidx = getelementptr inbounds i8, i8* %3, i32 %4
  %5 = load i8, i8* %arrayidx, align 1
  %conv3 = sext i8 %5 to i32
  %cmp4 = icmp ne i32 %conv3, 0
  br i1 %cmp4, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %6 = load i8*, i8** %s.addr, align 4
  %7 = load i32, i32* %i, align 4
  %arrayidx6 = getelementptr inbounds i8, i8* %6, i32 %7
  %8 = load i8, i8* %arrayidx6, align 1
  %conv7 = sext i8 %8 to i32
  %cmp8 = icmp slt i32 %conv7, 48
  br i1 %cmp8, label %if.then14, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %for.body
  %9 = load i8*, i8** %s.addr, align 4
  %10 = load i32, i32* %i, align 4
  %arrayidx10 = getelementptr inbounds i8, i8* %9, i32 %10
  %11 = load i8, i8* %arrayidx10, align 1
  %conv11 = sext i8 %11 to i32
  %cmp12 = icmp slt i32 51, %conv11
  br i1 %cmp12, label %if.then14, label %if.end20

if.then14:                                        ; preds = %lor.lhs.false, %for.body
  %12 = load i8*, i8** %s.addr, align 4
  %13 = load i32, i32* %i, align 4
  %arrayidx15 = getelementptr inbounds i8, i8* %12, i32 %13
  %14 = load i8, i8* %arrayidx15, align 1
  %conv16 = sext i8 %14 to i32
  %cmp17 = icmp eq i32 %conv16, 46
  br i1 %cmp17, label %if.then19, label %if.else

if.then19:                                        ; preds = %if.then14
  %15 = load i32, i32* %cnt, align 4
  %inc = add i32 %15, 1
  store i32 %inc, i32* %cnt, align 4
  br label %if.end

if.else:                                          ; preds = %if.then14
  store i32 0, i32* %valid1, align 4
  br label %for.end

if.end:                                           ; preds = %if.then19
  br label %if.end20

if.end20:                                         ; preds = %if.end, %lor.lhs.false
  br label %for.inc

for.inc:                                          ; preds = %if.end20
  %16 = load i32, i32* %i, align 4
  %inc21 = add i32 %16, 1
  store i32 %inc21, i32* %i, align 4
  br label %for.cond

for.end:                                          ; preds = %if.else, %for.cond
  %17 = load i32, i32* %valid1, align 4
  %tobool = icmp ne i32 %17, 0
  br i1 %tobool, label %land.lhs.true, label %if.end25

land.lhs.true:                                    ; preds = %for.end
  %18 = load i32, i32* %cnt, align 4
  %cmp22 = icmp ugt i32 %18, 1
  br i1 %cmp22, label %if.then24, label %if.end25

if.then24:                                        ; preds = %land.lhs.true
  store i32 0, i32* %valid1, align 4
  br label %if.end25

if.end25:                                         ; preds = %if.then24, %land.lhs.true, %for.end
  br label %if.end26

if.end26:                                         ; preds = %if.end25, %entry
  %19 = load i32, i32* %valid1, align 4
  %valid27 = getelementptr inbounds %struct.QuaterImaginary, %struct.QuaterImaginary* %agg.result, i32 0, i32 1
  store i32 %19, i32* %valid27, align 4
  ret void
}

; Function Attrs: noinline nounwind optnone
define hidden void @printQuaterImaginary(%struct.QuaterImaginary* byval(%struct.QuaterImaginary) align 4 %qi) #0 {
entry:
  %valid = getelementptr inbounds %struct.QuaterImaginary, %struct.QuaterImaginary* %qi, i32 0, i32 1
  %0 = load i32, i32* %valid, align 4
  %tobool = icmp ne i32 %0, 0
  br i1 %tobool, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  %b2i = getelementptr inbounds %struct.QuaterImaginary, %struct.QuaterImaginary* %qi, i32 0, i32 0
  %1 = load i8*, i8** %b2i, align 4
  %call = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([4 x i8], [4 x i8]* @.str.1, i32 0, i32 0), i8* %1)
  br label %if.end

if.else:                                          ; preds = %entry
  %call1 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([9 x i8], [9 x i8]* @.str.2, i32 0, i32 0))
  br label %if.end

if.end:                                           ; preds = %if.else, %if.then
  ret void
}

; Function Attrs: noinline nounwind optnone
define hidden void @qi2c(%struct.Complex* noalias sret align 8 %agg.result, %struct.QuaterImaginary* byval(%struct.QuaterImaginary) align 4 %qi) #0 {
entry:
  %len = alloca i32, align 4
  %pointPos = alloca i32, align 4
  %posLen = alloca i32, align 4
  %prod = alloca %struct.Complex, align 8
  %j = alloca i32, align 4
  %k = alloca double, align 8
  %tmp = alloca %struct.Complex, align 8
  %agg.tmp = alloca %struct.Complex, align 8
  %tmp10 = alloca %struct.Complex, align 8
  %k18 = alloca double, align 8
  %tmp27 = alloca %struct.Complex, align 8
  %agg.tmp28 = alloca %struct.Complex, align 8
  %tmp30 = alloca %struct.Complex, align 8
  %b2i = getelementptr inbounds %struct.QuaterImaginary, %struct.QuaterImaginary* %qi, i32 0, i32 0
  %0 = load i8*, i8** %b2i, align 4
  %call = call i32 @strlen(i8* %0) #5
  store i32 %call, i32* %len, align 4
  %b2i1 = getelementptr inbounds %struct.QuaterImaginary, %struct.QuaterImaginary* %qi, i32 0, i32 0
  %1 = load i8*, i8** %b2i1, align 4
  %call2 = call i32 @find(i8* %1, i8 signext 46)
  store i32 %call2, i32* %pointPos, align 4
  %2 = load i32, i32* %pointPos, align 4
  %cmp = icmp sgt i32 %2, 0
  br i1 %cmp, label %cond.true, label %cond.false

cond.true:                                        ; preds = %entry
  %3 = load i32, i32* %pointPos, align 4
  br label %cond.end

cond.false:                                       ; preds = %entry
  %4 = load i32, i32* %len, align 4
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi i32 [ %3, %cond.true ], [ %4, %cond.false ]
  store i32 %cond, i32* %posLen, align 4
  call void @makeComplex(%struct.Complex* sret align 8 %agg.result, double 0.000000e+00, double 0.000000e+00)
  call void @makeComplex(%struct.Complex* sret align 8 %prod, double 1.000000e+00, double 0.000000e+00)
  store i32 0, i32* %j, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %cond.end
  %5 = load i32, i32* %j, align 4
  %6 = load i32, i32* %posLen, align 4
  %cmp3 = icmp ult i32 %5, %6
  br i1 %cmp3, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %b2i4 = getelementptr inbounds %struct.QuaterImaginary, %struct.QuaterImaginary* %qi, i32 0, i32 0
  %7 = load i8*, i8** %b2i4, align 4
  %8 = load i32, i32* %posLen, align 4
  %sub = sub i32 %8, 1
  %9 = load i32, i32* %j, align 4
  %sub5 = sub i32 %sub, %9
  %arrayidx = getelementptr inbounds i8, i8* %7, i32 %sub5
  %10 = load i8, i8* %arrayidx, align 1
  %conv = sext i8 %10 to i32
  %sub6 = sub nsw i32 %conv, 48
  %conv7 = sitofp i32 %sub6 to double
  store double %conv7, double* %k, align 8
  %11 = load double, double* %k, align 8
  %cmp8 = fcmp ogt double %11, 0.000000e+00
  br i1 %cmp8, label %if.then, label %if.end

if.then:                                          ; preds = %for.body
  %12 = load double, double* %k, align 8
  call void @mulComplexD(%struct.Complex* sret align 8 %agg.tmp, %struct.Complex* byval(%struct.Complex) align 8 %prod, double %12)
  call void @addComplex(%struct.Complex* sret align 8 %tmp, %struct.Complex* byval(%struct.Complex) align 8 %agg.result, %struct.Complex* byval(%struct.Complex) align 8 %agg.tmp)
  %13 = bitcast %struct.Complex* %agg.result to i8*
  %14 = bitcast %struct.Complex* %tmp to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 8 %13, i8* align 8 %14, i32 16, i1 false)
  br label %if.end

if.end:                                           ; preds = %if.then, %for.body
  call void @mulComplex(%struct.Complex* sret align 8 %tmp10, %struct.Complex* byval(%struct.Complex) align 8 %prod, %struct.Complex* byval(%struct.Complex) align 8 @TWO_I)
  %15 = bitcast %struct.Complex* %prod to i8*
  %16 = bitcast %struct.Complex* %tmp10 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 8 %15, i8* align 8 %16, i32 16, i1 false)
  br label %for.inc

for.inc:                                          ; preds = %if.end
  %17 = load i32, i32* %j, align 4
  %inc = add i32 %17, 1
  store i32 %inc, i32* %j, align 4
  br label %for.cond

for.end:                                          ; preds = %for.cond
  %18 = load i32, i32* %pointPos, align 4
  %cmp11 = icmp ne i32 %18, -1
  br i1 %cmp11, label %if.then13, label %if.end34

if.then13:                                        ; preds = %for.end
  %19 = bitcast %struct.Complex* %prod to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 8 %19, i8* align 8 bitcast (%struct.Complex* @INV_TWO_I to i8*), i32 16, i1 false)
  %20 = load i32, i32* %posLen, align 4
  %add = add i32 %20, 1
  store i32 %add, i32* %j, align 4
  br label %for.cond14

for.cond14:                                       ; preds = %for.inc31, %if.then13
  %21 = load i32, i32* %j, align 4
  %22 = load i32, i32* %len, align 4
  %cmp15 = icmp ult i32 %21, %22
  br i1 %cmp15, label %for.body17, label %for.end33

for.body17:                                       ; preds = %for.cond14
  %b2i19 = getelementptr inbounds %struct.QuaterImaginary, %struct.QuaterImaginary* %qi, i32 0, i32 0
  %23 = load i8*, i8** %b2i19, align 4
  %24 = load i32, i32* %j, align 4
  %arrayidx20 = getelementptr inbounds i8, i8* %23, i32 %24
  %25 = load i8, i8* %arrayidx20, align 1
  %conv21 = sext i8 %25 to i32
  %sub22 = sub nsw i32 %conv21, 48
  %conv23 = sitofp i32 %sub22 to double
  store double %conv23, double* %k18, align 8
  %26 = load double, double* %k18, align 8
  %cmp24 = fcmp ogt double %26, 0.000000e+00
  br i1 %cmp24, label %if.then26, label %if.end29

if.then26:                                        ; preds = %for.body17
  %27 = load double, double* %k18, align 8
  call void @mulComplexD(%struct.Complex* sret align 8 %agg.tmp28, %struct.Complex* byval(%struct.Complex) align 8 %prod, double %27)
  call void @addComplex(%struct.Complex* sret align 8 %tmp27, %struct.Complex* byval(%struct.Complex) align 8 %agg.result, %struct.Complex* byval(%struct.Complex) align 8 %agg.tmp28)
  %28 = bitcast %struct.Complex* %agg.result to i8*
  %29 = bitcast %struct.Complex* %tmp27 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 8 %28, i8* align 8 %29, i32 16, i1 false)
  br label %if.end29

if.end29:                                         ; preds = %if.then26, %for.body17
  call void @mulComplex(%struct.Complex* sret align 8 %tmp30, %struct.Complex* byval(%struct.Complex) align 8 %prod, %struct.Complex* byval(%struct.Complex) align 8 @INV_TWO_I)
  %30 = bitcast %struct.Complex* %prod to i8*
  %31 = bitcast %struct.Complex* %tmp30 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 8 %30, i8* align 8 %31, i32 16, i1 false)
  br label %for.inc31

for.inc31:                                        ; preds = %if.end29
  %32 = load i32, i32* %j, align 4
  %inc32 = add i32 %32, 1
  store i32 %inc32, i32* %j, align 4
  br label %for.cond14

for.end33:                                        ; preds = %for.cond14
  br label %if.end34

if.end34:                                         ; preds = %for.end33, %for.end
  ret void
}

; Function Attrs: nounwind readonly
declare i32 @strlen(i8* %0) #2

; Function Attrs: argmemonly nounwind willreturn
declare void @llvm.memcpy.p0i8.p0i8.i32(i8* noalias nocapture writeonly %0, i8* noalias nocapture readonly %1, i32 %2, i1 immarg %3) #3

; Function Attrs: noinline nounwind optnone
define hidden void @c2qi(%struct.QuaterImaginary* noalias sret align 4 %agg.result, %struct.Complex* byval(%struct.Complex) align 8 %c, i8* %out) #0 {
entry:
  %out.addr = alloca i8*, align 4
  %p = alloca i8*, align 4
  %re = alloca i32, align 4
  %im = alloca i32, align 4
  %fi = alloca i32, align 4
  %rem = alloca i32, align 4
  %index = alloca i32, align 4
  %fc = alloca %struct.Complex, align 8
  %.compoundliteral = alloca %struct.Complex, align 8
  %.compoundliteral21 = alloca %struct.Complex, align 8
  %f = alloca double, align 8
  %rem31 = alloca i32, align 4
  %i = alloca i32, align 4
  store i8* %out, i8** %out.addr, align 4
  %0 = load i8*, i8** %out.addr, align 4
  store i8* %0, i8** %p, align 4
  %1 = load i8*, i8** %p, align 4
  store i8 0, i8* %1, align 1
  %rel = getelementptr inbounds %struct.Complex, %struct.Complex* %c, i32 0, i32 0
  %2 = load double, double* %rel, align 8
  %cmp = fcmp oeq double %2, 0.000000e+00
  br i1 %cmp, label %land.lhs.true, label %if.end

land.lhs.true:                                    ; preds = %entry
  %img = getelementptr inbounds %struct.Complex, %struct.Complex* %c, i32 0, i32 1
  %3 = load double, double* %img, align 8
  %cmp1 = fcmp oeq double %3, 0.000000e+00
  br i1 %cmp1, label %if.then, label %if.end

if.then:                                          ; preds = %land.lhs.true
  call void @makeQuaterImaginary(%struct.QuaterImaginary* sret align 4 %agg.result, i8* getelementptr inbounds ([2 x i8], [2 x i8]* @.str.3, i32 0, i32 0))
  br label %return

if.end:                                           ; preds = %land.lhs.true, %entry
  %rel2 = getelementptr inbounds %struct.Complex, %struct.Complex* %c, i32 0, i32 0
  %4 = load double, double* %rel2, align 8
  %conv = fptosi double %4 to i32
  store i32 %conv, i32* %re, align 4
  %img3 = getelementptr inbounds %struct.Complex, %struct.Complex* %c, i32 0, i32 1
  %5 = load double, double* %img3, align 8
  %conv4 = fptosi double %5 to i32
  store i32 %conv4, i32* %im, align 4
  store i32 -1, i32* %fi, align 4
  br label %while.cond

while.cond:                                       ; preds = %if.end11, %if.end
  %6 = load i32, i32* %re, align 4
  %cmp5 = icmp ne i32 %6, 0
  br i1 %cmp5, label %while.body, label %while.end

while.body:                                       ; preds = %while.cond
  %7 = load i32, i32* %re, align 4
  %rem7 = srem i32 %7, -4
  store i32 %rem7, i32* %rem, align 4
  %8 = load i32, i32* %re, align 4
  %div = sdiv i32 %8, -4
  store i32 %div, i32* %re, align 4
  %9 = load i32, i32* %rem, align 4
  %cmp8 = icmp slt i32 %9, 0
  br i1 %cmp8, label %if.then10, label %if.end11

if.then10:                                        ; preds = %while.body
  %10 = load i32, i32* %rem, align 4
  %add = add nsw i32 %10, 4
  store i32 %add, i32* %rem, align 4
  %11 = load i32, i32* %re, align 4
  %inc = add nsw i32 %11, 1
  store i32 %inc, i32* %re, align 4
  br label %if.end11

if.end11:                                         ; preds = %if.then10, %while.body
  %12 = load i32, i32* %rem, align 4
  %add12 = add nsw i32 %12, 48
  %conv13 = trunc i32 %add12 to i8
  %13 = load i8*, i8** %p, align 4
  %incdec.ptr = getelementptr inbounds i8, i8* %13, i32 1
  store i8* %incdec.ptr, i8** %p, align 4
  store i8 %conv13, i8* %13, align 1
  %14 = load i8*, i8** %p, align 4
  %incdec.ptr14 = getelementptr inbounds i8, i8* %14, i32 1
  store i8* %incdec.ptr14, i8** %p, align 4
  store i8 48, i8* %14, align 1
  %15 = load i8*, i8** %p, align 4
  store i8 0, i8* %15, align 1
  br label %while.cond

while.end:                                        ; preds = %while.cond
  %16 = load i32, i32* %im, align 4
  %cmp15 = icmp ne i32 %16, 0
  br i1 %cmp15, label %if.then17, label %if.end53

if.then17:                                        ; preds = %while.end
  store i32 1, i32* %index, align 4
  %rel18 = getelementptr inbounds %struct.Complex, %struct.Complex* %.compoundliteral, i32 0, i32 0
  store double 0.000000e+00, double* %rel18, align 8
  %img19 = getelementptr inbounds %struct.Complex, %struct.Complex* %.compoundliteral, i32 0, i32 1
  %img20 = getelementptr inbounds %struct.Complex, %struct.Complex* %c, i32 0, i32 1
  %17 = load double, double* %img20, align 8
  store double %17, double* %img19, align 8
  %rel22 = getelementptr inbounds %struct.Complex, %struct.Complex* %.compoundliteral21, i32 0, i32 0
  store double 0.000000e+00, double* %rel22, align 8
  %img23 = getelementptr inbounds %struct.Complex, %struct.Complex* %.compoundliteral21, i32 0, i32 1
  store double 2.000000e+00, double* %img23, align 8
  call void @divComplex(%struct.Complex* sret align 8 %fc, %struct.Complex* byval(%struct.Complex) align 8 %.compoundliteral, %struct.Complex* byval(%struct.Complex) align 8 %.compoundliteral21)
  %rel24 = getelementptr inbounds %struct.Complex, %struct.Complex* %fc, i32 0, i32 0
  %18 = load double, double* %rel24, align 8
  store double %18, double* %f, align 8
  %19 = load double, double* %f, align 8
  %20 = call double @llvm.ceil.f64(double %19)
  %conv25 = fptosi double %20 to i32
  store i32 %conv25, i32* %im, align 4
  %21 = load double, double* %f, align 8
  %22 = load i32, i32* %im, align 4
  %conv26 = sitofp i32 %22 to double
  %sub = fsub double %21, %conv26
  %mul = fmul double -4.000000e+00, %sub
  store double %mul, double* %f, align 8
  br label %while.cond27

while.cond27:                                     ; preds = %if.end49, %if.then17
  %23 = load i32, i32* %im, align 4
  %cmp28 = icmp ne i32 %23, 0
  br i1 %cmp28, label %while.body30, label %while.end51

while.body30:                                     ; preds = %while.cond27
  %24 = load i32, i32* %im, align 4
  %rem32 = srem i32 %24, -4
  store i32 %rem32, i32* %rem31, align 4
  %25 = load i32, i32* %im, align 4
  %div33 = sdiv i32 %25, -4
  store i32 %div33, i32* %im, align 4
  %26 = load i32, i32* %rem31, align 4
  %cmp34 = icmp slt i32 %26, 0
  br i1 %cmp34, label %if.then36, label %if.end39

if.then36:                                        ; preds = %while.body30
  %27 = load i32, i32* %rem31, align 4
  %add37 = add nsw i32 %27, 4
  store i32 %add37, i32* %rem31, align 4
  %28 = load i32, i32* %im, align 4
  %inc38 = add nsw i32 %28, 1
  store i32 %inc38, i32* %im, align 4
  br label %if.end39

if.end39:                                         ; preds = %if.then36, %while.body30
  %29 = load i32, i32* %index, align 4
  %30 = load i8*, i8** %p, align 4
  %31 = load i8*, i8** %out.addr, align 4
  %sub.ptr.lhs.cast = ptrtoint i8* %30 to i32
  %sub.ptr.rhs.cast = ptrtoint i8* %31 to i32
  %sub.ptr.sub = sub i32 %sub.ptr.lhs.cast, %sub.ptr.rhs.cast
  %cmp40 = icmp ult i32 %29, %sub.ptr.sub
  br i1 %cmp40, label %if.then42, label %if.else

if.then42:                                        ; preds = %if.end39
  %32 = load i32, i32* %rem31, align 4
  %add43 = add nsw i32 %32, 48
  %conv44 = trunc i32 %add43 to i8
  %33 = load i8*, i8** %out.addr, align 4
  %34 = load i32, i32* %index, align 4
  %arrayidx = getelementptr inbounds i8, i8* %33, i32 %34
  store i8 %conv44, i8* %arrayidx, align 1
  br label %if.end49

if.else:                                          ; preds = %if.end39
  %35 = load i8*, i8** %p, align 4
  %incdec.ptr45 = getelementptr inbounds i8, i8* %35, i32 1
  store i8* %incdec.ptr45, i8** %p, align 4
  store i8 48, i8* %35, align 1
  %36 = load i32, i32* %rem31, align 4
  %add46 = add nsw i32 %36, 48
  %conv47 = trunc i32 %add46 to i8
  %37 = load i8*, i8** %p, align 4
  %incdec.ptr48 = getelementptr inbounds i8, i8* %37, i32 1
  store i8* %incdec.ptr48, i8** %p, align 4
  store i8 %conv47, i8* %37, align 1
  %38 = load i8*, i8** %p, align 4
  store i8 0, i8* %38, align 1
  br label %if.end49

if.end49:                                         ; preds = %if.else, %if.then42
  %39 = load i32, i32* %index, align 4
  %add50 = add i32 %39, 2
  store i32 %add50, i32* %index, align 4
  br label %while.cond27

while.end51:                                      ; preds = %while.cond27
  %40 = load double, double* %f, align 8
  %conv52 = fptosi double %40 to i32
  store i32 %conv52, i32* %fi, align 4
  br label %if.end53

if.end53:                                         ; preds = %while.end51, %while.end
  %41 = load i8*, i8** %out.addr, align 4
  %42 = load i8*, i8** %p, align 4
  call void @reverse(i8* %41, i8* %42)
  %43 = load i32, i32* %fi, align 4
  %cmp54 = icmp ne i32 %43, -1
  br i1 %cmp54, label %if.then56, label %if.end61

if.then56:                                        ; preds = %if.end53
  %44 = load i8*, i8** %p, align 4
  %incdec.ptr57 = getelementptr inbounds i8, i8* %44, i32 1
  store i8* %incdec.ptr57, i8** %p, align 4
  store i8 46, i8* %44, align 1
  %45 = load i32, i32* %fi, align 4
  %add58 = add nsw i32 %45, 48
  %conv59 = trunc i32 %add58 to i8
  %46 = load i8*, i8** %p, align 4
  %incdec.ptr60 = getelementptr inbounds i8, i8* %46, i32 1
  store i8* %incdec.ptr60, i8** %p, align 4
  store i8 %conv59, i8* %46, align 1
  %47 = load i8*, i8** %p, align 4
  store i8 0, i8* %47, align 1
  br label %if.end61

if.end61:                                         ; preds = %if.then56, %if.end53
  br label %while.cond62

while.cond62:                                     ; preds = %for.end, %if.end61
  %48 = load i8*, i8** %out.addr, align 4
  %arrayidx63 = getelementptr inbounds i8, i8* %48, i32 0
  %49 = load i8, i8* %arrayidx63, align 1
  %conv64 = sext i8 %49 to i32
  %cmp65 = icmp eq i32 %conv64, 48
  br i1 %cmp65, label %land.rhs, label %land.end

land.rhs:                                         ; preds = %while.cond62
  %50 = load i8*, i8** %out.addr, align 4
  %arrayidx67 = getelementptr inbounds i8, i8* %50, i32 1
  %51 = load i8, i8* %arrayidx67, align 1
  %conv68 = sext i8 %51 to i32
  %cmp69 = icmp ne i32 %conv68, 46
  br label %land.end

land.end:                                         ; preds = %land.rhs, %while.cond62
  %52 = phi i1 [ false, %while.cond62 ], [ %cmp69, %land.rhs ]
  br i1 %52, label %while.body71, label %while.end80

while.body71:                                     ; preds = %land.end
  store i32 0, i32* %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %while.body71
  %53 = load i8*, i8** %out.addr, align 4
  %54 = load i32, i32* %i, align 4
  %arrayidx72 = getelementptr inbounds i8, i8* %53, i32 %54
  %55 = load i8, i8* %arrayidx72, align 1
  %conv73 = sext i8 %55 to i32
  %cmp74 = icmp ne i32 %conv73, 0
  br i1 %cmp74, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %56 = load i8*, i8** %out.addr, align 4
  %57 = load i32, i32* %i, align 4
  %add76 = add i32 %57, 1
  %arrayidx77 = getelementptr inbounds i8, i8* %56, i32 %add76
  %58 = load i8, i8* %arrayidx77, align 1
  %59 = load i8*, i8** %out.addr, align 4
  %60 = load i32, i32* %i, align 4
  %arrayidx78 = getelementptr inbounds i8, i8* %59, i32 %60
  store i8 %58, i8* %arrayidx78, align 1
  br label %for.inc

for.inc:                                          ; preds = %for.body
  %61 = load i32, i32* %i, align 4
  %inc79 = add i32 %61, 1
  store i32 %inc79, i32* %i, align 4
  br label %for.cond

for.end:                                          ; preds = %for.cond
  br label %while.cond62

while.end80:                                      ; preds = %land.end
  %62 = load i8*, i8** %out.addr, align 4
  %63 = load i8, i8* %62, align 1
  %conv81 = sext i8 %63 to i32
  %cmp82 = icmp eq i32 %conv81, 46
  br i1 %cmp82, label %if.then84, label %if.end86

if.then84:                                        ; preds = %while.end80
  %64 = load i8*, i8** %out.addr, align 4
  %65 = load i8*, i8** %p, align 4
  call void @reverse(i8* %64, i8* %65)
  %66 = load i8*, i8** %p, align 4
  %incdec.ptr85 = getelementptr inbounds i8, i8* %66, i32 1
  store i8* %incdec.ptr85, i8** %p, align 4
  store i8 48, i8* %66, align 1
  %67 = load i8*, i8** %p, align 4
  store i8 0, i8* %67, align 1
  %68 = load i8*, i8** %out.addr, align 4
  %69 = load i8*, i8** %p, align 4
  call void @reverse(i8* %68, i8* %69)
  br label %if.end86

if.end86:                                         ; preds = %if.then84, %while.end80
  %70 = load i8*, i8** %out.addr, align 4
  call void @makeQuaterImaginary(%struct.QuaterImaginary* sret align 4 %agg.result, i8* %70)
  br label %return

return:                                           ; preds = %if.end86, %if.then
  ret void
}

; Function Attrs: nounwind readnone speculatable willreturn
declare double @llvm.ceil.f64(double %0) #4

; Function Attrs: noinline nounwind optnone
define hidden i32 @main() #0 {
entry:
  %retval = alloca i32, align 4
  %buffer = alloca [16 x i8], align 16
  %i = alloca i32, align 4
  %c1 = alloca %struct.Complex, align 8
  %qi = alloca %struct.QuaterImaginary, align 4
  %c2 = alloca %struct.Complex, align 8
  %tmp = alloca %struct.Complex, align 8
  %tmp3 = alloca %struct.QuaterImaginary, align 4
  %tmp5 = alloca %struct.Complex, align 8
  %c114 = alloca %struct.Complex, align 8
  %qi18 = alloca %struct.QuaterImaginary, align 4
  %c220 = alloca %struct.Complex, align 8
  %tmp24 = alloca %struct.Complex, align 8
  %tmp25 = alloca %struct.QuaterImaginary, align 4
  %tmp27 = alloca %struct.Complex, align 8
  store i32 0, i32* %retval, align 4
  store i32 1, i32* %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %0 = load i32, i32* %i, align 4
  %cmp = icmp sle i32 %0, 16
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %rel = getelementptr inbounds %struct.Complex, %struct.Complex* %c1, i32 0, i32 0
  %1 = load i32, i32* %i, align 4
  %conv = sitofp i32 %1 to double
  store double %conv, double* %rel, align 8
  %img = getelementptr inbounds %struct.Complex, %struct.Complex* %c1, i32 0, i32 1
  store double 0.000000e+00, double* %img, align 8
  %arraydecay = getelementptr inbounds [16 x i8], [16 x i8]* %buffer, i32 0, i32 0
  call void @c2qi(%struct.QuaterImaginary* sret align 4 %qi, %struct.Complex* byval(%struct.Complex) align 8 %c1, i8* %arraydecay)
  call void @qi2c(%struct.Complex* sret align 8 %c2, %struct.QuaterImaginary* byval(%struct.QuaterImaginary) align 4 %qi)
  call void @printComplex(%struct.Complex* byval(%struct.Complex) align 8 %c1)
  %call = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.4, i32 0, i32 0))
  call void @printQuaterImaginary(%struct.QuaterImaginary* byval(%struct.QuaterImaginary) align 4 %qi)
  %call1 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.4, i32 0, i32 0))
  call void @printComplex(%struct.Complex* byval(%struct.Complex) align 8 %c2)
  %call2 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([6 x i8], [6 x i8]* @.str.5, i32 0, i32 0))
  call void @negComplex(%struct.Complex* sret align 8 %tmp, %struct.Complex* byval(%struct.Complex) align 8 %c1)
  %2 = bitcast %struct.Complex* %c1 to i8*
  %3 = bitcast %struct.Complex* %tmp to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 8 %2, i8* align 8 %3, i32 16, i1 false)
  %arraydecay4 = getelementptr inbounds [16 x i8], [16 x i8]* %buffer, i32 0, i32 0
  call void @c2qi(%struct.QuaterImaginary* sret align 4 %tmp3, %struct.Complex* byval(%struct.Complex) align 8 %c1, i8* %arraydecay4)
  %4 = bitcast %struct.QuaterImaginary* %qi to i8*
  %5 = bitcast %struct.QuaterImaginary* %tmp3 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 4 %4, i8* align 4 %5, i32 8, i1 false)
  call void @qi2c(%struct.Complex* sret align 8 %tmp5, %struct.QuaterImaginary* byval(%struct.QuaterImaginary) align 4 %qi)
  %6 = bitcast %struct.Complex* %c2 to i8*
  %7 = bitcast %struct.Complex* %tmp5 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 8 %6, i8* align 8 %7, i32 16, i1 false)
  call void @printComplex(%struct.Complex* byval(%struct.Complex) align 8 %c1)
  %call6 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.4, i32 0, i32 0))
  call void @printQuaterImaginary(%struct.QuaterImaginary* byval(%struct.QuaterImaginary) align 4 %qi)
  %call7 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.4, i32 0, i32 0))
  call void @printComplex(%struct.Complex* byval(%struct.Complex) align 8 %c2)
  %call8 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([2 x i8], [2 x i8]* @.str.6, i32 0, i32 0))
  br label %for.inc

for.inc:                                          ; preds = %for.body
  %8 = load i32, i32* %i, align 4
  %inc = add nsw i32 %8, 1
  store i32 %inc, i32* %i, align 4
  br label %for.cond

for.end:                                          ; preds = %for.cond
  %call9 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([2 x i8], [2 x i8]* @.str.6, i32 0, i32 0))
  store i32 1, i32* %i, align 4
  br label %for.cond10

for.cond10:                                       ; preds = %for.inc31, %for.end
  %9 = load i32, i32* %i, align 4
  %cmp11 = icmp sle i32 %9, 16
  br i1 %cmp11, label %for.body13, label %for.end33

for.body13:                                       ; preds = %for.cond10
  %rel15 = getelementptr inbounds %struct.Complex, %struct.Complex* %c114, i32 0, i32 0
  store double 0.000000e+00, double* %rel15, align 8
  %img16 = getelementptr inbounds %struct.Complex, %struct.Complex* %c114, i32 0, i32 1
  %10 = load i32, i32* %i, align 4
  %conv17 = sitofp i32 %10 to double
  store double %conv17, double* %img16, align 8
  %arraydecay19 = getelementptr inbounds [16 x i8], [16 x i8]* %buffer, i32 0, i32 0
  call void @c2qi(%struct.QuaterImaginary* sret align 4 %qi18, %struct.Complex* byval(%struct.Complex) align 8 %c114, i8* %arraydecay19)
  call void @qi2c(%struct.Complex* sret align 8 %c220, %struct.QuaterImaginary* byval(%struct.QuaterImaginary) align 4 %qi18)
  call void @printComplex(%struct.Complex* byval(%struct.Complex) align 8 %c114)
  %call21 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.4, i32 0, i32 0))
  call void @printQuaterImaginary(%struct.QuaterImaginary* byval(%struct.QuaterImaginary) align 4 %qi18)
  %call22 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.4, i32 0, i32 0))
  call void @printComplex(%struct.Complex* byval(%struct.Complex) align 8 %c220)
  %call23 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([6 x i8], [6 x i8]* @.str.5, i32 0, i32 0))
  call void @negComplex(%struct.Complex* sret align 8 %tmp24, %struct.Complex* byval(%struct.Complex) align 8 %c114)
  %11 = bitcast %struct.Complex* %c114 to i8*
  %12 = bitcast %struct.Complex* %tmp24 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 8 %11, i8* align 8 %12, i32 16, i1 false)
  %arraydecay26 = getelementptr inbounds [16 x i8], [16 x i8]* %buffer, i32 0, i32 0
  call void @c2qi(%struct.QuaterImaginary* sret align 4 %tmp25, %struct.Complex* byval(%struct.Complex) align 8 %c114, i8* %arraydecay26)
  %13 = bitcast %struct.QuaterImaginary* %qi18 to i8*
  %14 = bitcast %struct.QuaterImaginary* %tmp25 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 4 %13, i8* align 4 %14, i32 8, i1 false)
  call void @qi2c(%struct.Complex* sret align 8 %tmp27, %struct.QuaterImaginary* byval(%struct.QuaterImaginary) align 4 %qi18)
  %15 = bitcast %struct.Complex* %c220 to i8*
  %16 = bitcast %struct.Complex* %tmp27 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 8 %15, i8* align 8 %16, i32 16, i1 false)
  call void @printComplex(%struct.Complex* byval(%struct.Complex) align 8 %c114)
  %call28 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.4, i32 0, i32 0))
  call void @printQuaterImaginary(%struct.QuaterImaginary* byval(%struct.QuaterImaginary) align 4 %qi18)
  %call29 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.4, i32 0, i32 0))
  call void @printComplex(%struct.Complex* byval(%struct.Complex) align 8 %c220)
  %call30 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([2 x i8], [2 x i8]* @.str.6, i32 0, i32 0))
  br label %for.inc31

for.inc31:                                        ; preds = %for.body13
  %17 = load i32, i32* %i, align 4
  %inc32 = add nsw i32 %17, 1
  store i32 %inc32, i32* %i, align 4
  br label %for.cond10

for.end33:                                        ; preds = %for.cond10
  ret i32 0
}

attributes #0 = { noinline nounwind optnone "correctly-rounded-divide-sqrt-fp-math"="false" "disable-tail-calls"="false" "frame-pointer"="none" "less-precise-fpmad"="false" "min-legal-vector-width"="0" "no-infs-fp-math"="false" "no-jump-tables"="false" "no-nans-fp-math"="false" "no-signed-zeros-fp-math"="false" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="generic" "unsafe-fp-math"="false" "use-soft-float"="false" }
attributes #1 = { "correctly-rounded-divide-sqrt-fp-math"="false" "disable-tail-calls"="false" "frame-pointer"="none" "less-precise-fpmad"="false" "no-infs-fp-math"="false" "no-nans-fp-math"="false" "no-signed-zeros-fp-math"="false" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="generic" "unsafe-fp-math"="false" "use-soft-float"="false" }
attributes #2 = { nounwind readonly "correctly-rounded-divide-sqrt-fp-math"="false" "disable-tail-calls"="false" "frame-pointer"="none" "less-precise-fpmad"="false" "no-infs-fp-math"="false" "no-nans-fp-math"="false" "no-signed-zeros-fp-math"="false" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="generic" "unsafe-fp-math"="false" "use-soft-float"="false" }
attributes #3 = { argmemonly nounwind willreturn }
attributes #4 = { nounwind readnone speculatable willreturn }
attributes #5 = { nounwind readonly }

!llvm.module.flags = !{!0}
!llvm.ident = !{!1}

!0 = !{i32 1, !"wchar_size", i32 4}
!1 = !{!"clang version 11.0.0 (https://github.com/Jacarte/llvm-project.git 0f6dea67136cc1e0b3d200eb2bb165628970c44b)"}

; extracted candidates
#########################################################
; exiting Souper's runOnFunction() for addComplex()

; entering Souper's runOnFunction() for mulComplex()

; ModuleID = './Imaginary_base_numbers.c.bc'
source_filename = "./Imaginary_base_numbers.c"
target datalayout = "e-m:e-p:32:32-i64:64-n32:64-S128"
target triple = "wasm32-unknown-wasi"

%struct.Complex = type { double, double }
%struct.QuaterImaginary = type { i8*, i32 }

@.str = private unnamed_addr constant [17 x i8] c"(%3.0f + %3.0fi)\00", align 1
@TWO_I = hidden constant %struct.Complex { double 0.000000e+00, double 2.000000e+00 }, align 8
@INV_TWO_I = hidden constant %struct.Complex { double 0.000000e+00, double -5.000000e-01 }, align 8
@.str.1 = private unnamed_addr constant [4 x i8] c"%8s\00", align 1
@.str.2 = private unnamed_addr constant [9 x i8] c" ERROR  \00", align 1
@.str.3 = private unnamed_addr constant [2 x i8] c"0\00", align 1
@.str.4 = private unnamed_addr constant [5 x i8] c" -> \00", align 1
@.str.5 = private unnamed_addr constant [6 x i8] c"     \00", align 1
@.str.6 = private unnamed_addr constant [2 x i8] c"\0A\00", align 1
@llvm.used = appending global [1 x i8*] [i8* bitcast (i32 ()* @__main_void to i8*)], section "llvm.metadata"

@__main_void = alias i32 (), i32 ()* @main

; Function Attrs: noinline nounwind optnone
define hidden i32 @find(i8* %s, i8 signext %c) #0 {
entry:
  %retval = alloca i32, align 4
  %s.addr = alloca i8*, align 4
  %c.addr = alloca i8, align 1
  %i = alloca i8*, align 4
  store i8* %s, i8** %s.addr, align 4
  store i8 %c, i8* %c.addr, align 1
  %0 = load i8*, i8** %s.addr, align 4
  store i8* %0, i8** %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %1 = load i8*, i8** %i, align 4
  %2 = load i8, i8* %1, align 1
  %conv = sext i8 %2 to i32
  %cmp = icmp ne i32 %conv, 0
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %3 = load i8*, i8** %i, align 4
  %4 = load i8, i8* %3, align 1
  %conv2 = sext i8 %4 to i32
  %5 = load i8, i8* %c.addr, align 1
  %conv3 = sext i8 %5 to i32
  %cmp4 = icmp eq i32 %conv2, %conv3
  br i1 %cmp4, label %if.then, label %if.end

if.then:                                          ; preds = %for.body
  %6 = load i8*, i8** %i, align 4
  %7 = load i8*, i8** %s.addr, align 4
  %sub.ptr.lhs.cast = ptrtoint i8* %6 to i32
  %sub.ptr.rhs.cast = ptrtoint i8* %7 to i32
  %sub.ptr.sub = sub i32 %sub.ptr.lhs.cast, %sub.ptr.rhs.cast
  store i32 %sub.ptr.sub, i32* %retval, align 4
  br label %return

if.end:                                           ; preds = %for.body
  br label %for.inc

for.inc:                                          ; preds = %if.end
  %8 = load i8*, i8** %i, align 4
  %incdec.ptr = getelementptr inbounds i8, i8* %8, i32 1
  store i8* %incdec.ptr, i8** %i, align 4
  br label %for.cond

for.end:                                          ; preds = %for.cond
  store i32 -1, i32* %retval, align 4
  br label %return

return:                                           ; preds = %for.end, %if.then
  %9 = load i32, i32* %retval, align 4
  ret i32 %9
}

; Function Attrs: noinline nounwind optnone
define hidden void @reverse(i8* %b, i8* %e) #0 {
entry:
  %b.addr = alloca i8*, align 4
  %e.addr = alloca i8*, align 4
  %t = alloca i8, align 1
  store i8* %b, i8** %b.addr, align 4
  store i8* %e, i8** %e.addr, align 4
  %0 = load i8*, i8** %e.addr, align 4
  %incdec.ptr = getelementptr inbounds i8, i8* %0, i32 -1
  store i8* %incdec.ptr, i8** %e.addr, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %1 = load i8*, i8** %b.addr, align 4
  %2 = load i8*, i8** %e.addr, align 4
  %cmp = icmp ult i8* %1, %2
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %3 = load i8*, i8** %b.addr, align 4
  %4 = load i8, i8* %3, align 1
  store i8 %4, i8* %t, align 1
  %5 = load i8*, i8** %e.addr, align 4
  %6 = load i8, i8* %5, align 1
  %7 = load i8*, i8** %b.addr, align 4
  store i8 %6, i8* %7, align 1
  %8 = load i8, i8* %t, align 1
  %9 = load i8*, i8** %e.addr, align 4
  store i8 %8, i8* %9, align 1
  br label %for.inc

for.inc:                                          ; preds = %for.body
  %10 = load i8*, i8** %b.addr, align 4
  %incdec.ptr1 = getelementptr inbounds i8, i8* %10, i32 1
  store i8* %incdec.ptr1, i8** %b.addr, align 4
  %11 = load i8*, i8** %e.addr, align 4
  %incdec.ptr2 = getelementptr inbounds i8, i8* %11, i32 -1
  store i8* %incdec.ptr2, i8** %e.addr, align 4
  br label %for.cond

for.end:                                          ; preds = %for.cond
  ret void
}

; Function Attrs: noinline nounwind optnone
define hidden void @printComplex(%struct.Complex* byval(%struct.Complex) align 8 %c) #0 {
entry:
  %rel = getelementptr inbounds %struct.Complex, %struct.Complex* %c, i32 0, i32 0
  %0 = load double, double* %rel, align 8
  %img = getelementptr inbounds %struct.Complex, %struct.Complex* %c, i32 0, i32 1
  %1 = load double, double* %img, align 8
  %call = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([17 x i8], [17 x i8]* @.str, i32 0, i32 0), double %0, double %1)
  ret void
}

declare i32 @printf(i8* %0, ...) #1

; Function Attrs: noinline nounwind optnone
define hidden void @makeComplex(%struct.Complex* noalias sret align 8 %agg.result, double %rel, double %img) #0 {
entry:
  %rel.addr = alloca double, align 8
  %img.addr = alloca double, align 8
  store double %rel, double* %rel.addr, align 8
  store double %img, double* %img.addr, align 8
  %rel1 = getelementptr inbounds %struct.Complex, %struct.Complex* %agg.result, i32 0, i32 0
  %0 = load double, double* %rel.addr, align 8
  store double %0, double* %rel1, align 8
  %img2 = getelementptr inbounds %struct.Complex, %struct.Complex* %agg.result, i32 0, i32 1
  %1 = load double, double* %img.addr, align 8
  store double %1, double* %img2, align 8
  ret void
}

; Function Attrs: noinline nounwind optnone
define hidden void @addComplex(%struct.Complex* noalias sret align 8 %agg.result, %struct.Complex* byval(%struct.Complex) align 8 %a, %struct.Complex* byval(%struct.Complex) align 8 %b) #0 {
entry:
  %rel = getelementptr inbounds %struct.Complex, %struct.Complex* %agg.result, i32 0, i32 0
  %rel1 = getelementptr inbounds %struct.Complex, %struct.Complex* %a, i32 0, i32 0
  %0 = load double, double* %rel1, align 8
  %rel2 = getelementptr inbounds %struct.Complex, %struct.Complex* %b, i32 0, i32 0
  %1 = load double, double* %rel2, align 8
  %add = fadd double %0, %1
  store double %add, double* %rel, align 8
  %img = getelementptr inbounds %struct.Complex, %struct.Complex* %agg.result, i32 0, i32 1
  %img3 = getelementptr inbounds %struct.Complex, %struct.Complex* %a, i32 0, i32 1
  %2 = load double, double* %img3, align 8
  %img4 = getelementptr inbounds %struct.Complex, %struct.Complex* %b, i32 0, i32 1
  %3 = load double, double* %img4, align 8
  %add5 = fadd double %2, %3
  store double %add5, double* %img, align 8
  ret void
}

; Function Attrs: noinline nounwind optnone
define hidden void @mulComplex(%struct.Complex* noalias sret align 8 %agg.result, %struct.Complex* byval(%struct.Complex) align 8 %a, %struct.Complex* byval(%struct.Complex) align 8 %b) #0 {
entry:
  %rel = getelementptr inbounds %struct.Complex, %struct.Complex* %agg.result, i32 0, i32 0
  %rel1 = getelementptr inbounds %struct.Complex, %struct.Complex* %a, i32 0, i32 0
  %0 = load double, double* %rel1, align 8
  %rel2 = getelementptr inbounds %struct.Complex, %struct.Complex* %b, i32 0, i32 0
  %1 = load double, double* %rel2, align 8
  %mul = fmul double %0, %1
  %img = getelementptr inbounds %struct.Complex, %struct.Complex* %a, i32 0, i32 1
  %2 = load double, double* %img, align 8
  %img3 = getelementptr inbounds %struct.Complex, %struct.Complex* %b, i32 0, i32 1
  %3 = load double, double* %img3, align 8
  %mul4 = fmul double %2, %3
  %sub = fsub double %mul, %mul4
  store double %sub, double* %rel, align 8
  %img5 = getelementptr inbounds %struct.Complex, %struct.Complex* %agg.result, i32 0, i32 1
  %rel6 = getelementptr inbounds %struct.Complex, %struct.Complex* %a, i32 0, i32 0
  %4 = load double, double* %rel6, align 8
  %img7 = getelementptr inbounds %struct.Complex, %struct.Complex* %b, i32 0, i32 1
  %5 = load double, double* %img7, align 8
  %mul8 = fmul double %4, %5
  %img9 = getelementptr inbounds %struct.Complex, %struct.Complex* %a, i32 0, i32 1
  %6 = load double, double* %img9, align 8
  %rel10 = getelementptr inbounds %struct.Complex, %struct.Complex* %b, i32 0, i32 0
  %7 = load double, double* %rel10, align 8
  %mul11 = fmul double %6, %7
  %sub12 = fsub double %mul8, %mul11
  store double %sub12, double* %img5, align 8
  ret void
}

; Function Attrs: noinline nounwind optnone
define hidden void @mulComplexD(%struct.Complex* noalias sret align 8 %agg.result, %struct.Complex* byval(%struct.Complex) align 8 %a, double %b) #0 {
entry:
  %b.addr = alloca double, align 8
  store double %b, double* %b.addr, align 8
  %rel = getelementptr inbounds %struct.Complex, %struct.Complex* %agg.result, i32 0, i32 0
  %rel1 = getelementptr inbounds %struct.Complex, %struct.Complex* %a, i32 0, i32 0
  %0 = load double, double* %rel1, align 8
  %1 = load double, double* %b.addr, align 8
  %mul = fmul double %0, %1
  store double %mul, double* %rel, align 8
  %img = getelementptr inbounds %struct.Complex, %struct.Complex* %agg.result, i32 0, i32 1
  %img2 = getelementptr inbounds %struct.Complex, %struct.Complex* %a, i32 0, i32 1
  %2 = load double, double* %img2, align 8
  %3 = load double, double* %b.addr, align 8
  %mul3 = fmul double %2, %3
  store double %mul3, double* %img, align 8
  ret void
}

; Function Attrs: noinline nounwind optnone
define hidden void @negComplex(%struct.Complex* noalias sret align 8 %agg.result, %struct.Complex* byval(%struct.Complex) align 8 %a) #0 {
entry:
  call void @mulComplexD(%struct.Complex* sret align 8 %agg.result, %struct.Complex* byval(%struct.Complex) align 8 %a, double -1.000000e+00)
  ret void
}

; Function Attrs: noinline nounwind optnone
define hidden void @divComplex(%struct.Complex* noalias sret align 8 %agg.result, %struct.Complex* byval(%struct.Complex) align 8 %a, %struct.Complex* byval(%struct.Complex) align 8 %b) #0 {
entry:
  %re = alloca double, align 8
  %im = alloca double, align 8
  %d = alloca double, align 8
  %rel = getelementptr inbounds %struct.Complex, %struct.Complex* %a, i32 0, i32 0
  %0 = load double, double* %rel, align 8
  %rel1 = getelementptr inbounds %struct.Complex, %struct.Complex* %b, i32 0, i32 0
  %1 = load double, double* %rel1, align 8
  %mul = fmul double %0, %1
  %img = getelementptr inbounds %struct.Complex, %struct.Complex* %a, i32 0, i32 1
  %2 = load double, double* %img, align 8
  %img2 = getelementptr inbounds %struct.Complex, %struct.Complex* %b, i32 0, i32 1
  %3 = load double, double* %img2, align 8
  %mul3 = fmul double %2, %3
  %add = fadd double %mul, %mul3
  store double %add, double* %re, align 8
  %img4 = getelementptr inbounds %struct.Complex, %struct.Complex* %a, i32 0, i32 1
  %4 = load double, double* %img4, align 8
  %rel5 = getelementptr inbounds %struct.Complex, %struct.Complex* %b, i32 0, i32 0
  %5 = load double, double* %rel5, align 8
  %mul6 = fmul double %4, %5
  %rel7 = getelementptr inbounds %struct.Complex, %struct.Complex* %a, i32 0, i32 0
  %6 = load double, double* %rel7, align 8
  %img8 = getelementptr inbounds %struct.Complex, %struct.Complex* %b, i32 0, i32 1
  %7 = load double, double* %img8, align 8
  %mul9 = fmul double %6, %7
  %sub = fsub double %mul6, %mul9
  store double %sub, double* %im, align 8
  %rel10 = getelementptr inbounds %struct.Complex, %struct.Complex* %b, i32 0, i32 0
  %8 = load double, double* %rel10, align 8
  %rel11 = getelementptr inbounds %struct.Complex, %struct.Complex* %b, i32 0, i32 0
  %9 = load double, double* %rel11, align 8
  %mul12 = fmul double %8, %9
  %img13 = getelementptr inbounds %struct.Complex, %struct.Complex* %b, i32 0, i32 1
  %10 = load double, double* %img13, align 8
  %img14 = getelementptr inbounds %struct.Complex, %struct.Complex* %b, i32 0, i32 1
  %11 = load double, double* %img14, align 8
  %mul15 = fmul double %10, %11
  %add16 = fadd double %mul12, %mul15
  store double %add16, double* %d, align 8
  %rel17 = getelementptr inbounds %struct.Complex, %struct.Complex* %agg.result, i32 0, i32 0
  %12 = load double, double* %re, align 8
  %13 = load double, double* %d, align 8
  %div = fdiv double %12, %13
  store double %div, double* %rel17, align 8
  %img18 = getelementptr inbounds %struct.Complex, %struct.Complex* %agg.result, i32 0, i32 1
  %14 = load double, double* %im, align 8
  %15 = load double, double* %d, align 8
  %div19 = fdiv double %14, %15
  store double %div19, double* %img18, align 8
  ret void
}

; Function Attrs: noinline nounwind optnone
define hidden void @inv(%struct.Complex* noalias sret align 8 %agg.result, %struct.Complex* byval(%struct.Complex) align 8 %c) #0 {
entry:
  %d = alloca double, align 8
  %rel = getelementptr inbounds %struct.Complex, %struct.Complex* %c, i32 0, i32 0
  %0 = load double, double* %rel, align 8
  %rel1 = getelementptr inbounds %struct.Complex, %struct.Complex* %c, i32 0, i32 0
  %1 = load double, double* %rel1, align 8
  %mul = fmul double %0, %1
  %img = getelementptr inbounds %struct.Complex, %struct.Complex* %c, i32 0, i32 1
  %2 = load double, double* %img, align 8
  %img2 = getelementptr inbounds %struct.Complex, %struct.Complex* %c, i32 0, i32 1
  %3 = load double, double* %img2, align 8
  %mul3 = fmul double %2, %3
  %add = fadd double %mul, %mul3
  store double %add, double* %d, align 8
  %rel4 = getelementptr inbounds %struct.Complex, %struct.Complex* %agg.result, i32 0, i32 0
  %rel5 = getelementptr inbounds %struct.Complex, %struct.Complex* %c, i32 0, i32 0
  %4 = load double, double* %rel5, align 8
  %5 = load double, double* %d, align 8
  %div = fdiv double %4, %5
  store double %div, double* %rel4, align 8
  %img6 = getelementptr inbounds %struct.Complex, %struct.Complex* %agg.result, i32 0, i32 1
  %img7 = getelementptr inbounds %struct.Complex, %struct.Complex* %c, i32 0, i32 1
  %6 = load double, double* %img7, align 8
  %fneg = fneg double %6
  %7 = load double, double* %d, align 8
  %div8 = fdiv double %fneg, %7
  store double %div8, double* %img6, align 8
  ret void
}

; Function Attrs: noinline nounwind optnone
define hidden void @makeQuaterImaginary(%struct.QuaterImaginary* noalias sret align 4 %agg.result, i8* %s) #0 {
entry:
  %s.addr = alloca i8*, align 4
  %i = alloca i32, align 4
  %valid1 = alloca i32, align 4
  %cnt = alloca i32, align 4
  store i8* %s, i8** %s.addr, align 4
  %b2i = getelementptr inbounds %struct.QuaterImaginary, %struct.QuaterImaginary* %agg.result, i32 0, i32 0
  %0 = load i8*, i8** %s.addr, align 4
  store i8* %0, i8** %b2i, align 4
  %valid = getelementptr inbounds %struct.QuaterImaginary, %struct.QuaterImaginary* %agg.result, i32 0, i32 1
  store i32 0, i32* %valid, align 4
  store i32 1, i32* %valid1, align 4
  store i32 0, i32* %cnt, align 4
  %1 = load i8*, i8** %s.addr, align 4
  %2 = load i8, i8* %1, align 1
  %conv = sext i8 %2 to i32
  %cmp = icmp ne i32 %conv, 0
  br i1 %cmp, label %if.then, label %if.end26

if.then:                                          ; preds = %entry
  store i32 0, i32* %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.then
  %3 = load i8*, i8** %s.addr, align 4
  %4 = load i32, i32* %i, align 4
  %arrayidx = getelementptr inbounds i8, i8* %3, i32 %4
  %5 = load i8, i8* %arrayidx, align 1
  %conv3 = sext i8 %5 to i32
  %cmp4 = icmp ne i32 %conv3, 0
  br i1 %cmp4, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %6 = load i8*, i8** %s.addr, align 4
  %7 = load i32, i32* %i, align 4
  %arrayidx6 = getelementptr inbounds i8, i8* %6, i32 %7
  %8 = load i8, i8* %arrayidx6, align 1
  %conv7 = sext i8 %8 to i32
  %cmp8 = icmp slt i32 %conv7, 48
  br i1 %cmp8, label %if.then14, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %for.body
  %9 = load i8*, i8** %s.addr, align 4
  %10 = load i32, i32* %i, align 4
  %arrayidx10 = getelementptr inbounds i8, i8* %9, i32 %10
  %11 = load i8, i8* %arrayidx10, align 1
  %conv11 = sext i8 %11 to i32
  %cmp12 = icmp slt i32 51, %conv11
  br i1 %cmp12, label %if.then14, label %if.end20

if.then14:                                        ; preds = %lor.lhs.false, %for.body
  %12 = load i8*, i8** %s.addr, align 4
  %13 = load i32, i32* %i, align 4
  %arrayidx15 = getelementptr inbounds i8, i8* %12, i32 %13
  %14 = load i8, i8* %arrayidx15, align 1
  %conv16 = sext i8 %14 to i32
  %cmp17 = icmp eq i32 %conv16, 46
  br i1 %cmp17, label %if.then19, label %if.else

if.then19:                                        ; preds = %if.then14
  %15 = load i32, i32* %cnt, align 4
  %inc = add i32 %15, 1
  store i32 %inc, i32* %cnt, align 4
  br label %if.end

if.else:                                          ; preds = %if.then14
  store i32 0, i32* %valid1, align 4
  br label %for.end

if.end:                                           ; preds = %if.then19
  br label %if.end20

if.end20:                                         ; preds = %if.end, %lor.lhs.false
  br label %for.inc

for.inc:                                          ; preds = %if.end20
  %16 = load i32, i32* %i, align 4
  %inc21 = add i32 %16, 1
  store i32 %inc21, i32* %i, align 4
  br label %for.cond

for.end:                                          ; preds = %if.else, %for.cond
  %17 = load i32, i32* %valid1, align 4
  %tobool = icmp ne i32 %17, 0
  br i1 %tobool, label %land.lhs.true, label %if.end25

land.lhs.true:                                    ; preds = %for.end
  %18 = load i32, i32* %cnt, align 4
  %cmp22 = icmp ugt i32 %18, 1
  br i1 %cmp22, label %if.then24, label %if.end25

if.then24:                                        ; preds = %land.lhs.true
  store i32 0, i32* %valid1, align 4
  br label %if.end25

if.end25:                                         ; preds = %if.then24, %land.lhs.true, %for.end
  br label %if.end26

if.end26:                                         ; preds = %if.end25, %entry
  %19 = load i32, i32* %valid1, align 4
  %valid27 = getelementptr inbounds %struct.QuaterImaginary, %struct.QuaterImaginary* %agg.result, i32 0, i32 1
  store i32 %19, i32* %valid27, align 4
  ret void
}

; Function Attrs: noinline nounwind optnone
define hidden void @printQuaterImaginary(%struct.QuaterImaginary* byval(%struct.QuaterImaginary) align 4 %qi) #0 {
entry:
  %valid = getelementptr inbounds %struct.QuaterImaginary, %struct.QuaterImaginary* %qi, i32 0, i32 1
  %0 = load i32, i32* %valid, align 4
  %tobool = icmp ne i32 %0, 0
  br i1 %tobool, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  %b2i = getelementptr inbounds %struct.QuaterImaginary, %struct.QuaterImaginary* %qi, i32 0, i32 0
  %1 = load i8*, i8** %b2i, align 4
  %call = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([4 x i8], [4 x i8]* @.str.1, i32 0, i32 0), i8* %1)
  br label %if.end

if.else:                                          ; preds = %entry
  %call1 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([9 x i8], [9 x i8]* @.str.2, i32 0, i32 0))
  br label %if.end

if.end:                                           ; preds = %if.else, %if.then
  ret void
}

; Function Attrs: noinline nounwind optnone
define hidden void @qi2c(%struct.Complex* noalias sret align 8 %agg.result, %struct.QuaterImaginary* byval(%struct.QuaterImaginary) align 4 %qi) #0 {
entry:
  %len = alloca i32, align 4
  %pointPos = alloca i32, align 4
  %posLen = alloca i32, align 4
  %prod = alloca %struct.Complex, align 8
  %j = alloca i32, align 4
  %k = alloca double, align 8
  %tmp = alloca %struct.Complex, align 8
  %agg.tmp = alloca %struct.Complex, align 8
  %tmp10 = alloca %struct.Complex, align 8
  %k18 = alloca double, align 8
  %tmp27 = alloca %struct.Complex, align 8
  %agg.tmp28 = alloca %struct.Complex, align 8
  %tmp30 = alloca %struct.Complex, align 8
  %b2i = getelementptr inbounds %struct.QuaterImaginary, %struct.QuaterImaginary* %qi, i32 0, i32 0
  %0 = load i8*, i8** %b2i, align 4
  %call = call i32 @strlen(i8* %0) #5
  store i32 %call, i32* %len, align 4
  %b2i1 = getelementptr inbounds %struct.QuaterImaginary, %struct.QuaterImaginary* %qi, i32 0, i32 0
  %1 = load i8*, i8** %b2i1, align 4
  %call2 = call i32 @find(i8* %1, i8 signext 46)
  store i32 %call2, i32* %pointPos, align 4
  %2 = load i32, i32* %pointPos, align 4
  %cmp = icmp sgt i32 %2, 0
  br i1 %cmp, label %cond.true, label %cond.false

cond.true:                                        ; preds = %entry
  %3 = load i32, i32* %pointPos, align 4
  br label %cond.end

cond.false:                                       ; preds = %entry
  %4 = load i32, i32* %len, align 4
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi i32 [ %3, %cond.true ], [ %4, %cond.false ]
  store i32 %cond, i32* %posLen, align 4
  call void @makeComplex(%struct.Complex* sret align 8 %agg.result, double 0.000000e+00, double 0.000000e+00)
  call void @makeComplex(%struct.Complex* sret align 8 %prod, double 1.000000e+00, double 0.000000e+00)
  store i32 0, i32* %j, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %cond.end
  %5 = load i32, i32* %j, align 4
  %6 = load i32, i32* %posLen, align 4
  %cmp3 = icmp ult i32 %5, %6
  br i1 %cmp3, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %b2i4 = getelementptr inbounds %struct.QuaterImaginary, %struct.QuaterImaginary* %qi, i32 0, i32 0
  %7 = load i8*, i8** %b2i4, align 4
  %8 = load i32, i32* %posLen, align 4
  %sub = sub i32 %8, 1
  %9 = load i32, i32* %j, align 4
  %sub5 = sub i32 %sub, %9
  %arrayidx = getelementptr inbounds i8, i8* %7, i32 %sub5
  %10 = load i8, i8* %arrayidx, align 1
  %conv = sext i8 %10 to i32
  %sub6 = sub nsw i32 %conv, 48
  %conv7 = sitofp i32 %sub6 to double
  store double %conv7, double* %k, align 8
  %11 = load double, double* %k, align 8
  %cmp8 = fcmp ogt double %11, 0.000000e+00
  br i1 %cmp8, label %if.then, label %if.end

if.then:                                          ; preds = %for.body
  %12 = load double, double* %k, align 8
  call void @mulComplexD(%struct.Complex* sret align 8 %agg.tmp, %struct.Complex* byval(%struct.Complex) align 8 %prod, double %12)
  call void @addComplex(%struct.Complex* sret align 8 %tmp, %struct.Complex* byval(%struct.Complex) align 8 %agg.result, %struct.Complex* byval(%struct.Complex) align 8 %agg.tmp)
  %13 = bitcast %struct.Complex* %agg.result to i8*
  %14 = bitcast %struct.Complex* %tmp to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 8 %13, i8* align 8 %14, i32 16, i1 false)
  br label %if.end

if.end:                                           ; preds = %if.then, %for.body
  call void @mulComplex(%struct.Complex* sret align 8 %tmp10, %struct.Complex* byval(%struct.Complex) align 8 %prod, %struct.Complex* byval(%struct.Complex) align 8 @TWO_I)
  %15 = bitcast %struct.Complex* %prod to i8*
  %16 = bitcast %struct.Complex* %tmp10 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 8 %15, i8* align 8 %16, i32 16, i1 false)
  br label %for.inc

for.inc:                                          ; preds = %if.end
  %17 = load i32, i32* %j, align 4
  %inc = add i32 %17, 1
  store i32 %inc, i32* %j, align 4
  br label %for.cond

for.end:                                          ; preds = %for.cond
  %18 = load i32, i32* %pointPos, align 4
  %cmp11 = icmp ne i32 %18, -1
  br i1 %cmp11, label %if.then13, label %if.end34

if.then13:                                        ; preds = %for.end
  %19 = bitcast %struct.Complex* %prod to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 8 %19, i8* align 8 bitcast (%struct.Complex* @INV_TWO_I to i8*), i32 16, i1 false)
  %20 = load i32, i32* %posLen, align 4
  %add = add i32 %20, 1
  store i32 %add, i32* %j, align 4
  br label %for.cond14

for.cond14:                                       ; preds = %for.inc31, %if.then13
  %21 = load i32, i32* %j, align 4
  %22 = load i32, i32* %len, align 4
  %cmp15 = icmp ult i32 %21, %22
  br i1 %cmp15, label %for.body17, label %for.end33

for.body17:                                       ; preds = %for.cond14
  %b2i19 = getelementptr inbounds %struct.QuaterImaginary, %struct.QuaterImaginary* %qi, i32 0, i32 0
  %23 = load i8*, i8** %b2i19, align 4
  %24 = load i32, i32* %j, align 4
  %arrayidx20 = getelementptr inbounds i8, i8* %23, i32 %24
  %25 = load i8, i8* %arrayidx20, align 1
  %conv21 = sext i8 %25 to i32
  %sub22 = sub nsw i32 %conv21, 48
  %conv23 = sitofp i32 %sub22 to double
  store double %conv23, double* %k18, align 8
  %26 = load double, double* %k18, align 8
  %cmp24 = fcmp ogt double %26, 0.000000e+00
  br i1 %cmp24, label %if.then26, label %if.end29

if.then26:                                        ; preds = %for.body17
  %27 = load double, double* %k18, align 8
  call void @mulComplexD(%struct.Complex* sret align 8 %agg.tmp28, %struct.Complex* byval(%struct.Complex) align 8 %prod, double %27)
  call void @addComplex(%struct.Complex* sret align 8 %tmp27, %struct.Complex* byval(%struct.Complex) align 8 %agg.result, %struct.Complex* byval(%struct.Complex) align 8 %agg.tmp28)
  %28 = bitcast %struct.Complex* %agg.result to i8*
  %29 = bitcast %struct.Complex* %tmp27 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 8 %28, i8* align 8 %29, i32 16, i1 false)
  br label %if.end29

if.end29:                                         ; preds = %if.then26, %for.body17
  call void @mulComplex(%struct.Complex* sret align 8 %tmp30, %struct.Complex* byval(%struct.Complex) align 8 %prod, %struct.Complex* byval(%struct.Complex) align 8 @INV_TWO_I)
  %30 = bitcast %struct.Complex* %prod to i8*
  %31 = bitcast %struct.Complex* %tmp30 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 8 %30, i8* align 8 %31, i32 16, i1 false)
  br label %for.inc31

for.inc31:                                        ; preds = %if.end29
  %32 = load i32, i32* %j, align 4
  %inc32 = add i32 %32, 1
  store i32 %inc32, i32* %j, align 4
  br label %for.cond14

for.end33:                                        ; preds = %for.cond14
  br label %if.end34

if.end34:                                         ; preds = %for.end33, %for.end
  ret void
}

; Function Attrs: nounwind readonly
declare i32 @strlen(i8* %0) #2

; Function Attrs: argmemonly nounwind willreturn
declare void @llvm.memcpy.p0i8.p0i8.i32(i8* noalias nocapture writeonly %0, i8* noalias nocapture readonly %1, i32 %2, i1 immarg %3) #3

; Function Attrs: noinline nounwind optnone
define hidden void @c2qi(%struct.QuaterImaginary* noalias sret align 4 %agg.result, %struct.Complex* byval(%struct.Complex) align 8 %c, i8* %out) #0 {
entry:
  %out.addr = alloca i8*, align 4
  %p = alloca i8*, align 4
  %re = alloca i32, align 4
  %im = alloca i32, align 4
  %fi = alloca i32, align 4
  %rem = alloca i32, align 4
  %index = alloca i32, align 4
  %fc = alloca %struct.Complex, align 8
  %.compoundliteral = alloca %struct.Complex, align 8
  %.compoundliteral21 = alloca %struct.Complex, align 8
  %f = alloca double, align 8
  %rem31 = alloca i32, align 4
  %i = alloca i32, align 4
  store i8* %out, i8** %out.addr, align 4
  %0 = load i8*, i8** %out.addr, align 4
  store i8* %0, i8** %p, align 4
  %1 = load i8*, i8** %p, align 4
  store i8 0, i8* %1, align 1
  %rel = getelementptr inbounds %struct.Complex, %struct.Complex* %c, i32 0, i32 0
  %2 = load double, double* %rel, align 8
  %cmp = fcmp oeq double %2, 0.000000e+00
  br i1 %cmp, label %land.lhs.true, label %if.end

land.lhs.true:                                    ; preds = %entry
  %img = getelementptr inbounds %struct.Complex, %struct.Complex* %c, i32 0, i32 1
  %3 = load double, double* %img, align 8
  %cmp1 = fcmp oeq double %3, 0.000000e+00
  br i1 %cmp1, label %if.then, label %if.end

if.then:                                          ; preds = %land.lhs.true
  call void @makeQuaterImaginary(%struct.QuaterImaginary* sret align 4 %agg.result, i8* getelementptr inbounds ([2 x i8], [2 x i8]* @.str.3, i32 0, i32 0))
  br label %return

if.end:                                           ; preds = %land.lhs.true, %entry
  %rel2 = getelementptr inbounds %struct.Complex, %struct.Complex* %c, i32 0, i32 0
  %4 = load double, double* %rel2, align 8
  %conv = fptosi double %4 to i32
  store i32 %conv, i32* %re, align 4
  %img3 = getelementptr inbounds %struct.Complex, %struct.Complex* %c, i32 0, i32 1
  %5 = load double, double* %img3, align 8
  %conv4 = fptosi double %5 to i32
  store i32 %conv4, i32* %im, align 4
  store i32 -1, i32* %fi, align 4
  br label %while.cond

while.cond:                                       ; preds = %if.end11, %if.end
  %6 = load i32, i32* %re, align 4
  %cmp5 = icmp ne i32 %6, 0
  br i1 %cmp5, label %while.body, label %while.end

while.body:                                       ; preds = %while.cond
  %7 = load i32, i32* %re, align 4
  %rem7 = srem i32 %7, -4
  store i32 %rem7, i32* %rem, align 4
  %8 = load i32, i32* %re, align 4
  %div = sdiv i32 %8, -4
  store i32 %div, i32* %re, align 4
  %9 = load i32, i32* %rem, align 4
  %cmp8 = icmp slt i32 %9, 0
  br i1 %cmp8, label %if.then10, label %if.end11

if.then10:                                        ; preds = %while.body
  %10 = load i32, i32* %rem, align 4
  %add = add nsw i32 %10, 4
  store i32 %add, i32* %rem, align 4
  %11 = load i32, i32* %re, align 4
  %inc = add nsw i32 %11, 1
  store i32 %inc, i32* %re, align 4
  br label %if.end11

if.end11:                                         ; preds = %if.then10, %while.body
  %12 = load i32, i32* %rem, align 4
  %add12 = add nsw i32 %12, 48
  %conv13 = trunc i32 %add12 to i8
  %13 = load i8*, i8** %p, align 4
  %incdec.ptr = getelementptr inbounds i8, i8* %13, i32 1
  store i8* %incdec.ptr, i8** %p, align 4
  store i8 %conv13, i8* %13, align 1
  %14 = load i8*, i8** %p, align 4
  %incdec.ptr14 = getelementptr inbounds i8, i8* %14, i32 1
  store i8* %incdec.ptr14, i8** %p, align 4
  store i8 48, i8* %14, align 1
  %15 = load i8*, i8** %p, align 4
  store i8 0, i8* %15, align 1
  br label %while.cond

while.end:                                        ; preds = %while.cond
  %16 = load i32, i32* %im, align 4
  %cmp15 = icmp ne i32 %16, 0
  br i1 %cmp15, label %if.then17, label %if.end53

if.then17:                                        ; preds = %while.end
  store i32 1, i32* %index, align 4
  %rel18 = getelementptr inbounds %struct.Complex, %struct.Complex* %.compoundliteral, i32 0, i32 0
  store double 0.000000e+00, double* %rel18, align 8
  %img19 = getelementptr inbounds %struct.Complex, %struct.Complex* %.compoundliteral, i32 0, i32 1
  %img20 = getelementptr inbounds %struct.Complex, %struct.Complex* %c, i32 0, i32 1
  %17 = load double, double* %img20, align 8
  store double %17, double* %img19, align 8
  %rel22 = getelementptr inbounds %struct.Complex, %struct.Complex* %.compoundliteral21, i32 0, i32 0
  store double 0.000000e+00, double* %rel22, align 8
  %img23 = getelementptr inbounds %struct.Complex, %struct.Complex* %.compoundliteral21, i32 0, i32 1
  store double 2.000000e+00, double* %img23, align 8
  call void @divComplex(%struct.Complex* sret align 8 %fc, %struct.Complex* byval(%struct.Complex) align 8 %.compoundliteral, %struct.Complex* byval(%struct.Complex) align 8 %.compoundliteral21)
  %rel24 = getelementptr inbounds %struct.Complex, %struct.Complex* %fc, i32 0, i32 0
  %18 = load double, double* %rel24, align 8
  store double %18, double* %f, align 8
  %19 = load double, double* %f, align 8
  %20 = call double @llvm.ceil.f64(double %19)
  %conv25 = fptosi double %20 to i32
  store i32 %conv25, i32* %im, align 4
  %21 = load double, double* %f, align 8
  %22 = load i32, i32* %im, align 4
  %conv26 = sitofp i32 %22 to double
  %sub = fsub double %21, %conv26
  %mul = fmul double -4.000000e+00, %sub
  store double %mul, double* %f, align 8
  br label %while.cond27

while.cond27:                                     ; preds = %if.end49, %if.then17
  %23 = load i32, i32* %im, align 4
  %cmp28 = icmp ne i32 %23, 0
  br i1 %cmp28, label %while.body30, label %while.end51

while.body30:                                     ; preds = %while.cond27
  %24 = load i32, i32* %im, align 4
  %rem32 = srem i32 %24, -4
  store i32 %rem32, i32* %rem31, align 4
  %25 = load i32, i32* %im, align 4
  %div33 = sdiv i32 %25, -4
  store i32 %div33, i32* %im, align 4
  %26 = load i32, i32* %rem31, align 4
  %cmp34 = icmp slt i32 %26, 0
  br i1 %cmp34, label %if.then36, label %if.end39

if.then36:                                        ; preds = %while.body30
  %27 = load i32, i32* %rem31, align 4
  %add37 = add nsw i32 %27, 4
  store i32 %add37, i32* %rem31, align 4
  %28 = load i32, i32* %im, align 4
  %inc38 = add nsw i32 %28, 1
  store i32 %inc38, i32* %im, align 4
  br label %if.end39

if.end39:                                         ; preds = %if.then36, %while.body30
  %29 = load i32, i32* %index, align 4
  %30 = load i8*, i8** %p, align 4
  %31 = load i8*, i8** %out.addr, align 4
  %sub.ptr.lhs.cast = ptrtoint i8* %30 to i32
  %sub.ptr.rhs.cast = ptrtoint i8* %31 to i32
  %sub.ptr.sub = sub i32 %sub.ptr.lhs.cast, %sub.ptr.rhs.cast
  %cmp40 = icmp ult i32 %29, %sub.ptr.sub
  br i1 %cmp40, label %if.then42, label %if.else

if.then42:                                        ; preds = %if.end39
  %32 = load i32, i32* %rem31, align 4
  %add43 = add nsw i32 %32, 48
  %conv44 = trunc i32 %add43 to i8
  %33 = load i8*, i8** %out.addr, align 4
  %34 = load i32, i32* %index, align 4
  %arrayidx = getelementptr inbounds i8, i8* %33, i32 %34
  store i8 %conv44, i8* %arrayidx, align 1
  br label %if.end49

if.else:                                          ; preds = %if.end39
  %35 = load i8*, i8** %p, align 4
  %incdec.ptr45 = getelementptr inbounds i8, i8* %35, i32 1
  store i8* %incdec.ptr45, i8** %p, align 4
  store i8 48, i8* %35, align 1
  %36 = load i32, i32* %rem31, align 4
  %add46 = add nsw i32 %36, 48
  %conv47 = trunc i32 %add46 to i8
  %37 = load i8*, i8** %p, align 4
  %incdec.ptr48 = getelementptr inbounds i8, i8* %37, i32 1
  store i8* %incdec.ptr48, i8** %p, align 4
  store i8 %conv47, i8* %37, align 1
  %38 = load i8*, i8** %p, align 4
  store i8 0, i8* %38, align 1
  br label %if.end49

if.end49:                                         ; preds = %if.else, %if.then42
  %39 = load i32, i32* %index, align 4
  %add50 = add i32 %39, 2
  store i32 %add50, i32* %index, align 4
  br label %while.cond27

while.end51:                                      ; preds = %while.cond27
  %40 = load double, double* %f, align 8
  %conv52 = fptosi double %40 to i32
  store i32 %conv52, i32* %fi, align 4
  br label %if.end53

if.end53:                                         ; preds = %while.end51, %while.end
  %41 = load i8*, i8** %out.addr, align 4
  %42 = load i8*, i8** %p, align 4
  call void @reverse(i8* %41, i8* %42)
  %43 = load i32, i32* %fi, align 4
  %cmp54 = icmp ne i32 %43, -1
  br i1 %cmp54, label %if.then56, label %if.end61

if.then56:                                        ; preds = %if.end53
  %44 = load i8*, i8** %p, align 4
  %incdec.ptr57 = getelementptr inbounds i8, i8* %44, i32 1
  store i8* %incdec.ptr57, i8** %p, align 4
  store i8 46, i8* %44, align 1
  %45 = load i32, i32* %fi, align 4
  %add58 = add nsw i32 %45, 48
  %conv59 = trunc i32 %add58 to i8
  %46 = load i8*, i8** %p, align 4
  %incdec.ptr60 = getelementptr inbounds i8, i8* %46, i32 1
  store i8* %incdec.ptr60, i8** %p, align 4
  store i8 %conv59, i8* %46, align 1
  %47 = load i8*, i8** %p, align 4
  store i8 0, i8* %47, align 1
  br label %if.end61

if.end61:                                         ; preds = %if.then56, %if.end53
  br label %while.cond62

while.cond62:                                     ; preds = %for.end, %if.end61
  %48 = load i8*, i8** %out.addr, align 4
  %arrayidx63 = getelementptr inbounds i8, i8* %48, i32 0
  %49 = load i8, i8* %arrayidx63, align 1
  %conv64 = sext i8 %49 to i32
  %cmp65 = icmp eq i32 %conv64, 48
  br i1 %cmp65, label %land.rhs, label %land.end

land.rhs:                                         ; preds = %while.cond62
  %50 = load i8*, i8** %out.addr, align 4
  %arrayidx67 = getelementptr inbounds i8, i8* %50, i32 1
  %51 = load i8, i8* %arrayidx67, align 1
  %conv68 = sext i8 %51 to i32
  %cmp69 = icmp ne i32 %conv68, 46
  br label %land.end

land.end:                                         ; preds = %land.rhs, %while.cond62
  %52 = phi i1 [ false, %while.cond62 ], [ %cmp69, %land.rhs ]
  br i1 %52, label %while.body71, label %while.end80

while.body71:                                     ; preds = %land.end
  store i32 0, i32* %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %while.body71
  %53 = load i8*, i8** %out.addr, align 4
  %54 = load i32, i32* %i, align 4
  %arrayidx72 = getelementptr inbounds i8, i8* %53, i32 %54
  %55 = load i8, i8* %arrayidx72, align 1
  %conv73 = sext i8 %55 to i32
  %cmp74 = icmp ne i32 %conv73, 0
  br i1 %cmp74, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %56 = load i8*, i8** %out.addr, align 4
  %57 = load i32, i32* %i, align 4
  %add76 = add i32 %57, 1
  %arrayidx77 = getelementptr inbounds i8, i8* %56, i32 %add76
  %58 = load i8, i8* %arrayidx77, align 1
  %59 = load i8*, i8** %out.addr, align 4
  %60 = load i32, i32* %i, align 4
  %arrayidx78 = getelementptr inbounds i8, i8* %59, i32 %60
  store i8 %58, i8* %arrayidx78, align 1
  br label %for.inc

for.inc:                                          ; preds = %for.body
  %61 = load i32, i32* %i, align 4
  %inc79 = add i32 %61, 1
  store i32 %inc79, i32* %i, align 4
  br label %for.cond

for.end:                                          ; preds = %for.cond
  br label %while.cond62

while.end80:                                      ; preds = %land.end
  %62 = load i8*, i8** %out.addr, align 4
  %63 = load i8, i8* %62, align 1
  %conv81 = sext i8 %63 to i32
  %cmp82 = icmp eq i32 %conv81, 46
  br i1 %cmp82, label %if.then84, label %if.end86

if.then84:                                        ; preds = %while.end80
  %64 = load i8*, i8** %out.addr, align 4
  %65 = load i8*, i8** %p, align 4
  call void @reverse(i8* %64, i8* %65)
  %66 = load i8*, i8** %p, align 4
  %incdec.ptr85 = getelementptr inbounds i8, i8* %66, i32 1
  store i8* %incdec.ptr85, i8** %p, align 4
  store i8 48, i8* %66, align 1
  %67 = load i8*, i8** %p, align 4
  store i8 0, i8* %67, align 1
  %68 = load i8*, i8** %out.addr, align 4
  %69 = load i8*, i8** %p, align 4
  call void @reverse(i8* %68, i8* %69)
  br label %if.end86

if.end86:                                         ; preds = %if.then84, %while.end80
  %70 = load i8*, i8** %out.addr, align 4
  call void @makeQuaterImaginary(%struct.QuaterImaginary* sret align 4 %agg.result, i8* %70)
  br label %return

return:                                           ; preds = %if.end86, %if.then
  ret void
}

; Function Attrs: nounwind readnone speculatable willreturn
declare double @llvm.ceil.f64(double %0) #4

; Function Attrs: noinline nounwind optnone
define hidden i32 @main() #0 {
entry:
  %retval = alloca i32, align 4
  %buffer = alloca [16 x i8], align 16
  %i = alloca i32, align 4
  %c1 = alloca %struct.Complex, align 8
  %qi = alloca %struct.QuaterImaginary, align 4
  %c2 = alloca %struct.Complex, align 8
  %tmp = alloca %struct.Complex, align 8
  %tmp3 = alloca %struct.QuaterImaginary, align 4
  %tmp5 = alloca %struct.Complex, align 8
  %c114 = alloca %struct.Complex, align 8
  %qi18 = alloca %struct.QuaterImaginary, align 4
  %c220 = alloca %struct.Complex, align 8
  %tmp24 = alloca %struct.Complex, align 8
  %tmp25 = alloca %struct.QuaterImaginary, align 4
  %tmp27 = alloca %struct.Complex, align 8
  store i32 0, i32* %retval, align 4
  store i32 1, i32* %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %0 = load i32, i32* %i, align 4
  %cmp = icmp sle i32 %0, 16
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %rel = getelementptr inbounds %struct.Complex, %struct.Complex* %c1, i32 0, i32 0
  %1 = load i32, i32* %i, align 4
  %conv = sitofp i32 %1 to double
  store double %conv, double* %rel, align 8
  %img = getelementptr inbounds %struct.Complex, %struct.Complex* %c1, i32 0, i32 1
  store double 0.000000e+00, double* %img, align 8
  %arraydecay = getelementptr inbounds [16 x i8], [16 x i8]* %buffer, i32 0, i32 0
  call void @c2qi(%struct.QuaterImaginary* sret align 4 %qi, %struct.Complex* byval(%struct.Complex) align 8 %c1, i8* %arraydecay)
  call void @qi2c(%struct.Complex* sret align 8 %c2, %struct.QuaterImaginary* byval(%struct.QuaterImaginary) align 4 %qi)
  call void @printComplex(%struct.Complex* byval(%struct.Complex) align 8 %c1)
  %call = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.4, i32 0, i32 0))
  call void @printQuaterImaginary(%struct.QuaterImaginary* byval(%struct.QuaterImaginary) align 4 %qi)
  %call1 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.4, i32 0, i32 0))
  call void @printComplex(%struct.Complex* byval(%struct.Complex) align 8 %c2)
  %call2 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([6 x i8], [6 x i8]* @.str.5, i32 0, i32 0))
  call void @negComplex(%struct.Complex* sret align 8 %tmp, %struct.Complex* byval(%struct.Complex) align 8 %c1)
  %2 = bitcast %struct.Complex* %c1 to i8*
  %3 = bitcast %struct.Complex* %tmp to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 8 %2, i8* align 8 %3, i32 16, i1 false)
  %arraydecay4 = getelementptr inbounds [16 x i8], [16 x i8]* %buffer, i32 0, i32 0
  call void @c2qi(%struct.QuaterImaginary* sret align 4 %tmp3, %struct.Complex* byval(%struct.Complex) align 8 %c1, i8* %arraydecay4)
  %4 = bitcast %struct.QuaterImaginary* %qi to i8*
  %5 = bitcast %struct.QuaterImaginary* %tmp3 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 4 %4, i8* align 4 %5, i32 8, i1 false)
  call void @qi2c(%struct.Complex* sret align 8 %tmp5, %struct.QuaterImaginary* byval(%struct.QuaterImaginary) align 4 %qi)
  %6 = bitcast %struct.Complex* %c2 to i8*
  %7 = bitcast %struct.Complex* %tmp5 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 8 %6, i8* align 8 %7, i32 16, i1 false)
  call void @printComplex(%struct.Complex* byval(%struct.Complex) align 8 %c1)
  %call6 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.4, i32 0, i32 0))
  call void @printQuaterImaginary(%struct.QuaterImaginary* byval(%struct.QuaterImaginary) align 4 %qi)
  %call7 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.4, i32 0, i32 0))
  call void @printComplex(%struct.Complex* byval(%struct.Complex) align 8 %c2)
  %call8 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([2 x i8], [2 x i8]* @.str.6, i32 0, i32 0))
  br label %for.inc

for.inc:                                          ; preds = %for.body
  %8 = load i32, i32* %i, align 4
  %inc = add nsw i32 %8, 1
  store i32 %inc, i32* %i, align 4
  br label %for.cond

for.end:                                          ; preds = %for.cond
  %call9 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([2 x i8], [2 x i8]* @.str.6, i32 0, i32 0))
  store i32 1, i32* %i, align 4
  br label %for.cond10

for.cond10:                                       ; preds = %for.inc31, %for.end
  %9 = load i32, i32* %i, align 4
  %cmp11 = icmp sle i32 %9, 16
  br i1 %cmp11, label %for.body13, label %for.end33

for.body13:                                       ; preds = %for.cond10
  %rel15 = getelementptr inbounds %struct.Complex, %struct.Complex* %c114, i32 0, i32 0
  store double 0.000000e+00, double* %rel15, align 8
  %img16 = getelementptr inbounds %struct.Complex, %struct.Complex* %c114, i32 0, i32 1
  %10 = load i32, i32* %i, align 4
  %conv17 = sitofp i32 %10 to double
  store double %conv17, double* %img16, align 8
  %arraydecay19 = getelementptr inbounds [16 x i8], [16 x i8]* %buffer, i32 0, i32 0
  call void @c2qi(%struct.QuaterImaginary* sret align 4 %qi18, %struct.Complex* byval(%struct.Complex) align 8 %c114, i8* %arraydecay19)
  call void @qi2c(%struct.Complex* sret align 8 %c220, %struct.QuaterImaginary* byval(%struct.QuaterImaginary) align 4 %qi18)
  call void @printComplex(%struct.Complex* byval(%struct.Complex) align 8 %c114)
  %call21 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.4, i32 0, i32 0))
  call void @printQuaterImaginary(%struct.QuaterImaginary* byval(%struct.QuaterImaginary) align 4 %qi18)
  %call22 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.4, i32 0, i32 0))
  call void @printComplex(%struct.Complex* byval(%struct.Complex) align 8 %c220)
  %call23 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([6 x i8], [6 x i8]* @.str.5, i32 0, i32 0))
  call void @negComplex(%struct.Complex* sret align 8 %tmp24, %struct.Complex* byval(%struct.Complex) align 8 %c114)
  %11 = bitcast %struct.Complex* %c114 to i8*
  %12 = bitcast %struct.Complex* %tmp24 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 8 %11, i8* align 8 %12, i32 16, i1 false)
  %arraydecay26 = getelementptr inbounds [16 x i8], [16 x i8]* %buffer, i32 0, i32 0
  call void @c2qi(%struct.QuaterImaginary* sret align 4 %tmp25, %struct.Complex* byval(%struct.Complex) align 8 %c114, i8* %arraydecay26)
  %13 = bitcast %struct.QuaterImaginary* %qi18 to i8*
  %14 = bitcast %struct.QuaterImaginary* %tmp25 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 4 %13, i8* align 4 %14, i32 8, i1 false)
  call void @qi2c(%struct.Complex* sret align 8 %tmp27, %struct.QuaterImaginary* byval(%struct.QuaterImaginary) align 4 %qi18)
  %15 = bitcast %struct.Complex* %c220 to i8*
  %16 = bitcast %struct.Complex* %tmp27 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 8 %15, i8* align 8 %16, i32 16, i1 false)
  call void @printComplex(%struct.Complex* byval(%struct.Complex) align 8 %c114)
  %call28 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.4, i32 0, i32 0))
  call void @printQuaterImaginary(%struct.QuaterImaginary* byval(%struct.QuaterImaginary) align 4 %qi18)
  %call29 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.4, i32 0, i32 0))
  call void @printComplex(%struct.Complex* byval(%struct.Complex) align 8 %c220)
  %call30 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([2 x i8], [2 x i8]* @.str.6, i32 0, i32 0))
  br label %for.inc31

for.inc31:                                        ; preds = %for.body13
  %17 = load i32, i32* %i, align 4
  %inc32 = add nsw i32 %17, 1
  store i32 %inc32, i32* %i, align 4
  br label %for.cond10

for.end33:                                        ; preds = %for.cond10
  ret i32 0
}

attributes #0 = { noinline nounwind optnone "correctly-rounded-divide-sqrt-fp-math"="false" "disable-tail-calls"="false" "frame-pointer"="none" "less-precise-fpmad"="false" "min-legal-vector-width"="0" "no-infs-fp-math"="false" "no-jump-tables"="false" "no-nans-fp-math"="false" "no-signed-zeros-fp-math"="false" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="generic" "unsafe-fp-math"="false" "use-soft-float"="false" }
attributes #1 = { "correctly-rounded-divide-sqrt-fp-math"="false" "disable-tail-calls"="false" "frame-pointer"="none" "less-precise-fpmad"="false" "no-infs-fp-math"="false" "no-nans-fp-math"="false" "no-signed-zeros-fp-math"="false" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="generic" "unsafe-fp-math"="false" "use-soft-float"="false" }
attributes #2 = { nounwind readonly "correctly-rounded-divide-sqrt-fp-math"="false" "disable-tail-calls"="false" "frame-pointer"="none" "less-precise-fpmad"="false" "no-infs-fp-math"="false" "no-nans-fp-math"="false" "no-signed-zeros-fp-math"="false" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="generic" "unsafe-fp-math"="false" "use-soft-float"="false" }
attributes #3 = { argmemonly nounwind willreturn }
attributes #4 = { nounwind readnone speculatable willreturn }
attributes #5 = { nounwind readonly }

!llvm.module.flags = !{!0}
!llvm.ident = !{!1}

!0 = !{i32 1, !"wchar_size", i32 4}
!1 = !{!"clang version 11.0.0 (https://github.com/Jacarte/llvm-project.git 0f6dea67136cc1e0b3d200eb2bb165628970c44b)"}

; extracted candidates
#########################################################
; exiting Souper's runOnFunction() for mulComplex()

; entering Souper's runOnFunction() for mulComplexD()

; ModuleID = './Imaginary_base_numbers.c.bc'
source_filename = "./Imaginary_base_numbers.c"
target datalayout = "e-m:e-p:32:32-i64:64-n32:64-S128"
target triple = "wasm32-unknown-wasi"

%struct.Complex = type { double, double }
%struct.QuaterImaginary = type { i8*, i32 }

@.str = private unnamed_addr constant [17 x i8] c"(%3.0f + %3.0fi)\00", align 1
@TWO_I = hidden constant %struct.Complex { double 0.000000e+00, double 2.000000e+00 }, align 8
@INV_TWO_I = hidden constant %struct.Complex { double 0.000000e+00, double -5.000000e-01 }, align 8
@.str.1 = private unnamed_addr constant [4 x i8] c"%8s\00", align 1
@.str.2 = private unnamed_addr constant [9 x i8] c" ERROR  \00", align 1
@.str.3 = private unnamed_addr constant [2 x i8] c"0\00", align 1
@.str.4 = private unnamed_addr constant [5 x i8] c" -> \00", align 1
@.str.5 = private unnamed_addr constant [6 x i8] c"     \00", align 1
@.str.6 = private unnamed_addr constant [2 x i8] c"\0A\00", align 1
@llvm.used = appending global [1 x i8*] [i8* bitcast (i32 ()* @__main_void to i8*)], section "llvm.metadata"

@__main_void = alias i32 (), i32 ()* @main

; Function Attrs: noinline nounwind optnone
define hidden i32 @find(i8* %s, i8 signext %c) #0 {
entry:
  %retval = alloca i32, align 4
  %s.addr = alloca i8*, align 4
  %c.addr = alloca i8, align 1
  %i = alloca i8*, align 4
  store i8* %s, i8** %s.addr, align 4
  store i8 %c, i8* %c.addr, align 1
  %0 = load i8*, i8** %s.addr, align 4
  store i8* %0, i8** %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %1 = load i8*, i8** %i, align 4
  %2 = load i8, i8* %1, align 1
  %conv = sext i8 %2 to i32
  %cmp = icmp ne i32 %conv, 0
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %3 = load i8*, i8** %i, align 4
  %4 = load i8, i8* %3, align 1
  %conv2 = sext i8 %4 to i32
  %5 = load i8, i8* %c.addr, align 1
  %conv3 = sext i8 %5 to i32
  %cmp4 = icmp eq i32 %conv2, %conv3
  br i1 %cmp4, label %if.then, label %if.end

if.then:                                          ; preds = %for.body
  %6 = load i8*, i8** %i, align 4
  %7 = load i8*, i8** %s.addr, align 4
  %sub.ptr.lhs.cast = ptrtoint i8* %6 to i32
  %sub.ptr.rhs.cast = ptrtoint i8* %7 to i32
  %sub.ptr.sub = sub i32 %sub.ptr.lhs.cast, %sub.ptr.rhs.cast
  store i32 %sub.ptr.sub, i32* %retval, align 4
  br label %return

if.end:                                           ; preds = %for.body
  br label %for.inc

for.inc:                                          ; preds = %if.end
  %8 = load i8*, i8** %i, align 4
  %incdec.ptr = getelementptr inbounds i8, i8* %8, i32 1
  store i8* %incdec.ptr, i8** %i, align 4
  br label %for.cond

for.end:                                          ; preds = %for.cond
  store i32 -1, i32* %retval, align 4
  br label %return

return:                                           ; preds = %for.end, %if.then
  %9 = load i32, i32* %retval, align 4
  ret i32 %9
}

; Function Attrs: noinline nounwind optnone
define hidden void @reverse(i8* %b, i8* %e) #0 {
entry:
  %b.addr = alloca i8*, align 4
  %e.addr = alloca i8*, align 4
  %t = alloca i8, align 1
  store i8* %b, i8** %b.addr, align 4
  store i8* %e, i8** %e.addr, align 4
  %0 = load i8*, i8** %e.addr, align 4
  %incdec.ptr = getelementptr inbounds i8, i8* %0, i32 -1
  store i8* %incdec.ptr, i8** %e.addr, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %1 = load i8*, i8** %b.addr, align 4
  %2 = load i8*, i8** %e.addr, align 4
  %cmp = icmp ult i8* %1, %2
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %3 = load i8*, i8** %b.addr, align 4
  %4 = load i8, i8* %3, align 1
  store i8 %4, i8* %t, align 1
  %5 = load i8*, i8** %e.addr, align 4
  %6 = load i8, i8* %5, align 1
  %7 = load i8*, i8** %b.addr, align 4
  store i8 %6, i8* %7, align 1
  %8 = load i8, i8* %t, align 1
  %9 = load i8*, i8** %e.addr, align 4
  store i8 %8, i8* %9, align 1
  br label %for.inc

for.inc:                                          ; preds = %for.body
  %10 = load i8*, i8** %b.addr, align 4
  %incdec.ptr1 = getelementptr inbounds i8, i8* %10, i32 1
  store i8* %incdec.ptr1, i8** %b.addr, align 4
  %11 = load i8*, i8** %e.addr, align 4
  %incdec.ptr2 = getelementptr inbounds i8, i8* %11, i32 -1
  store i8* %incdec.ptr2, i8** %e.addr, align 4
  br label %for.cond

for.end:                                          ; preds = %for.cond
  ret void
}

; Function Attrs: noinline nounwind optnone
define hidden void @printComplex(%struct.Complex* byval(%struct.Complex) align 8 %c) #0 {
entry:
  %rel = getelementptr inbounds %struct.Complex, %struct.Complex* %c, i32 0, i32 0
  %0 = load double, double* %rel, align 8
  %img = getelementptr inbounds %struct.Complex, %struct.Complex* %c, i32 0, i32 1
  %1 = load double, double* %img, align 8
  %call = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([17 x i8], [17 x i8]* @.str, i32 0, i32 0), double %0, double %1)
  ret void
}

declare i32 @printf(i8* %0, ...) #1

; Function Attrs: noinline nounwind optnone
define hidden void @makeComplex(%struct.Complex* noalias sret align 8 %agg.result, double %rel, double %img) #0 {
entry:
  %rel.addr = alloca double, align 8
  %img.addr = alloca double, align 8
  store double %rel, double* %rel.addr, align 8
  store double %img, double* %img.addr, align 8
  %rel1 = getelementptr inbounds %struct.Complex, %struct.Complex* %agg.result, i32 0, i32 0
  %0 = load double, double* %rel.addr, align 8
  store double %0, double* %rel1, align 8
  %img2 = getelementptr inbounds %struct.Complex, %struct.Complex* %agg.result, i32 0, i32 1
  %1 = load double, double* %img.addr, align 8
  store double %1, double* %img2, align 8
  ret void
}

; Function Attrs: noinline nounwind optnone
define hidden void @addComplex(%struct.Complex* noalias sret align 8 %agg.result, %struct.Complex* byval(%struct.Complex) align 8 %a, %struct.Complex* byval(%struct.Complex) align 8 %b) #0 {
entry:
  %rel = getelementptr inbounds %struct.Complex, %struct.Complex* %agg.result, i32 0, i32 0
  %rel1 = getelementptr inbounds %struct.Complex, %struct.Complex* %a, i32 0, i32 0
  %0 = load double, double* %rel1, align 8
  %rel2 = getelementptr inbounds %struct.Complex, %struct.Complex* %b, i32 0, i32 0
  %1 = load double, double* %rel2, align 8
  %add = fadd double %0, %1
  store double %add, double* %rel, align 8
  %img = getelementptr inbounds %struct.Complex, %struct.Complex* %agg.result, i32 0, i32 1
  %img3 = getelementptr inbounds %struct.Complex, %struct.Complex* %a, i32 0, i32 1
  %2 = load double, double* %img3, align 8
  %img4 = getelementptr inbounds %struct.Complex, %struct.Complex* %b, i32 0, i32 1
  %3 = load double, double* %img4, align 8
  %add5 = fadd double %2, %3
  store double %add5, double* %img, align 8
  ret void
}

; Function Attrs: noinline nounwind optnone
define hidden void @mulComplex(%struct.Complex* noalias sret align 8 %agg.result, %struct.Complex* byval(%struct.Complex) align 8 %a, %struct.Complex* byval(%struct.Complex) align 8 %b) #0 {
entry:
  %rel = getelementptr inbounds %struct.Complex, %struct.Complex* %agg.result, i32 0, i32 0
  %rel1 = getelementptr inbounds %struct.Complex, %struct.Complex* %a, i32 0, i32 0
  %0 = load double, double* %rel1, align 8
  %rel2 = getelementptr inbounds %struct.Complex, %struct.Complex* %b, i32 0, i32 0
  %1 = load double, double* %rel2, align 8
  %mul = fmul double %0, %1
  %img = getelementptr inbounds %struct.Complex, %struct.Complex* %a, i32 0, i32 1
  %2 = load double, double* %img, align 8
  %img3 = getelementptr inbounds %struct.Complex, %struct.Complex* %b, i32 0, i32 1
  %3 = load double, double* %img3, align 8
  %mul4 = fmul double %2, %3
  %sub = fsub double %mul, %mul4
  store double %sub, double* %rel, align 8
  %img5 = getelementptr inbounds %struct.Complex, %struct.Complex* %agg.result, i32 0, i32 1
  %rel6 = getelementptr inbounds %struct.Complex, %struct.Complex* %a, i32 0, i32 0
  %4 = load double, double* %rel6, align 8
  %img7 = getelementptr inbounds %struct.Complex, %struct.Complex* %b, i32 0, i32 1
  %5 = load double, double* %img7, align 8
  %mul8 = fmul double %4, %5
  %img9 = getelementptr inbounds %struct.Complex, %struct.Complex* %a, i32 0, i32 1
  %6 = load double, double* %img9, align 8
  %rel10 = getelementptr inbounds %struct.Complex, %struct.Complex* %b, i32 0, i32 0
  %7 = load double, double* %rel10, align 8
  %mul11 = fmul double %6, %7
  %sub12 = fsub double %mul8, %mul11
  store double %sub12, double* %img5, align 8
  ret void
}

; Function Attrs: noinline nounwind optnone
define hidden void @mulComplexD(%struct.Complex* noalias sret align 8 %agg.result, %struct.Complex* byval(%struct.Complex) align 8 %a, double %b) #0 {
entry:
  %b.addr = alloca double, align 8
  store double %b, double* %b.addr, align 8
  %rel = getelementptr inbounds %struct.Complex, %struct.Complex* %agg.result, i32 0, i32 0
  %rel1 = getelementptr inbounds %struct.Complex, %struct.Complex* %a, i32 0, i32 0
  %0 = load double, double* %rel1, align 8
  %1 = load double, double* %b.addr, align 8
  %mul = fmul double %0, %1
  store double %mul, double* %rel, align 8
  %img = getelementptr inbounds %struct.Complex, %struct.Complex* %agg.result, i32 0, i32 1
  %img2 = getelementptr inbounds %struct.Complex, %struct.Complex* %a, i32 0, i32 1
  %2 = load double, double* %img2, align 8
  %3 = load double, double* %b.addr, align 8
  %mul3 = fmul double %2, %3
  store double %mul3, double* %img, align 8
  ret void
}

; Function Attrs: noinline nounwind optnone
define hidden void @negComplex(%struct.Complex* noalias sret align 8 %agg.result, %struct.Complex* byval(%struct.Complex) align 8 %a) #0 {
entry:
  call void @mulComplexD(%struct.Complex* sret align 8 %agg.result, %struct.Complex* byval(%struct.Complex) align 8 %a, double -1.000000e+00)
  ret void
}

; Function Attrs: noinline nounwind optnone
define hidden void @divComplex(%struct.Complex* noalias sret align 8 %agg.result, %struct.Complex* byval(%struct.Complex) align 8 %a, %struct.Complex* byval(%struct.Complex) align 8 %b) #0 {
entry:
  %re = alloca double, align 8
  %im = alloca double, align 8
  %d = alloca double, align 8
  %rel = getelementptr inbounds %struct.Complex, %struct.Complex* %a, i32 0, i32 0
  %0 = load double, double* %rel, align 8
  %rel1 = getelementptr inbounds %struct.Complex, %struct.Complex* %b, i32 0, i32 0
  %1 = load double, double* %rel1, align 8
  %mul = fmul double %0, %1
  %img = getelementptr inbounds %struct.Complex, %struct.Complex* %a, i32 0, i32 1
  %2 = load double, double* %img, align 8
  %img2 = getelementptr inbounds %struct.Complex, %struct.Complex* %b, i32 0, i32 1
  %3 = load double, double* %img2, align 8
  %mul3 = fmul double %2, %3
  %add = fadd double %mul, %mul3
  store double %add, double* %re, align 8
  %img4 = getelementptr inbounds %struct.Complex, %struct.Complex* %a, i32 0, i32 1
  %4 = load double, double* %img4, align 8
  %rel5 = getelementptr inbounds %struct.Complex, %struct.Complex* %b, i32 0, i32 0
  %5 = load double, double* %rel5, align 8
  %mul6 = fmul double %4, %5
  %rel7 = getelementptr inbounds %struct.Complex, %struct.Complex* %a, i32 0, i32 0
  %6 = load double, double* %rel7, align 8
  %img8 = getelementptr inbounds %struct.Complex, %struct.Complex* %b, i32 0, i32 1
  %7 = load double, double* %img8, align 8
  %mul9 = fmul double %6, %7
  %sub = fsub double %mul6, %mul9
  store double %sub, double* %im, align 8
  %rel10 = getelementptr inbounds %struct.Complex, %struct.Complex* %b, i32 0, i32 0
  %8 = load double, double* %rel10, align 8
  %rel11 = getelementptr inbounds %struct.Complex, %struct.Complex* %b, i32 0, i32 0
  %9 = load double, double* %rel11, align 8
  %mul12 = fmul double %8, %9
  %img13 = getelementptr inbounds %struct.Complex, %struct.Complex* %b, i32 0, i32 1
  %10 = load double, double* %img13, align 8
  %img14 = getelementptr inbounds %struct.Complex, %struct.Complex* %b, i32 0, i32 1
  %11 = load double, double* %img14, align 8
  %mul15 = fmul double %10, %11
  %add16 = fadd double %mul12, %mul15
  store double %add16, double* %d, align 8
  %rel17 = getelementptr inbounds %struct.Complex, %struct.Complex* %agg.result, i32 0, i32 0
  %12 = load double, double* %re, align 8
  %13 = load double, double* %d, align 8
  %div = fdiv double %12, %13
  store double %div, double* %rel17, align 8
  %img18 = getelementptr inbounds %struct.Complex, %struct.Complex* %agg.result, i32 0, i32 1
  %14 = load double, double* %im, align 8
  %15 = load double, double* %d, align 8
  %div19 = fdiv double %14, %15
  store double %div19, double* %img18, align 8
  ret void
}

; Function Attrs: noinline nounwind optnone
define hidden void @inv(%struct.Complex* noalias sret align 8 %agg.result, %struct.Complex* byval(%struct.Complex) align 8 %c) #0 {
entry:
  %d = alloca double, align 8
  %rel = getelementptr inbounds %struct.Complex, %struct.Complex* %c, i32 0, i32 0
  %0 = load double, double* %rel, align 8
  %rel1 = getelementptr inbounds %struct.Complex, %struct.Complex* %c, i32 0, i32 0
  %1 = load double, double* %rel1, align 8
  %mul = fmul double %0, %1
  %img = getelementptr inbounds %struct.Complex, %struct.Complex* %c, i32 0, i32 1
  %2 = load double, double* %img, align 8
  %img2 = getelementptr inbounds %struct.Complex, %struct.Complex* %c, i32 0, i32 1
  %3 = load double, double* %img2, align 8
  %mul3 = fmul double %2, %3
  %add = fadd double %mul, %mul3
  store double %add, double* %d, align 8
  %rel4 = getelementptr inbounds %struct.Complex, %struct.Complex* %agg.result, i32 0, i32 0
  %rel5 = getelementptr inbounds %struct.Complex, %struct.Complex* %c, i32 0, i32 0
  %4 = load double, double* %rel5, align 8
  %5 = load double, double* %d, align 8
  %div = fdiv double %4, %5
  store double %div, double* %rel4, align 8
  %img6 = getelementptr inbounds %struct.Complex, %struct.Complex* %agg.result, i32 0, i32 1
  %img7 = getelementptr inbounds %struct.Complex, %struct.Complex* %c, i32 0, i32 1
  %6 = load double, double* %img7, align 8
  %fneg = fneg double %6
  %7 = load double, double* %d, align 8
  %div8 = fdiv double %fneg, %7
  store double %div8, double* %img6, align 8
  ret void
}

; Function Attrs: noinline nounwind optnone
define hidden void @makeQuaterImaginary(%struct.QuaterImaginary* noalias sret align 4 %agg.result, i8* %s) #0 {
entry:
  %s.addr = alloca i8*, align 4
  %i = alloca i32, align 4
  %valid1 = alloca i32, align 4
  %cnt = alloca i32, align 4
  store i8* %s, i8** %s.addr, align 4
  %b2i = getelementptr inbounds %struct.QuaterImaginary, %struct.QuaterImaginary* %agg.result, i32 0, i32 0
  %0 = load i8*, i8** %s.addr, align 4
  store i8* %0, i8** %b2i, align 4
  %valid = getelementptr inbounds %struct.QuaterImaginary, %struct.QuaterImaginary* %agg.result, i32 0, i32 1
  store i32 0, i32* %valid, align 4
  store i32 1, i32* %valid1, align 4
  store i32 0, i32* %cnt, align 4
  %1 = load i8*, i8** %s.addr, align 4
  %2 = load i8, i8* %1, align 1
  %conv = sext i8 %2 to i32
  %cmp = icmp ne i32 %conv, 0
  br i1 %cmp, label %if.then, label %if.end26

if.then:                                          ; preds = %entry
  store i32 0, i32* %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.then
  %3 = load i8*, i8** %s.addr, align 4
  %4 = load i32, i32* %i, align 4
  %arrayidx = getelementptr inbounds i8, i8* %3, i32 %4
  %5 = load i8, i8* %arrayidx, align 1
  %conv3 = sext i8 %5 to i32
  %cmp4 = icmp ne i32 %conv3, 0
  br i1 %cmp4, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %6 = load i8*, i8** %s.addr, align 4
  %7 = load i32, i32* %i, align 4
  %arrayidx6 = getelementptr inbounds i8, i8* %6, i32 %7
  %8 = load i8, i8* %arrayidx6, align 1
  %conv7 = sext i8 %8 to i32
  %cmp8 = icmp slt i32 %conv7, 48
  br i1 %cmp8, label %if.then14, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %for.body
  %9 = load i8*, i8** %s.addr, align 4
  %10 = load i32, i32* %i, align 4
  %arrayidx10 = getelementptr inbounds i8, i8* %9, i32 %10
  %11 = load i8, i8* %arrayidx10, align 1
  %conv11 = sext i8 %11 to i32
  %cmp12 = icmp slt i32 51, %conv11
  br i1 %cmp12, label %if.then14, label %if.end20

if.then14:                                        ; preds = %lor.lhs.false, %for.body
  %12 = load i8*, i8** %s.addr, align 4
  %13 = load i32, i32* %i, align 4
  %arrayidx15 = getelementptr inbounds i8, i8* %12, i32 %13
  %14 = load i8, i8* %arrayidx15, align 1
  %conv16 = sext i8 %14 to i32
  %cmp17 = icmp eq i32 %conv16, 46
  br i1 %cmp17, label %if.then19, label %if.else

if.then19:                                        ; preds = %if.then14
  %15 = load i32, i32* %cnt, align 4
  %inc = add i32 %15, 1
  store i32 %inc, i32* %cnt, align 4
  br label %if.end

if.else:                                          ; preds = %if.then14
  store i32 0, i32* %valid1, align 4
  br label %for.end

if.end:                                           ; preds = %if.then19
  br label %if.end20

if.end20:                                         ; preds = %if.end, %lor.lhs.false
  br label %for.inc

for.inc:                                          ; preds = %if.end20
  %16 = load i32, i32* %i, align 4
  %inc21 = add i32 %16, 1
  store i32 %inc21, i32* %i, align 4
  br label %for.cond

for.end:                                          ; preds = %if.else, %for.cond
  %17 = load i32, i32* %valid1, align 4
  %tobool = icmp ne i32 %17, 0
  br i1 %tobool, label %land.lhs.true, label %if.end25

land.lhs.true:                                    ; preds = %for.end
  %18 = load i32, i32* %cnt, align 4
  %cmp22 = icmp ugt i32 %18, 1
  br i1 %cmp22, label %if.then24, label %if.end25

if.then24:                                        ; preds = %land.lhs.true
  store i32 0, i32* %valid1, align 4
  br label %if.end25

if.end25:                                         ; preds = %if.then24, %land.lhs.true, %for.end
  br label %if.end26

if.end26:                                         ; preds = %if.end25, %entry
  %19 = load i32, i32* %valid1, align 4
  %valid27 = getelementptr inbounds %struct.QuaterImaginary, %struct.QuaterImaginary* %agg.result, i32 0, i32 1
  store i32 %19, i32* %valid27, align 4
  ret void
}

; Function Attrs: noinline nounwind optnone
define hidden void @printQuaterImaginary(%struct.QuaterImaginary* byval(%struct.QuaterImaginary) align 4 %qi) #0 {
entry:
  %valid = getelementptr inbounds %struct.QuaterImaginary, %struct.QuaterImaginary* %qi, i32 0, i32 1
  %0 = load i32, i32* %valid, align 4
  %tobool = icmp ne i32 %0, 0
  br i1 %tobool, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  %b2i = getelementptr inbounds %struct.QuaterImaginary, %struct.QuaterImaginary* %qi, i32 0, i32 0
  %1 = load i8*, i8** %b2i, align 4
  %call = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([4 x i8], [4 x i8]* @.str.1, i32 0, i32 0), i8* %1)
  br label %if.end

if.else:                                          ; preds = %entry
  %call1 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([9 x i8], [9 x i8]* @.str.2, i32 0, i32 0))
  br label %if.end

if.end:                                           ; preds = %if.else, %if.then
  ret void
}

; Function Attrs: noinline nounwind optnone
define hidden void @qi2c(%struct.Complex* noalias sret align 8 %agg.result, %struct.QuaterImaginary* byval(%struct.QuaterImaginary) align 4 %qi) #0 {
entry:
  %len = alloca i32, align 4
  %pointPos = alloca i32, align 4
  %posLen = alloca i32, align 4
  %prod = alloca %struct.Complex, align 8
  %j = alloca i32, align 4
  %k = alloca double, align 8
  %tmp = alloca %struct.Complex, align 8
  %agg.tmp = alloca %struct.Complex, align 8
  %tmp10 = alloca %struct.Complex, align 8
  %k18 = alloca double, align 8
  %tmp27 = alloca %struct.Complex, align 8
  %agg.tmp28 = alloca %struct.Complex, align 8
  %tmp30 = alloca %struct.Complex, align 8
  %b2i = getelementptr inbounds %struct.QuaterImaginary, %struct.QuaterImaginary* %qi, i32 0, i32 0
  %0 = load i8*, i8** %b2i, align 4
  %call = call i32 @strlen(i8* %0) #5
  store i32 %call, i32* %len, align 4
  %b2i1 = getelementptr inbounds %struct.QuaterImaginary, %struct.QuaterImaginary* %qi, i32 0, i32 0
  %1 = load i8*, i8** %b2i1, align 4
  %call2 = call i32 @find(i8* %1, i8 signext 46)
  store i32 %call2, i32* %pointPos, align 4
  %2 = load i32, i32* %pointPos, align 4
  %cmp = icmp sgt i32 %2, 0
  br i1 %cmp, label %cond.true, label %cond.false

cond.true:                                        ; preds = %entry
  %3 = load i32, i32* %pointPos, align 4
  br label %cond.end

cond.false:                                       ; preds = %entry
  %4 = load i32, i32* %len, align 4
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi i32 [ %3, %cond.true ], [ %4, %cond.false ]
  store i32 %cond, i32* %posLen, align 4
  call void @makeComplex(%struct.Complex* sret align 8 %agg.result, double 0.000000e+00, double 0.000000e+00)
  call void @makeComplex(%struct.Complex* sret align 8 %prod, double 1.000000e+00, double 0.000000e+00)
  store i32 0, i32* %j, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %cond.end
  %5 = load i32, i32* %j, align 4
  %6 = load i32, i32* %posLen, align 4
  %cmp3 = icmp ult i32 %5, %6
  br i1 %cmp3, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %b2i4 = getelementptr inbounds %struct.QuaterImaginary, %struct.QuaterImaginary* %qi, i32 0, i32 0
  %7 = load i8*, i8** %b2i4, align 4
  %8 = load i32, i32* %posLen, align 4
  %sub = sub i32 %8, 1
  %9 = load i32, i32* %j, align 4
  %sub5 = sub i32 %sub, %9
  %arrayidx = getelementptr inbounds i8, i8* %7, i32 %sub5
  %10 = load i8, i8* %arrayidx, align 1
  %conv = sext i8 %10 to i32
  %sub6 = sub nsw i32 %conv, 48
  %conv7 = sitofp i32 %sub6 to double
  store double %conv7, double* %k, align 8
  %11 = load double, double* %k, align 8
  %cmp8 = fcmp ogt double %11, 0.000000e+00
  br i1 %cmp8, label %if.then, label %if.end

if.then:                                          ; preds = %for.body
  %12 = load double, double* %k, align 8
  call void @mulComplexD(%struct.Complex* sret align 8 %agg.tmp, %struct.Complex* byval(%struct.Complex) align 8 %prod, double %12)
  call void @addComplex(%struct.Complex* sret align 8 %tmp, %struct.Complex* byval(%struct.Complex) align 8 %agg.result, %struct.Complex* byval(%struct.Complex) align 8 %agg.tmp)
  %13 = bitcast %struct.Complex* %agg.result to i8*
  %14 = bitcast %struct.Complex* %tmp to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 8 %13, i8* align 8 %14, i32 16, i1 false)
  br label %if.end

if.end:                                           ; preds = %if.then, %for.body
  call void @mulComplex(%struct.Complex* sret align 8 %tmp10, %struct.Complex* byval(%struct.Complex) align 8 %prod, %struct.Complex* byval(%struct.Complex) align 8 @TWO_I)
  %15 = bitcast %struct.Complex* %prod to i8*
  %16 = bitcast %struct.Complex* %tmp10 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 8 %15, i8* align 8 %16, i32 16, i1 false)
  br label %for.inc

for.inc:                                          ; preds = %if.end
  %17 = load i32, i32* %j, align 4
  %inc = add i32 %17, 1
  store i32 %inc, i32* %j, align 4
  br label %for.cond

for.end:                                          ; preds = %for.cond
  %18 = load i32, i32* %pointPos, align 4
  %cmp11 = icmp ne i32 %18, -1
  br i1 %cmp11, label %if.then13, label %if.end34

if.then13:                                        ; preds = %for.end
  %19 = bitcast %struct.Complex* %prod to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 8 %19, i8* align 8 bitcast (%struct.Complex* @INV_TWO_I to i8*), i32 16, i1 false)
  %20 = load i32, i32* %posLen, align 4
  %add = add i32 %20, 1
  store i32 %add, i32* %j, align 4
  br label %for.cond14

for.cond14:                                       ; preds = %for.inc31, %if.then13
  %21 = load i32, i32* %j, align 4
  %22 = load i32, i32* %len, align 4
  %cmp15 = icmp ult i32 %21, %22
  br i1 %cmp15, label %for.body17, label %for.end33

for.body17:                                       ; preds = %for.cond14
  %b2i19 = getelementptr inbounds %struct.QuaterImaginary, %struct.QuaterImaginary* %qi, i32 0, i32 0
  %23 = load i8*, i8** %b2i19, align 4
  %24 = load i32, i32* %j, align 4
  %arrayidx20 = getelementptr inbounds i8, i8* %23, i32 %24
  %25 = load i8, i8* %arrayidx20, align 1
  %conv21 = sext i8 %25 to i32
  %sub22 = sub nsw i32 %conv21, 48
  %conv23 = sitofp i32 %sub22 to double
  store double %conv23, double* %k18, align 8
  %26 = load double, double* %k18, align 8
  %cmp24 = fcmp ogt double %26, 0.000000e+00
  br i1 %cmp24, label %if.then26, label %if.end29

if.then26:                                        ; preds = %for.body17
  %27 = load double, double* %k18, align 8
  call void @mulComplexD(%struct.Complex* sret align 8 %agg.tmp28, %struct.Complex* byval(%struct.Complex) align 8 %prod, double %27)
  call void @addComplex(%struct.Complex* sret align 8 %tmp27, %struct.Complex* byval(%struct.Complex) align 8 %agg.result, %struct.Complex* byval(%struct.Complex) align 8 %agg.tmp28)
  %28 = bitcast %struct.Complex* %agg.result to i8*
  %29 = bitcast %struct.Complex* %tmp27 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 8 %28, i8* align 8 %29, i32 16, i1 false)
  br label %if.end29

if.end29:                                         ; preds = %if.then26, %for.body17
  call void @mulComplex(%struct.Complex* sret align 8 %tmp30, %struct.Complex* byval(%struct.Complex) align 8 %prod, %struct.Complex* byval(%struct.Complex) align 8 @INV_TWO_I)
  %30 = bitcast %struct.Complex* %prod to i8*
  %31 = bitcast %struct.Complex* %tmp30 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 8 %30, i8* align 8 %31, i32 16, i1 false)
  br label %for.inc31

for.inc31:                                        ; preds = %if.end29
  %32 = load i32, i32* %j, align 4
  %inc32 = add i32 %32, 1
  store i32 %inc32, i32* %j, align 4
  br label %for.cond14

for.end33:                                        ; preds = %for.cond14
  br label %if.end34

if.end34:                                         ; preds = %for.end33, %for.end
  ret void
}

; Function Attrs: nounwind readonly
declare i32 @strlen(i8* %0) #2

; Function Attrs: argmemonly nounwind willreturn
declare void @llvm.memcpy.p0i8.p0i8.i32(i8* noalias nocapture writeonly %0, i8* noalias nocapture readonly %1, i32 %2, i1 immarg %3) #3

; Function Attrs: noinline nounwind optnone
define hidden void @c2qi(%struct.QuaterImaginary* noalias sret align 4 %agg.result, %struct.Complex* byval(%struct.Complex) align 8 %c, i8* %out) #0 {
entry:
  %out.addr = alloca i8*, align 4
  %p = alloca i8*, align 4
  %re = alloca i32, align 4
  %im = alloca i32, align 4
  %fi = alloca i32, align 4
  %rem = alloca i32, align 4
  %index = alloca i32, align 4
  %fc = alloca %struct.Complex, align 8
  %.compoundliteral = alloca %struct.Complex, align 8
  %.compoundliteral21 = alloca %struct.Complex, align 8
  %f = alloca double, align 8
  %rem31 = alloca i32, align 4
  %i = alloca i32, align 4
  store i8* %out, i8** %out.addr, align 4
  %0 = load i8*, i8** %out.addr, align 4
  store i8* %0, i8** %p, align 4
  %1 = load i8*, i8** %p, align 4
  store i8 0, i8* %1, align 1
  %rel = getelementptr inbounds %struct.Complex, %struct.Complex* %c, i32 0, i32 0
  %2 = load double, double* %rel, align 8
  %cmp = fcmp oeq double %2, 0.000000e+00
  br i1 %cmp, label %land.lhs.true, label %if.end

land.lhs.true:                                    ; preds = %entry
  %img = getelementptr inbounds %struct.Complex, %struct.Complex* %c, i32 0, i32 1
  %3 = load double, double* %img, align 8
  %cmp1 = fcmp oeq double %3, 0.000000e+00
  br i1 %cmp1, label %if.then, label %if.end

if.then:                                          ; preds = %land.lhs.true
  call void @makeQuaterImaginary(%struct.QuaterImaginary* sret align 4 %agg.result, i8* getelementptr inbounds ([2 x i8], [2 x i8]* @.str.3, i32 0, i32 0))
  br label %return

if.end:                                           ; preds = %land.lhs.true, %entry
  %rel2 = getelementptr inbounds %struct.Complex, %struct.Complex* %c, i32 0, i32 0
  %4 = load double, double* %rel2, align 8
  %conv = fptosi double %4 to i32
  store i32 %conv, i32* %re, align 4
  %img3 = getelementptr inbounds %struct.Complex, %struct.Complex* %c, i32 0, i32 1
  %5 = load double, double* %img3, align 8
  %conv4 = fptosi double %5 to i32
  store i32 %conv4, i32* %im, align 4
  store i32 -1, i32* %fi, align 4
  br label %while.cond

while.cond:                                       ; preds = %if.end11, %if.end
  %6 = load i32, i32* %re, align 4
  %cmp5 = icmp ne i32 %6, 0
  br i1 %cmp5, label %while.body, label %while.end

while.body:                                       ; preds = %while.cond
  %7 = load i32, i32* %re, align 4
  %rem7 = srem i32 %7, -4
  store i32 %rem7, i32* %rem, align 4
  %8 = load i32, i32* %re, align 4
  %div = sdiv i32 %8, -4
  store i32 %div, i32* %re, align 4
  %9 = load i32, i32* %rem, align 4
  %cmp8 = icmp slt i32 %9, 0
  br i1 %cmp8, label %if.then10, label %if.end11

if.then10:                                        ; preds = %while.body
  %10 = load i32, i32* %rem, align 4
  %add = add nsw i32 %10, 4
  store i32 %add, i32* %rem, align 4
  %11 = load i32, i32* %re, align 4
  %inc = add nsw i32 %11, 1
  store i32 %inc, i32* %re, align 4
  br label %if.end11

if.end11:                                         ; preds = %if.then10, %while.body
  %12 = load i32, i32* %rem, align 4
  %add12 = add nsw i32 %12, 48
  %conv13 = trunc i32 %add12 to i8
  %13 = load i8*, i8** %p, align 4
  %incdec.ptr = getelementptr inbounds i8, i8* %13, i32 1
  store i8* %incdec.ptr, i8** %p, align 4
  store i8 %conv13, i8* %13, align 1
  %14 = load i8*, i8** %p, align 4
  %incdec.ptr14 = getelementptr inbounds i8, i8* %14, i32 1
  store i8* %incdec.ptr14, i8** %p, align 4
  store i8 48, i8* %14, align 1
  %15 = load i8*, i8** %p, align 4
  store i8 0, i8* %15, align 1
  br label %while.cond

while.end:                                        ; preds = %while.cond
  %16 = load i32, i32* %im, align 4
  %cmp15 = icmp ne i32 %16, 0
  br i1 %cmp15, label %if.then17, label %if.end53

if.then17:                                        ; preds = %while.end
  store i32 1, i32* %index, align 4
  %rel18 = getelementptr inbounds %struct.Complex, %struct.Complex* %.compoundliteral, i32 0, i32 0
  store double 0.000000e+00, double* %rel18, align 8
  %img19 = getelementptr inbounds %struct.Complex, %struct.Complex* %.compoundliteral, i32 0, i32 1
  %img20 = getelementptr inbounds %struct.Complex, %struct.Complex* %c, i32 0, i32 1
  %17 = load double, double* %img20, align 8
  store double %17, double* %img19, align 8
  %rel22 = getelementptr inbounds %struct.Complex, %struct.Complex* %.compoundliteral21, i32 0, i32 0
  store double 0.000000e+00, double* %rel22, align 8
  %img23 = getelementptr inbounds %struct.Complex, %struct.Complex* %.compoundliteral21, i32 0, i32 1
  store double 2.000000e+00, double* %img23, align 8
  call void @divComplex(%struct.Complex* sret align 8 %fc, %struct.Complex* byval(%struct.Complex) align 8 %.compoundliteral, %struct.Complex* byval(%struct.Complex) align 8 %.compoundliteral21)
  %rel24 = getelementptr inbounds %struct.Complex, %struct.Complex* %fc, i32 0, i32 0
  %18 = load double, double* %rel24, align 8
  store double %18, double* %f, align 8
  %19 = load double, double* %f, align 8
  %20 = call double @llvm.ceil.f64(double %19)
  %conv25 = fptosi double %20 to i32
  store i32 %conv25, i32* %im, align 4
  %21 = load double, double* %f, align 8
  %22 = load i32, i32* %im, align 4
  %conv26 = sitofp i32 %22 to double
  %sub = fsub double %21, %conv26
  %mul = fmul double -4.000000e+00, %sub
  store double %mul, double* %f, align 8
  br label %while.cond27

while.cond27:                                     ; preds = %if.end49, %if.then17
  %23 = load i32, i32* %im, align 4
  %cmp28 = icmp ne i32 %23, 0
  br i1 %cmp28, label %while.body30, label %while.end51

while.body30:                                     ; preds = %while.cond27
  %24 = load i32, i32* %im, align 4
  %rem32 = srem i32 %24, -4
  store i32 %rem32, i32* %rem31, align 4
  %25 = load i32, i32* %im, align 4
  %div33 = sdiv i32 %25, -4
  store i32 %div33, i32* %im, align 4
  %26 = load i32, i32* %rem31, align 4
  %cmp34 = icmp slt i32 %26, 0
  br i1 %cmp34, label %if.then36, label %if.end39

if.then36:                                        ; preds = %while.body30
  %27 = load i32, i32* %rem31, align 4
  %add37 = add nsw i32 %27, 4
  store i32 %add37, i32* %rem31, align 4
  %28 = load i32, i32* %im, align 4
  %inc38 = add nsw i32 %28, 1
  store i32 %inc38, i32* %im, align 4
  br label %if.end39

if.end39:                                         ; preds = %if.then36, %while.body30
  %29 = load i32, i32* %index, align 4
  %30 = load i8*, i8** %p, align 4
  %31 = load i8*, i8** %out.addr, align 4
  %sub.ptr.lhs.cast = ptrtoint i8* %30 to i32
  %sub.ptr.rhs.cast = ptrtoint i8* %31 to i32
  %sub.ptr.sub = sub i32 %sub.ptr.lhs.cast, %sub.ptr.rhs.cast
  %cmp40 = icmp ult i32 %29, %sub.ptr.sub
  br i1 %cmp40, label %if.then42, label %if.else

if.then42:                                        ; preds = %if.end39
  %32 = load i32, i32* %rem31, align 4
  %add43 = add nsw i32 %32, 48
  %conv44 = trunc i32 %add43 to i8
  %33 = load i8*, i8** %out.addr, align 4
  %34 = load i32, i32* %index, align 4
  %arrayidx = getelementptr inbounds i8, i8* %33, i32 %34
  store i8 %conv44, i8* %arrayidx, align 1
  br label %if.end49

if.else:                                          ; preds = %if.end39
  %35 = load i8*, i8** %p, align 4
  %incdec.ptr45 = getelementptr inbounds i8, i8* %35, i32 1
  store i8* %incdec.ptr45, i8** %p, align 4
  store i8 48, i8* %35, align 1
  %36 = load i32, i32* %rem31, align 4
  %add46 = add nsw i32 %36, 48
  %conv47 = trunc i32 %add46 to i8
  %37 = load i8*, i8** %p, align 4
  %incdec.ptr48 = getelementptr inbounds i8, i8* %37, i32 1
  store i8* %incdec.ptr48, i8** %p, align 4
  store i8 %conv47, i8* %37, align 1
  %38 = load i8*, i8** %p, align 4
  store i8 0, i8* %38, align 1
  br label %if.end49

if.end49:                                         ; preds = %if.else, %if.then42
  %39 = load i32, i32* %index, align 4
  %add50 = add i32 %39, 2
  store i32 %add50, i32* %index, align 4
  br label %while.cond27

while.end51:                                      ; preds = %while.cond27
  %40 = load double, double* %f, align 8
  %conv52 = fptosi double %40 to i32
  store i32 %conv52, i32* %fi, align 4
  br label %if.end53

if.end53:                                         ; preds = %while.end51, %while.end
  %41 = load i8*, i8** %out.addr, align 4
  %42 = load i8*, i8** %p, align 4
  call void @reverse(i8* %41, i8* %42)
  %43 = load i32, i32* %fi, align 4
  %cmp54 = icmp ne i32 %43, -1
  br i1 %cmp54, label %if.then56, label %if.end61

if.then56:                                        ; preds = %if.end53
  %44 = load i8*, i8** %p, align 4
  %incdec.ptr57 = getelementptr inbounds i8, i8* %44, i32 1
  store i8* %incdec.ptr57, i8** %p, align 4
  store i8 46, i8* %44, align 1
  %45 = load i32, i32* %fi, align 4
  %add58 = add nsw i32 %45, 48
  %conv59 = trunc i32 %add58 to i8
  %46 = load i8*, i8** %p, align 4
  %incdec.ptr60 = getelementptr inbounds i8, i8* %46, i32 1
  store i8* %incdec.ptr60, i8** %p, align 4
  store i8 %conv59, i8* %46, align 1
  %47 = load i8*, i8** %p, align 4
  store i8 0, i8* %47, align 1
  br label %if.end61

if.end61:                                         ; preds = %if.then56, %if.end53
  br label %while.cond62

while.cond62:                                     ; preds = %for.end, %if.end61
  %48 = load i8*, i8** %out.addr, align 4
  %arrayidx63 = getelementptr inbounds i8, i8* %48, i32 0
  %49 = load i8, i8* %arrayidx63, align 1
  %conv64 = sext i8 %49 to i32
  %cmp65 = icmp eq i32 %conv64, 48
  br i1 %cmp65, label %land.rhs, label %land.end

land.rhs:                                         ; preds = %while.cond62
  %50 = load i8*, i8** %out.addr, align 4
  %arrayidx67 = getelementptr inbounds i8, i8* %50, i32 1
  %51 = load i8, i8* %arrayidx67, align 1
  %conv68 = sext i8 %51 to i32
  %cmp69 = icmp ne i32 %conv68, 46
  br label %land.end

land.end:                                         ; preds = %land.rhs, %while.cond62
  %52 = phi i1 [ false, %while.cond62 ], [ %cmp69, %land.rhs ]
  br i1 %52, label %while.body71, label %while.end80

while.body71:                                     ; preds = %land.end
  store i32 0, i32* %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %while.body71
  %53 = load i8*, i8** %out.addr, align 4
  %54 = load i32, i32* %i, align 4
  %arrayidx72 = getelementptr inbounds i8, i8* %53, i32 %54
  %55 = load i8, i8* %arrayidx72, align 1
  %conv73 = sext i8 %55 to i32
  %cmp74 = icmp ne i32 %conv73, 0
  br i1 %cmp74, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %56 = load i8*, i8** %out.addr, align 4
  %57 = load i32, i32* %i, align 4
  %add76 = add i32 %57, 1
  %arrayidx77 = getelementptr inbounds i8, i8* %56, i32 %add76
  %58 = load i8, i8* %arrayidx77, align 1
  %59 = load i8*, i8** %out.addr, align 4
  %60 = load i32, i32* %i, align 4
  %arrayidx78 = getelementptr inbounds i8, i8* %59, i32 %60
  store i8 %58, i8* %arrayidx78, align 1
  br label %for.inc

for.inc:                                          ; preds = %for.body
  %61 = load i32, i32* %i, align 4
  %inc79 = add i32 %61, 1
  store i32 %inc79, i32* %i, align 4
  br label %for.cond

for.end:                                          ; preds = %for.cond
  br label %while.cond62

while.end80:                                      ; preds = %land.end
  %62 = load i8*, i8** %out.addr, align 4
  %63 = load i8, i8* %62, align 1
  %conv81 = sext i8 %63 to i32
  %cmp82 = icmp eq i32 %conv81, 46
  br i1 %cmp82, label %if.then84, label %if.end86

if.then84:                                        ; preds = %while.end80
  %64 = load i8*, i8** %out.addr, align 4
  %65 = load i8*, i8** %p, align 4
  call void @reverse(i8* %64, i8* %65)
  %66 = load i8*, i8** %p, align 4
  %incdec.ptr85 = getelementptr inbounds i8, i8* %66, i32 1
  store i8* %incdec.ptr85, i8** %p, align 4
  store i8 48, i8* %66, align 1
  %67 = load i8*, i8** %p, align 4
  store i8 0, i8* %67, align 1
  %68 = load i8*, i8** %out.addr, align 4
  %69 = load i8*, i8** %p, align 4
  call void @reverse(i8* %68, i8* %69)
  br label %if.end86

if.end86:                                         ; preds = %if.then84, %while.end80
  %70 = load i8*, i8** %out.addr, align 4
  call void @makeQuaterImaginary(%struct.QuaterImaginary* sret align 4 %agg.result, i8* %70)
  br label %return

return:                                           ; preds = %if.end86, %if.then
  ret void
}

; Function Attrs: nounwind readnone speculatable willreturn
declare double @llvm.ceil.f64(double %0) #4

; Function Attrs: noinline nounwind optnone
define hidden i32 @main() #0 {
entry:
  %retval = alloca i32, align 4
  %buffer = alloca [16 x i8], align 16
  %i = alloca i32, align 4
  %c1 = alloca %struct.Complex, align 8
  %qi = alloca %struct.QuaterImaginary, align 4
  %c2 = alloca %struct.Complex, align 8
  %tmp = alloca %struct.Complex, align 8
  %tmp3 = alloca %struct.QuaterImaginary, align 4
  %tmp5 = alloca %struct.Complex, align 8
  %c114 = alloca %struct.Complex, align 8
  %qi18 = alloca %struct.QuaterImaginary, align 4
  %c220 = alloca %struct.Complex, align 8
  %tmp24 = alloca %struct.Complex, align 8
  %tmp25 = alloca %struct.QuaterImaginary, align 4
  %tmp27 = alloca %struct.Complex, align 8
  store i32 0, i32* %retval, align 4
  store i32 1, i32* %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %0 = load i32, i32* %i, align 4
  %cmp = icmp sle i32 %0, 16
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %rel = getelementptr inbounds %struct.Complex, %struct.Complex* %c1, i32 0, i32 0
  %1 = load i32, i32* %i, align 4
  %conv = sitofp i32 %1 to double
  store double %conv, double* %rel, align 8
  %img = getelementptr inbounds %struct.Complex, %struct.Complex* %c1, i32 0, i32 1
  store double 0.000000e+00, double* %img, align 8
  %arraydecay = getelementptr inbounds [16 x i8], [16 x i8]* %buffer, i32 0, i32 0
  call void @c2qi(%struct.QuaterImaginary* sret align 4 %qi, %struct.Complex* byval(%struct.Complex) align 8 %c1, i8* %arraydecay)
  call void @qi2c(%struct.Complex* sret align 8 %c2, %struct.QuaterImaginary* byval(%struct.QuaterImaginary) align 4 %qi)
  call void @printComplex(%struct.Complex* byval(%struct.Complex) align 8 %c1)
  %call = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.4, i32 0, i32 0))
  call void @printQuaterImaginary(%struct.QuaterImaginary* byval(%struct.QuaterImaginary) align 4 %qi)
  %call1 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.4, i32 0, i32 0))
  call void @printComplex(%struct.Complex* byval(%struct.Complex) align 8 %c2)
  %call2 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([6 x i8], [6 x i8]* @.str.5, i32 0, i32 0))
  call void @negComplex(%struct.Complex* sret align 8 %tmp, %struct.Complex* byval(%struct.Complex) align 8 %c1)
  %2 = bitcast %struct.Complex* %c1 to i8*
  %3 = bitcast %struct.Complex* %tmp to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 8 %2, i8* align 8 %3, i32 16, i1 false)
  %arraydecay4 = getelementptr inbounds [16 x i8], [16 x i8]* %buffer, i32 0, i32 0
  call void @c2qi(%struct.QuaterImaginary* sret align 4 %tmp3, %struct.Complex* byval(%struct.Complex) align 8 %c1, i8* %arraydecay4)
  %4 = bitcast %struct.QuaterImaginary* %qi to i8*
  %5 = bitcast %struct.QuaterImaginary* %tmp3 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 4 %4, i8* align 4 %5, i32 8, i1 false)
  call void @qi2c(%struct.Complex* sret align 8 %tmp5, %struct.QuaterImaginary* byval(%struct.QuaterImaginary) align 4 %qi)
  %6 = bitcast %struct.Complex* %c2 to i8*
  %7 = bitcast %struct.Complex* %tmp5 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 8 %6, i8* align 8 %7, i32 16, i1 false)
  call void @printComplex(%struct.Complex* byval(%struct.Complex) align 8 %c1)
  %call6 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.4, i32 0, i32 0))
  call void @printQuaterImaginary(%struct.QuaterImaginary* byval(%struct.QuaterImaginary) align 4 %qi)
  %call7 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.4, i32 0, i32 0))
  call void @printComplex(%struct.Complex* byval(%struct.Complex) align 8 %c2)
  %call8 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([2 x i8], [2 x i8]* @.str.6, i32 0, i32 0))
  br label %for.inc

for.inc:                                          ; preds = %for.body
  %8 = load i32, i32* %i, align 4
  %inc = add nsw i32 %8, 1
  store i32 %inc, i32* %i, align 4
  br label %for.cond

for.end:                                          ; preds = %for.cond
  %call9 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([2 x i8], [2 x i8]* @.str.6, i32 0, i32 0))
  store i32 1, i32* %i, align 4
  br label %for.cond10

for.cond10:                                       ; preds = %for.inc31, %for.end
  %9 = load i32, i32* %i, align 4
  %cmp11 = icmp sle i32 %9, 16
  br i1 %cmp11, label %for.body13, label %for.end33

for.body13:                                       ; preds = %for.cond10
  %rel15 = getelementptr inbounds %struct.Complex, %struct.Complex* %c114, i32 0, i32 0
  store double 0.000000e+00, double* %rel15, align 8
  %img16 = getelementptr inbounds %struct.Complex, %struct.Complex* %c114, i32 0, i32 1
  %10 = load i32, i32* %i, align 4
  %conv17 = sitofp i32 %10 to double
  store double %conv17, double* %img16, align 8
  %arraydecay19 = getelementptr inbounds [16 x i8], [16 x i8]* %buffer, i32 0, i32 0
  call void @c2qi(%struct.QuaterImaginary* sret align 4 %qi18, %struct.Complex* byval(%struct.Complex) align 8 %c114, i8* %arraydecay19)
  call void @qi2c(%struct.Complex* sret align 8 %c220, %struct.QuaterImaginary* byval(%struct.QuaterImaginary) align 4 %qi18)
  call void @printComplex(%struct.Complex* byval(%struct.Complex) align 8 %c114)
  %call21 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.4, i32 0, i32 0))
  call void @printQuaterImaginary(%struct.QuaterImaginary* byval(%struct.QuaterImaginary) align 4 %qi18)
  %call22 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.4, i32 0, i32 0))
  call void @printComplex(%struct.Complex* byval(%struct.Complex) align 8 %c220)
  %call23 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([6 x i8], [6 x i8]* @.str.5, i32 0, i32 0))
  call void @negComplex(%struct.Complex* sret align 8 %tmp24, %struct.Complex* byval(%struct.Complex) align 8 %c114)
  %11 = bitcast %struct.Complex* %c114 to i8*
  %12 = bitcast %struct.Complex* %tmp24 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 8 %11, i8* align 8 %12, i32 16, i1 false)
  %arraydecay26 = getelementptr inbounds [16 x i8], [16 x i8]* %buffer, i32 0, i32 0
  call void @c2qi(%struct.QuaterImaginary* sret align 4 %tmp25, %struct.Complex* byval(%struct.Complex) align 8 %c114, i8* %arraydecay26)
  %13 = bitcast %struct.QuaterImaginary* %qi18 to i8*
  %14 = bitcast %struct.QuaterImaginary* %tmp25 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 4 %13, i8* align 4 %14, i32 8, i1 false)
  call void @qi2c(%struct.Complex* sret align 8 %tmp27, %struct.QuaterImaginary* byval(%struct.QuaterImaginary) align 4 %qi18)
  %15 = bitcast %struct.Complex* %c220 to i8*
  %16 = bitcast %struct.Complex* %tmp27 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 8 %15, i8* align 8 %16, i32 16, i1 false)
  call void @printComplex(%struct.Complex* byval(%struct.Complex) align 8 %c114)
  %call28 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.4, i32 0, i32 0))
  call void @printQuaterImaginary(%struct.QuaterImaginary* byval(%struct.QuaterImaginary) align 4 %qi18)
  %call29 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.4, i32 0, i32 0))
  call void @printComplex(%struct.Complex* byval(%struct.Complex) align 8 %c220)
  %call30 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([2 x i8], [2 x i8]* @.str.6, i32 0, i32 0))
  br label %for.inc31

for.inc31:                                        ; preds = %for.body13
  %17 = load i32, i32* %i, align 4
  %inc32 = add nsw i32 %17, 1
  store i32 %inc32, i32* %i, align 4
  br label %for.cond10

for.end33:                                        ; preds = %for.cond10
  ret i32 0
}

attributes #0 = { noinline nounwind optnone "correctly-rounded-divide-sqrt-fp-math"="false" "disable-tail-calls"="false" "frame-pointer"="none" "less-precise-fpmad"="false" "min-legal-vector-width"="0" "no-infs-fp-math"="false" "no-jump-tables"="false" "no-nans-fp-math"="false" "no-signed-zeros-fp-math"="false" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="generic" "unsafe-fp-math"="false" "use-soft-float"="false" }
attributes #1 = { "correctly-rounded-divide-sqrt-fp-math"="false" "disable-tail-calls"="false" "frame-pointer"="none" "less-precise-fpmad"="false" "no-infs-fp-math"="false" "no-nans-fp-math"="false" "no-signed-zeros-fp-math"="false" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="generic" "unsafe-fp-math"="false" "use-soft-float"="false" }
attributes #2 = { nounwind readonly "correctly-rounded-divide-sqrt-fp-math"="false" "disable-tail-calls"="false" "frame-pointer"="none" "less-precise-fpmad"="false" "no-infs-fp-math"="false" "no-nans-fp-math"="false" "no-signed-zeros-fp-math"="false" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="generic" "unsafe-fp-math"="false" "use-soft-float"="false" }
attributes #3 = { argmemonly nounwind willreturn }
attributes #4 = { nounwind readnone speculatable willreturn }
attributes #5 = { nounwind readonly }

!llvm.module.flags = !{!0}
!llvm.ident = !{!1}

!0 = !{i32 1, !"wchar_size", i32 4}
!1 = !{!"clang version 11.0.0 (https://github.com/Jacarte/llvm-project.git 0f6dea67136cc1e0b3d200eb2bb165628970c44b)"}

; extracted candidates
#########################################################
; exiting Souper's runOnFunction() for mulComplexD()

; entering Souper's runOnFunction() for negComplex()

; ModuleID = './Imaginary_base_numbers.c.bc'
source_filename = "./Imaginary_base_numbers.c"
target datalayout = "e-m:e-p:32:32-i64:64-n32:64-S128"
target triple = "wasm32-unknown-wasi"

%struct.Complex = type { double, double }
%struct.QuaterImaginary = type { i8*, i32 }

@.str = private unnamed_addr constant [17 x i8] c"(%3.0f + %3.0fi)\00", align 1
@TWO_I = hidden constant %struct.Complex { double 0.000000e+00, double 2.000000e+00 }, align 8
@INV_TWO_I = hidden constant %struct.Complex { double 0.000000e+00, double -5.000000e-01 }, align 8
@.str.1 = private unnamed_addr constant [4 x i8] c"%8s\00", align 1
@.str.2 = private unnamed_addr constant [9 x i8] c" ERROR  \00", align 1
@.str.3 = private unnamed_addr constant [2 x i8] c"0\00", align 1
@.str.4 = private unnamed_addr constant [5 x i8] c" -> \00", align 1
@.str.5 = private unnamed_addr constant [6 x i8] c"     \00", align 1
@.str.6 = private unnamed_addr constant [2 x i8] c"\0A\00", align 1
@llvm.used = appending global [1 x i8*] [i8* bitcast (i32 ()* @__main_void to i8*)], section "llvm.metadata"

@__main_void = alias i32 (), i32 ()* @main

; Function Attrs: noinline nounwind optnone
define hidden i32 @find(i8* %s, i8 signext %c) #0 {
entry:
  %retval = alloca i32, align 4
  %s.addr = alloca i8*, align 4
  %c.addr = alloca i8, align 1
  %i = alloca i8*, align 4
  store i8* %s, i8** %s.addr, align 4
  store i8 %c, i8* %c.addr, align 1
  %0 = load i8*, i8** %s.addr, align 4
  store i8* %0, i8** %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %1 = load i8*, i8** %i, align 4
  %2 = load i8, i8* %1, align 1
  %conv = sext i8 %2 to i32
  %cmp = icmp ne i32 %conv, 0
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %3 = load i8*, i8** %i, align 4
  %4 = load i8, i8* %3, align 1
  %conv2 = sext i8 %4 to i32
  %5 = load i8, i8* %c.addr, align 1
  %conv3 = sext i8 %5 to i32
  %cmp4 = icmp eq i32 %conv2, %conv3
  br i1 %cmp4, label %if.then, label %if.end

if.then:                                          ; preds = %for.body
  %6 = load i8*, i8** %i, align 4
  %7 = load i8*, i8** %s.addr, align 4
  %sub.ptr.lhs.cast = ptrtoint i8* %6 to i32
  %sub.ptr.rhs.cast = ptrtoint i8* %7 to i32
  %sub.ptr.sub = sub i32 %sub.ptr.lhs.cast, %sub.ptr.rhs.cast
  store i32 %sub.ptr.sub, i32* %retval, align 4
  br label %return

if.end:                                           ; preds = %for.body
  br label %for.inc

for.inc:                                          ; preds = %if.end
  %8 = load i8*, i8** %i, align 4
  %incdec.ptr = getelementptr inbounds i8, i8* %8, i32 1
  store i8* %incdec.ptr, i8** %i, align 4
  br label %for.cond

for.end:                                          ; preds = %for.cond
  store i32 -1, i32* %retval, align 4
  br label %return

return:                                           ; preds = %for.end, %if.then
  %9 = load i32, i32* %retval, align 4
  ret i32 %9
}

; Function Attrs: noinline nounwind optnone
define hidden void @reverse(i8* %b, i8* %e) #0 {
entry:
  %b.addr = alloca i8*, align 4
  %e.addr = alloca i8*, align 4
  %t = alloca i8, align 1
  store i8* %b, i8** %b.addr, align 4
  store i8* %e, i8** %e.addr, align 4
  %0 = load i8*, i8** %e.addr, align 4
  %incdec.ptr = getelementptr inbounds i8, i8* %0, i32 -1
  store i8* %incdec.ptr, i8** %e.addr, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %1 = load i8*, i8** %b.addr, align 4
  %2 = load i8*, i8** %e.addr, align 4
  %cmp = icmp ult i8* %1, %2
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %3 = load i8*, i8** %b.addr, align 4
  %4 = load i8, i8* %3, align 1
  store i8 %4, i8* %t, align 1
  %5 = load i8*, i8** %e.addr, align 4
  %6 = load i8, i8* %5, align 1
  %7 = load i8*, i8** %b.addr, align 4
  store i8 %6, i8* %7, align 1
  %8 = load i8, i8* %t, align 1
  %9 = load i8*, i8** %e.addr, align 4
  store i8 %8, i8* %9, align 1
  br label %for.inc

for.inc:                                          ; preds = %for.body
  %10 = load i8*, i8** %b.addr, align 4
  %incdec.ptr1 = getelementptr inbounds i8, i8* %10, i32 1
  store i8* %incdec.ptr1, i8** %b.addr, align 4
  %11 = load i8*, i8** %e.addr, align 4
  %incdec.ptr2 = getelementptr inbounds i8, i8* %11, i32 -1
  store i8* %incdec.ptr2, i8** %e.addr, align 4
  br label %for.cond

for.end:                                          ; preds = %for.cond
  ret void
}

; Function Attrs: noinline nounwind optnone
define hidden void @printComplex(%struct.Complex* byval(%struct.Complex) align 8 %c) #0 {
entry:
  %rel = getelementptr inbounds %struct.Complex, %struct.Complex* %c, i32 0, i32 0
  %0 = load double, double* %rel, align 8
  %img = getelementptr inbounds %struct.Complex, %struct.Complex* %c, i32 0, i32 1
  %1 = load double, double* %img, align 8
  %call = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([17 x i8], [17 x i8]* @.str, i32 0, i32 0), double %0, double %1)
  ret void
}

declare i32 @printf(i8* %0, ...) #1

; Function Attrs: noinline nounwind optnone
define hidden void @makeComplex(%struct.Complex* noalias sret align 8 %agg.result, double %rel, double %img) #0 {
entry:
  %rel.addr = alloca double, align 8
  %img.addr = alloca double, align 8
  store double %rel, double* %rel.addr, align 8
  store double %img, double* %img.addr, align 8
  %rel1 = getelementptr inbounds %struct.Complex, %struct.Complex* %agg.result, i32 0, i32 0
  %0 = load double, double* %rel.addr, align 8
  store double %0, double* %rel1, align 8
  %img2 = getelementptr inbounds %struct.Complex, %struct.Complex* %agg.result, i32 0, i32 1
  %1 = load double, double* %img.addr, align 8
  store double %1, double* %img2, align 8
  ret void
}

; Function Attrs: noinline nounwind optnone
define hidden void @addComplex(%struct.Complex* noalias sret align 8 %agg.result, %struct.Complex* byval(%struct.Complex) align 8 %a, %struct.Complex* byval(%struct.Complex) align 8 %b) #0 {
entry:
  %rel = getelementptr inbounds %struct.Complex, %struct.Complex* %agg.result, i32 0, i32 0
  %rel1 = getelementptr inbounds %struct.Complex, %struct.Complex* %a, i32 0, i32 0
  %0 = load double, double* %rel1, align 8
  %rel2 = getelementptr inbounds %struct.Complex, %struct.Complex* %b, i32 0, i32 0
  %1 = load double, double* %rel2, align 8
  %add = fadd double %0, %1
  store double %add, double* %rel, align 8
  %img = getelementptr inbounds %struct.Complex, %struct.Complex* %agg.result, i32 0, i32 1
  %img3 = getelementptr inbounds %struct.Complex, %struct.Complex* %a, i32 0, i32 1
  %2 = load double, double* %img3, align 8
  %img4 = getelementptr inbounds %struct.Complex, %struct.Complex* %b, i32 0, i32 1
  %3 = load double, double* %img4, align 8
  %add5 = fadd double %2, %3
  store double %add5, double* %img, align 8
  ret void
}

; Function Attrs: noinline nounwind optnone
define hidden void @mulComplex(%struct.Complex* noalias sret align 8 %agg.result, %struct.Complex* byval(%struct.Complex) align 8 %a, %struct.Complex* byval(%struct.Complex) align 8 %b) #0 {
entry:
  %rel = getelementptr inbounds %struct.Complex, %struct.Complex* %agg.result, i32 0, i32 0
  %rel1 = getelementptr inbounds %struct.Complex, %struct.Complex* %a, i32 0, i32 0
  %0 = load double, double* %rel1, align 8
  %rel2 = getelementptr inbounds %struct.Complex, %struct.Complex* %b, i32 0, i32 0
  %1 = load double, double* %rel2, align 8
  %mul = fmul double %0, %1
  %img = getelementptr inbounds %struct.Complex, %struct.Complex* %a, i32 0, i32 1
  %2 = load double, double* %img, align 8
  %img3 = getelementptr inbounds %struct.Complex, %struct.Complex* %b, i32 0, i32 1
  %3 = load double, double* %img3, align 8
  %mul4 = fmul double %2, %3
  %sub = fsub double %mul, %mul4
  store double %sub, double* %rel, align 8
  %img5 = getelementptr inbounds %struct.Complex, %struct.Complex* %agg.result, i32 0, i32 1
  %rel6 = getelementptr inbounds %struct.Complex, %struct.Complex* %a, i32 0, i32 0
  %4 = load double, double* %rel6, align 8
  %img7 = getelementptr inbounds %struct.Complex, %struct.Complex* %b, i32 0, i32 1
  %5 = load double, double* %img7, align 8
  %mul8 = fmul double %4, %5
  %img9 = getelementptr inbounds %struct.Complex, %struct.Complex* %a, i32 0, i32 1
  %6 = load double, double* %img9, align 8
  %rel10 = getelementptr inbounds %struct.Complex, %struct.Complex* %b, i32 0, i32 0
  %7 = load double, double* %rel10, align 8
  %mul11 = fmul double %6, %7
  %sub12 = fsub double %mul8, %mul11
  store double %sub12, double* %img5, align 8
  ret void
}

; Function Attrs: noinline nounwind optnone
define hidden void @mulComplexD(%struct.Complex* noalias sret align 8 %agg.result, %struct.Complex* byval(%struct.Complex) align 8 %a, double %b) #0 {
entry:
  %b.addr = alloca double, align 8
  store double %b, double* %b.addr, align 8
  %rel = getelementptr inbounds %struct.Complex, %struct.Complex* %agg.result, i32 0, i32 0
  %rel1 = getelementptr inbounds %struct.Complex, %struct.Complex* %a, i32 0, i32 0
  %0 = load double, double* %rel1, align 8
  %1 = load double, double* %b.addr, align 8
  %mul = fmul double %0, %1
  store double %mul, double* %rel, align 8
  %img = getelementptr inbounds %struct.Complex, %struct.Complex* %agg.result, i32 0, i32 1
  %img2 = getelementptr inbounds %struct.Complex, %struct.Complex* %a, i32 0, i32 1
  %2 = load double, double* %img2, align 8
  %3 = load double, double* %b.addr, align 8
  %mul3 = fmul double %2, %3
  store double %mul3, double* %img, align 8
  ret void
}

; Function Attrs: noinline nounwind optnone
define hidden void @negComplex(%struct.Complex* noalias sret align 8 %agg.result, %struct.Complex* byval(%struct.Complex) align 8 %a) #0 {
entry:
  call void @mulComplexD(%struct.Complex* sret align 8 %agg.result, %struct.Complex* byval(%struct.Complex) align 8 %a, double -1.000000e+00)
  ret void
}

; Function Attrs: noinline nounwind optnone
define hidden void @divComplex(%struct.Complex* noalias sret align 8 %agg.result, %struct.Complex* byval(%struct.Complex) align 8 %a, %struct.Complex* byval(%struct.Complex) align 8 %b) #0 {
entry:
  %re = alloca double, align 8
  %im = alloca double, align 8
  %d = alloca double, align 8
  %rel = getelementptr inbounds %struct.Complex, %struct.Complex* %a, i32 0, i32 0
  %0 = load double, double* %rel, align 8
  %rel1 = getelementptr inbounds %struct.Complex, %struct.Complex* %b, i32 0, i32 0
  %1 = load double, double* %rel1, align 8
  %mul = fmul double %0, %1
  %img = getelementptr inbounds %struct.Complex, %struct.Complex* %a, i32 0, i32 1
  %2 = load double, double* %img, align 8
  %img2 = getelementptr inbounds %struct.Complex, %struct.Complex* %b, i32 0, i32 1
  %3 = load double, double* %img2, align 8
  %mul3 = fmul double %2, %3
  %add = fadd double %mul, %mul3
  store double %add, double* %re, align 8
  %img4 = getelementptr inbounds %struct.Complex, %struct.Complex* %a, i32 0, i32 1
  %4 = load double, double* %img4, align 8
  %rel5 = getelementptr inbounds %struct.Complex, %struct.Complex* %b, i32 0, i32 0
  %5 = load double, double* %rel5, align 8
  %mul6 = fmul double %4, %5
  %rel7 = getelementptr inbounds %struct.Complex, %struct.Complex* %a, i32 0, i32 0
  %6 = load double, double* %rel7, align 8
  %img8 = getelementptr inbounds %struct.Complex, %struct.Complex* %b, i32 0, i32 1
  %7 = load double, double* %img8, align 8
  %mul9 = fmul double %6, %7
  %sub = fsub double %mul6, %mul9
  store double %sub, double* %im, align 8
  %rel10 = getelementptr inbounds %struct.Complex, %struct.Complex* %b, i32 0, i32 0
  %8 = load double, double* %rel10, align 8
  %rel11 = getelementptr inbounds %struct.Complex, %struct.Complex* %b, i32 0, i32 0
  %9 = load double, double* %rel11, align 8
  %mul12 = fmul double %8, %9
  %img13 = getelementptr inbounds %struct.Complex, %struct.Complex* %b, i32 0, i32 1
  %10 = load double, double* %img13, align 8
  %img14 = getelementptr inbounds %struct.Complex, %struct.Complex* %b, i32 0, i32 1
  %11 = load double, double* %img14, align 8
  %mul15 = fmul double %10, %11
  %add16 = fadd double %mul12, %mul15
  store double %add16, double* %d, align 8
  %rel17 = getelementptr inbounds %struct.Complex, %struct.Complex* %agg.result, i32 0, i32 0
  %12 = load double, double* %re, align 8
  %13 = load double, double* %d, align 8
  %div = fdiv double %12, %13
  store double %div, double* %rel17, align 8
  %img18 = getelementptr inbounds %struct.Complex, %struct.Complex* %agg.result, i32 0, i32 1
  %14 = load double, double* %im, align 8
  %15 = load double, double* %d, align 8
  %div19 = fdiv double %14, %15
  store double %div19, double* %img18, align 8
  ret void
}

; Function Attrs: noinline nounwind optnone
define hidden void @inv(%struct.Complex* noalias sret align 8 %agg.result, %struct.Complex* byval(%struct.Complex) align 8 %c) #0 {
entry:
  %d = alloca double, align 8
  %rel = getelementptr inbounds %struct.Complex, %struct.Complex* %c, i32 0, i32 0
  %0 = load double, double* %rel, align 8
  %rel1 = getelementptr inbounds %struct.Complex, %struct.Complex* %c, i32 0, i32 0
  %1 = load double, double* %rel1, align 8
  %mul = fmul double %0, %1
  %img = getelementptr inbounds %struct.Complex, %struct.Complex* %c, i32 0, i32 1
  %2 = load double, double* %img, align 8
  %img2 = getelementptr inbounds %struct.Complex, %struct.Complex* %c, i32 0, i32 1
  %3 = load double, double* %img2, align 8
  %mul3 = fmul double %2, %3
  %add = fadd double %mul, %mul3
  store double %add, double* %d, align 8
  %rel4 = getelementptr inbounds %struct.Complex, %struct.Complex* %agg.result, i32 0, i32 0
  %rel5 = getelementptr inbounds %struct.Complex, %struct.Complex* %c, i32 0, i32 0
  %4 = load double, double* %rel5, align 8
  %5 = load double, double* %d, align 8
  %div = fdiv double %4, %5
  store double %div, double* %rel4, align 8
  %img6 = getelementptr inbounds %struct.Complex, %struct.Complex* %agg.result, i32 0, i32 1
  %img7 = getelementptr inbounds %struct.Complex, %struct.Complex* %c, i32 0, i32 1
  %6 = load double, double* %img7, align 8
  %fneg = fneg double %6
  %7 = load double, double* %d, align 8
  %div8 = fdiv double %fneg, %7
  store double %div8, double* %img6, align 8
  ret void
}

; Function Attrs: noinline nounwind optnone
define hidden void @makeQuaterImaginary(%struct.QuaterImaginary* noalias sret align 4 %agg.result, i8* %s) #0 {
entry:
  %s.addr = alloca i8*, align 4
  %i = alloca i32, align 4
  %valid1 = alloca i32, align 4
  %cnt = alloca i32, align 4
  store i8* %s, i8** %s.addr, align 4
  %b2i = getelementptr inbounds %struct.QuaterImaginary, %struct.QuaterImaginary* %agg.result, i32 0, i32 0
  %0 = load i8*, i8** %s.addr, align 4
  store i8* %0, i8** %b2i, align 4
  %valid = getelementptr inbounds %struct.QuaterImaginary, %struct.QuaterImaginary* %agg.result, i32 0, i32 1
  store i32 0, i32* %valid, align 4
  store i32 1, i32* %valid1, align 4
  store i32 0, i32* %cnt, align 4
  %1 = load i8*, i8** %s.addr, align 4
  %2 = load i8, i8* %1, align 1
  %conv = sext i8 %2 to i32
  %cmp = icmp ne i32 %conv, 0
  br i1 %cmp, label %if.then, label %if.end26

if.then:                                          ; preds = %entry
  store i32 0, i32* %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.then
  %3 = load i8*, i8** %s.addr, align 4
  %4 = load i32, i32* %i, align 4
  %arrayidx = getelementptr inbounds i8, i8* %3, i32 %4
  %5 = load i8, i8* %arrayidx, align 1
  %conv3 = sext i8 %5 to i32
  %cmp4 = icmp ne i32 %conv3, 0
  br i1 %cmp4, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %6 = load i8*, i8** %s.addr, align 4
  %7 = load i32, i32* %i, align 4
  %arrayidx6 = getelementptr inbounds i8, i8* %6, i32 %7
  %8 = load i8, i8* %arrayidx6, align 1
  %conv7 = sext i8 %8 to i32
  %cmp8 = icmp slt i32 %conv7, 48
  br i1 %cmp8, label %if.then14, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %for.body
  %9 = load i8*, i8** %s.addr, align 4
  %10 = load i32, i32* %i, align 4
  %arrayidx10 = getelementptr inbounds i8, i8* %9, i32 %10
  %11 = load i8, i8* %arrayidx10, align 1
  %conv11 = sext i8 %11 to i32
  %cmp12 = icmp slt i32 51, %conv11
  br i1 %cmp12, label %if.then14, label %if.end20

if.then14:                                        ; preds = %lor.lhs.false, %for.body
  %12 = load i8*, i8** %s.addr, align 4
  %13 = load i32, i32* %i, align 4
  %arrayidx15 = getelementptr inbounds i8, i8* %12, i32 %13
  %14 = load i8, i8* %arrayidx15, align 1
  %conv16 = sext i8 %14 to i32
  %cmp17 = icmp eq i32 %conv16, 46
  br i1 %cmp17, label %if.then19, label %if.else

if.then19:                                        ; preds = %if.then14
  %15 = load i32, i32* %cnt, align 4
  %inc = add i32 %15, 1
  store i32 %inc, i32* %cnt, align 4
  br label %if.end

if.else:                                          ; preds = %if.then14
  store i32 0, i32* %valid1, align 4
  br label %for.end

if.end:                                           ; preds = %if.then19
  br label %if.end20

if.end20:                                         ; preds = %if.end, %lor.lhs.false
  br label %for.inc

for.inc:                                          ; preds = %if.end20
  %16 = load i32, i32* %i, align 4
  %inc21 = add i32 %16, 1
  store i32 %inc21, i32* %i, align 4
  br label %for.cond

for.end:                                          ; preds = %if.else, %for.cond
  %17 = load i32, i32* %valid1, align 4
  %tobool = icmp ne i32 %17, 0
  br i1 %tobool, label %land.lhs.true, label %if.end25

land.lhs.true:                                    ; preds = %for.end
  %18 = load i32, i32* %cnt, align 4
  %cmp22 = icmp ugt i32 %18, 1
  br i1 %cmp22, label %if.then24, label %if.end25

if.then24:                                        ; preds = %land.lhs.true
  store i32 0, i32* %valid1, align 4
  br label %if.end25

if.end25:                                         ; preds = %if.then24, %land.lhs.true, %for.end
  br label %if.end26

if.end26:                                         ; preds = %if.end25, %entry
  %19 = load i32, i32* %valid1, align 4
  %valid27 = getelementptr inbounds %struct.QuaterImaginary, %struct.QuaterImaginary* %agg.result, i32 0, i32 1
  store i32 %19, i32* %valid27, align 4
  ret void
}

; Function Attrs: noinline nounwind optnone
define hidden void @printQuaterImaginary(%struct.QuaterImaginary* byval(%struct.QuaterImaginary) align 4 %qi) #0 {
entry:
  %valid = getelementptr inbounds %struct.QuaterImaginary, %struct.QuaterImaginary* %qi, i32 0, i32 1
  %0 = load i32, i32* %valid, align 4
  %tobool = icmp ne i32 %0, 0
  br i1 %tobool, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  %b2i = getelementptr inbounds %struct.QuaterImaginary, %struct.QuaterImaginary* %qi, i32 0, i32 0
  %1 = load i8*, i8** %b2i, align 4
  %call = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([4 x i8], [4 x i8]* @.str.1, i32 0, i32 0), i8* %1)
  br label %if.end

if.else:                                          ; preds = %entry
  %call1 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([9 x i8], [9 x i8]* @.str.2, i32 0, i32 0))
  br label %if.end

if.end:                                           ; preds = %if.else, %if.then
  ret void
}

; Function Attrs: noinline nounwind optnone
define hidden void @qi2c(%struct.Complex* noalias sret align 8 %agg.result, %struct.QuaterImaginary* byval(%struct.QuaterImaginary) align 4 %qi) #0 {
entry:
  %len = alloca i32, align 4
  %pointPos = alloca i32, align 4
  %posLen = alloca i32, align 4
  %prod = alloca %struct.Complex, align 8
  %j = alloca i32, align 4
  %k = alloca double, align 8
  %tmp = alloca %struct.Complex, align 8
  %agg.tmp = alloca %struct.Complex, align 8
  %tmp10 = alloca %struct.Complex, align 8
  %k18 = alloca double, align 8
  %tmp27 = alloca %struct.Complex, align 8
  %agg.tmp28 = alloca %struct.Complex, align 8
  %tmp30 = alloca %struct.Complex, align 8
  %b2i = getelementptr inbounds %struct.QuaterImaginary, %struct.QuaterImaginary* %qi, i32 0, i32 0
  %0 = load i8*, i8** %b2i, align 4
  %call = call i32 @strlen(i8* %0) #5
  store i32 %call, i32* %len, align 4
  %b2i1 = getelementptr inbounds %struct.QuaterImaginary, %struct.QuaterImaginary* %qi, i32 0, i32 0
  %1 = load i8*, i8** %b2i1, align 4
  %call2 = call i32 @find(i8* %1, i8 signext 46)
  store i32 %call2, i32* %pointPos, align 4
  %2 = load i32, i32* %pointPos, align 4
  %cmp = icmp sgt i32 %2, 0
  br i1 %cmp, label %cond.true, label %cond.false

cond.true:                                        ; preds = %entry
  %3 = load i32, i32* %pointPos, align 4
  br label %cond.end

cond.false:                                       ; preds = %entry
  %4 = load i32, i32* %len, align 4
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi i32 [ %3, %cond.true ], [ %4, %cond.false ]
  store i32 %cond, i32* %posLen, align 4
  call void @makeComplex(%struct.Complex* sret align 8 %agg.result, double 0.000000e+00, double 0.000000e+00)
  call void @makeComplex(%struct.Complex* sret align 8 %prod, double 1.000000e+00, double 0.000000e+00)
  store i32 0, i32* %j, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %cond.end
  %5 = load i32, i32* %j, align 4
  %6 = load i32, i32* %posLen, align 4
  %cmp3 = icmp ult i32 %5, %6
  br i1 %cmp3, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %b2i4 = getelementptr inbounds %struct.QuaterImaginary, %struct.QuaterImaginary* %qi, i32 0, i32 0
  %7 = load i8*, i8** %b2i4, align 4
  %8 = load i32, i32* %posLen, align 4
  %sub = sub i32 %8, 1
  %9 = load i32, i32* %j, align 4
  %sub5 = sub i32 %sub, %9
  %arrayidx = getelementptr inbounds i8, i8* %7, i32 %sub5
  %10 = load i8, i8* %arrayidx, align 1
  %conv = sext i8 %10 to i32
  %sub6 = sub nsw i32 %conv, 48
  %conv7 = sitofp i32 %sub6 to double
  store double %conv7, double* %k, align 8
  %11 = load double, double* %k, align 8
  %cmp8 = fcmp ogt double %11, 0.000000e+00
  br i1 %cmp8, label %if.then, label %if.end

if.then:                                          ; preds = %for.body
  %12 = load double, double* %k, align 8
  call void @mulComplexD(%struct.Complex* sret align 8 %agg.tmp, %struct.Complex* byval(%struct.Complex) align 8 %prod, double %12)
  call void @addComplex(%struct.Complex* sret align 8 %tmp, %struct.Complex* byval(%struct.Complex) align 8 %agg.result, %struct.Complex* byval(%struct.Complex) align 8 %agg.tmp)
  %13 = bitcast %struct.Complex* %agg.result to i8*
  %14 = bitcast %struct.Complex* %tmp to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 8 %13, i8* align 8 %14, i32 16, i1 false)
  br label %if.end

if.end:                                           ; preds = %if.then, %for.body
  call void @mulComplex(%struct.Complex* sret align 8 %tmp10, %struct.Complex* byval(%struct.Complex) align 8 %prod, %struct.Complex* byval(%struct.Complex) align 8 @TWO_I)
  %15 = bitcast %struct.Complex* %prod to i8*
  %16 = bitcast %struct.Complex* %tmp10 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 8 %15, i8* align 8 %16, i32 16, i1 false)
  br label %for.inc

for.inc:                                          ; preds = %if.end
  %17 = load i32, i32* %j, align 4
  %inc = add i32 %17, 1
  store i32 %inc, i32* %j, align 4
  br label %for.cond

for.end:                                          ; preds = %for.cond
  %18 = load i32, i32* %pointPos, align 4
  %cmp11 = icmp ne i32 %18, -1
  br i1 %cmp11, label %if.then13, label %if.end34

if.then13:                                        ; preds = %for.end
  %19 = bitcast %struct.Complex* %prod to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 8 %19, i8* align 8 bitcast (%struct.Complex* @INV_TWO_I to i8*), i32 16, i1 false)
  %20 = load i32, i32* %posLen, align 4
  %add = add i32 %20, 1
  store i32 %add, i32* %j, align 4
  br label %for.cond14

for.cond14:                                       ; preds = %for.inc31, %if.then13
  %21 = load i32, i32* %j, align 4
  %22 = load i32, i32* %len, align 4
  %cmp15 = icmp ult i32 %21, %22
  br i1 %cmp15, label %for.body17, label %for.end33

for.body17:                                       ; preds = %for.cond14
  %b2i19 = getelementptr inbounds %struct.QuaterImaginary, %struct.QuaterImaginary* %qi, i32 0, i32 0
  %23 = load i8*, i8** %b2i19, align 4
  %24 = load i32, i32* %j, align 4
  %arrayidx20 = getelementptr inbounds i8, i8* %23, i32 %24
  %25 = load i8, i8* %arrayidx20, align 1
  %conv21 = sext i8 %25 to i32
  %sub22 = sub nsw i32 %conv21, 48
  %conv23 = sitofp i32 %sub22 to double
  store double %conv23, double* %k18, align 8
  %26 = load double, double* %k18, align 8
  %cmp24 = fcmp ogt double %26, 0.000000e+00
  br i1 %cmp24, label %if.then26, label %if.end29

if.then26:                                        ; preds = %for.body17
  %27 = load double, double* %k18, align 8
  call void @mulComplexD(%struct.Complex* sret align 8 %agg.tmp28, %struct.Complex* byval(%struct.Complex) align 8 %prod, double %27)
  call void @addComplex(%struct.Complex* sret align 8 %tmp27, %struct.Complex* byval(%struct.Complex) align 8 %agg.result, %struct.Complex* byval(%struct.Complex) align 8 %agg.tmp28)
  %28 = bitcast %struct.Complex* %agg.result to i8*
  %29 = bitcast %struct.Complex* %tmp27 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 8 %28, i8* align 8 %29, i32 16, i1 false)
  br label %if.end29

if.end29:                                         ; preds = %if.then26, %for.body17
  call void @mulComplex(%struct.Complex* sret align 8 %tmp30, %struct.Complex* byval(%struct.Complex) align 8 %prod, %struct.Complex* byval(%struct.Complex) align 8 @INV_TWO_I)
  %30 = bitcast %struct.Complex* %prod to i8*
  %31 = bitcast %struct.Complex* %tmp30 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 8 %30, i8* align 8 %31, i32 16, i1 false)
  br label %for.inc31

for.inc31:                                        ; preds = %if.end29
  %32 = load i32, i32* %j, align 4
  %inc32 = add i32 %32, 1
  store i32 %inc32, i32* %j, align 4
  br label %for.cond14

for.end33:                                        ; preds = %for.cond14
  br label %if.end34

if.end34:                                         ; preds = %for.end33, %for.end
  ret void
}

; Function Attrs: nounwind readonly
declare i32 @strlen(i8* %0) #2

; Function Attrs: argmemonly nounwind willreturn
declare void @llvm.memcpy.p0i8.p0i8.i32(i8* noalias nocapture writeonly %0, i8* noalias nocapture readonly %1, i32 %2, i1 immarg %3) #3

; Function Attrs: noinline nounwind optnone
define hidden void @c2qi(%struct.QuaterImaginary* noalias sret align 4 %agg.result, %struct.Complex* byval(%struct.Complex) align 8 %c, i8* %out) #0 {
entry:
  %out.addr = alloca i8*, align 4
  %p = alloca i8*, align 4
  %re = alloca i32, align 4
  %im = alloca i32, align 4
  %fi = alloca i32, align 4
  %rem = alloca i32, align 4
  %index = alloca i32, align 4
  %fc = alloca %struct.Complex, align 8
  %.compoundliteral = alloca %struct.Complex, align 8
  %.compoundliteral21 = alloca %struct.Complex, align 8
  %f = alloca double, align 8
  %rem31 = alloca i32, align 4
  %i = alloca i32, align 4
  store i8* %out, i8** %out.addr, align 4
  %0 = load i8*, i8** %out.addr, align 4
  store i8* %0, i8** %p, align 4
  %1 = load i8*, i8** %p, align 4
  store i8 0, i8* %1, align 1
  %rel = getelementptr inbounds %struct.Complex, %struct.Complex* %c, i32 0, i32 0
  %2 = load double, double* %rel, align 8
  %cmp = fcmp oeq double %2, 0.000000e+00
  br i1 %cmp, label %land.lhs.true, label %if.end

land.lhs.true:                                    ; preds = %entry
  %img = getelementptr inbounds %struct.Complex, %struct.Complex* %c, i32 0, i32 1
  %3 = load double, double* %img, align 8
  %cmp1 = fcmp oeq double %3, 0.000000e+00
  br i1 %cmp1, label %if.then, label %if.end

if.then:                                          ; preds = %land.lhs.true
  call void @makeQuaterImaginary(%struct.QuaterImaginary* sret align 4 %agg.result, i8* getelementptr inbounds ([2 x i8], [2 x i8]* @.str.3, i32 0, i32 0))
  br label %return

if.end:                                           ; preds = %land.lhs.true, %entry
  %rel2 = getelementptr inbounds %struct.Complex, %struct.Complex* %c, i32 0, i32 0
  %4 = load double, double* %rel2, align 8
  %conv = fptosi double %4 to i32
  store i32 %conv, i32* %re, align 4
  %img3 = getelementptr inbounds %struct.Complex, %struct.Complex* %c, i32 0, i32 1
  %5 = load double, double* %img3, align 8
  %conv4 = fptosi double %5 to i32
  store i32 %conv4, i32* %im, align 4
  store i32 -1, i32* %fi, align 4
  br label %while.cond

while.cond:                                       ; preds = %if.end11, %if.end
  %6 = load i32, i32* %re, align 4
  %cmp5 = icmp ne i32 %6, 0
  br i1 %cmp5, label %while.body, label %while.end

while.body:                                       ; preds = %while.cond
  %7 = load i32, i32* %re, align 4
  %rem7 = srem i32 %7, -4
  store i32 %rem7, i32* %rem, align 4
  %8 = load i32, i32* %re, align 4
  %div = sdiv i32 %8, -4
  store i32 %div, i32* %re, align 4
  %9 = load i32, i32* %rem, align 4
  %cmp8 = icmp slt i32 %9, 0
  br i1 %cmp8, label %if.then10, label %if.end11

if.then10:                                        ; preds = %while.body
  %10 = load i32, i32* %rem, align 4
  %add = add nsw i32 %10, 4
  store i32 %add, i32* %rem, align 4
  %11 = load i32, i32* %re, align 4
  %inc = add nsw i32 %11, 1
  store i32 %inc, i32* %re, align 4
  br label %if.end11

if.end11:                                         ; preds = %if.then10, %while.body
  %12 = load i32, i32* %rem, align 4
  %add12 = add nsw i32 %12, 48
  %conv13 = trunc i32 %add12 to i8
  %13 = load i8*, i8** %p, align 4
  %incdec.ptr = getelementptr inbounds i8, i8* %13, i32 1
  store i8* %incdec.ptr, i8** %p, align 4
  store i8 %conv13, i8* %13, align 1
  %14 = load i8*, i8** %p, align 4
  %incdec.ptr14 = getelementptr inbounds i8, i8* %14, i32 1
  store i8* %incdec.ptr14, i8** %p, align 4
  store i8 48, i8* %14, align 1
  %15 = load i8*, i8** %p, align 4
  store i8 0, i8* %15, align 1
  br label %while.cond

while.end:                                        ; preds = %while.cond
  %16 = load i32, i32* %im, align 4
  %cmp15 = icmp ne i32 %16, 0
  br i1 %cmp15, label %if.then17, label %if.end53

if.then17:                                        ; preds = %while.end
  store i32 1, i32* %index, align 4
  %rel18 = getelementptr inbounds %struct.Complex, %struct.Complex* %.compoundliteral, i32 0, i32 0
  store double 0.000000e+00, double* %rel18, align 8
  %img19 = getelementptr inbounds %struct.Complex, %struct.Complex* %.compoundliteral, i32 0, i32 1
  %img20 = getelementptr inbounds %struct.Complex, %struct.Complex* %c, i32 0, i32 1
  %17 = load double, double* %img20, align 8
  store double %17, double* %img19, align 8
  %rel22 = getelementptr inbounds %struct.Complex, %struct.Complex* %.compoundliteral21, i32 0, i32 0
  store double 0.000000e+00, double* %rel22, align 8
  %img23 = getelementptr inbounds %struct.Complex, %struct.Complex* %.compoundliteral21, i32 0, i32 1
  store double 2.000000e+00, double* %img23, align 8
  call void @divComplex(%struct.Complex* sret align 8 %fc, %struct.Complex* byval(%struct.Complex) align 8 %.compoundliteral, %struct.Complex* byval(%struct.Complex) align 8 %.compoundliteral21)
  %rel24 = getelementptr inbounds %struct.Complex, %struct.Complex* %fc, i32 0, i32 0
  %18 = load double, double* %rel24, align 8
  store double %18, double* %f, align 8
  %19 = load double, double* %f, align 8
  %20 = call double @llvm.ceil.f64(double %19)
  %conv25 = fptosi double %20 to i32
  store i32 %conv25, i32* %im, align 4
  %21 = load double, double* %f, align 8
  %22 = load i32, i32* %im, align 4
  %conv26 = sitofp i32 %22 to double
  %sub = fsub double %21, %conv26
  %mul = fmul double -4.000000e+00, %sub
  store double %mul, double* %f, align 8
  br label %while.cond27

while.cond27:                                     ; preds = %if.end49, %if.then17
  %23 = load i32, i32* %im, align 4
  %cmp28 = icmp ne i32 %23, 0
  br i1 %cmp28, label %while.body30, label %while.end51

while.body30:                                     ; preds = %while.cond27
  %24 = load i32, i32* %im, align 4
  %rem32 = srem i32 %24, -4
  store i32 %rem32, i32* %rem31, align 4
  %25 = load i32, i32* %im, align 4
  %div33 = sdiv i32 %25, -4
  store i32 %div33, i32* %im, align 4
  %26 = load i32, i32* %rem31, align 4
  %cmp34 = icmp slt i32 %26, 0
  br i1 %cmp34, label %if.then36, label %if.end39

if.then36:                                        ; preds = %while.body30
  %27 = load i32, i32* %rem31, align 4
  %add37 = add nsw i32 %27, 4
  store i32 %add37, i32* %rem31, align 4
  %28 = load i32, i32* %im, align 4
  %inc38 = add nsw i32 %28, 1
  store i32 %inc38, i32* %im, align 4
  br label %if.end39

if.end39:                                         ; preds = %if.then36, %while.body30
  %29 = load i32, i32* %index, align 4
  %30 = load i8*, i8** %p, align 4
  %31 = load i8*, i8** %out.addr, align 4
  %sub.ptr.lhs.cast = ptrtoint i8* %30 to i32
  %sub.ptr.rhs.cast = ptrtoint i8* %31 to i32
  %sub.ptr.sub = sub i32 %sub.ptr.lhs.cast, %sub.ptr.rhs.cast
  %cmp40 = icmp ult i32 %29, %sub.ptr.sub
  br i1 %cmp40, label %if.then42, label %if.else

if.then42:                                        ; preds = %if.end39
  %32 = load i32, i32* %rem31, align 4
  %add43 = add nsw i32 %32, 48
  %conv44 = trunc i32 %add43 to i8
  %33 = load i8*, i8** %out.addr, align 4
  %34 = load i32, i32* %index, align 4
  %arrayidx = getelementptr inbounds i8, i8* %33, i32 %34
  store i8 %conv44, i8* %arrayidx, align 1
  br label %if.end49

if.else:                                          ; preds = %if.end39
  %35 = load i8*, i8** %p, align 4
  %incdec.ptr45 = getelementptr inbounds i8, i8* %35, i32 1
  store i8* %incdec.ptr45, i8** %p, align 4
  store i8 48, i8* %35, align 1
  %36 = load i32, i32* %rem31, align 4
  %add46 = add nsw i32 %36, 48
  %conv47 = trunc i32 %add46 to i8
  %37 = load i8*, i8** %p, align 4
  %incdec.ptr48 = getelementptr inbounds i8, i8* %37, i32 1
  store i8* %incdec.ptr48, i8** %p, align 4
  store i8 %conv47, i8* %37, align 1
  %38 = load i8*, i8** %p, align 4
  store i8 0, i8* %38, align 1
  br label %if.end49

if.end49:                                         ; preds = %if.else, %if.then42
  %39 = load i32, i32* %index, align 4
  %add50 = add i32 %39, 2
  store i32 %add50, i32* %index, align 4
  br label %while.cond27

while.end51:                                      ; preds = %while.cond27
  %40 = load double, double* %f, align 8
  %conv52 = fptosi double %40 to i32
  store i32 %conv52, i32* %fi, align 4
  br label %if.end53

if.end53:                                         ; preds = %while.end51, %while.end
  %41 = load i8*, i8** %out.addr, align 4
  %42 = load i8*, i8** %p, align 4
  call void @reverse(i8* %41, i8* %42)
  %43 = load i32, i32* %fi, align 4
  %cmp54 = icmp ne i32 %43, -1
  br i1 %cmp54, label %if.then56, label %if.end61

if.then56:                                        ; preds = %if.end53
  %44 = load i8*, i8** %p, align 4
  %incdec.ptr57 = getelementptr inbounds i8, i8* %44, i32 1
  store i8* %incdec.ptr57, i8** %p, align 4
  store i8 46, i8* %44, align 1
  %45 = load i32, i32* %fi, align 4
  %add58 = add nsw i32 %45, 48
  %conv59 = trunc i32 %add58 to i8
  %46 = load i8*, i8** %p, align 4
  %incdec.ptr60 = getelementptr inbounds i8, i8* %46, i32 1
  store i8* %incdec.ptr60, i8** %p, align 4
  store i8 %conv59, i8* %46, align 1
  %47 = load i8*, i8** %p, align 4
  store i8 0, i8* %47, align 1
  br label %if.end61

if.end61:                                         ; preds = %if.then56, %if.end53
  br label %while.cond62

while.cond62:                                     ; preds = %for.end, %if.end61
  %48 = load i8*, i8** %out.addr, align 4
  %arrayidx63 = getelementptr inbounds i8, i8* %48, i32 0
  %49 = load i8, i8* %arrayidx63, align 1
  %conv64 = sext i8 %49 to i32
  %cmp65 = icmp eq i32 %conv64, 48
  br i1 %cmp65, label %land.rhs, label %land.end

land.rhs:                                         ; preds = %while.cond62
  %50 = load i8*, i8** %out.addr, align 4
  %arrayidx67 = getelementptr inbounds i8, i8* %50, i32 1
  %51 = load i8, i8* %arrayidx67, align 1
  %conv68 = sext i8 %51 to i32
  %cmp69 = icmp ne i32 %conv68, 46
  br label %land.end

land.end:                                         ; preds = %land.rhs, %while.cond62
  %52 = phi i1 [ false, %while.cond62 ], [ %cmp69, %land.rhs ]
  br i1 %52, label %while.body71, label %while.end80

while.body71:                                     ; preds = %land.end
  store i32 0, i32* %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %while.body71
  %53 = load i8*, i8** %out.addr, align 4
  %54 = load i32, i32* %i, align 4
  %arrayidx72 = getelementptr inbounds i8, i8* %53, i32 %54
  %55 = load i8, i8* %arrayidx72, align 1
  %conv73 = sext i8 %55 to i32
  %cmp74 = icmp ne i32 %conv73, 0
  br i1 %cmp74, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %56 = load i8*, i8** %out.addr, align 4
  %57 = load i32, i32* %i, align 4
  %add76 = add i32 %57, 1
  %arrayidx77 = getelementptr inbounds i8, i8* %56, i32 %add76
  %58 = load i8, i8* %arrayidx77, align 1
  %59 = load i8*, i8** %out.addr, align 4
  %60 = load i32, i32* %i, align 4
  %arrayidx78 = getelementptr inbounds i8, i8* %59, i32 %60
  store i8 %58, i8* %arrayidx78, align 1
  br label %for.inc

for.inc:                                          ; preds = %for.body
  %61 = load i32, i32* %i, align 4
  %inc79 = add i32 %61, 1
  store i32 %inc79, i32* %i, align 4
  br label %for.cond

for.end:                                          ; preds = %for.cond
  br label %while.cond62

while.end80:                                      ; preds = %land.end
  %62 = load i8*, i8** %out.addr, align 4
  %63 = load i8, i8* %62, align 1
  %conv81 = sext i8 %63 to i32
  %cmp82 = icmp eq i32 %conv81, 46
  br i1 %cmp82, label %if.then84, label %if.end86

if.then84:                                        ; preds = %while.end80
  %64 = load i8*, i8** %out.addr, align 4
  %65 = load i8*, i8** %p, align 4
  call void @reverse(i8* %64, i8* %65)
  %66 = load i8*, i8** %p, align 4
  %incdec.ptr85 = getelementptr inbounds i8, i8* %66, i32 1
  store i8* %incdec.ptr85, i8** %p, align 4
  store i8 48, i8* %66, align 1
  %67 = load i8*, i8** %p, align 4
  store i8 0, i8* %67, align 1
  %68 = load i8*, i8** %out.addr, align 4
  %69 = load i8*, i8** %p, align 4
  call void @reverse(i8* %68, i8* %69)
  br label %if.end86

if.end86:                                         ; preds = %if.then84, %while.end80
  %70 = load i8*, i8** %out.addr, align 4
  call void @makeQuaterImaginary(%struct.QuaterImaginary* sret align 4 %agg.result, i8* %70)
  br label %return

return:                                           ; preds = %if.end86, %if.then
  ret void
}

; Function Attrs: nounwind readnone speculatable willreturn
declare double @llvm.ceil.f64(double %0) #4

; Function Attrs: noinline nounwind optnone
define hidden i32 @main() #0 {
entry:
  %retval = alloca i32, align 4
  %buffer = alloca [16 x i8], align 16
  %i = alloca i32, align 4
  %c1 = alloca %struct.Complex, align 8
  %qi = alloca %struct.QuaterImaginary, align 4
  %c2 = alloca %struct.Complex, align 8
  %tmp = alloca %struct.Complex, align 8
  %tmp3 = alloca %struct.QuaterImaginary, align 4
  %tmp5 = alloca %struct.Complex, align 8
  %c114 = alloca %struct.Complex, align 8
  %qi18 = alloca %struct.QuaterImaginary, align 4
  %c220 = alloca %struct.Complex, align 8
  %tmp24 = alloca %struct.Complex, align 8
  %tmp25 = alloca %struct.QuaterImaginary, align 4
  %tmp27 = alloca %struct.Complex, align 8
  store i32 0, i32* %retval, align 4
  store i32 1, i32* %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %0 = load i32, i32* %i, align 4
  %cmp = icmp sle i32 %0, 16
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %rel = getelementptr inbounds %struct.Complex, %struct.Complex* %c1, i32 0, i32 0
  %1 = load i32, i32* %i, align 4
  %conv = sitofp i32 %1 to double
  store double %conv, double* %rel, align 8
  %img = getelementptr inbounds %struct.Complex, %struct.Complex* %c1, i32 0, i32 1
  store double 0.000000e+00, double* %img, align 8
  %arraydecay = getelementptr inbounds [16 x i8], [16 x i8]* %buffer, i32 0, i32 0
  call void @c2qi(%struct.QuaterImaginary* sret align 4 %qi, %struct.Complex* byval(%struct.Complex) align 8 %c1, i8* %arraydecay)
  call void @qi2c(%struct.Complex* sret align 8 %c2, %struct.QuaterImaginary* byval(%struct.QuaterImaginary) align 4 %qi)
  call void @printComplex(%struct.Complex* byval(%struct.Complex) align 8 %c1)
  %call = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.4, i32 0, i32 0))
  call void @printQuaterImaginary(%struct.QuaterImaginary* byval(%struct.QuaterImaginary) align 4 %qi)
  %call1 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.4, i32 0, i32 0))
  call void @printComplex(%struct.Complex* byval(%struct.Complex) align 8 %c2)
  %call2 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([6 x i8], [6 x i8]* @.str.5, i32 0, i32 0))
  call void @negComplex(%struct.Complex* sret align 8 %tmp, %struct.Complex* byval(%struct.Complex) align 8 %c1)
  %2 = bitcast %struct.Complex* %c1 to i8*
  %3 = bitcast %struct.Complex* %tmp to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 8 %2, i8* align 8 %3, i32 16, i1 false)
  %arraydecay4 = getelementptr inbounds [16 x i8], [16 x i8]* %buffer, i32 0, i32 0
  call void @c2qi(%struct.QuaterImaginary* sret align 4 %tmp3, %struct.Complex* byval(%struct.Complex) align 8 %c1, i8* %arraydecay4)
  %4 = bitcast %struct.QuaterImaginary* %qi to i8*
  %5 = bitcast %struct.QuaterImaginary* %tmp3 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 4 %4, i8* align 4 %5, i32 8, i1 false)
  call void @qi2c(%struct.Complex* sret align 8 %tmp5, %struct.QuaterImaginary* byval(%struct.QuaterImaginary) align 4 %qi)
  %6 = bitcast %struct.Complex* %c2 to i8*
  %7 = bitcast %struct.Complex* %tmp5 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 8 %6, i8* align 8 %7, i32 16, i1 false)
  call void @printComplex(%struct.Complex* byval(%struct.Complex) align 8 %c1)
  %call6 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.4, i32 0, i32 0))
  call void @printQuaterImaginary(%struct.QuaterImaginary* byval(%struct.QuaterImaginary) align 4 %qi)
  %call7 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.4, i32 0, i32 0))
  call void @printComplex(%struct.Complex* byval(%struct.Complex) align 8 %c2)
  %call8 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([2 x i8], [2 x i8]* @.str.6, i32 0, i32 0))
  br label %for.inc

for.inc:                                          ; preds = %for.body
  %8 = load i32, i32* %i, align 4
  %inc = add nsw i32 %8, 1
  store i32 %inc, i32* %i, align 4
  br label %for.cond

for.end:                                          ; preds = %for.cond
  %call9 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([2 x i8], [2 x i8]* @.str.6, i32 0, i32 0))
  store i32 1, i32* %i, align 4
  br label %for.cond10

for.cond10:                                       ; preds = %for.inc31, %for.end
  %9 = load i32, i32* %i, align 4
  %cmp11 = icmp sle i32 %9, 16
  br i1 %cmp11, label %for.body13, label %for.end33

for.body13:                                       ; preds = %for.cond10
  %rel15 = getelementptr inbounds %struct.Complex, %struct.Complex* %c114, i32 0, i32 0
  store double 0.000000e+00, double* %rel15, align 8
  %img16 = getelementptr inbounds %struct.Complex, %struct.Complex* %c114, i32 0, i32 1
  %10 = load i32, i32* %i, align 4
  %conv17 = sitofp i32 %10 to double
  store double %conv17, double* %img16, align 8
  %arraydecay19 = getelementptr inbounds [16 x i8], [16 x i8]* %buffer, i32 0, i32 0
  call void @c2qi(%struct.QuaterImaginary* sret align 4 %qi18, %struct.Complex* byval(%struct.Complex) align 8 %c114, i8* %arraydecay19)
  call void @qi2c(%struct.Complex* sret align 8 %c220, %struct.QuaterImaginary* byval(%struct.QuaterImaginary) align 4 %qi18)
  call void @printComplex(%struct.Complex* byval(%struct.Complex) align 8 %c114)
  %call21 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.4, i32 0, i32 0))
  call void @printQuaterImaginary(%struct.QuaterImaginary* byval(%struct.QuaterImaginary) align 4 %qi18)
  %call22 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.4, i32 0, i32 0))
  call void @printComplex(%struct.Complex* byval(%struct.Complex) align 8 %c220)
  %call23 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([6 x i8], [6 x i8]* @.str.5, i32 0, i32 0))
  call void @negComplex(%struct.Complex* sret align 8 %tmp24, %struct.Complex* byval(%struct.Complex) align 8 %c114)
  %11 = bitcast %struct.Complex* %c114 to i8*
  %12 = bitcast %struct.Complex* %tmp24 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 8 %11, i8* align 8 %12, i32 16, i1 false)
  %arraydecay26 = getelementptr inbounds [16 x i8], [16 x i8]* %buffer, i32 0, i32 0
  call void @c2qi(%struct.QuaterImaginary* sret align 4 %tmp25, %struct.Complex* byval(%struct.Complex) align 8 %c114, i8* %arraydecay26)
  %13 = bitcast %struct.QuaterImaginary* %qi18 to i8*
  %14 = bitcast %struct.QuaterImaginary* %tmp25 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 4 %13, i8* align 4 %14, i32 8, i1 false)
  call void @qi2c(%struct.Complex* sret align 8 %tmp27, %struct.QuaterImaginary* byval(%struct.QuaterImaginary) align 4 %qi18)
  %15 = bitcast %struct.Complex* %c220 to i8*
  %16 = bitcast %struct.Complex* %tmp27 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 8 %15, i8* align 8 %16, i32 16, i1 false)
  call void @printComplex(%struct.Complex* byval(%struct.Complex) align 8 %c114)
  %call28 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.4, i32 0, i32 0))
  call void @printQuaterImaginary(%struct.QuaterImaginary* byval(%struct.QuaterImaginary) align 4 %qi18)
  %call29 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.4, i32 0, i32 0))
  call void @printComplex(%struct.Complex* byval(%struct.Complex) align 8 %c220)
  %call30 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([2 x i8], [2 x i8]* @.str.6, i32 0, i32 0))
  br label %for.inc31

for.inc31:                                        ; preds = %for.body13
  %17 = load i32, i32* %i, align 4
  %inc32 = add nsw i32 %17, 1
  store i32 %inc32, i32* %i, align 4
  br label %for.cond10

for.end33:                                        ; preds = %for.cond10
  ret i32 0
}

attributes #0 = { noinline nounwind optnone "correctly-rounded-divide-sqrt-fp-math"="false" "disable-tail-calls"="false" "frame-pointer"="none" "less-precise-fpmad"="false" "min-legal-vector-width"="0" "no-infs-fp-math"="false" "no-jump-tables"="false" "no-nans-fp-math"="false" "no-signed-zeros-fp-math"="false" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="generic" "unsafe-fp-math"="false" "use-soft-float"="false" }
attributes #1 = { "correctly-rounded-divide-sqrt-fp-math"="false" "disable-tail-calls"="false" "frame-pointer"="none" "less-precise-fpmad"="false" "no-infs-fp-math"="false" "no-nans-fp-math"="false" "no-signed-zeros-fp-math"="false" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="generic" "unsafe-fp-math"="false" "use-soft-float"="false" }
attributes #2 = { nounwind readonly "correctly-rounded-divide-sqrt-fp-math"="false" "disable-tail-calls"="false" "frame-pointer"="none" "less-precise-fpmad"="false" "no-infs-fp-math"="false" "no-nans-fp-math"="false" "no-signed-zeros-fp-math"="false" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="generic" "unsafe-fp-math"="false" "use-soft-float"="false" }
attributes #3 = { argmemonly nounwind willreturn }
attributes #4 = { nounwind readnone speculatable willreturn }
attributes #5 = { nounwind readonly }

!llvm.module.flags = !{!0}
!llvm.ident = !{!1}

!0 = !{i32 1, !"wchar_size", i32 4}
!1 = !{!"clang version 11.0.0 (https://github.com/Jacarte/llvm-project.git 0f6dea67136cc1e0b3d200eb2bb165628970c44b)"}

; extracted candidates
#########################################################
; exiting Souper's runOnFunction() for negComplex()

; entering Souper's runOnFunction() for divComplex()

; ModuleID = './Imaginary_base_numbers.c.bc'
source_filename = "./Imaginary_base_numbers.c"
target datalayout = "e-m:e-p:32:32-i64:64-n32:64-S128"
target triple = "wasm32-unknown-wasi"

%struct.Complex = type { double, double }
%struct.QuaterImaginary = type { i8*, i32 }

@.str = private unnamed_addr constant [17 x i8] c"(%3.0f + %3.0fi)\00", align 1
@TWO_I = hidden constant %struct.Complex { double 0.000000e+00, double 2.000000e+00 }, align 8
@INV_TWO_I = hidden constant %struct.Complex { double 0.000000e+00, double -5.000000e-01 }, align 8
@.str.1 = private unnamed_addr constant [4 x i8] c"%8s\00", align 1
@.str.2 = private unnamed_addr constant [9 x i8] c" ERROR  \00", align 1
@.str.3 = private unnamed_addr constant [2 x i8] c"0\00", align 1
@.str.4 = private unnamed_addr constant [5 x i8] c" -> \00", align 1
@.str.5 = private unnamed_addr constant [6 x i8] c"     \00", align 1
@.str.6 = private unnamed_addr constant [2 x i8] c"\0A\00", align 1
@llvm.used = appending global [1 x i8*] [i8* bitcast (i32 ()* @__main_void to i8*)], section "llvm.metadata"

@__main_void = alias i32 (), i32 ()* @main

; Function Attrs: noinline nounwind optnone
define hidden i32 @find(i8* %s, i8 signext %c) #0 {
entry:
  %retval = alloca i32, align 4
  %s.addr = alloca i8*, align 4
  %c.addr = alloca i8, align 1
  %i = alloca i8*, align 4
  store i8* %s, i8** %s.addr, align 4
  store i8 %c, i8* %c.addr, align 1
  %0 = load i8*, i8** %s.addr, align 4
  store i8* %0, i8** %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %1 = load i8*, i8** %i, align 4
  %2 = load i8, i8* %1, align 1
  %conv = sext i8 %2 to i32
  %cmp = icmp ne i32 %conv, 0
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %3 = load i8*, i8** %i, align 4
  %4 = load i8, i8* %3, align 1
  %conv2 = sext i8 %4 to i32
  %5 = load i8, i8* %c.addr, align 1
  %conv3 = sext i8 %5 to i32
  %cmp4 = icmp eq i32 %conv2, %conv3
  br i1 %cmp4, label %if.then, label %if.end

if.then:                                          ; preds = %for.body
  %6 = load i8*, i8** %i, align 4
  %7 = load i8*, i8** %s.addr, align 4
  %sub.ptr.lhs.cast = ptrtoint i8* %6 to i32
  %sub.ptr.rhs.cast = ptrtoint i8* %7 to i32
  %sub.ptr.sub = sub i32 %sub.ptr.lhs.cast, %sub.ptr.rhs.cast
  store i32 %sub.ptr.sub, i32* %retval, align 4
  br label %return

if.end:                                           ; preds = %for.body
  br label %for.inc

for.inc:                                          ; preds = %if.end
  %8 = load i8*, i8** %i, align 4
  %incdec.ptr = getelementptr inbounds i8, i8* %8, i32 1
  store i8* %incdec.ptr, i8** %i, align 4
  br label %for.cond

for.end:                                          ; preds = %for.cond
  store i32 -1, i32* %retval, align 4
  br label %return

return:                                           ; preds = %for.end, %if.then
  %9 = load i32, i32* %retval, align 4
  ret i32 %9
}

; Function Attrs: noinline nounwind optnone
define hidden void @reverse(i8* %b, i8* %e) #0 {
entry:
  %b.addr = alloca i8*, align 4
  %e.addr = alloca i8*, align 4
  %t = alloca i8, align 1
  store i8* %b, i8** %b.addr, align 4
  store i8* %e, i8** %e.addr, align 4
  %0 = load i8*, i8** %e.addr, align 4
  %incdec.ptr = getelementptr inbounds i8, i8* %0, i32 -1
  store i8* %incdec.ptr, i8** %e.addr, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %1 = load i8*, i8** %b.addr, align 4
  %2 = load i8*, i8** %e.addr, align 4
  %cmp = icmp ult i8* %1, %2
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %3 = load i8*, i8** %b.addr, align 4
  %4 = load i8, i8* %3, align 1
  store i8 %4, i8* %t, align 1
  %5 = load i8*, i8** %e.addr, align 4
  %6 = load i8, i8* %5, align 1
  %7 = load i8*, i8** %b.addr, align 4
  store i8 %6, i8* %7, align 1
  %8 = load i8, i8* %t, align 1
  %9 = load i8*, i8** %e.addr, align 4
  store i8 %8, i8* %9, align 1
  br label %for.inc

for.inc:                                          ; preds = %for.body
  %10 = load i8*, i8** %b.addr, align 4
  %incdec.ptr1 = getelementptr inbounds i8, i8* %10, i32 1
  store i8* %incdec.ptr1, i8** %b.addr, align 4
  %11 = load i8*, i8** %e.addr, align 4
  %incdec.ptr2 = getelementptr inbounds i8, i8* %11, i32 -1
  store i8* %incdec.ptr2, i8** %e.addr, align 4
  br label %for.cond

for.end:                                          ; preds = %for.cond
  ret void
}

; Function Attrs: noinline nounwind optnone
define hidden void @printComplex(%struct.Complex* byval(%struct.Complex) align 8 %c) #0 {
entry:
  %rel = getelementptr inbounds %struct.Complex, %struct.Complex* %c, i32 0, i32 0
  %0 = load double, double* %rel, align 8
  %img = getelementptr inbounds %struct.Complex, %struct.Complex* %c, i32 0, i32 1
  %1 = load double, double* %img, align 8
  %call = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([17 x i8], [17 x i8]* @.str, i32 0, i32 0), double %0, double %1)
  ret void
}

declare i32 @printf(i8* %0, ...) #1

; Function Attrs: noinline nounwind optnone
define hidden void @makeComplex(%struct.Complex* noalias sret align 8 %agg.result, double %rel, double %img) #0 {
entry:
  %rel.addr = alloca double, align 8
  %img.addr = alloca double, align 8
  store double %rel, double* %rel.addr, align 8
  store double %img, double* %img.addr, align 8
  %rel1 = getelementptr inbounds %struct.Complex, %struct.Complex* %agg.result, i32 0, i32 0
  %0 = load double, double* %rel.addr, align 8
  store double %0, double* %rel1, align 8
  %img2 = getelementptr inbounds %struct.Complex, %struct.Complex* %agg.result, i32 0, i32 1
  %1 = load double, double* %img.addr, align 8
  store double %1, double* %img2, align 8
  ret void
}

; Function Attrs: noinline nounwind optnone
define hidden void @addComplex(%struct.Complex* noalias sret align 8 %agg.result, %struct.Complex* byval(%struct.Complex) align 8 %a, %struct.Complex* byval(%struct.Complex) align 8 %b) #0 {
entry:
  %rel = getelementptr inbounds %struct.Complex, %struct.Complex* %agg.result, i32 0, i32 0
  %rel1 = getelementptr inbounds %struct.Complex, %struct.Complex* %a, i32 0, i32 0
  %0 = load double, double* %rel1, align 8
  %rel2 = getelementptr inbounds %struct.Complex, %struct.Complex* %b, i32 0, i32 0
  %1 = load double, double* %rel2, align 8
  %add = fadd double %0, %1
  store double %add, double* %rel, align 8
  %img = getelementptr inbounds %struct.Complex, %struct.Complex* %agg.result, i32 0, i32 1
  %img3 = getelementptr inbounds %struct.Complex, %struct.Complex* %a, i32 0, i32 1
  %2 = load double, double* %img3, align 8
  %img4 = getelementptr inbounds %struct.Complex, %struct.Complex* %b, i32 0, i32 1
  %3 = load double, double* %img4, align 8
  %add5 = fadd double %2, %3
  store double %add5, double* %img, align 8
  ret void
}

; Function Attrs: noinline nounwind optnone
define hidden void @mulComplex(%struct.Complex* noalias sret align 8 %agg.result, %struct.Complex* byval(%struct.Complex) align 8 %a, %struct.Complex* byval(%struct.Complex) align 8 %b) #0 {
entry:
  %rel = getelementptr inbounds %struct.Complex, %struct.Complex* %agg.result, i32 0, i32 0
  %rel1 = getelementptr inbounds %struct.Complex, %struct.Complex* %a, i32 0, i32 0
  %0 = load double, double* %rel1, align 8
  %rel2 = getelementptr inbounds %struct.Complex, %struct.Complex* %b, i32 0, i32 0
  %1 = load double, double* %rel2, align 8
  %mul = fmul double %0, %1
  %img = getelementptr inbounds %struct.Complex, %struct.Complex* %a, i32 0, i32 1
  %2 = load double, double* %img, align 8
  %img3 = getelementptr inbounds %struct.Complex, %struct.Complex* %b, i32 0, i32 1
  %3 = load double, double* %img3, align 8
  %mul4 = fmul double %2, %3
  %sub = fsub double %mul, %mul4
  store double %sub, double* %rel, align 8
  %img5 = getelementptr inbounds %struct.Complex, %struct.Complex* %agg.result, i32 0, i32 1
  %rel6 = getelementptr inbounds %struct.Complex, %struct.Complex* %a, i32 0, i32 0
  %4 = load double, double* %rel6, align 8
  %img7 = getelementptr inbounds %struct.Complex, %struct.Complex* %b, i32 0, i32 1
  %5 = load double, double* %img7, align 8
  %mul8 = fmul double %4, %5
  %img9 = getelementptr inbounds %struct.Complex, %struct.Complex* %a, i32 0, i32 1
  %6 = load double, double* %img9, align 8
  %rel10 = getelementptr inbounds %struct.Complex, %struct.Complex* %b, i32 0, i32 0
  %7 = load double, double* %rel10, align 8
  %mul11 = fmul double %6, %7
  %sub12 = fsub double %mul8, %mul11
  store double %sub12, double* %img5, align 8
  ret void
}

; Function Attrs: noinline nounwind optnone
define hidden void @mulComplexD(%struct.Complex* noalias sret align 8 %agg.result, %struct.Complex* byval(%struct.Complex) align 8 %a, double %b) #0 {
entry:
  %b.addr = alloca double, align 8
  store double %b, double* %b.addr, align 8
  %rel = getelementptr inbounds %struct.Complex, %struct.Complex* %agg.result, i32 0, i32 0
  %rel1 = getelementptr inbounds %struct.Complex, %struct.Complex* %a, i32 0, i32 0
  %0 = load double, double* %rel1, align 8
  %1 = load double, double* %b.addr, align 8
  %mul = fmul double %0, %1
  store double %mul, double* %rel, align 8
  %img = getelementptr inbounds %struct.Complex, %struct.Complex* %agg.result, i32 0, i32 1
  %img2 = getelementptr inbounds %struct.Complex, %struct.Complex* %a, i32 0, i32 1
  %2 = load double, double* %img2, align 8
  %3 = load double, double* %b.addr, align 8
  %mul3 = fmul double %2, %3
  store double %mul3, double* %img, align 8
  ret void
}

; Function Attrs: noinline nounwind optnone
define hidden void @negComplex(%struct.Complex* noalias sret align 8 %agg.result, %struct.Complex* byval(%struct.Complex) align 8 %a) #0 {
entry:
  call void @mulComplexD(%struct.Complex* sret align 8 %agg.result, %struct.Complex* byval(%struct.Complex) align 8 %a, double -1.000000e+00)
  ret void
}

; Function Attrs: noinline nounwind optnone
define hidden void @divComplex(%struct.Complex* noalias sret align 8 %agg.result, %struct.Complex* byval(%struct.Complex) align 8 %a, %struct.Complex* byval(%struct.Complex) align 8 %b) #0 {
entry:
  %re = alloca double, align 8
  %im = alloca double, align 8
  %d = alloca double, align 8
  %rel = getelementptr inbounds %struct.Complex, %struct.Complex* %a, i32 0, i32 0
  %0 = load double, double* %rel, align 8
  %rel1 = getelementptr inbounds %struct.Complex, %struct.Complex* %b, i32 0, i32 0
  %1 = load double, double* %rel1, align 8
  %mul = fmul double %0, %1
  %img = getelementptr inbounds %struct.Complex, %struct.Complex* %a, i32 0, i32 1
  %2 = load double, double* %img, align 8
  %img2 = getelementptr inbounds %struct.Complex, %struct.Complex* %b, i32 0, i32 1
  %3 = load double, double* %img2, align 8
  %mul3 = fmul double %2, %3
  %add = fadd double %mul, %mul3
  store double %add, double* %re, align 8
  %img4 = getelementptr inbounds %struct.Complex, %struct.Complex* %a, i32 0, i32 1
  %4 = load double, double* %img4, align 8
  %rel5 = getelementptr inbounds %struct.Complex, %struct.Complex* %b, i32 0, i32 0
  %5 = load double, double* %rel5, align 8
  %mul6 = fmul double %4, %5
  %rel7 = getelementptr inbounds %struct.Complex, %struct.Complex* %a, i32 0, i32 0
  %6 = load double, double* %rel7, align 8
  %img8 = getelementptr inbounds %struct.Complex, %struct.Complex* %b, i32 0, i32 1
  %7 = load double, double* %img8, align 8
  %mul9 = fmul double %6, %7
  %sub = fsub double %mul6, %mul9
  store double %sub, double* %im, align 8
  %rel10 = getelementptr inbounds %struct.Complex, %struct.Complex* %b, i32 0, i32 0
  %8 = load double, double* %rel10, align 8
  %rel11 = getelementptr inbounds %struct.Complex, %struct.Complex* %b, i32 0, i32 0
  %9 = load double, double* %rel11, align 8
  %mul12 = fmul double %8, %9
  %img13 = getelementptr inbounds %struct.Complex, %struct.Complex* %b, i32 0, i32 1
  %10 = load double, double* %img13, align 8
  %img14 = getelementptr inbounds %struct.Complex, %struct.Complex* %b, i32 0, i32 1
  %11 = load double, double* %img14, align 8
  %mul15 = fmul double %10, %11
  %add16 = fadd double %mul12, %mul15
  store double %add16, double* %d, align 8
  %rel17 = getelementptr inbounds %struct.Complex, %struct.Complex* %agg.result, i32 0, i32 0
  %12 = load double, double* %re, align 8
  %13 = load double, double* %d, align 8
  %div = fdiv double %12, %13
  store double %div, double* %rel17, align 8
  %img18 = getelementptr inbounds %struct.Complex, %struct.Complex* %agg.result, i32 0, i32 1
  %14 = load double, double* %im, align 8
  %15 = load double, double* %d, align 8
  %div19 = fdiv double %14, %15
  store double %div19, double* %img18, align 8
  ret void
}

; Function Attrs: noinline nounwind optnone
define hidden void @inv(%struct.Complex* noalias sret align 8 %agg.result, %struct.Complex* byval(%struct.Complex) align 8 %c) #0 {
entry:
  %d = alloca double, align 8
  %rel = getelementptr inbounds %struct.Complex, %struct.Complex* %c, i32 0, i32 0
  %0 = load double, double* %rel, align 8
  %rel1 = getelementptr inbounds %struct.Complex, %struct.Complex* %c, i32 0, i32 0
  %1 = load double, double* %rel1, align 8
  %mul = fmul double %0, %1
  %img = getelementptr inbounds %struct.Complex, %struct.Complex* %c, i32 0, i32 1
  %2 = load double, double* %img, align 8
  %img2 = getelementptr inbounds %struct.Complex, %struct.Complex* %c, i32 0, i32 1
  %3 = load double, double* %img2, align 8
  %mul3 = fmul double %2, %3
  %add = fadd double %mul, %mul3
  store double %add, double* %d, align 8
  %rel4 = getelementptr inbounds %struct.Complex, %struct.Complex* %agg.result, i32 0, i32 0
  %rel5 = getelementptr inbounds %struct.Complex, %struct.Complex* %c, i32 0, i32 0
  %4 = load double, double* %rel5, align 8
  %5 = load double, double* %d, align 8
  %div = fdiv double %4, %5
  store double %div, double* %rel4, align 8
  %img6 = getelementptr inbounds %struct.Complex, %struct.Complex* %agg.result, i32 0, i32 1
  %img7 = getelementptr inbounds %struct.Complex, %struct.Complex* %c, i32 0, i32 1
  %6 = load double, double* %img7, align 8
  %fneg = fneg double %6
  %7 = load double, double* %d, align 8
  %div8 = fdiv double %fneg, %7
  store double %div8, double* %img6, align 8
  ret void
}

; Function Attrs: noinline nounwind optnone
define hidden void @makeQuaterImaginary(%struct.QuaterImaginary* noalias sret align 4 %agg.result, i8* %s) #0 {
entry:
  %s.addr = alloca i8*, align 4
  %i = alloca i32, align 4
  %valid1 = alloca i32, align 4
  %cnt = alloca i32, align 4
  store i8* %s, i8** %s.addr, align 4
  %b2i = getelementptr inbounds %struct.QuaterImaginary, %struct.QuaterImaginary* %agg.result, i32 0, i32 0
  %0 = load i8*, i8** %s.addr, align 4
  store i8* %0, i8** %b2i, align 4
  %valid = getelementptr inbounds %struct.QuaterImaginary, %struct.QuaterImaginary* %agg.result, i32 0, i32 1
  store i32 0, i32* %valid, align 4
  store i32 1, i32* %valid1, align 4
  store i32 0, i32* %cnt, align 4
  %1 = load i8*, i8** %s.addr, align 4
  %2 = load i8, i8* %1, align 1
  %conv = sext i8 %2 to i32
  %cmp = icmp ne i32 %conv, 0
  br i1 %cmp, label %if.then, label %if.end26

if.then:                                          ; preds = %entry
  store i32 0, i32* %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.then
  %3 = load i8*, i8** %s.addr, align 4
  %4 = load i32, i32* %i, align 4
  %arrayidx = getelementptr inbounds i8, i8* %3, i32 %4
  %5 = load i8, i8* %arrayidx, align 1
  %conv3 = sext i8 %5 to i32
  %cmp4 = icmp ne i32 %conv3, 0
  br i1 %cmp4, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %6 = load i8*, i8** %s.addr, align 4
  %7 = load i32, i32* %i, align 4
  %arrayidx6 = getelementptr inbounds i8, i8* %6, i32 %7
  %8 = load i8, i8* %arrayidx6, align 1
  %conv7 = sext i8 %8 to i32
  %cmp8 = icmp slt i32 %conv7, 48
  br i1 %cmp8, label %if.then14, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %for.body
  %9 = load i8*, i8** %s.addr, align 4
  %10 = load i32, i32* %i, align 4
  %arrayidx10 = getelementptr inbounds i8, i8* %9, i32 %10
  %11 = load i8, i8* %arrayidx10, align 1
  %conv11 = sext i8 %11 to i32
  %cmp12 = icmp slt i32 51, %conv11
  br i1 %cmp12, label %if.then14, label %if.end20

if.then14:                                        ; preds = %lor.lhs.false, %for.body
  %12 = load i8*, i8** %s.addr, align 4
  %13 = load i32, i32* %i, align 4
  %arrayidx15 = getelementptr inbounds i8, i8* %12, i32 %13
  %14 = load i8, i8* %arrayidx15, align 1
  %conv16 = sext i8 %14 to i32
  %cmp17 = icmp eq i32 %conv16, 46
  br i1 %cmp17, label %if.then19, label %if.else

if.then19:                                        ; preds = %if.then14
  %15 = load i32, i32* %cnt, align 4
  %inc = add i32 %15, 1
  store i32 %inc, i32* %cnt, align 4
  br label %if.end

if.else:                                          ; preds = %if.then14
  store i32 0, i32* %valid1, align 4
  br label %for.end

if.end:                                           ; preds = %if.then19
  br label %if.end20

if.end20:                                         ; preds = %if.end, %lor.lhs.false
  br label %for.inc

for.inc:                                          ; preds = %if.end20
  %16 = load i32, i32* %i, align 4
  %inc21 = add i32 %16, 1
  store i32 %inc21, i32* %i, align 4
  br label %for.cond

for.end:                                          ; preds = %if.else, %for.cond
  %17 = load i32, i32* %valid1, align 4
  %tobool = icmp ne i32 %17, 0
  br i1 %tobool, label %land.lhs.true, label %if.end25

land.lhs.true:                                    ; preds = %for.end
  %18 = load i32, i32* %cnt, align 4
  %cmp22 = icmp ugt i32 %18, 1
  br i1 %cmp22, label %if.then24, label %if.end25

if.then24:                                        ; preds = %land.lhs.true
  store i32 0, i32* %valid1, align 4
  br label %if.end25

if.end25:                                         ; preds = %if.then24, %land.lhs.true, %for.end
  br label %if.end26

if.end26:                                         ; preds = %if.end25, %entry
  %19 = load i32, i32* %valid1, align 4
  %valid27 = getelementptr inbounds %struct.QuaterImaginary, %struct.QuaterImaginary* %agg.result, i32 0, i32 1
  store i32 %19, i32* %valid27, align 4
  ret void
}

; Function Attrs: noinline nounwind optnone
define hidden void @printQuaterImaginary(%struct.QuaterImaginary* byval(%struct.QuaterImaginary) align 4 %qi) #0 {
entry:
  %valid = getelementptr inbounds %struct.QuaterImaginary, %struct.QuaterImaginary* %qi, i32 0, i32 1
  %0 = load i32, i32* %valid, align 4
  %tobool = icmp ne i32 %0, 0
  br i1 %tobool, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  %b2i = getelementptr inbounds %struct.QuaterImaginary, %struct.QuaterImaginary* %qi, i32 0, i32 0
  %1 = load i8*, i8** %b2i, align 4
  %call = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([4 x i8], [4 x i8]* @.str.1, i32 0, i32 0), i8* %1)
  br label %if.end

if.else:                                          ; preds = %entry
  %call1 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([9 x i8], [9 x i8]* @.str.2, i32 0, i32 0))
  br label %if.end

if.end:                                           ; preds = %if.else, %if.then
  ret void
}

; Function Attrs: noinline nounwind optnone
define hidden void @qi2c(%struct.Complex* noalias sret align 8 %agg.result, %struct.QuaterImaginary* byval(%struct.QuaterImaginary) align 4 %qi) #0 {
entry:
  %len = alloca i32, align 4
  %pointPos = alloca i32, align 4
  %posLen = alloca i32, align 4
  %prod = alloca %struct.Complex, align 8
  %j = alloca i32, align 4
  %k = alloca double, align 8
  %tmp = alloca %struct.Complex, align 8
  %agg.tmp = alloca %struct.Complex, align 8
  %tmp10 = alloca %struct.Complex, align 8
  %k18 = alloca double, align 8
  %tmp27 = alloca %struct.Complex, align 8
  %agg.tmp28 = alloca %struct.Complex, align 8
  %tmp30 = alloca %struct.Complex, align 8
  %b2i = getelementptr inbounds %struct.QuaterImaginary, %struct.QuaterImaginary* %qi, i32 0, i32 0
  %0 = load i8*, i8** %b2i, align 4
  %call = call i32 @strlen(i8* %0) #5
  store i32 %call, i32* %len, align 4
  %b2i1 = getelementptr inbounds %struct.QuaterImaginary, %struct.QuaterImaginary* %qi, i32 0, i32 0
  %1 = load i8*, i8** %b2i1, align 4
  %call2 = call i32 @find(i8* %1, i8 signext 46)
  store i32 %call2, i32* %pointPos, align 4
  %2 = load i32, i32* %pointPos, align 4
  %cmp = icmp sgt i32 %2, 0
  br i1 %cmp, label %cond.true, label %cond.false

cond.true:                                        ; preds = %entry
  %3 = load i32, i32* %pointPos, align 4
  br label %cond.end

cond.false:                                       ; preds = %entry
  %4 = load i32, i32* %len, align 4
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi i32 [ %3, %cond.true ], [ %4, %cond.false ]
  store i32 %cond, i32* %posLen, align 4
  call void @makeComplex(%struct.Complex* sret align 8 %agg.result, double 0.000000e+00, double 0.000000e+00)
  call void @makeComplex(%struct.Complex* sret align 8 %prod, double 1.000000e+00, double 0.000000e+00)
  store i32 0, i32* %j, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %cond.end
  %5 = load i32, i32* %j, align 4
  %6 = load i32, i32* %posLen, align 4
  %cmp3 = icmp ult i32 %5, %6
  br i1 %cmp3, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %b2i4 = getelementptr inbounds %struct.QuaterImaginary, %struct.QuaterImaginary* %qi, i32 0, i32 0
  %7 = load i8*, i8** %b2i4, align 4
  %8 = load i32, i32* %posLen, align 4
  %sub = sub i32 %8, 1
  %9 = load i32, i32* %j, align 4
  %sub5 = sub i32 %sub, %9
  %arrayidx = getelementptr inbounds i8, i8* %7, i32 %sub5
  %10 = load i8, i8* %arrayidx, align 1
  %conv = sext i8 %10 to i32
  %sub6 = sub nsw i32 %conv, 48
  %conv7 = sitofp i32 %sub6 to double
  store double %conv7, double* %k, align 8
  %11 = load double, double* %k, align 8
  %cmp8 = fcmp ogt double %11, 0.000000e+00
  br i1 %cmp8, label %if.then, label %if.end

if.then:                                          ; preds = %for.body
  %12 = load double, double* %k, align 8
  call void @mulComplexD(%struct.Complex* sret align 8 %agg.tmp, %struct.Complex* byval(%struct.Complex) align 8 %prod, double %12)
  call void @addComplex(%struct.Complex* sret align 8 %tmp, %struct.Complex* byval(%struct.Complex) align 8 %agg.result, %struct.Complex* byval(%struct.Complex) align 8 %agg.tmp)
  %13 = bitcast %struct.Complex* %agg.result to i8*
  %14 = bitcast %struct.Complex* %tmp to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 8 %13, i8* align 8 %14, i32 16, i1 false)
  br label %if.end

if.end:                                           ; preds = %if.then, %for.body
  call void @mulComplex(%struct.Complex* sret align 8 %tmp10, %struct.Complex* byval(%struct.Complex) align 8 %prod, %struct.Complex* byval(%struct.Complex) align 8 @TWO_I)
  %15 = bitcast %struct.Complex* %prod to i8*
  %16 = bitcast %struct.Complex* %tmp10 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 8 %15, i8* align 8 %16, i32 16, i1 false)
  br label %for.inc

for.inc:                                          ; preds = %if.end
  %17 = load i32, i32* %j, align 4
  %inc = add i32 %17, 1
  store i32 %inc, i32* %j, align 4
  br label %for.cond

for.end:                                          ; preds = %for.cond
  %18 = load i32, i32* %pointPos, align 4
  %cmp11 = icmp ne i32 %18, -1
  br i1 %cmp11, label %if.then13, label %if.end34

if.then13:                                        ; preds = %for.end
  %19 = bitcast %struct.Complex* %prod to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 8 %19, i8* align 8 bitcast (%struct.Complex* @INV_TWO_I to i8*), i32 16, i1 false)
  %20 = load i32, i32* %posLen, align 4
  %add = add i32 %20, 1
  store i32 %add, i32* %j, align 4
  br label %for.cond14

for.cond14:                                       ; preds = %for.inc31, %if.then13
  %21 = load i32, i32* %j, align 4
  %22 = load i32, i32* %len, align 4
  %cmp15 = icmp ult i32 %21, %22
  br i1 %cmp15, label %for.body17, label %for.end33

for.body17:                                       ; preds = %for.cond14
  %b2i19 = getelementptr inbounds %struct.QuaterImaginary, %struct.QuaterImaginary* %qi, i32 0, i32 0
  %23 = load i8*, i8** %b2i19, align 4
  %24 = load i32, i32* %j, align 4
  %arrayidx20 = getelementptr inbounds i8, i8* %23, i32 %24
  %25 = load i8, i8* %arrayidx20, align 1
  %conv21 = sext i8 %25 to i32
  %sub22 = sub nsw i32 %conv21, 48
  %conv23 = sitofp i32 %sub22 to double
  store double %conv23, double* %k18, align 8
  %26 = load double, double* %k18, align 8
  %cmp24 = fcmp ogt double %26, 0.000000e+00
  br i1 %cmp24, label %if.then26, label %if.end29

if.then26:                                        ; preds = %for.body17
  %27 = load double, double* %k18, align 8
  call void @mulComplexD(%struct.Complex* sret align 8 %agg.tmp28, %struct.Complex* byval(%struct.Complex) align 8 %prod, double %27)
  call void @addComplex(%struct.Complex* sret align 8 %tmp27, %struct.Complex* byval(%struct.Complex) align 8 %agg.result, %struct.Complex* byval(%struct.Complex) align 8 %agg.tmp28)
  %28 = bitcast %struct.Complex* %agg.result to i8*
  %29 = bitcast %struct.Complex* %tmp27 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 8 %28, i8* align 8 %29, i32 16, i1 false)
  br label %if.end29

if.end29:                                         ; preds = %if.then26, %for.body17
  call void @mulComplex(%struct.Complex* sret align 8 %tmp30, %struct.Complex* byval(%struct.Complex) align 8 %prod, %struct.Complex* byval(%struct.Complex) align 8 @INV_TWO_I)
  %30 = bitcast %struct.Complex* %prod to i8*
  %31 = bitcast %struct.Complex* %tmp30 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 8 %30, i8* align 8 %31, i32 16, i1 false)
  br label %for.inc31

for.inc31:                                        ; preds = %if.end29
  %32 = load i32, i32* %j, align 4
  %inc32 = add i32 %32, 1
  store i32 %inc32, i32* %j, align 4
  br label %for.cond14

for.end33:                                        ; preds = %for.cond14
  br label %if.end34

if.end34:                                         ; preds = %for.end33, %for.end
  ret void
}

; Function Attrs: nounwind readonly
declare i32 @strlen(i8* %0) #2

; Function Attrs: argmemonly nounwind willreturn
declare void @llvm.memcpy.p0i8.p0i8.i32(i8* noalias nocapture writeonly %0, i8* noalias nocapture readonly %1, i32 %2, i1 immarg %3) #3

; Function Attrs: noinline nounwind optnone
define hidden void @c2qi(%struct.QuaterImaginary* noalias sret align 4 %agg.result, %struct.Complex* byval(%struct.Complex) align 8 %c, i8* %out) #0 {
entry:
  %out.addr = alloca i8*, align 4
  %p = alloca i8*, align 4
  %re = alloca i32, align 4
  %im = alloca i32, align 4
  %fi = alloca i32, align 4
  %rem = alloca i32, align 4
  %index = alloca i32, align 4
  %fc = alloca %struct.Complex, align 8
  %.compoundliteral = alloca %struct.Complex, align 8
  %.compoundliteral21 = alloca %struct.Complex, align 8
  %f = alloca double, align 8
  %rem31 = alloca i32, align 4
  %i = alloca i32, align 4
  store i8* %out, i8** %out.addr, align 4
  %0 = load i8*, i8** %out.addr, align 4
  store i8* %0, i8** %p, align 4
  %1 = load i8*, i8** %p, align 4
  store i8 0, i8* %1, align 1
  %rel = getelementptr inbounds %struct.Complex, %struct.Complex* %c, i32 0, i32 0
  %2 = load double, double* %rel, align 8
  %cmp = fcmp oeq double %2, 0.000000e+00
  br i1 %cmp, label %land.lhs.true, label %if.end

land.lhs.true:                                    ; preds = %entry
  %img = getelementptr inbounds %struct.Complex, %struct.Complex* %c, i32 0, i32 1
  %3 = load double, double* %img, align 8
  %cmp1 = fcmp oeq double %3, 0.000000e+00
  br i1 %cmp1, label %if.then, label %if.end

if.then:                                          ; preds = %land.lhs.true
  call void @makeQuaterImaginary(%struct.QuaterImaginary* sret align 4 %agg.result, i8* getelementptr inbounds ([2 x i8], [2 x i8]* @.str.3, i32 0, i32 0))
  br label %return

if.end:                                           ; preds = %land.lhs.true, %entry
  %rel2 = getelementptr inbounds %struct.Complex, %struct.Complex* %c, i32 0, i32 0
  %4 = load double, double* %rel2, align 8
  %conv = fptosi double %4 to i32
  store i32 %conv, i32* %re, align 4
  %img3 = getelementptr inbounds %struct.Complex, %struct.Complex* %c, i32 0, i32 1
  %5 = load double, double* %img3, align 8
  %conv4 = fptosi double %5 to i32
  store i32 %conv4, i32* %im, align 4
  store i32 -1, i32* %fi, align 4
  br label %while.cond

while.cond:                                       ; preds = %if.end11, %if.end
  %6 = load i32, i32* %re, align 4
  %cmp5 = icmp ne i32 %6, 0
  br i1 %cmp5, label %while.body, label %while.end

while.body:                                       ; preds = %while.cond
  %7 = load i32, i32* %re, align 4
  %rem7 = srem i32 %7, -4
  store i32 %rem7, i32* %rem, align 4
  %8 = load i32, i32* %re, align 4
  %div = sdiv i32 %8, -4
  store i32 %div, i32* %re, align 4
  %9 = load i32, i32* %rem, align 4
  %cmp8 = icmp slt i32 %9, 0
  br i1 %cmp8, label %if.then10, label %if.end11

if.then10:                                        ; preds = %while.body
  %10 = load i32, i32* %rem, align 4
  %add = add nsw i32 %10, 4
  store i32 %add, i32* %rem, align 4
  %11 = load i32, i32* %re, align 4
  %inc = add nsw i32 %11, 1
  store i32 %inc, i32* %re, align 4
  br label %if.end11

if.end11:                                         ; preds = %if.then10, %while.body
  %12 = load i32, i32* %rem, align 4
  %add12 = add nsw i32 %12, 48
  %conv13 = trunc i32 %add12 to i8
  %13 = load i8*, i8** %p, align 4
  %incdec.ptr = getelementptr inbounds i8, i8* %13, i32 1
  store i8* %incdec.ptr, i8** %p, align 4
  store i8 %conv13, i8* %13, align 1
  %14 = load i8*, i8** %p, align 4
  %incdec.ptr14 = getelementptr inbounds i8, i8* %14, i32 1
  store i8* %incdec.ptr14, i8** %p, align 4
  store i8 48, i8* %14, align 1
  %15 = load i8*, i8** %p, align 4
  store i8 0, i8* %15, align 1
  br label %while.cond

while.end:                                        ; preds = %while.cond
  %16 = load i32, i32* %im, align 4
  %cmp15 = icmp ne i32 %16, 0
  br i1 %cmp15, label %if.then17, label %if.end53

if.then17:                                        ; preds = %while.end
  store i32 1, i32* %index, align 4
  %rel18 = getelementptr inbounds %struct.Complex, %struct.Complex* %.compoundliteral, i32 0, i32 0
  store double 0.000000e+00, double* %rel18, align 8
  %img19 = getelementptr inbounds %struct.Complex, %struct.Complex* %.compoundliteral, i32 0, i32 1
  %img20 = getelementptr inbounds %struct.Complex, %struct.Complex* %c, i32 0, i32 1
  %17 = load double, double* %img20, align 8
  store double %17, double* %img19, align 8
  %rel22 = getelementptr inbounds %struct.Complex, %struct.Complex* %.compoundliteral21, i32 0, i32 0
  store double 0.000000e+00, double* %rel22, align 8
  %img23 = getelementptr inbounds %struct.Complex, %struct.Complex* %.compoundliteral21, i32 0, i32 1
  store double 2.000000e+00, double* %img23, align 8
  call void @divComplex(%struct.Complex* sret align 8 %fc, %struct.Complex* byval(%struct.Complex) align 8 %.compoundliteral, %struct.Complex* byval(%struct.Complex) align 8 %.compoundliteral21)
  %rel24 = getelementptr inbounds %struct.Complex, %struct.Complex* %fc, i32 0, i32 0
  %18 = load double, double* %rel24, align 8
  store double %18, double* %f, align 8
  %19 = load double, double* %f, align 8
  %20 = call double @llvm.ceil.f64(double %19)
  %conv25 = fptosi double %20 to i32
  store i32 %conv25, i32* %im, align 4
  %21 = load double, double* %f, align 8
  %22 = load i32, i32* %im, align 4
  %conv26 = sitofp i32 %22 to double
  %sub = fsub double %21, %conv26
  %mul = fmul double -4.000000e+00, %sub
  store double %mul, double* %f, align 8
  br label %while.cond27

while.cond27:                                     ; preds = %if.end49, %if.then17
  %23 = load i32, i32* %im, align 4
  %cmp28 = icmp ne i32 %23, 0
  br i1 %cmp28, label %while.body30, label %while.end51

while.body30:                                     ; preds = %while.cond27
  %24 = load i32, i32* %im, align 4
  %rem32 = srem i32 %24, -4
  store i32 %rem32, i32* %rem31, align 4
  %25 = load i32, i32* %im, align 4
  %div33 = sdiv i32 %25, -4
  store i32 %div33, i32* %im, align 4
  %26 = load i32, i32* %rem31, align 4
  %cmp34 = icmp slt i32 %26, 0
  br i1 %cmp34, label %if.then36, label %if.end39

if.then36:                                        ; preds = %while.body30
  %27 = load i32, i32* %rem31, align 4
  %add37 = add nsw i32 %27, 4
  store i32 %add37, i32* %rem31, align 4
  %28 = load i32, i32* %im, align 4
  %inc38 = add nsw i32 %28, 1
  store i32 %inc38, i32* %im, align 4
  br label %if.end39

if.end39:                                         ; preds = %if.then36, %while.body30
  %29 = load i32, i32* %index, align 4
  %30 = load i8*, i8** %p, align 4
  %31 = load i8*, i8** %out.addr, align 4
  %sub.ptr.lhs.cast = ptrtoint i8* %30 to i32
  %sub.ptr.rhs.cast = ptrtoint i8* %31 to i32
  %sub.ptr.sub = sub i32 %sub.ptr.lhs.cast, %sub.ptr.rhs.cast
  %cmp40 = icmp ult i32 %29, %sub.ptr.sub
  br i1 %cmp40, label %if.then42, label %if.else

if.then42:                                        ; preds = %if.end39
  %32 = load i32, i32* %rem31, align 4
  %add43 = add nsw i32 %32, 48
  %conv44 = trunc i32 %add43 to i8
  %33 = load i8*, i8** %out.addr, align 4
  %34 = load i32, i32* %index, align 4
  %arrayidx = getelementptr inbounds i8, i8* %33, i32 %34
  store i8 %conv44, i8* %arrayidx, align 1
  br label %if.end49

if.else:                                          ; preds = %if.end39
  %35 = load i8*, i8** %p, align 4
  %incdec.ptr45 = getelementptr inbounds i8, i8* %35, i32 1
  store i8* %incdec.ptr45, i8** %p, align 4
  store i8 48, i8* %35, align 1
  %36 = load i32, i32* %rem31, align 4
  %add46 = add nsw i32 %36, 48
  %conv47 = trunc i32 %add46 to i8
  %37 = load i8*, i8** %p, align 4
  %incdec.ptr48 = getelementptr inbounds i8, i8* %37, i32 1
  store i8* %incdec.ptr48, i8** %p, align 4
  store i8 %conv47, i8* %37, align 1
  %38 = load i8*, i8** %p, align 4
  store i8 0, i8* %38, align 1
  br label %if.end49

if.end49:                                         ; preds = %if.else, %if.then42
  %39 = load i32, i32* %index, align 4
  %add50 = add i32 %39, 2
  store i32 %add50, i32* %index, align 4
  br label %while.cond27

while.end51:                                      ; preds = %while.cond27
  %40 = load double, double* %f, align 8
  %conv52 = fptosi double %40 to i32
  store i32 %conv52, i32* %fi, align 4
  br label %if.end53

if.end53:                                         ; preds = %while.end51, %while.end
  %41 = load i8*, i8** %out.addr, align 4
  %42 = load i8*, i8** %p, align 4
  call void @reverse(i8* %41, i8* %42)
  %43 = load i32, i32* %fi, align 4
  %cmp54 = icmp ne i32 %43, -1
  br i1 %cmp54, label %if.then56, label %if.end61

if.then56:                                        ; preds = %if.end53
  %44 = load i8*, i8** %p, align 4
  %incdec.ptr57 = getelementptr inbounds i8, i8* %44, i32 1
  store i8* %incdec.ptr57, i8** %p, align 4
  store i8 46, i8* %44, align 1
  %45 = load i32, i32* %fi, align 4
  %add58 = add nsw i32 %45, 48
  %conv59 = trunc i32 %add58 to i8
  %46 = load i8*, i8** %p, align 4
  %incdec.ptr60 = getelementptr inbounds i8, i8* %46, i32 1
  store i8* %incdec.ptr60, i8** %p, align 4
  store i8 %conv59, i8* %46, align 1
  %47 = load i8*, i8** %p, align 4
  store i8 0, i8* %47, align 1
  br label %if.end61

if.end61:                                         ; preds = %if.then56, %if.end53
  br label %while.cond62

while.cond62:                                     ; preds = %for.end, %if.end61
  %48 = load i8*, i8** %out.addr, align 4
  %arrayidx63 = getelementptr inbounds i8, i8* %48, i32 0
  %49 = load i8, i8* %arrayidx63, align 1
  %conv64 = sext i8 %49 to i32
  %cmp65 = icmp eq i32 %conv64, 48
  br i1 %cmp65, label %land.rhs, label %land.end

land.rhs:                                         ; preds = %while.cond62
  %50 = load i8*, i8** %out.addr, align 4
  %arrayidx67 = getelementptr inbounds i8, i8* %50, i32 1
  %51 = load i8, i8* %arrayidx67, align 1
  %conv68 = sext i8 %51 to i32
  %cmp69 = icmp ne i32 %conv68, 46
  br label %land.end

land.end:                                         ; preds = %land.rhs, %while.cond62
  %52 = phi i1 [ false, %while.cond62 ], [ %cmp69, %land.rhs ]
  br i1 %52, label %while.body71, label %while.end80

while.body71:                                     ; preds = %land.end
  store i32 0, i32* %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %while.body71
  %53 = load i8*, i8** %out.addr, align 4
  %54 = load i32, i32* %i, align 4
  %arrayidx72 = getelementptr inbounds i8, i8* %53, i32 %54
  %55 = load i8, i8* %arrayidx72, align 1
  %conv73 = sext i8 %55 to i32
  %cmp74 = icmp ne i32 %conv73, 0
  br i1 %cmp74, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %56 = load i8*, i8** %out.addr, align 4
  %57 = load i32, i32* %i, align 4
  %add76 = add i32 %57, 1
  %arrayidx77 = getelementptr inbounds i8, i8* %56, i32 %add76
  %58 = load i8, i8* %arrayidx77, align 1
  %59 = load i8*, i8** %out.addr, align 4
  %60 = load i32, i32* %i, align 4
  %arrayidx78 = getelementptr inbounds i8, i8* %59, i32 %60
  store i8 %58, i8* %arrayidx78, align 1
  br label %for.inc

for.inc:                                          ; preds = %for.body
  %61 = load i32, i32* %i, align 4
  %inc79 = add i32 %61, 1
  store i32 %inc79, i32* %i, align 4
  br label %for.cond

for.end:                                          ; preds = %for.cond
  br label %while.cond62

while.end80:                                      ; preds = %land.end
  %62 = load i8*, i8** %out.addr, align 4
  %63 = load i8, i8* %62, align 1
  %conv81 = sext i8 %63 to i32
  %cmp82 = icmp eq i32 %conv81, 46
  br i1 %cmp82, label %if.then84, label %if.end86

if.then84:                                        ; preds = %while.end80
  %64 = load i8*, i8** %out.addr, align 4
  %65 = load i8*, i8** %p, align 4
  call void @reverse(i8* %64, i8* %65)
  %66 = load i8*, i8** %p, align 4
  %incdec.ptr85 = getelementptr inbounds i8, i8* %66, i32 1
  store i8* %incdec.ptr85, i8** %p, align 4
  store i8 48, i8* %66, align 1
  %67 = load i8*, i8** %p, align 4
  store i8 0, i8* %67, align 1
  %68 = load i8*, i8** %out.addr, align 4
  %69 = load i8*, i8** %p, align 4
  call void @reverse(i8* %68, i8* %69)
  br label %if.end86

if.end86:                                         ; preds = %if.then84, %while.end80
  %70 = load i8*, i8** %out.addr, align 4
  call void @makeQuaterImaginary(%struct.QuaterImaginary* sret align 4 %agg.result, i8* %70)
  br label %return

return:                                           ; preds = %if.end86, %if.then
  ret void
}

; Function Attrs: nounwind readnone speculatable willreturn
declare double @llvm.ceil.f64(double %0) #4

; Function Attrs: noinline nounwind optnone
define hidden i32 @main() #0 {
entry:
  %retval = alloca i32, align 4
  %buffer = alloca [16 x i8], align 16
  %i = alloca i32, align 4
  %c1 = alloca %struct.Complex, align 8
  %qi = alloca %struct.QuaterImaginary, align 4
  %c2 = alloca %struct.Complex, align 8
  %tmp = alloca %struct.Complex, align 8
  %tmp3 = alloca %struct.QuaterImaginary, align 4
  %tmp5 = alloca %struct.Complex, align 8
  %c114 = alloca %struct.Complex, align 8
  %qi18 = alloca %struct.QuaterImaginary, align 4
  %c220 = alloca %struct.Complex, align 8
  %tmp24 = alloca %struct.Complex, align 8
  %tmp25 = alloca %struct.QuaterImaginary, align 4
  %tmp27 = alloca %struct.Complex, align 8
  store i32 0, i32* %retval, align 4
  store i32 1, i32* %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %0 = load i32, i32* %i, align 4
  %cmp = icmp sle i32 %0, 16
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %rel = getelementptr inbounds %struct.Complex, %struct.Complex* %c1, i32 0, i32 0
  %1 = load i32, i32* %i, align 4
  %conv = sitofp i32 %1 to double
  store double %conv, double* %rel, align 8
  %img = getelementptr inbounds %struct.Complex, %struct.Complex* %c1, i32 0, i32 1
  store double 0.000000e+00, double* %img, align 8
  %arraydecay = getelementptr inbounds [16 x i8], [16 x i8]* %buffer, i32 0, i32 0
  call void @c2qi(%struct.QuaterImaginary* sret align 4 %qi, %struct.Complex* byval(%struct.Complex) align 8 %c1, i8* %arraydecay)
  call void @qi2c(%struct.Complex* sret align 8 %c2, %struct.QuaterImaginary* byval(%struct.QuaterImaginary) align 4 %qi)
  call void @printComplex(%struct.Complex* byval(%struct.Complex) align 8 %c1)
  %call = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.4, i32 0, i32 0))
  call void @printQuaterImaginary(%struct.QuaterImaginary* byval(%struct.QuaterImaginary) align 4 %qi)
  %call1 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.4, i32 0, i32 0))
  call void @printComplex(%struct.Complex* byval(%struct.Complex) align 8 %c2)
  %call2 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([6 x i8], [6 x i8]* @.str.5, i32 0, i32 0))
  call void @negComplex(%struct.Complex* sret align 8 %tmp, %struct.Complex* byval(%struct.Complex) align 8 %c1)
  %2 = bitcast %struct.Complex* %c1 to i8*
  %3 = bitcast %struct.Complex* %tmp to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 8 %2, i8* align 8 %3, i32 16, i1 false)
  %arraydecay4 = getelementptr inbounds [16 x i8], [16 x i8]* %buffer, i32 0, i32 0
  call void @c2qi(%struct.QuaterImaginary* sret align 4 %tmp3, %struct.Complex* byval(%struct.Complex) align 8 %c1, i8* %arraydecay4)
  %4 = bitcast %struct.QuaterImaginary* %qi to i8*
  %5 = bitcast %struct.QuaterImaginary* %tmp3 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 4 %4, i8* align 4 %5, i32 8, i1 false)
  call void @qi2c(%struct.Complex* sret align 8 %tmp5, %struct.QuaterImaginary* byval(%struct.QuaterImaginary) align 4 %qi)
  %6 = bitcast %struct.Complex* %c2 to i8*
  %7 = bitcast %struct.Complex* %tmp5 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 8 %6, i8* align 8 %7, i32 16, i1 false)
  call void @printComplex(%struct.Complex* byval(%struct.Complex) align 8 %c1)
  %call6 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.4, i32 0, i32 0))
  call void @printQuaterImaginary(%struct.QuaterImaginary* byval(%struct.QuaterImaginary) align 4 %qi)
  %call7 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.4, i32 0, i32 0))
  call void @printComplex(%struct.Complex* byval(%struct.Complex) align 8 %c2)
  %call8 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([2 x i8], [2 x i8]* @.str.6, i32 0, i32 0))
  br label %for.inc

for.inc:                                          ; preds = %for.body
  %8 = load i32, i32* %i, align 4
  %inc = add nsw i32 %8, 1
  store i32 %inc, i32* %i, align 4
  br label %for.cond

for.end:                                          ; preds = %for.cond
  %call9 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([2 x i8], [2 x i8]* @.str.6, i32 0, i32 0))
  store i32 1, i32* %i, align 4
  br label %for.cond10

for.cond10:                                       ; preds = %for.inc31, %for.end
  %9 = load i32, i32* %i, align 4
  %cmp11 = icmp sle i32 %9, 16
  br i1 %cmp11, label %for.body13, label %for.end33

for.body13:                                       ; preds = %for.cond10
  %rel15 = getelementptr inbounds %struct.Complex, %struct.Complex* %c114, i32 0, i32 0
  store double 0.000000e+00, double* %rel15, align 8
  %img16 = getelementptr inbounds %struct.Complex, %struct.Complex* %c114, i32 0, i32 1
  %10 = load i32, i32* %i, align 4
  %conv17 = sitofp i32 %10 to double
  store double %conv17, double* %img16, align 8
  %arraydecay19 = getelementptr inbounds [16 x i8], [16 x i8]* %buffer, i32 0, i32 0
  call void @c2qi(%struct.QuaterImaginary* sret align 4 %qi18, %struct.Complex* byval(%struct.Complex) align 8 %c114, i8* %arraydecay19)
  call void @qi2c(%struct.Complex* sret align 8 %c220, %struct.QuaterImaginary* byval(%struct.QuaterImaginary) align 4 %qi18)
  call void @printComplex(%struct.Complex* byval(%struct.Complex) align 8 %c114)
  %call21 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.4, i32 0, i32 0))
  call void @printQuaterImaginary(%struct.QuaterImaginary* byval(%struct.QuaterImaginary) align 4 %qi18)
  %call22 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.4, i32 0, i32 0))
  call void @printComplex(%struct.Complex* byval(%struct.Complex) align 8 %c220)
  %call23 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([6 x i8], [6 x i8]* @.str.5, i32 0, i32 0))
  call void @negComplex(%struct.Complex* sret align 8 %tmp24, %struct.Complex* byval(%struct.Complex) align 8 %c114)
  %11 = bitcast %struct.Complex* %c114 to i8*
  %12 = bitcast %struct.Complex* %tmp24 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 8 %11, i8* align 8 %12, i32 16, i1 false)
  %arraydecay26 = getelementptr inbounds [16 x i8], [16 x i8]* %buffer, i32 0, i32 0
  call void @c2qi(%struct.QuaterImaginary* sret align 4 %tmp25, %struct.Complex* byval(%struct.Complex) align 8 %c114, i8* %arraydecay26)
  %13 = bitcast %struct.QuaterImaginary* %qi18 to i8*
  %14 = bitcast %struct.QuaterImaginary* %tmp25 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 4 %13, i8* align 4 %14, i32 8, i1 false)
  call void @qi2c(%struct.Complex* sret align 8 %tmp27, %struct.QuaterImaginary* byval(%struct.QuaterImaginary) align 4 %qi18)
  %15 = bitcast %struct.Complex* %c220 to i8*
  %16 = bitcast %struct.Complex* %tmp27 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 8 %15, i8* align 8 %16, i32 16, i1 false)
  call void @printComplex(%struct.Complex* byval(%struct.Complex) align 8 %c114)
  %call28 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.4, i32 0, i32 0))
  call void @printQuaterImaginary(%struct.QuaterImaginary* byval(%struct.QuaterImaginary) align 4 %qi18)
  %call29 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.4, i32 0, i32 0))
  call void @printComplex(%struct.Complex* byval(%struct.Complex) align 8 %c220)
  %call30 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([2 x i8], [2 x i8]* @.str.6, i32 0, i32 0))
  br label %for.inc31

for.inc31:                                        ; preds = %for.body13
  %17 = load i32, i32* %i, align 4
  %inc32 = add nsw i32 %17, 1
  store i32 %inc32, i32* %i, align 4
  br label %for.cond10

for.end33:                                        ; preds = %for.cond10
  ret i32 0
}

attributes #0 = { noinline nounwind optnone "correctly-rounded-divide-sqrt-fp-math"="false" "disable-tail-calls"="false" "frame-pointer"="none" "less-precise-fpmad"="false" "min-legal-vector-width"="0" "no-infs-fp-math"="false" "no-jump-tables"="false" "no-nans-fp-math"="false" "no-signed-zeros-fp-math"="false" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="generic" "unsafe-fp-math"="false" "use-soft-float"="false" }
attributes #1 = { "correctly-rounded-divide-sqrt-fp-math"="false" "disable-tail-calls"="false" "frame-pointer"="none" "less-precise-fpmad"="false" "no-infs-fp-math"="false" "no-nans-fp-math"="false" "no-signed-zeros-fp-math"="false" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="generic" "unsafe-fp-math"="false" "use-soft-float"="false" }
attributes #2 = { nounwind readonly "correctly-rounded-divide-sqrt-fp-math"="false" "disable-tail-calls"="false" "frame-pointer"="none" "less-precise-fpmad"="false" "no-infs-fp-math"="false" "no-nans-fp-math"="false" "no-signed-zeros-fp-math"="false" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="generic" "unsafe-fp-math"="false" "use-soft-float"="false" }
attributes #3 = { argmemonly nounwind willreturn }
attributes #4 = { nounwind readnone speculatable willreturn }
attributes #5 = { nounwind readonly }

!llvm.module.flags = !{!0}
!llvm.ident = !{!1}

!0 = !{i32 1, !"wchar_size", i32 4}
!1 = !{!"clang version 11.0.0 (https://github.com/Jacarte/llvm-project.git 0f6dea67136cc1e0b3d200eb2bb165628970c44b)"}

; extracted candidates
#########################################################
; exiting Souper's runOnFunction() for divComplex()

; entering Souper's runOnFunction() for inv()

; ModuleID = './Imaginary_base_numbers.c.bc'
source_filename = "./Imaginary_base_numbers.c"
target datalayout = "e-m:e-p:32:32-i64:64-n32:64-S128"
target triple = "wasm32-unknown-wasi"

%struct.Complex = type { double, double }
%struct.QuaterImaginary = type { i8*, i32 }

@.str = private unnamed_addr constant [17 x i8] c"(%3.0f + %3.0fi)\00", align 1
@TWO_I = hidden constant %struct.Complex { double 0.000000e+00, double 2.000000e+00 }, align 8
@INV_TWO_I = hidden constant %struct.Complex { double 0.000000e+00, double -5.000000e-01 }, align 8
@.str.1 = private unnamed_addr constant [4 x i8] c"%8s\00", align 1
@.str.2 = private unnamed_addr constant [9 x i8] c" ERROR  \00", align 1
@.str.3 = private unnamed_addr constant [2 x i8] c"0\00", align 1
@.str.4 = private unnamed_addr constant [5 x i8] c" -> \00", align 1
@.str.5 = private unnamed_addr constant [6 x i8] c"     \00", align 1
@.str.6 = private unnamed_addr constant [2 x i8] c"\0A\00", align 1
@llvm.used = appending global [1 x i8*] [i8* bitcast (i32 ()* @__main_void to i8*)], section "llvm.metadata"

@__main_void = alias i32 (), i32 ()* @main

; Function Attrs: noinline nounwind optnone
define hidden i32 @find(i8* %s, i8 signext %c) #0 {
entry:
  %retval = alloca i32, align 4
  %s.addr = alloca i8*, align 4
  %c.addr = alloca i8, align 1
  %i = alloca i8*, align 4
  store i8* %s, i8** %s.addr, align 4
  store i8 %c, i8* %c.addr, align 1
  %0 = load i8*, i8** %s.addr, align 4
  store i8* %0, i8** %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %1 = load i8*, i8** %i, align 4
  %2 = load i8, i8* %1, align 1
  %conv = sext i8 %2 to i32
  %cmp = icmp ne i32 %conv, 0
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %3 = load i8*, i8** %i, align 4
  %4 = load i8, i8* %3, align 1
  %conv2 = sext i8 %4 to i32
  %5 = load i8, i8* %c.addr, align 1
  %conv3 = sext i8 %5 to i32
  %cmp4 = icmp eq i32 %conv2, %conv3
  br i1 %cmp4, label %if.then, label %if.end

if.then:                                          ; preds = %for.body
  %6 = load i8*, i8** %i, align 4
  %7 = load i8*, i8** %s.addr, align 4
  %sub.ptr.lhs.cast = ptrtoint i8* %6 to i32
  %sub.ptr.rhs.cast = ptrtoint i8* %7 to i32
  %sub.ptr.sub = sub i32 %sub.ptr.lhs.cast, %sub.ptr.rhs.cast
  store i32 %sub.ptr.sub, i32* %retval, align 4
  br label %return

if.end:                                           ; preds = %for.body
  br label %for.inc

for.inc:                                          ; preds = %if.end
  %8 = load i8*, i8** %i, align 4
  %incdec.ptr = getelementptr inbounds i8, i8* %8, i32 1
  store i8* %incdec.ptr, i8** %i, align 4
  br label %for.cond

for.end:                                          ; preds = %for.cond
  store i32 -1, i32* %retval, align 4
  br label %return

return:                                           ; preds = %for.end, %if.then
  %9 = load i32, i32* %retval, align 4
  ret i32 %9
}

; Function Attrs: noinline nounwind optnone
define hidden void @reverse(i8* %b, i8* %e) #0 {
entry:
  %b.addr = alloca i8*, align 4
  %e.addr = alloca i8*, align 4
  %t = alloca i8, align 1
  store i8* %b, i8** %b.addr, align 4
  store i8* %e, i8** %e.addr, align 4
  %0 = load i8*, i8** %e.addr, align 4
  %incdec.ptr = getelementptr inbounds i8, i8* %0, i32 -1
  store i8* %incdec.ptr, i8** %e.addr, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %1 = load i8*, i8** %b.addr, align 4
  %2 = load i8*, i8** %e.addr, align 4
  %cmp = icmp ult i8* %1, %2
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %3 = load i8*, i8** %b.addr, align 4
  %4 = load i8, i8* %3, align 1
  store i8 %4, i8* %t, align 1
  %5 = load i8*, i8** %e.addr, align 4
  %6 = load i8, i8* %5, align 1
  %7 = load i8*, i8** %b.addr, align 4
  store i8 %6, i8* %7, align 1
  %8 = load i8, i8* %t, align 1
  %9 = load i8*, i8** %e.addr, align 4
  store i8 %8, i8* %9, align 1
  br label %for.inc

for.inc:                                          ; preds = %for.body
  %10 = load i8*, i8** %b.addr, align 4
  %incdec.ptr1 = getelementptr inbounds i8, i8* %10, i32 1
  store i8* %incdec.ptr1, i8** %b.addr, align 4
  %11 = load i8*, i8** %e.addr, align 4
  %incdec.ptr2 = getelementptr inbounds i8, i8* %11, i32 -1
  store i8* %incdec.ptr2, i8** %e.addr, align 4
  br label %for.cond

for.end:                                          ; preds = %for.cond
  ret void
}

; Function Attrs: noinline nounwind optnone
define hidden void @printComplex(%struct.Complex* byval(%struct.Complex) align 8 %c) #0 {
entry:
  %rel = getelementptr inbounds %struct.Complex, %struct.Complex* %c, i32 0, i32 0
  %0 = load double, double* %rel, align 8
  %img = getelementptr inbounds %struct.Complex, %struct.Complex* %c, i32 0, i32 1
  %1 = load double, double* %img, align 8
  %call = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([17 x i8], [17 x i8]* @.str, i32 0, i32 0), double %0, double %1)
  ret void
}

declare i32 @printf(i8* %0, ...) #1

; Function Attrs: noinline nounwind optnone
define hidden void @makeComplex(%struct.Complex* noalias sret align 8 %agg.result, double %rel, double %img) #0 {
entry:
  %rel.addr = alloca double, align 8
  %img.addr = alloca double, align 8
  store double %rel, double* %rel.addr, align 8
  store double %img, double* %img.addr, align 8
  %rel1 = getelementptr inbounds %struct.Complex, %struct.Complex* %agg.result, i32 0, i32 0
  %0 = load double, double* %rel.addr, align 8
  store double %0, double* %rel1, align 8
  %img2 = getelementptr inbounds %struct.Complex, %struct.Complex* %agg.result, i32 0, i32 1
  %1 = load double, double* %img.addr, align 8
  store double %1, double* %img2, align 8
  ret void
}

; Function Attrs: noinline nounwind optnone
define hidden void @addComplex(%struct.Complex* noalias sret align 8 %agg.result, %struct.Complex* byval(%struct.Complex) align 8 %a, %struct.Complex* byval(%struct.Complex) align 8 %b) #0 {
entry:
  %rel = getelementptr inbounds %struct.Complex, %struct.Complex* %agg.result, i32 0, i32 0
  %rel1 = getelementptr inbounds %struct.Complex, %struct.Complex* %a, i32 0, i32 0
  %0 = load double, double* %rel1, align 8
  %rel2 = getelementptr inbounds %struct.Complex, %struct.Complex* %b, i32 0, i32 0
  %1 = load double, double* %rel2, align 8
  %add = fadd double %0, %1
  store double %add, double* %rel, align 8
  %img = getelementptr inbounds %struct.Complex, %struct.Complex* %agg.result, i32 0, i32 1
  %img3 = getelementptr inbounds %struct.Complex, %struct.Complex* %a, i32 0, i32 1
  %2 = load double, double* %img3, align 8
  %img4 = getelementptr inbounds %struct.Complex, %struct.Complex* %b, i32 0, i32 1
  %3 = load double, double* %img4, align 8
  %add5 = fadd double %2, %3
  store double %add5, double* %img, align 8
  ret void
}

; Function Attrs: noinline nounwind optnone
define hidden void @mulComplex(%struct.Complex* noalias sret align 8 %agg.result, %struct.Complex* byval(%struct.Complex) align 8 %a, %struct.Complex* byval(%struct.Complex) align 8 %b) #0 {
entry:
  %rel = getelementptr inbounds %struct.Complex, %struct.Complex* %agg.result, i32 0, i32 0
  %rel1 = getelementptr inbounds %struct.Complex, %struct.Complex* %a, i32 0, i32 0
  %0 = load double, double* %rel1, align 8
  %rel2 = getelementptr inbounds %struct.Complex, %struct.Complex* %b, i32 0, i32 0
  %1 = load double, double* %rel2, align 8
  %mul = fmul double %0, %1
  %img = getelementptr inbounds %struct.Complex, %struct.Complex* %a, i32 0, i32 1
  %2 = load double, double* %img, align 8
  %img3 = getelementptr inbounds %struct.Complex, %struct.Complex* %b, i32 0, i32 1
  %3 = load double, double* %img3, align 8
  %mul4 = fmul double %2, %3
  %sub = fsub double %mul, %mul4
  store double %sub, double* %rel, align 8
  %img5 = getelementptr inbounds %struct.Complex, %struct.Complex* %agg.result, i32 0, i32 1
  %rel6 = getelementptr inbounds %struct.Complex, %struct.Complex* %a, i32 0, i32 0
  %4 = load double, double* %rel6, align 8
  %img7 = getelementptr inbounds %struct.Complex, %struct.Complex* %b, i32 0, i32 1
  %5 = load double, double* %img7, align 8
  %mul8 = fmul double %4, %5
  %img9 = getelementptr inbounds %struct.Complex, %struct.Complex* %a, i32 0, i32 1
  %6 = load double, double* %img9, align 8
  %rel10 = getelementptr inbounds %struct.Complex, %struct.Complex* %b, i32 0, i32 0
  %7 = load double, double* %rel10, align 8
  %mul11 = fmul double %6, %7
  %sub12 = fsub double %mul8, %mul11
  store double %sub12, double* %img5, align 8
  ret void
}

; Function Attrs: noinline nounwind optnone
define hidden void @mulComplexD(%struct.Complex* noalias sret align 8 %agg.result, %struct.Complex* byval(%struct.Complex) align 8 %a, double %b) #0 {
entry:
  %b.addr = alloca double, align 8
  store double %b, double* %b.addr, align 8
  %rel = getelementptr inbounds %struct.Complex, %struct.Complex* %agg.result, i32 0, i32 0
  %rel1 = getelementptr inbounds %struct.Complex, %struct.Complex* %a, i32 0, i32 0
  %0 = load double, double* %rel1, align 8
  %1 = load double, double* %b.addr, align 8
  %mul = fmul double %0, %1
  store double %mul, double* %rel, align 8
  %img = getelementptr inbounds %struct.Complex, %struct.Complex* %agg.result, i32 0, i32 1
  %img2 = getelementptr inbounds %struct.Complex, %struct.Complex* %a, i32 0, i32 1
  %2 = load double, double* %img2, align 8
  %3 = load double, double* %b.addr, align 8
  %mul3 = fmul double %2, %3
  store double %mul3, double* %img, align 8
  ret void
}

; Function Attrs: noinline nounwind optnone
define hidden void @negComplex(%struct.Complex* noalias sret align 8 %agg.result, %struct.Complex* byval(%struct.Complex) align 8 %a) #0 {
entry:
  call void @mulComplexD(%struct.Complex* sret align 8 %agg.result, %struct.Complex* byval(%struct.Complex) align 8 %a, double -1.000000e+00)
  ret void
}

; Function Attrs: noinline nounwind optnone
define hidden void @divComplex(%struct.Complex* noalias sret align 8 %agg.result, %struct.Complex* byval(%struct.Complex) align 8 %a, %struct.Complex* byval(%struct.Complex) align 8 %b) #0 {
entry:
  %re = alloca double, align 8
  %im = alloca double, align 8
  %d = alloca double, align 8
  %rel = getelementptr inbounds %struct.Complex, %struct.Complex* %a, i32 0, i32 0
  %0 = load double, double* %rel, align 8
  %rel1 = getelementptr inbounds %struct.Complex, %struct.Complex* %b, i32 0, i32 0
  %1 = load double, double* %rel1, align 8
  %mul = fmul double %0, %1
  %img = getelementptr inbounds %struct.Complex, %struct.Complex* %a, i32 0, i32 1
  %2 = load double, double* %img, align 8
  %img2 = getelementptr inbounds %struct.Complex, %struct.Complex* %b, i32 0, i32 1
  %3 = load double, double* %img2, align 8
  %mul3 = fmul double %2, %3
  %add = fadd double %mul, %mul3
  store double %add, double* %re, align 8
  %img4 = getelementptr inbounds %struct.Complex, %struct.Complex* %a, i32 0, i32 1
  %4 = load double, double* %img4, align 8
  %rel5 = getelementptr inbounds %struct.Complex, %struct.Complex* %b, i32 0, i32 0
  %5 = load double, double* %rel5, align 8
  %mul6 = fmul double %4, %5
  %rel7 = getelementptr inbounds %struct.Complex, %struct.Complex* %a, i32 0, i32 0
  %6 = load double, double* %rel7, align 8
  %img8 = getelementptr inbounds %struct.Complex, %struct.Complex* %b, i32 0, i32 1
  %7 = load double, double* %img8, align 8
  %mul9 = fmul double %6, %7
  %sub = fsub double %mul6, %mul9
  store double %sub, double* %im, align 8
  %rel10 = getelementptr inbounds %struct.Complex, %struct.Complex* %b, i32 0, i32 0
  %8 = load double, double* %rel10, align 8
  %rel11 = getelementptr inbounds %struct.Complex, %struct.Complex* %b, i32 0, i32 0
  %9 = load double, double* %rel11, align 8
  %mul12 = fmul double %8, %9
  %img13 = getelementptr inbounds %struct.Complex, %struct.Complex* %b, i32 0, i32 1
  %10 = load double, double* %img13, align 8
  %img14 = getelementptr inbounds %struct.Complex, %struct.Complex* %b, i32 0, i32 1
  %11 = load double, double* %img14, align 8
  %mul15 = fmul double %10, %11
  %add16 = fadd double %mul12, %mul15
  store double %add16, double* %d, align 8
  %rel17 = getelementptr inbounds %struct.Complex, %struct.Complex* %agg.result, i32 0, i32 0
  %12 = load double, double* %re, align 8
  %13 = load double, double* %d, align 8
  %div = fdiv double %12, %13
  store double %div, double* %rel17, align 8
  %img18 = getelementptr inbounds %struct.Complex, %struct.Complex* %agg.result, i32 0, i32 1
  %14 = load double, double* %im, align 8
  %15 = load double, double* %d, align 8
  %div19 = fdiv double %14, %15
  store double %div19, double* %img18, align 8
  ret void
}

; Function Attrs: noinline nounwind optnone
define hidden void @inv(%struct.Complex* noalias sret align 8 %agg.result, %struct.Complex* byval(%struct.Complex) align 8 %c) #0 {
entry:
  %d = alloca double, align 8
  %rel = getelementptr inbounds %struct.Complex, %struct.Complex* %c, i32 0, i32 0
  %0 = load double, double* %rel, align 8
  %rel1 = getelementptr inbounds %struct.Complex, %struct.Complex* %c, i32 0, i32 0
  %1 = load double, double* %rel1, align 8
  %mul = fmul double %0, %1
  %img = getelementptr inbounds %struct.Complex, %struct.Complex* %c, i32 0, i32 1
  %2 = load double, double* %img, align 8
  %img2 = getelementptr inbounds %struct.Complex, %struct.Complex* %c, i32 0, i32 1
  %3 = load double, double* %img2, align 8
  %mul3 = fmul double %2, %3
  %add = fadd double %mul, %mul3
  store double %add, double* %d, align 8
  %rel4 = getelementptr inbounds %struct.Complex, %struct.Complex* %agg.result, i32 0, i32 0
  %rel5 = getelementptr inbounds %struct.Complex, %struct.Complex* %c, i32 0, i32 0
  %4 = load double, double* %rel5, align 8
  %5 = load double, double* %d, align 8
  %div = fdiv double %4, %5
  store double %div, double* %rel4, align 8
  %img6 = getelementptr inbounds %struct.Complex, %struct.Complex* %agg.result, i32 0, i32 1
  %img7 = getelementptr inbounds %struct.Complex, %struct.Complex* %c, i32 0, i32 1
  %6 = load double, double* %img7, align 8
  %fneg = fneg double %6
  %7 = load double, double* %d, align 8
  %div8 = fdiv double %fneg, %7
  store double %div8, double* %img6, align 8
  ret void
}

; Function Attrs: noinline nounwind optnone
define hidden void @makeQuaterImaginary(%struct.QuaterImaginary* noalias sret align 4 %agg.result, i8* %s) #0 {
entry:
  %s.addr = alloca i8*, align 4
  %i = alloca i32, align 4
  %valid1 = alloca i32, align 4
  %cnt = alloca i32, align 4
  store i8* %s, i8** %s.addr, align 4
  %b2i = getelementptr inbounds %struct.QuaterImaginary, %struct.QuaterImaginary* %agg.result, i32 0, i32 0
  %0 = load i8*, i8** %s.addr, align 4
  store i8* %0, i8** %b2i, align 4
  %valid = getelementptr inbounds %struct.QuaterImaginary, %struct.QuaterImaginary* %agg.result, i32 0, i32 1
  store i32 0, i32* %valid, align 4
  store i32 1, i32* %valid1, align 4
  store i32 0, i32* %cnt, align 4
  %1 = load i8*, i8** %s.addr, align 4
  %2 = load i8, i8* %1, align 1
  %conv = sext i8 %2 to i32
  %cmp = icmp ne i32 %conv, 0
  br i1 %cmp, label %if.then, label %if.end26

if.then:                                          ; preds = %entry
  store i32 0, i32* %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.then
  %3 = load i8*, i8** %s.addr, align 4
  %4 = load i32, i32* %i, align 4
  %arrayidx = getelementptr inbounds i8, i8* %3, i32 %4
  %5 = load i8, i8* %arrayidx, align 1
  %conv3 = sext i8 %5 to i32
  %cmp4 = icmp ne i32 %conv3, 0
  br i1 %cmp4, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %6 = load i8*, i8** %s.addr, align 4
  %7 = load i32, i32* %i, align 4
  %arrayidx6 = getelementptr inbounds i8, i8* %6, i32 %7
  %8 = load i8, i8* %arrayidx6, align 1
  %conv7 = sext i8 %8 to i32
  %cmp8 = icmp slt i32 %conv7, 48
  br i1 %cmp8, label %if.then14, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %for.body
  %9 = load i8*, i8** %s.addr, align 4
  %10 = load i32, i32* %i, align 4
  %arrayidx10 = getelementptr inbounds i8, i8* %9, i32 %10
  %11 = load i8, i8* %arrayidx10, align 1
  %conv11 = sext i8 %11 to i32
  %cmp12 = icmp slt i32 51, %conv11
  br i1 %cmp12, label %if.then14, label %if.end20

if.then14:                                        ; preds = %lor.lhs.false, %for.body
  %12 = load i8*, i8** %s.addr, align 4
  %13 = load i32, i32* %i, align 4
  %arrayidx15 = getelementptr inbounds i8, i8* %12, i32 %13
  %14 = load i8, i8* %arrayidx15, align 1
  %conv16 = sext i8 %14 to i32
  %cmp17 = icmp eq i32 %conv16, 46
  br i1 %cmp17, label %if.then19, label %if.else

if.then19:                                        ; preds = %if.then14
  %15 = load i32, i32* %cnt, align 4
  %inc = add i32 %15, 1
  store i32 %inc, i32* %cnt, align 4
  br label %if.end

if.else:                                          ; preds = %if.then14
  store i32 0, i32* %valid1, align 4
  br label %for.end

if.end:                                           ; preds = %if.then19
  br label %if.end20

if.end20:                                         ; preds = %if.end, %lor.lhs.false
  br label %for.inc

for.inc:                                          ; preds = %if.end20
  %16 = load i32, i32* %i, align 4
  %inc21 = add i32 %16, 1
  store i32 %inc21, i32* %i, align 4
  br label %for.cond

for.end:                                          ; preds = %if.else, %for.cond
  %17 = load i32, i32* %valid1, align 4
  %tobool = icmp ne i32 %17, 0
  br i1 %tobool, label %land.lhs.true, label %if.end25

land.lhs.true:                                    ; preds = %for.end
  %18 = load i32, i32* %cnt, align 4
  %cmp22 = icmp ugt i32 %18, 1
  br i1 %cmp22, label %if.then24, label %if.end25

if.then24:                                        ; preds = %land.lhs.true
  store i32 0, i32* %valid1, align 4
  br label %if.end25

if.end25:                                         ; preds = %if.then24, %land.lhs.true, %for.end
  br label %if.end26

if.end26:                                         ; preds = %if.end25, %entry
  %19 = load i32, i32* %valid1, align 4
  %valid27 = getelementptr inbounds %struct.QuaterImaginary, %struct.QuaterImaginary* %agg.result, i32 0, i32 1
  store i32 %19, i32* %valid27, align 4
  ret void
}

; Function Attrs: noinline nounwind optnone
define hidden void @printQuaterImaginary(%struct.QuaterImaginary* byval(%struct.QuaterImaginary) align 4 %qi) #0 {
entry:
  %valid = getelementptr inbounds %struct.QuaterImaginary, %struct.QuaterImaginary* %qi, i32 0, i32 1
  %0 = load i32, i32* %valid, align 4
  %tobool = icmp ne i32 %0, 0
  br i1 %tobool, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  %b2i = getelementptr inbounds %struct.QuaterImaginary, %struct.QuaterImaginary* %qi, i32 0, i32 0
  %1 = load i8*, i8** %b2i, align 4
  %call = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([4 x i8], [4 x i8]* @.str.1, i32 0, i32 0), i8* %1)
  br label %if.end

if.else:                                          ; preds = %entry
  %call1 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([9 x i8], [9 x i8]* @.str.2, i32 0, i32 0))
  br label %if.end

if.end:                                           ; preds = %if.else, %if.then
  ret void
}

; Function Attrs: noinline nounwind optnone
define hidden void @qi2c(%struct.Complex* noalias sret align 8 %agg.result, %struct.QuaterImaginary* byval(%struct.QuaterImaginary) align 4 %qi) #0 {
entry:
  %len = alloca i32, align 4
  %pointPos = alloca i32, align 4
  %posLen = alloca i32, align 4
  %prod = alloca %struct.Complex, align 8
  %j = alloca i32, align 4
  %k = alloca double, align 8
  %tmp = alloca %struct.Complex, align 8
  %agg.tmp = alloca %struct.Complex, align 8
  %tmp10 = alloca %struct.Complex, align 8
  %k18 = alloca double, align 8
  %tmp27 = alloca %struct.Complex, align 8
  %agg.tmp28 = alloca %struct.Complex, align 8
  %tmp30 = alloca %struct.Complex, align 8
  %b2i = getelementptr inbounds %struct.QuaterImaginary, %struct.QuaterImaginary* %qi, i32 0, i32 0
  %0 = load i8*, i8** %b2i, align 4
  %call = call i32 @strlen(i8* %0) #5
  store i32 %call, i32* %len, align 4
  %b2i1 = getelementptr inbounds %struct.QuaterImaginary, %struct.QuaterImaginary* %qi, i32 0, i32 0
  %1 = load i8*, i8** %b2i1, align 4
  %call2 = call i32 @find(i8* %1, i8 signext 46)
  store i32 %call2, i32* %pointPos, align 4
  %2 = load i32, i32* %pointPos, align 4
  %cmp = icmp sgt i32 %2, 0
  br i1 %cmp, label %cond.true, label %cond.false

cond.true:                                        ; preds = %entry
  %3 = load i32, i32* %pointPos, align 4
  br label %cond.end

cond.false:                                       ; preds = %entry
  %4 = load i32, i32* %len, align 4
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi i32 [ %3, %cond.true ], [ %4, %cond.false ]
  store i32 %cond, i32* %posLen, align 4
  call void @makeComplex(%struct.Complex* sret align 8 %agg.result, double 0.000000e+00, double 0.000000e+00)
  call void @makeComplex(%struct.Complex* sret align 8 %prod, double 1.000000e+00, double 0.000000e+00)
  store i32 0, i32* %j, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %cond.end
  %5 = load i32, i32* %j, align 4
  %6 = load i32, i32* %posLen, align 4
  %cmp3 = icmp ult i32 %5, %6
  br i1 %cmp3, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %b2i4 = getelementptr inbounds %struct.QuaterImaginary, %struct.QuaterImaginary* %qi, i32 0, i32 0
  %7 = load i8*, i8** %b2i4, align 4
  %8 = load i32, i32* %posLen, align 4
  %sub = sub i32 %8, 1
  %9 = load i32, i32* %j, align 4
  %sub5 = sub i32 %sub, %9
  %arrayidx = getelementptr inbounds i8, i8* %7, i32 %sub5
  %10 = load i8, i8* %arrayidx, align 1
  %conv = sext i8 %10 to i32
  %sub6 = sub nsw i32 %conv, 48
  %conv7 = sitofp i32 %sub6 to double
  store double %conv7, double* %k, align 8
  %11 = load double, double* %k, align 8
  %cmp8 = fcmp ogt double %11, 0.000000e+00
  br i1 %cmp8, label %if.then, label %if.end

if.then:                                          ; preds = %for.body
  %12 = load double, double* %k, align 8
  call void @mulComplexD(%struct.Complex* sret align 8 %agg.tmp, %struct.Complex* byval(%struct.Complex) align 8 %prod, double %12)
  call void @addComplex(%struct.Complex* sret align 8 %tmp, %struct.Complex* byval(%struct.Complex) align 8 %agg.result, %struct.Complex* byval(%struct.Complex) align 8 %agg.tmp)
  %13 = bitcast %struct.Complex* %agg.result to i8*
  %14 = bitcast %struct.Complex* %tmp to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 8 %13, i8* align 8 %14, i32 16, i1 false)
  br label %if.end

if.end:                                           ; preds = %if.then, %for.body
  call void @mulComplex(%struct.Complex* sret align 8 %tmp10, %struct.Complex* byval(%struct.Complex) align 8 %prod, %struct.Complex* byval(%struct.Complex) align 8 @TWO_I)
  %15 = bitcast %struct.Complex* %prod to i8*
  %16 = bitcast %struct.Complex* %tmp10 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 8 %15, i8* align 8 %16, i32 16, i1 false)
  br label %for.inc

for.inc:                                          ; preds = %if.end
  %17 = load i32, i32* %j, align 4
  %inc = add i32 %17, 1
  store i32 %inc, i32* %j, align 4
  br label %for.cond

for.end:                                          ; preds = %for.cond
  %18 = load i32, i32* %pointPos, align 4
  %cmp11 = icmp ne i32 %18, -1
  br i1 %cmp11, label %if.then13, label %if.end34

if.then13:                                        ; preds = %for.end
  %19 = bitcast %struct.Complex* %prod to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 8 %19, i8* align 8 bitcast (%struct.Complex* @INV_TWO_I to i8*), i32 16, i1 false)
  %20 = load i32, i32* %posLen, align 4
  %add = add i32 %20, 1
  store i32 %add, i32* %j, align 4
  br label %for.cond14

for.cond14:                                       ; preds = %for.inc31, %if.then13
  %21 = load i32, i32* %j, align 4
  %22 = load i32, i32* %len, align 4
  %cmp15 = icmp ult i32 %21, %22
  br i1 %cmp15, label %for.body17, label %for.end33

for.body17:                                       ; preds = %for.cond14
  %b2i19 = getelementptr inbounds %struct.QuaterImaginary, %struct.QuaterImaginary* %qi, i32 0, i32 0
  %23 = load i8*, i8** %b2i19, align 4
  %24 = load i32, i32* %j, align 4
  %arrayidx20 = getelementptr inbounds i8, i8* %23, i32 %24
  %25 = load i8, i8* %arrayidx20, align 1
  %conv21 = sext i8 %25 to i32
  %sub22 = sub nsw i32 %conv21, 48
  %conv23 = sitofp i32 %sub22 to double
  store double %conv23, double* %k18, align 8
  %26 = load double, double* %k18, align 8
  %cmp24 = fcmp ogt double %26, 0.000000e+00
  br i1 %cmp24, label %if.then26, label %if.end29

if.then26:                                        ; preds = %for.body17
  %27 = load double, double* %k18, align 8
  call void @mulComplexD(%struct.Complex* sret align 8 %agg.tmp28, %struct.Complex* byval(%struct.Complex) align 8 %prod, double %27)
  call void @addComplex(%struct.Complex* sret align 8 %tmp27, %struct.Complex* byval(%struct.Complex) align 8 %agg.result, %struct.Complex* byval(%struct.Complex) align 8 %agg.tmp28)
  %28 = bitcast %struct.Complex* %agg.result to i8*
  %29 = bitcast %struct.Complex* %tmp27 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 8 %28, i8* align 8 %29, i32 16, i1 false)
  br label %if.end29

if.end29:                                         ; preds = %if.then26, %for.body17
  call void @mulComplex(%struct.Complex* sret align 8 %tmp30, %struct.Complex* byval(%struct.Complex) align 8 %prod, %struct.Complex* byval(%struct.Complex) align 8 @INV_TWO_I)
  %30 = bitcast %struct.Complex* %prod to i8*
  %31 = bitcast %struct.Complex* %tmp30 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 8 %30, i8* align 8 %31, i32 16, i1 false)
  br label %for.inc31

for.inc31:                                        ; preds = %if.end29
  %32 = load i32, i32* %j, align 4
  %inc32 = add i32 %32, 1
  store i32 %inc32, i32* %j, align 4
  br label %for.cond14

for.end33:                                        ; preds = %for.cond14
  br label %if.end34

if.end34:                                         ; preds = %for.end33, %for.end
  ret void
}

; Function Attrs: nounwind readonly
declare i32 @strlen(i8* %0) #2

; Function Attrs: argmemonly nounwind willreturn
declare void @llvm.memcpy.p0i8.p0i8.i32(i8* noalias nocapture writeonly %0, i8* noalias nocapture readonly %1, i32 %2, i1 immarg %3) #3

; Function Attrs: noinline nounwind optnone
define hidden void @c2qi(%struct.QuaterImaginary* noalias sret align 4 %agg.result, %struct.Complex* byval(%struct.Complex) align 8 %c, i8* %out) #0 {
entry:
  %out.addr = alloca i8*, align 4
  %p = alloca i8*, align 4
  %re = alloca i32, align 4
  %im = alloca i32, align 4
  %fi = alloca i32, align 4
  %rem = alloca i32, align 4
  %index = alloca i32, align 4
  %fc = alloca %struct.Complex, align 8
  %.compoundliteral = alloca %struct.Complex, align 8
  %.compoundliteral21 = alloca %struct.Complex, align 8
  %f = alloca double, align 8
  %rem31 = alloca i32, align 4
  %i = alloca i32, align 4
  store i8* %out, i8** %out.addr, align 4
  %0 = load i8*, i8** %out.addr, align 4
  store i8* %0, i8** %p, align 4
  %1 = load i8*, i8** %p, align 4
  store i8 0, i8* %1, align 1
  %rel = getelementptr inbounds %struct.Complex, %struct.Complex* %c, i32 0, i32 0
  %2 = load double, double* %rel, align 8
  %cmp = fcmp oeq double %2, 0.000000e+00
  br i1 %cmp, label %land.lhs.true, label %if.end

land.lhs.true:                                    ; preds = %entry
  %img = getelementptr inbounds %struct.Complex, %struct.Complex* %c, i32 0, i32 1
  %3 = load double, double* %img, align 8
  %cmp1 = fcmp oeq double %3, 0.000000e+00
  br i1 %cmp1, label %if.then, label %if.end

if.then:                                          ; preds = %land.lhs.true
  call void @makeQuaterImaginary(%struct.QuaterImaginary* sret align 4 %agg.result, i8* getelementptr inbounds ([2 x i8], [2 x i8]* @.str.3, i32 0, i32 0))
  br label %return

if.end:                                           ; preds = %land.lhs.true, %entry
  %rel2 = getelementptr inbounds %struct.Complex, %struct.Complex* %c, i32 0, i32 0
  %4 = load double, double* %rel2, align 8
  %conv = fptosi double %4 to i32
  store i32 %conv, i32* %re, align 4
  %img3 = getelementptr inbounds %struct.Complex, %struct.Complex* %c, i32 0, i32 1
  %5 = load double, double* %img3, align 8
  %conv4 = fptosi double %5 to i32
  store i32 %conv4, i32* %im, align 4
  store i32 -1, i32* %fi, align 4
  br label %while.cond

while.cond:                                       ; preds = %if.end11, %if.end
  %6 = load i32, i32* %re, align 4
  %cmp5 = icmp ne i32 %6, 0
  br i1 %cmp5, label %while.body, label %while.end

while.body:                                       ; preds = %while.cond
  %7 = load i32, i32* %re, align 4
  %rem7 = srem i32 %7, -4
  store i32 %rem7, i32* %rem, align 4
  %8 = load i32, i32* %re, align 4
  %div = sdiv i32 %8, -4
  store i32 %div, i32* %re, align 4
  %9 = load i32, i32* %rem, align 4
  %cmp8 = icmp slt i32 %9, 0
  br i1 %cmp8, label %if.then10, label %if.end11

if.then10:                                        ; preds = %while.body
  %10 = load i32, i32* %rem, align 4
  %add = add nsw i32 %10, 4
  store i32 %add, i32* %rem, align 4
  %11 = load i32, i32* %re, align 4
  %inc = add nsw i32 %11, 1
  store i32 %inc, i32* %re, align 4
  br label %if.end11

if.end11:                                         ; preds = %if.then10, %while.body
  %12 = load i32, i32* %rem, align 4
  %add12 = add nsw i32 %12, 48
  %conv13 = trunc i32 %add12 to i8
  %13 = load i8*, i8** %p, align 4
  %incdec.ptr = getelementptr inbounds i8, i8* %13, i32 1
  store i8* %incdec.ptr, i8** %p, align 4
  store i8 %conv13, i8* %13, align 1
  %14 = load i8*, i8** %p, align 4
  %incdec.ptr14 = getelementptr inbounds i8, i8* %14, i32 1
  store i8* %incdec.ptr14, i8** %p, align 4
  store i8 48, i8* %14, align 1
  %15 = load i8*, i8** %p, align 4
  store i8 0, i8* %15, align 1
  br label %while.cond

while.end:                                        ; preds = %while.cond
  %16 = load i32, i32* %im, align 4
  %cmp15 = icmp ne i32 %16, 0
  br i1 %cmp15, label %if.then17, label %if.end53

if.then17:                                        ; preds = %while.end
  store i32 1, i32* %index, align 4
  %rel18 = getelementptr inbounds %struct.Complex, %struct.Complex* %.compoundliteral, i32 0, i32 0
  store double 0.000000e+00, double* %rel18, align 8
  %img19 = getelementptr inbounds %struct.Complex, %struct.Complex* %.compoundliteral, i32 0, i32 1
  %img20 = getelementptr inbounds %struct.Complex, %struct.Complex* %c, i32 0, i32 1
  %17 = load double, double* %img20, align 8
  store double %17, double* %img19, align 8
  %rel22 = getelementptr inbounds %struct.Complex, %struct.Complex* %.compoundliteral21, i32 0, i32 0
  store double 0.000000e+00, double* %rel22, align 8
  %img23 = getelementptr inbounds %struct.Complex, %struct.Complex* %.compoundliteral21, i32 0, i32 1
  store double 2.000000e+00, double* %img23, align 8
  call void @divComplex(%struct.Complex* sret align 8 %fc, %struct.Complex* byval(%struct.Complex) align 8 %.compoundliteral, %struct.Complex* byval(%struct.Complex) align 8 %.compoundliteral21)
  %rel24 = getelementptr inbounds %struct.Complex, %struct.Complex* %fc, i32 0, i32 0
  %18 = load double, double* %rel24, align 8
  store double %18, double* %f, align 8
  %19 = load double, double* %f, align 8
  %20 = call double @llvm.ceil.f64(double %19)
  %conv25 = fptosi double %20 to i32
  store i32 %conv25, i32* %im, align 4
  %21 = load double, double* %f, align 8
  %22 = load i32, i32* %im, align 4
  %conv26 = sitofp i32 %22 to double
  %sub = fsub double %21, %conv26
  %mul = fmul double -4.000000e+00, %sub
  store double %mul, double* %f, align 8
  br label %while.cond27

while.cond27:                                     ; preds = %if.end49, %if.then17
  %23 = load i32, i32* %im, align 4
  %cmp28 = icmp ne i32 %23, 0
  br i1 %cmp28, label %while.body30, label %while.end51

while.body30:                                     ; preds = %while.cond27
  %24 = load i32, i32* %im, align 4
  %rem32 = srem i32 %24, -4
  store i32 %rem32, i32* %rem31, align 4
  %25 = load i32, i32* %im, align 4
  %div33 = sdiv i32 %25, -4
  store i32 %div33, i32* %im, align 4
  %26 = load i32, i32* %rem31, align 4
  %cmp34 = icmp slt i32 %26, 0
  br i1 %cmp34, label %if.then36, label %if.end39

if.then36:                                        ; preds = %while.body30
  %27 = load i32, i32* %rem31, align 4
  %add37 = add nsw i32 %27, 4
  store i32 %add37, i32* %rem31, align 4
  %28 = load i32, i32* %im, align 4
  %inc38 = add nsw i32 %28, 1
  store i32 %inc38, i32* %im, align 4
  br label %if.end39

if.end39:                                         ; preds = %if.then36, %while.body30
  %29 = load i32, i32* %index, align 4
  %30 = load i8*, i8** %p, align 4
  %31 = load i8*, i8** %out.addr, align 4
  %sub.ptr.lhs.cast = ptrtoint i8* %30 to i32
  %sub.ptr.rhs.cast = ptrtoint i8* %31 to i32
  %sub.ptr.sub = sub i32 %sub.ptr.lhs.cast, %sub.ptr.rhs.cast
  %cmp40 = icmp ult i32 %29, %sub.ptr.sub
  br i1 %cmp40, label %if.then42, label %if.else

if.then42:                                        ; preds = %if.end39
  %32 = load i32, i32* %rem31, align 4
  %add43 = add nsw i32 %32, 48
  %conv44 = trunc i32 %add43 to i8
  %33 = load i8*, i8** %out.addr, align 4
  %34 = load i32, i32* %index, align 4
  %arrayidx = getelementptr inbounds i8, i8* %33, i32 %34
  store i8 %conv44, i8* %arrayidx, align 1
  br label %if.end49

if.else:                                          ; preds = %if.end39
  %35 = load i8*, i8** %p, align 4
  %incdec.ptr45 = getelementptr inbounds i8, i8* %35, i32 1
  store i8* %incdec.ptr45, i8** %p, align 4
  store i8 48, i8* %35, align 1
  %36 = load i32, i32* %rem31, align 4
  %add46 = add nsw i32 %36, 48
  %conv47 = trunc i32 %add46 to i8
  %37 = load i8*, i8** %p, align 4
  %incdec.ptr48 = getelementptr inbounds i8, i8* %37, i32 1
  store i8* %incdec.ptr48, i8** %p, align 4
  store i8 %conv47, i8* %37, align 1
  %38 = load i8*, i8** %p, align 4
  store i8 0, i8* %38, align 1
  br label %if.end49

if.end49:                                         ; preds = %if.else, %if.then42
  %39 = load i32, i32* %index, align 4
  %add50 = add i32 %39, 2
  store i32 %add50, i32* %index, align 4
  br label %while.cond27

while.end51:                                      ; preds = %while.cond27
  %40 = load double, double* %f, align 8
  %conv52 = fptosi double %40 to i32
  store i32 %conv52, i32* %fi, align 4
  br label %if.end53

if.end53:                                         ; preds = %while.end51, %while.end
  %41 = load i8*, i8** %out.addr, align 4
  %42 = load i8*, i8** %p, align 4
  call void @reverse(i8* %41, i8* %42)
  %43 = load i32, i32* %fi, align 4
  %cmp54 = icmp ne i32 %43, -1
  br i1 %cmp54, label %if.then56, label %if.end61

if.then56:                                        ; preds = %if.end53
  %44 = load i8*, i8** %p, align 4
  %incdec.ptr57 = getelementptr inbounds i8, i8* %44, i32 1
  store i8* %incdec.ptr57, i8** %p, align 4
  store i8 46, i8* %44, align 1
  %45 = load i32, i32* %fi, align 4
  %add58 = add nsw i32 %45, 48
  %conv59 = trunc i32 %add58 to i8
  %46 = load i8*, i8** %p, align 4
  %incdec.ptr60 = getelementptr inbounds i8, i8* %46, i32 1
  store i8* %incdec.ptr60, i8** %p, align 4
  store i8 %conv59, i8* %46, align 1
  %47 = load i8*, i8** %p, align 4
  store i8 0, i8* %47, align 1
  br label %if.end61

if.end61:                                         ; preds = %if.then56, %if.end53
  br label %while.cond62

while.cond62:                                     ; preds = %for.end, %if.end61
  %48 = load i8*, i8** %out.addr, align 4
  %arrayidx63 = getelementptr inbounds i8, i8* %48, i32 0
  %49 = load i8, i8* %arrayidx63, align 1
  %conv64 = sext i8 %49 to i32
  %cmp65 = icmp eq i32 %conv64, 48
  br i1 %cmp65, label %land.rhs, label %land.end

land.rhs:                                         ; preds = %while.cond62
  %50 = load i8*, i8** %out.addr, align 4
  %arrayidx67 = getelementptr inbounds i8, i8* %50, i32 1
  %51 = load i8, i8* %arrayidx67, align 1
  %conv68 = sext i8 %51 to i32
  %cmp69 = icmp ne i32 %conv68, 46
  br label %land.end

land.end:                                         ; preds = %land.rhs, %while.cond62
  %52 = phi i1 [ false, %while.cond62 ], [ %cmp69, %land.rhs ]
  br i1 %52, label %while.body71, label %while.end80

while.body71:                                     ; preds = %land.end
  store i32 0, i32* %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %while.body71
  %53 = load i8*, i8** %out.addr, align 4
  %54 = load i32, i32* %i, align 4
  %arrayidx72 = getelementptr inbounds i8, i8* %53, i32 %54
  %55 = load i8, i8* %arrayidx72, align 1
  %conv73 = sext i8 %55 to i32
  %cmp74 = icmp ne i32 %conv73, 0
  br i1 %cmp74, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %56 = load i8*, i8** %out.addr, align 4
  %57 = load i32, i32* %i, align 4
  %add76 = add i32 %57, 1
  %arrayidx77 = getelementptr inbounds i8, i8* %56, i32 %add76
  %58 = load i8, i8* %arrayidx77, align 1
  %59 = load i8*, i8** %out.addr, align 4
  %60 = load i32, i32* %i, align 4
  %arrayidx78 = getelementptr inbounds i8, i8* %59, i32 %60
  store i8 %58, i8* %arrayidx78, align 1
  br label %for.inc

for.inc:                                          ; preds = %for.body
  %61 = load i32, i32* %i, align 4
  %inc79 = add i32 %61, 1
  store i32 %inc79, i32* %i, align 4
  br label %for.cond

for.end:                                          ; preds = %for.cond
  br label %while.cond62

while.end80:                                      ; preds = %land.end
  %62 = load i8*, i8** %out.addr, align 4
  %63 = load i8, i8* %62, align 1
  %conv81 = sext i8 %63 to i32
  %cmp82 = icmp eq i32 %conv81, 46
  br i1 %cmp82, label %if.then84, label %if.end86

if.then84:                                        ; preds = %while.end80
  %64 = load i8*, i8** %out.addr, align 4
  %65 = load i8*, i8** %p, align 4
  call void @reverse(i8* %64, i8* %65)
  %66 = load i8*, i8** %p, align 4
  %incdec.ptr85 = getelementptr inbounds i8, i8* %66, i32 1
  store i8* %incdec.ptr85, i8** %p, align 4
  store i8 48, i8* %66, align 1
  %67 = load i8*, i8** %p, align 4
  store i8 0, i8* %67, align 1
  %68 = load i8*, i8** %out.addr, align 4
  %69 = load i8*, i8** %p, align 4
  call void @reverse(i8* %68, i8* %69)
  br label %if.end86

if.end86:                                         ; preds = %if.then84, %while.end80
  %70 = load i8*, i8** %out.addr, align 4
  call void @makeQuaterImaginary(%struct.QuaterImaginary* sret align 4 %agg.result, i8* %70)
  br label %return

return:                                           ; preds = %if.end86, %if.then
  ret void
}

; Function Attrs: nounwind readnone speculatable willreturn
declare double @llvm.ceil.f64(double %0) #4

; Function Attrs: noinline nounwind optnone
define hidden i32 @main() #0 {
entry:
  %retval = alloca i32, align 4
  %buffer = alloca [16 x i8], align 16
  %i = alloca i32, align 4
  %c1 = alloca %struct.Complex, align 8
  %qi = alloca %struct.QuaterImaginary, align 4
  %c2 = alloca %struct.Complex, align 8
  %tmp = alloca %struct.Complex, align 8
  %tmp3 = alloca %struct.QuaterImaginary, align 4
  %tmp5 = alloca %struct.Complex, align 8
  %c114 = alloca %struct.Complex, align 8
  %qi18 = alloca %struct.QuaterImaginary, align 4
  %c220 = alloca %struct.Complex, align 8
  %tmp24 = alloca %struct.Complex, align 8
  %tmp25 = alloca %struct.QuaterImaginary, align 4
  %tmp27 = alloca %struct.Complex, align 8
  store i32 0, i32* %retval, align 4
  store i32 1, i32* %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %0 = load i32, i32* %i, align 4
  %cmp = icmp sle i32 %0, 16
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %rel = getelementptr inbounds %struct.Complex, %struct.Complex* %c1, i32 0, i32 0
  %1 = load i32, i32* %i, align 4
  %conv = sitofp i32 %1 to double
  store double %conv, double* %rel, align 8
  %img = getelementptr inbounds %struct.Complex, %struct.Complex* %c1, i32 0, i32 1
  store double 0.000000e+00, double* %img, align 8
  %arraydecay = getelementptr inbounds [16 x i8], [16 x i8]* %buffer, i32 0, i32 0
  call void @c2qi(%struct.QuaterImaginary* sret align 4 %qi, %struct.Complex* byval(%struct.Complex) align 8 %c1, i8* %arraydecay)
  call void @qi2c(%struct.Complex* sret align 8 %c2, %struct.QuaterImaginary* byval(%struct.QuaterImaginary) align 4 %qi)
  call void @printComplex(%struct.Complex* byval(%struct.Complex) align 8 %c1)
  %call = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.4, i32 0, i32 0))
  call void @printQuaterImaginary(%struct.QuaterImaginary* byval(%struct.QuaterImaginary) align 4 %qi)
  %call1 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.4, i32 0, i32 0))
  call void @printComplex(%struct.Complex* byval(%struct.Complex) align 8 %c2)
  %call2 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([6 x i8], [6 x i8]* @.str.5, i32 0, i32 0))
  call void @negComplex(%struct.Complex* sret align 8 %tmp, %struct.Complex* byval(%struct.Complex) align 8 %c1)
  %2 = bitcast %struct.Complex* %c1 to i8*
  %3 = bitcast %struct.Complex* %tmp to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 8 %2, i8* align 8 %3, i32 16, i1 false)
  %arraydecay4 = getelementptr inbounds [16 x i8], [16 x i8]* %buffer, i32 0, i32 0
  call void @c2qi(%struct.QuaterImaginary* sret align 4 %tmp3, %struct.Complex* byval(%struct.Complex) align 8 %c1, i8* %arraydecay4)
  %4 = bitcast %struct.QuaterImaginary* %qi to i8*
  %5 = bitcast %struct.QuaterImaginary* %tmp3 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 4 %4, i8* align 4 %5, i32 8, i1 false)
  call void @qi2c(%struct.Complex* sret align 8 %tmp5, %struct.QuaterImaginary* byval(%struct.QuaterImaginary) align 4 %qi)
  %6 = bitcast %struct.Complex* %c2 to i8*
  %7 = bitcast %struct.Complex* %tmp5 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 8 %6, i8* align 8 %7, i32 16, i1 false)
  call void @printComplex(%struct.Complex* byval(%struct.Complex) align 8 %c1)
  %call6 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.4, i32 0, i32 0))
  call void @printQuaterImaginary(%struct.QuaterImaginary* byval(%struct.QuaterImaginary) align 4 %qi)
  %call7 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.4, i32 0, i32 0))
  call void @printComplex(%struct.Complex* byval(%struct.Complex) align 8 %c2)
  %call8 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([2 x i8], [2 x i8]* @.str.6, i32 0, i32 0))
  br label %for.inc

for.inc:                                          ; preds = %for.body
  %8 = load i32, i32* %i, align 4
  %inc = add nsw i32 %8, 1
  store i32 %inc, i32* %i, align 4
  br label %for.cond

for.end:                                          ; preds = %for.cond
  %call9 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([2 x i8], [2 x i8]* @.str.6, i32 0, i32 0))
  store i32 1, i32* %i, align 4
  br label %for.cond10

for.cond10:                                       ; preds = %for.inc31, %for.end
  %9 = load i32, i32* %i, align 4
  %cmp11 = icmp sle i32 %9, 16
  br i1 %cmp11, label %for.body13, label %for.end33

for.body13:                                       ; preds = %for.cond10
  %rel15 = getelementptr inbounds %struct.Complex, %struct.Complex* %c114, i32 0, i32 0
  store double 0.000000e+00, double* %rel15, align 8
  %img16 = getelementptr inbounds %struct.Complex, %struct.Complex* %c114, i32 0, i32 1
  %10 = load i32, i32* %i, align 4
  %conv17 = sitofp i32 %10 to double
  store double %conv17, double* %img16, align 8
  %arraydecay19 = getelementptr inbounds [16 x i8], [16 x i8]* %buffer, i32 0, i32 0
  call void @c2qi(%struct.QuaterImaginary* sret align 4 %qi18, %struct.Complex* byval(%struct.Complex) align 8 %c114, i8* %arraydecay19)
  call void @qi2c(%struct.Complex* sret align 8 %c220, %struct.QuaterImaginary* byval(%struct.QuaterImaginary) align 4 %qi18)
  call void @printComplex(%struct.Complex* byval(%struct.Complex) align 8 %c114)
  %call21 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.4, i32 0, i32 0))
  call void @printQuaterImaginary(%struct.QuaterImaginary* byval(%struct.QuaterImaginary) align 4 %qi18)
  %call22 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.4, i32 0, i32 0))
  call void @printComplex(%struct.Complex* byval(%struct.Complex) align 8 %c220)
  %call23 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([6 x i8], [6 x i8]* @.str.5, i32 0, i32 0))
  call void @negComplex(%struct.Complex* sret align 8 %tmp24, %struct.Complex* byval(%struct.Complex) align 8 %c114)
  %11 = bitcast %struct.Complex* %c114 to i8*
  %12 = bitcast %struct.Complex* %tmp24 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 8 %11, i8* align 8 %12, i32 16, i1 false)
  %arraydecay26 = getelementptr inbounds [16 x i8], [16 x i8]* %buffer, i32 0, i32 0
  call void @c2qi(%struct.QuaterImaginary* sret align 4 %tmp25, %struct.Complex* byval(%struct.Complex) align 8 %c114, i8* %arraydecay26)
  %13 = bitcast %struct.QuaterImaginary* %qi18 to i8*
  %14 = bitcast %struct.QuaterImaginary* %tmp25 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 4 %13, i8* align 4 %14, i32 8, i1 false)
  call void @qi2c(%struct.Complex* sret align 8 %tmp27, %struct.QuaterImaginary* byval(%struct.QuaterImaginary) align 4 %qi18)
  %15 = bitcast %struct.Complex* %c220 to i8*
  %16 = bitcast %struct.Complex* %tmp27 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 8 %15, i8* align 8 %16, i32 16, i1 false)
  call void @printComplex(%struct.Complex* byval(%struct.Complex) align 8 %c114)
  %call28 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.4, i32 0, i32 0))
  call void @printQuaterImaginary(%struct.QuaterImaginary* byval(%struct.QuaterImaginary) align 4 %qi18)
  %call29 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.4, i32 0, i32 0))
  call void @printComplex(%struct.Complex* byval(%struct.Complex) align 8 %c220)
  %call30 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([2 x i8], [2 x i8]* @.str.6, i32 0, i32 0))
  br label %for.inc31

for.inc31:                                        ; preds = %for.body13
  %17 = load i32, i32* %i, align 4
  %inc32 = add nsw i32 %17, 1
  store i32 %inc32, i32* %i, align 4
  br label %for.cond10

for.end33:                                        ; preds = %for.cond10
  ret i32 0
}

attributes #0 = { noinline nounwind optnone "correctly-rounded-divide-sqrt-fp-math"="false" "disable-tail-calls"="false" "frame-pointer"="none" "less-precise-fpmad"="false" "min-legal-vector-width"="0" "no-infs-fp-math"="false" "no-jump-tables"="false" "no-nans-fp-math"="false" "no-signed-zeros-fp-math"="false" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="generic" "unsafe-fp-math"="false" "use-soft-float"="false" }
attributes #1 = { "correctly-rounded-divide-sqrt-fp-math"="false" "disable-tail-calls"="false" "frame-pointer"="none" "less-precise-fpmad"="false" "no-infs-fp-math"="false" "no-nans-fp-math"="false" "no-signed-zeros-fp-math"="false" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="generic" "unsafe-fp-math"="false" "use-soft-float"="false" }
attributes #2 = { nounwind readonly "correctly-rounded-divide-sqrt-fp-math"="false" "disable-tail-calls"="false" "frame-pointer"="none" "less-precise-fpmad"="false" "no-infs-fp-math"="false" "no-nans-fp-math"="false" "no-signed-zeros-fp-math"="false" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="generic" "unsafe-fp-math"="false" "use-soft-float"="false" }
attributes #3 = { argmemonly nounwind willreturn }
attributes #4 = { nounwind readnone speculatable willreturn }
attributes #5 = { nounwind readonly }

!llvm.module.flags = !{!0}
!llvm.ident = !{!1}

!0 = !{i32 1, !"wchar_size", i32 4}
!1 = !{!"clang version 11.0.0 (https://github.com/Jacarte/llvm-project.git 0f6dea67136cc1e0b3d200eb2bb165628970c44b)"}

; extracted candidates
#########################################################
; exiting Souper's runOnFunction() for inv()

; entering Souper's runOnFunction() for makeQuaterImaginary()

; ModuleID = './Imaginary_base_numbers.c.bc'
source_filename = "./Imaginary_base_numbers.c"
target datalayout = "e-m:e-p:32:32-i64:64-n32:64-S128"
target triple = "wasm32-unknown-wasi"

%struct.Complex = type { double, double }
%struct.QuaterImaginary = type { i8*, i32 }

@.str = private unnamed_addr constant [17 x i8] c"(%3.0f + %3.0fi)\00", align 1
@TWO_I = hidden constant %struct.Complex { double 0.000000e+00, double 2.000000e+00 }, align 8
@INV_TWO_I = hidden constant %struct.Complex { double 0.000000e+00, double -5.000000e-01 }, align 8
@.str.1 = private unnamed_addr constant [4 x i8] c"%8s\00", align 1
@.str.2 = private unnamed_addr constant [9 x i8] c" ERROR  \00", align 1
@.str.3 = private unnamed_addr constant [2 x i8] c"0\00", align 1
@.str.4 = private unnamed_addr constant [5 x i8] c" -> \00", align 1
@.str.5 = private unnamed_addr constant [6 x i8] c"     \00", align 1
@.str.6 = private unnamed_addr constant [2 x i8] c"\0A\00", align 1
@llvm.used = appending global [1 x i8*] [i8* bitcast (i32 ()* @__main_void to i8*)], section "llvm.metadata"

@__main_void = alias i32 (), i32 ()* @main

; Function Attrs: noinline nounwind optnone
define hidden i32 @find(i8* %s, i8 signext %c) #0 {
entry:
  %retval = alloca i32, align 4
  %s.addr = alloca i8*, align 4
  %c.addr = alloca i8, align 1
  %i = alloca i8*, align 4
  store i8* %s, i8** %s.addr, align 4
  store i8 %c, i8* %c.addr, align 1
  %0 = load i8*, i8** %s.addr, align 4
  store i8* %0, i8** %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %1 = load i8*, i8** %i, align 4
  %2 = load i8, i8* %1, align 1
  %conv = sext i8 %2 to i32
  %cmp = icmp ne i32 %conv, 0
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %3 = load i8*, i8** %i, align 4
  %4 = load i8, i8* %3, align 1
  %conv2 = sext i8 %4 to i32
  %5 = load i8, i8* %c.addr, align 1
  %conv3 = sext i8 %5 to i32
  %cmp4 = icmp eq i32 %conv2, %conv3
  br i1 %cmp4, label %if.then, label %if.end

if.then:                                          ; preds = %for.body
  %6 = load i8*, i8** %i, align 4
  %7 = load i8*, i8** %s.addr, align 4
  %sub.ptr.lhs.cast = ptrtoint i8* %6 to i32
  %sub.ptr.rhs.cast = ptrtoint i8* %7 to i32
  %sub.ptr.sub = sub i32 %sub.ptr.lhs.cast, %sub.ptr.rhs.cast
  store i32 %sub.ptr.sub, i32* %retval, align 4
  br label %return

if.end:                                           ; preds = %for.body
  br label %for.inc

for.inc:                                          ; preds = %if.end
  %8 = load i8*, i8** %i, align 4
  %incdec.ptr = getelementptr inbounds i8, i8* %8, i32 1
  store i8* %incdec.ptr, i8** %i, align 4
  br label %for.cond

for.end:                                          ; preds = %for.cond
  store i32 -1, i32* %retval, align 4
  br label %return

return:                                           ; preds = %for.end, %if.then
  %9 = load i32, i32* %retval, align 4
  ret i32 %9
}

; Function Attrs: noinline nounwind optnone
define hidden void @reverse(i8* %b, i8* %e) #0 {
entry:
  %b.addr = alloca i8*, align 4
  %e.addr = alloca i8*, align 4
  %t = alloca i8, align 1
  store i8* %b, i8** %b.addr, align 4
  store i8* %e, i8** %e.addr, align 4
  %0 = load i8*, i8** %e.addr, align 4
  %incdec.ptr = getelementptr inbounds i8, i8* %0, i32 -1
  store i8* %incdec.ptr, i8** %e.addr, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %1 = load i8*, i8** %b.addr, align 4
  %2 = load i8*, i8** %e.addr, align 4
  %cmp = icmp ult i8* %1, %2
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %3 = load i8*, i8** %b.addr, align 4
  %4 = load i8, i8* %3, align 1
  store i8 %4, i8* %t, align 1
  %5 = load i8*, i8** %e.addr, align 4
  %6 = load i8, i8* %5, align 1
  %7 = load i8*, i8** %b.addr, align 4
  store i8 %6, i8* %7, align 1
  %8 = load i8, i8* %t, align 1
  %9 = load i8*, i8** %e.addr, align 4
  store i8 %8, i8* %9, align 1
  br label %for.inc

for.inc:                                          ; preds = %for.body
  %10 = load i8*, i8** %b.addr, align 4
  %incdec.ptr1 = getelementptr inbounds i8, i8* %10, i32 1
  store i8* %incdec.ptr1, i8** %b.addr, align 4
  %11 = load i8*, i8** %e.addr, align 4
  %incdec.ptr2 = getelementptr inbounds i8, i8* %11, i32 -1
  store i8* %incdec.ptr2, i8** %e.addr, align 4
  br label %for.cond

for.end:                                          ; preds = %for.cond
  ret void
}

; Function Attrs: noinline nounwind optnone
define hidden void @printComplex(%struct.Complex* byval(%struct.Complex) align 8 %c) #0 {
entry:
  %rel = getelementptr inbounds %struct.Complex, %struct.Complex* %c, i32 0, i32 0
  %0 = load double, double* %rel, align 8
  %img = getelementptr inbounds %struct.Complex, %struct.Complex* %c, i32 0, i32 1
  %1 = load double, double* %img, align 8
  %call = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([17 x i8], [17 x i8]* @.str, i32 0, i32 0), double %0, double %1)
  ret void
}

declare i32 @printf(i8* %0, ...) #1

; Function Attrs: noinline nounwind optnone
define hidden void @makeComplex(%struct.Complex* noalias sret align 8 %agg.result, double %rel, double %img) #0 {
entry:
  %rel.addr = alloca double, align 8
  %img.addr = alloca double, align 8
  store double %rel, double* %rel.addr, align 8
  store double %img, double* %img.addr, align 8
  %rel1 = getelementptr inbounds %struct.Complex, %struct.Complex* %agg.result, i32 0, i32 0
  %0 = load double, double* %rel.addr, align 8
  store double %0, double* %rel1, align 8
  %img2 = getelementptr inbounds %struct.Complex, %struct.Complex* %agg.result, i32 0, i32 1
  %1 = load double, double* %img.addr, align 8
  store double %1, double* %img2, align 8
  ret void
}

; Function Attrs: noinline nounwind optnone
define hidden void @addComplex(%struct.Complex* noalias sret align 8 %agg.result, %struct.Complex* byval(%struct.Complex) align 8 %a, %struct.Complex* byval(%struct.Complex) align 8 %b) #0 {
entry:
  %rel = getelementptr inbounds %struct.Complex, %struct.Complex* %agg.result, i32 0, i32 0
  %rel1 = getelementptr inbounds %struct.Complex, %struct.Complex* %a, i32 0, i32 0
  %0 = load double, double* %rel1, align 8
  %rel2 = getelementptr inbounds %struct.Complex, %struct.Complex* %b, i32 0, i32 0
  %1 = load double, double* %rel2, align 8
  %add = fadd double %0, %1
  store double %add, double* %rel, align 8
  %img = getelementptr inbounds %struct.Complex, %struct.Complex* %agg.result, i32 0, i32 1
  %img3 = getelementptr inbounds %struct.Complex, %struct.Complex* %a, i32 0, i32 1
  %2 = load double, double* %img3, align 8
  %img4 = getelementptr inbounds %struct.Complex, %struct.Complex* %b, i32 0, i32 1
  %3 = load double, double* %img4, align 8
  %add5 = fadd double %2, %3
  store double %add5, double* %img, align 8
  ret void
}

; Function Attrs: noinline nounwind optnone
define hidden void @mulComplex(%struct.Complex* noalias sret align 8 %agg.result, %struct.Complex* byval(%struct.Complex) align 8 %a, %struct.Complex* byval(%struct.Complex) align 8 %b) #0 {
entry:
  %rel = getelementptr inbounds %struct.Complex, %struct.Complex* %agg.result, i32 0, i32 0
  %rel1 = getelementptr inbounds %struct.Complex, %struct.Complex* %a, i32 0, i32 0
  %0 = load double, double* %rel1, align 8
  %rel2 = getelementptr inbounds %struct.Complex, %struct.Complex* %b, i32 0, i32 0
  %1 = load double, double* %rel2, align 8
  %mul = fmul double %0, %1
  %img = getelementptr inbounds %struct.Complex, %struct.Complex* %a, i32 0, i32 1
  %2 = load double, double* %img, align 8
  %img3 = getelementptr inbounds %struct.Complex, %struct.Complex* %b, i32 0, i32 1
  %3 = load double, double* %img3, align 8
  %mul4 = fmul double %2, %3
  %sub = fsub double %mul, %mul4
  store double %sub, double* %rel, align 8
  %img5 = getelementptr inbounds %struct.Complex, %struct.Complex* %agg.result, i32 0, i32 1
  %rel6 = getelementptr inbounds %struct.Complex, %struct.Complex* %a, i32 0, i32 0
  %4 = load double, double* %rel6, align 8
  %img7 = getelementptr inbounds %struct.Complex, %struct.Complex* %b, i32 0, i32 1
  %5 = load double, double* %img7, align 8
  %mul8 = fmul double %4, %5
  %img9 = getelementptr inbounds %struct.Complex, %struct.Complex* %a, i32 0, i32 1
  %6 = load double, double* %img9, align 8
  %rel10 = getelementptr inbounds %struct.Complex, %struct.Complex* %b, i32 0, i32 0
  %7 = load double, double* %rel10, align 8
  %mul11 = fmul double %6, %7
  %sub12 = fsub double %mul8, %mul11
  store double %sub12, double* %img5, align 8
  ret void
}

; Function Attrs: noinline nounwind optnone
define hidden void @mulComplexD(%struct.Complex* noalias sret align 8 %agg.result, %struct.Complex* byval(%struct.Complex) align 8 %a, double %b) #0 {
entry:
  %b.addr = alloca double, align 8
  store double %b, double* %b.addr, align 8
  %rel = getelementptr inbounds %struct.Complex, %struct.Complex* %agg.result, i32 0, i32 0
  %rel1 = getelementptr inbounds %struct.Complex, %struct.Complex* %a, i32 0, i32 0
  %0 = load double, double* %rel1, align 8
  %1 = load double, double* %b.addr, align 8
  %mul = fmul double %0, %1
  store double %mul, double* %rel, align 8
  %img = getelementptr inbounds %struct.Complex, %struct.Complex* %agg.result, i32 0, i32 1
  %img2 = getelementptr inbounds %struct.Complex, %struct.Complex* %a, i32 0, i32 1
  %2 = load double, double* %img2, align 8
  %3 = load double, double* %b.addr, align 8
  %mul3 = fmul double %2, %3
  store double %mul3, double* %img, align 8
  ret void
}

; Function Attrs: noinline nounwind optnone
define hidden void @negComplex(%struct.Complex* noalias sret align 8 %agg.result, %struct.Complex* byval(%struct.Complex) align 8 %a) #0 {
entry:
  call void @mulComplexD(%struct.Complex* sret align 8 %agg.result, %struct.Complex* byval(%struct.Complex) align 8 %a, double -1.000000e+00)
  ret void
}

; Function Attrs: noinline nounwind optnone
define hidden void @divComplex(%struct.Complex* noalias sret align 8 %agg.result, %struct.Complex* byval(%struct.Complex) align 8 %a, %struct.Complex* byval(%struct.Complex) align 8 %b) #0 {
entry:
  %re = alloca double, align 8
  %im = alloca double, align 8
  %d = alloca double, align 8
  %rel = getelementptr inbounds %struct.Complex, %struct.Complex* %a, i32 0, i32 0
  %0 = load double, double* %rel, align 8
  %rel1 = getelementptr inbounds %struct.Complex, %struct.Complex* %b, i32 0, i32 0
  %1 = load double, double* %rel1, align 8
  %mul = fmul double %0, %1
  %img = getelementptr inbounds %struct.Complex, %struct.Complex* %a, i32 0, i32 1
  %2 = load double, double* %img, align 8
  %img2 = getelementptr inbounds %struct.Complex, %struct.Complex* %b, i32 0, i32 1
  %3 = load double, double* %img2, align 8
  %mul3 = fmul double %2, %3
  %add = fadd double %mul, %mul3
  store double %add, double* %re, align 8
  %img4 = getelementptr inbounds %struct.Complex, %struct.Complex* %a, i32 0, i32 1
  %4 = load double, double* %img4, align 8
  %rel5 = getelementptr inbounds %struct.Complex, %struct.Complex* %b, i32 0, i32 0
  %5 = load double, double* %rel5, align 8
  %mul6 = fmul double %4, %5
  %rel7 = getelementptr inbounds %struct.Complex, %struct.Complex* %a, i32 0, i32 0
  %6 = load double, double* %rel7, align 8
  %img8 = getelementptr inbounds %struct.Complex, %struct.Complex* %b, i32 0, i32 1
  %7 = load double, double* %img8, align 8
  %mul9 = fmul double %6, %7
  %sub = fsub double %mul6, %mul9
  store double %sub, double* %im, align 8
  %rel10 = getelementptr inbounds %struct.Complex, %struct.Complex* %b, i32 0, i32 0
  %8 = load double, double* %rel10, align 8
  %rel11 = getelementptr inbounds %struct.Complex, %struct.Complex* %b, i32 0, i32 0
  %9 = load double, double* %rel11, align 8
  %mul12 = fmul double %8, %9
  %img13 = getelementptr inbounds %struct.Complex, %struct.Complex* %b, i32 0, i32 1
  %10 = load double, double* %img13, align 8
  %img14 = getelementptr inbounds %struct.Complex, %struct.Complex* %b, i32 0, i32 1
  %11 = load double, double* %img14, align 8
  %mul15 = fmul double %10, %11
  %add16 = fadd double %mul12, %mul15
  store double %add16, double* %d, align 8
  %rel17 = getelementptr inbounds %struct.Complex, %struct.Complex* %agg.result, i32 0, i32 0
  %12 = load double, double* %re, align 8
  %13 = load double, double* %d, align 8
  %div = fdiv double %12, %13
  store double %div, double* %rel17, align 8
  %img18 = getelementptr inbounds %struct.Complex, %struct.Complex* %agg.result, i32 0, i32 1
  %14 = load double, double* %im, align 8
  %15 = load double, double* %d, align 8
  %div19 = fdiv double %14, %15
  store double %div19, double* %img18, align 8
  ret void
}

; Function Attrs: noinline nounwind optnone
define hidden void @inv(%struct.Complex* noalias sret align 8 %agg.result, %struct.Complex* byval(%struct.Complex) align 8 %c) #0 {
entry:
  %d = alloca double, align 8
  %rel = getelementptr inbounds %struct.Complex, %struct.Complex* %c, i32 0, i32 0
  %0 = load double, double* %rel, align 8
  %rel1 = getelementptr inbounds %struct.Complex, %struct.Complex* %c, i32 0, i32 0
  %1 = load double, double* %rel1, align 8
  %mul = fmul double %0, %1
  %img = getelementptr inbounds %struct.Complex, %struct.Complex* %c, i32 0, i32 1
  %2 = load double, double* %img, align 8
  %img2 = getelementptr inbounds %struct.Complex, %struct.Complex* %c, i32 0, i32 1
  %3 = load double, double* %img2, align 8
  %mul3 = fmul double %2, %3
  %add = fadd double %mul, %mul3
  store double %add, double* %d, align 8
  %rel4 = getelementptr inbounds %struct.Complex, %struct.Complex* %agg.result, i32 0, i32 0
  %rel5 = getelementptr inbounds %struct.Complex, %struct.Complex* %c, i32 0, i32 0
  %4 = load double, double* %rel5, align 8
  %5 = load double, double* %d, align 8
  %div = fdiv double %4, %5
  store double %div, double* %rel4, align 8
  %img6 = getelementptr inbounds %struct.Complex, %struct.Complex* %agg.result, i32 0, i32 1
  %img7 = getelementptr inbounds %struct.Complex, %struct.Complex* %c, i32 0, i32 1
  %6 = load double, double* %img7, align 8
  %fneg = fneg double %6
  %7 = load double, double* %d, align 8
  %div8 = fdiv double %fneg, %7
  store double %div8, double* %img6, align 8
  ret void
}

; Function Attrs: noinline nounwind optnone
define hidden void @makeQuaterImaginary(%struct.QuaterImaginary* noalias sret align 4 %agg.result, i8* %s) #0 {
entry:
  %s.addr = alloca i8*, align 4
  %i = alloca i32, align 4
  %valid1 = alloca i32, align 4
  %cnt = alloca i32, align 4
  store i8* %s, i8** %s.addr, align 4
  %b2i = getelementptr inbounds %struct.QuaterImaginary, %struct.QuaterImaginary* %agg.result, i32 0, i32 0
  %0 = load i8*, i8** %s.addr, align 4
  store i8* %0, i8** %b2i, align 4
  %valid = getelementptr inbounds %struct.QuaterImaginary, %struct.QuaterImaginary* %agg.result, i32 0, i32 1
  store i32 0, i32* %valid, align 4
  store i32 1, i32* %valid1, align 4
  store i32 0, i32* %cnt, align 4
  %1 = load i8*, i8** %s.addr, align 4
  %2 = load i8, i8* %1, align 1
  %conv = sext i8 %2 to i32
  %cmp = icmp ne i32 %conv, 0
  br i1 %cmp, label %if.then, label %if.end26

if.then:                                          ; preds = %entry
  store i32 0, i32* %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.then
  %3 = load i8*, i8** %s.addr, align 4
  %4 = load i32, i32* %i, align 4
  %arrayidx = getelementptr inbounds i8, i8* %3, i32 %4
  %5 = load i8, i8* %arrayidx, align 1
  %conv3 = sext i8 %5 to i32
  %cmp4 = icmp ne i32 %conv3, 0
  br i1 %cmp4, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %6 = load i8*, i8** %s.addr, align 4
  %7 = load i32, i32* %i, align 4
  %arrayidx6 = getelementptr inbounds i8, i8* %6, i32 %7
  %8 = load i8, i8* %arrayidx6, align 1
  %conv7 = sext i8 %8 to i32
  %cmp8 = icmp slt i32 %conv7, 48
  br i1 %cmp8, label %if.then14, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %for.body
  %9 = load i8*, i8** %s.addr, align 4
  %10 = load i32, i32* %i, align 4
  %arrayidx10 = getelementptr inbounds i8, i8* %9, i32 %10
  %11 = load i8, i8* %arrayidx10, align 1
  %conv11 = sext i8 %11 to i32
  %cmp12 = icmp slt i32 51, %conv11
  br i1 %cmp12, label %if.then14, label %if.end20

if.then14:                                        ; preds = %lor.lhs.false, %for.body
  %12 = load i8*, i8** %s.addr, align 4
  %13 = load i32, i32* %i, align 4
  %arrayidx15 = getelementptr inbounds i8, i8* %12, i32 %13
  %14 = load i8, i8* %arrayidx15, align 1
  %conv16 = sext i8 %14 to i32
  %cmp17 = icmp eq i32 %conv16, 46
  br i1 %cmp17, label %if.then19, label %if.else

if.then19:                                        ; preds = %if.then14
  %15 = load i32, i32* %cnt, align 4
  %inc = add i32 %15, 1
  store i32 %inc, i32* %cnt, align 4
  br label %if.end

if.else:                                          ; preds = %if.then14
  store i32 0, i32* %valid1, align 4
  br label %for.end

if.end:                                           ; preds = %if.then19
  br label %if.end20

if.end20:                                         ; preds = %if.end, %lor.lhs.false
  br label %for.inc

for.inc:                                          ; preds = %if.end20
  %16 = load i32, i32* %i, align 4
  %inc21 = add i32 %16, 1
  store i32 %inc21, i32* %i, align 4
  br label %for.cond

for.end:                                          ; preds = %if.else, %for.cond
  %17 = load i32, i32* %valid1, align 4
  %tobool = icmp ne i32 %17, 0
  br i1 %tobool, label %land.lhs.true, label %if.end25

land.lhs.true:                                    ; preds = %for.end
  %18 = load i32, i32* %cnt, align 4
  %cmp22 = icmp ugt i32 %18, 1
  br i1 %cmp22, label %if.then24, label %if.end25

if.then24:                                        ; preds = %land.lhs.true
  store i32 0, i32* %valid1, align 4
  br label %if.end25

if.end25:                                         ; preds = %if.then24, %land.lhs.true, %for.end
  br label %if.end26

if.end26:                                         ; preds = %if.end25, %entry
  %19 = load i32, i32* %valid1, align 4
  %valid27 = getelementptr inbounds %struct.QuaterImaginary, %struct.QuaterImaginary* %agg.result, i32 0, i32 1
  store i32 %19, i32* %valid27, align 4
  ret void
}

; Function Attrs: noinline nounwind optnone
define hidden void @printQuaterImaginary(%struct.QuaterImaginary* byval(%struct.QuaterImaginary) align 4 %qi) #0 {
entry:
  %valid = getelementptr inbounds %struct.QuaterImaginary, %struct.QuaterImaginary* %qi, i32 0, i32 1
  %0 = load i32, i32* %valid, align 4
  %tobool = icmp ne i32 %0, 0
  br i1 %tobool, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  %b2i = getelementptr inbounds %struct.QuaterImaginary, %struct.QuaterImaginary* %qi, i32 0, i32 0
  %1 = load i8*, i8** %b2i, align 4
  %call = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([4 x i8], [4 x i8]* @.str.1, i32 0, i32 0), i8* %1)
  br label %if.end

if.else:                                          ; preds = %entry
  %call1 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([9 x i8], [9 x i8]* @.str.2, i32 0, i32 0))
  br label %if.end

if.end:                                           ; preds = %if.else, %if.then
  ret void
}

; Function Attrs: noinline nounwind optnone
define hidden void @qi2c(%struct.Complex* noalias sret align 8 %agg.result, %struct.QuaterImaginary* byval(%struct.QuaterImaginary) align 4 %qi) #0 {
entry:
  %len = alloca i32, align 4
  %pointPos = alloca i32, align 4
  %posLen = alloca i32, align 4
  %prod = alloca %struct.Complex, align 8
  %j = alloca i32, align 4
  %k = alloca double, align 8
  %tmp = alloca %struct.Complex, align 8
  %agg.tmp = alloca %struct.Complex, align 8
  %tmp10 = alloca %struct.Complex, align 8
  %k18 = alloca double, align 8
  %tmp27 = alloca %struct.Complex, align 8
  %agg.tmp28 = alloca %struct.Complex, align 8
  %tmp30 = alloca %struct.Complex, align 8
  %b2i = getelementptr inbounds %struct.QuaterImaginary, %struct.QuaterImaginary* %qi, i32 0, i32 0
  %0 = load i8*, i8** %b2i, align 4
  %call = call i32 @strlen(i8* %0) #5
  store i32 %call, i32* %len, align 4
  %b2i1 = getelementptr inbounds %struct.QuaterImaginary, %struct.QuaterImaginary* %qi, i32 0, i32 0
  %1 = load i8*, i8** %b2i1, align 4
  %call2 = call i32 @find(i8* %1, i8 signext 46)
  store i32 %call2, i32* %pointPos, align 4
  %2 = load i32, i32* %pointPos, align 4
  %cmp = icmp sgt i32 %2, 0
  br i1 %cmp, label %cond.true, label %cond.false

cond.true:                                        ; preds = %entry
  %3 = load i32, i32* %pointPos, align 4
  br label %cond.end

cond.false:                                       ; preds = %entry
  %4 = load i32, i32* %len, align 4
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi i32 [ %3, %cond.true ], [ %4, %cond.false ]
  store i32 %cond, i32* %posLen, align 4
  call void @makeComplex(%struct.Complex* sret align 8 %agg.result, double 0.000000e+00, double 0.000000e+00)
  call void @makeComplex(%struct.Complex* sret align 8 %prod, double 1.000000e+00, double 0.000000e+00)
  store i32 0, i32* %j, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %cond.end
  %5 = load i32, i32* %j, align 4
  %6 = load i32, i32* %posLen, align 4
  %cmp3 = icmp ult i32 %5, %6
  br i1 %cmp3, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %b2i4 = getelementptr inbounds %struct.QuaterImaginary, %struct.QuaterImaginary* %qi, i32 0, i32 0
  %7 = load i8*, i8** %b2i4, align 4
  %8 = load i32, i32* %posLen, align 4
  %sub = sub i32 %8, 1
  %9 = load i32, i32* %j, align 4
  %sub5 = sub i32 %sub, %9
  %arrayidx = getelementptr inbounds i8, i8* %7, i32 %sub5
  %10 = load i8, i8* %arrayidx, align 1
  %conv = sext i8 %10 to i32
  %sub6 = sub nsw i32 %conv, 48
  %conv7 = sitofp i32 %sub6 to double
  store double %conv7, double* %k, align 8
  %11 = load double, double* %k, align 8
  %cmp8 = fcmp ogt double %11, 0.000000e+00
  br i1 %cmp8, label %if.then, label %if.end

if.then:                                          ; preds = %for.body
  %12 = load double, double* %k, align 8
  call void @mulComplexD(%struct.Complex* sret align 8 %agg.tmp, %struct.Complex* byval(%struct.Complex) align 8 %prod, double %12)
  call void @addComplex(%struct.Complex* sret align 8 %tmp, %struct.Complex* byval(%struct.Complex) align 8 %agg.result, %struct.Complex* byval(%struct.Complex) align 8 %agg.tmp)
  %13 = bitcast %struct.Complex* %agg.result to i8*
  %14 = bitcast %struct.Complex* %tmp to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 8 %13, i8* align 8 %14, i32 16, i1 false)
  br label %if.end

if.end:                                           ; preds = %if.then, %for.body
  call void @mulComplex(%struct.Complex* sret align 8 %tmp10, %struct.Complex* byval(%struct.Complex) align 8 %prod, %struct.Complex* byval(%struct.Complex) align 8 @TWO_I)
  %15 = bitcast %struct.Complex* %prod to i8*
  %16 = bitcast %struct.Complex* %tmp10 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 8 %15, i8* align 8 %16, i32 16, i1 false)
  br label %for.inc

for.inc:                                          ; preds = %if.end
  %17 = load i32, i32* %j, align 4
  %inc = add i32 %17, 1
  store i32 %inc, i32* %j, align 4
  br label %for.cond

for.end:                                          ; preds = %for.cond
  %18 = load i32, i32* %pointPos, align 4
  %cmp11 = icmp ne i32 %18, -1
  br i1 %cmp11, label %if.then13, label %if.end34

if.then13:                                        ; preds = %for.end
  %19 = bitcast %struct.Complex* %prod to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 8 %19, i8* align 8 bitcast (%struct.Complex* @INV_TWO_I to i8*), i32 16, i1 false)
  %20 = load i32, i32* %posLen, align 4
  %add = add i32 %20, 1
  store i32 %add, i32* %j, align 4
  br label %for.cond14

for.cond14:                                       ; preds = %for.inc31, %if.then13
  %21 = load i32, i32* %j, align 4
  %22 = load i32, i32* %len, align 4
  %cmp15 = icmp ult i32 %21, %22
  br i1 %cmp15, label %for.body17, label %for.end33

for.body17:                                       ; preds = %for.cond14
  %b2i19 = getelementptr inbounds %struct.QuaterImaginary, %struct.QuaterImaginary* %qi, i32 0, i32 0
  %23 = load i8*, i8** %b2i19, align 4
  %24 = load i32, i32* %j, align 4
  %arrayidx20 = getelementptr inbounds i8, i8* %23, i32 %24
  %25 = load i8, i8* %arrayidx20, align 1
  %conv21 = sext i8 %25 to i32
  %sub22 = sub nsw i32 %conv21, 48
  %conv23 = sitofp i32 %sub22 to double
  store double %conv23, double* %k18, align 8
  %26 = load double, double* %k18, align 8
  %cmp24 = fcmp ogt double %26, 0.000000e+00
  br i1 %cmp24, label %if.then26, label %if.end29

if.then26:                                        ; preds = %for.body17
  %27 = load double, double* %k18, align 8
  call void @mulComplexD(%struct.Complex* sret align 8 %agg.tmp28, %struct.Complex* byval(%struct.Complex) align 8 %prod, double %27)
  call void @addComplex(%struct.Complex* sret align 8 %tmp27, %struct.Complex* byval(%struct.Complex) align 8 %agg.result, %struct.Complex* byval(%struct.Complex) align 8 %agg.tmp28)
  %28 = bitcast %struct.Complex* %agg.result to i8*
  %29 = bitcast %struct.Complex* %tmp27 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 8 %28, i8* align 8 %29, i32 16, i1 false)
  br label %if.end29

if.end29:                                         ; preds = %if.then26, %for.body17
  call void @mulComplex(%struct.Complex* sret align 8 %tmp30, %struct.Complex* byval(%struct.Complex) align 8 %prod, %struct.Complex* byval(%struct.Complex) align 8 @INV_TWO_I)
  %30 = bitcast %struct.Complex* %prod to i8*
  %31 = bitcast %struct.Complex* %tmp30 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 8 %30, i8* align 8 %31, i32 16, i1 false)
  br label %for.inc31

for.inc31:                                        ; preds = %if.end29
  %32 = load i32, i32* %j, align 4
  %inc32 = add i32 %32, 1
  store i32 %inc32, i32* %j, align 4
  br label %for.cond14

for.end33:                                        ; preds = %for.cond14
  br label %if.end34

if.end34:                                         ; preds = %for.end33, %for.end
  ret void
}

; Function Attrs: nounwind readonly
declare i32 @strlen(i8* %0) #2

; Function Attrs: argmemonly nounwind willreturn
declare void @llvm.memcpy.p0i8.p0i8.i32(i8* noalias nocapture writeonly %0, i8* noalias nocapture readonly %1, i32 %2, i1 immarg %3) #3

; Function Attrs: noinline nounwind optnone
define hidden void @c2qi(%struct.QuaterImaginary* noalias sret align 4 %agg.result, %struct.Complex* byval(%struct.Complex) align 8 %c, i8* %out) #0 {
entry:
  %out.addr = alloca i8*, align 4
  %p = alloca i8*, align 4
  %re = alloca i32, align 4
  %im = alloca i32, align 4
  %fi = alloca i32, align 4
  %rem = alloca i32, align 4
  %index = alloca i32, align 4
  %fc = alloca %struct.Complex, align 8
  %.compoundliteral = alloca %struct.Complex, align 8
  %.compoundliteral21 = alloca %struct.Complex, align 8
  %f = alloca double, align 8
  %rem31 = alloca i32, align 4
  %i = alloca i32, align 4
  store i8* %out, i8** %out.addr, align 4
  %0 = load i8*, i8** %out.addr, align 4
  store i8* %0, i8** %p, align 4
  %1 = load i8*, i8** %p, align 4
  store i8 0, i8* %1, align 1
  %rel = getelementptr inbounds %struct.Complex, %struct.Complex* %c, i32 0, i32 0
  %2 = load double, double* %rel, align 8
  %cmp = fcmp oeq double %2, 0.000000e+00
  br i1 %cmp, label %land.lhs.true, label %if.end

land.lhs.true:                                    ; preds = %entry
  %img = getelementptr inbounds %struct.Complex, %struct.Complex* %c, i32 0, i32 1
  %3 = load double, double* %img, align 8
  %cmp1 = fcmp oeq double %3, 0.000000e+00
  br i1 %cmp1, label %if.then, label %if.end

if.then:                                          ; preds = %land.lhs.true
  call void @makeQuaterImaginary(%struct.QuaterImaginary* sret align 4 %agg.result, i8* getelementptr inbounds ([2 x i8], [2 x i8]* @.str.3, i32 0, i32 0))
  br label %return

if.end:                                           ; preds = %land.lhs.true, %entry
  %rel2 = getelementptr inbounds %struct.Complex, %struct.Complex* %c, i32 0, i32 0
  %4 = load double, double* %rel2, align 8
  %conv = fptosi double %4 to i32
  store i32 %conv, i32* %re, align 4
  %img3 = getelementptr inbounds %struct.Complex, %struct.Complex* %c, i32 0, i32 1
  %5 = load double, double* %img3, align 8
  %conv4 = fptosi double %5 to i32
  store i32 %conv4, i32* %im, align 4
  store i32 -1, i32* %fi, align 4
  br label %while.cond

while.cond:                                       ; preds = %if.end11, %if.end
  %6 = load i32, i32* %re, align 4
  %cmp5 = icmp ne i32 %6, 0
  br i1 %cmp5, label %while.body, label %while.end

while.body:                                       ; preds = %while.cond
  %7 = load i32, i32* %re, align 4
  %rem7 = srem i32 %7, -4
  store i32 %rem7, i32* %rem, align 4
  %8 = load i32, i32* %re, align 4
  %div = sdiv i32 %8, -4
  store i32 %div, i32* %re, align 4
  %9 = load i32, i32* %rem, align 4
  %cmp8 = icmp slt i32 %9, 0
  br i1 %cmp8, label %if.then10, label %if.end11

if.then10:                                        ; preds = %while.body
  %10 = load i32, i32* %rem, align 4
  %add = add nsw i32 %10, 4
  store i32 %add, i32* %rem, align 4
  %11 = load i32, i32* %re, align 4
  %inc = add nsw i32 %11, 1
  store i32 %inc, i32* %re, align 4
  br label %if.end11

if.end11:                                         ; preds = %if.then10, %while.body
  %12 = load i32, i32* %rem, align 4
  %add12 = add nsw i32 %12, 48
  %conv13 = trunc i32 %add12 to i8
  %13 = load i8*, i8** %p, align 4
  %incdec.ptr = getelementptr inbounds i8, i8* %13, i32 1
  store i8* %incdec.ptr, i8** %p, align 4
  store i8 %conv13, i8* %13, align 1
  %14 = load i8*, i8** %p, align 4
  %incdec.ptr14 = getelementptr inbounds i8, i8* %14, i32 1
  store i8* %incdec.ptr14, i8** %p, align 4
  store i8 48, i8* %14, align 1
  %15 = load i8*, i8** %p, align 4
  store i8 0, i8* %15, align 1
  br label %while.cond

while.end:                                        ; preds = %while.cond
  %16 = load i32, i32* %im, align 4
  %cmp15 = icmp ne i32 %16, 0
  br i1 %cmp15, label %if.then17, label %if.end53

if.then17:                                        ; preds = %while.end
  store i32 1, i32* %index, align 4
  %rel18 = getelementptr inbounds %struct.Complex, %struct.Complex* %.compoundliteral, i32 0, i32 0
  store double 0.000000e+00, double* %rel18, align 8
  %img19 = getelementptr inbounds %struct.Complex, %struct.Complex* %.compoundliteral, i32 0, i32 1
  %img20 = getelementptr inbounds %struct.Complex, %struct.Complex* %c, i32 0, i32 1
  %17 = load double, double* %img20, align 8
  store double %17, double* %img19, align 8
  %rel22 = getelementptr inbounds %struct.Complex, %struct.Complex* %.compoundliteral21, i32 0, i32 0
  store double 0.000000e+00, double* %rel22, align 8
  %img23 = getelementptr inbounds %struct.Complex, %struct.Complex* %.compoundliteral21, i32 0, i32 1
  store double 2.000000e+00, double* %img23, align 8
  call void @divComplex(%struct.Complex* sret align 8 %fc, %struct.Complex* byval(%struct.Complex) align 8 %.compoundliteral, %struct.Complex* byval(%struct.Complex) align 8 %.compoundliteral21)
  %rel24 = getelementptr inbounds %struct.Complex, %struct.Complex* %fc, i32 0, i32 0
  %18 = load double, double* %rel24, align 8
  store double %18, double* %f, align 8
  %19 = load double, double* %f, align 8
  %20 = call double @llvm.ceil.f64(double %19)
  %conv25 = fptosi double %20 to i32
  store i32 %conv25, i32* %im, align 4
  %21 = load double, double* %f, align 8
  %22 = load i32, i32* %im, align 4
  %conv26 = sitofp i32 %22 to double
  %sub = fsub double %21, %conv26
  %mul = fmul double -4.000000e+00, %sub
  store double %mul, double* %f, align 8
  br label %while.cond27

while.cond27:                                     ; preds = %if.end49, %if.then17
  %23 = load i32, i32* %im, align 4
  %cmp28 = icmp ne i32 %23, 0
  br i1 %cmp28, label %while.body30, label %while.end51

while.body30:                                     ; preds = %while.cond27
  %24 = load i32, i32* %im, align 4
  %rem32 = srem i32 %24, -4
  store i32 %rem32, i32* %rem31, align 4
  %25 = load i32, i32* %im, align 4
  %div33 = sdiv i32 %25, -4
  store i32 %div33, i32* %im, align 4
  %26 = load i32, i32* %rem31, align 4
  %cmp34 = icmp slt i32 %26, 0
  br i1 %cmp34, label %if.then36, label %if.end39

if.then36:                                        ; preds = %while.body30
  %27 = load i32, i32* %rem31, align 4
  %add37 = add nsw i32 %27, 4
  store i32 %add37, i32* %rem31, align 4
  %28 = load i32, i32* %im, align 4
  %inc38 = add nsw i32 %28, 1
  store i32 %inc38, i32* %im, align 4
  br label %if.end39

if.end39:                                         ; preds = %if.then36, %while.body30
  %29 = load i32, i32* %index, align 4
  %30 = load i8*, i8** %p, align 4
  %31 = load i8*, i8** %out.addr, align 4
  %sub.ptr.lhs.cast = ptrtoint i8* %30 to i32
  %sub.ptr.rhs.cast = ptrtoint i8* %31 to i32
  %sub.ptr.sub = sub i32 %sub.ptr.lhs.cast, %sub.ptr.rhs.cast
  %cmp40 = icmp ult i32 %29, %sub.ptr.sub
  br i1 %cmp40, label %if.then42, label %if.else

if.then42:                                        ; preds = %if.end39
  %32 = load i32, i32* %rem31, align 4
  %add43 = add nsw i32 %32, 48
  %conv44 = trunc i32 %add43 to i8
  %33 = load i8*, i8** %out.addr, align 4
  %34 = load i32, i32* %index, align 4
  %arrayidx = getelementptr inbounds i8, i8* %33, i32 %34
  store i8 %conv44, i8* %arrayidx, align 1
  br label %if.end49

if.else:                                          ; preds = %if.end39
  %35 = load i8*, i8** %p, align 4
  %incdec.ptr45 = getelementptr inbounds i8, i8* %35, i32 1
  store i8* %incdec.ptr45, i8** %p, align 4
  store i8 48, i8* %35, align 1
  %36 = load i32, i32* %rem31, align 4
  %add46 = add nsw i32 %36, 48
  %conv47 = trunc i32 %add46 to i8
  %37 = load i8*, i8** %p, align 4
  %incdec.ptr48 = getelementptr inbounds i8, i8* %37, i32 1
  store i8* %incdec.ptr48, i8** %p, align 4
  store i8 %conv47, i8* %37, align 1
  %38 = load i8*, i8** %p, align 4
  store i8 0, i8* %38, align 1
  br label %if.end49

if.end49:                                         ; preds = %if.else, %if.then42
  %39 = load i32, i32* %index, align 4
  %add50 = add i32 %39, 2
  store i32 %add50, i32* %index, align 4
  br label %while.cond27

while.end51:                                      ; preds = %while.cond27
  %40 = load double, double* %f, align 8
  %conv52 = fptosi double %40 to i32
  store i32 %conv52, i32* %fi, align 4
  br label %if.end53

if.end53:                                         ; preds = %while.end51, %while.end
  %41 = load i8*, i8** %out.addr, align 4
  %42 = load i8*, i8** %p, align 4
  call void @reverse(i8* %41, i8* %42)
  %43 = load i32, i32* %fi, align 4
  %cmp54 = icmp ne i32 %43, -1
  br i1 %cmp54, label %if.then56, label %if.end61

if.then56:                                        ; preds = %if.end53
  %44 = load i8*, i8** %p, align 4
  %incdec.ptr57 = getelementptr inbounds i8, i8* %44, i32 1
  store i8* %incdec.ptr57, i8** %p, align 4
  store i8 46, i8* %44, align 1
  %45 = load i32, i32* %fi, align 4
  %add58 = add nsw i32 %45, 48
  %conv59 = trunc i32 %add58 to i8
  %46 = load i8*, i8** %p, align 4
  %incdec.ptr60 = getelementptr inbounds i8, i8* %46, i32 1
  store i8* %incdec.ptr60, i8** %p, align 4
  store i8 %conv59, i8* %46, align 1
  %47 = load i8*, i8** %p, align 4
  store i8 0, i8* %47, align 1
  br label %if.end61

if.end61:                                         ; preds = %if.then56, %if.end53
  br label %while.cond62

while.cond62:                                     ; preds = %for.end, %if.end61
  %48 = load i8*, i8** %out.addr, align 4
  %arrayidx63 = getelementptr inbounds i8, i8* %48, i32 0
  %49 = load i8, i8* %arrayidx63, align 1
  %conv64 = sext i8 %49 to i32
  %cmp65 = icmp eq i32 %conv64, 48
  br i1 %cmp65, label %land.rhs, label %land.end

land.rhs:                                         ; preds = %while.cond62
  %50 = load i8*, i8** %out.addr, align 4
  %arrayidx67 = getelementptr inbounds i8, i8* %50, i32 1
  %51 = load i8, i8* %arrayidx67, align 1
  %conv68 = sext i8 %51 to i32
  %cmp69 = icmp ne i32 %conv68, 46
  br label %land.end

land.end:                                         ; preds = %land.rhs, %while.cond62
  %52 = phi i1 [ false, %while.cond62 ], [ %cmp69, %land.rhs ]
  br i1 %52, label %while.body71, label %while.end80

while.body71:                                     ; preds = %land.end
  store i32 0, i32* %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %while.body71
  %53 = load i8*, i8** %out.addr, align 4
  %54 = load i32, i32* %i, align 4
  %arrayidx72 = getelementptr inbounds i8, i8* %53, i32 %54
  %55 = load i8, i8* %arrayidx72, align 1
  %conv73 = sext i8 %55 to i32
  %cmp74 = icmp ne i32 %conv73, 0
  br i1 %cmp74, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %56 = load i8*, i8** %out.addr, align 4
  %57 = load i32, i32* %i, align 4
  %add76 = add i32 %57, 1
  %arrayidx77 = getelementptr inbounds i8, i8* %56, i32 %add76
  %58 = load i8, i8* %arrayidx77, align 1
  %59 = load i8*, i8** %out.addr, align 4
  %60 = load i32, i32* %i, align 4
  %arrayidx78 = getelementptr inbounds i8, i8* %59, i32 %60
  store i8 %58, i8* %arrayidx78, align 1
  br label %for.inc

for.inc:                                          ; preds = %for.body
  %61 = load i32, i32* %i, align 4
  %inc79 = add i32 %61, 1
  store i32 %inc79, i32* %i, align 4
  br label %for.cond

for.end:                                          ; preds = %for.cond
  br label %while.cond62

while.end80:                                      ; preds = %land.end
  %62 = load i8*, i8** %out.addr, align 4
  %63 = load i8, i8* %62, align 1
  %conv81 = sext i8 %63 to i32
  %cmp82 = icmp eq i32 %conv81, 46
  br i1 %cmp82, label %if.then84, label %if.end86

if.then84:                                        ; preds = %while.end80
  %64 = load i8*, i8** %out.addr, align 4
  %65 = load i8*, i8** %p, align 4
  call void @reverse(i8* %64, i8* %65)
  %66 = load i8*, i8** %p, align 4
  %incdec.ptr85 = getelementptr inbounds i8, i8* %66, i32 1
  store i8* %incdec.ptr85, i8** %p, align 4
  store i8 48, i8* %66, align 1
  %67 = load i8*, i8** %p, align 4
  store i8 0, i8* %67, align 1
  %68 = load i8*, i8** %out.addr, align 4
  %69 = load i8*, i8** %p, align 4
  call void @reverse(i8* %68, i8* %69)
  br label %if.end86

if.end86:                                         ; preds = %if.then84, %while.end80
  %70 = load i8*, i8** %out.addr, align 4
  call void @makeQuaterImaginary(%struct.QuaterImaginary* sret align 4 %agg.result, i8* %70)
  br label %return

return:                                           ; preds = %if.end86, %if.then
  ret void
}

; Function Attrs: nounwind readnone speculatable willreturn
declare double @llvm.ceil.f64(double %0) #4

; Function Attrs: noinline nounwind optnone
define hidden i32 @main() #0 {
entry:
  %retval = alloca i32, align 4
  %buffer = alloca [16 x i8], align 16
  %i = alloca i32, align 4
  %c1 = alloca %struct.Complex, align 8
  %qi = alloca %struct.QuaterImaginary, align 4
  %c2 = alloca %struct.Complex, align 8
  %tmp = alloca %struct.Complex, align 8
  %tmp3 = alloca %struct.QuaterImaginary, align 4
  %tmp5 = alloca %struct.Complex, align 8
  %c114 = alloca %struct.Complex, align 8
  %qi18 = alloca %struct.QuaterImaginary, align 4
  %c220 = alloca %struct.Complex, align 8
  %tmp24 = alloca %struct.Complex, align 8
  %tmp25 = alloca %struct.QuaterImaginary, align 4
  %tmp27 = alloca %struct.Complex, align 8
  store i32 0, i32* %retval, align 4
  store i32 1, i32* %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %0 = load i32, i32* %i, align 4
  %cmp = icmp sle i32 %0, 16
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %rel = getelementptr inbounds %struct.Complex, %struct.Complex* %c1, i32 0, i32 0
  %1 = load i32, i32* %i, align 4
  %conv = sitofp i32 %1 to double
  store double %conv, double* %rel, align 8
  %img = getelementptr inbounds %struct.Complex, %struct.Complex* %c1, i32 0, i32 1
  store double 0.000000e+00, double* %img, align 8
  %arraydecay = getelementptr inbounds [16 x i8], [16 x i8]* %buffer, i32 0, i32 0
  call void @c2qi(%struct.QuaterImaginary* sret align 4 %qi, %struct.Complex* byval(%struct.Complex) align 8 %c1, i8* %arraydecay)
  call void @qi2c(%struct.Complex* sret align 8 %c2, %struct.QuaterImaginary* byval(%struct.QuaterImaginary) align 4 %qi)
  call void @printComplex(%struct.Complex* byval(%struct.Complex) align 8 %c1)
  %call = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.4, i32 0, i32 0))
  call void @printQuaterImaginary(%struct.QuaterImaginary* byval(%struct.QuaterImaginary) align 4 %qi)
  %call1 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.4, i32 0, i32 0))
  call void @printComplex(%struct.Complex* byval(%struct.Complex) align 8 %c2)
  %call2 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([6 x i8], [6 x i8]* @.str.5, i32 0, i32 0))
  call void @negComplex(%struct.Complex* sret align 8 %tmp, %struct.Complex* byval(%struct.Complex) align 8 %c1)
  %2 = bitcast %struct.Complex* %c1 to i8*
  %3 = bitcast %struct.Complex* %tmp to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 8 %2, i8* align 8 %3, i32 16, i1 false)
  %arraydecay4 = getelementptr inbounds [16 x i8], [16 x i8]* %buffer, i32 0, i32 0
  call void @c2qi(%struct.QuaterImaginary* sret align 4 %tmp3, %struct.Complex* byval(%struct.Complex) align 8 %c1, i8* %arraydecay4)
  %4 = bitcast %struct.QuaterImaginary* %qi to i8*
  %5 = bitcast %struct.QuaterImaginary* %tmp3 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 4 %4, i8* align 4 %5, i32 8, i1 false)
  call void @qi2c(%struct.Complex* sret align 8 %tmp5, %struct.QuaterImaginary* byval(%struct.QuaterImaginary) align 4 %qi)
  %6 = bitcast %struct.Complex* %c2 to i8*
  %7 = bitcast %struct.Complex* %tmp5 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 8 %6, i8* align 8 %7, i32 16, i1 false)
  call void @printComplex(%struct.Complex* byval(%struct.Complex) align 8 %c1)
  %call6 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.4, i32 0, i32 0))
  call void @printQuaterImaginary(%struct.QuaterImaginary* byval(%struct.QuaterImaginary) align 4 %qi)
  %call7 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.4, i32 0, i32 0))
  call void @printComplex(%struct.Complex* byval(%struct.Complex) align 8 %c2)
  %call8 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([2 x i8], [2 x i8]* @.str.6, i32 0, i32 0))
  br label %for.inc

for.inc:                                          ; preds = %for.body
  %8 = load i32, i32* %i, align 4
  %inc = add nsw i32 %8, 1
  store i32 %inc, i32* %i, align 4
  br label %for.cond

for.end:                                          ; preds = %for.cond
  %call9 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([2 x i8], [2 x i8]* @.str.6, i32 0, i32 0))
  store i32 1, i32* %i, align 4
  br label %for.cond10

for.cond10:                                       ; preds = %for.inc31, %for.end
  %9 = load i32, i32* %i, align 4
  %cmp11 = icmp sle i32 %9, 16
  br i1 %cmp11, label %for.body13, label %for.end33

for.body13:                                       ; preds = %for.cond10
  %rel15 = getelementptr inbounds %struct.Complex, %struct.Complex* %c114, i32 0, i32 0
  store double 0.000000e+00, double* %rel15, align 8
  %img16 = getelementptr inbounds %struct.Complex, %struct.Complex* %c114, i32 0, i32 1
  %10 = load i32, i32* %i, align 4
  %conv17 = sitofp i32 %10 to double
  store double %conv17, double* %img16, align 8
  %arraydecay19 = getelementptr inbounds [16 x i8], [16 x i8]* %buffer, i32 0, i32 0
  call void @c2qi(%struct.QuaterImaginary* sret align 4 %qi18, %struct.Complex* byval(%struct.Complex) align 8 %c114, i8* %arraydecay19)
  call void @qi2c(%struct.Complex* sret align 8 %c220, %struct.QuaterImaginary* byval(%struct.QuaterImaginary) align 4 %qi18)
  call void @printComplex(%struct.Complex* byval(%struct.Complex) align 8 %c114)
  %call21 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.4, i32 0, i32 0))
  call void @printQuaterImaginary(%struct.QuaterImaginary* byval(%struct.QuaterImaginary) align 4 %qi18)
  %call22 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.4, i32 0, i32 0))
  call void @printComplex(%struct.Complex* byval(%struct.Complex) align 8 %c220)
  %call23 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([6 x i8], [6 x i8]* @.str.5, i32 0, i32 0))
  call void @negComplex(%struct.Complex* sret align 8 %tmp24, %struct.Complex* byval(%struct.Complex) align 8 %c114)
  %11 = bitcast %struct.Complex* %c114 to i8*
  %12 = bitcast %struct.Complex* %tmp24 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 8 %11, i8* align 8 %12, i32 16, i1 false)
  %arraydecay26 = getelementptr inbounds [16 x i8], [16 x i8]* %buffer, i32 0, i32 0
  call void @c2qi(%struct.QuaterImaginary* sret align 4 %tmp25, %struct.Complex* byval(%struct.Complex) align 8 %c114, i8* %arraydecay26)
  %13 = bitcast %struct.QuaterImaginary* %qi18 to i8*
  %14 = bitcast %struct.QuaterImaginary* %tmp25 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 4 %13, i8* align 4 %14, i32 8, i1 false)
  call void @qi2c(%struct.Complex* sret align 8 %tmp27, %struct.QuaterImaginary* byval(%struct.QuaterImaginary) align 4 %qi18)
  %15 = bitcast %struct.Complex* %c220 to i8*
  %16 = bitcast %struct.Complex* %tmp27 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 8 %15, i8* align 8 %16, i32 16, i1 false)
  call void @printComplex(%struct.Complex* byval(%struct.Complex) align 8 %c114)
  %call28 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.4, i32 0, i32 0))
  call void @printQuaterImaginary(%struct.QuaterImaginary* byval(%struct.QuaterImaginary) align 4 %qi18)
  %call29 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.4, i32 0, i32 0))
  call void @printComplex(%struct.Complex* byval(%struct.Complex) align 8 %c220)
  %call30 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([2 x i8], [2 x i8]* @.str.6, i32 0, i32 0))
  br label %for.inc31

for.inc31:                                        ; preds = %for.body13
  %17 = load i32, i32* %i, align 4
  %inc32 = add nsw i32 %17, 1
  store i32 %inc32, i32* %i, align 4
  br label %for.cond10

for.end33:                                        ; preds = %for.cond10
  ret i32 0
}

attributes #0 = { noinline nounwind optnone "correctly-rounded-divide-sqrt-fp-math"="false" "disable-tail-calls"="false" "frame-pointer"="none" "less-precise-fpmad"="false" "min-legal-vector-width"="0" "no-infs-fp-math"="false" "no-jump-tables"="false" "no-nans-fp-math"="false" "no-signed-zeros-fp-math"="false" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="generic" "unsafe-fp-math"="false" "use-soft-float"="false" }
attributes #1 = { "correctly-rounded-divide-sqrt-fp-math"="false" "disable-tail-calls"="false" "frame-pointer"="none" "less-precise-fpmad"="false" "no-infs-fp-math"="false" "no-nans-fp-math"="false" "no-signed-zeros-fp-math"="false" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="generic" "unsafe-fp-math"="false" "use-soft-float"="false" }
attributes #2 = { nounwind readonly "correctly-rounded-divide-sqrt-fp-math"="false" "disable-tail-calls"="false" "frame-pointer"="none" "less-precise-fpmad"="false" "no-infs-fp-math"="false" "no-nans-fp-math"="false" "no-signed-zeros-fp-math"="false" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="generic" "unsafe-fp-math"="false" "use-soft-float"="false" }
attributes #3 = { argmemonly nounwind willreturn }
attributes #4 = { nounwind readnone speculatable willreturn }
attributes #5 = { nounwind readonly }

!llvm.module.flags = !{!0}
!llvm.ident = !{!1}

!0 = !{i32 1, !"wchar_size", i32 4}
!1 = !{!"clang version 11.0.0 (https://github.com/Jacarte/llvm-project.git 0f6dea67136cc1e0b3d200eb2bb165628970c44b)"}

; extracted candidates

; *****
; For LLVM instruction:
;  %2 = load i8, i8* %1, align 1
; Looking for a replacement for:
%0:i8 = var
infer %0

; *****
; For LLVM instruction:
;  %conv = sext i8 %2 to i32
; Looking for a replacement for:
%0:i8 = var
%1:i32 = sext %0
infer %1

; *****
; For LLVM instruction:
;  %cmp = icmp ne i32 %conv, 0
; Looking for a replacement for:
%0:i8 = var
%1:i32 = sext %0
%2:i1 = ne 0:i32, %1
infer %2

; *****
; For LLVM instruction:
;  %4 = load i32, i32* %i, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %5 = load i8, i8* %arrayidx, align 1
; Looking for a replacement for:
%0:i8 = var
infer %0

; *****
; For LLVM instruction:
;  %conv3 = sext i8 %5 to i32
; Looking for a replacement for:
%0:i8 = var
%1:i32 = sext %0
infer %1

; *****
; For LLVM instruction:
;  %cmp4 = icmp ne i32 %conv3, 0
; Looking for a replacement for:
%0:i8 = var
%1:i32 = sext %0
%2:i1 = ne 0:i32, %1
infer %2

; *****
; For LLVM instruction:
;  %7 = load i32, i32* %i, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %8 = load i8, i8* %arrayidx6, align 1
; Looking for a replacement for:
%0:i8 = var
infer %0

; *****
; For LLVM instruction:
;  %conv7 = sext i8 %8 to i32
; Looking for a replacement for:
%0:i8 = var
%1:i32 = sext %0
infer %1

; *****
; For LLVM instruction:
;  %cmp8 = icmp slt i32 %conv7, 48
; Looking for a replacement for:
%0:i8 = var
%1:i32 = sext %0
%2:i1 = slt %1, 48:i32
infer %2

; *****
; For LLVM instruction:
;  %10 = load i32, i32* %i, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %11 = load i8, i8* %arrayidx10, align 1
; Looking for a replacement for:
%0:i8 = var
infer %0

; *****
; For LLVM instruction:
;  %conv11 = sext i8 %11 to i32
; Looking for a replacement for:
%0:i8 = var
%1:i32 = sext %0
infer %1

; *****
; For LLVM instruction:
;  %cmp12 = icmp slt i32 51, %conv11
; Looking for a replacement for:
%0:i8 = var
%1:i32 = sext %0
%2:i1 = slt 51:i32, %1
infer %2

; *****
; For LLVM instruction:
;  %13 = load i32, i32* %i, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %14 = load i8, i8* %arrayidx15, align 1
; Looking for a replacement for:
%0:i8 = var
infer %0

; *****
; For LLVM instruction:
;  %conv16 = sext i8 %14 to i32
; Looking for a replacement for:
%0:i8 = var
%1:i32 = sext %0
infer %1

; *****
; For LLVM instruction:
;  %cmp17 = icmp eq i32 %conv16, 46
; Looking for a replacement for:
%0:i8 = var
%1:i32 = sext %0
%2:i1 = eq 46:i32, %1
infer %2

; *****
; For LLVM instruction:
;  %15 = load i32, i32* %cnt, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %inc = add i32 %15, 1
; Looking for a replacement for:
%0:i32 = var
%1:i32 = add 1:i32, %0
infer %1

; *****
; For LLVM instruction:
;  %16 = load i32, i32* %i, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %inc21 = add i32 %16, 1
; Looking for a replacement for:
%0:i32 = var
%1:i32 = add 1:i32, %0
infer %1

; *****
; For LLVM instruction:
;  %17 = load i32, i32* %valid1, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %tobool = icmp ne i32 %17, 0
; Looking for a replacement for:
%0:i32 = var
%1:i1 = ne 0:i32, %0
infer %1

; *****
; For LLVM instruction:
;  %18 = load i32, i32* %cnt, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %cmp22 = icmp ugt i32 %18, 1
; Looking for a replacement for:
%0:i32 = var
%1:i1 = ult 1:i32, %0
infer %1

; *****
; For LLVM instruction:
;  %19 = load i32, i32* %valid1, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0
got 3 candidates from LHS

-------------------------------------------------
%0:i8 = var
%1:i32 = sext %0
%2:i1 = slt %1, 48:i32
infer %2


--------------------------------
guess 0

%0:i1 = var ; reservedconst_1

Cost = 0
first query is SAT, returning the model:
reservedconst_1: -1
0 th attempt: second query is SAT-- constant doesn't work
first query is SAT, returning the model:
reservedconst_1: 0
1 th attempt: second query is SAT-- constant doesn't work
first query is UNSAT-- no more guesses
Dataflow Pruned 0/0
There are 1 Guesses
There are 0 RHSs before deduplication
There are 0 RHSs after deduplication
got 3 candidates from LHS

-------------------------------------------------
%0:i8 = var
%1:i32 = sext %0
%2:i1 = slt 51:i32, %1
infer %2


--------------------------------
guess 0

%0:i1 = var ; reservedconst_1

Cost = 0
first query is SAT, returning the model:
reservedconst_1: 0
0 th attempt: second query is SAT-- constant doesn't work
first query is SAT, returning the model:
reservedconst_1: -1
1 th attempt: second query is SAT-- constant doesn't work
first query is UNSAT-- no more guesses
Dataflow Pruned 0/0
There are 1 Guesses
There are 0 RHSs before deduplication
There are 0 RHSs after deduplication
got 3 candidates from LHS

-------------------------------------------------
%0:i8 = var
%1:i32 = sext %0
%2:i1 = eq 46:i32, %1
infer %2


--------------------------------
guess 0

%0:i1 = var ; reservedconst_1

Cost = 0
first query is SAT, returning the model:
reservedconst_1: 0
0 th attempt: second query is SAT-- constant doesn't work
first query is SAT, returning the model:
reservedconst_1: -1
1 th attempt: second query is SAT-- constant doesn't work
first query is UNSAT-- no more guesses
Dataflow Pruned 0/0
There are 1 Guesses
There are 0 RHSs before deduplication
There are 0 RHSs after deduplication
got 2 candidates from LHS

-------------------------------------------------
%0:i32 = var
%1:i32 = add 1:i32, %0
infer %1


--------------------------------
guess 0

%0:i32 = var ; reservedconst_1

Cost = 0
first query is SAT, returning the model:
reservedconst_1: 1
0 th attempt: second query is SAT-- constant doesn't work
first query is SAT, returning the model:
reservedconst_1: 0
1 th attempt: second query is SAT-- constant doesn't work
first query is UNSAT-- no more guesses

--------------------------------
guess 1

%0:i32 = var

Cost = 0
second query is SAT-- constant doesn't work
Dataflow Pruned 0/0
There are 2 Guesses
There are 0 RHSs before deduplication
There are 0 RHSs after deduplication
got 2 candidates from LHS

-------------------------------------------------
%0:i32 = var
%1:i1 = ne 0:i32, %0
infer %1


--------------------------------
guess 0

%0:i1 = var ; reservedconst_1

Cost = 0
first query is SAT, returning the model:
reservedconst_1: 0
0 th attempt: second query is SAT-- constant doesn't work
first query is SAT, returning the model:
reservedconst_1: -1
1 th attempt: second query is SAT-- constant doesn't work
first query is UNSAT-- no more guesses
Dataflow Pruned 0/0
There are 1 Guesses
There are 0 RHSs before deduplication
There are 0 RHSs after deduplication
got 2 candidates from LHS

-------------------------------------------------
%0:i32 = var
%1:i1 = ult 1:i32, %0
infer %1


--------------------------------
guess 0

%0:i1 = var ; reservedconst_1

Cost = 0
first query is SAT, returning the model:
reservedconst_1: 0
0 th attempt: second query is SAT-- constant doesn't work
first query is SAT, returning the model:
reservedconst_1: -1
1 th attempt: second query is SAT-- constant doesn't work
first query is UNSAT-- no more guesses
Dataflow Pruned 0/0
There are 1 Guesses
There are 0 RHSs before deduplication
There are 0 RHSs after deduplication
#########################################################
; exiting Souper's runOnFunction() for makeQuaterImaginary()

; entering Souper's runOnFunction() for printQuaterImaginary()

; ModuleID = './Imaginary_base_numbers.c.bc'
source_filename = "./Imaginary_base_numbers.c"
target datalayout = "e-m:e-p:32:32-i64:64-n32:64-S128"
target triple = "wasm32-unknown-wasi"

%struct.Complex = type { double, double }
%struct.QuaterImaginary = type { i8*, i32 }

@.str = private unnamed_addr constant [17 x i8] c"(%3.0f + %3.0fi)\00", align 1
@TWO_I = hidden constant %struct.Complex { double 0.000000e+00, double 2.000000e+00 }, align 8
@INV_TWO_I = hidden constant %struct.Complex { double 0.000000e+00, double -5.000000e-01 }, align 8
@.str.1 = private unnamed_addr constant [4 x i8] c"%8s\00", align 1
@.str.2 = private unnamed_addr constant [9 x i8] c" ERROR  \00", align 1
@.str.3 = private unnamed_addr constant [2 x i8] c"0\00", align 1
@.str.4 = private unnamed_addr constant [5 x i8] c" -> \00", align 1
@.str.5 = private unnamed_addr constant [6 x i8] c"     \00", align 1
@.str.6 = private unnamed_addr constant [2 x i8] c"\0A\00", align 1
@llvm.used = appending global [1 x i8*] [i8* bitcast (i32 ()* @__main_void to i8*)], section "llvm.metadata"

@__main_void = alias i32 (), i32 ()* @main

; Function Attrs: noinline nounwind optnone
define hidden i32 @find(i8* %s, i8 signext %c) #0 {
entry:
  %retval = alloca i32, align 4
  %s.addr = alloca i8*, align 4
  %c.addr = alloca i8, align 1
  %i = alloca i8*, align 4
  store i8* %s, i8** %s.addr, align 4
  store i8 %c, i8* %c.addr, align 1
  %0 = load i8*, i8** %s.addr, align 4
  store i8* %0, i8** %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %1 = load i8*, i8** %i, align 4
  %2 = load i8, i8* %1, align 1
  %conv = sext i8 %2 to i32
  %cmp = icmp ne i32 %conv, 0
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %3 = load i8*, i8** %i, align 4
  %4 = load i8, i8* %3, align 1
  %conv2 = sext i8 %4 to i32
  %5 = load i8, i8* %c.addr, align 1
  %conv3 = sext i8 %5 to i32
  %cmp4 = icmp eq i32 %conv2, %conv3
  br i1 %cmp4, label %if.then, label %if.end

if.then:                                          ; preds = %for.body
  %6 = load i8*, i8** %i, align 4
  %7 = load i8*, i8** %s.addr, align 4
  %sub.ptr.lhs.cast = ptrtoint i8* %6 to i32
  %sub.ptr.rhs.cast = ptrtoint i8* %7 to i32
  %sub.ptr.sub = sub i32 %sub.ptr.lhs.cast, %sub.ptr.rhs.cast
  store i32 %sub.ptr.sub, i32* %retval, align 4
  br label %return

if.end:                                           ; preds = %for.body
  br label %for.inc

for.inc:                                          ; preds = %if.end
  %8 = load i8*, i8** %i, align 4
  %incdec.ptr = getelementptr inbounds i8, i8* %8, i32 1
  store i8* %incdec.ptr, i8** %i, align 4
  br label %for.cond

for.end:                                          ; preds = %for.cond
  store i32 -1, i32* %retval, align 4
  br label %return

return:                                           ; preds = %for.end, %if.then
  %9 = load i32, i32* %retval, align 4
  ret i32 %9
}

; Function Attrs: noinline nounwind optnone
define hidden void @reverse(i8* %b, i8* %e) #0 {
entry:
  %b.addr = alloca i8*, align 4
  %e.addr = alloca i8*, align 4
  %t = alloca i8, align 1
  store i8* %b, i8** %b.addr, align 4
  store i8* %e, i8** %e.addr, align 4
  %0 = load i8*, i8** %e.addr, align 4
  %incdec.ptr = getelementptr inbounds i8, i8* %0, i32 -1
  store i8* %incdec.ptr, i8** %e.addr, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %1 = load i8*, i8** %b.addr, align 4
  %2 = load i8*, i8** %e.addr, align 4
  %cmp = icmp ult i8* %1, %2
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %3 = load i8*, i8** %b.addr, align 4
  %4 = load i8, i8* %3, align 1
  store i8 %4, i8* %t, align 1
  %5 = load i8*, i8** %e.addr, align 4
  %6 = load i8, i8* %5, align 1
  %7 = load i8*, i8** %b.addr, align 4
  store i8 %6, i8* %7, align 1
  %8 = load i8, i8* %t, align 1
  %9 = load i8*, i8** %e.addr, align 4
  store i8 %8, i8* %9, align 1
  br label %for.inc

for.inc:                                          ; preds = %for.body
  %10 = load i8*, i8** %b.addr, align 4
  %incdec.ptr1 = getelementptr inbounds i8, i8* %10, i32 1
  store i8* %incdec.ptr1, i8** %b.addr, align 4
  %11 = load i8*, i8** %e.addr, align 4
  %incdec.ptr2 = getelementptr inbounds i8, i8* %11, i32 -1
  store i8* %incdec.ptr2, i8** %e.addr, align 4
  br label %for.cond

for.end:                                          ; preds = %for.cond
  ret void
}

; Function Attrs: noinline nounwind optnone
define hidden void @printComplex(%struct.Complex* byval(%struct.Complex) align 8 %c) #0 {
entry:
  %rel = getelementptr inbounds %struct.Complex, %struct.Complex* %c, i32 0, i32 0
  %0 = load double, double* %rel, align 8
  %img = getelementptr inbounds %struct.Complex, %struct.Complex* %c, i32 0, i32 1
  %1 = load double, double* %img, align 8
  %call = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([17 x i8], [17 x i8]* @.str, i32 0, i32 0), double %0, double %1)
  ret void
}

declare i32 @printf(i8* %0, ...) #1

; Function Attrs: noinline nounwind optnone
define hidden void @makeComplex(%struct.Complex* noalias sret align 8 %agg.result, double %rel, double %img) #0 {
entry:
  %rel.addr = alloca double, align 8
  %img.addr = alloca double, align 8
  store double %rel, double* %rel.addr, align 8
  store double %img, double* %img.addr, align 8
  %rel1 = getelementptr inbounds %struct.Complex, %struct.Complex* %agg.result, i32 0, i32 0
  %0 = load double, double* %rel.addr, align 8
  store double %0, double* %rel1, align 8
  %img2 = getelementptr inbounds %struct.Complex, %struct.Complex* %agg.result, i32 0, i32 1
  %1 = load double, double* %img.addr, align 8
  store double %1, double* %img2, align 8
  ret void
}

; Function Attrs: noinline nounwind optnone
define hidden void @addComplex(%struct.Complex* noalias sret align 8 %agg.result, %struct.Complex* byval(%struct.Complex) align 8 %a, %struct.Complex* byval(%struct.Complex) align 8 %b) #0 {
entry:
  %rel = getelementptr inbounds %struct.Complex, %struct.Complex* %agg.result, i32 0, i32 0
  %rel1 = getelementptr inbounds %struct.Complex, %struct.Complex* %a, i32 0, i32 0
  %0 = load double, double* %rel1, align 8
  %rel2 = getelementptr inbounds %struct.Complex, %struct.Complex* %b, i32 0, i32 0
  %1 = load double, double* %rel2, align 8
  %add = fadd double %0, %1
  store double %add, double* %rel, align 8
  %img = getelementptr inbounds %struct.Complex, %struct.Complex* %agg.result, i32 0, i32 1
  %img3 = getelementptr inbounds %struct.Complex, %struct.Complex* %a, i32 0, i32 1
  %2 = load double, double* %img3, align 8
  %img4 = getelementptr inbounds %struct.Complex, %struct.Complex* %b, i32 0, i32 1
  %3 = load double, double* %img4, align 8
  %add5 = fadd double %2, %3
  store double %add5, double* %img, align 8
  ret void
}

; Function Attrs: noinline nounwind optnone
define hidden void @mulComplex(%struct.Complex* noalias sret align 8 %agg.result, %struct.Complex* byval(%struct.Complex) align 8 %a, %struct.Complex* byval(%struct.Complex) align 8 %b) #0 {
entry:
  %rel = getelementptr inbounds %struct.Complex, %struct.Complex* %agg.result, i32 0, i32 0
  %rel1 = getelementptr inbounds %struct.Complex, %struct.Complex* %a, i32 0, i32 0
  %0 = load double, double* %rel1, align 8
  %rel2 = getelementptr inbounds %struct.Complex, %struct.Complex* %b, i32 0, i32 0
  %1 = load double, double* %rel2, align 8
  %mul = fmul double %0, %1
  %img = getelementptr inbounds %struct.Complex, %struct.Complex* %a, i32 0, i32 1
  %2 = load double, double* %img, align 8
  %img3 = getelementptr inbounds %struct.Complex, %struct.Complex* %b, i32 0, i32 1
  %3 = load double, double* %img3, align 8
  %mul4 = fmul double %2, %3
  %sub = fsub double %mul, %mul4
  store double %sub, double* %rel, align 8
  %img5 = getelementptr inbounds %struct.Complex, %struct.Complex* %agg.result, i32 0, i32 1
  %rel6 = getelementptr inbounds %struct.Complex, %struct.Complex* %a, i32 0, i32 0
  %4 = load double, double* %rel6, align 8
  %img7 = getelementptr inbounds %struct.Complex, %struct.Complex* %b, i32 0, i32 1
  %5 = load double, double* %img7, align 8
  %mul8 = fmul double %4, %5
  %img9 = getelementptr inbounds %struct.Complex, %struct.Complex* %a, i32 0, i32 1
  %6 = load double, double* %img9, align 8
  %rel10 = getelementptr inbounds %struct.Complex, %struct.Complex* %b, i32 0, i32 0
  %7 = load double, double* %rel10, align 8
  %mul11 = fmul double %6, %7
  %sub12 = fsub double %mul8, %mul11
  store double %sub12, double* %img5, align 8
  ret void
}

; Function Attrs: noinline nounwind optnone
define hidden void @mulComplexD(%struct.Complex* noalias sret align 8 %agg.result, %struct.Complex* byval(%struct.Complex) align 8 %a, double %b) #0 {
entry:
  %b.addr = alloca double, align 8
  store double %b, double* %b.addr, align 8
  %rel = getelementptr inbounds %struct.Complex, %struct.Complex* %agg.result, i32 0, i32 0
  %rel1 = getelementptr inbounds %struct.Complex, %struct.Complex* %a, i32 0, i32 0
  %0 = load double, double* %rel1, align 8
  %1 = load double, double* %b.addr, align 8
  %mul = fmul double %0, %1
  store double %mul, double* %rel, align 8
  %img = getelementptr inbounds %struct.Complex, %struct.Complex* %agg.result, i32 0, i32 1
  %img2 = getelementptr inbounds %struct.Complex, %struct.Complex* %a, i32 0, i32 1
  %2 = load double, double* %img2, align 8
  %3 = load double, double* %b.addr, align 8
  %mul3 = fmul double %2, %3
  store double %mul3, double* %img, align 8
  ret void
}

; Function Attrs: noinline nounwind optnone
define hidden void @negComplex(%struct.Complex* noalias sret align 8 %agg.result, %struct.Complex* byval(%struct.Complex) align 8 %a) #0 {
entry:
  call void @mulComplexD(%struct.Complex* sret align 8 %agg.result, %struct.Complex* byval(%struct.Complex) align 8 %a, double -1.000000e+00)
  ret void
}

; Function Attrs: noinline nounwind optnone
define hidden void @divComplex(%struct.Complex* noalias sret align 8 %agg.result, %struct.Complex* byval(%struct.Complex) align 8 %a, %struct.Complex* byval(%struct.Complex) align 8 %b) #0 {
entry:
  %re = alloca double, align 8
  %im = alloca double, align 8
  %d = alloca double, align 8
  %rel = getelementptr inbounds %struct.Complex, %struct.Complex* %a, i32 0, i32 0
  %0 = load double, double* %rel, align 8
  %rel1 = getelementptr inbounds %struct.Complex, %struct.Complex* %b, i32 0, i32 0
  %1 = load double, double* %rel1, align 8
  %mul = fmul double %0, %1
  %img = getelementptr inbounds %struct.Complex, %struct.Complex* %a, i32 0, i32 1
  %2 = load double, double* %img, align 8
  %img2 = getelementptr inbounds %struct.Complex, %struct.Complex* %b, i32 0, i32 1
  %3 = load double, double* %img2, align 8
  %mul3 = fmul double %2, %3
  %add = fadd double %mul, %mul3
  store double %add, double* %re, align 8
  %img4 = getelementptr inbounds %struct.Complex, %struct.Complex* %a, i32 0, i32 1
  %4 = load double, double* %img4, align 8
  %rel5 = getelementptr inbounds %struct.Complex, %struct.Complex* %b, i32 0, i32 0
  %5 = load double, double* %rel5, align 8
  %mul6 = fmul double %4, %5
  %rel7 = getelementptr inbounds %struct.Complex, %struct.Complex* %a, i32 0, i32 0
  %6 = load double, double* %rel7, align 8
  %img8 = getelementptr inbounds %struct.Complex, %struct.Complex* %b, i32 0, i32 1
  %7 = load double, double* %img8, align 8
  %mul9 = fmul double %6, %7
  %sub = fsub double %mul6, %mul9
  store double %sub, double* %im, align 8
  %rel10 = getelementptr inbounds %struct.Complex, %struct.Complex* %b, i32 0, i32 0
  %8 = load double, double* %rel10, align 8
  %rel11 = getelementptr inbounds %struct.Complex, %struct.Complex* %b, i32 0, i32 0
  %9 = load double, double* %rel11, align 8
  %mul12 = fmul double %8, %9
  %img13 = getelementptr inbounds %struct.Complex, %struct.Complex* %b, i32 0, i32 1
  %10 = load double, double* %img13, align 8
  %img14 = getelementptr inbounds %struct.Complex, %struct.Complex* %b, i32 0, i32 1
  %11 = load double, double* %img14, align 8
  %mul15 = fmul double %10, %11
  %add16 = fadd double %mul12, %mul15
  store double %add16, double* %d, align 8
  %rel17 = getelementptr inbounds %struct.Complex, %struct.Complex* %agg.result, i32 0, i32 0
  %12 = load double, double* %re, align 8
  %13 = load double, double* %d, align 8
  %div = fdiv double %12, %13
  store double %div, double* %rel17, align 8
  %img18 = getelementptr inbounds %struct.Complex, %struct.Complex* %agg.result, i32 0, i32 1
  %14 = load double, double* %im, align 8
  %15 = load double, double* %d, align 8
  %div19 = fdiv double %14, %15
  store double %div19, double* %img18, align 8
  ret void
}

; Function Attrs: noinline nounwind optnone
define hidden void @inv(%struct.Complex* noalias sret align 8 %agg.result, %struct.Complex* byval(%struct.Complex) align 8 %c) #0 {
entry:
  %d = alloca double, align 8
  %rel = getelementptr inbounds %struct.Complex, %struct.Complex* %c, i32 0, i32 0
  %0 = load double, double* %rel, align 8
  %rel1 = getelementptr inbounds %struct.Complex, %struct.Complex* %c, i32 0, i32 0
  %1 = load double, double* %rel1, align 8
  %mul = fmul double %0, %1
  %img = getelementptr inbounds %struct.Complex, %struct.Complex* %c, i32 0, i32 1
  %2 = load double, double* %img, align 8
  %img2 = getelementptr inbounds %struct.Complex, %struct.Complex* %c, i32 0, i32 1
  %3 = load double, double* %img2, align 8
  %mul3 = fmul double %2, %3
  %add = fadd double %mul, %mul3
  store double %add, double* %d, align 8
  %rel4 = getelementptr inbounds %struct.Complex, %struct.Complex* %agg.result, i32 0, i32 0
  %rel5 = getelementptr inbounds %struct.Complex, %struct.Complex* %c, i32 0, i32 0
  %4 = load double, double* %rel5, align 8
  %5 = load double, double* %d, align 8
  %div = fdiv double %4, %5
  store double %div, double* %rel4, align 8
  %img6 = getelementptr inbounds %struct.Complex, %struct.Complex* %agg.result, i32 0, i32 1
  %img7 = getelementptr inbounds %struct.Complex, %struct.Complex* %c, i32 0, i32 1
  %6 = load double, double* %img7, align 8
  %fneg = fneg double %6
  %7 = load double, double* %d, align 8
  %div8 = fdiv double %fneg, %7
  store double %div8, double* %img6, align 8
  ret void
}

; Function Attrs: noinline nounwind optnone
define hidden void @makeQuaterImaginary(%struct.QuaterImaginary* noalias sret align 4 %agg.result, i8* %s) #0 {
entry:
  %s.addr = alloca i8*, align 4
  %i = alloca i32, align 4
  %valid1 = alloca i32, align 4
  %cnt = alloca i32, align 4
  store i8* %s, i8** %s.addr, align 4
  %b2i = getelementptr inbounds %struct.QuaterImaginary, %struct.QuaterImaginary* %agg.result, i32 0, i32 0
  %0 = load i8*, i8** %s.addr, align 4
  store i8* %0, i8** %b2i, align 4
  %valid = getelementptr inbounds %struct.QuaterImaginary, %struct.QuaterImaginary* %agg.result, i32 0, i32 1
  store i32 0, i32* %valid, align 4
  store i32 1, i32* %valid1, align 4
  store i32 0, i32* %cnt, align 4
  %1 = load i8*, i8** %s.addr, align 4
  %2 = load i8, i8* %1, align 1
  %conv = sext i8 %2 to i32
  %cmp = icmp ne i32 %conv, 0
  br i1 %cmp, label %if.then, label %if.end26

if.then:                                          ; preds = %entry
  store i32 0, i32* %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.then
  %3 = load i8*, i8** %s.addr, align 4
  %4 = load i32, i32* %i, align 4
  %arrayidx = getelementptr inbounds i8, i8* %3, i32 %4
  %5 = load i8, i8* %arrayidx, align 1
  %conv3 = sext i8 %5 to i32
  %cmp4 = icmp ne i32 %conv3, 0
  br i1 %cmp4, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %6 = load i8*, i8** %s.addr, align 4
  %7 = load i32, i32* %i, align 4
  %arrayidx6 = getelementptr inbounds i8, i8* %6, i32 %7
  %8 = load i8, i8* %arrayidx6, align 1
  %conv7 = sext i8 %8 to i32
  %cmp8 = icmp slt i32 %conv7, 48
  br i1 %cmp8, label %if.then14, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %for.body
  %9 = load i8*, i8** %s.addr, align 4
  %10 = load i32, i32* %i, align 4
  %arrayidx10 = getelementptr inbounds i8, i8* %9, i32 %10
  %11 = load i8, i8* %arrayidx10, align 1
  %conv11 = sext i8 %11 to i32
  %cmp12 = icmp slt i32 51, %conv11
  br i1 %cmp12, label %if.then14, label %if.end20

if.then14:                                        ; preds = %lor.lhs.false, %for.body
  %12 = load i8*, i8** %s.addr, align 4
  %13 = load i32, i32* %i, align 4
  %arrayidx15 = getelementptr inbounds i8, i8* %12, i32 %13
  %14 = load i8, i8* %arrayidx15, align 1
  %conv16 = sext i8 %14 to i32
  %cmp17 = icmp eq i32 %conv16, 46
  br i1 %cmp17, label %if.then19, label %if.else

if.then19:                                        ; preds = %if.then14
  %15 = load i32, i32* %cnt, align 4
  %inc = add i32 %15, 1
  store i32 %inc, i32* %cnt, align 4
  br label %if.end

if.else:                                          ; preds = %if.then14
  store i32 0, i32* %valid1, align 4
  br label %for.end

if.end:                                           ; preds = %if.then19
  br label %if.end20

if.end20:                                         ; preds = %if.end, %lor.lhs.false
  br label %for.inc

for.inc:                                          ; preds = %if.end20
  %16 = load i32, i32* %i, align 4
  %inc21 = add i32 %16, 1
  store i32 %inc21, i32* %i, align 4
  br label %for.cond

for.end:                                          ; preds = %if.else, %for.cond
  %17 = load i32, i32* %valid1, align 4
  %tobool = icmp ne i32 %17, 0
  br i1 %tobool, label %land.lhs.true, label %if.end25

land.lhs.true:                                    ; preds = %for.end
  %18 = load i32, i32* %cnt, align 4
  %cmp22 = icmp ugt i32 %18, 1
  br i1 %cmp22, label %if.then24, label %if.end25

if.then24:                                        ; preds = %land.lhs.true
  store i32 0, i32* %valid1, align 4
  br label %if.end25

if.end25:                                         ; preds = %if.then24, %land.lhs.true, %for.end
  br label %if.end26

if.end26:                                         ; preds = %if.end25, %entry
  %19 = load i32, i32* %valid1, align 4
  %valid27 = getelementptr inbounds %struct.QuaterImaginary, %struct.QuaterImaginary* %agg.result, i32 0, i32 1
  store i32 %19, i32* %valid27, align 4
  ret void
}

; Function Attrs: noinline nounwind optnone
define hidden void @printQuaterImaginary(%struct.QuaterImaginary* byval(%struct.QuaterImaginary) align 4 %qi) #0 {
entry:
  %valid = getelementptr inbounds %struct.QuaterImaginary, %struct.QuaterImaginary* %qi, i32 0, i32 1
  %0 = load i32, i32* %valid, align 4
  %tobool = icmp ne i32 %0, 0
  br i1 %tobool, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  %b2i = getelementptr inbounds %struct.QuaterImaginary, %struct.QuaterImaginary* %qi, i32 0, i32 0
  %1 = load i8*, i8** %b2i, align 4
  %call = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([4 x i8], [4 x i8]* @.str.1, i32 0, i32 0), i8* %1)
  br label %if.end

if.else:                                          ; preds = %entry
  %call1 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([9 x i8], [9 x i8]* @.str.2, i32 0, i32 0))
  br label %if.end

if.end:                                           ; preds = %if.else, %if.then
  ret void
}

; Function Attrs: noinline nounwind optnone
define hidden void @qi2c(%struct.Complex* noalias sret align 8 %agg.result, %struct.QuaterImaginary* byval(%struct.QuaterImaginary) align 4 %qi) #0 {
entry:
  %len = alloca i32, align 4
  %pointPos = alloca i32, align 4
  %posLen = alloca i32, align 4
  %prod = alloca %struct.Complex, align 8
  %j = alloca i32, align 4
  %k = alloca double, align 8
  %tmp = alloca %struct.Complex, align 8
  %agg.tmp = alloca %struct.Complex, align 8
  %tmp10 = alloca %struct.Complex, align 8
  %k18 = alloca double, align 8
  %tmp27 = alloca %struct.Complex, align 8
  %agg.tmp28 = alloca %struct.Complex, align 8
  %tmp30 = alloca %struct.Complex, align 8
  %b2i = getelementptr inbounds %struct.QuaterImaginary, %struct.QuaterImaginary* %qi, i32 0, i32 0
  %0 = load i8*, i8** %b2i, align 4
  %call = call i32 @strlen(i8* %0) #5
  store i32 %call, i32* %len, align 4
  %b2i1 = getelementptr inbounds %struct.QuaterImaginary, %struct.QuaterImaginary* %qi, i32 0, i32 0
  %1 = load i8*, i8** %b2i1, align 4
  %call2 = call i32 @find(i8* %1, i8 signext 46)
  store i32 %call2, i32* %pointPos, align 4
  %2 = load i32, i32* %pointPos, align 4
  %cmp = icmp sgt i32 %2, 0
  br i1 %cmp, label %cond.true, label %cond.false

cond.true:                                        ; preds = %entry
  %3 = load i32, i32* %pointPos, align 4
  br label %cond.end

cond.false:                                       ; preds = %entry
  %4 = load i32, i32* %len, align 4
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi i32 [ %3, %cond.true ], [ %4, %cond.false ]
  store i32 %cond, i32* %posLen, align 4
  call void @makeComplex(%struct.Complex* sret align 8 %agg.result, double 0.000000e+00, double 0.000000e+00)
  call void @makeComplex(%struct.Complex* sret align 8 %prod, double 1.000000e+00, double 0.000000e+00)
  store i32 0, i32* %j, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %cond.end
  %5 = load i32, i32* %j, align 4
  %6 = load i32, i32* %posLen, align 4
  %cmp3 = icmp ult i32 %5, %6
  br i1 %cmp3, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %b2i4 = getelementptr inbounds %struct.QuaterImaginary, %struct.QuaterImaginary* %qi, i32 0, i32 0
  %7 = load i8*, i8** %b2i4, align 4
  %8 = load i32, i32* %posLen, align 4
  %sub = sub i32 %8, 1
  %9 = load i32, i32* %j, align 4
  %sub5 = sub i32 %sub, %9
  %arrayidx = getelementptr inbounds i8, i8* %7, i32 %sub5
  %10 = load i8, i8* %arrayidx, align 1
  %conv = sext i8 %10 to i32
  %sub6 = sub nsw i32 %conv, 48
  %conv7 = sitofp i32 %sub6 to double
  store double %conv7, double* %k, align 8
  %11 = load double, double* %k, align 8
  %cmp8 = fcmp ogt double %11, 0.000000e+00
  br i1 %cmp8, label %if.then, label %if.end

if.then:                                          ; preds = %for.body
  %12 = load double, double* %k, align 8
  call void @mulComplexD(%struct.Complex* sret align 8 %agg.tmp, %struct.Complex* byval(%struct.Complex) align 8 %prod, double %12)
  call void @addComplex(%struct.Complex* sret align 8 %tmp, %struct.Complex* byval(%struct.Complex) align 8 %agg.result, %struct.Complex* byval(%struct.Complex) align 8 %agg.tmp)
  %13 = bitcast %struct.Complex* %agg.result to i8*
  %14 = bitcast %struct.Complex* %tmp to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 8 %13, i8* align 8 %14, i32 16, i1 false)
  br label %if.end

if.end:                                           ; preds = %if.then, %for.body
  call void @mulComplex(%struct.Complex* sret align 8 %tmp10, %struct.Complex* byval(%struct.Complex) align 8 %prod, %struct.Complex* byval(%struct.Complex) align 8 @TWO_I)
  %15 = bitcast %struct.Complex* %prod to i8*
  %16 = bitcast %struct.Complex* %tmp10 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 8 %15, i8* align 8 %16, i32 16, i1 false)
  br label %for.inc

for.inc:                                          ; preds = %if.end
  %17 = load i32, i32* %j, align 4
  %inc = add i32 %17, 1
  store i32 %inc, i32* %j, align 4
  br label %for.cond

for.end:                                          ; preds = %for.cond
  %18 = load i32, i32* %pointPos, align 4
  %cmp11 = icmp ne i32 %18, -1
  br i1 %cmp11, label %if.then13, label %if.end34

if.then13:                                        ; preds = %for.end
  %19 = bitcast %struct.Complex* %prod to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 8 %19, i8* align 8 bitcast (%struct.Complex* @INV_TWO_I to i8*), i32 16, i1 false)
  %20 = load i32, i32* %posLen, align 4
  %add = add i32 %20, 1
  store i32 %add, i32* %j, align 4
  br label %for.cond14

for.cond14:                                       ; preds = %for.inc31, %if.then13
  %21 = load i32, i32* %j, align 4
  %22 = load i32, i32* %len, align 4
  %cmp15 = icmp ult i32 %21, %22
  br i1 %cmp15, label %for.body17, label %for.end33

for.body17:                                       ; preds = %for.cond14
  %b2i19 = getelementptr inbounds %struct.QuaterImaginary, %struct.QuaterImaginary* %qi, i32 0, i32 0
  %23 = load i8*, i8** %b2i19, align 4
  %24 = load i32, i32* %j, align 4
  %arrayidx20 = getelementptr inbounds i8, i8* %23, i32 %24
  %25 = load i8, i8* %arrayidx20, align 1
  %conv21 = sext i8 %25 to i32
  %sub22 = sub nsw i32 %conv21, 48
  %conv23 = sitofp i32 %sub22 to double
  store double %conv23, double* %k18, align 8
  %26 = load double, double* %k18, align 8
  %cmp24 = fcmp ogt double %26, 0.000000e+00
  br i1 %cmp24, label %if.then26, label %if.end29

if.then26:                                        ; preds = %for.body17
  %27 = load double, double* %k18, align 8
  call void @mulComplexD(%struct.Complex* sret align 8 %agg.tmp28, %struct.Complex* byval(%struct.Complex) align 8 %prod, double %27)
  call void @addComplex(%struct.Complex* sret align 8 %tmp27, %struct.Complex* byval(%struct.Complex) align 8 %agg.result, %struct.Complex* byval(%struct.Complex) align 8 %agg.tmp28)
  %28 = bitcast %struct.Complex* %agg.result to i8*
  %29 = bitcast %struct.Complex* %tmp27 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 8 %28, i8* align 8 %29, i32 16, i1 false)
  br label %if.end29

if.end29:                                         ; preds = %if.then26, %for.body17
  call void @mulComplex(%struct.Complex* sret align 8 %tmp30, %struct.Complex* byval(%struct.Complex) align 8 %prod, %struct.Complex* byval(%struct.Complex) align 8 @INV_TWO_I)
  %30 = bitcast %struct.Complex* %prod to i8*
  %31 = bitcast %struct.Complex* %tmp30 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 8 %30, i8* align 8 %31, i32 16, i1 false)
  br label %for.inc31

for.inc31:                                        ; preds = %if.end29
  %32 = load i32, i32* %j, align 4
  %inc32 = add i32 %32, 1
  store i32 %inc32, i32* %j, align 4
  br label %for.cond14

for.end33:                                        ; preds = %for.cond14
  br label %if.end34

if.end34:                                         ; preds = %for.end33, %for.end
  ret void
}

; Function Attrs: nounwind readonly
declare i32 @strlen(i8* %0) #2

; Function Attrs: argmemonly nounwind willreturn
declare void @llvm.memcpy.p0i8.p0i8.i32(i8* noalias nocapture writeonly %0, i8* noalias nocapture readonly %1, i32 %2, i1 immarg %3) #3

; Function Attrs: noinline nounwind optnone
define hidden void @c2qi(%struct.QuaterImaginary* noalias sret align 4 %agg.result, %struct.Complex* byval(%struct.Complex) align 8 %c, i8* %out) #0 {
entry:
  %out.addr = alloca i8*, align 4
  %p = alloca i8*, align 4
  %re = alloca i32, align 4
  %im = alloca i32, align 4
  %fi = alloca i32, align 4
  %rem = alloca i32, align 4
  %index = alloca i32, align 4
  %fc = alloca %struct.Complex, align 8
  %.compoundliteral = alloca %struct.Complex, align 8
  %.compoundliteral21 = alloca %struct.Complex, align 8
  %f = alloca double, align 8
  %rem31 = alloca i32, align 4
  %i = alloca i32, align 4
  store i8* %out, i8** %out.addr, align 4
  %0 = load i8*, i8** %out.addr, align 4
  store i8* %0, i8** %p, align 4
  %1 = load i8*, i8** %p, align 4
  store i8 0, i8* %1, align 1
  %rel = getelementptr inbounds %struct.Complex, %struct.Complex* %c, i32 0, i32 0
  %2 = load double, double* %rel, align 8
  %cmp = fcmp oeq double %2, 0.000000e+00
  br i1 %cmp, label %land.lhs.true, label %if.end

land.lhs.true:                                    ; preds = %entry
  %img = getelementptr inbounds %struct.Complex, %struct.Complex* %c, i32 0, i32 1
  %3 = load double, double* %img, align 8
  %cmp1 = fcmp oeq double %3, 0.000000e+00
  br i1 %cmp1, label %if.then, label %if.end

if.then:                                          ; preds = %land.lhs.true
  call void @makeQuaterImaginary(%struct.QuaterImaginary* sret align 4 %agg.result, i8* getelementptr inbounds ([2 x i8], [2 x i8]* @.str.3, i32 0, i32 0))
  br label %return

if.end:                                           ; preds = %land.lhs.true, %entry
  %rel2 = getelementptr inbounds %struct.Complex, %struct.Complex* %c, i32 0, i32 0
  %4 = load double, double* %rel2, align 8
  %conv = fptosi double %4 to i32
  store i32 %conv, i32* %re, align 4
  %img3 = getelementptr inbounds %struct.Complex, %struct.Complex* %c, i32 0, i32 1
  %5 = load double, double* %img3, align 8
  %conv4 = fptosi double %5 to i32
  store i32 %conv4, i32* %im, align 4
  store i32 -1, i32* %fi, align 4
  br label %while.cond

while.cond:                                       ; preds = %if.end11, %if.end
  %6 = load i32, i32* %re, align 4
  %cmp5 = icmp ne i32 %6, 0
  br i1 %cmp5, label %while.body, label %while.end

while.body:                                       ; preds = %while.cond
  %7 = load i32, i32* %re, align 4
  %rem7 = srem i32 %7, -4
  store i32 %rem7, i32* %rem, align 4
  %8 = load i32, i32* %re, align 4
  %div = sdiv i32 %8, -4
  store i32 %div, i32* %re, align 4
  %9 = load i32, i32* %rem, align 4
  %cmp8 = icmp slt i32 %9, 0
  br i1 %cmp8, label %if.then10, label %if.end11

if.then10:                                        ; preds = %while.body
  %10 = load i32, i32* %rem, align 4
  %add = add nsw i32 %10, 4
  store i32 %add, i32* %rem, align 4
  %11 = load i32, i32* %re, align 4
  %inc = add nsw i32 %11, 1
  store i32 %inc, i32* %re, align 4
  br label %if.end11

if.end11:                                         ; preds = %if.then10, %while.body
  %12 = load i32, i32* %rem, align 4
  %add12 = add nsw i32 %12, 48
  %conv13 = trunc i32 %add12 to i8
  %13 = load i8*, i8** %p, align 4
  %incdec.ptr = getelementptr inbounds i8, i8* %13, i32 1
  store i8* %incdec.ptr, i8** %p, align 4
  store i8 %conv13, i8* %13, align 1
  %14 = load i8*, i8** %p, align 4
  %incdec.ptr14 = getelementptr inbounds i8, i8* %14, i32 1
  store i8* %incdec.ptr14, i8** %p, align 4
  store i8 48, i8* %14, align 1
  %15 = load i8*, i8** %p, align 4
  store i8 0, i8* %15, align 1
  br label %while.cond

while.end:                                        ; preds = %while.cond
  %16 = load i32, i32* %im, align 4
  %cmp15 = icmp ne i32 %16, 0
  br i1 %cmp15, label %if.then17, label %if.end53

if.then17:                                        ; preds = %while.end
  store i32 1, i32* %index, align 4
  %rel18 = getelementptr inbounds %struct.Complex, %struct.Complex* %.compoundliteral, i32 0, i32 0
  store double 0.000000e+00, double* %rel18, align 8
  %img19 = getelementptr inbounds %struct.Complex, %struct.Complex* %.compoundliteral, i32 0, i32 1
  %img20 = getelementptr inbounds %struct.Complex, %struct.Complex* %c, i32 0, i32 1
  %17 = load double, double* %img20, align 8
  store double %17, double* %img19, align 8
  %rel22 = getelementptr inbounds %struct.Complex, %struct.Complex* %.compoundliteral21, i32 0, i32 0
  store double 0.000000e+00, double* %rel22, align 8
  %img23 = getelementptr inbounds %struct.Complex, %struct.Complex* %.compoundliteral21, i32 0, i32 1
  store double 2.000000e+00, double* %img23, align 8
  call void @divComplex(%struct.Complex* sret align 8 %fc, %struct.Complex* byval(%struct.Complex) align 8 %.compoundliteral, %struct.Complex* byval(%struct.Complex) align 8 %.compoundliteral21)
  %rel24 = getelementptr inbounds %struct.Complex, %struct.Complex* %fc, i32 0, i32 0
  %18 = load double, double* %rel24, align 8
  store double %18, double* %f, align 8
  %19 = load double, double* %f, align 8
  %20 = call double @llvm.ceil.f64(double %19)
  %conv25 = fptosi double %20 to i32
  store i32 %conv25, i32* %im, align 4
  %21 = load double, double* %f, align 8
  %22 = load i32, i32* %im, align 4
  %conv26 = sitofp i32 %22 to double
  %sub = fsub double %21, %conv26
  %mul = fmul double -4.000000e+00, %sub
  store double %mul, double* %f, align 8
  br label %while.cond27

while.cond27:                                     ; preds = %if.end49, %if.then17
  %23 = load i32, i32* %im, align 4
  %cmp28 = icmp ne i32 %23, 0
  br i1 %cmp28, label %while.body30, label %while.end51

while.body30:                                     ; preds = %while.cond27
  %24 = load i32, i32* %im, align 4
  %rem32 = srem i32 %24, -4
  store i32 %rem32, i32* %rem31, align 4
  %25 = load i32, i32* %im, align 4
  %div33 = sdiv i32 %25, -4
  store i32 %div33, i32* %im, align 4
  %26 = load i32, i32* %rem31, align 4
  %cmp34 = icmp slt i32 %26, 0
  br i1 %cmp34, label %if.then36, label %if.end39

if.then36:                                        ; preds = %while.body30
  %27 = load i32, i32* %rem31, align 4
  %add37 = add nsw i32 %27, 4
  store i32 %add37, i32* %rem31, align 4
  %28 = load i32, i32* %im, align 4
  %inc38 = add nsw i32 %28, 1
  store i32 %inc38, i32* %im, align 4
  br label %if.end39

if.end39:                                         ; preds = %if.then36, %while.body30
  %29 = load i32, i32* %index, align 4
  %30 = load i8*, i8** %p, align 4
  %31 = load i8*, i8** %out.addr, align 4
  %sub.ptr.lhs.cast = ptrtoint i8* %30 to i32
  %sub.ptr.rhs.cast = ptrtoint i8* %31 to i32
  %sub.ptr.sub = sub i32 %sub.ptr.lhs.cast, %sub.ptr.rhs.cast
  %cmp40 = icmp ult i32 %29, %sub.ptr.sub
  br i1 %cmp40, label %if.then42, label %if.else

if.then42:                                        ; preds = %if.end39
  %32 = load i32, i32* %rem31, align 4
  %add43 = add nsw i32 %32, 48
  %conv44 = trunc i32 %add43 to i8
  %33 = load i8*, i8** %out.addr, align 4
  %34 = load i32, i32* %index, align 4
  %arrayidx = getelementptr inbounds i8, i8* %33, i32 %34
  store i8 %conv44, i8* %arrayidx, align 1
  br label %if.end49

if.else:                                          ; preds = %if.end39
  %35 = load i8*, i8** %p, align 4
  %incdec.ptr45 = getelementptr inbounds i8, i8* %35, i32 1
  store i8* %incdec.ptr45, i8** %p, align 4
  store i8 48, i8* %35, align 1
  %36 = load i32, i32* %rem31, align 4
  %add46 = add nsw i32 %36, 48
  %conv47 = trunc i32 %add46 to i8
  %37 = load i8*, i8** %p, align 4
  %incdec.ptr48 = getelementptr inbounds i8, i8* %37, i32 1
  store i8* %incdec.ptr48, i8** %p, align 4
  store i8 %conv47, i8* %37, align 1
  %38 = load i8*, i8** %p, align 4
  store i8 0, i8* %38, align 1
  br label %if.end49

if.end49:                                         ; preds = %if.else, %if.then42
  %39 = load i32, i32* %index, align 4
  %add50 = add i32 %39, 2
  store i32 %add50, i32* %index, align 4
  br label %while.cond27

while.end51:                                      ; preds = %while.cond27
  %40 = load double, double* %f, align 8
  %conv52 = fptosi double %40 to i32
  store i32 %conv52, i32* %fi, align 4
  br label %if.end53

if.end53:                                         ; preds = %while.end51, %while.end
  %41 = load i8*, i8** %out.addr, align 4
  %42 = load i8*, i8** %p, align 4
  call void @reverse(i8* %41, i8* %42)
  %43 = load i32, i32* %fi, align 4
  %cmp54 = icmp ne i32 %43, -1
  br i1 %cmp54, label %if.then56, label %if.end61

if.then56:                                        ; preds = %if.end53
  %44 = load i8*, i8** %p, align 4
  %incdec.ptr57 = getelementptr inbounds i8, i8* %44, i32 1
  store i8* %incdec.ptr57, i8** %p, align 4
  store i8 46, i8* %44, align 1
  %45 = load i32, i32* %fi, align 4
  %add58 = add nsw i32 %45, 48
  %conv59 = trunc i32 %add58 to i8
  %46 = load i8*, i8** %p, align 4
  %incdec.ptr60 = getelementptr inbounds i8, i8* %46, i32 1
  store i8* %incdec.ptr60, i8** %p, align 4
  store i8 %conv59, i8* %46, align 1
  %47 = load i8*, i8** %p, align 4
  store i8 0, i8* %47, align 1
  br label %if.end61

if.end61:                                         ; preds = %if.then56, %if.end53
  br label %while.cond62

while.cond62:                                     ; preds = %for.end, %if.end61
  %48 = load i8*, i8** %out.addr, align 4
  %arrayidx63 = getelementptr inbounds i8, i8* %48, i32 0
  %49 = load i8, i8* %arrayidx63, align 1
  %conv64 = sext i8 %49 to i32
  %cmp65 = icmp eq i32 %conv64, 48
  br i1 %cmp65, label %land.rhs, label %land.end

land.rhs:                                         ; preds = %while.cond62
  %50 = load i8*, i8** %out.addr, align 4
  %arrayidx67 = getelementptr inbounds i8, i8* %50, i32 1
  %51 = load i8, i8* %arrayidx67, align 1
  %conv68 = sext i8 %51 to i32
  %cmp69 = icmp ne i32 %conv68, 46
  br label %land.end

land.end:                                         ; preds = %land.rhs, %while.cond62
  %52 = phi i1 [ false, %while.cond62 ], [ %cmp69, %land.rhs ]
  br i1 %52, label %while.body71, label %while.end80

while.body71:                                     ; preds = %land.end
  store i32 0, i32* %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %while.body71
  %53 = load i8*, i8** %out.addr, align 4
  %54 = load i32, i32* %i, align 4
  %arrayidx72 = getelementptr inbounds i8, i8* %53, i32 %54
  %55 = load i8, i8* %arrayidx72, align 1
  %conv73 = sext i8 %55 to i32
  %cmp74 = icmp ne i32 %conv73, 0
  br i1 %cmp74, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %56 = load i8*, i8** %out.addr, align 4
  %57 = load i32, i32* %i, align 4
  %add76 = add i32 %57, 1
  %arrayidx77 = getelementptr inbounds i8, i8* %56, i32 %add76
  %58 = load i8, i8* %arrayidx77, align 1
  %59 = load i8*, i8** %out.addr, align 4
  %60 = load i32, i32* %i, align 4
  %arrayidx78 = getelementptr inbounds i8, i8* %59, i32 %60
  store i8 %58, i8* %arrayidx78, align 1
  br label %for.inc

for.inc:                                          ; preds = %for.body
  %61 = load i32, i32* %i, align 4
  %inc79 = add i32 %61, 1
  store i32 %inc79, i32* %i, align 4
  br label %for.cond

for.end:                                          ; preds = %for.cond
  br label %while.cond62

while.end80:                                      ; preds = %land.end
  %62 = load i8*, i8** %out.addr, align 4
  %63 = load i8, i8* %62, align 1
  %conv81 = sext i8 %63 to i32
  %cmp82 = icmp eq i32 %conv81, 46
  br i1 %cmp82, label %if.then84, label %if.end86

if.then84:                                        ; preds = %while.end80
  %64 = load i8*, i8** %out.addr, align 4
  %65 = load i8*, i8** %p, align 4
  call void @reverse(i8* %64, i8* %65)
  %66 = load i8*, i8** %p, align 4
  %incdec.ptr85 = getelementptr inbounds i8, i8* %66, i32 1
  store i8* %incdec.ptr85, i8** %p, align 4
  store i8 48, i8* %66, align 1
  %67 = load i8*, i8** %p, align 4
  store i8 0, i8* %67, align 1
  %68 = load i8*, i8** %out.addr, align 4
  %69 = load i8*, i8** %p, align 4
  call void @reverse(i8* %68, i8* %69)
  br label %if.end86

if.end86:                                         ; preds = %if.then84, %while.end80
  %70 = load i8*, i8** %out.addr, align 4
  call void @makeQuaterImaginary(%struct.QuaterImaginary* sret align 4 %agg.result, i8* %70)
  br label %return

return:                                           ; preds = %if.end86, %if.then
  ret void
}

; Function Attrs: nounwind readnone speculatable willreturn
declare double @llvm.ceil.f64(double %0) #4

; Function Attrs: noinline nounwind optnone
define hidden i32 @main() #0 {
entry:
  %retval = alloca i32, align 4
  %buffer = alloca [16 x i8], align 16
  %i = alloca i32, align 4
  %c1 = alloca %struct.Complex, align 8
  %qi = alloca %struct.QuaterImaginary, align 4
  %c2 = alloca %struct.Complex, align 8
  %tmp = alloca %struct.Complex, align 8
  %tmp3 = alloca %struct.QuaterImaginary, align 4
  %tmp5 = alloca %struct.Complex, align 8
  %c114 = alloca %struct.Complex, align 8
  %qi18 = alloca %struct.QuaterImaginary, align 4
  %c220 = alloca %struct.Complex, align 8
  %tmp24 = alloca %struct.Complex, align 8
  %tmp25 = alloca %struct.QuaterImaginary, align 4
  %tmp27 = alloca %struct.Complex, align 8
  store i32 0, i32* %retval, align 4
  store i32 1, i32* %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %0 = load i32, i32* %i, align 4
  %cmp = icmp sle i32 %0, 16
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %rel = getelementptr inbounds %struct.Complex, %struct.Complex* %c1, i32 0, i32 0
  %1 = load i32, i32* %i, align 4
  %conv = sitofp i32 %1 to double
  store double %conv, double* %rel, align 8
  %img = getelementptr inbounds %struct.Complex, %struct.Complex* %c1, i32 0, i32 1
  store double 0.000000e+00, double* %img, align 8
  %arraydecay = getelementptr inbounds [16 x i8], [16 x i8]* %buffer, i32 0, i32 0
  call void @c2qi(%struct.QuaterImaginary* sret align 4 %qi, %struct.Complex* byval(%struct.Complex) align 8 %c1, i8* %arraydecay)
  call void @qi2c(%struct.Complex* sret align 8 %c2, %struct.QuaterImaginary* byval(%struct.QuaterImaginary) align 4 %qi)
  call void @printComplex(%struct.Complex* byval(%struct.Complex) align 8 %c1)
  %call = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.4, i32 0, i32 0))
  call void @printQuaterImaginary(%struct.QuaterImaginary* byval(%struct.QuaterImaginary) align 4 %qi)
  %call1 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.4, i32 0, i32 0))
  call void @printComplex(%struct.Complex* byval(%struct.Complex) align 8 %c2)
  %call2 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([6 x i8], [6 x i8]* @.str.5, i32 0, i32 0))
  call void @negComplex(%struct.Complex* sret align 8 %tmp, %struct.Complex* byval(%struct.Complex) align 8 %c1)
  %2 = bitcast %struct.Complex* %c1 to i8*
  %3 = bitcast %struct.Complex* %tmp to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 8 %2, i8* align 8 %3, i32 16, i1 false)
  %arraydecay4 = getelementptr inbounds [16 x i8], [16 x i8]* %buffer, i32 0, i32 0
  call void @c2qi(%struct.QuaterImaginary* sret align 4 %tmp3, %struct.Complex* byval(%struct.Complex) align 8 %c1, i8* %arraydecay4)
  %4 = bitcast %struct.QuaterImaginary* %qi to i8*
  %5 = bitcast %struct.QuaterImaginary* %tmp3 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 4 %4, i8* align 4 %5, i32 8, i1 false)
  call void @qi2c(%struct.Complex* sret align 8 %tmp5, %struct.QuaterImaginary* byval(%struct.QuaterImaginary) align 4 %qi)
  %6 = bitcast %struct.Complex* %c2 to i8*
  %7 = bitcast %struct.Complex* %tmp5 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 8 %6, i8* align 8 %7, i32 16, i1 false)
  call void @printComplex(%struct.Complex* byval(%struct.Complex) align 8 %c1)
  %call6 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.4, i32 0, i32 0))
  call void @printQuaterImaginary(%struct.QuaterImaginary* byval(%struct.QuaterImaginary) align 4 %qi)
  %call7 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.4, i32 0, i32 0))
  call void @printComplex(%struct.Complex* byval(%struct.Complex) align 8 %c2)
  %call8 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([2 x i8], [2 x i8]* @.str.6, i32 0, i32 0))
  br label %for.inc

for.inc:                                          ; preds = %for.body
  %8 = load i32, i32* %i, align 4
  %inc = add nsw i32 %8, 1
  store i32 %inc, i32* %i, align 4
  br label %for.cond

for.end:                                          ; preds = %for.cond
  %call9 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([2 x i8], [2 x i8]* @.str.6, i32 0, i32 0))
  store i32 1, i32* %i, align 4
  br label %for.cond10

for.cond10:                                       ; preds = %for.inc31, %for.end
  %9 = load i32, i32* %i, align 4
  %cmp11 = icmp sle i32 %9, 16
  br i1 %cmp11, label %for.body13, label %for.end33

for.body13:                                       ; preds = %for.cond10
  %rel15 = getelementptr inbounds %struct.Complex, %struct.Complex* %c114, i32 0, i32 0
  store double 0.000000e+00, double* %rel15, align 8
  %img16 = getelementptr inbounds %struct.Complex, %struct.Complex* %c114, i32 0, i32 1
  %10 = load i32, i32* %i, align 4
  %conv17 = sitofp i32 %10 to double
  store double %conv17, double* %img16, align 8
  %arraydecay19 = getelementptr inbounds [16 x i8], [16 x i8]* %buffer, i32 0, i32 0
  call void @c2qi(%struct.QuaterImaginary* sret align 4 %qi18, %struct.Complex* byval(%struct.Complex) align 8 %c114, i8* %arraydecay19)
  call void @qi2c(%struct.Complex* sret align 8 %c220, %struct.QuaterImaginary* byval(%struct.QuaterImaginary) align 4 %qi18)
  call void @printComplex(%struct.Complex* byval(%struct.Complex) align 8 %c114)
  %call21 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.4, i32 0, i32 0))
  call void @printQuaterImaginary(%struct.QuaterImaginary* byval(%struct.QuaterImaginary) align 4 %qi18)
  %call22 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.4, i32 0, i32 0))
  call void @printComplex(%struct.Complex* byval(%struct.Complex) align 8 %c220)
  %call23 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([6 x i8], [6 x i8]* @.str.5, i32 0, i32 0))
  call void @negComplex(%struct.Complex* sret align 8 %tmp24, %struct.Complex* byval(%struct.Complex) align 8 %c114)
  %11 = bitcast %struct.Complex* %c114 to i8*
  %12 = bitcast %struct.Complex* %tmp24 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 8 %11, i8* align 8 %12, i32 16, i1 false)
  %arraydecay26 = getelementptr inbounds [16 x i8], [16 x i8]* %buffer, i32 0, i32 0
  call void @c2qi(%struct.QuaterImaginary* sret align 4 %tmp25, %struct.Complex* byval(%struct.Complex) align 8 %c114, i8* %arraydecay26)
  %13 = bitcast %struct.QuaterImaginary* %qi18 to i8*
  %14 = bitcast %struct.QuaterImaginary* %tmp25 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 4 %13, i8* align 4 %14, i32 8, i1 false)
  call void @qi2c(%struct.Complex* sret align 8 %tmp27, %struct.QuaterImaginary* byval(%struct.QuaterImaginary) align 4 %qi18)
  %15 = bitcast %struct.Complex* %c220 to i8*
  %16 = bitcast %struct.Complex* %tmp27 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 8 %15, i8* align 8 %16, i32 16, i1 false)
  call void @printComplex(%struct.Complex* byval(%struct.Complex) align 8 %c114)
  %call28 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.4, i32 0, i32 0))
  call void @printQuaterImaginary(%struct.QuaterImaginary* byval(%struct.QuaterImaginary) align 4 %qi18)
  %call29 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.4, i32 0, i32 0))
  call void @printComplex(%struct.Complex* byval(%struct.Complex) align 8 %c220)
  %call30 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([2 x i8], [2 x i8]* @.str.6, i32 0, i32 0))
  br label %for.inc31

for.inc31:                                        ; preds = %for.body13
  %17 = load i32, i32* %i, align 4
  %inc32 = add nsw i32 %17, 1
  store i32 %inc32, i32* %i, align 4
  br label %for.cond10

for.end33:                                        ; preds = %for.cond10
  ret i32 0
}

attributes #0 = { noinline nounwind optnone "correctly-rounded-divide-sqrt-fp-math"="false" "disable-tail-calls"="false" "frame-pointer"="none" "less-precise-fpmad"="false" "min-legal-vector-width"="0" "no-infs-fp-math"="false" "no-jump-tables"="false" "no-nans-fp-math"="false" "no-signed-zeros-fp-math"="false" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="generic" "unsafe-fp-math"="false" "use-soft-float"="false" }
attributes #1 = { "correctly-rounded-divide-sqrt-fp-math"="false" "disable-tail-calls"="false" "frame-pointer"="none" "less-precise-fpmad"="false" "no-infs-fp-math"="false" "no-nans-fp-math"="false" "no-signed-zeros-fp-math"="false" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="generic" "unsafe-fp-math"="false" "use-soft-float"="false" }
attributes #2 = { nounwind readonly "correctly-rounded-divide-sqrt-fp-math"="false" "disable-tail-calls"="false" "frame-pointer"="none" "less-precise-fpmad"="false" "no-infs-fp-math"="false" "no-nans-fp-math"="false" "no-signed-zeros-fp-math"="false" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="generic" "unsafe-fp-math"="false" "use-soft-float"="false" }
attributes #3 = { argmemonly nounwind willreturn }
attributes #4 = { nounwind readnone speculatable willreturn }
attributes #5 = { nounwind readonly }

!llvm.module.flags = !{!0}
!llvm.ident = !{!1}

!0 = !{i32 1, !"wchar_size", i32 4}
!1 = !{!"clang version 11.0.0 (https://github.com/Jacarte/llvm-project.git 0f6dea67136cc1e0b3d200eb2bb165628970c44b)"}

; extracted candidates

; *****
; For LLVM instruction:
;  %0 = load i32, i32* %valid, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %tobool = icmp ne i32 %0, 0
; Looking for a replacement for:
%0:i32 = var
%1:i1 = ne 0:i32, %0
infer %1
#########################################################
; exiting Souper's runOnFunction() for printQuaterImaginary()

; entering Souper's runOnFunction() for qi2c()

; ModuleID = './Imaginary_base_numbers.c.bc'
source_filename = "./Imaginary_base_numbers.c"
target datalayout = "e-m:e-p:32:32-i64:64-n32:64-S128"
target triple = "wasm32-unknown-wasi"

%struct.Complex = type { double, double }
%struct.QuaterImaginary = type { i8*, i32 }

@.str = private unnamed_addr constant [17 x i8] c"(%3.0f + %3.0fi)\00", align 1
@TWO_I = hidden constant %struct.Complex { double 0.000000e+00, double 2.000000e+00 }, align 8
@INV_TWO_I = hidden constant %struct.Complex { double 0.000000e+00, double -5.000000e-01 }, align 8
@.str.1 = private unnamed_addr constant [4 x i8] c"%8s\00", align 1
@.str.2 = private unnamed_addr constant [9 x i8] c" ERROR  \00", align 1
@.str.3 = private unnamed_addr constant [2 x i8] c"0\00", align 1
@.str.4 = private unnamed_addr constant [5 x i8] c" -> \00", align 1
@.str.5 = private unnamed_addr constant [6 x i8] c"     \00", align 1
@.str.6 = private unnamed_addr constant [2 x i8] c"\0A\00", align 1
@llvm.used = appending global [1 x i8*] [i8* bitcast (i32 ()* @__main_void to i8*)], section "llvm.metadata"

@__main_void = alias i32 (), i32 ()* @main

; Function Attrs: noinline nounwind optnone
define hidden i32 @find(i8* %s, i8 signext %c) #0 {
entry:
  %retval = alloca i32, align 4
  %s.addr = alloca i8*, align 4
  %c.addr = alloca i8, align 1
  %i = alloca i8*, align 4
  store i8* %s, i8** %s.addr, align 4
  store i8 %c, i8* %c.addr, align 1
  %0 = load i8*, i8** %s.addr, align 4
  store i8* %0, i8** %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %1 = load i8*, i8** %i, align 4
  %2 = load i8, i8* %1, align 1
  %conv = sext i8 %2 to i32
  %cmp = icmp ne i32 %conv, 0
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %3 = load i8*, i8** %i, align 4
  %4 = load i8, i8* %3, align 1
  %conv2 = sext i8 %4 to i32
  %5 = load i8, i8* %c.addr, align 1
  %conv3 = sext i8 %5 to i32
  %cmp4 = icmp eq i32 %conv2, %conv3
  br i1 %cmp4, label %if.then, label %if.end

if.then:                                          ; preds = %for.body
  %6 = load i8*, i8** %i, align 4
  %7 = load i8*, i8** %s.addr, align 4
  %sub.ptr.lhs.cast = ptrtoint i8* %6 to i32
  %sub.ptr.rhs.cast = ptrtoint i8* %7 to i32
  %sub.ptr.sub = sub i32 %sub.ptr.lhs.cast, %sub.ptr.rhs.cast
  store i32 %sub.ptr.sub, i32* %retval, align 4
  br label %return

if.end:                                           ; preds = %for.body
  br label %for.inc

for.inc:                                          ; preds = %if.end
  %8 = load i8*, i8** %i, align 4
  %incdec.ptr = getelementptr inbounds i8, i8* %8, i32 1
  store i8* %incdec.ptr, i8** %i, align 4
  br label %for.cond

for.end:                                          ; preds = %for.cond
  store i32 -1, i32* %retval, align 4
  br label %return

return:                                           ; preds = %for.end, %if.then
  %9 = load i32, i32* %retval, align 4
  ret i32 %9
}

; Function Attrs: noinline nounwind optnone
define hidden void @reverse(i8* %b, i8* %e) #0 {
entry:
  %b.addr = alloca i8*, align 4
  %e.addr = alloca i8*, align 4
  %t = alloca i8, align 1
  store i8* %b, i8** %b.addr, align 4
  store i8* %e, i8** %e.addr, align 4
  %0 = load i8*, i8** %e.addr, align 4
  %incdec.ptr = getelementptr inbounds i8, i8* %0, i32 -1
  store i8* %incdec.ptr, i8** %e.addr, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %1 = load i8*, i8** %b.addr, align 4
  %2 = load i8*, i8** %e.addr, align 4
  %cmp = icmp ult i8* %1, %2
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %3 = load i8*, i8** %b.addr, align 4
  %4 = load i8, i8* %3, align 1
  store i8 %4, i8* %t, align 1
  %5 = load i8*, i8** %e.addr, align 4
  %6 = load i8, i8* %5, align 1
  %7 = load i8*, i8** %b.addr, align 4
  store i8 %6, i8* %7, align 1
  %8 = load i8, i8* %t, align 1
  %9 = load i8*, i8** %e.addr, align 4
  store i8 %8, i8* %9, align 1
  br label %for.inc

for.inc:                                          ; preds = %for.body
  %10 = load i8*, i8** %b.addr, align 4
  %incdec.ptr1 = getelementptr inbounds i8, i8* %10, i32 1
  store i8* %incdec.ptr1, i8** %b.addr, align 4
  %11 = load i8*, i8** %e.addr, align 4
  %incdec.ptr2 = getelementptr inbounds i8, i8* %11, i32 -1
  store i8* %incdec.ptr2, i8** %e.addr, align 4
  br label %for.cond

for.end:                                          ; preds = %for.cond
  ret void
}

; Function Attrs: noinline nounwind optnone
define hidden void @printComplex(%struct.Complex* byval(%struct.Complex) align 8 %c) #0 {
entry:
  %rel = getelementptr inbounds %struct.Complex, %struct.Complex* %c, i32 0, i32 0
  %0 = load double, double* %rel, align 8
  %img = getelementptr inbounds %struct.Complex, %struct.Complex* %c, i32 0, i32 1
  %1 = load double, double* %img, align 8
  %call = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([17 x i8], [17 x i8]* @.str, i32 0, i32 0), double %0, double %1)
  ret void
}

declare i32 @printf(i8* %0, ...) #1

; Function Attrs: noinline nounwind optnone
define hidden void @makeComplex(%struct.Complex* noalias sret align 8 %agg.result, double %rel, double %img) #0 {
entry:
  %rel.addr = alloca double, align 8
  %img.addr = alloca double, align 8
  store double %rel, double* %rel.addr, align 8
  store double %img, double* %img.addr, align 8
  %rel1 = getelementptr inbounds %struct.Complex, %struct.Complex* %agg.result, i32 0, i32 0
  %0 = load double, double* %rel.addr, align 8
  store double %0, double* %rel1, align 8
  %img2 = getelementptr inbounds %struct.Complex, %struct.Complex* %agg.result, i32 0, i32 1
  %1 = load double, double* %img.addr, align 8
  store double %1, double* %img2, align 8
  ret void
}

; Function Attrs: noinline nounwind optnone
define hidden void @addComplex(%struct.Complex* noalias sret align 8 %agg.result, %struct.Complex* byval(%struct.Complex) align 8 %a, %struct.Complex* byval(%struct.Complex) align 8 %b) #0 {
entry:
  %rel = getelementptr inbounds %struct.Complex, %struct.Complex* %agg.result, i32 0, i32 0
  %rel1 = getelementptr inbounds %struct.Complex, %struct.Complex* %a, i32 0, i32 0
  %0 = load double, double* %rel1, align 8
  %rel2 = getelementptr inbounds %struct.Complex, %struct.Complex* %b, i32 0, i32 0
  %1 = load double, double* %rel2, align 8
  %add = fadd double %0, %1
  store double %add, double* %rel, align 8
  %img = getelementptr inbounds %struct.Complex, %struct.Complex* %agg.result, i32 0, i32 1
  %img3 = getelementptr inbounds %struct.Complex, %struct.Complex* %a, i32 0, i32 1
  %2 = load double, double* %img3, align 8
  %img4 = getelementptr inbounds %struct.Complex, %struct.Complex* %b, i32 0, i32 1
  %3 = load double, double* %img4, align 8
  %add5 = fadd double %2, %3
  store double %add5, double* %img, align 8
  ret void
}

; Function Attrs: noinline nounwind optnone
define hidden void @mulComplex(%struct.Complex* noalias sret align 8 %agg.result, %struct.Complex* byval(%struct.Complex) align 8 %a, %struct.Complex* byval(%struct.Complex) align 8 %b) #0 {
entry:
  %rel = getelementptr inbounds %struct.Complex, %struct.Complex* %agg.result, i32 0, i32 0
  %rel1 = getelementptr inbounds %struct.Complex, %struct.Complex* %a, i32 0, i32 0
  %0 = load double, double* %rel1, align 8
  %rel2 = getelementptr inbounds %struct.Complex, %struct.Complex* %b, i32 0, i32 0
  %1 = load double, double* %rel2, align 8
  %mul = fmul double %0, %1
  %img = getelementptr inbounds %struct.Complex, %struct.Complex* %a, i32 0, i32 1
  %2 = load double, double* %img, align 8
  %img3 = getelementptr inbounds %struct.Complex, %struct.Complex* %b, i32 0, i32 1
  %3 = load double, double* %img3, align 8
  %mul4 = fmul double %2, %3
  %sub = fsub double %mul, %mul4
  store double %sub, double* %rel, align 8
  %img5 = getelementptr inbounds %struct.Complex, %struct.Complex* %agg.result, i32 0, i32 1
  %rel6 = getelementptr inbounds %struct.Complex, %struct.Complex* %a, i32 0, i32 0
  %4 = load double, double* %rel6, align 8
  %img7 = getelementptr inbounds %struct.Complex, %struct.Complex* %b, i32 0, i32 1
  %5 = load double, double* %img7, align 8
  %mul8 = fmul double %4, %5
  %img9 = getelementptr inbounds %struct.Complex, %struct.Complex* %a, i32 0, i32 1
  %6 = load double, double* %img9, align 8
  %rel10 = getelementptr inbounds %struct.Complex, %struct.Complex* %b, i32 0, i32 0
  %7 = load double, double* %rel10, align 8
  %mul11 = fmul double %6, %7
  %sub12 = fsub double %mul8, %mul11
  store double %sub12, double* %img5, align 8
  ret void
}

; Function Attrs: noinline nounwind optnone
define hidden void @mulComplexD(%struct.Complex* noalias sret align 8 %agg.result, %struct.Complex* byval(%struct.Complex) align 8 %a, double %b) #0 {
entry:
  %b.addr = alloca double, align 8
  store double %b, double* %b.addr, align 8
  %rel = getelementptr inbounds %struct.Complex, %struct.Complex* %agg.result, i32 0, i32 0
  %rel1 = getelementptr inbounds %struct.Complex, %struct.Complex* %a, i32 0, i32 0
  %0 = load double, double* %rel1, align 8
  %1 = load double, double* %b.addr, align 8
  %mul = fmul double %0, %1
  store double %mul, double* %rel, align 8
  %img = getelementptr inbounds %struct.Complex, %struct.Complex* %agg.result, i32 0, i32 1
  %img2 = getelementptr inbounds %struct.Complex, %struct.Complex* %a, i32 0, i32 1
  %2 = load double, double* %img2, align 8
  %3 = load double, double* %b.addr, align 8
  %mul3 = fmul double %2, %3
  store double %mul3, double* %img, align 8
  ret void
}

; Function Attrs: noinline nounwind optnone
define hidden void @negComplex(%struct.Complex* noalias sret align 8 %agg.result, %struct.Complex* byval(%struct.Complex) align 8 %a) #0 {
entry:
  call void @mulComplexD(%struct.Complex* sret align 8 %agg.result, %struct.Complex* byval(%struct.Complex) align 8 %a, double -1.000000e+00)
  ret void
}

; Function Attrs: noinline nounwind optnone
define hidden void @divComplex(%struct.Complex* noalias sret align 8 %agg.result, %struct.Complex* byval(%struct.Complex) align 8 %a, %struct.Complex* byval(%struct.Complex) align 8 %b) #0 {
entry:
  %re = alloca double, align 8
  %im = alloca double, align 8
  %d = alloca double, align 8
  %rel = getelementptr inbounds %struct.Complex, %struct.Complex* %a, i32 0, i32 0
  %0 = load double, double* %rel, align 8
  %rel1 = getelementptr inbounds %struct.Complex, %struct.Complex* %b, i32 0, i32 0
  %1 = load double, double* %rel1, align 8
  %mul = fmul double %0, %1
  %img = getelementptr inbounds %struct.Complex, %struct.Complex* %a, i32 0, i32 1
  %2 = load double, double* %img, align 8
  %img2 = getelementptr inbounds %struct.Complex, %struct.Complex* %b, i32 0, i32 1
  %3 = load double, double* %img2, align 8
  %mul3 = fmul double %2, %3
  %add = fadd double %mul, %mul3
  store double %add, double* %re, align 8
  %img4 = getelementptr inbounds %struct.Complex, %struct.Complex* %a, i32 0, i32 1
  %4 = load double, double* %img4, align 8
  %rel5 = getelementptr inbounds %struct.Complex, %struct.Complex* %b, i32 0, i32 0
  %5 = load double, double* %rel5, align 8
  %mul6 = fmul double %4, %5
  %rel7 = getelementptr inbounds %struct.Complex, %struct.Complex* %a, i32 0, i32 0
  %6 = load double, double* %rel7, align 8
  %img8 = getelementptr inbounds %struct.Complex, %struct.Complex* %b, i32 0, i32 1
  %7 = load double, double* %img8, align 8
  %mul9 = fmul double %6, %7
  %sub = fsub double %mul6, %mul9
  store double %sub, double* %im, align 8
  %rel10 = getelementptr inbounds %struct.Complex, %struct.Complex* %b, i32 0, i32 0
  %8 = load double, double* %rel10, align 8
  %rel11 = getelementptr inbounds %struct.Complex, %struct.Complex* %b, i32 0, i32 0
  %9 = load double, double* %rel11, align 8
  %mul12 = fmul double %8, %9
  %img13 = getelementptr inbounds %struct.Complex, %struct.Complex* %b, i32 0, i32 1
  %10 = load double, double* %img13, align 8
  %img14 = getelementptr inbounds %struct.Complex, %struct.Complex* %b, i32 0, i32 1
  %11 = load double, double* %img14, align 8
  %mul15 = fmul double %10, %11
  %add16 = fadd double %mul12, %mul15
  store double %add16, double* %d, align 8
  %rel17 = getelementptr inbounds %struct.Complex, %struct.Complex* %agg.result, i32 0, i32 0
  %12 = load double, double* %re, align 8
  %13 = load double, double* %d, align 8
  %div = fdiv double %12, %13
  store double %div, double* %rel17, align 8
  %img18 = getelementptr inbounds %struct.Complex, %struct.Complex* %agg.result, i32 0, i32 1
  %14 = load double, double* %im, align 8
  %15 = load double, double* %d, align 8
  %div19 = fdiv double %14, %15
  store double %div19, double* %img18, align 8
  ret void
}

; Function Attrs: noinline nounwind optnone
define hidden void @inv(%struct.Complex* noalias sret align 8 %agg.result, %struct.Complex* byval(%struct.Complex) align 8 %c) #0 {
entry:
  %d = alloca double, align 8
  %rel = getelementptr inbounds %struct.Complex, %struct.Complex* %c, i32 0, i32 0
  %0 = load double, double* %rel, align 8
  %rel1 = getelementptr inbounds %struct.Complex, %struct.Complex* %c, i32 0, i32 0
  %1 = load double, double* %rel1, align 8
  %mul = fmul double %0, %1
  %img = getelementptr inbounds %struct.Complex, %struct.Complex* %c, i32 0, i32 1
  %2 = load double, double* %img, align 8
  %img2 = getelementptr inbounds %struct.Complex, %struct.Complex* %c, i32 0, i32 1
  %3 = load double, double* %img2, align 8
  %mul3 = fmul double %2, %3
  %add = fadd double %mul, %mul3
  store double %add, double* %d, align 8
  %rel4 = getelementptr inbounds %struct.Complex, %struct.Complex* %agg.result, i32 0, i32 0
  %rel5 = getelementptr inbounds %struct.Complex, %struct.Complex* %c, i32 0, i32 0
  %4 = load double, double* %rel5, align 8
  %5 = load double, double* %d, align 8
  %div = fdiv double %4, %5
  store double %div, double* %rel4, align 8
  %img6 = getelementptr inbounds %struct.Complex, %struct.Complex* %agg.result, i32 0, i32 1
  %img7 = getelementptr inbounds %struct.Complex, %struct.Complex* %c, i32 0, i32 1
  %6 = load double, double* %img7, align 8
  %fneg = fneg double %6
  %7 = load double, double* %d, align 8
  %div8 = fdiv double %fneg, %7
  store double %div8, double* %img6, align 8
  ret void
}

; Function Attrs: noinline nounwind optnone
define hidden void @makeQuaterImaginary(%struct.QuaterImaginary* noalias sret align 4 %agg.result, i8* %s) #0 {
entry:
  %s.addr = alloca i8*, align 4
  %i = alloca i32, align 4
  %valid1 = alloca i32, align 4
  %cnt = alloca i32, align 4
  store i8* %s, i8** %s.addr, align 4
  %b2i = getelementptr inbounds %struct.QuaterImaginary, %struct.QuaterImaginary* %agg.result, i32 0, i32 0
  %0 = load i8*, i8** %s.addr, align 4
  store i8* %0, i8** %b2i, align 4
  %valid = getelementptr inbounds %struct.QuaterImaginary, %struct.QuaterImaginary* %agg.result, i32 0, i32 1
  store i32 0, i32* %valid, align 4
  store i32 1, i32* %valid1, align 4
  store i32 0, i32* %cnt, align 4
  %1 = load i8*, i8** %s.addr, align 4
  %2 = load i8, i8* %1, align 1
  %conv = sext i8 %2 to i32
  %cmp = icmp ne i32 %conv, 0
  br i1 %cmp, label %if.then, label %if.end26

if.then:                                          ; preds = %entry
  store i32 0, i32* %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.then
  %3 = load i8*, i8** %s.addr, align 4
  %4 = load i32, i32* %i, align 4
  %arrayidx = getelementptr inbounds i8, i8* %3, i32 %4
  %5 = load i8, i8* %arrayidx, align 1
  %conv3 = sext i8 %5 to i32
  %cmp4 = icmp ne i32 %conv3, 0
  br i1 %cmp4, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %6 = load i8*, i8** %s.addr, align 4
  %7 = load i32, i32* %i, align 4
  %arrayidx6 = getelementptr inbounds i8, i8* %6, i32 %7
  %8 = load i8, i8* %arrayidx6, align 1
  %conv7 = sext i8 %8 to i32
  %cmp8 = icmp slt i32 %conv7, 48
  br i1 %cmp8, label %if.then14, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %for.body
  %9 = load i8*, i8** %s.addr, align 4
  %10 = load i32, i32* %i, align 4
  %arrayidx10 = getelementptr inbounds i8, i8* %9, i32 %10
  %11 = load i8, i8* %arrayidx10, align 1
  %conv11 = sext i8 %11 to i32
  %cmp12 = icmp slt i32 51, %conv11
  br i1 %cmp12, label %if.then14, label %if.end20

if.then14:                                        ; preds = %lor.lhs.false, %for.body
  %12 = load i8*, i8** %s.addr, align 4
  %13 = load i32, i32* %i, align 4
  %arrayidx15 = getelementptr inbounds i8, i8* %12, i32 %13
  %14 = load i8, i8* %arrayidx15, align 1
  %conv16 = sext i8 %14 to i32
  %cmp17 = icmp eq i32 %conv16, 46
  br i1 %cmp17, label %if.then19, label %if.else

if.then19:                                        ; preds = %if.then14
  %15 = load i32, i32* %cnt, align 4
  %inc = add i32 %15, 1
  store i32 %inc, i32* %cnt, align 4
  br label %if.end

if.else:                                          ; preds = %if.then14
  store i32 0, i32* %valid1, align 4
  br label %for.end

if.end:                                           ; preds = %if.then19
  br label %if.end20

if.end20:                                         ; preds = %if.end, %lor.lhs.false
  br label %for.inc

for.inc:                                          ; preds = %if.end20
  %16 = load i32, i32* %i, align 4
  %inc21 = add i32 %16, 1
  store i32 %inc21, i32* %i, align 4
  br label %for.cond

for.end:                                          ; preds = %if.else, %for.cond
  %17 = load i32, i32* %valid1, align 4
  %tobool = icmp ne i32 %17, 0
  br i1 %tobool, label %land.lhs.true, label %if.end25

land.lhs.true:                                    ; preds = %for.end
  %18 = load i32, i32* %cnt, align 4
  %cmp22 = icmp ugt i32 %18, 1
  br i1 %cmp22, label %if.then24, label %if.end25

if.then24:                                        ; preds = %land.lhs.true
  store i32 0, i32* %valid1, align 4
  br label %if.end25

if.end25:                                         ; preds = %if.then24, %land.lhs.true, %for.end
  br label %if.end26

if.end26:                                         ; preds = %if.end25, %entry
  %19 = load i32, i32* %valid1, align 4
  %valid27 = getelementptr inbounds %struct.QuaterImaginary, %struct.QuaterImaginary* %agg.result, i32 0, i32 1
  store i32 %19, i32* %valid27, align 4
  ret void
}

; Function Attrs: noinline nounwind optnone
define hidden void @printQuaterImaginary(%struct.QuaterImaginary* byval(%struct.QuaterImaginary) align 4 %qi) #0 {
entry:
  %valid = getelementptr inbounds %struct.QuaterImaginary, %struct.QuaterImaginary* %qi, i32 0, i32 1
  %0 = load i32, i32* %valid, align 4
  %tobool = icmp ne i32 %0, 0
  br i1 %tobool, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  %b2i = getelementptr inbounds %struct.QuaterImaginary, %struct.QuaterImaginary* %qi, i32 0, i32 0
  %1 = load i8*, i8** %b2i, align 4
  %call = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([4 x i8], [4 x i8]* @.str.1, i32 0, i32 0), i8* %1)
  br label %if.end

if.else:                                          ; preds = %entry
  %call1 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([9 x i8], [9 x i8]* @.str.2, i32 0, i32 0))
  br label %if.end

if.end:                                           ; preds = %if.else, %if.then
  ret void
}

; Function Attrs: noinline nounwind optnone
define hidden void @qi2c(%struct.Complex* noalias sret align 8 %agg.result, %struct.QuaterImaginary* byval(%struct.QuaterImaginary) align 4 %qi) #0 {
entry:
  %len = alloca i32, align 4
  %pointPos = alloca i32, align 4
  %posLen = alloca i32, align 4
  %prod = alloca %struct.Complex, align 8
  %j = alloca i32, align 4
  %k = alloca double, align 8
  %tmp = alloca %struct.Complex, align 8
  %agg.tmp = alloca %struct.Complex, align 8
  %tmp10 = alloca %struct.Complex, align 8
  %k18 = alloca double, align 8
  %tmp27 = alloca %struct.Complex, align 8
  %agg.tmp28 = alloca %struct.Complex, align 8
  %tmp30 = alloca %struct.Complex, align 8
  %b2i = getelementptr inbounds %struct.QuaterImaginary, %struct.QuaterImaginary* %qi, i32 0, i32 0
  %0 = load i8*, i8** %b2i, align 4
  %call = call i32 @strlen(i8* %0) #5
  store i32 %call, i32* %len, align 4
  %b2i1 = getelementptr inbounds %struct.QuaterImaginary, %struct.QuaterImaginary* %qi, i32 0, i32 0
  %1 = load i8*, i8** %b2i1, align 4
  %call2 = call i32 @find(i8* %1, i8 signext 46)
  store i32 %call2, i32* %pointPos, align 4
  %2 = load i32, i32* %pointPos, align 4
  %cmp = icmp sgt i32 %2, 0
  br i1 %cmp, label %cond.true, label %cond.false

cond.true:                                        ; preds = %entry
  %3 = load i32, i32* %pointPos, align 4
  br label %cond.end

cond.false:                                       ; preds = %entry
  %4 = load i32, i32* %len, align 4
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi i32 [ %3, %cond.true ], [ %4, %cond.false ]
  store i32 %cond, i32* %posLen, align 4
  call void @makeComplex(%struct.Complex* sret align 8 %agg.result, double 0.000000e+00, double 0.000000e+00)
  call void @makeComplex(%struct.Complex* sret align 8 %prod, double 1.000000e+00, double 0.000000e+00)
  store i32 0, i32* %j, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %cond.end
  %5 = load i32, i32* %j, align 4
  %6 = load i32, i32* %posLen, align 4
  %cmp3 = icmp ult i32 %5, %6
  br i1 %cmp3, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %b2i4 = getelementptr inbounds %struct.QuaterImaginary, %struct.QuaterImaginary* %qi, i32 0, i32 0
  %7 = load i8*, i8** %b2i4, align 4
  %8 = load i32, i32* %posLen, align 4
  %sub = sub i32 %8, 1
  %9 = load i32, i32* %j, align 4
  %sub5 = sub i32 %sub, %9
  %arrayidx = getelementptr inbounds i8, i8* %7, i32 %sub5
  %10 = load i8, i8* %arrayidx, align 1
  %conv = sext i8 %10 to i32
  %sub6 = sub nsw i32 %conv, 48
  %conv7 = sitofp i32 %sub6 to double
  store double %conv7, double* %k, align 8
  %11 = load double, double* %k, align 8
  %cmp8 = fcmp ogt double %11, 0.000000e+00
  br i1 %cmp8, label %if.then, label %if.end

if.then:                                          ; preds = %for.body
  %12 = load double, double* %k, align 8
  call void @mulComplexD(%struct.Complex* sret align 8 %agg.tmp, %struct.Complex* byval(%struct.Complex) align 8 %prod, double %12)
  call void @addComplex(%struct.Complex* sret align 8 %tmp, %struct.Complex* byval(%struct.Complex) align 8 %agg.result, %struct.Complex* byval(%struct.Complex) align 8 %agg.tmp)
  %13 = bitcast %struct.Complex* %agg.result to i8*
  %14 = bitcast %struct.Complex* %tmp to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 8 %13, i8* align 8 %14, i32 16, i1 false)
  br label %if.end

if.end:                                           ; preds = %if.then, %for.body
  call void @mulComplex(%struct.Complex* sret align 8 %tmp10, %struct.Complex* byval(%struct.Complex) align 8 %prod, %struct.Complex* byval(%struct.Complex) align 8 @TWO_I)
  %15 = bitcast %struct.Complex* %prod to i8*
  %16 = bitcast %struct.Complex* %tmp10 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 8 %15, i8* align 8 %16, i32 16, i1 false)
  br label %for.inc

for.inc:                                          ; preds = %if.end
  %17 = load i32, i32* %j, align 4
  %inc = add i32 %17, 1
  store i32 %inc, i32* %j, align 4
  br label %for.cond

for.end:                                          ; preds = %for.cond
  %18 = load i32, i32* %pointPos, align 4
  %cmp11 = icmp ne i32 %18, -1
  br i1 %cmp11, label %if.then13, label %if.end34

if.then13:                                        ; preds = %for.end
  %19 = bitcast %struct.Complex* %prod to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 8 %19, i8* align 8 bitcast (%struct.Complex* @INV_TWO_I to i8*), i32 16, i1 false)
  %20 = load i32, i32* %posLen, align 4
  %add = add i32 %20, 1
  store i32 %add, i32* %j, align 4
  br label %for.cond14

for.cond14:                                       ; preds = %for.inc31, %if.then13
  %21 = load i32, i32* %j, align 4
  %22 = load i32, i32* %len, align 4
  %cmp15 = icmp ult i32 %21, %22
  br i1 %cmp15, label %for.body17, label %for.end33

for.body17:                                       ; preds = %for.cond14
  %b2i19 = getelementptr inbounds %struct.QuaterImaginary, %struct.QuaterImaginary* %qi, i32 0, i32 0
  %23 = load i8*, i8** %b2i19, align 4
  %24 = load i32, i32* %j, align 4
  %arrayidx20 = getelementptr inbounds i8, i8* %23, i32 %24
  %25 = load i8, i8* %arrayidx20, align 1
  %conv21 = sext i8 %25 to i32
  %sub22 = sub nsw i32 %conv21, 48
  %conv23 = sitofp i32 %sub22 to double
  store double %conv23, double* %k18, align 8
  %26 = load double, double* %k18, align 8
  %cmp24 = fcmp ogt double %26, 0.000000e+00
  br i1 %cmp24, label %if.then26, label %if.end29

if.then26:                                        ; preds = %for.body17
  %27 = load double, double* %k18, align 8
  call void @mulComplexD(%struct.Complex* sret align 8 %agg.tmp28, %struct.Complex* byval(%struct.Complex) align 8 %prod, double %27)
  call void @addComplex(%struct.Complex* sret align 8 %tmp27, %struct.Complex* byval(%struct.Complex) align 8 %agg.result, %struct.Complex* byval(%struct.Complex) align 8 %agg.tmp28)
  %28 = bitcast %struct.Complex* %agg.result to i8*
  %29 = bitcast %struct.Complex* %tmp27 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 8 %28, i8* align 8 %29, i32 16, i1 false)
  br label %if.end29

if.end29:                                         ; preds = %if.then26, %for.body17
  call void @mulComplex(%struct.Complex* sret align 8 %tmp30, %struct.Complex* byval(%struct.Complex) align 8 %prod, %struct.Complex* byval(%struct.Complex) align 8 @INV_TWO_I)
  %30 = bitcast %struct.Complex* %prod to i8*
  %31 = bitcast %struct.Complex* %tmp30 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 8 %30, i8* align 8 %31, i32 16, i1 false)
  br label %for.inc31

for.inc31:                                        ; preds = %if.end29
  %32 = load i32, i32* %j, align 4
  %inc32 = add i32 %32, 1
  store i32 %inc32, i32* %j, align 4
  br label %for.cond14

for.end33:                                        ; preds = %for.cond14
  br label %if.end34

if.end34:                                         ; preds = %for.end33, %for.end
  ret void
}

; Function Attrs: nounwind readonly
declare i32 @strlen(i8* %0) #2

; Function Attrs: argmemonly nounwind willreturn
declare void @llvm.memcpy.p0i8.p0i8.i32(i8* noalias nocapture writeonly %0, i8* noalias nocapture readonly %1, i32 %2, i1 immarg %3) #3

; Function Attrs: noinline nounwind optnone
define hidden void @c2qi(%struct.QuaterImaginary* noalias sret align 4 %agg.result, %struct.Complex* byval(%struct.Complex) align 8 %c, i8* %out) #0 {
entry:
  %out.addr = alloca i8*, align 4
  %p = alloca i8*, align 4
  %re = alloca i32, align 4
  %im = alloca i32, align 4
  %fi = alloca i32, align 4
  %rem = alloca i32, align 4
  %index = alloca i32, align 4
  %fc = alloca %struct.Complex, align 8
  %.compoundliteral = alloca %struct.Complex, align 8
  %.compoundliteral21 = alloca %struct.Complex, align 8
  %f = alloca double, align 8
  %rem31 = alloca i32, align 4
  %i = alloca i32, align 4
  store i8* %out, i8** %out.addr, align 4
  %0 = load i8*, i8** %out.addr, align 4
  store i8* %0, i8** %p, align 4
  %1 = load i8*, i8** %p, align 4
  store i8 0, i8* %1, align 1
  %rel = getelementptr inbounds %struct.Complex, %struct.Complex* %c, i32 0, i32 0
  %2 = load double, double* %rel, align 8
  %cmp = fcmp oeq double %2, 0.000000e+00
  br i1 %cmp, label %land.lhs.true, label %if.end

land.lhs.true:                                    ; preds = %entry
  %img = getelementptr inbounds %struct.Complex, %struct.Complex* %c, i32 0, i32 1
  %3 = load double, double* %img, align 8
  %cmp1 = fcmp oeq double %3, 0.000000e+00
  br i1 %cmp1, label %if.then, label %if.end

if.then:                                          ; preds = %land.lhs.true
  call void @makeQuaterImaginary(%struct.QuaterImaginary* sret align 4 %agg.result, i8* getelementptr inbounds ([2 x i8], [2 x i8]* @.str.3, i32 0, i32 0))
  br label %return

if.end:                                           ; preds = %land.lhs.true, %entry
  %rel2 = getelementptr inbounds %struct.Complex, %struct.Complex* %c, i32 0, i32 0
  %4 = load double, double* %rel2, align 8
  %conv = fptosi double %4 to i32
  store i32 %conv, i32* %re, align 4
  %img3 = getelementptr inbounds %struct.Complex, %struct.Complex* %c, i32 0, i32 1
  %5 = load double, double* %img3, align 8
  %conv4 = fptosi double %5 to i32
  store i32 %conv4, i32* %im, align 4
  store i32 -1, i32* %fi, align 4
  br label %while.cond

while.cond:                                       ; preds = %if.end11, %if.end
  %6 = load i32, i32* %re, align 4
  %cmp5 = icmp ne i32 %6, 0
  br i1 %cmp5, label %while.body, label %while.end

while.body:                                       ; preds = %while.cond
  %7 = load i32, i32* %re, align 4
  %rem7 = srem i32 %7, -4
  store i32 %rem7, i32* %rem, align 4
  %8 = load i32, i32* %re, align 4
  %div = sdiv i32 %8, -4
  store i32 %div, i32* %re, align 4
  %9 = load i32, i32* %rem, align 4
  %cmp8 = icmp slt i32 %9, 0
  br i1 %cmp8, label %if.then10, label %if.end11

if.then10:                                        ; preds = %while.body
  %10 = load i32, i32* %rem, align 4
  %add = add nsw i32 %10, 4
  store i32 %add, i32* %rem, align 4
  %11 = load i32, i32* %re, align 4
  %inc = add nsw i32 %11, 1
  store i32 %inc, i32* %re, align 4
  br label %if.end11

if.end11:                                         ; preds = %if.then10, %while.body
  %12 = load i32, i32* %rem, align 4
  %add12 = add nsw i32 %12, 48
  %conv13 = trunc i32 %add12 to i8
  %13 = load i8*, i8** %p, align 4
  %incdec.ptr = getelementptr inbounds i8, i8* %13, i32 1
  store i8* %incdec.ptr, i8** %p, align 4
  store i8 %conv13, i8* %13, align 1
  %14 = load i8*, i8** %p, align 4
  %incdec.ptr14 = getelementptr inbounds i8, i8* %14, i32 1
  store i8* %incdec.ptr14, i8** %p, align 4
  store i8 48, i8* %14, align 1
  %15 = load i8*, i8** %p, align 4
  store i8 0, i8* %15, align 1
  br label %while.cond

while.end:                                        ; preds = %while.cond
  %16 = load i32, i32* %im, align 4
  %cmp15 = icmp ne i32 %16, 0
  br i1 %cmp15, label %if.then17, label %if.end53

if.then17:                                        ; preds = %while.end
  store i32 1, i32* %index, align 4
  %rel18 = getelementptr inbounds %struct.Complex, %struct.Complex* %.compoundliteral, i32 0, i32 0
  store double 0.000000e+00, double* %rel18, align 8
  %img19 = getelementptr inbounds %struct.Complex, %struct.Complex* %.compoundliteral, i32 0, i32 1
  %img20 = getelementptr inbounds %struct.Complex, %struct.Complex* %c, i32 0, i32 1
  %17 = load double, double* %img20, align 8
  store double %17, double* %img19, align 8
  %rel22 = getelementptr inbounds %struct.Complex, %struct.Complex* %.compoundliteral21, i32 0, i32 0
  store double 0.000000e+00, double* %rel22, align 8
  %img23 = getelementptr inbounds %struct.Complex, %struct.Complex* %.compoundliteral21, i32 0, i32 1
  store double 2.000000e+00, double* %img23, align 8
  call void @divComplex(%struct.Complex* sret align 8 %fc, %struct.Complex* byval(%struct.Complex) align 8 %.compoundliteral, %struct.Complex* byval(%struct.Complex) align 8 %.compoundliteral21)
  %rel24 = getelementptr inbounds %struct.Complex, %struct.Complex* %fc, i32 0, i32 0
  %18 = load double, double* %rel24, align 8
  store double %18, double* %f, align 8
  %19 = load double, double* %f, align 8
  %20 = call double @llvm.ceil.f64(double %19)
  %conv25 = fptosi double %20 to i32
  store i32 %conv25, i32* %im, align 4
  %21 = load double, double* %f, align 8
  %22 = load i32, i32* %im, align 4
  %conv26 = sitofp i32 %22 to double
  %sub = fsub double %21, %conv26
  %mul = fmul double -4.000000e+00, %sub
  store double %mul, double* %f, align 8
  br label %while.cond27

while.cond27:                                     ; preds = %if.end49, %if.then17
  %23 = load i32, i32* %im, align 4
  %cmp28 = icmp ne i32 %23, 0
  br i1 %cmp28, label %while.body30, label %while.end51

while.body30:                                     ; preds = %while.cond27
  %24 = load i32, i32* %im, align 4
  %rem32 = srem i32 %24, -4
  store i32 %rem32, i32* %rem31, align 4
  %25 = load i32, i32* %im, align 4
  %div33 = sdiv i32 %25, -4
  store i32 %div33, i32* %im, align 4
  %26 = load i32, i32* %rem31, align 4
  %cmp34 = icmp slt i32 %26, 0
  br i1 %cmp34, label %if.then36, label %if.end39

if.then36:                                        ; preds = %while.body30
  %27 = load i32, i32* %rem31, align 4
  %add37 = add nsw i32 %27, 4
  store i32 %add37, i32* %rem31, align 4
  %28 = load i32, i32* %im, align 4
  %inc38 = add nsw i32 %28, 1
  store i32 %inc38, i32* %im, align 4
  br label %if.end39

if.end39:                                         ; preds = %if.then36, %while.body30
  %29 = load i32, i32* %index, align 4
  %30 = load i8*, i8** %p, align 4
  %31 = load i8*, i8** %out.addr, align 4
  %sub.ptr.lhs.cast = ptrtoint i8* %30 to i32
  %sub.ptr.rhs.cast = ptrtoint i8* %31 to i32
  %sub.ptr.sub = sub i32 %sub.ptr.lhs.cast, %sub.ptr.rhs.cast
  %cmp40 = icmp ult i32 %29, %sub.ptr.sub
  br i1 %cmp40, label %if.then42, label %if.else

if.then42:                                        ; preds = %if.end39
  %32 = load i32, i32* %rem31, align 4
  %add43 = add nsw i32 %32, 48
  %conv44 = trunc i32 %add43 to i8
  %33 = load i8*, i8** %out.addr, align 4
  %34 = load i32, i32* %index, align 4
  %arrayidx = getelementptr inbounds i8, i8* %33, i32 %34
  store i8 %conv44, i8* %arrayidx, align 1
  br label %if.end49

if.else:                                          ; preds = %if.end39
  %35 = load i8*, i8** %p, align 4
  %incdec.ptr45 = getelementptr inbounds i8, i8* %35, i32 1
  store i8* %incdec.ptr45, i8** %p, align 4
  store i8 48, i8* %35, align 1
  %36 = load i32, i32* %rem31, align 4
  %add46 = add nsw i32 %36, 48
  %conv47 = trunc i32 %add46 to i8
  %37 = load i8*, i8** %p, align 4
  %incdec.ptr48 = getelementptr inbounds i8, i8* %37, i32 1
  store i8* %incdec.ptr48, i8** %p, align 4
  store i8 %conv47, i8* %37, align 1
  %38 = load i8*, i8** %p, align 4
  store i8 0, i8* %38, align 1
  br label %if.end49

if.end49:                                         ; preds = %if.else, %if.then42
  %39 = load i32, i32* %index, align 4
  %add50 = add i32 %39, 2
  store i32 %add50, i32* %index, align 4
  br label %while.cond27

while.end51:                                      ; preds = %while.cond27
  %40 = load double, double* %f, align 8
  %conv52 = fptosi double %40 to i32
  store i32 %conv52, i32* %fi, align 4
  br label %if.end53

if.end53:                                         ; preds = %while.end51, %while.end
  %41 = load i8*, i8** %out.addr, align 4
  %42 = load i8*, i8** %p, align 4
  call void @reverse(i8* %41, i8* %42)
  %43 = load i32, i32* %fi, align 4
  %cmp54 = icmp ne i32 %43, -1
  br i1 %cmp54, label %if.then56, label %if.end61

if.then56:                                        ; preds = %if.end53
  %44 = load i8*, i8** %p, align 4
  %incdec.ptr57 = getelementptr inbounds i8, i8* %44, i32 1
  store i8* %incdec.ptr57, i8** %p, align 4
  store i8 46, i8* %44, align 1
  %45 = load i32, i32* %fi, align 4
  %add58 = add nsw i32 %45, 48
  %conv59 = trunc i32 %add58 to i8
  %46 = load i8*, i8** %p, align 4
  %incdec.ptr60 = getelementptr inbounds i8, i8* %46, i32 1
  store i8* %incdec.ptr60, i8** %p, align 4
  store i8 %conv59, i8* %46, align 1
  %47 = load i8*, i8** %p, align 4
  store i8 0, i8* %47, align 1
  br label %if.end61

if.end61:                                         ; preds = %if.then56, %if.end53
  br label %while.cond62

while.cond62:                                     ; preds = %for.end, %if.end61
  %48 = load i8*, i8** %out.addr, align 4
  %arrayidx63 = getelementptr inbounds i8, i8* %48, i32 0
  %49 = load i8, i8* %arrayidx63, align 1
  %conv64 = sext i8 %49 to i32
  %cmp65 = icmp eq i32 %conv64, 48
  br i1 %cmp65, label %land.rhs, label %land.end

land.rhs:                                         ; preds = %while.cond62
  %50 = load i8*, i8** %out.addr, align 4
  %arrayidx67 = getelementptr inbounds i8, i8* %50, i32 1
  %51 = load i8, i8* %arrayidx67, align 1
  %conv68 = sext i8 %51 to i32
  %cmp69 = icmp ne i32 %conv68, 46
  br label %land.end

land.end:                                         ; preds = %land.rhs, %while.cond62
  %52 = phi i1 [ false, %while.cond62 ], [ %cmp69, %land.rhs ]
  br i1 %52, label %while.body71, label %while.end80

while.body71:                                     ; preds = %land.end
  store i32 0, i32* %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %while.body71
  %53 = load i8*, i8** %out.addr, align 4
  %54 = load i32, i32* %i, align 4
  %arrayidx72 = getelementptr inbounds i8, i8* %53, i32 %54
  %55 = load i8, i8* %arrayidx72, align 1
  %conv73 = sext i8 %55 to i32
  %cmp74 = icmp ne i32 %conv73, 0
  br i1 %cmp74, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %56 = load i8*, i8** %out.addr, align 4
  %57 = load i32, i32* %i, align 4
  %add76 = add i32 %57, 1
  %arrayidx77 = getelementptr inbounds i8, i8* %56, i32 %add76
  %58 = load i8, i8* %arrayidx77, align 1
  %59 = load i8*, i8** %out.addr, align 4
  %60 = load i32, i32* %i, align 4
  %arrayidx78 = getelementptr inbounds i8, i8* %59, i32 %60
  store i8 %58, i8* %arrayidx78, align 1
  br label %for.inc

for.inc:                                          ; preds = %for.body
  %61 = load i32, i32* %i, align 4
  %inc79 = add i32 %61, 1
  store i32 %inc79, i32* %i, align 4
  br label %for.cond

for.end:                                          ; preds = %for.cond
  br label %while.cond62

while.end80:                                      ; preds = %land.end
  %62 = load i8*, i8** %out.addr, align 4
  %63 = load i8, i8* %62, align 1
  %conv81 = sext i8 %63 to i32
  %cmp82 = icmp eq i32 %conv81, 46
  br i1 %cmp82, label %if.then84, label %if.end86

if.then84:                                        ; preds = %while.end80
  %64 = load i8*, i8** %out.addr, align 4
  %65 = load i8*, i8** %p, align 4
  call void @reverse(i8* %64, i8* %65)
  %66 = load i8*, i8** %p, align 4
  %incdec.ptr85 = getelementptr inbounds i8, i8* %66, i32 1
  store i8* %incdec.ptr85, i8** %p, align 4
  store i8 48, i8* %66, align 1
  %67 = load i8*, i8** %p, align 4
  store i8 0, i8* %67, align 1
  %68 = load i8*, i8** %out.addr, align 4
  %69 = load i8*, i8** %p, align 4
  call void @reverse(i8* %68, i8* %69)
  br label %if.end86

if.end86:                                         ; preds = %if.then84, %while.end80
  %70 = load i8*, i8** %out.addr, align 4
  call void @makeQuaterImaginary(%struct.QuaterImaginary* sret align 4 %agg.result, i8* %70)
  br label %return

return:                                           ; preds = %if.end86, %if.then
  ret void
}

; Function Attrs: nounwind readnone speculatable willreturn
declare double @llvm.ceil.f64(double %0) #4

; Function Attrs: noinline nounwind optnone
define hidden i32 @main() #0 {
entry:
  %retval = alloca i32, align 4
  %buffer = alloca [16 x i8], align 16
  %i = alloca i32, align 4
  %c1 = alloca %struct.Complex, align 8
  %qi = alloca %struct.QuaterImaginary, align 4
  %c2 = alloca %struct.Complex, align 8
  %tmp = alloca %struct.Complex, align 8
  %tmp3 = alloca %struct.QuaterImaginary, align 4
  %tmp5 = alloca %struct.Complex, align 8
  %c114 = alloca %struct.Complex, align 8
  %qi18 = alloca %struct.QuaterImaginary, align 4
  %c220 = alloca %struct.Complex, align 8
  %tmp24 = alloca %struct.Complex, align 8
  %tmp25 = alloca %struct.QuaterImaginary, align 4
  %tmp27 = alloca %struct.Complex, align 8
  store i32 0, i32* %retval, align 4
  store i32 1, i32* %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %0 = load i32, i32* %i, align 4
  %cmp = icmp sle i32 %0, 16
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %rel = getelementptr inbounds %struct.Complex, %struct.Complex* %c1, i32 0, i32 0
  %1 = load i32, i32* %i, align 4
  %conv = sitofp i32 %1 to double
  store double %conv, double* %rel, align 8
  %img = getelementptr inbounds %struct.Complex, %struct.Complex* %c1, i32 0, i32 1
  store double 0.000000e+00, double* %img, align 8
  %arraydecay = getelementptr inbounds [16 x i8], [16 x i8]* %buffer, i32 0, i32 0
  call void @c2qi(%struct.QuaterImaginary* sret align 4 %qi, %struct.Complex* byval(%struct.Complex) align 8 %c1, i8* %arraydecay)
  call void @qi2c(%struct.Complex* sret align 8 %c2, %struct.QuaterImaginary* byval(%struct.QuaterImaginary) align 4 %qi)
  call void @printComplex(%struct.Complex* byval(%struct.Complex) align 8 %c1)
  %call = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.4, i32 0, i32 0))
  call void @printQuaterImaginary(%struct.QuaterImaginary* byval(%struct.QuaterImaginary) align 4 %qi)
  %call1 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.4, i32 0, i32 0))
  call void @printComplex(%struct.Complex* byval(%struct.Complex) align 8 %c2)
  %call2 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([6 x i8], [6 x i8]* @.str.5, i32 0, i32 0))
  call void @negComplex(%struct.Complex* sret align 8 %tmp, %struct.Complex* byval(%struct.Complex) align 8 %c1)
  %2 = bitcast %struct.Complex* %c1 to i8*
  %3 = bitcast %struct.Complex* %tmp to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 8 %2, i8* align 8 %3, i32 16, i1 false)
  %arraydecay4 = getelementptr inbounds [16 x i8], [16 x i8]* %buffer, i32 0, i32 0
  call void @c2qi(%struct.QuaterImaginary* sret align 4 %tmp3, %struct.Complex* byval(%struct.Complex) align 8 %c1, i8* %arraydecay4)
  %4 = bitcast %struct.QuaterImaginary* %qi to i8*
  %5 = bitcast %struct.QuaterImaginary* %tmp3 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 4 %4, i8* align 4 %5, i32 8, i1 false)
  call void @qi2c(%struct.Complex* sret align 8 %tmp5, %struct.QuaterImaginary* byval(%struct.QuaterImaginary) align 4 %qi)
  %6 = bitcast %struct.Complex* %c2 to i8*
  %7 = bitcast %struct.Complex* %tmp5 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 8 %6, i8* align 8 %7, i32 16, i1 false)
  call void @printComplex(%struct.Complex* byval(%struct.Complex) align 8 %c1)
  %call6 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.4, i32 0, i32 0))
  call void @printQuaterImaginary(%struct.QuaterImaginary* byval(%struct.QuaterImaginary) align 4 %qi)
  %call7 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.4, i32 0, i32 0))
  call void @printComplex(%struct.Complex* byval(%struct.Complex) align 8 %c2)
  %call8 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([2 x i8], [2 x i8]* @.str.6, i32 0, i32 0))
  br label %for.inc

for.inc:                                          ; preds = %for.body
  %8 = load i32, i32* %i, align 4
  %inc = add nsw i32 %8, 1
  store i32 %inc, i32* %i, align 4
  br label %for.cond

for.end:                                          ; preds = %for.cond
  %call9 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([2 x i8], [2 x i8]* @.str.6, i32 0, i32 0))
  store i32 1, i32* %i, align 4
  br label %for.cond10

for.cond10:                                       ; preds = %for.inc31, %for.end
  %9 = load i32, i32* %i, align 4
  %cmp11 = icmp sle i32 %9, 16
  br i1 %cmp11, label %for.body13, label %for.end33

for.body13:                                       ; preds = %for.cond10
  %rel15 = getelementptr inbounds %struct.Complex, %struct.Complex* %c114, i32 0, i32 0
  store double 0.000000e+00, double* %rel15, align 8
  %img16 = getelementptr inbounds %struct.Complex, %struct.Complex* %c114, i32 0, i32 1
  %10 = load i32, i32* %i, align 4
  %conv17 = sitofp i32 %10 to double
  store double %conv17, double* %img16, align 8
  %arraydecay19 = getelementptr inbounds [16 x i8], [16 x i8]* %buffer, i32 0, i32 0
  call void @c2qi(%struct.QuaterImaginary* sret align 4 %qi18, %struct.Complex* byval(%struct.Complex) align 8 %c114, i8* %arraydecay19)
  call void @qi2c(%struct.Complex* sret align 8 %c220, %struct.QuaterImaginary* byval(%struct.QuaterImaginary) align 4 %qi18)
  call void @printComplex(%struct.Complex* byval(%struct.Complex) align 8 %c114)
  %call21 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.4, i32 0, i32 0))
  call void @printQuaterImaginary(%struct.QuaterImaginary* byval(%struct.QuaterImaginary) align 4 %qi18)
  %call22 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.4, i32 0, i32 0))
  call void @printComplex(%struct.Complex* byval(%struct.Complex) align 8 %c220)
  %call23 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([6 x i8], [6 x i8]* @.str.5, i32 0, i32 0))
  call void @negComplex(%struct.Complex* sret align 8 %tmp24, %struct.Complex* byval(%struct.Complex) align 8 %c114)
  %11 = bitcast %struct.Complex* %c114 to i8*
  %12 = bitcast %struct.Complex* %tmp24 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 8 %11, i8* align 8 %12, i32 16, i1 false)
  %arraydecay26 = getelementptr inbounds [16 x i8], [16 x i8]* %buffer, i32 0, i32 0
  call void @c2qi(%struct.QuaterImaginary* sret align 4 %tmp25, %struct.Complex* byval(%struct.Complex) align 8 %c114, i8* %arraydecay26)
  %13 = bitcast %struct.QuaterImaginary* %qi18 to i8*
  %14 = bitcast %struct.QuaterImaginary* %tmp25 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 4 %13, i8* align 4 %14, i32 8, i1 false)
  call void @qi2c(%struct.Complex* sret align 8 %tmp27, %struct.QuaterImaginary* byval(%struct.QuaterImaginary) align 4 %qi18)
  %15 = bitcast %struct.Complex* %c220 to i8*
  %16 = bitcast %struct.Complex* %tmp27 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 8 %15, i8* align 8 %16, i32 16, i1 false)
  call void @printComplex(%struct.Complex* byval(%struct.Complex) align 8 %c114)
  %call28 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.4, i32 0, i32 0))
  call void @printQuaterImaginary(%struct.QuaterImaginary* byval(%struct.QuaterImaginary) align 4 %qi18)
  %call29 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.4, i32 0, i32 0))
  call void @printComplex(%struct.Complex* byval(%struct.Complex) align 8 %c220)
  %call30 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([2 x i8], [2 x i8]* @.str.6, i32 0, i32 0))
  br label %for.inc31

for.inc31:                                        ; preds = %for.body13
  %17 = load i32, i32* %i, align 4
  %inc32 = add nsw i32 %17, 1
  store i32 %inc32, i32* %i, align 4
  br label %for.cond10

for.end33:                                        ; preds = %for.cond10
  ret i32 0
}

attributes #0 = { noinline nounwind optnone "correctly-rounded-divide-sqrt-fp-math"="false" "disable-tail-calls"="false" "frame-pointer"="none" "less-precise-fpmad"="false" "min-legal-vector-width"="0" "no-infs-fp-math"="false" "no-jump-tables"="false" "no-nans-fp-math"="false" "no-signed-zeros-fp-math"="false" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="generic" "unsafe-fp-math"="false" "use-soft-float"="false" }
attributes #1 = { "correctly-rounded-divide-sqrt-fp-math"="false" "disable-tail-calls"="false" "frame-pointer"="none" "less-precise-fpmad"="false" "no-infs-fp-math"="false" "no-nans-fp-math"="false" "no-signed-zeros-fp-math"="false" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="generic" "unsafe-fp-math"="false" "use-soft-float"="false" }
attributes #2 = { nounwind readonly "correctly-rounded-divide-sqrt-fp-math"="false" "disable-tail-calls"="false" "frame-pointer"="none" "less-precise-fpmad"="false" "no-infs-fp-math"="false" "no-nans-fp-math"="false" "no-signed-zeros-fp-math"="false" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="generic" "unsafe-fp-math"="false" "use-soft-float"="false" }
attributes #3 = { argmemonly nounwind willreturn }
attributes #4 = { nounwind readnone speculatable willreturn }
attributes #5 = { nounwind readonly }

!llvm.module.flags = !{!0}
!llvm.ident = !{!1}

!0 = !{i32 1, !"wchar_size", i32 4}
!1 = !{!"clang version 11.0.0 (https://github.com/Jacarte/llvm-project.git 0f6dea67136cc1e0b3d200eb2bb165628970c44b)"}

; extracted candidates

; *****
; For LLVM instruction:
;  %call = call i32 @strlen(i8* %0) #5
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %call2 = call i32 @find(i8* %1, i8 signext 46)
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %2 = load i32, i32* %pointPos, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %cmp = icmp sgt i32 %2, 0
; Looking for a replacement for:
%0:i32 = var
%1:i1 = slt 0:i32, %0
infer %1

; *****
; For LLVM instruction:
;  %3 = load i32, i32* %pointPos, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %4 = load i32, i32* %len, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %cond = phi i32 [ %3, %cond.true ], [ %4, %cond.false ]
; Looking for a replacement for:
%0 = block 2
%1:i32 = var
%2:i32 = var
%3:i32 = phi %0, %1, %2
infer %3

; *****
; For LLVM instruction:
;  %5 = load i32, i32* %j, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %6 = load i32, i32* %posLen, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %cmp3 = icmp ult i32 %5, %6
; Looking for a replacement for:
%0:i32 = var
%1:i32 = var
%2:i1 = ult %0, %1
infer %2

; *****
; For LLVM instruction:
;  %8 = load i32, i32* %posLen, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %sub = sub i32 %8, 1
; Looking for a replacement for:
%0:i32 = var
%1:i32 = sub %0, 1:i32
infer %1

; *****
; For LLVM instruction:
;  %9 = load i32, i32* %j, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %sub5 = sub i32 %sub, %9
; Looking for a replacement for:
%0:i32 = var
%1:i32 = sub %0, 1:i32
%2:i32 = var
%3:i32 = sub %1, %2
infer %3

; *****
; For LLVM instruction:
;  %10 = load i8, i8* %arrayidx, align 1
; Looking for a replacement for:
%0:i8 = var
infer %0

; *****
; For LLVM instruction:
;  %conv = sext i8 %10 to i32
; Looking for a replacement for:
%0:i8 = var
%1:i32 = sext %0
infer %1

; *****
; For LLVM instruction:
;  %sub6 = sub nsw i32 %conv, 48
; Looking for a replacement for:
%0:i8 = var
%1:i32 = sext %0
%2:i32 = subnsw %1, 48:i32
infer %2

; *****
; For LLVM instruction:
;  %cmp8 = fcmp ogt double %11, 0.000000e+00
; Looking for a replacement for:
%0:i1 = var
infer %0

; *****
; For LLVM instruction:
;  %17 = load i32, i32* %j, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %inc = add i32 %17, 1
; Looking for a replacement for:
%0:i32 = var
%1:i32 = add 1:i32, %0
infer %1

; *****
; For LLVM instruction:
;  %18 = load i32, i32* %pointPos, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %cmp11 = icmp ne i32 %18, -1
; Looking for a replacement for:
%0:i32 = var
%1:i1 = ne 4294967295:i32, %0
infer %1

; *****
; For LLVM instruction:
;  %20 = load i32, i32* %posLen, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %add = add i32 %20, 1
; Looking for a replacement for:
%0:i32 = var
%1:i32 = add 1:i32, %0
infer %1

; *****
; For LLVM instruction:
;  %21 = load i32, i32* %j, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %22 = load i32, i32* %len, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %cmp15 = icmp ult i32 %21, %22
; Looking for a replacement for:
%0:i32 = var
%1:i32 = var
%2:i1 = ult %0, %1
infer %2

; *****
; For LLVM instruction:
;  %24 = load i32, i32* %j, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %25 = load i8, i8* %arrayidx20, align 1
; Looking for a replacement for:
%0:i8 = var
infer %0

; *****
; For LLVM instruction:
;  %conv21 = sext i8 %25 to i32
; Looking for a replacement for:
%0:i8 = var
%1:i32 = sext %0
infer %1

; *****
; For LLVM instruction:
;  %sub22 = sub nsw i32 %conv21, 48
; Looking for a replacement for:
%0:i8 = var
%1:i32 = sext %0
%2:i32 = subnsw %1, 48:i32
infer %2

; *****
; For LLVM instruction:
;  %cmp24 = fcmp ogt double %26, 0.000000e+00
; Looking for a replacement for:
%0:i1 = var
infer %0

; *****
; For LLVM instruction:
;  %32 = load i32, i32* %j, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %inc32 = add i32 %32, 1
; Looking for a replacement for:
%0:i32 = var
%1:i32 = add 1:i32, %0
infer %1
got 2 candidates from LHS

-------------------------------------------------
%0:i32 = var
%1:i1 = slt 0:i32, %0
infer %1


--------------------------------
guess 0

%0:i1 = var ; reservedconst_1

Cost = 0
first query is SAT, returning the model:
reservedconst_1: 0
0 th attempt: second query is SAT-- constant doesn't work
first query is SAT, returning the model:
reservedconst_1: -1
1 th attempt: second query is SAT-- constant doesn't work
first query is UNSAT-- no more guesses
Dataflow Pruned 0/0
There are 1 Guesses
There are 0 RHSs before deduplication
There are 0 RHSs after deduplication
got 3 candidates from LHS

-------------------------------------------------
%0 = block 2
%1:i32 = var
%2:i32 = var
%3:i32 = phi %0, %1, %2
infer %3


--------------------------------
guess 0

%0:i32 = var ; reservedconst_1

Cost = 0
first query is SAT, returning the model:
reservedconst_1: 0
0 th attempt: second query is SAT-- constant doesn't work
first query is SAT, returning the model:
reservedconst_1: -1
1 th attempt: second query is SAT-- constant doesn't work
first query is UNSAT-- no more guesses

--------------------------------
guess 1

%0:i32 = var

Cost = 0
second query is SAT-- constant doesn't work

--------------------------------
guess 2

%0:i32 = var

Cost = 0
second query is SAT-- constant doesn't work
Dataflow Pruned 0/0
There are 3 Guesses
There are 0 RHSs before deduplication
There are 0 RHSs after deduplication
got 2 candidates from LHS

-------------------------------------------------
%0:i32 = var
%1:i32 = sub %0, 1:i32
infer %1


--------------------------------
guess 0

%0:i32 = var ; reservedconst_1

Cost = 0
first query is SAT, returning the model:
reservedconst_1: -1
0 th attempt: second query is SAT-- constant doesn't work
first query is SAT, returning the model:
reservedconst_1: -2
1 th attempt: second query is SAT-- constant doesn't work
first query is UNSAT-- no more guesses

--------------------------------
guess 1

%0:i32 = var

Cost = 0
second query is SAT-- constant doesn't work
Dataflow Pruned 0/0
There are 2 Guesses
There are 0 RHSs before deduplication
There are 0 RHSs after deduplication
got 4 candidates from LHS

-------------------------------------------------
%0:i32 = var
%1:i32 = sub %0, 1:i32
%2:i32 = var
%3:i32 = sub %1, %2
infer %3


--------------------------------
guess 0

%0:i32 = var ; reservedconst_1

Cost = 0
first query is SAT, returning the model:
reservedconst_1: -1
0 th attempt: second query is SAT-- constant doesn't work
first query is SAT, returning the model:
reservedconst_1: -2
1 th attempt: second query is SAT-- constant doesn't work
first query is UNSAT-- no more guesses

--------------------------------
guess 1

%0:i32 = var

Cost = 0
second query is SAT-- constant doesn't work

--------------------------------
guess 2

%0:i32 = var

Cost = 0
second query is SAT-- constant doesn't work

--------------------------------
guess 3

%0:i32 = var
%1:i32 = sub %0, 1:i32

Cost = 1
second query is SAT-- constant doesn't work
Dataflow Pruned 0/0
There are 4 Guesses
There are 0 RHSs before deduplication
There are 0 RHSs after deduplication
got 3 candidates from LHS

-------------------------------------------------
%0:i8 = var
%1:i32 = sext %0
%2:i32 = subnsw %1, 48:i32
infer %2


--------------------------------
guess 0

%0:i32 = var ; reservedconst_1

Cost = 0
first query is SAT, returning the model:
reservedconst_1: -48
0 th attempt: second query is SAT-- constant doesn't work
first query is SAT, returning the model:
reservedconst_1: 16
1 th attempt: second query is SAT-- constant doesn't work
first query is UNSAT-- no more guesses

--------------------------------
guess 1

%0:i8 = var
%1:i32 = sext %0

Cost = 1
second query is SAT-- constant doesn't work
Dataflow Pruned 0/0
There are 2 Guesses
There are 0 RHSs before deduplication
There are 0 RHSs after deduplication
got 1 candidates from LHS

-------------------------------------------------
%0:i1 = var
infer %0


--------------------------------
guess 0

%0:i1 = var ; reservedconst_1

Cost = 0
first query is SAT, returning the model:
reservedconst_1: 0
0 th attempt: second query is SAT-- constant doesn't work
first query is SAT, returning the model:
reservedconst_1: -1
1 th attempt: second query is SAT-- constant doesn't work
first query is UNSAT-- no more guesses
Dataflow Pruned 0/0
There are 1 Guesses
There are 0 RHSs before deduplication
There are 0 RHSs after deduplication
got 2 candidates from LHS

-------------------------------------------------
%0:i32 = var
%1:i1 = ne 4294967295:i32, %0
infer %1


--------------------------------
guess 0

%0:i1 = var ; reservedconst_1

Cost = 0
first query is SAT, returning the model:
reservedconst_1: -1
0 th attempt: second query is SAT-- constant doesn't work
first query is SAT, returning the model:
reservedconst_1: 0
1 th attempt: second query is SAT-- constant doesn't work
first query is UNSAT-- no more guesses
Dataflow Pruned 0/0
There are 1 Guesses
There are 0 RHSs before deduplication
There are 0 RHSs after deduplication
#########################################################
; exiting Souper's runOnFunction() for qi2c()

; entering Souper's runOnFunction() for c2qi()

; ModuleID = './Imaginary_base_numbers.c.bc'
source_filename = "./Imaginary_base_numbers.c"
target datalayout = "e-m:e-p:32:32-i64:64-n32:64-S128"
target triple = "wasm32-unknown-wasi"

%struct.Complex = type { double, double }
%struct.QuaterImaginary = type { i8*, i32 }

@.str = private unnamed_addr constant [17 x i8] c"(%3.0f + %3.0fi)\00", align 1
@TWO_I = hidden constant %struct.Complex { double 0.000000e+00, double 2.000000e+00 }, align 8
@INV_TWO_I = hidden constant %struct.Complex { double 0.000000e+00, double -5.000000e-01 }, align 8
@.str.1 = private unnamed_addr constant [4 x i8] c"%8s\00", align 1
@.str.2 = private unnamed_addr constant [9 x i8] c" ERROR  \00", align 1
@.str.3 = private unnamed_addr constant [2 x i8] c"0\00", align 1
@.str.4 = private unnamed_addr constant [5 x i8] c" -> \00", align 1
@.str.5 = private unnamed_addr constant [6 x i8] c"     \00", align 1
@.str.6 = private unnamed_addr constant [2 x i8] c"\0A\00", align 1
@llvm.used = appending global [1 x i8*] [i8* bitcast (i32 ()* @__main_void to i8*)], section "llvm.metadata"

@__main_void = alias i32 (), i32 ()* @main

; Function Attrs: noinline nounwind optnone
define hidden i32 @find(i8* %s, i8 signext %c) #0 {
entry:
  %retval = alloca i32, align 4
  %s.addr = alloca i8*, align 4
  %c.addr = alloca i8, align 1
  %i = alloca i8*, align 4
  store i8* %s, i8** %s.addr, align 4
  store i8 %c, i8* %c.addr, align 1
  %0 = load i8*, i8** %s.addr, align 4
  store i8* %0, i8** %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %1 = load i8*, i8** %i, align 4
  %2 = load i8, i8* %1, align 1
  %conv = sext i8 %2 to i32
  %cmp = icmp ne i32 %conv, 0
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %3 = load i8*, i8** %i, align 4
  %4 = load i8, i8* %3, align 1
  %conv2 = sext i8 %4 to i32
  %5 = load i8, i8* %c.addr, align 1
  %conv3 = sext i8 %5 to i32
  %cmp4 = icmp eq i32 %conv2, %conv3
  br i1 %cmp4, label %if.then, label %if.end

if.then:                                          ; preds = %for.body
  %6 = load i8*, i8** %i, align 4
  %7 = load i8*, i8** %s.addr, align 4
  %sub.ptr.lhs.cast = ptrtoint i8* %6 to i32
  %sub.ptr.rhs.cast = ptrtoint i8* %7 to i32
  %sub.ptr.sub = sub i32 %sub.ptr.lhs.cast, %sub.ptr.rhs.cast
  store i32 %sub.ptr.sub, i32* %retval, align 4
  br label %return

if.end:                                           ; preds = %for.body
  br label %for.inc

for.inc:                                          ; preds = %if.end
  %8 = load i8*, i8** %i, align 4
  %incdec.ptr = getelementptr inbounds i8, i8* %8, i32 1
  store i8* %incdec.ptr, i8** %i, align 4
  br label %for.cond

for.end:                                          ; preds = %for.cond
  store i32 -1, i32* %retval, align 4
  br label %return

return:                                           ; preds = %for.end, %if.then
  %9 = load i32, i32* %retval, align 4
  ret i32 %9
}

; Function Attrs: noinline nounwind optnone
define hidden void @reverse(i8* %b, i8* %e) #0 {
entry:
  %b.addr = alloca i8*, align 4
  %e.addr = alloca i8*, align 4
  %t = alloca i8, align 1
  store i8* %b, i8** %b.addr, align 4
  store i8* %e, i8** %e.addr, align 4
  %0 = load i8*, i8** %e.addr, align 4
  %incdec.ptr = getelementptr inbounds i8, i8* %0, i32 -1
  store i8* %incdec.ptr, i8** %e.addr, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %1 = load i8*, i8** %b.addr, align 4
  %2 = load i8*, i8** %e.addr, align 4
  %cmp = icmp ult i8* %1, %2
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %3 = load i8*, i8** %b.addr, align 4
  %4 = load i8, i8* %3, align 1
  store i8 %4, i8* %t, align 1
  %5 = load i8*, i8** %e.addr, align 4
  %6 = load i8, i8* %5, align 1
  %7 = load i8*, i8** %b.addr, align 4
  store i8 %6, i8* %7, align 1
  %8 = load i8, i8* %t, align 1
  %9 = load i8*, i8** %e.addr, align 4
  store i8 %8, i8* %9, align 1
  br label %for.inc

for.inc:                                          ; preds = %for.body
  %10 = load i8*, i8** %b.addr, align 4
  %incdec.ptr1 = getelementptr inbounds i8, i8* %10, i32 1
  store i8* %incdec.ptr1, i8** %b.addr, align 4
  %11 = load i8*, i8** %e.addr, align 4
  %incdec.ptr2 = getelementptr inbounds i8, i8* %11, i32 -1
  store i8* %incdec.ptr2, i8** %e.addr, align 4
  br label %for.cond

for.end:                                          ; preds = %for.cond
  ret void
}

; Function Attrs: noinline nounwind optnone
define hidden void @printComplex(%struct.Complex* byval(%struct.Complex) align 8 %c) #0 {
entry:
  %rel = getelementptr inbounds %struct.Complex, %struct.Complex* %c, i32 0, i32 0
  %0 = load double, double* %rel, align 8
  %img = getelementptr inbounds %struct.Complex, %struct.Complex* %c, i32 0, i32 1
  %1 = load double, double* %img, align 8
  %call = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([17 x i8], [17 x i8]* @.str, i32 0, i32 0), double %0, double %1)
  ret void
}

declare i32 @printf(i8* %0, ...) #1

; Function Attrs: noinline nounwind optnone
define hidden void @makeComplex(%struct.Complex* noalias sret align 8 %agg.result, double %rel, double %img) #0 {
entry:
  %rel.addr = alloca double, align 8
  %img.addr = alloca double, align 8
  store double %rel, double* %rel.addr, align 8
  store double %img, double* %img.addr, align 8
  %rel1 = getelementptr inbounds %struct.Complex, %struct.Complex* %agg.result, i32 0, i32 0
  %0 = load double, double* %rel.addr, align 8
  store double %0, double* %rel1, align 8
  %img2 = getelementptr inbounds %struct.Complex, %struct.Complex* %agg.result, i32 0, i32 1
  %1 = load double, double* %img.addr, align 8
  store double %1, double* %img2, align 8
  ret void
}

; Function Attrs: noinline nounwind optnone
define hidden void @addComplex(%struct.Complex* noalias sret align 8 %agg.result, %struct.Complex* byval(%struct.Complex) align 8 %a, %struct.Complex* byval(%struct.Complex) align 8 %b) #0 {
entry:
  %rel = getelementptr inbounds %struct.Complex, %struct.Complex* %agg.result, i32 0, i32 0
  %rel1 = getelementptr inbounds %struct.Complex, %struct.Complex* %a, i32 0, i32 0
  %0 = load double, double* %rel1, align 8
  %rel2 = getelementptr inbounds %struct.Complex, %struct.Complex* %b, i32 0, i32 0
  %1 = load double, double* %rel2, align 8
  %add = fadd double %0, %1
  store double %add, double* %rel, align 8
  %img = getelementptr inbounds %struct.Complex, %struct.Complex* %agg.result, i32 0, i32 1
  %img3 = getelementptr inbounds %struct.Complex, %struct.Complex* %a, i32 0, i32 1
  %2 = load double, double* %img3, align 8
  %img4 = getelementptr inbounds %struct.Complex, %struct.Complex* %b, i32 0, i32 1
  %3 = load double, double* %img4, align 8
  %add5 = fadd double %2, %3
  store double %add5, double* %img, align 8
  ret void
}

; Function Attrs: noinline nounwind optnone
define hidden void @mulComplex(%struct.Complex* noalias sret align 8 %agg.result, %struct.Complex* byval(%struct.Complex) align 8 %a, %struct.Complex* byval(%struct.Complex) align 8 %b) #0 {
entry:
  %rel = getelementptr inbounds %struct.Complex, %struct.Complex* %agg.result, i32 0, i32 0
  %rel1 = getelementptr inbounds %struct.Complex, %struct.Complex* %a, i32 0, i32 0
  %0 = load double, double* %rel1, align 8
  %rel2 = getelementptr inbounds %struct.Complex, %struct.Complex* %b, i32 0, i32 0
  %1 = load double, double* %rel2, align 8
  %mul = fmul double %0, %1
  %img = getelementptr inbounds %struct.Complex, %struct.Complex* %a, i32 0, i32 1
  %2 = load double, double* %img, align 8
  %img3 = getelementptr inbounds %struct.Complex, %struct.Complex* %b, i32 0, i32 1
  %3 = load double, double* %img3, align 8
  %mul4 = fmul double %2, %3
  %sub = fsub double %mul, %mul4
  store double %sub, double* %rel, align 8
  %img5 = getelementptr inbounds %struct.Complex, %struct.Complex* %agg.result, i32 0, i32 1
  %rel6 = getelementptr inbounds %struct.Complex, %struct.Complex* %a, i32 0, i32 0
  %4 = load double, double* %rel6, align 8
  %img7 = getelementptr inbounds %struct.Complex, %struct.Complex* %b, i32 0, i32 1
  %5 = load double, double* %img7, align 8
  %mul8 = fmul double %4, %5
  %img9 = getelementptr inbounds %struct.Complex, %struct.Complex* %a, i32 0, i32 1
  %6 = load double, double* %img9, align 8
  %rel10 = getelementptr inbounds %struct.Complex, %struct.Complex* %b, i32 0, i32 0
  %7 = load double, double* %rel10, align 8
  %mul11 = fmul double %6, %7
  %sub12 = fsub double %mul8, %mul11
  store double %sub12, double* %img5, align 8
  ret void
}

; Function Attrs: noinline nounwind optnone
define hidden void @mulComplexD(%struct.Complex* noalias sret align 8 %agg.result, %struct.Complex* byval(%struct.Complex) align 8 %a, double %b) #0 {
entry:
  %b.addr = alloca double, align 8
  store double %b, double* %b.addr, align 8
  %rel = getelementptr inbounds %struct.Complex, %struct.Complex* %agg.result, i32 0, i32 0
  %rel1 = getelementptr inbounds %struct.Complex, %struct.Complex* %a, i32 0, i32 0
  %0 = load double, double* %rel1, align 8
  %1 = load double, double* %b.addr, align 8
  %mul = fmul double %0, %1
  store double %mul, double* %rel, align 8
  %img = getelementptr inbounds %struct.Complex, %struct.Complex* %agg.result, i32 0, i32 1
  %img2 = getelementptr inbounds %struct.Complex, %struct.Complex* %a, i32 0, i32 1
  %2 = load double, double* %img2, align 8
  %3 = load double, double* %b.addr, align 8
  %mul3 = fmul double %2, %3
  store double %mul3, double* %img, align 8
  ret void
}

; Function Attrs: noinline nounwind optnone
define hidden void @negComplex(%struct.Complex* noalias sret align 8 %agg.result, %struct.Complex* byval(%struct.Complex) align 8 %a) #0 {
entry:
  call void @mulComplexD(%struct.Complex* sret align 8 %agg.result, %struct.Complex* byval(%struct.Complex) align 8 %a, double -1.000000e+00)
  ret void
}

; Function Attrs: noinline nounwind optnone
define hidden void @divComplex(%struct.Complex* noalias sret align 8 %agg.result, %struct.Complex* byval(%struct.Complex) align 8 %a, %struct.Complex* byval(%struct.Complex) align 8 %b) #0 {
entry:
  %re = alloca double, align 8
  %im = alloca double, align 8
  %d = alloca double, align 8
  %rel = getelementptr inbounds %struct.Complex, %struct.Complex* %a, i32 0, i32 0
  %0 = load double, double* %rel, align 8
  %rel1 = getelementptr inbounds %struct.Complex, %struct.Complex* %b, i32 0, i32 0
  %1 = load double, double* %rel1, align 8
  %mul = fmul double %0, %1
  %img = getelementptr inbounds %struct.Complex, %struct.Complex* %a, i32 0, i32 1
  %2 = load double, double* %img, align 8
  %img2 = getelementptr inbounds %struct.Complex, %struct.Complex* %b, i32 0, i32 1
  %3 = load double, double* %img2, align 8
  %mul3 = fmul double %2, %3
  %add = fadd double %mul, %mul3
  store double %add, double* %re, align 8
  %img4 = getelementptr inbounds %struct.Complex, %struct.Complex* %a, i32 0, i32 1
  %4 = load double, double* %img4, align 8
  %rel5 = getelementptr inbounds %struct.Complex, %struct.Complex* %b, i32 0, i32 0
  %5 = load double, double* %rel5, align 8
  %mul6 = fmul double %4, %5
  %rel7 = getelementptr inbounds %struct.Complex, %struct.Complex* %a, i32 0, i32 0
  %6 = load double, double* %rel7, align 8
  %img8 = getelementptr inbounds %struct.Complex, %struct.Complex* %b, i32 0, i32 1
  %7 = load double, double* %img8, align 8
  %mul9 = fmul double %6, %7
  %sub = fsub double %mul6, %mul9
  store double %sub, double* %im, align 8
  %rel10 = getelementptr inbounds %struct.Complex, %struct.Complex* %b, i32 0, i32 0
  %8 = load double, double* %rel10, align 8
  %rel11 = getelementptr inbounds %struct.Complex, %struct.Complex* %b, i32 0, i32 0
  %9 = load double, double* %rel11, align 8
  %mul12 = fmul double %8, %9
  %img13 = getelementptr inbounds %struct.Complex, %struct.Complex* %b, i32 0, i32 1
  %10 = load double, double* %img13, align 8
  %img14 = getelementptr inbounds %struct.Complex, %struct.Complex* %b, i32 0, i32 1
  %11 = load double, double* %img14, align 8
  %mul15 = fmul double %10, %11
  %add16 = fadd double %mul12, %mul15
  store double %add16, double* %d, align 8
  %rel17 = getelementptr inbounds %struct.Complex, %struct.Complex* %agg.result, i32 0, i32 0
  %12 = load double, double* %re, align 8
  %13 = load double, double* %d, align 8
  %div = fdiv double %12, %13
  store double %div, double* %rel17, align 8
  %img18 = getelementptr inbounds %struct.Complex, %struct.Complex* %agg.result, i32 0, i32 1
  %14 = load double, double* %im, align 8
  %15 = load double, double* %d, align 8
  %div19 = fdiv double %14, %15
  store double %div19, double* %img18, align 8
  ret void
}

; Function Attrs: noinline nounwind optnone
define hidden void @inv(%struct.Complex* noalias sret align 8 %agg.result, %struct.Complex* byval(%struct.Complex) align 8 %c) #0 {
entry:
  %d = alloca double, align 8
  %rel = getelementptr inbounds %struct.Complex, %struct.Complex* %c, i32 0, i32 0
  %0 = load double, double* %rel, align 8
  %rel1 = getelementptr inbounds %struct.Complex, %struct.Complex* %c, i32 0, i32 0
  %1 = load double, double* %rel1, align 8
  %mul = fmul double %0, %1
  %img = getelementptr inbounds %struct.Complex, %struct.Complex* %c, i32 0, i32 1
  %2 = load double, double* %img, align 8
  %img2 = getelementptr inbounds %struct.Complex, %struct.Complex* %c, i32 0, i32 1
  %3 = load double, double* %img2, align 8
  %mul3 = fmul double %2, %3
  %add = fadd double %mul, %mul3
  store double %add, double* %d, align 8
  %rel4 = getelementptr inbounds %struct.Complex, %struct.Complex* %agg.result, i32 0, i32 0
  %rel5 = getelementptr inbounds %struct.Complex, %struct.Complex* %c, i32 0, i32 0
  %4 = load double, double* %rel5, align 8
  %5 = load double, double* %d, align 8
  %div = fdiv double %4, %5
  store double %div, double* %rel4, align 8
  %img6 = getelementptr inbounds %struct.Complex, %struct.Complex* %agg.result, i32 0, i32 1
  %img7 = getelementptr inbounds %struct.Complex, %struct.Complex* %c, i32 0, i32 1
  %6 = load double, double* %img7, align 8
  %fneg = fneg double %6
  %7 = load double, double* %d, align 8
  %div8 = fdiv double %fneg, %7
  store double %div8, double* %img6, align 8
  ret void
}

; Function Attrs: noinline nounwind optnone
define hidden void @makeQuaterImaginary(%struct.QuaterImaginary* noalias sret align 4 %agg.result, i8* %s) #0 {
entry:
  %s.addr = alloca i8*, align 4
  %i = alloca i32, align 4
  %valid1 = alloca i32, align 4
  %cnt = alloca i32, align 4
  store i8* %s, i8** %s.addr, align 4
  %b2i = getelementptr inbounds %struct.QuaterImaginary, %struct.QuaterImaginary* %agg.result, i32 0, i32 0
  %0 = load i8*, i8** %s.addr, align 4
  store i8* %0, i8** %b2i, align 4
  %valid = getelementptr inbounds %struct.QuaterImaginary, %struct.QuaterImaginary* %agg.result, i32 0, i32 1
  store i32 0, i32* %valid, align 4
  store i32 1, i32* %valid1, align 4
  store i32 0, i32* %cnt, align 4
  %1 = load i8*, i8** %s.addr, align 4
  %2 = load i8, i8* %1, align 1
  %conv = sext i8 %2 to i32
  %cmp = icmp ne i32 %conv, 0
  br i1 %cmp, label %if.then, label %if.end26

if.then:                                          ; preds = %entry
  store i32 0, i32* %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.then
  %3 = load i8*, i8** %s.addr, align 4
  %4 = load i32, i32* %i, align 4
  %arrayidx = getelementptr inbounds i8, i8* %3, i32 %4
  %5 = load i8, i8* %arrayidx, align 1
  %conv3 = sext i8 %5 to i32
  %cmp4 = icmp ne i32 %conv3, 0
  br i1 %cmp4, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %6 = load i8*, i8** %s.addr, align 4
  %7 = load i32, i32* %i, align 4
  %arrayidx6 = getelementptr inbounds i8, i8* %6, i32 %7
  %8 = load i8, i8* %arrayidx6, align 1
  %conv7 = sext i8 %8 to i32
  %cmp8 = icmp slt i32 %conv7, 48
  br i1 %cmp8, label %if.then14, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %for.body
  %9 = load i8*, i8** %s.addr, align 4
  %10 = load i32, i32* %i, align 4
  %arrayidx10 = getelementptr inbounds i8, i8* %9, i32 %10
  %11 = load i8, i8* %arrayidx10, align 1
  %conv11 = sext i8 %11 to i32
  %cmp12 = icmp slt i32 51, %conv11
  br i1 %cmp12, label %if.then14, label %if.end20

if.then14:                                        ; preds = %lor.lhs.false, %for.body
  %12 = load i8*, i8** %s.addr, align 4
  %13 = load i32, i32* %i, align 4
  %arrayidx15 = getelementptr inbounds i8, i8* %12, i32 %13
  %14 = load i8, i8* %arrayidx15, align 1
  %conv16 = sext i8 %14 to i32
  %cmp17 = icmp eq i32 %conv16, 46
  br i1 %cmp17, label %if.then19, label %if.else

if.then19:                                        ; preds = %if.then14
  %15 = load i32, i32* %cnt, align 4
  %inc = add i32 %15, 1
  store i32 %inc, i32* %cnt, align 4
  br label %if.end

if.else:                                          ; preds = %if.then14
  store i32 0, i32* %valid1, align 4
  br label %for.end

if.end:                                           ; preds = %if.then19
  br label %if.end20

if.end20:                                         ; preds = %if.end, %lor.lhs.false
  br label %for.inc

for.inc:                                          ; preds = %if.end20
  %16 = load i32, i32* %i, align 4
  %inc21 = add i32 %16, 1
  store i32 %inc21, i32* %i, align 4
  br label %for.cond

for.end:                                          ; preds = %if.else, %for.cond
  %17 = load i32, i32* %valid1, align 4
  %tobool = icmp ne i32 %17, 0
  br i1 %tobool, label %land.lhs.true, label %if.end25

land.lhs.true:                                    ; preds = %for.end
  %18 = load i32, i32* %cnt, align 4
  %cmp22 = icmp ugt i32 %18, 1
  br i1 %cmp22, label %if.then24, label %if.end25

if.then24:                                        ; preds = %land.lhs.true
  store i32 0, i32* %valid1, align 4
  br label %if.end25

if.end25:                                         ; preds = %if.then24, %land.lhs.true, %for.end
  br label %if.end26

if.end26:                                         ; preds = %if.end25, %entry
  %19 = load i32, i32* %valid1, align 4
  %valid27 = getelementptr inbounds %struct.QuaterImaginary, %struct.QuaterImaginary* %agg.result, i32 0, i32 1
  store i32 %19, i32* %valid27, align 4
  ret void
}

; Function Attrs: noinline nounwind optnone
define hidden void @printQuaterImaginary(%struct.QuaterImaginary* byval(%struct.QuaterImaginary) align 4 %qi) #0 {
entry:
  %valid = getelementptr inbounds %struct.QuaterImaginary, %struct.QuaterImaginary* %qi, i32 0, i32 1
  %0 = load i32, i32* %valid, align 4
  %tobool = icmp ne i32 %0, 0
  br i1 %tobool, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  %b2i = getelementptr inbounds %struct.QuaterImaginary, %struct.QuaterImaginary* %qi, i32 0, i32 0
  %1 = load i8*, i8** %b2i, align 4
  %call = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([4 x i8], [4 x i8]* @.str.1, i32 0, i32 0), i8* %1)
  br label %if.end

if.else:                                          ; preds = %entry
  %call1 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([9 x i8], [9 x i8]* @.str.2, i32 0, i32 0))
  br label %if.end

if.end:                                           ; preds = %if.else, %if.then
  ret void
}

; Function Attrs: noinline nounwind optnone
define hidden void @qi2c(%struct.Complex* noalias sret align 8 %agg.result, %struct.QuaterImaginary* byval(%struct.QuaterImaginary) align 4 %qi) #0 {
entry:
  %len = alloca i32, align 4
  %pointPos = alloca i32, align 4
  %posLen = alloca i32, align 4
  %prod = alloca %struct.Complex, align 8
  %j = alloca i32, align 4
  %k = alloca double, align 8
  %tmp = alloca %struct.Complex, align 8
  %agg.tmp = alloca %struct.Complex, align 8
  %tmp10 = alloca %struct.Complex, align 8
  %k18 = alloca double, align 8
  %tmp27 = alloca %struct.Complex, align 8
  %agg.tmp28 = alloca %struct.Complex, align 8
  %tmp30 = alloca %struct.Complex, align 8
  %b2i = getelementptr inbounds %struct.QuaterImaginary, %struct.QuaterImaginary* %qi, i32 0, i32 0
  %0 = load i8*, i8** %b2i, align 4
  %call = call i32 @strlen(i8* %0) #5
  store i32 %call, i32* %len, align 4
  %b2i1 = getelementptr inbounds %struct.QuaterImaginary, %struct.QuaterImaginary* %qi, i32 0, i32 0
  %1 = load i8*, i8** %b2i1, align 4
  %call2 = call i32 @find(i8* %1, i8 signext 46)
  store i32 %call2, i32* %pointPos, align 4
  %2 = load i32, i32* %pointPos, align 4
  %cmp = icmp sgt i32 %2, 0
  br i1 %cmp, label %cond.true, label %cond.false

cond.true:                                        ; preds = %entry
  %3 = load i32, i32* %pointPos, align 4
  br label %cond.end

cond.false:                                       ; preds = %entry
  %4 = load i32, i32* %len, align 4
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi i32 [ %3, %cond.true ], [ %4, %cond.false ]
  store i32 %cond, i32* %posLen, align 4
  call void @makeComplex(%struct.Complex* sret align 8 %agg.result, double 0.000000e+00, double 0.000000e+00)
  call void @makeComplex(%struct.Complex* sret align 8 %prod, double 1.000000e+00, double 0.000000e+00)
  store i32 0, i32* %j, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %cond.end
  %5 = load i32, i32* %j, align 4
  %6 = load i32, i32* %posLen, align 4
  %cmp3 = icmp ult i32 %5, %6
  br i1 %cmp3, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %b2i4 = getelementptr inbounds %struct.QuaterImaginary, %struct.QuaterImaginary* %qi, i32 0, i32 0
  %7 = load i8*, i8** %b2i4, align 4
  %8 = load i32, i32* %posLen, align 4
  %sub = sub i32 %8, 1
  %9 = load i32, i32* %j, align 4
  %sub5 = sub i32 %sub, %9
  %arrayidx = getelementptr inbounds i8, i8* %7, i32 %sub5
  %10 = load i8, i8* %arrayidx, align 1
  %conv = sext i8 %10 to i32
  %sub6 = sub nsw i32 %conv, 48
  %conv7 = sitofp i32 %sub6 to double
  store double %conv7, double* %k, align 8
  %11 = load double, double* %k, align 8
  %cmp8 = fcmp ogt double %11, 0.000000e+00
  br i1 %cmp8, label %if.then, label %if.end

if.then:                                          ; preds = %for.body
  %12 = load double, double* %k, align 8
  call void @mulComplexD(%struct.Complex* sret align 8 %agg.tmp, %struct.Complex* byval(%struct.Complex) align 8 %prod, double %12)
  call void @addComplex(%struct.Complex* sret align 8 %tmp, %struct.Complex* byval(%struct.Complex) align 8 %agg.result, %struct.Complex* byval(%struct.Complex) align 8 %agg.tmp)
  %13 = bitcast %struct.Complex* %agg.result to i8*
  %14 = bitcast %struct.Complex* %tmp to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 8 %13, i8* align 8 %14, i32 16, i1 false)
  br label %if.end

if.end:                                           ; preds = %if.then, %for.body
  call void @mulComplex(%struct.Complex* sret align 8 %tmp10, %struct.Complex* byval(%struct.Complex) align 8 %prod, %struct.Complex* byval(%struct.Complex) align 8 @TWO_I)
  %15 = bitcast %struct.Complex* %prod to i8*
  %16 = bitcast %struct.Complex* %tmp10 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 8 %15, i8* align 8 %16, i32 16, i1 false)
  br label %for.inc

for.inc:                                          ; preds = %if.end
  %17 = load i32, i32* %j, align 4
  %inc = add i32 %17, 1
  store i32 %inc, i32* %j, align 4
  br label %for.cond

for.end:                                          ; preds = %for.cond
  %18 = load i32, i32* %pointPos, align 4
  %cmp11 = icmp ne i32 %18, -1
  br i1 %cmp11, label %if.then13, label %if.end34

if.then13:                                        ; preds = %for.end
  %19 = bitcast %struct.Complex* %prod to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 8 %19, i8* align 8 bitcast (%struct.Complex* @INV_TWO_I to i8*), i32 16, i1 false)
  %20 = load i32, i32* %posLen, align 4
  %add = add i32 %20, 1
  store i32 %add, i32* %j, align 4
  br label %for.cond14

for.cond14:                                       ; preds = %for.inc31, %if.then13
  %21 = load i32, i32* %j, align 4
  %22 = load i32, i32* %len, align 4
  %cmp15 = icmp ult i32 %21, %22
  br i1 %cmp15, label %for.body17, label %for.end33

for.body17:                                       ; preds = %for.cond14
  %b2i19 = getelementptr inbounds %struct.QuaterImaginary, %struct.QuaterImaginary* %qi, i32 0, i32 0
  %23 = load i8*, i8** %b2i19, align 4
  %24 = load i32, i32* %j, align 4
  %arrayidx20 = getelementptr inbounds i8, i8* %23, i32 %24
  %25 = load i8, i8* %arrayidx20, align 1
  %conv21 = sext i8 %25 to i32
  %sub22 = sub nsw i32 %conv21, 48
  %conv23 = sitofp i32 %sub22 to double
  store double %conv23, double* %k18, align 8
  %26 = load double, double* %k18, align 8
  %cmp24 = fcmp ogt double %26, 0.000000e+00
  br i1 %cmp24, label %if.then26, label %if.end29

if.then26:                                        ; preds = %for.body17
  %27 = load double, double* %k18, align 8
  call void @mulComplexD(%struct.Complex* sret align 8 %agg.tmp28, %struct.Complex* byval(%struct.Complex) align 8 %prod, double %27)
  call void @addComplex(%struct.Complex* sret align 8 %tmp27, %struct.Complex* byval(%struct.Complex) align 8 %agg.result, %struct.Complex* byval(%struct.Complex) align 8 %agg.tmp28)
  %28 = bitcast %struct.Complex* %agg.result to i8*
  %29 = bitcast %struct.Complex* %tmp27 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 8 %28, i8* align 8 %29, i32 16, i1 false)
  br label %if.end29

if.end29:                                         ; preds = %if.then26, %for.body17
  call void @mulComplex(%struct.Complex* sret align 8 %tmp30, %struct.Complex* byval(%struct.Complex) align 8 %prod, %struct.Complex* byval(%struct.Complex) align 8 @INV_TWO_I)
  %30 = bitcast %struct.Complex* %prod to i8*
  %31 = bitcast %struct.Complex* %tmp30 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 8 %30, i8* align 8 %31, i32 16, i1 false)
  br label %for.inc31

for.inc31:                                        ; preds = %if.end29
  %32 = load i32, i32* %j, align 4
  %inc32 = add i32 %32, 1
  store i32 %inc32, i32* %j, align 4
  br label %for.cond14

for.end33:                                        ; preds = %for.cond14
  br label %if.end34

if.end34:                                         ; preds = %for.end33, %for.end
  ret void
}

; Function Attrs: nounwind readonly
declare i32 @strlen(i8* %0) #2

; Function Attrs: argmemonly nounwind willreturn
declare void @llvm.memcpy.p0i8.p0i8.i32(i8* noalias nocapture writeonly %0, i8* noalias nocapture readonly %1, i32 %2, i1 immarg %3) #3

; Function Attrs: noinline nounwind optnone
define hidden void @c2qi(%struct.QuaterImaginary* noalias sret align 4 %agg.result, %struct.Complex* byval(%struct.Complex) align 8 %c, i8* %out) #0 {
entry:
  %out.addr = alloca i8*, align 4
  %p = alloca i8*, align 4
  %re = alloca i32, align 4
  %im = alloca i32, align 4
  %fi = alloca i32, align 4
  %rem = alloca i32, align 4
  %index = alloca i32, align 4
  %fc = alloca %struct.Complex, align 8
  %.compoundliteral = alloca %struct.Complex, align 8
  %.compoundliteral21 = alloca %struct.Complex, align 8
  %f = alloca double, align 8
  %rem31 = alloca i32, align 4
  %i = alloca i32, align 4
  store i8* %out, i8** %out.addr, align 4
  %0 = load i8*, i8** %out.addr, align 4
  store i8* %0, i8** %p, align 4
  %1 = load i8*, i8** %p, align 4
  store i8 0, i8* %1, align 1
  %rel = getelementptr inbounds %struct.Complex, %struct.Complex* %c, i32 0, i32 0
  %2 = load double, double* %rel, align 8
  %cmp = fcmp oeq double %2, 0.000000e+00
  br i1 %cmp, label %land.lhs.true, label %if.end

land.lhs.true:                                    ; preds = %entry
  %img = getelementptr inbounds %struct.Complex, %struct.Complex* %c, i32 0, i32 1
  %3 = load double, double* %img, align 8
  %cmp1 = fcmp oeq double %3, 0.000000e+00
  br i1 %cmp1, label %if.then, label %if.end

if.then:                                          ; preds = %land.lhs.true
  call void @makeQuaterImaginary(%struct.QuaterImaginary* sret align 4 %agg.result, i8* getelementptr inbounds ([2 x i8], [2 x i8]* @.str.3, i32 0, i32 0))
  br label %return

if.end:                                           ; preds = %land.lhs.true, %entry
  %rel2 = getelementptr inbounds %struct.Complex, %struct.Complex* %c, i32 0, i32 0
  %4 = load double, double* %rel2, align 8
  %conv = fptosi double %4 to i32
  store i32 %conv, i32* %re, align 4
  %img3 = getelementptr inbounds %struct.Complex, %struct.Complex* %c, i32 0, i32 1
  %5 = load double, double* %img3, align 8
  %conv4 = fptosi double %5 to i32
  store i32 %conv4, i32* %im, align 4
  store i32 -1, i32* %fi, align 4
  br label %while.cond

while.cond:                                       ; preds = %if.end11, %if.end
  %6 = load i32, i32* %re, align 4
  %cmp5 = icmp ne i32 %6, 0
  br i1 %cmp5, label %while.body, label %while.end

while.body:                                       ; preds = %while.cond
  %7 = load i32, i32* %re, align 4
  %rem7 = srem i32 %7, -4
  store i32 %rem7, i32* %rem, align 4
  %8 = load i32, i32* %re, align 4
  %div = sdiv i32 %8, -4
  store i32 %div, i32* %re, align 4
  %9 = load i32, i32* %rem, align 4
  %cmp8 = icmp slt i32 %9, 0
  br i1 %cmp8, label %if.then10, label %if.end11

if.then10:                                        ; preds = %while.body
  %10 = load i32, i32* %rem, align 4
  %add = add nsw i32 %10, 4
  store i32 %add, i32* %rem, align 4
  %11 = load i32, i32* %re, align 4
  %inc = add nsw i32 %11, 1
  store i32 %inc, i32* %re, align 4
  br label %if.end11

if.end11:                                         ; preds = %if.then10, %while.body
  %12 = load i32, i32* %rem, align 4
  %add12 = add nsw i32 %12, 48
  %conv13 = trunc i32 %add12 to i8
  %13 = load i8*, i8** %p, align 4
  %incdec.ptr = getelementptr inbounds i8, i8* %13, i32 1
  store i8* %incdec.ptr, i8** %p, align 4
  store i8 %conv13, i8* %13, align 1
  %14 = load i8*, i8** %p, align 4
  %incdec.ptr14 = getelementptr inbounds i8, i8* %14, i32 1
  store i8* %incdec.ptr14, i8** %p, align 4
  store i8 48, i8* %14, align 1
  %15 = load i8*, i8** %p, align 4
  store i8 0, i8* %15, align 1
  br label %while.cond

while.end:                                        ; preds = %while.cond
  %16 = load i32, i32* %im, align 4
  %cmp15 = icmp ne i32 %16, 0
  br i1 %cmp15, label %if.then17, label %if.end53

if.then17:                                        ; preds = %while.end
  store i32 1, i32* %index, align 4
  %rel18 = getelementptr inbounds %struct.Complex, %struct.Complex* %.compoundliteral, i32 0, i32 0
  store double 0.000000e+00, double* %rel18, align 8
  %img19 = getelementptr inbounds %struct.Complex, %struct.Complex* %.compoundliteral, i32 0, i32 1
  %img20 = getelementptr inbounds %struct.Complex, %struct.Complex* %c, i32 0, i32 1
  %17 = load double, double* %img20, align 8
  store double %17, double* %img19, align 8
  %rel22 = getelementptr inbounds %struct.Complex, %struct.Complex* %.compoundliteral21, i32 0, i32 0
  store double 0.000000e+00, double* %rel22, align 8
  %img23 = getelementptr inbounds %struct.Complex, %struct.Complex* %.compoundliteral21, i32 0, i32 1
  store double 2.000000e+00, double* %img23, align 8
  call void @divComplex(%struct.Complex* sret align 8 %fc, %struct.Complex* byval(%struct.Complex) align 8 %.compoundliteral, %struct.Complex* byval(%struct.Complex) align 8 %.compoundliteral21)
  %rel24 = getelementptr inbounds %struct.Complex, %struct.Complex* %fc, i32 0, i32 0
  %18 = load double, double* %rel24, align 8
  store double %18, double* %f, align 8
  %19 = load double, double* %f, align 8
  %20 = call double @llvm.ceil.f64(double %19)
  %conv25 = fptosi double %20 to i32
  store i32 %conv25, i32* %im, align 4
  %21 = load double, double* %f, align 8
  %22 = load i32, i32* %im, align 4
  %conv26 = sitofp i32 %22 to double
  %sub = fsub double %21, %conv26
  %mul = fmul double -4.000000e+00, %sub
  store double %mul, double* %f, align 8
  br label %while.cond27

while.cond27:                                     ; preds = %if.end49, %if.then17
  %23 = load i32, i32* %im, align 4
  %cmp28 = icmp ne i32 %23, 0
  br i1 %cmp28, label %while.body30, label %while.end51

while.body30:                                     ; preds = %while.cond27
  %24 = load i32, i32* %im, align 4
  %rem32 = srem i32 %24, -4
  store i32 %rem32, i32* %rem31, align 4
  %25 = load i32, i32* %im, align 4
  %div33 = sdiv i32 %25, -4
  store i32 %div33, i32* %im, align 4
  %26 = load i32, i32* %rem31, align 4
  %cmp34 = icmp slt i32 %26, 0
  br i1 %cmp34, label %if.then36, label %if.end39

if.then36:                                        ; preds = %while.body30
  %27 = load i32, i32* %rem31, align 4
  %add37 = add nsw i32 %27, 4
  store i32 %add37, i32* %rem31, align 4
  %28 = load i32, i32* %im, align 4
  %inc38 = add nsw i32 %28, 1
  store i32 %inc38, i32* %im, align 4
  br label %if.end39

if.end39:                                         ; preds = %if.then36, %while.body30
  %29 = load i32, i32* %index, align 4
  %30 = load i8*, i8** %p, align 4
  %31 = load i8*, i8** %out.addr, align 4
  %sub.ptr.lhs.cast = ptrtoint i8* %30 to i32
  %sub.ptr.rhs.cast = ptrtoint i8* %31 to i32
  %sub.ptr.sub = sub i32 %sub.ptr.lhs.cast, %sub.ptr.rhs.cast
  %cmp40 = icmp ult i32 %29, %sub.ptr.sub
  br i1 %cmp40, label %if.then42, label %if.else

if.then42:                                        ; preds = %if.end39
  %32 = load i32, i32* %rem31, align 4
  %add43 = add nsw i32 %32, 48
  %conv44 = trunc i32 %add43 to i8
  %33 = load i8*, i8** %out.addr, align 4
  %34 = load i32, i32* %index, align 4
  %arrayidx = getelementptr inbounds i8, i8* %33, i32 %34
  store i8 %conv44, i8* %arrayidx, align 1
  br label %if.end49

if.else:                                          ; preds = %if.end39
  %35 = load i8*, i8** %p, align 4
  %incdec.ptr45 = getelementptr inbounds i8, i8* %35, i32 1
  store i8* %incdec.ptr45, i8** %p, align 4
  store i8 48, i8* %35, align 1
  %36 = load i32, i32* %rem31, align 4
  %add46 = add nsw i32 %36, 48
  %conv47 = trunc i32 %add46 to i8
  %37 = load i8*, i8** %p, align 4
  %incdec.ptr48 = getelementptr inbounds i8, i8* %37, i32 1
  store i8* %incdec.ptr48, i8** %p, align 4
  store i8 %conv47, i8* %37, align 1
  %38 = load i8*, i8** %p, align 4
  store i8 0, i8* %38, align 1
  br label %if.end49

if.end49:                                         ; preds = %if.else, %if.then42
  %39 = load i32, i32* %index, align 4
  %add50 = add i32 %39, 2
  store i32 %add50, i32* %index, align 4
  br label %while.cond27

while.end51:                                      ; preds = %while.cond27
  %40 = load double, double* %f, align 8
  %conv52 = fptosi double %40 to i32
  store i32 %conv52, i32* %fi, align 4
  br label %if.end53

if.end53:                                         ; preds = %while.end51, %while.end
  %41 = load i8*, i8** %out.addr, align 4
  %42 = load i8*, i8** %p, align 4
  call void @reverse(i8* %41, i8* %42)
  %43 = load i32, i32* %fi, align 4
  %cmp54 = icmp ne i32 %43, -1
  br i1 %cmp54, label %if.then56, label %if.end61

if.then56:                                        ; preds = %if.end53
  %44 = load i8*, i8** %p, align 4
  %incdec.ptr57 = getelementptr inbounds i8, i8* %44, i32 1
  store i8* %incdec.ptr57, i8** %p, align 4
  store i8 46, i8* %44, align 1
  %45 = load i32, i32* %fi, align 4
  %add58 = add nsw i32 %45, 48
  %conv59 = trunc i32 %add58 to i8
  %46 = load i8*, i8** %p, align 4
  %incdec.ptr60 = getelementptr inbounds i8, i8* %46, i32 1
  store i8* %incdec.ptr60, i8** %p, align 4
  store i8 %conv59, i8* %46, align 1
  %47 = load i8*, i8** %p, align 4
  store i8 0, i8* %47, align 1
  br label %if.end61

if.end61:                                         ; preds = %if.then56, %if.end53
  br label %while.cond62

while.cond62:                                     ; preds = %for.end, %if.end61
  %48 = load i8*, i8** %out.addr, align 4
  %arrayidx63 = getelementptr inbounds i8, i8* %48, i32 0
  %49 = load i8, i8* %arrayidx63, align 1
  %conv64 = sext i8 %49 to i32
  %cmp65 = icmp eq i32 %conv64, 48
  br i1 %cmp65, label %land.rhs, label %land.end

land.rhs:                                         ; preds = %while.cond62
  %50 = load i8*, i8** %out.addr, align 4
  %arrayidx67 = getelementptr inbounds i8, i8* %50, i32 1
  %51 = load i8, i8* %arrayidx67, align 1
  %conv68 = sext i8 %51 to i32
  %cmp69 = icmp ne i32 %conv68, 46
  br label %land.end

land.end:                                         ; preds = %land.rhs, %while.cond62
  %52 = phi i1 [ false, %while.cond62 ], [ %cmp69, %land.rhs ]
  br i1 %52, label %while.body71, label %while.end80

while.body71:                                     ; preds = %land.end
  store i32 0, i32* %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %while.body71
  %53 = load i8*, i8** %out.addr, align 4
  %54 = load i32, i32* %i, align 4
  %arrayidx72 = getelementptr inbounds i8, i8* %53, i32 %54
  %55 = load i8, i8* %arrayidx72, align 1
  %conv73 = sext i8 %55 to i32
  %cmp74 = icmp ne i32 %conv73, 0
  br i1 %cmp74, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %56 = load i8*, i8** %out.addr, align 4
  %57 = load i32, i32* %i, align 4
  %add76 = add i32 %57, 1
  %arrayidx77 = getelementptr inbounds i8, i8* %56, i32 %add76
  %58 = load i8, i8* %arrayidx77, align 1
  %59 = load i8*, i8** %out.addr, align 4
  %60 = load i32, i32* %i, align 4
  %arrayidx78 = getelementptr inbounds i8, i8* %59, i32 %60
  store i8 %58, i8* %arrayidx78, align 1
  br label %for.inc

for.inc:                                          ; preds = %for.body
  %61 = load i32, i32* %i, align 4
  %inc79 = add i32 %61, 1
  store i32 %inc79, i32* %i, align 4
  br label %for.cond

for.end:                                          ; preds = %for.cond
  br label %while.cond62

while.end80:                                      ; preds = %land.end
  %62 = load i8*, i8** %out.addr, align 4
  %63 = load i8, i8* %62, align 1
  %conv81 = sext i8 %63 to i32
  %cmp82 = icmp eq i32 %conv81, 46
  br i1 %cmp82, label %if.then84, label %if.end86

if.then84:                                        ; preds = %while.end80
  %64 = load i8*, i8** %out.addr, align 4
  %65 = load i8*, i8** %p, align 4
  call void @reverse(i8* %64, i8* %65)
  %66 = load i8*, i8** %p, align 4
  %incdec.ptr85 = getelementptr inbounds i8, i8* %66, i32 1
  store i8* %incdec.ptr85, i8** %p, align 4
  store i8 48, i8* %66, align 1
  %67 = load i8*, i8** %p, align 4
  store i8 0, i8* %67, align 1
  %68 = load i8*, i8** %out.addr, align 4
  %69 = load i8*, i8** %p, align 4
  call void @reverse(i8* %68, i8* %69)
  br label %if.end86

if.end86:                                         ; preds = %if.then84, %while.end80
  %70 = load i8*, i8** %out.addr, align 4
  call void @makeQuaterImaginary(%struct.QuaterImaginary* sret align 4 %agg.result, i8* %70)
  br label %return

return:                                           ; preds = %if.end86, %if.then
  ret void
}

; Function Attrs: nounwind readnone speculatable willreturn
declare double @llvm.ceil.f64(double %0) #4

; Function Attrs: noinline nounwind optnone
define hidden i32 @main() #0 {
entry:
  %retval = alloca i32, align 4
  %buffer = alloca [16 x i8], align 16
  %i = alloca i32, align 4
  %c1 = alloca %struct.Complex, align 8
  %qi = alloca %struct.QuaterImaginary, align 4
  %c2 = alloca %struct.Complex, align 8
  %tmp = alloca %struct.Complex, align 8
  %tmp3 = alloca %struct.QuaterImaginary, align 4
  %tmp5 = alloca %struct.Complex, align 8
  %c114 = alloca %struct.Complex, align 8
  %qi18 = alloca %struct.QuaterImaginary, align 4
  %c220 = alloca %struct.Complex, align 8
  %tmp24 = alloca %struct.Complex, align 8
  %tmp25 = alloca %struct.QuaterImaginary, align 4
  %tmp27 = alloca %struct.Complex, align 8
  store i32 0, i32* %retval, align 4
  store i32 1, i32* %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %0 = load i32, i32* %i, align 4
  %cmp = icmp sle i32 %0, 16
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %rel = getelementptr inbounds %struct.Complex, %struct.Complex* %c1, i32 0, i32 0
  %1 = load i32, i32* %i, align 4
  %conv = sitofp i32 %1 to double
  store double %conv, double* %rel, align 8
  %img = getelementptr inbounds %struct.Complex, %struct.Complex* %c1, i32 0, i32 1
  store double 0.000000e+00, double* %img, align 8
  %arraydecay = getelementptr inbounds [16 x i8], [16 x i8]* %buffer, i32 0, i32 0
  call void @c2qi(%struct.QuaterImaginary* sret align 4 %qi, %struct.Complex* byval(%struct.Complex) align 8 %c1, i8* %arraydecay)
  call void @qi2c(%struct.Complex* sret align 8 %c2, %struct.QuaterImaginary* byval(%struct.QuaterImaginary) align 4 %qi)
  call void @printComplex(%struct.Complex* byval(%struct.Complex) align 8 %c1)
  %call = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.4, i32 0, i32 0))
  call void @printQuaterImaginary(%struct.QuaterImaginary* byval(%struct.QuaterImaginary) align 4 %qi)
  %call1 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.4, i32 0, i32 0))
  call void @printComplex(%struct.Complex* byval(%struct.Complex) align 8 %c2)
  %call2 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([6 x i8], [6 x i8]* @.str.5, i32 0, i32 0))
  call void @negComplex(%struct.Complex* sret align 8 %tmp, %struct.Complex* byval(%struct.Complex) align 8 %c1)
  %2 = bitcast %struct.Complex* %c1 to i8*
  %3 = bitcast %struct.Complex* %tmp to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 8 %2, i8* align 8 %3, i32 16, i1 false)
  %arraydecay4 = getelementptr inbounds [16 x i8], [16 x i8]* %buffer, i32 0, i32 0
  call void @c2qi(%struct.QuaterImaginary* sret align 4 %tmp3, %struct.Complex* byval(%struct.Complex) align 8 %c1, i8* %arraydecay4)
  %4 = bitcast %struct.QuaterImaginary* %qi to i8*
  %5 = bitcast %struct.QuaterImaginary* %tmp3 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 4 %4, i8* align 4 %5, i32 8, i1 false)
  call void @qi2c(%struct.Complex* sret align 8 %tmp5, %struct.QuaterImaginary* byval(%struct.QuaterImaginary) align 4 %qi)
  %6 = bitcast %struct.Complex* %c2 to i8*
  %7 = bitcast %struct.Complex* %tmp5 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 8 %6, i8* align 8 %7, i32 16, i1 false)
  call void @printComplex(%struct.Complex* byval(%struct.Complex) align 8 %c1)
  %call6 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.4, i32 0, i32 0))
  call void @printQuaterImaginary(%struct.QuaterImaginary* byval(%struct.QuaterImaginary) align 4 %qi)
  %call7 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.4, i32 0, i32 0))
  call void @printComplex(%struct.Complex* byval(%struct.Complex) align 8 %c2)
  %call8 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([2 x i8], [2 x i8]* @.str.6, i32 0, i32 0))
  br label %for.inc

for.inc:                                          ; preds = %for.body
  %8 = load i32, i32* %i, align 4
  %inc = add nsw i32 %8, 1
  store i32 %inc, i32* %i, align 4
  br label %for.cond

for.end:                                          ; preds = %for.cond
  %call9 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([2 x i8], [2 x i8]* @.str.6, i32 0, i32 0))
  store i32 1, i32* %i, align 4
  br label %for.cond10

for.cond10:                                       ; preds = %for.inc31, %for.end
  %9 = load i32, i32* %i, align 4
  %cmp11 = icmp sle i32 %9, 16
  br i1 %cmp11, label %for.body13, label %for.end33

for.body13:                                       ; preds = %for.cond10
  %rel15 = getelementptr inbounds %struct.Complex, %struct.Complex* %c114, i32 0, i32 0
  store double 0.000000e+00, double* %rel15, align 8
  %img16 = getelementptr inbounds %struct.Complex, %struct.Complex* %c114, i32 0, i32 1
  %10 = load i32, i32* %i, align 4
  %conv17 = sitofp i32 %10 to double
  store double %conv17, double* %img16, align 8
  %arraydecay19 = getelementptr inbounds [16 x i8], [16 x i8]* %buffer, i32 0, i32 0
  call void @c2qi(%struct.QuaterImaginary* sret align 4 %qi18, %struct.Complex* byval(%struct.Complex) align 8 %c114, i8* %arraydecay19)
  call void @qi2c(%struct.Complex* sret align 8 %c220, %struct.QuaterImaginary* byval(%struct.QuaterImaginary) align 4 %qi18)
  call void @printComplex(%struct.Complex* byval(%struct.Complex) align 8 %c114)
  %call21 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.4, i32 0, i32 0))
  call void @printQuaterImaginary(%struct.QuaterImaginary* byval(%struct.QuaterImaginary) align 4 %qi18)
  %call22 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.4, i32 0, i32 0))
  call void @printComplex(%struct.Complex* byval(%struct.Complex) align 8 %c220)
  %call23 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([6 x i8], [6 x i8]* @.str.5, i32 0, i32 0))
  call void @negComplex(%struct.Complex* sret align 8 %tmp24, %struct.Complex* byval(%struct.Complex) align 8 %c114)
  %11 = bitcast %struct.Complex* %c114 to i8*
  %12 = bitcast %struct.Complex* %tmp24 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 8 %11, i8* align 8 %12, i32 16, i1 false)
  %arraydecay26 = getelementptr inbounds [16 x i8], [16 x i8]* %buffer, i32 0, i32 0
  call void @c2qi(%struct.QuaterImaginary* sret align 4 %tmp25, %struct.Complex* byval(%struct.Complex) align 8 %c114, i8* %arraydecay26)
  %13 = bitcast %struct.QuaterImaginary* %qi18 to i8*
  %14 = bitcast %struct.QuaterImaginary* %tmp25 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 4 %13, i8* align 4 %14, i32 8, i1 false)
  call void @qi2c(%struct.Complex* sret align 8 %tmp27, %struct.QuaterImaginary* byval(%struct.QuaterImaginary) align 4 %qi18)
  %15 = bitcast %struct.Complex* %c220 to i8*
  %16 = bitcast %struct.Complex* %tmp27 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 8 %15, i8* align 8 %16, i32 16, i1 false)
  call void @printComplex(%struct.Complex* byval(%struct.Complex) align 8 %c114)
  %call28 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.4, i32 0, i32 0))
  call void @printQuaterImaginary(%struct.QuaterImaginary* byval(%struct.QuaterImaginary) align 4 %qi18)
  %call29 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.4, i32 0, i32 0))
  call void @printComplex(%struct.Complex* byval(%struct.Complex) align 8 %c220)
  %call30 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([2 x i8], [2 x i8]* @.str.6, i32 0, i32 0))
  br label %for.inc31

for.inc31:                                        ; preds = %for.body13
  %17 = load i32, i32* %i, align 4
  %inc32 = add nsw i32 %17, 1
  store i32 %inc32, i32* %i, align 4
  br label %for.cond10

for.end33:                                        ; preds = %for.cond10
  ret i32 0
}

attributes #0 = { noinline nounwind optnone "correctly-rounded-divide-sqrt-fp-math"="false" "disable-tail-calls"="false" "frame-pointer"="none" "less-precise-fpmad"="false" "min-legal-vector-width"="0" "no-infs-fp-math"="false" "no-jump-tables"="false" "no-nans-fp-math"="false" "no-signed-zeros-fp-math"="false" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="generic" "unsafe-fp-math"="false" "use-soft-float"="false" }
attributes #1 = { "correctly-rounded-divide-sqrt-fp-math"="false" "disable-tail-calls"="false" "frame-pointer"="none" "less-precise-fpmad"="false" "no-infs-fp-math"="false" "no-nans-fp-math"="false" "no-signed-zeros-fp-math"="false" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="generic" "unsafe-fp-math"="false" "use-soft-float"="false" }
attributes #2 = { nounwind readonly "correctly-rounded-divide-sqrt-fp-math"="false" "disable-tail-calls"="false" "frame-pointer"="none" "less-precise-fpmad"="false" "no-infs-fp-math"="false" "no-nans-fp-math"="false" "no-signed-zeros-fp-math"="false" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="generic" "unsafe-fp-math"="false" "use-soft-float"="false" }
attributes #3 = { argmemonly nounwind willreturn }
attributes #4 = { nounwind readnone speculatable willreturn }
attributes #5 = { nounwind readonly }

!llvm.module.flags = !{!0}
!llvm.ident = !{!1}

!0 = !{i32 1, !"wchar_size", i32 4}
!1 = !{!"clang version 11.0.0 (https://github.com/Jacarte/llvm-project.git 0f6dea67136cc1e0b3d200eb2bb165628970c44b)"}

; extracted candidates

; *****
; For LLVM instruction:
;  %cmp = fcmp oeq double %2, 0.000000e+00
; Looking for a replacement for:
%0:i1 = var
infer %0

; *****
; For LLVM instruction:
;  %cmp1 = fcmp oeq double %3, 0.000000e+00
; Looking for a replacement for:
%0:i1 = var
infer %0

; *****
; For LLVM instruction:
;  %conv = fptosi double %4 to i32
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %conv4 = fptosi double %5 to i32
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %6 = load i32, i32* %re, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %cmp5 = icmp ne i32 %6, 0
; Looking for a replacement for:
%0:i32 = var
%1:i1 = ne 0:i32, %0
infer %1

; *****
; For LLVM instruction:
;  %7 = load i32, i32* %re, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %rem7 = srem i32 %7, -4
; Looking for a replacement for:
%0:i32 = var
%1:i32 = srem %0, 4294967292:i32
infer %1

; *****
; For LLVM instruction:
;  %8 = load i32, i32* %re, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %div = sdiv i32 %8, -4
; Looking for a replacement for:
%0:i32 = var
%1:i32 = sdiv %0, 4294967292:i32
infer %1

; *****
; For LLVM instruction:
;  %9 = load i32, i32* %rem, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %cmp8 = icmp slt i32 %9, 0
; Looking for a replacement for:
%0:i32 = var
%1:i1 = slt %0, 0:i32
infer %1

; *****
; For LLVM instruction:
;  %10 = load i32, i32* %rem, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %add = add nsw i32 %10, 4
; Looking for a replacement for:
%0:i32 = var
%1:i32 = addnsw 4:i32, %0
infer %1

; *****
; For LLVM instruction:
;  %11 = load i32, i32* %re, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %inc = add nsw i32 %11, 1
; Looking for a replacement for:
%0:i32 = var
%1:i32 = addnsw 1:i32, %0
infer %1

; *****
; For LLVM instruction:
;  %12 = load i32, i32* %rem, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0 (demandedBits=00000000000000000000000011111111)

; *****
; For LLVM instruction:
;  %add12 = add nsw i32 %12, 48
; Looking for a replacement for:
%0:i32 = var
%1:i32 = addnsw 48:i32, %0
infer %1 (demandedBits=00000000000000000000000011111111)

; *****
; For LLVM instruction:
;  %conv13 = trunc i32 %add12 to i8
; Looking for a replacement for:
%0:i32 = var
%1:i32 = addnsw 48:i32, %0
%2:i8 = trunc %1
infer %2

; *****
; For LLVM instruction:
;  %16 = load i32, i32* %im, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %cmp15 = icmp ne i32 %16, 0
; Looking for a replacement for:
%0:i32 = var
%1:i1 = ne 0:i32, %0
infer %1

; *****
; For LLVM instruction:
;  %conv25 = fptosi double %20 to i32
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %22 = load i32, i32* %im, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %23 = load i32, i32* %im, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %cmp28 = icmp ne i32 %23, 0
; Looking for a replacement for:
%0:i32 = var
%1:i1 = ne 0:i32, %0
infer %1

; *****
; For LLVM instruction:
;  %24 = load i32, i32* %im, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %rem32 = srem i32 %24, -4
; Looking for a replacement for:
%0:i32 = var
%1:i32 = srem %0, 4294967292:i32
infer %1

; *****
; For LLVM instruction:
;  %25 = load i32, i32* %im, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %div33 = sdiv i32 %25, -4
; Looking for a replacement for:
%0:i32 = var
%1:i32 = sdiv %0, 4294967292:i32
infer %1

; *****
; For LLVM instruction:
;  %26 = load i32, i32* %rem31, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %cmp34 = icmp slt i32 %26, 0
; Looking for a replacement for:
%0:i32 = var
%1:i1 = slt %0, 0:i32
infer %1

; *****
; For LLVM instruction:
;  %27 = load i32, i32* %rem31, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %add37 = add nsw i32 %27, 4
; Looking for a replacement for:
%0:i32 = var
%1:i32 = addnsw 4:i32, %0
infer %1

; *****
; For LLVM instruction:
;  %28 = load i32, i32* %im, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %inc38 = add nsw i32 %28, 1
; Looking for a replacement for:
%0:i32 = var
%1:i32 = addnsw 1:i32, %0
infer %1

; *****
; For LLVM instruction:
;  %29 = load i32, i32* %index, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %sub.ptr.lhs.cast = ptrtoint i8* %30 to i32
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %sub.ptr.rhs.cast = ptrtoint i8* %31 to i32
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %sub.ptr.sub = sub i32 %sub.ptr.lhs.cast, %sub.ptr.rhs.cast
; Looking for a replacement for:
%0:i32 = var
%1:i32 = var
%2:i32 = sub %0, %1
infer %2

; *****
; For LLVM instruction:
;  %cmp40 = icmp ult i32 %29, %sub.ptr.sub
; Looking for a replacement for:
%0:i32 = var
%1:i32 = var
%2:i32 = var
%3:i32 = sub %1, %2
%4:i1 = ult %0, %3
infer %4

; *****
; For LLVM instruction:
;  %32 = load i32, i32* %rem31, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0 (demandedBits=00000000000000000000000011111111)

; *****
; For LLVM instruction:
;  %add43 = add nsw i32 %32, 48
; Looking for a replacement for:
%0:i32 = var
%1:i32 = addnsw 48:i32, %0
infer %1 (demandedBits=00000000000000000000000011111111)

; *****
; For LLVM instruction:
;  %conv44 = trunc i32 %add43 to i8
; Looking for a replacement for:
%0:i32 = var
%1:i32 = addnsw 48:i32, %0
%2:i8 = trunc %1
infer %2

; *****
; For LLVM instruction:
;  %34 = load i32, i32* %index, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %36 = load i32, i32* %rem31, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0 (demandedBits=00000000000000000000000011111111)

; *****
; For LLVM instruction:
;  %add46 = add nsw i32 %36, 48
; Looking for a replacement for:
%0:i32 = var
%1:i32 = addnsw 48:i32, %0
infer %1 (demandedBits=00000000000000000000000011111111)

; *****
; For LLVM instruction:
;  %conv47 = trunc i32 %add46 to i8
; Looking for a replacement for:
%0:i32 = var
%1:i32 = addnsw 48:i32, %0
%2:i8 = trunc %1
infer %2

; *****
; For LLVM instruction:
;  %39 = load i32, i32* %index, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %add50 = add i32 %39, 2
; Looking for a replacement for:
%0:i32 = var
%1:i32 = add 2:i32, %0
infer %1

; *****
; For LLVM instruction:
;  %conv52 = fptosi double %40 to i32
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %43 = load i32, i32* %fi, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %cmp54 = icmp ne i32 %43, -1
; Looking for a replacement for:
%0:i32 = var
%1:i1 = ne 4294967295:i32, %0
infer %1

; *****
; For LLVM instruction:
;  %45 = load i32, i32* %fi, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0 (demandedBits=00000000000000000000000011111111)

; *****
; For LLVM instruction:
;  %add58 = add nsw i32 %45, 48
; Looking for a replacement for:
%0:i32 = var
%1:i32 = addnsw 48:i32, %0
infer %1 (demandedBits=00000000000000000000000011111111)

; *****
; For LLVM instruction:
;  %conv59 = trunc i32 %add58 to i8
; Looking for a replacement for:
%0:i32 = var
%1:i32 = addnsw 48:i32, %0
%2:i8 = trunc %1
infer %2

; *****
; For LLVM instruction:
;  %49 = load i8, i8* %arrayidx63, align 1
; Looking for a replacement for:
%0:i8 = var
infer %0

; *****
; For LLVM instruction:
;  %conv64 = sext i8 %49 to i32
; Looking for a replacement for:
%0:i8 = var
%1:i32 = sext %0
infer %1

; *****
; For LLVM instruction:
;  %cmp65 = icmp eq i32 %conv64, 48
; Looking for a replacement for:
%0:i8 = var
%1:i32 = sext %0
%2:i1 = eq 48:i32, %1
infer %2

; *****
; For LLVM instruction:
;  %51 = load i8, i8* %arrayidx67, align 1
; Looking for a replacement for:
%0:i8 = var
infer %0

; *****
; For LLVM instruction:
;  %conv68 = sext i8 %51 to i32
; Looking for a replacement for:
%0:i8 = var
%1:i32 = sext %0
infer %1

; *****
; For LLVM instruction:
;  %cmp69 = icmp ne i32 %conv68, 46
; Looking for a replacement for:
%0:i8 = var
%1:i32 = sext %0
%2:i1 = ne 46:i32, %1
infer %2

; *****
; For LLVM instruction:
;  %52 = phi i1 [ false, %while.cond62 ], [ %cmp69, %land.rhs ]
; Looking for a replacement for:
%0:i1 = var
infer %0

; *****
; For LLVM instruction:
;  %54 = load i32, i32* %i, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %55 = load i8, i8* %arrayidx72, align 1
; Looking for a replacement for:
%0:i8 = var
infer %0

; *****
; For LLVM instruction:
;  %conv73 = sext i8 %55 to i32
; Looking for a replacement for:
%0:i8 = var
%1:i32 = sext %0
infer %1

; *****
; For LLVM instruction:
;  %cmp74 = icmp ne i32 %conv73, 0
; Looking for a replacement for:
%0:i8 = var
%1:i32 = sext %0
%2:i1 = ne 0:i32, %1
infer %2

; *****
; For LLVM instruction:
;  %57 = load i32, i32* %i, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %add76 = add i32 %57, 1
; Looking for a replacement for:
%0:i32 = var
%1:i32 = add 1:i32, %0
infer %1

; *****
; For LLVM instruction:
;  %58 = load i8, i8* %arrayidx77, align 1
; Looking for a replacement for:
%0:i8 = var
infer %0

; *****
; For LLVM instruction:
;  %60 = load i32, i32* %i, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %61 = load i32, i32* %i, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %inc79 = add i32 %61, 1
; Looking for a replacement for:
%0:i32 = var
%1:i32 = add 1:i32, %0
infer %1

; *****
; For LLVM instruction:
;  %63 = load i8, i8* %62, align 1
; Looking for a replacement for:
%0:i8 = var
infer %0

; *****
; For LLVM instruction:
;  %conv81 = sext i8 %63 to i32
; Looking for a replacement for:
%0:i8 = var
%1:i32 = sext %0
infer %1

; *****
; For LLVM instruction:
;  %cmp82 = icmp eq i32 %conv81, 46
; Looking for a replacement for:
%0:i8 = var
%1:i32 = sext %0
%2:i1 = eq 46:i32, %1
infer %2
got 2 candidates from LHS

-------------------------------------------------
%0:i32 = var
%1:i32 = srem %0, 4294967292:i32
infer %1


--------------------------------
guess 0

%0:i32 = var ; reservedconst_1

Cost = 0
first query is SAT, returning the model:
reservedconst_1: 0
0 th attempt: second query is SAT-- constant doesn't work
first query is SAT, returning the model:
reservedconst_1: -3
1 th attempt: second query is SAT-- constant doesn't work
first query is UNSAT-- no more guesses

--------------------------------
guess 1

%0:i32 = var

Cost = 0
second query is SAT-- constant doesn't work
Dataflow Pruned 0/0
There are 2 Guesses
There are 0 RHSs before deduplication
There are 0 RHSs after deduplication
got 2 candidates from LHS

-------------------------------------------------
%0:i32 = var
%1:i32 = sdiv %0, 4294967292:i32
infer %1


--------------------------------
guess 0

%0:i32 = var ; reservedconst_1

Cost = 0
first query is SAT, returning the model:
reservedconst_1: 0
0 th attempt: second query is SAT-- constant doesn't work
first query is SAT, returning the model:
reservedconst_1: -353880472
1 th attempt: second query is SAT-- constant doesn't work
first query is UNSAT-- no more guesses

--------------------------------
guess 1

%0:i32 = var

Cost = 0
second query is SAT-- constant doesn't work
Dataflow Pruned 0/0
There are 2 Guesses
There are 0 RHSs before deduplication
There are 0 RHSs after deduplication
got 2 candidates from LHS

-------------------------------------------------
%0:i32 = var
%1:i1 = slt %0, 0:i32
infer %1


--------------------------------
guess 0

%0:i1 = var ; reservedconst_1

Cost = 0
first query is SAT, returning the model:
reservedconst_1: 0
0 th attempt: second query is SAT-- constant doesn't work
first query is SAT, returning the model:
reservedconst_1: -1
1 th attempt: second query is SAT-- constant doesn't work
first query is UNSAT-- no more guesses
Dataflow Pruned 0/0
There are 1 Guesses
There are 0 RHSs before deduplication
There are 0 RHSs after deduplication
got 2 candidates from LHS

-------------------------------------------------
%0:i32 = var
%1:i32 = addnsw 4:i32, %0
infer %1


--------------------------------
guess 0

%0:i32 = var ; reservedconst_1

Cost = 0
first query is SAT, returning the model:
reservedconst_1: 4
0 th attempt: second query is SAT-- constant doesn't work
first query is SAT, returning the model:
reservedconst_1: 5
1 th attempt: second query is SAT-- constant doesn't work
first query is UNSAT-- no more guesses

--------------------------------
guess 1

%0:i32 = var

Cost = 0
second query is SAT-- constant doesn't work
Dataflow Pruned 0/0
There are 2 Guesses
There are 0 RHSs before deduplication
There are 0 RHSs after deduplication
got 2 candidates from LHS

-------------------------------------------------
%0:i32 = var
%1:i32 = addnsw 1:i32, %0
infer %1


--------------------------------
guess 0

%0:i32 = var ; reservedconst_1

Cost = 0
first query is SAT, returning the model:
reservedconst_1: 1
0 th attempt: second query is SAT-- constant doesn't work
first query is SAT, returning the model:
reservedconst_1: 268435457
1 th attempt: second query is SAT-- constant doesn't work
first query is UNSAT-- no more guesses

--------------------------------
guess 1

%0:i32 = var

Cost = 0
second query is SAT-- constant doesn't work
Dataflow Pruned 0/0
There are 2 Guesses
There are 0 RHSs before deduplication
There are 0 RHSs after deduplication
got 1 candidates from LHS

-------------------------------------------------
%0:i32 = var
infer %0 (demandedBits=00000000000000000000000011111111)


--------------------------------
guess 0

%0:i32 = var ; reservedconst_1

Cost = 0
first query is SAT, returning the model:
reservedconst_1: 0
0 th attempt: second query is SAT-- constant doesn't work
first query is SAT, returning the model:
reservedconst_1: 255
1 th attempt: second query is SAT-- constant doesn't work
first query is UNSAT-- no more guesses
Dataflow Pruned 0/0
There are 1 Guesses
There are 0 RHSs before deduplication
There are 0 RHSs after deduplication
got 2 candidates from LHS

-------------------------------------------------
%0:i32 = var
%1:i32 = addnsw 48:i32, %0
infer %1 (demandedBits=00000000000000000000000011111111)


--------------------------------
guess 0

%0:i32 = var ; reservedconst_1

Cost = 0
first query is SAT, returning the model:
reservedconst_1: 0
0 th attempt: second query is SAT-- constant doesn't work
first query is SAT, returning the model:
reservedconst_1: 48
1 th attempt: second query is SAT-- constant doesn't work
first query is UNSAT-- no more guesses

--------------------------------
guess 1

%0:i32 = var

Cost = 0
second query is SAT-- constant doesn't work
Dataflow Pruned 0/0
There are 2 Guesses
There are 0 RHSs before deduplication
There are 0 RHSs after deduplication
got 3 candidates from LHS

-------------------------------------------------
%0:i32 = var
%1:i32 = addnsw 48:i32, %0
%2:i8 = trunc %1
infer %2


--------------------------------
guess 0

%0:i8 = var ; reservedconst_1

Cost = 0
first query is SAT, returning the model:
reservedconst_1: 48
0 th attempt: second query is SAT-- constant doesn't work
first query is SAT, returning the model:
reservedconst_1: 52
1 th attempt: second query is SAT-- constant doesn't work
first query is UNSAT-- no more guesses
Dataflow Pruned 0/0
There are 1 Guesses
There are 0 RHSs before deduplication
There are 0 RHSs after deduplication
got 5 candidates from LHS

-------------------------------------------------
%0:i32 = var
%1:i32 = var
%2:i32 = var
%3:i32 = sub %1, %2
%4:i1 = ult %0, %3
infer %4


--------------------------------
guess 0

%0:i1 = var ; reservedconst_1

Cost = 0
first query is SAT, returning the model:
reservedconst_1: 0
0 th attempt: second query is SAT-- constant doesn't work
first query is SAT, returning the model:
reservedconst_1: -1
1 th attempt: second query is SAT-- constant doesn't work
first query is UNSAT-- no more guesses
Dataflow Pruned 0/0
There are 1 Guesses
There are 0 RHSs before deduplication
There are 0 RHSs after deduplication
got 2 candidates from LHS

-------------------------------------------------
%0:i32 = var
%1:i32 = add 2:i32, %0
infer %1


--------------------------------
guess 0

%0:i32 = var ; reservedconst_1

Cost = 0
first query is SAT, returning the model:
reservedconst_1: 2
0 th attempt: second query is SAT-- constant doesn't work
first query is SAT, returning the model:
reservedconst_1: 1
1 th attempt: second query is SAT-- constant doesn't work
first query is UNSAT-- no more guesses

--------------------------------
guess 1

%0:i32 = var

Cost = 0
second query is SAT-- constant doesn't work
Dataflow Pruned 0/0
There are 2 Guesses
There are 0 RHSs before deduplication
There are 0 RHSs after deduplication
got 3 candidates from LHS

-------------------------------------------------
%0:i8 = var
%1:i32 = sext %0
%2:i1 = eq 48:i32, %1
infer %2


--------------------------------
guess 0

%0:i1 = var ; reservedconst_1

Cost = 0
first query is SAT, returning the model:
reservedconst_1: 0
0 th attempt: second query is SAT-- constant doesn't work
first query is SAT, returning the model:
reservedconst_1: -1
1 th attempt: second query is SAT-- constant doesn't work
first query is UNSAT-- no more guesses
Dataflow Pruned 0/0
There are 1 Guesses
There are 0 RHSs before deduplication
There are 0 RHSs after deduplication
got 3 candidates from LHS

-------------------------------------------------
%0:i8 = var
%1:i32 = sext %0
%2:i1 = ne 46:i32, %1
infer %2


--------------------------------
guess 0

%0:i1 = var ; reservedconst_1

Cost = 0
first query is SAT, returning the model:
reservedconst_1: -1
0 th attempt: second query is SAT-- constant doesn't work
first query is SAT, returning the model:
reservedconst_1: 0
1 th attempt: second query is SAT-- constant doesn't work
first query is UNSAT-- no more guesses
Dataflow Pruned 0/0
There are 1 Guesses
There are 0 RHSs before deduplication
There are 0 RHSs after deduplication
#########################################################
; exiting Souper's runOnFunction() for c2qi()

; entering Souper's runOnFunction() for main()

; ModuleID = './Imaginary_base_numbers.c.bc'
source_filename = "./Imaginary_base_numbers.c"
target datalayout = "e-m:e-p:32:32-i64:64-n32:64-S128"
target triple = "wasm32-unknown-wasi"

%struct.Complex = type { double, double }
%struct.QuaterImaginary = type { i8*, i32 }

@.str = private unnamed_addr constant [17 x i8] c"(%3.0f + %3.0fi)\00", align 1
@TWO_I = hidden constant %struct.Complex { double 0.000000e+00, double 2.000000e+00 }, align 8
@INV_TWO_I = hidden constant %struct.Complex { double 0.000000e+00, double -5.000000e-01 }, align 8
@.str.1 = private unnamed_addr constant [4 x i8] c"%8s\00", align 1
@.str.2 = private unnamed_addr constant [9 x i8] c" ERROR  \00", align 1
@.str.3 = private unnamed_addr constant [2 x i8] c"0\00", align 1
@.str.4 = private unnamed_addr constant [5 x i8] c" -> \00", align 1
@.str.5 = private unnamed_addr constant [6 x i8] c"     \00", align 1
@.str.6 = private unnamed_addr constant [2 x i8] c"\0A\00", align 1
@llvm.used = appending global [1 x i8*] [i8* bitcast (i32 ()* @__main_void to i8*)], section "llvm.metadata"

@__main_void = alias i32 (), i32 ()* @main

; Function Attrs: noinline nounwind optnone
define hidden i32 @find(i8* %s, i8 signext %c) #0 {
entry:
  %retval = alloca i32, align 4
  %s.addr = alloca i8*, align 4
  %c.addr = alloca i8, align 1
  %i = alloca i8*, align 4
  store i8* %s, i8** %s.addr, align 4
  store i8 %c, i8* %c.addr, align 1
  %0 = load i8*, i8** %s.addr, align 4
  store i8* %0, i8** %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %1 = load i8*, i8** %i, align 4
  %2 = load i8, i8* %1, align 1
  %conv = sext i8 %2 to i32
  %cmp = icmp ne i32 %conv, 0
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %3 = load i8*, i8** %i, align 4
  %4 = load i8, i8* %3, align 1
  %conv2 = sext i8 %4 to i32
  %5 = load i8, i8* %c.addr, align 1
  %conv3 = sext i8 %5 to i32
  %cmp4 = icmp eq i32 %conv2, %conv3
  br i1 %cmp4, label %if.then, label %if.end

if.then:                                          ; preds = %for.body
  %6 = load i8*, i8** %i, align 4
  %7 = load i8*, i8** %s.addr, align 4
  %sub.ptr.lhs.cast = ptrtoint i8* %6 to i32
  %sub.ptr.rhs.cast = ptrtoint i8* %7 to i32
  %sub.ptr.sub = sub i32 %sub.ptr.lhs.cast, %sub.ptr.rhs.cast
  store i32 %sub.ptr.sub, i32* %retval, align 4
  br label %return

if.end:                                           ; preds = %for.body
  br label %for.inc

for.inc:                                          ; preds = %if.end
  %8 = load i8*, i8** %i, align 4
  %incdec.ptr = getelementptr inbounds i8, i8* %8, i32 1
  store i8* %incdec.ptr, i8** %i, align 4
  br label %for.cond

for.end:                                          ; preds = %for.cond
  store i32 -1, i32* %retval, align 4
  br label %return

return:                                           ; preds = %for.end, %if.then
  %9 = load i32, i32* %retval, align 4
  ret i32 %9
}

; Function Attrs: noinline nounwind optnone
define hidden void @reverse(i8* %b, i8* %e) #0 {
entry:
  %b.addr = alloca i8*, align 4
  %e.addr = alloca i8*, align 4
  %t = alloca i8, align 1
  store i8* %b, i8** %b.addr, align 4
  store i8* %e, i8** %e.addr, align 4
  %0 = load i8*, i8** %e.addr, align 4
  %incdec.ptr = getelementptr inbounds i8, i8* %0, i32 -1
  store i8* %incdec.ptr, i8** %e.addr, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %1 = load i8*, i8** %b.addr, align 4
  %2 = load i8*, i8** %e.addr, align 4
  %cmp = icmp ult i8* %1, %2
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %3 = load i8*, i8** %b.addr, align 4
  %4 = load i8, i8* %3, align 1
  store i8 %4, i8* %t, align 1
  %5 = load i8*, i8** %e.addr, align 4
  %6 = load i8, i8* %5, align 1
  %7 = load i8*, i8** %b.addr, align 4
  store i8 %6, i8* %7, align 1
  %8 = load i8, i8* %t, align 1
  %9 = load i8*, i8** %e.addr, align 4
  store i8 %8, i8* %9, align 1
  br label %for.inc

for.inc:                                          ; preds = %for.body
  %10 = load i8*, i8** %b.addr, align 4
  %incdec.ptr1 = getelementptr inbounds i8, i8* %10, i32 1
  store i8* %incdec.ptr1, i8** %b.addr, align 4
  %11 = load i8*, i8** %e.addr, align 4
  %incdec.ptr2 = getelementptr inbounds i8, i8* %11, i32 -1
  store i8* %incdec.ptr2, i8** %e.addr, align 4
  br label %for.cond

for.end:                                          ; preds = %for.cond
  ret void
}

; Function Attrs: noinline nounwind optnone
define hidden void @printComplex(%struct.Complex* byval(%struct.Complex) align 8 %c) #0 {
entry:
  %rel = getelementptr inbounds %struct.Complex, %struct.Complex* %c, i32 0, i32 0
  %0 = load double, double* %rel, align 8
  %img = getelementptr inbounds %struct.Complex, %struct.Complex* %c, i32 0, i32 1
  %1 = load double, double* %img, align 8
  %call = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([17 x i8], [17 x i8]* @.str, i32 0, i32 0), double %0, double %1)
  ret void
}

declare i32 @printf(i8* %0, ...) #1

; Function Attrs: noinline nounwind optnone
define hidden void @makeComplex(%struct.Complex* noalias sret align 8 %agg.result, double %rel, double %img) #0 {
entry:
  %rel.addr = alloca double, align 8
  %img.addr = alloca double, align 8
  store double %rel, double* %rel.addr, align 8
  store double %img, double* %img.addr, align 8
  %rel1 = getelementptr inbounds %struct.Complex, %struct.Complex* %agg.result, i32 0, i32 0
  %0 = load double, double* %rel.addr, align 8
  store double %0, double* %rel1, align 8
  %img2 = getelementptr inbounds %struct.Complex, %struct.Complex* %agg.result, i32 0, i32 1
  %1 = load double, double* %img.addr, align 8
  store double %1, double* %img2, align 8
  ret void
}

; Function Attrs: noinline nounwind optnone
define hidden void @addComplex(%struct.Complex* noalias sret align 8 %agg.result, %struct.Complex* byval(%struct.Complex) align 8 %a, %struct.Complex* byval(%struct.Complex) align 8 %b) #0 {
entry:
  %rel = getelementptr inbounds %struct.Complex, %struct.Complex* %agg.result, i32 0, i32 0
  %rel1 = getelementptr inbounds %struct.Complex, %struct.Complex* %a, i32 0, i32 0
  %0 = load double, double* %rel1, align 8
  %rel2 = getelementptr inbounds %struct.Complex, %struct.Complex* %b, i32 0, i32 0
  %1 = load double, double* %rel2, align 8
  %add = fadd double %0, %1
  store double %add, double* %rel, align 8
  %img = getelementptr inbounds %struct.Complex, %struct.Complex* %agg.result, i32 0, i32 1
  %img3 = getelementptr inbounds %struct.Complex, %struct.Complex* %a, i32 0, i32 1
  %2 = load double, double* %img3, align 8
  %img4 = getelementptr inbounds %struct.Complex, %struct.Complex* %b, i32 0, i32 1
  %3 = load double, double* %img4, align 8
  %add5 = fadd double %2, %3
  store double %add5, double* %img, align 8
  ret void
}

; Function Attrs: noinline nounwind optnone
define hidden void @mulComplex(%struct.Complex* noalias sret align 8 %agg.result, %struct.Complex* byval(%struct.Complex) align 8 %a, %struct.Complex* byval(%struct.Complex) align 8 %b) #0 {
entry:
  %rel = getelementptr inbounds %struct.Complex, %struct.Complex* %agg.result, i32 0, i32 0
  %rel1 = getelementptr inbounds %struct.Complex, %struct.Complex* %a, i32 0, i32 0
  %0 = load double, double* %rel1, align 8
  %rel2 = getelementptr inbounds %struct.Complex, %struct.Complex* %b, i32 0, i32 0
  %1 = load double, double* %rel2, align 8
  %mul = fmul double %0, %1
  %img = getelementptr inbounds %struct.Complex, %struct.Complex* %a, i32 0, i32 1
  %2 = load double, double* %img, align 8
  %img3 = getelementptr inbounds %struct.Complex, %struct.Complex* %b, i32 0, i32 1
  %3 = load double, double* %img3, align 8
  %mul4 = fmul double %2, %3
  %sub = fsub double %mul, %mul4
  store double %sub, double* %rel, align 8
  %img5 = getelementptr inbounds %struct.Complex, %struct.Complex* %agg.result, i32 0, i32 1
  %rel6 = getelementptr inbounds %struct.Complex, %struct.Complex* %a, i32 0, i32 0
  %4 = load double, double* %rel6, align 8
  %img7 = getelementptr inbounds %struct.Complex, %struct.Complex* %b, i32 0, i32 1
  %5 = load double, double* %img7, align 8
  %mul8 = fmul double %4, %5
  %img9 = getelementptr inbounds %struct.Complex, %struct.Complex* %a, i32 0, i32 1
  %6 = load double, double* %img9, align 8
  %rel10 = getelementptr inbounds %struct.Complex, %struct.Complex* %b, i32 0, i32 0
  %7 = load double, double* %rel10, align 8
  %mul11 = fmul double %6, %7
  %sub12 = fsub double %mul8, %mul11
  store double %sub12, double* %img5, align 8
  ret void
}

; Function Attrs: noinline nounwind optnone
define hidden void @mulComplexD(%struct.Complex* noalias sret align 8 %agg.result, %struct.Complex* byval(%struct.Complex) align 8 %a, double %b) #0 {
entry:
  %b.addr = alloca double, align 8
  store double %b, double* %b.addr, align 8
  %rel = getelementptr inbounds %struct.Complex, %struct.Complex* %agg.result, i32 0, i32 0
  %rel1 = getelementptr inbounds %struct.Complex, %struct.Complex* %a, i32 0, i32 0
  %0 = load double, double* %rel1, align 8
  %1 = load double, double* %b.addr, align 8
  %mul = fmul double %0, %1
  store double %mul, double* %rel, align 8
  %img = getelementptr inbounds %struct.Complex, %struct.Complex* %agg.result, i32 0, i32 1
  %img2 = getelementptr inbounds %struct.Complex, %struct.Complex* %a, i32 0, i32 1
  %2 = load double, double* %img2, align 8
  %3 = load double, double* %b.addr, align 8
  %mul3 = fmul double %2, %3
  store double %mul3, double* %img, align 8
  ret void
}

; Function Attrs: noinline nounwind optnone
define hidden void @negComplex(%struct.Complex* noalias sret align 8 %agg.result, %struct.Complex* byval(%struct.Complex) align 8 %a) #0 {
entry:
  call void @mulComplexD(%struct.Complex* sret align 8 %agg.result, %struct.Complex* byval(%struct.Complex) align 8 %a, double -1.000000e+00)
  ret void
}

; Function Attrs: noinline nounwind optnone
define hidden void @divComplex(%struct.Complex* noalias sret align 8 %agg.result, %struct.Complex* byval(%struct.Complex) align 8 %a, %struct.Complex* byval(%struct.Complex) align 8 %b) #0 {
entry:
  %re = alloca double, align 8
  %im = alloca double, align 8
  %d = alloca double, align 8
  %rel = getelementptr inbounds %struct.Complex, %struct.Complex* %a, i32 0, i32 0
  %0 = load double, double* %rel, align 8
  %rel1 = getelementptr inbounds %struct.Complex, %struct.Complex* %b, i32 0, i32 0
  %1 = load double, double* %rel1, align 8
  %mul = fmul double %0, %1
  %img = getelementptr inbounds %struct.Complex, %struct.Complex* %a, i32 0, i32 1
  %2 = load double, double* %img, align 8
  %img2 = getelementptr inbounds %struct.Complex, %struct.Complex* %b, i32 0, i32 1
  %3 = load double, double* %img2, align 8
  %mul3 = fmul double %2, %3
  %add = fadd double %mul, %mul3
  store double %add, double* %re, align 8
  %img4 = getelementptr inbounds %struct.Complex, %struct.Complex* %a, i32 0, i32 1
  %4 = load double, double* %img4, align 8
  %rel5 = getelementptr inbounds %struct.Complex, %struct.Complex* %b, i32 0, i32 0
  %5 = load double, double* %rel5, align 8
  %mul6 = fmul double %4, %5
  %rel7 = getelementptr inbounds %struct.Complex, %struct.Complex* %a, i32 0, i32 0
  %6 = load double, double* %rel7, align 8
  %img8 = getelementptr inbounds %struct.Complex, %struct.Complex* %b, i32 0, i32 1
  %7 = load double, double* %img8, align 8
  %mul9 = fmul double %6, %7
  %sub = fsub double %mul6, %mul9
  store double %sub, double* %im, align 8
  %rel10 = getelementptr inbounds %struct.Complex, %struct.Complex* %b, i32 0, i32 0
  %8 = load double, double* %rel10, align 8
  %rel11 = getelementptr inbounds %struct.Complex, %struct.Complex* %b, i32 0, i32 0
  %9 = load double, double* %rel11, align 8
  %mul12 = fmul double %8, %9
  %img13 = getelementptr inbounds %struct.Complex, %struct.Complex* %b, i32 0, i32 1
  %10 = load double, double* %img13, align 8
  %img14 = getelementptr inbounds %struct.Complex, %struct.Complex* %b, i32 0, i32 1
  %11 = load double, double* %img14, align 8
  %mul15 = fmul double %10, %11
  %add16 = fadd double %mul12, %mul15
  store double %add16, double* %d, align 8
  %rel17 = getelementptr inbounds %struct.Complex, %struct.Complex* %agg.result, i32 0, i32 0
  %12 = load double, double* %re, align 8
  %13 = load double, double* %d, align 8
  %div = fdiv double %12, %13
  store double %div, double* %rel17, align 8
  %img18 = getelementptr inbounds %struct.Complex, %struct.Complex* %agg.result, i32 0, i32 1
  %14 = load double, double* %im, align 8
  %15 = load double, double* %d, align 8
  %div19 = fdiv double %14, %15
  store double %div19, double* %img18, align 8
  ret void
}

; Function Attrs: noinline nounwind optnone
define hidden void @inv(%struct.Complex* noalias sret align 8 %agg.result, %struct.Complex* byval(%struct.Complex) align 8 %c) #0 {
entry:
  %d = alloca double, align 8
  %rel = getelementptr inbounds %struct.Complex, %struct.Complex* %c, i32 0, i32 0
  %0 = load double, double* %rel, align 8
  %rel1 = getelementptr inbounds %struct.Complex, %struct.Complex* %c, i32 0, i32 0
  %1 = load double, double* %rel1, align 8
  %mul = fmul double %0, %1
  %img = getelementptr inbounds %struct.Complex, %struct.Complex* %c, i32 0, i32 1
  %2 = load double, double* %img, align 8
  %img2 = getelementptr inbounds %struct.Complex, %struct.Complex* %c, i32 0, i32 1
  %3 = load double, double* %img2, align 8
  %mul3 = fmul double %2, %3
  %add = fadd double %mul, %mul3
  store double %add, double* %d, align 8
  %rel4 = getelementptr inbounds %struct.Complex, %struct.Complex* %agg.result, i32 0, i32 0
  %rel5 = getelementptr inbounds %struct.Complex, %struct.Complex* %c, i32 0, i32 0
  %4 = load double, double* %rel5, align 8
  %5 = load double, double* %d, align 8
  %div = fdiv double %4, %5
  store double %div, double* %rel4, align 8
  %img6 = getelementptr inbounds %struct.Complex, %struct.Complex* %agg.result, i32 0, i32 1
  %img7 = getelementptr inbounds %struct.Complex, %struct.Complex* %c, i32 0, i32 1
  %6 = load double, double* %img7, align 8
  %fneg = fneg double %6
  %7 = load double, double* %d, align 8
  %div8 = fdiv double %fneg, %7
  store double %div8, double* %img6, align 8
  ret void
}

; Function Attrs: noinline nounwind optnone
define hidden void @makeQuaterImaginary(%struct.QuaterImaginary* noalias sret align 4 %agg.result, i8* %s) #0 {
entry:
  %s.addr = alloca i8*, align 4
  %i = alloca i32, align 4
  %valid1 = alloca i32, align 4
  %cnt = alloca i32, align 4
  store i8* %s, i8** %s.addr, align 4
  %b2i = getelementptr inbounds %struct.QuaterImaginary, %struct.QuaterImaginary* %agg.result, i32 0, i32 0
  %0 = load i8*, i8** %s.addr, align 4
  store i8* %0, i8** %b2i, align 4
  %valid = getelementptr inbounds %struct.QuaterImaginary, %struct.QuaterImaginary* %agg.result, i32 0, i32 1
  store i32 0, i32* %valid, align 4
  store i32 1, i32* %valid1, align 4
  store i32 0, i32* %cnt, align 4
  %1 = load i8*, i8** %s.addr, align 4
  %2 = load i8, i8* %1, align 1
  %conv = sext i8 %2 to i32
  %cmp = icmp ne i32 %conv, 0
  br i1 %cmp, label %if.then, label %if.end26

if.then:                                          ; preds = %entry
  store i32 0, i32* %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.then
  %3 = load i8*, i8** %s.addr, align 4
  %4 = load i32, i32* %i, align 4
  %arrayidx = getelementptr inbounds i8, i8* %3, i32 %4
  %5 = load i8, i8* %arrayidx, align 1
  %conv3 = sext i8 %5 to i32
  %cmp4 = icmp ne i32 %conv3, 0
  br i1 %cmp4, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %6 = load i8*, i8** %s.addr, align 4
  %7 = load i32, i32* %i, align 4
  %arrayidx6 = getelementptr inbounds i8, i8* %6, i32 %7
  %8 = load i8, i8* %arrayidx6, align 1
  %conv7 = sext i8 %8 to i32
  %cmp8 = icmp slt i32 %conv7, 48
  br i1 %cmp8, label %if.then14, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %for.body
  %9 = load i8*, i8** %s.addr, align 4
  %10 = load i32, i32* %i, align 4
  %arrayidx10 = getelementptr inbounds i8, i8* %9, i32 %10
  %11 = load i8, i8* %arrayidx10, align 1
  %conv11 = sext i8 %11 to i32
  %cmp12 = icmp slt i32 51, %conv11
  br i1 %cmp12, label %if.then14, label %if.end20

if.then14:                                        ; preds = %lor.lhs.false, %for.body
  %12 = load i8*, i8** %s.addr, align 4
  %13 = load i32, i32* %i, align 4
  %arrayidx15 = getelementptr inbounds i8, i8* %12, i32 %13
  %14 = load i8, i8* %arrayidx15, align 1
  %conv16 = sext i8 %14 to i32
  %cmp17 = icmp eq i32 %conv16, 46
  br i1 %cmp17, label %if.then19, label %if.else

if.then19:                                        ; preds = %if.then14
  %15 = load i32, i32* %cnt, align 4
  %inc = add i32 %15, 1
  store i32 %inc, i32* %cnt, align 4
  br label %if.end

if.else:                                          ; preds = %if.then14
  store i32 0, i32* %valid1, align 4
  br label %for.end

if.end:                                           ; preds = %if.then19
  br label %if.end20

if.end20:                                         ; preds = %if.end, %lor.lhs.false
  br label %for.inc

for.inc:                                          ; preds = %if.end20
  %16 = load i32, i32* %i, align 4
  %inc21 = add i32 %16, 1
  store i32 %inc21, i32* %i, align 4
  br label %for.cond

for.end:                                          ; preds = %if.else, %for.cond
  %17 = load i32, i32* %valid1, align 4
  %tobool = icmp ne i32 %17, 0
  br i1 %tobool, label %land.lhs.true, label %if.end25

land.lhs.true:                                    ; preds = %for.end
  %18 = load i32, i32* %cnt, align 4
  %cmp22 = icmp ugt i32 %18, 1
  br i1 %cmp22, label %if.then24, label %if.end25

if.then24:                                        ; preds = %land.lhs.true
  store i32 0, i32* %valid1, align 4
  br label %if.end25

if.end25:                                         ; preds = %if.then24, %land.lhs.true, %for.end
  br label %if.end26

if.end26:                                         ; preds = %if.end25, %entry
  %19 = load i32, i32* %valid1, align 4
  %valid27 = getelementptr inbounds %struct.QuaterImaginary, %struct.QuaterImaginary* %agg.result, i32 0, i32 1
  store i32 %19, i32* %valid27, align 4
  ret void
}

; Function Attrs: noinline nounwind optnone
define hidden void @printQuaterImaginary(%struct.QuaterImaginary* byval(%struct.QuaterImaginary) align 4 %qi) #0 {
entry:
  %valid = getelementptr inbounds %struct.QuaterImaginary, %struct.QuaterImaginary* %qi, i32 0, i32 1
  %0 = load i32, i32* %valid, align 4
  %tobool = icmp ne i32 %0, 0
  br i1 %tobool, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  %b2i = getelementptr inbounds %struct.QuaterImaginary, %struct.QuaterImaginary* %qi, i32 0, i32 0
  %1 = load i8*, i8** %b2i, align 4
  %call = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([4 x i8], [4 x i8]* @.str.1, i32 0, i32 0), i8* %1)
  br label %if.end

if.else:                                          ; preds = %entry
  %call1 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([9 x i8], [9 x i8]* @.str.2, i32 0, i32 0))
  br label %if.end

if.end:                                           ; preds = %if.else, %if.then
  ret void
}

; Function Attrs: noinline nounwind optnone
define hidden void @qi2c(%struct.Complex* noalias sret align 8 %agg.result, %struct.QuaterImaginary* byval(%struct.QuaterImaginary) align 4 %qi) #0 {
entry:
  %len = alloca i32, align 4
  %pointPos = alloca i32, align 4
  %posLen = alloca i32, align 4
  %prod = alloca %struct.Complex, align 8
  %j = alloca i32, align 4
  %k = alloca double, align 8
  %tmp = alloca %struct.Complex, align 8
  %agg.tmp = alloca %struct.Complex, align 8
  %tmp10 = alloca %struct.Complex, align 8
  %k18 = alloca double, align 8
  %tmp27 = alloca %struct.Complex, align 8
  %agg.tmp28 = alloca %struct.Complex, align 8
  %tmp30 = alloca %struct.Complex, align 8
  %b2i = getelementptr inbounds %struct.QuaterImaginary, %struct.QuaterImaginary* %qi, i32 0, i32 0
  %0 = load i8*, i8** %b2i, align 4
  %call = call i32 @strlen(i8* %0) #5
  store i32 %call, i32* %len, align 4
  %b2i1 = getelementptr inbounds %struct.QuaterImaginary, %struct.QuaterImaginary* %qi, i32 0, i32 0
  %1 = load i8*, i8** %b2i1, align 4
  %call2 = call i32 @find(i8* %1, i8 signext 46)
  store i32 %call2, i32* %pointPos, align 4
  %2 = load i32, i32* %pointPos, align 4
  %cmp = icmp sgt i32 %2, 0
  br i1 %cmp, label %cond.true, label %cond.false

cond.true:                                        ; preds = %entry
  %3 = load i32, i32* %pointPos, align 4
  br label %cond.end

cond.false:                                       ; preds = %entry
  %4 = load i32, i32* %len, align 4
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi i32 [ %3, %cond.true ], [ %4, %cond.false ]
  store i32 %cond, i32* %posLen, align 4
  call void @makeComplex(%struct.Complex* sret align 8 %agg.result, double 0.000000e+00, double 0.000000e+00)
  call void @makeComplex(%struct.Complex* sret align 8 %prod, double 1.000000e+00, double 0.000000e+00)
  store i32 0, i32* %j, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %cond.end
  %5 = load i32, i32* %j, align 4
  %6 = load i32, i32* %posLen, align 4
  %cmp3 = icmp ult i32 %5, %6
  br i1 %cmp3, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %b2i4 = getelementptr inbounds %struct.QuaterImaginary, %struct.QuaterImaginary* %qi, i32 0, i32 0
  %7 = load i8*, i8** %b2i4, align 4
  %8 = load i32, i32* %posLen, align 4
  %sub = sub i32 %8, 1
  %9 = load i32, i32* %j, align 4
  %sub5 = sub i32 %sub, %9
  %arrayidx = getelementptr inbounds i8, i8* %7, i32 %sub5
  %10 = load i8, i8* %arrayidx, align 1
  %conv = sext i8 %10 to i32
  %sub6 = sub nsw i32 %conv, 48
  %conv7 = sitofp i32 %sub6 to double
  store double %conv7, double* %k, align 8
  %11 = load double, double* %k, align 8
  %cmp8 = fcmp ogt double %11, 0.000000e+00
  br i1 %cmp8, label %if.then, label %if.end

if.then:                                          ; preds = %for.body
  %12 = load double, double* %k, align 8
  call void @mulComplexD(%struct.Complex* sret align 8 %agg.tmp, %struct.Complex* byval(%struct.Complex) align 8 %prod, double %12)
  call void @addComplex(%struct.Complex* sret align 8 %tmp, %struct.Complex* byval(%struct.Complex) align 8 %agg.result, %struct.Complex* byval(%struct.Complex) align 8 %agg.tmp)
  %13 = bitcast %struct.Complex* %agg.result to i8*
  %14 = bitcast %struct.Complex* %tmp to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 8 %13, i8* align 8 %14, i32 16, i1 false)
  br label %if.end

if.end:                                           ; preds = %if.then, %for.body
  call void @mulComplex(%struct.Complex* sret align 8 %tmp10, %struct.Complex* byval(%struct.Complex) align 8 %prod, %struct.Complex* byval(%struct.Complex) align 8 @TWO_I)
  %15 = bitcast %struct.Complex* %prod to i8*
  %16 = bitcast %struct.Complex* %tmp10 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 8 %15, i8* align 8 %16, i32 16, i1 false)
  br label %for.inc

for.inc:                                          ; preds = %if.end
  %17 = load i32, i32* %j, align 4
  %inc = add i32 %17, 1
  store i32 %inc, i32* %j, align 4
  br label %for.cond

for.end:                                          ; preds = %for.cond
  %18 = load i32, i32* %pointPos, align 4
  %cmp11 = icmp ne i32 %18, -1
  br i1 %cmp11, label %if.then13, label %if.end34

if.then13:                                        ; preds = %for.end
  %19 = bitcast %struct.Complex* %prod to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 8 %19, i8* align 8 bitcast (%struct.Complex* @INV_TWO_I to i8*), i32 16, i1 false)
  %20 = load i32, i32* %posLen, align 4
  %add = add i32 %20, 1
  store i32 %add, i32* %j, align 4
  br label %for.cond14

for.cond14:                                       ; preds = %for.inc31, %if.then13
  %21 = load i32, i32* %j, align 4
  %22 = load i32, i32* %len, align 4
  %cmp15 = icmp ult i32 %21, %22
  br i1 %cmp15, label %for.body17, label %for.end33

for.body17:                                       ; preds = %for.cond14
  %b2i19 = getelementptr inbounds %struct.QuaterImaginary, %struct.QuaterImaginary* %qi, i32 0, i32 0
  %23 = load i8*, i8** %b2i19, align 4
  %24 = load i32, i32* %j, align 4
  %arrayidx20 = getelementptr inbounds i8, i8* %23, i32 %24
  %25 = load i8, i8* %arrayidx20, align 1
  %conv21 = sext i8 %25 to i32
  %sub22 = sub nsw i32 %conv21, 48
  %conv23 = sitofp i32 %sub22 to double
  store double %conv23, double* %k18, align 8
  %26 = load double, double* %k18, align 8
  %cmp24 = fcmp ogt double %26, 0.000000e+00
  br i1 %cmp24, label %if.then26, label %if.end29

if.then26:                                        ; preds = %for.body17
  %27 = load double, double* %k18, align 8
  call void @mulComplexD(%struct.Complex* sret align 8 %agg.tmp28, %struct.Complex* byval(%struct.Complex) align 8 %prod, double %27)
  call void @addComplex(%struct.Complex* sret align 8 %tmp27, %struct.Complex* byval(%struct.Complex) align 8 %agg.result, %struct.Complex* byval(%struct.Complex) align 8 %agg.tmp28)
  %28 = bitcast %struct.Complex* %agg.result to i8*
  %29 = bitcast %struct.Complex* %tmp27 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 8 %28, i8* align 8 %29, i32 16, i1 false)
  br label %if.end29

if.end29:                                         ; preds = %if.then26, %for.body17
  call void @mulComplex(%struct.Complex* sret align 8 %tmp30, %struct.Complex* byval(%struct.Complex) align 8 %prod, %struct.Complex* byval(%struct.Complex) align 8 @INV_TWO_I)
  %30 = bitcast %struct.Complex* %prod to i8*
  %31 = bitcast %struct.Complex* %tmp30 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 8 %30, i8* align 8 %31, i32 16, i1 false)
  br label %for.inc31

for.inc31:                                        ; preds = %if.end29
  %32 = load i32, i32* %j, align 4
  %inc32 = add i32 %32, 1
  store i32 %inc32, i32* %j, align 4
  br label %for.cond14

for.end33:                                        ; preds = %for.cond14
  br label %if.end34

if.end34:                                         ; preds = %for.end33, %for.end
  ret void
}

; Function Attrs: nounwind readonly
declare i32 @strlen(i8* %0) #2

; Function Attrs: argmemonly nounwind willreturn
declare void @llvm.memcpy.p0i8.p0i8.i32(i8* noalias nocapture writeonly %0, i8* noalias nocapture readonly %1, i32 %2, i1 immarg %3) #3

; Function Attrs: noinline nounwind optnone
define hidden void @c2qi(%struct.QuaterImaginary* noalias sret align 4 %agg.result, %struct.Complex* byval(%struct.Complex) align 8 %c, i8* %out) #0 {
entry:
  %out.addr = alloca i8*, align 4
  %p = alloca i8*, align 4
  %re = alloca i32, align 4
  %im = alloca i32, align 4
  %fi = alloca i32, align 4
  %rem = alloca i32, align 4
  %index = alloca i32, align 4
  %fc = alloca %struct.Complex, align 8
  %.compoundliteral = alloca %struct.Complex, align 8
  %.compoundliteral21 = alloca %struct.Complex, align 8
  %f = alloca double, align 8
  %rem31 = alloca i32, align 4
  %i = alloca i32, align 4
  store i8* %out, i8** %out.addr, align 4
  %0 = load i8*, i8** %out.addr, align 4
  store i8* %0, i8** %p, align 4
  %1 = load i8*, i8** %p, align 4
  store i8 0, i8* %1, align 1
  %rel = getelementptr inbounds %struct.Complex, %struct.Complex* %c, i32 0, i32 0
  %2 = load double, double* %rel, align 8
  %cmp = fcmp oeq double %2, 0.000000e+00
  br i1 %cmp, label %land.lhs.true, label %if.end

land.lhs.true:                                    ; preds = %entry
  %img = getelementptr inbounds %struct.Complex, %struct.Complex* %c, i32 0, i32 1
  %3 = load double, double* %img, align 8
  %cmp1 = fcmp oeq double %3, 0.000000e+00
  br i1 %cmp1, label %if.then, label %if.end

if.then:                                          ; preds = %land.lhs.true
  call void @makeQuaterImaginary(%struct.QuaterImaginary* sret align 4 %agg.result, i8* getelementptr inbounds ([2 x i8], [2 x i8]* @.str.3, i32 0, i32 0))
  br label %return

if.end:                                           ; preds = %land.lhs.true, %entry
  %rel2 = getelementptr inbounds %struct.Complex, %struct.Complex* %c, i32 0, i32 0
  %4 = load double, double* %rel2, align 8
  %conv = fptosi double %4 to i32
  store i32 %conv, i32* %re, align 4
  %img3 = getelementptr inbounds %struct.Complex, %struct.Complex* %c, i32 0, i32 1
  %5 = load double, double* %img3, align 8
  %conv4 = fptosi double %5 to i32
  store i32 %conv4, i32* %im, align 4
  store i32 -1, i32* %fi, align 4
  br label %while.cond

while.cond:                                       ; preds = %if.end11, %if.end
  %6 = load i32, i32* %re, align 4
  %cmp5 = icmp ne i32 %6, 0
  br i1 %cmp5, label %while.body, label %while.end

while.body:                                       ; preds = %while.cond
  %7 = load i32, i32* %re, align 4
  %rem7 = srem i32 %7, -4
  store i32 %rem7, i32* %rem, align 4
  %8 = load i32, i32* %re, align 4
  %div = sdiv i32 %8, -4
  store i32 %div, i32* %re, align 4
  %9 = load i32, i32* %rem, align 4
  %cmp8 = icmp slt i32 %9, 0
  br i1 %cmp8, label %if.then10, label %if.end11

if.then10:                                        ; preds = %while.body
  %10 = load i32, i32* %rem, align 4
  %add = add nsw i32 %10, 4
  store i32 %add, i32* %rem, align 4
  %11 = load i32, i32* %re, align 4
  %inc = add nsw i32 %11, 1
  store i32 %inc, i32* %re, align 4
  br label %if.end11

if.end11:                                         ; preds = %if.then10, %while.body
  %12 = load i32, i32* %rem, align 4
  %add12 = add nsw i32 %12, 48
  %conv13 = trunc i32 %add12 to i8
  %13 = load i8*, i8** %p, align 4
  %incdec.ptr = getelementptr inbounds i8, i8* %13, i32 1
  store i8* %incdec.ptr, i8** %p, align 4
  store i8 %conv13, i8* %13, align 1
  %14 = load i8*, i8** %p, align 4
  %incdec.ptr14 = getelementptr inbounds i8, i8* %14, i32 1
  store i8* %incdec.ptr14, i8** %p, align 4
  store i8 48, i8* %14, align 1
  %15 = load i8*, i8** %p, align 4
  store i8 0, i8* %15, align 1
  br label %while.cond

while.end:                                        ; preds = %while.cond
  %16 = load i32, i32* %im, align 4
  %cmp15 = icmp ne i32 %16, 0
  br i1 %cmp15, label %if.then17, label %if.end53

if.then17:                                        ; preds = %while.end
  store i32 1, i32* %index, align 4
  %rel18 = getelementptr inbounds %struct.Complex, %struct.Complex* %.compoundliteral, i32 0, i32 0
  store double 0.000000e+00, double* %rel18, align 8
  %img19 = getelementptr inbounds %struct.Complex, %struct.Complex* %.compoundliteral, i32 0, i32 1
  %img20 = getelementptr inbounds %struct.Complex, %struct.Complex* %c, i32 0, i32 1
  %17 = load double, double* %img20, align 8
  store double %17, double* %img19, align 8
  %rel22 = getelementptr inbounds %struct.Complex, %struct.Complex* %.compoundliteral21, i32 0, i32 0
  store double 0.000000e+00, double* %rel22, align 8
  %img23 = getelementptr inbounds %struct.Complex, %struct.Complex* %.compoundliteral21, i32 0, i32 1
  store double 2.000000e+00, double* %img23, align 8
  call void @divComplex(%struct.Complex* sret align 8 %fc, %struct.Complex* byval(%struct.Complex) align 8 %.compoundliteral, %struct.Complex* byval(%struct.Complex) align 8 %.compoundliteral21)
  %rel24 = getelementptr inbounds %struct.Complex, %struct.Complex* %fc, i32 0, i32 0
  %18 = load double, double* %rel24, align 8
  store double %18, double* %f, align 8
  %19 = load double, double* %f, align 8
  %20 = call double @llvm.ceil.f64(double %19)
  %conv25 = fptosi double %20 to i32
  store i32 %conv25, i32* %im, align 4
  %21 = load double, double* %f, align 8
  %22 = load i32, i32* %im, align 4
  %conv26 = sitofp i32 %22 to double
  %sub = fsub double %21, %conv26
  %mul = fmul double -4.000000e+00, %sub
  store double %mul, double* %f, align 8
  br label %while.cond27

while.cond27:                                     ; preds = %if.end49, %if.then17
  %23 = load i32, i32* %im, align 4
  %cmp28 = icmp ne i32 %23, 0
  br i1 %cmp28, label %while.body30, label %while.end51

while.body30:                                     ; preds = %while.cond27
  %24 = load i32, i32* %im, align 4
  %rem32 = srem i32 %24, -4
  store i32 %rem32, i32* %rem31, align 4
  %25 = load i32, i32* %im, align 4
  %div33 = sdiv i32 %25, -4
  store i32 %div33, i32* %im, align 4
  %26 = load i32, i32* %rem31, align 4
  %cmp34 = icmp slt i32 %26, 0
  br i1 %cmp34, label %if.then36, label %if.end39

if.then36:                                        ; preds = %while.body30
  %27 = load i32, i32* %rem31, align 4
  %add37 = add nsw i32 %27, 4
  store i32 %add37, i32* %rem31, align 4
  %28 = load i32, i32* %im, align 4
  %inc38 = add nsw i32 %28, 1
  store i32 %inc38, i32* %im, align 4
  br label %if.end39

if.end39:                                         ; preds = %if.then36, %while.body30
  %29 = load i32, i32* %index, align 4
  %30 = load i8*, i8** %p, align 4
  %31 = load i8*, i8** %out.addr, align 4
  %sub.ptr.lhs.cast = ptrtoint i8* %30 to i32
  %sub.ptr.rhs.cast = ptrtoint i8* %31 to i32
  %sub.ptr.sub = sub i32 %sub.ptr.lhs.cast, %sub.ptr.rhs.cast
  %cmp40 = icmp ult i32 %29, %sub.ptr.sub
  br i1 %cmp40, label %if.then42, label %if.else

if.then42:                                        ; preds = %if.end39
  %32 = load i32, i32* %rem31, align 4
  %add43 = add nsw i32 %32, 48
  %conv44 = trunc i32 %add43 to i8
  %33 = load i8*, i8** %out.addr, align 4
  %34 = load i32, i32* %index, align 4
  %arrayidx = getelementptr inbounds i8, i8* %33, i32 %34
  store i8 %conv44, i8* %arrayidx, align 1
  br label %if.end49

if.else:                                          ; preds = %if.end39
  %35 = load i8*, i8** %p, align 4
  %incdec.ptr45 = getelementptr inbounds i8, i8* %35, i32 1
  store i8* %incdec.ptr45, i8** %p, align 4
  store i8 48, i8* %35, align 1
  %36 = load i32, i32* %rem31, align 4
  %add46 = add nsw i32 %36, 48
  %conv47 = trunc i32 %add46 to i8
  %37 = load i8*, i8** %p, align 4
  %incdec.ptr48 = getelementptr inbounds i8, i8* %37, i32 1
  store i8* %incdec.ptr48, i8** %p, align 4
  store i8 %conv47, i8* %37, align 1
  %38 = load i8*, i8** %p, align 4
  store i8 0, i8* %38, align 1
  br label %if.end49

if.end49:                                         ; preds = %if.else, %if.then42
  %39 = load i32, i32* %index, align 4
  %add50 = add i32 %39, 2
  store i32 %add50, i32* %index, align 4
  br label %while.cond27

while.end51:                                      ; preds = %while.cond27
  %40 = load double, double* %f, align 8
  %conv52 = fptosi double %40 to i32
  store i32 %conv52, i32* %fi, align 4
  br label %if.end53

if.end53:                                         ; preds = %while.end51, %while.end
  %41 = load i8*, i8** %out.addr, align 4
  %42 = load i8*, i8** %p, align 4
  call void @reverse(i8* %41, i8* %42)
  %43 = load i32, i32* %fi, align 4
  %cmp54 = icmp ne i32 %43, -1
  br i1 %cmp54, label %if.then56, label %if.end61

if.then56:                                        ; preds = %if.end53
  %44 = load i8*, i8** %p, align 4
  %incdec.ptr57 = getelementptr inbounds i8, i8* %44, i32 1
  store i8* %incdec.ptr57, i8** %p, align 4
  store i8 46, i8* %44, align 1
  %45 = load i32, i32* %fi, align 4
  %add58 = add nsw i32 %45, 48
  %conv59 = trunc i32 %add58 to i8
  %46 = load i8*, i8** %p, align 4
  %incdec.ptr60 = getelementptr inbounds i8, i8* %46, i32 1
  store i8* %incdec.ptr60, i8** %p, align 4
  store i8 %conv59, i8* %46, align 1
  %47 = load i8*, i8** %p, align 4
  store i8 0, i8* %47, align 1
  br label %if.end61

if.end61:                                         ; preds = %if.then56, %if.end53
  br label %while.cond62

while.cond62:                                     ; preds = %for.end, %if.end61
  %48 = load i8*, i8** %out.addr, align 4
  %arrayidx63 = getelementptr inbounds i8, i8* %48, i32 0
  %49 = load i8, i8* %arrayidx63, align 1
  %conv64 = sext i8 %49 to i32
  %cmp65 = icmp eq i32 %conv64, 48
  br i1 %cmp65, label %land.rhs, label %land.end

land.rhs:                                         ; preds = %while.cond62
  %50 = load i8*, i8** %out.addr, align 4
  %arrayidx67 = getelementptr inbounds i8, i8* %50, i32 1
  %51 = load i8, i8* %arrayidx67, align 1
  %conv68 = sext i8 %51 to i32
  %cmp69 = icmp ne i32 %conv68, 46
  br label %land.end

land.end:                                         ; preds = %land.rhs, %while.cond62
  %52 = phi i1 [ false, %while.cond62 ], [ %cmp69, %land.rhs ]
  br i1 %52, label %while.body71, label %while.end80

while.body71:                                     ; preds = %land.end
  store i32 0, i32* %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %while.body71
  %53 = load i8*, i8** %out.addr, align 4
  %54 = load i32, i32* %i, align 4
  %arrayidx72 = getelementptr inbounds i8, i8* %53, i32 %54
  %55 = load i8, i8* %arrayidx72, align 1
  %conv73 = sext i8 %55 to i32
  %cmp74 = icmp ne i32 %conv73, 0
  br i1 %cmp74, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %56 = load i8*, i8** %out.addr, align 4
  %57 = load i32, i32* %i, align 4
  %add76 = add i32 %57, 1
  %arrayidx77 = getelementptr inbounds i8, i8* %56, i32 %add76
  %58 = load i8, i8* %arrayidx77, align 1
  %59 = load i8*, i8** %out.addr, align 4
  %60 = load i32, i32* %i, align 4
  %arrayidx78 = getelementptr inbounds i8, i8* %59, i32 %60
  store i8 %58, i8* %arrayidx78, align 1
  br label %for.inc

for.inc:                                          ; preds = %for.body
  %61 = load i32, i32* %i, align 4
  %inc79 = add i32 %61, 1
  store i32 %inc79, i32* %i, align 4
  br label %for.cond

for.end:                                          ; preds = %for.cond
  br label %while.cond62

while.end80:                                      ; preds = %land.end
  %62 = load i8*, i8** %out.addr, align 4
  %63 = load i8, i8* %62, align 1
  %conv81 = sext i8 %63 to i32
  %cmp82 = icmp eq i32 %conv81, 46
  br i1 %cmp82, label %if.then84, label %if.end86

if.then84:                                        ; preds = %while.end80
  %64 = load i8*, i8** %out.addr, align 4
  %65 = load i8*, i8** %p, align 4
  call void @reverse(i8* %64, i8* %65)
  %66 = load i8*, i8** %p, align 4
  %incdec.ptr85 = getelementptr inbounds i8, i8* %66, i32 1
  store i8* %incdec.ptr85, i8** %p, align 4
  store i8 48, i8* %66, align 1
  %67 = load i8*, i8** %p, align 4
  store i8 0, i8* %67, align 1
  %68 = load i8*, i8** %out.addr, align 4
  %69 = load i8*, i8** %p, align 4
  call void @reverse(i8* %68, i8* %69)
  br label %if.end86

if.end86:                                         ; preds = %if.then84, %while.end80
  %70 = load i8*, i8** %out.addr, align 4
  call void @makeQuaterImaginary(%struct.QuaterImaginary* sret align 4 %agg.result, i8* %70)
  br label %return

return:                                           ; preds = %if.end86, %if.then
  ret void
}

; Function Attrs: nounwind readnone speculatable willreturn
declare double @llvm.ceil.f64(double %0) #4

; Function Attrs: noinline nounwind optnone
define hidden i32 @main() #0 {
entry:
  %retval = alloca i32, align 4
  %buffer = alloca [16 x i8], align 16
  %i = alloca i32, align 4
  %c1 = alloca %struct.Complex, align 8
  %qi = alloca %struct.QuaterImaginary, align 4
  %c2 = alloca %struct.Complex, align 8
  %tmp = alloca %struct.Complex, align 8
  %tmp3 = alloca %struct.QuaterImaginary, align 4
  %tmp5 = alloca %struct.Complex, align 8
  %c114 = alloca %struct.Complex, align 8
  %qi18 = alloca %struct.QuaterImaginary, align 4
  %c220 = alloca %struct.Complex, align 8
  %tmp24 = alloca %struct.Complex, align 8
  %tmp25 = alloca %struct.QuaterImaginary, align 4
  %tmp27 = alloca %struct.Complex, align 8
  store i32 0, i32* %retval, align 4
  store i32 1, i32* %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %0 = load i32, i32* %i, align 4
  %cmp = icmp sle i32 %0, 16
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %rel = getelementptr inbounds %struct.Complex, %struct.Complex* %c1, i32 0, i32 0
  %1 = load i32, i32* %i, align 4
  %conv = sitofp i32 %1 to double
  store double %conv, double* %rel, align 8
  %img = getelementptr inbounds %struct.Complex, %struct.Complex* %c1, i32 0, i32 1
  store double 0.000000e+00, double* %img, align 8
  %arraydecay = getelementptr inbounds [16 x i8], [16 x i8]* %buffer, i32 0, i32 0
  call void @c2qi(%struct.QuaterImaginary* sret align 4 %qi, %struct.Complex* byval(%struct.Complex) align 8 %c1, i8* %arraydecay)
  call void @qi2c(%struct.Complex* sret align 8 %c2, %struct.QuaterImaginary* byval(%struct.QuaterImaginary) align 4 %qi)
  call void @printComplex(%struct.Complex* byval(%struct.Complex) align 8 %c1)
  %call = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.4, i32 0, i32 0))
  call void @printQuaterImaginary(%struct.QuaterImaginary* byval(%struct.QuaterImaginary) align 4 %qi)
  %call1 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.4, i32 0, i32 0))
  call void @printComplex(%struct.Complex* byval(%struct.Complex) align 8 %c2)
  %call2 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([6 x i8], [6 x i8]* @.str.5, i32 0, i32 0))
  call void @negComplex(%struct.Complex* sret align 8 %tmp, %struct.Complex* byval(%struct.Complex) align 8 %c1)
  %2 = bitcast %struct.Complex* %c1 to i8*
  %3 = bitcast %struct.Complex* %tmp to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 8 %2, i8* align 8 %3, i32 16, i1 false)
  %arraydecay4 = getelementptr inbounds [16 x i8], [16 x i8]* %buffer, i32 0, i32 0
  call void @c2qi(%struct.QuaterImaginary* sret align 4 %tmp3, %struct.Complex* byval(%struct.Complex) align 8 %c1, i8* %arraydecay4)
  %4 = bitcast %struct.QuaterImaginary* %qi to i8*
  %5 = bitcast %struct.QuaterImaginary* %tmp3 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 4 %4, i8* align 4 %5, i32 8, i1 false)
  call void @qi2c(%struct.Complex* sret align 8 %tmp5, %struct.QuaterImaginary* byval(%struct.QuaterImaginary) align 4 %qi)
  %6 = bitcast %struct.Complex* %c2 to i8*
  %7 = bitcast %struct.Complex* %tmp5 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 8 %6, i8* align 8 %7, i32 16, i1 false)
  call void @printComplex(%struct.Complex* byval(%struct.Complex) align 8 %c1)
  %call6 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.4, i32 0, i32 0))
  call void @printQuaterImaginary(%struct.QuaterImaginary* byval(%struct.QuaterImaginary) align 4 %qi)
  %call7 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.4, i32 0, i32 0))
  call void @printComplex(%struct.Complex* byval(%struct.Complex) align 8 %c2)
  %call8 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([2 x i8], [2 x i8]* @.str.6, i32 0, i32 0))
  br label %for.inc

for.inc:                                          ; preds = %for.body
  %8 = load i32, i32* %i, align 4
  %inc = add nsw i32 %8, 1
  store i32 %inc, i32* %i, align 4
  br label %for.cond

for.end:                                          ; preds = %for.cond
  %call9 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([2 x i8], [2 x i8]* @.str.6, i32 0, i32 0))
  store i32 1, i32* %i, align 4
  br label %for.cond10

for.cond10:                                       ; preds = %for.inc31, %for.end
  %9 = load i32, i32* %i, align 4
  %cmp11 = icmp sle i32 %9, 16
  br i1 %cmp11, label %for.body13, label %for.end33

for.body13:                                       ; preds = %for.cond10
  %rel15 = getelementptr inbounds %struct.Complex, %struct.Complex* %c114, i32 0, i32 0
  store double 0.000000e+00, double* %rel15, align 8
  %img16 = getelementptr inbounds %struct.Complex, %struct.Complex* %c114, i32 0, i32 1
  %10 = load i32, i32* %i, align 4
  %conv17 = sitofp i32 %10 to double
  store double %conv17, double* %img16, align 8
  %arraydecay19 = getelementptr inbounds [16 x i8], [16 x i8]* %buffer, i32 0, i32 0
  call void @c2qi(%struct.QuaterImaginary* sret align 4 %qi18, %struct.Complex* byval(%struct.Complex) align 8 %c114, i8* %arraydecay19)
  call void @qi2c(%struct.Complex* sret align 8 %c220, %struct.QuaterImaginary* byval(%struct.QuaterImaginary) align 4 %qi18)
  call void @printComplex(%struct.Complex* byval(%struct.Complex) align 8 %c114)
  %call21 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.4, i32 0, i32 0))
  call void @printQuaterImaginary(%struct.QuaterImaginary* byval(%struct.QuaterImaginary) align 4 %qi18)
  %call22 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.4, i32 0, i32 0))
  call void @printComplex(%struct.Complex* byval(%struct.Complex) align 8 %c220)
  %call23 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([6 x i8], [6 x i8]* @.str.5, i32 0, i32 0))
  call void @negComplex(%struct.Complex* sret align 8 %tmp24, %struct.Complex* byval(%struct.Complex) align 8 %c114)
  %11 = bitcast %struct.Complex* %c114 to i8*
  %12 = bitcast %struct.Complex* %tmp24 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 8 %11, i8* align 8 %12, i32 16, i1 false)
  %arraydecay26 = getelementptr inbounds [16 x i8], [16 x i8]* %buffer, i32 0, i32 0
  call void @c2qi(%struct.QuaterImaginary* sret align 4 %tmp25, %struct.Complex* byval(%struct.Complex) align 8 %c114, i8* %arraydecay26)
  %13 = bitcast %struct.QuaterImaginary* %qi18 to i8*
  %14 = bitcast %struct.QuaterImaginary* %tmp25 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 4 %13, i8* align 4 %14, i32 8, i1 false)
  call void @qi2c(%struct.Complex* sret align 8 %tmp27, %struct.QuaterImaginary* byval(%struct.QuaterImaginary) align 4 %qi18)
  %15 = bitcast %struct.Complex* %c220 to i8*
  %16 = bitcast %struct.Complex* %tmp27 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 8 %15, i8* align 8 %16, i32 16, i1 false)
  call void @printComplex(%struct.Complex* byval(%struct.Complex) align 8 %c114)
  %call28 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.4, i32 0, i32 0))
  call void @printQuaterImaginary(%struct.QuaterImaginary* byval(%struct.QuaterImaginary) align 4 %qi18)
  %call29 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.4, i32 0, i32 0))
  call void @printComplex(%struct.Complex* byval(%struct.Complex) align 8 %c220)
  %call30 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([2 x i8], [2 x i8]* @.str.6, i32 0, i32 0))
  br label %for.inc31

for.inc31:                                        ; preds = %for.body13
  %17 = load i32, i32* %i, align 4
  %inc32 = add nsw i32 %17, 1
  store i32 %inc32, i32* %i, align 4
  br label %for.cond10

for.end33:                                        ; preds = %for.cond10
  ret i32 0
}

attributes #0 = { noinline nounwind optnone "correctly-rounded-divide-sqrt-fp-math"="false" "disable-tail-calls"="false" "frame-pointer"="none" "less-precise-fpmad"="false" "min-legal-vector-width"="0" "no-infs-fp-math"="false" "no-jump-tables"="false" "no-nans-fp-math"="false" "no-signed-zeros-fp-math"="false" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="generic" "unsafe-fp-math"="false" "use-soft-float"="false" }
attributes #1 = { "correctly-rounded-divide-sqrt-fp-math"="false" "disable-tail-calls"="false" "frame-pointer"="none" "less-precise-fpmad"="false" "no-infs-fp-math"="false" "no-nans-fp-math"="false" "no-signed-zeros-fp-math"="false" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="generic" "unsafe-fp-math"="false" "use-soft-float"="false" }
attributes #2 = { nounwind readonly "correctly-rounded-divide-sqrt-fp-math"="false" "disable-tail-calls"="false" "frame-pointer"="none" "less-precise-fpmad"="false" "no-infs-fp-math"="false" "no-nans-fp-math"="false" "no-signed-zeros-fp-math"="false" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="generic" "unsafe-fp-math"="false" "use-soft-float"="false" }
attributes #3 = { argmemonly nounwind willreturn }
attributes #4 = { nounwind readnone speculatable willreturn }
attributes #5 = { nounwind readonly }

!llvm.module.flags = !{!0}
!llvm.ident = !{!1}

!0 = !{i32 1, !"wchar_size", i32 4}
!1 = !{!"clang version 11.0.0 (https://github.com/Jacarte/llvm-project.git 0f6dea67136cc1e0b3d200eb2bb165628970c44b)"}

; extracted candidates

; *****
; For LLVM instruction:
;  %0 = load i32, i32* %i, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %cmp = icmp sle i32 %0, 16
; Looking for a replacement for:
%0:i32 = var
%1:i1 = sle %0, 16:i32
infer %1

; *****
; For LLVM instruction:
;  %1 = load i32, i32* %i, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %8 = load i32, i32* %i, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %inc = add nsw i32 %8, 1
; Looking for a replacement for:
%0:i32 = var
%1:i32 = addnsw 1:i32, %0
infer %1

; *****
; For LLVM instruction:
;  %9 = load i32, i32* %i, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %cmp11 = icmp sle i32 %9, 16
; Looking for a replacement for:
%0:i32 = var
%1:i1 = sle %0, 16:i32
infer %1

; *****
; For LLVM instruction:
;  %10 = load i32, i32* %i, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %17 = load i32, i32* %i, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %inc32 = add nsw i32 %17, 1
; Looking for a replacement for:
%0:i32 = var
%1:i32 = addnsw 1:i32, %0
infer %1
got 2 candidates from LHS

-------------------------------------------------
%0:i32 = var
%1:i1 = sle %0, 16:i32
infer %1


--------------------------------
guess 0

%0:i1 = var ; reservedconst_1

Cost = 0
first query is SAT, returning the model:
reservedconst_1: -1
0 th attempt: second query is SAT-- constant doesn't work
first query is SAT, returning the model:
reservedconst_1: 0
1 th attempt: second query is SAT-- constant doesn't work
first query is UNSAT-- no more guesses
Dataflow Pruned 0/0
There are 1 Guesses
There are 0 RHSs before deduplication
There are 0 RHSs after deduplication
#########################################################
; exiting Souper's runOnFunction() for main()
Total of 0 replacements done on this module
Total of 0 replacements candidates on this module
