
Entering the Souper pass's runOnModule()


; entering Souper's runOnFunction() for get_item()

; ModuleID = './Topological_sort.c.bc'
source_filename = "./Topological_sort.c"
target datalayout = "e-m:e-p:32:32-i64:64-n32:64-S128"
target triple = "wasm32-unknown-wasi"

%struct.item_t = type { i8*, i32*, i32, i32, i32 }

@input = hidden global [583 x i8] c"des_system_lib   std synopsys std_cell_lib des_system_lib dw02 dw01 ramlib ieee\0Adw01             ieee dw01 dware gtech\0Adw02             ieee dw02 dware\0Adw03             std synopsys dware dw03 dw02 dw01 ieee gtech\0Adw04             dw04 ieee dw01 dware gtech\0Adw05             dw05 ieee dware\0Adw06             dw06 ieee dware\0Adw07             ieee dware\0Adware            ieee dware\0Agtech            ieee gtech\0Aramlib           std ieee\0Astd_cell_lib     ieee std_cell_lib\0Asynopsys\0Acycle_11\09  cycle_12\0Acycle_12\09  cycle_11\0Acycle_21\09  dw01 cycle_22 dw02 dw03\0Acycle_22\09  cycle_21 dw01 dw04\00", align 16
@.str = private unnamed_addr constant [2 x i8] c"\0A\00", align 1
@.str.1 = private unnamed_addr constant [3 x i8] c" \09\00", align 1
@.str.2 = private unnamed_addr constant [16 x i8] c"Compile order:\0A\00", align 1
@.str.3 = private unnamed_addr constant [17 x i8] c"   [unorderable]\00", align 1
@.str.4 = private unnamed_addr constant [4 x i8] c"%d:\00", align 1
@.str.5 = private unnamed_addr constant [4 x i8] c" %s\00", align 1
@llvm.used = appending global [1 x i8*] [i8* bitcast (i32 ()* @__main_void to i8*)], section "llvm.metadata"

@__main_void = alias i32 (), i32 ()* @main

; Function Attrs: noinline nounwind optnone
define hidden i32 @get_item(%struct.item_t** %list, i32* %len, i8* %name) #0 {
entry:
  %retval = alloca i32, align 4
  %list.addr = alloca %struct.item_t**, align 4
  %len.addr = alloca i32*, align 4
  %name.addr = alloca i8*, align 4
  %i = alloca i32, align 4
  %lst = alloca %struct.item_t*, align 4
  store %struct.item_t** %list, %struct.item_t*** %list.addr, align 4
  store i32* %len, i32** %len.addr, align 4
  store i8* %name, i8** %name.addr, align 4
  %0 = load %struct.item_t**, %struct.item_t*** %list.addr, align 4
  %1 = load %struct.item_t*, %struct.item_t** %0, align 4
  store %struct.item_t* %1, %struct.item_t** %lst, align 4
  store i32 0, i32* %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %2 = load i32, i32* %i, align 4
  %3 = load i32*, i32** %len.addr, align 4
  %4 = load i32, i32* %3, align 4
  %cmp = icmp slt i32 %2, %4
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %5 = load %struct.item_t*, %struct.item_t** %lst, align 4
  %6 = load i32, i32* %i, align 4
  %arrayidx = getelementptr inbounds %struct.item_t, %struct.item_t* %5, i32 %6
  %name1 = getelementptr inbounds %struct.item_t, %struct.item_t* %arrayidx, i32 0, i32 0
  %7 = load i8*, i8** %name1, align 4
  %8 = load i8*, i8** %name.addr, align 4
  %call = call i32 @strcmp(i8* %7, i8* %8) #4
  %tobool = icmp ne i32 %call, 0
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %for.body
  %9 = load i32, i32* %i, align 4
  store i32 %9, i32* %retval, align 4
  br label %return

if.end:                                           ; preds = %for.body
  br label %for.inc

for.inc:                                          ; preds = %if.end
  %10 = load i32, i32* %i, align 4
  %inc = add nsw i32 %10, 1
  store i32 %inc, i32* %i, align 4
  br label %for.cond

for.end:                                          ; preds = %for.cond
  %11 = load %struct.item_t*, %struct.item_t** %lst, align 4
  %12 = bitcast %struct.item_t* %11 to i8*
  %13 = load i32*, i32** %len.addr, align 4
  %14 = load i32, i32* %13, align 4
  %inc2 = add nsw i32 %14, 1
  store i32 %inc2, i32* %13, align 4
  %mul = mul i32 %inc2, 20
  %call3 = call i8* @realloc(i8* %12, i32 %mul)
  %15 = bitcast i8* %call3 to %struct.item_t*
  %16 = load %struct.item_t**, %struct.item_t*** %list.addr, align 4
  store %struct.item_t* %15, %struct.item_t** %16, align 4
  store %struct.item_t* %15, %struct.item_t** %lst, align 4
  %17 = load i32*, i32** %len.addr, align 4
  %18 = load i32, i32* %17, align 4
  %sub = sub nsw i32 %18, 1
  store i32 %sub, i32* %i, align 4
  %19 = load %struct.item_t*, %struct.item_t** %lst, align 4
  %20 = load i32, i32* %i, align 4
  %add.ptr = getelementptr inbounds %struct.item_t, %struct.item_t* %19, i32 %20
  %21 = bitcast %struct.item_t* %add.ptr to i8*
  call void @llvm.memset.p0i8.i32(i8* align 4 %21, i8 0, i32 20, i1 false)
  %22 = load i32, i32* %i, align 4
  %23 = load %struct.item_t*, %struct.item_t** %lst, align 4
  %24 = load i32, i32* %i, align 4
  %arrayidx4 = getelementptr inbounds %struct.item_t, %struct.item_t* %23, i32 %24
  %idx = getelementptr inbounds %struct.item_t, %struct.item_t* %arrayidx4, i32 0, i32 3
  store i32 %22, i32* %idx, align 4
  %25 = load i8*, i8** %name.addr, align 4
  %26 = load %struct.item_t*, %struct.item_t** %lst, align 4
  %27 = load i32, i32* %i, align 4
  %arrayidx5 = getelementptr inbounds %struct.item_t, %struct.item_t* %26, i32 %27
  %name6 = getelementptr inbounds %struct.item_t, %struct.item_t* %arrayidx5, i32 0, i32 0
  store i8* %25, i8** %name6, align 4
  %28 = load i32, i32* %i, align 4
  store i32 %28, i32* %retval, align 4
  br label %return

return:                                           ; preds = %for.end, %if.then
  %29 = load i32, i32* %retval, align 4
  ret i32 %29
}

; Function Attrs: nounwind readonly
declare i32 @strcmp(i8* %0, i8* %1) #1

declare i8* @realloc(i8* %0, i32 %1) #2

; Function Attrs: argmemonly nounwind willreturn writeonly
declare void @llvm.memset.p0i8.i32(i8* nocapture writeonly %0, i8 %1, i32 %2, i1 immarg %3) #3

; Function Attrs: noinline nounwind optnone
define hidden void @add_dep(%struct.item_t* %it, i32 %i) #0 {
entry:
  %it.addr = alloca %struct.item_t*, align 4
  %i.addr = alloca i32, align 4
  store %struct.item_t* %it, %struct.item_t** %it.addr, align 4
  store i32 %i, i32* %i.addr, align 4
  %0 = load %struct.item_t*, %struct.item_t** %it.addr, align 4
  %idx = getelementptr inbounds %struct.item_t, %struct.item_t* %0, i32 0, i32 3
  %1 = load i32, i32* %idx, align 4
  %2 = load i32, i32* %i.addr, align 4
  %cmp = icmp eq i32 %1, %2
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  br label %return

if.end:                                           ; preds = %entry
  %3 = load %struct.item_t*, %struct.item_t** %it.addr, align 4
  %deps = getelementptr inbounds %struct.item_t, %struct.item_t* %3, i32 0, i32 1
  %4 = load i32*, i32** %deps, align 4
  %5 = bitcast i32* %4 to i8*
  %6 = load %struct.item_t*, %struct.item_t** %it.addr, align 4
  %n_deps = getelementptr inbounds %struct.item_t, %struct.item_t* %6, i32 0, i32 2
  %7 = load i32, i32* %n_deps, align 4
  %add = add nsw i32 %7, 1
  %mul = mul i32 %add, 4
  %call = call i8* @realloc(i8* %5, i32 %mul)
  %8 = bitcast i8* %call to i32*
  %9 = load %struct.item_t*, %struct.item_t** %it.addr, align 4
  %deps1 = getelementptr inbounds %struct.item_t, %struct.item_t* %9, i32 0, i32 1
  store i32* %8, i32** %deps1, align 4
  %10 = load i32, i32* %i.addr, align 4
  %11 = load %struct.item_t*, %struct.item_t** %it.addr, align 4
  %deps2 = getelementptr inbounds %struct.item_t, %struct.item_t* %11, i32 0, i32 1
  %12 = load i32*, i32** %deps2, align 4
  %13 = load %struct.item_t*, %struct.item_t** %it.addr, align 4
  %n_deps3 = getelementptr inbounds %struct.item_t, %struct.item_t* %13, i32 0, i32 2
  %14 = load i32, i32* %n_deps3, align 4
  %inc = add nsw i32 %14, 1
  store i32 %inc, i32* %n_deps3, align 4
  %arrayidx = getelementptr inbounds i32, i32* %12, i32 %14
  store i32 %10, i32* %arrayidx, align 4
  br label %return

return:                                           ; preds = %if.end, %if.then
  ret void
}

; Function Attrs: noinline nounwind optnone
define hidden i32 @parse_input(%struct.item_t** %ret) #0 {
entry:
  %ret.addr = alloca %struct.item_t**, align 4
  %n_items = alloca i32, align 4
  %i = alloca i32, align 4
  %parent = alloca i32, align 4
  %idx = alloca i32, align 4
  %list = alloca %struct.item_t*, align 4
  %s = alloca i8*, align 4
  %e = alloca i8*, align 4
  %word = alloca i8*, align 4
  %we = alloca i8*, align 4
  store %struct.item_t** %ret, %struct.item_t*** %ret.addr, align 4
  store i32 0, i32* %n_items, align 4
  store %struct.item_t* null, %struct.item_t** %list, align 4
  store i8* getelementptr inbounds ([583 x i8], [583 x i8]* @input, i32 0, i32 0), i8** %s, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc10, %entry
  %0 = load i8*, i8** %s, align 4
  %call = call i8* @strtok_r(i8* %0, i8* getelementptr inbounds ([2 x i8], [2 x i8]* @.str, i32 0, i32 0), i8** %e)
  store i8* %call, i8** %s, align 4
  %tobool = icmp ne i8* %call, null
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %for.cond
  br label %for.end11

if.end:                                           ; preds = %for.cond
  store i32 0, i32* %i, align 4
  %1 = load i8*, i8** %s, align 4
  store i8* %1, i8** %word, align 4
  br label %for.cond1

for.cond1:                                        ; preds = %for.inc, %if.end
  %2 = load i8*, i8** %word, align 4
  %call2 = call i8* @strtok_r(i8* %2, i8* getelementptr inbounds ([3 x i8], [3 x i8]* @.str.1, i32 0, i32 0), i8** %we)
  store i8* %call2, i8** %word, align 4
  %tobool3 = icmp ne i8* %call2, null
  br i1 %tobool3, label %if.end5, label %if.then4

if.then4:                                         ; preds = %for.cond1
  br label %for.end

if.end5:                                          ; preds = %for.cond1
  %3 = load i8*, i8** %word, align 4
  %call6 = call i32 @get_item(%struct.item_t** %list, i32* %n_items, i8* %3)
  store i32 %call6, i32* %idx, align 4
  %4 = load i32, i32* %i, align 4
  %tobool7 = icmp ne i32 %4, 0
  br i1 %tobool7, label %if.else, label %if.then8

if.then8:                                         ; preds = %if.end5
  %5 = load i32, i32* %idx, align 4
  store i32 %5, i32* %parent, align 4
  br label %if.end9

if.else:                                          ; preds = %if.end5
  %6 = load %struct.item_t*, %struct.item_t** %list, align 4
  %7 = load i32, i32* %parent, align 4
  %add.ptr = getelementptr inbounds %struct.item_t, %struct.item_t* %6, i32 %7
  %8 = load i32, i32* %idx, align 4
  call void @add_dep(%struct.item_t* %add.ptr, i32 %8)
  br label %if.end9

if.end9:                                          ; preds = %if.else, %if.then8
  br label %for.inc

for.inc:                                          ; preds = %if.end9
  %9 = load i32, i32* %i, align 4
  %inc = add nsw i32 %9, 1
  store i32 %inc, i32* %i, align 4
  store i8* null, i8** %word, align 4
  br label %for.cond1

for.end:                                          ; preds = %if.then4
  br label %for.inc10

for.inc10:                                        ; preds = %for.end
  store i8* null, i8** %s, align 4
  br label %for.cond

for.end11:                                        ; preds = %if.then
  %10 = load %struct.item_t*, %struct.item_t** %list, align 4
  %11 = load %struct.item_t**, %struct.item_t*** %ret.addr, align 4
  store %struct.item_t* %10, %struct.item_t** %11, align 4
  %12 = load i32, i32* %n_items, align 4
  ret i32 %12
}

declare i8* @strtok_r(i8* %0, i8* %1, i8** %2) #2

; Function Attrs: noinline nounwind optnone
define hidden i32 @get_depth(%struct.item_t* %list, i32 %idx, i32 %bad) #0 {
entry:
  %retval = alloca i32, align 4
  %list.addr = alloca %struct.item_t*, align 4
  %idx.addr = alloca i32, align 4
  %bad.addr = alloca i32, align 4
  %max = alloca i32, align 4
  %i = alloca i32, align 4
  %t = alloca i32, align 4
  store %struct.item_t* %list, %struct.item_t** %list.addr, align 4
  store i32 %idx, i32* %idx.addr, align 4
  store i32 %bad, i32* %bad.addr, align 4
  %0 = load %struct.item_t*, %struct.item_t** %list.addr, align 4
  %1 = load i32, i32* %idx.addr, align 4
  %arrayidx = getelementptr inbounds %struct.item_t, %struct.item_t* %0, i32 %1
  %deps = getelementptr inbounds %struct.item_t, %struct.item_t* %arrayidx, i32 0, i32 1
  %2 = load i32*, i32** %deps, align 4
  %tobool = icmp ne i32* %2, null
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  %3 = load %struct.item_t*, %struct.item_t** %list.addr, align 4
  %4 = load i32, i32* %idx.addr, align 4
  %arrayidx1 = getelementptr inbounds %struct.item_t, %struct.item_t* %3, i32 %4
  %depth = getelementptr inbounds %struct.item_t, %struct.item_t* %arrayidx1, i32 0, i32 4
  store i32 1, i32* %depth, align 4
  store i32 1, i32* %retval, align 4
  br label %return

if.end:                                           ; preds = %entry
  %5 = load %struct.item_t*, %struct.item_t** %list.addr, align 4
  %6 = load i32, i32* %idx.addr, align 4
  %arrayidx2 = getelementptr inbounds %struct.item_t, %struct.item_t* %5, i32 %6
  %depth3 = getelementptr inbounds %struct.item_t, %struct.item_t* %arrayidx2, i32 0, i32 4
  %7 = load i32, i32* %depth3, align 4
  store i32 %7, i32* %t, align 4
  %cmp = icmp slt i32 %7, 0
  br i1 %cmp, label %if.then4, label %if.end5

if.then4:                                         ; preds = %if.end
  %8 = load i32, i32* %t, align 4
  store i32 %8, i32* %retval, align 4
  br label %return

if.end5:                                          ; preds = %if.end
  %9 = load i32, i32* %bad.addr, align 4
  %10 = load %struct.item_t*, %struct.item_t** %list.addr, align 4
  %11 = load i32, i32* %idx.addr, align 4
  %arrayidx6 = getelementptr inbounds %struct.item_t, %struct.item_t* %10, i32 %11
  %depth7 = getelementptr inbounds %struct.item_t, %struct.item_t* %arrayidx6, i32 0, i32 4
  store i32 %9, i32* %depth7, align 4
  store i32 0, i32* %i, align 4
  store i32 0, i32* %max, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.end5
  %12 = load i32, i32* %i, align 4
  %13 = load %struct.item_t*, %struct.item_t** %list.addr, align 4
  %14 = load i32, i32* %idx.addr, align 4
  %arrayidx8 = getelementptr inbounds %struct.item_t, %struct.item_t* %13, i32 %14
  %n_deps = getelementptr inbounds %struct.item_t, %struct.item_t* %arrayidx8, i32 0, i32 2
  %15 = load i32, i32* %n_deps, align 4
  %cmp9 = icmp slt i32 %12, %15
  br i1 %cmp9, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %16 = load %struct.item_t*, %struct.item_t** %list.addr, align 4
  %17 = load %struct.item_t*, %struct.item_t** %list.addr, align 4
  %18 = load i32, i32* %idx.addr, align 4
  %arrayidx10 = getelementptr inbounds %struct.item_t, %struct.item_t* %17, i32 %18
  %deps11 = getelementptr inbounds %struct.item_t, %struct.item_t* %arrayidx10, i32 0, i32 1
  %19 = load i32*, i32** %deps11, align 4
  %20 = load i32, i32* %i, align 4
  %arrayidx12 = getelementptr inbounds i32, i32* %19, i32 %20
  %21 = load i32, i32* %arrayidx12, align 4
  %22 = load i32, i32* %bad.addr, align 4
  %call = call i32 @get_depth(%struct.item_t* %16, i32 %21, i32 %22)
  store i32 %call, i32* %t, align 4
  %cmp13 = icmp slt i32 %call, 0
  br i1 %cmp13, label %if.then14, label %if.end15

if.then14:                                        ; preds = %for.body
  %23 = load i32, i32* %t, align 4
  store i32 %23, i32* %max, align 4
  br label %for.end

if.end15:                                         ; preds = %for.body
  %24 = load i32, i32* %max, align 4
  %25 = load i32, i32* %t, align 4
  %add = add nsw i32 %25, 1
  %cmp16 = icmp slt i32 %24, %add
  br i1 %cmp16, label %if.then17, label %if.end19

if.then17:                                        ; preds = %if.end15
  %26 = load i32, i32* %t, align 4
  %add18 = add nsw i32 %26, 1
  store i32 %add18, i32* %max, align 4
  br label %if.end19

if.end19:                                         ; preds = %if.then17, %if.end15
  br label %for.inc

for.inc:                                          ; preds = %if.end19
  %27 = load i32, i32* %i, align 4
  %inc = add nsw i32 %27, 1
  store i32 %inc, i32* %i, align 4
  br label %for.cond

for.end:                                          ; preds = %if.then14, %for.cond
  %28 = load i32, i32* %max, align 4
  %29 = load %struct.item_t*, %struct.item_t** %list.addr, align 4
  %30 = load i32, i32* %idx.addr, align 4
  %arrayidx20 = getelementptr inbounds %struct.item_t, %struct.item_t* %29, i32 %30
  %depth21 = getelementptr inbounds %struct.item_t, %struct.item_t* %arrayidx20, i32 0, i32 4
  store i32 %28, i32* %depth21, align 4
  store i32 %28, i32* %retval, align 4
  br label %return

return:                                           ; preds = %for.end, %if.then4, %if.then
  %31 = load i32, i32* %retval, align 4
  ret i32 %31
}

; Function Attrs: noinline nounwind optnone
define hidden i32 @main() #0 {
entry:
  %retval = alloca i32, align 4
  %i = alloca i32, align 4
  %j = alloca i32, align 4
  %n = alloca i32, align 4
  %bad = alloca i32, align 4
  %max = alloca i32, align 4
  %min = alloca i32, align 4
  %items = alloca %struct.item_t*, align 4
  store i32 0, i32* %retval, align 4
  store i32 -1, i32* %bad, align 4
  %call = call i32 @parse_input(%struct.item_t** %items)
  store i32 %call, i32* %n, align 4
  store i32 0, i32* %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %0 = load i32, i32* %i, align 4
  %1 = load i32, i32* %n, align 4
  %cmp = icmp slt i32 %0, %1
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %2 = load %struct.item_t*, %struct.item_t** %items, align 4
  %3 = load i32, i32* %i, align 4
  %arrayidx = getelementptr inbounds %struct.item_t, %struct.item_t* %2, i32 %3
  %depth = getelementptr inbounds %struct.item_t, %struct.item_t* %arrayidx, i32 0, i32 4
  %4 = load i32, i32* %depth, align 4
  %tobool = icmp ne i32 %4, 0
  br i1 %tobool, label %if.end, label %land.lhs.true

land.lhs.true:                                    ; preds = %for.body
  %5 = load %struct.item_t*, %struct.item_t** %items, align 4
  %6 = load i32, i32* %i, align 4
  %7 = load i32, i32* %bad, align 4
  %call1 = call i32 @get_depth(%struct.item_t* %5, i32 %6, i32 %7)
  %cmp2 = icmp slt i32 %call1, 0
  br i1 %cmp2, label %if.then, label %if.end

if.then:                                          ; preds = %land.lhs.true
  %8 = load i32, i32* %bad, align 4
  %dec = add nsw i32 %8, -1
  store i32 %dec, i32* %bad, align 4
  br label %if.end

if.end:                                           ; preds = %if.then, %land.lhs.true, %for.body
  br label %for.inc

for.inc:                                          ; preds = %if.end
  %9 = load i32, i32* %i, align 4
  %inc = add nsw i32 %9, 1
  store i32 %inc, i32* %i, align 4
  br label %for.cond

for.end:                                          ; preds = %for.cond
  store i32 0, i32* %i, align 4
  store i32 0, i32* %min, align 4
  store i32 0, i32* %max, align 4
  br label %for.cond3

for.cond3:                                        ; preds = %for.inc20, %for.end
  %10 = load i32, i32* %i, align 4
  %11 = load i32, i32* %n, align 4
  %cmp4 = icmp slt i32 %10, %11
  br i1 %cmp4, label %for.body5, label %for.end22

for.body5:                                        ; preds = %for.cond3
  %12 = load %struct.item_t*, %struct.item_t** %items, align 4
  %13 = load i32, i32* %i, align 4
  %arrayidx6 = getelementptr inbounds %struct.item_t, %struct.item_t* %12, i32 %13
  %depth7 = getelementptr inbounds %struct.item_t, %struct.item_t* %arrayidx6, i32 0, i32 4
  %14 = load i32, i32* %depth7, align 4
  %15 = load i32, i32* %max, align 4
  %cmp8 = icmp sgt i32 %14, %15
  br i1 %cmp8, label %if.then9, label %if.end12

if.then9:                                         ; preds = %for.body5
  %16 = load %struct.item_t*, %struct.item_t** %items, align 4
  %17 = load i32, i32* %i, align 4
  %arrayidx10 = getelementptr inbounds %struct.item_t, %struct.item_t* %16, i32 %17
  %depth11 = getelementptr inbounds %struct.item_t, %struct.item_t* %arrayidx10, i32 0, i32 4
  %18 = load i32, i32* %depth11, align 4
  store i32 %18, i32* %max, align 4
  br label %if.end12

if.end12:                                         ; preds = %if.then9, %for.body5
  %19 = load %struct.item_t*, %struct.item_t** %items, align 4
  %20 = load i32, i32* %i, align 4
  %arrayidx13 = getelementptr inbounds %struct.item_t, %struct.item_t* %19, i32 %20
  %depth14 = getelementptr inbounds %struct.item_t, %struct.item_t* %arrayidx13, i32 0, i32 4
  %21 = load i32, i32* %depth14, align 4
  %22 = load i32, i32* %min, align 4
  %cmp15 = icmp slt i32 %21, %22
  br i1 %cmp15, label %if.then16, label %if.end19

if.then16:                                        ; preds = %if.end12
  %23 = load %struct.item_t*, %struct.item_t** %items, align 4
  %24 = load i32, i32* %i, align 4
  %arrayidx17 = getelementptr inbounds %struct.item_t, %struct.item_t* %23, i32 %24
  %depth18 = getelementptr inbounds %struct.item_t, %struct.item_t* %arrayidx17, i32 0, i32 4
  %25 = load i32, i32* %depth18, align 4
  store i32 %25, i32* %min, align 4
  br label %if.end19

if.end19:                                         ; preds = %if.then16, %if.end12
  br label %for.inc20

for.inc20:                                        ; preds = %if.end19
  %26 = load i32, i32* %i, align 4
  %inc21 = add nsw i32 %26, 1
  store i32 %inc21, i32* %i, align 4
  br label %for.cond3

for.end22:                                        ; preds = %for.cond3
  %call23 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([16 x i8], [16 x i8]* @.str.2, i32 0, i32 0))
  %27 = load i32, i32* %min, align 4
  store i32 %27, i32* %i, align 4
  br label %for.cond24

for.cond24:                                       ; preds = %for.inc50, %for.end22
  %28 = load i32, i32* %i, align 4
  %29 = load i32, i32* %max, align 4
  %cmp25 = icmp sle i32 %28, %29
  br i1 %cmp25, label %for.body26, label %for.end52

for.body26:                                       ; preds = %for.cond24
  %30 = load i32, i32* %i, align 4
  %tobool27 = icmp ne i32 %30, 0
  br i1 %tobool27, label %if.end29, label %if.then28

if.then28:                                        ; preds = %for.body26
  br label %for.inc50

if.end29:                                         ; preds = %for.body26
  %31 = load i32, i32* %i, align 4
  %cmp30 = icmp slt i32 %31, 0
  br i1 %cmp30, label %if.then31, label %if.else

if.then31:                                        ; preds = %if.end29
  %call32 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([17 x i8], [17 x i8]* @.str.3, i32 0, i32 0))
  br label %if.end34

if.else:                                          ; preds = %if.end29
  %32 = load i32, i32* %i, align 4
  %call33 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([4 x i8], [4 x i8]* @.str.4, i32 0, i32 0), i32 %32)
  br label %if.end34

if.end34:                                         ; preds = %if.else, %if.then31
  store i32 0, i32* %j, align 4
  br label %for.cond35

for.cond35:                                       ; preds = %for.inc47, %if.end34
  %33 = load i32, i32* %j, align 4
  %34 = load i32, i32* %n, align 4
  %cmp36 = icmp slt i32 %33, %34
  br i1 %cmp36, label %lor.end, label %lor.rhs

lor.rhs:                                          ; preds = %for.cond35
  %call37 = call i32 @putchar(i32 10)
  %tobool38 = icmp ne i32 %call37, 0
  %lnot = xor i1 %tobool38, true
  br label %lor.end

lor.end:                                          ; preds = %lor.rhs, %for.cond35
  %35 = phi i1 [ true, %for.cond35 ], [ %lnot, %lor.rhs ]
  br i1 %35, label %for.body39, label %for.end49

for.body39:                                       ; preds = %lor.end
  %36 = load %struct.item_t*, %struct.item_t** %items, align 4
  %37 = load i32, i32* %j, align 4
  %arrayidx40 = getelementptr inbounds %struct.item_t, %struct.item_t* %36, i32 %37
  %depth41 = getelementptr inbounds %struct.item_t, %struct.item_t* %arrayidx40, i32 0, i32 4
  %38 = load i32, i32* %depth41, align 4
  %39 = load i32, i32* %i, align 4
  %cmp42 = icmp eq i32 %38, %39
  br i1 %cmp42, label %if.then43, label %if.end46

if.then43:                                        ; preds = %for.body39
  %40 = load %struct.item_t*, %struct.item_t** %items, align 4
  %41 = load i32, i32* %j, align 4
  %arrayidx44 = getelementptr inbounds %struct.item_t, %struct.item_t* %40, i32 %41
  %name = getelementptr inbounds %struct.item_t, %struct.item_t* %arrayidx44, i32 0, i32 0
  %42 = load i8*, i8** %name, align 4
  %call45 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([4 x i8], [4 x i8]* @.str.5, i32 0, i32 0), i8* %42)
  br label %if.end46

if.end46:                                         ; preds = %if.then43, %for.body39
  br label %for.inc47

for.inc47:                                        ; preds = %if.end46
  %43 = load i32, i32* %j, align 4
  %inc48 = add nsw i32 %43, 1
  store i32 %inc48, i32* %j, align 4
  br label %for.cond35

for.end49:                                        ; preds = %lor.end
  br label %for.inc50

for.inc50:                                        ; preds = %for.end49, %if.then28
  %44 = load i32, i32* %i, align 4
  %inc51 = add nsw i32 %44, 1
  store i32 %inc51, i32* %i, align 4
  br label %for.cond24

for.end52:                                        ; preds = %for.cond24
  ret i32 0
}

declare i32 @printf(i8* %0, ...) #2

declare i32 @putchar(i32 %0) #2

attributes #0 = { noinline nounwind optnone "correctly-rounded-divide-sqrt-fp-math"="false" "disable-tail-calls"="false" "frame-pointer"="none" "less-precise-fpmad"="false" "min-legal-vector-width"="0" "no-infs-fp-math"="false" "no-jump-tables"="false" "no-nans-fp-math"="false" "no-signed-zeros-fp-math"="false" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="generic" "unsafe-fp-math"="false" "use-soft-float"="false" }
attributes #1 = { nounwind readonly "correctly-rounded-divide-sqrt-fp-math"="false" "disable-tail-calls"="false" "frame-pointer"="none" "less-precise-fpmad"="false" "no-infs-fp-math"="false" "no-nans-fp-math"="false" "no-signed-zeros-fp-math"="false" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="generic" "unsafe-fp-math"="false" "use-soft-float"="false" }
attributes #2 = { "correctly-rounded-divide-sqrt-fp-math"="false" "disable-tail-calls"="false" "frame-pointer"="none" "less-precise-fpmad"="false" "no-infs-fp-math"="false" "no-nans-fp-math"="false" "no-signed-zeros-fp-math"="false" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="generic" "unsafe-fp-math"="false" "use-soft-float"="false" }
attributes #3 = { argmemonly nounwind willreturn writeonly }
attributes #4 = { nounwind readonly }

!llvm.module.flags = !{!0}
!llvm.ident = !{!1}

!0 = !{i32 1, !"wchar_size", i32 4}
!1 = !{!"clang version 11.0.0 (https://github.com/Jacarte/llvm-project.git 0f6dea67136cc1e0b3d200eb2bb165628970c44b)"}

; extracted candidates

; *****
; For LLVM instruction:
;  %2 = load i32, i32* %i, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %4 = load i32, i32* %3, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %cmp = icmp slt i32 %2, %4
; Looking for a replacement for:
%0:i32 = var
%1:i32 = var
%2:i1 = slt %0, %1
infer %2

; *****
; For LLVM instruction:
;  %6 = load i32, i32* %i, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %call = call i32 @strcmp(i8* %7, i8* %8) #4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %tobool = icmp ne i32 %call, 0
; Looking for a replacement for:
%0:i32 = var
%1:i1 = ne 0:i32, %0
infer %1

; *****
; For LLVM instruction:
;  %9 = load i32, i32* %i, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %10 = load i32, i32* %i, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %inc = add nsw i32 %10, 1
; Looking for a replacement for:
%0:i32 = var
%1:i32 = addnsw 1:i32, %0
infer %1

; *****
; For LLVM instruction:
;  %14 = load i32, i32* %13, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %inc2 = add nsw i32 %14, 1
; Looking for a replacement for:
%0:i32 = var
%1:i32 = addnsw 1:i32, %0
infer %1

; *****
; For LLVM instruction:
;  %mul = mul i32 %inc2, 20
; Looking for a replacement for:
%0:i32 = var
%1:i32 = addnsw 1:i32, %0 (hasExternalUses)
%2:i32 = mul 20:i32, %1
infer %2

; *****
; For LLVM instruction:
;  %18 = load i32, i32* %17, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %sub = sub nsw i32 %18, 1
; Looking for a replacement for:
%0:i32 = var
%1:i32 = subnsw %0, 1:i32
infer %1

; *****
; For LLVM instruction:
;  %20 = load i32, i32* %i, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %22 = load i32, i32* %i, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %24 = load i32, i32* %i, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %27 = load i32, i32* %i, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %28 = load i32, i32* %i, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %29 = load i32, i32* %retval, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0
got 1 candidates from LHS

-------------------------------------------------
%0:i32 = var
infer %0


--------------------------------
guess 0

%0:i32 = var ; reservedconst_1

Cost = 0
first query is SAT, returning the model:
reservedconst_1: 0
0 th attempt: second query is SAT-- constant doesn't work
first query is SAT, returning the model:
reservedconst_1: -1
1 th attempt: second query is SAT-- constant doesn't work
first query is UNSAT-- no more guesses
Dataflow Pruned 0/0
There are 1 Guesses
There are 0 RHSs before deduplication
There are 0 RHSs after deduplication
got 3 candidates from LHS

-------------------------------------------------
%0:i32 = var
%1:i32 = var
%2:i1 = slt %0, %1
infer %2


--------------------------------
guess 0

%0:i1 = var ; reservedconst_1

Cost = 0
first query is SAT, returning the model:
reservedconst_1: 0
0 th attempt: second query is SAT-- constant doesn't work
first query is SAT, returning the model:
reservedconst_1: -1
1 th attempt: second query is SAT-- constant doesn't work
first query is UNSAT-- no more guesses
Dataflow Pruned 0/0
There are 1 Guesses
There are 0 RHSs before deduplication
There are 0 RHSs after deduplication
got 2 candidates from LHS

-------------------------------------------------
%0:i32 = var
%1:i1 = ne 0:i32, %0
infer %1


--------------------------------
guess 0

%0:i1 = var ; reservedconst_1

Cost = 0
first query is SAT, returning the model:
reservedconst_1: 0
0 th attempt: second query is SAT-- constant doesn't work
first query is SAT, returning the model:
reservedconst_1: -1
1 th attempt: second query is SAT-- constant doesn't work
first query is UNSAT-- no more guesses
Dataflow Pruned 0/0
There are 1 Guesses
There are 0 RHSs before deduplication
There are 0 RHSs after deduplication
got 2 candidates from LHS

-------------------------------------------------
%0:i32 = var
%1:i32 = addnsw 1:i32, %0
infer %1


--------------------------------
guess 0

%0:i32 = var ; reservedconst_1

Cost = 0
first query is SAT, returning the model:
reservedconst_1: 1
0 th attempt: second query is SAT-- constant doesn't work
first query is SAT, returning the model:
reservedconst_1: 268435457
1 th attempt: second query is SAT-- constant doesn't work
first query is UNSAT-- no more guesses

--------------------------------
guess 1

%0:i32 = var

Cost = 0
second query is SAT-- constant doesn't work
Dataflow Pruned 0/0
There are 2 Guesses
There are 0 RHSs before deduplication
There are 0 RHSs after deduplication
got 3 candidates from LHS

-------------------------------------------------
%0:i32 = var
%1:i32 = addnsw 1:i32, %0 (hasExternalUses)
%2:i32 = mul 20:i32, %1
infer %2


--------------------------------
guess 0

%0:i32 = var ; reservedconst_1

Cost = 0
first query is SAT, returning the model:
reservedconst_1: 20
0 th attempt: second query is SAT-- constant doesn't work
first query is SAT, returning the model:
reservedconst_1: -2147483616
1 th attempt: second query is SAT-- constant doesn't work
first query is UNSAT-- no more guesses

--------------------------------
guess 1

%0:i32 = var

Cost = 0
second query is SAT-- constant doesn't work
Dataflow Pruned 0/0
There are 2 Guesses
There are 0 RHSs before deduplication
There are 0 RHSs after deduplication
got 2 candidates from LHS

-------------------------------------------------
%0:i32 = var
%1:i32 = subnsw %0, 1:i32
infer %1


--------------------------------
guess 0

%0:i32 = var ; reservedconst_1

Cost = 0
first query is SAT, returning the model:
reservedconst_1: -1
0 th attempt: second query is SAT-- constant doesn't work
first query is SAT, returning the model:
reservedconst_1: 536870911
1 th attempt: second query is SAT-- constant doesn't work
first query is UNSAT-- no more guesses

--------------------------------
guess 1

%0:i32 = var

Cost = 0
second query is SAT-- constant doesn't work
Dataflow Pruned 0/0
There are 2 Guesses
There are 0 RHSs before deduplication
There are 0 RHSs after deduplication
#########################################################
; exiting Souper's runOnFunction() for get_item()

; entering Souper's runOnFunction() for add_dep()

; ModuleID = './Topological_sort.c.bc'
source_filename = "./Topological_sort.c"
target datalayout = "e-m:e-p:32:32-i64:64-n32:64-S128"
target triple = "wasm32-unknown-wasi"

%struct.item_t = type { i8*, i32*, i32, i32, i32 }

@input = hidden global [583 x i8] c"des_system_lib   std synopsys std_cell_lib des_system_lib dw02 dw01 ramlib ieee\0Adw01             ieee dw01 dware gtech\0Adw02             ieee dw02 dware\0Adw03             std synopsys dware dw03 dw02 dw01 ieee gtech\0Adw04             dw04 ieee dw01 dware gtech\0Adw05             dw05 ieee dware\0Adw06             dw06 ieee dware\0Adw07             ieee dware\0Adware            ieee dware\0Agtech            ieee gtech\0Aramlib           std ieee\0Astd_cell_lib     ieee std_cell_lib\0Asynopsys\0Acycle_11\09  cycle_12\0Acycle_12\09  cycle_11\0Acycle_21\09  dw01 cycle_22 dw02 dw03\0Acycle_22\09  cycle_21 dw01 dw04\00", align 16
@.str = private unnamed_addr constant [2 x i8] c"\0A\00", align 1
@.str.1 = private unnamed_addr constant [3 x i8] c" \09\00", align 1
@.str.2 = private unnamed_addr constant [16 x i8] c"Compile order:\0A\00", align 1
@.str.3 = private unnamed_addr constant [17 x i8] c"   [unorderable]\00", align 1
@.str.4 = private unnamed_addr constant [4 x i8] c"%d:\00", align 1
@.str.5 = private unnamed_addr constant [4 x i8] c" %s\00", align 1
@llvm.used = appending global [1 x i8*] [i8* bitcast (i32 ()* @__main_void to i8*)], section "llvm.metadata"

@__main_void = alias i32 (), i32 ()* @main

; Function Attrs: noinline nounwind optnone
define hidden i32 @get_item(%struct.item_t** %list, i32* %len, i8* %name) #0 {
entry:
  %retval = alloca i32, align 4
  %list.addr = alloca %struct.item_t**, align 4
  %len.addr = alloca i32*, align 4
  %name.addr = alloca i8*, align 4
  %i = alloca i32, align 4
  %lst = alloca %struct.item_t*, align 4
  store %struct.item_t** %list, %struct.item_t*** %list.addr, align 4
  store i32* %len, i32** %len.addr, align 4
  store i8* %name, i8** %name.addr, align 4
  %0 = load %struct.item_t**, %struct.item_t*** %list.addr, align 4
  %1 = load %struct.item_t*, %struct.item_t** %0, align 4
  store %struct.item_t* %1, %struct.item_t** %lst, align 4
  store i32 0, i32* %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %2 = load i32, i32* %i, align 4
  %3 = load i32*, i32** %len.addr, align 4
  %4 = load i32, i32* %3, align 4
  %cmp = icmp slt i32 %2, %4
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %5 = load %struct.item_t*, %struct.item_t** %lst, align 4
  %6 = load i32, i32* %i, align 4
  %arrayidx = getelementptr inbounds %struct.item_t, %struct.item_t* %5, i32 %6
  %name1 = getelementptr inbounds %struct.item_t, %struct.item_t* %arrayidx, i32 0, i32 0
  %7 = load i8*, i8** %name1, align 4
  %8 = load i8*, i8** %name.addr, align 4
  %call = call i32 @strcmp(i8* %7, i8* %8) #4
  %tobool = icmp ne i32 %call, 0
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %for.body
  %9 = load i32, i32* %i, align 4
  store i32 %9, i32* %retval, align 4
  br label %return

if.end:                                           ; preds = %for.body
  br label %for.inc

for.inc:                                          ; preds = %if.end
  %10 = load i32, i32* %i, align 4
  %inc = add nsw i32 %10, 1
  store i32 %inc, i32* %i, align 4
  br label %for.cond

for.end:                                          ; preds = %for.cond
  %11 = load %struct.item_t*, %struct.item_t** %lst, align 4
  %12 = bitcast %struct.item_t* %11 to i8*
  %13 = load i32*, i32** %len.addr, align 4
  %14 = load i32, i32* %13, align 4
  %inc2 = add nsw i32 %14, 1
  store i32 %inc2, i32* %13, align 4
  %mul = mul i32 %inc2, 20
  %call3 = call i8* @realloc(i8* %12, i32 %mul)
  %15 = bitcast i8* %call3 to %struct.item_t*
  %16 = load %struct.item_t**, %struct.item_t*** %list.addr, align 4
  store %struct.item_t* %15, %struct.item_t** %16, align 4
  store %struct.item_t* %15, %struct.item_t** %lst, align 4
  %17 = load i32*, i32** %len.addr, align 4
  %18 = load i32, i32* %17, align 4
  %sub = sub nsw i32 %18, 1
  store i32 %sub, i32* %i, align 4
  %19 = load %struct.item_t*, %struct.item_t** %lst, align 4
  %20 = load i32, i32* %i, align 4
  %add.ptr = getelementptr inbounds %struct.item_t, %struct.item_t* %19, i32 %20
  %21 = bitcast %struct.item_t* %add.ptr to i8*
  call void @llvm.memset.p0i8.i32(i8* align 4 %21, i8 0, i32 20, i1 false)
  %22 = load i32, i32* %i, align 4
  %23 = load %struct.item_t*, %struct.item_t** %lst, align 4
  %24 = load i32, i32* %i, align 4
  %arrayidx4 = getelementptr inbounds %struct.item_t, %struct.item_t* %23, i32 %24
  %idx = getelementptr inbounds %struct.item_t, %struct.item_t* %arrayidx4, i32 0, i32 3
  store i32 %22, i32* %idx, align 4
  %25 = load i8*, i8** %name.addr, align 4
  %26 = load %struct.item_t*, %struct.item_t** %lst, align 4
  %27 = load i32, i32* %i, align 4
  %arrayidx5 = getelementptr inbounds %struct.item_t, %struct.item_t* %26, i32 %27
  %name6 = getelementptr inbounds %struct.item_t, %struct.item_t* %arrayidx5, i32 0, i32 0
  store i8* %25, i8** %name6, align 4
  %28 = load i32, i32* %i, align 4
  store i32 %28, i32* %retval, align 4
  br label %return

return:                                           ; preds = %for.end, %if.then
  %29 = load i32, i32* %retval, align 4
  ret i32 %29
}

; Function Attrs: nounwind readonly
declare i32 @strcmp(i8* %0, i8* %1) #1

declare i8* @realloc(i8* %0, i32 %1) #2

; Function Attrs: argmemonly nounwind willreturn writeonly
declare void @llvm.memset.p0i8.i32(i8* nocapture writeonly %0, i8 %1, i32 %2, i1 immarg %3) #3

; Function Attrs: noinline nounwind optnone
define hidden void @add_dep(%struct.item_t* %it, i32 %i) #0 {
entry:
  %it.addr = alloca %struct.item_t*, align 4
  %i.addr = alloca i32, align 4
  store %struct.item_t* %it, %struct.item_t** %it.addr, align 4
  store i32 %i, i32* %i.addr, align 4
  %0 = load %struct.item_t*, %struct.item_t** %it.addr, align 4
  %idx = getelementptr inbounds %struct.item_t, %struct.item_t* %0, i32 0, i32 3
  %1 = load i32, i32* %idx, align 4
  %2 = load i32, i32* %i.addr, align 4
  %cmp = icmp eq i32 %1, %2
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  br label %return

if.end:                                           ; preds = %entry
  %3 = load %struct.item_t*, %struct.item_t** %it.addr, align 4
  %deps = getelementptr inbounds %struct.item_t, %struct.item_t* %3, i32 0, i32 1
  %4 = load i32*, i32** %deps, align 4
  %5 = bitcast i32* %4 to i8*
  %6 = load %struct.item_t*, %struct.item_t** %it.addr, align 4
  %n_deps = getelementptr inbounds %struct.item_t, %struct.item_t* %6, i32 0, i32 2
  %7 = load i32, i32* %n_deps, align 4
  %add = add nsw i32 %7, 1
  %mul = mul i32 %add, 4
  %call = call i8* @realloc(i8* %5, i32 %mul)
  %8 = bitcast i8* %call to i32*
  %9 = load %struct.item_t*, %struct.item_t** %it.addr, align 4
  %deps1 = getelementptr inbounds %struct.item_t, %struct.item_t* %9, i32 0, i32 1
  store i32* %8, i32** %deps1, align 4
  %10 = load i32, i32* %i.addr, align 4
  %11 = load %struct.item_t*, %struct.item_t** %it.addr, align 4
  %deps2 = getelementptr inbounds %struct.item_t, %struct.item_t* %11, i32 0, i32 1
  %12 = load i32*, i32** %deps2, align 4
  %13 = load %struct.item_t*, %struct.item_t** %it.addr, align 4
  %n_deps3 = getelementptr inbounds %struct.item_t, %struct.item_t* %13, i32 0, i32 2
  %14 = load i32, i32* %n_deps3, align 4
  %inc = add nsw i32 %14, 1
  store i32 %inc, i32* %n_deps3, align 4
  %arrayidx = getelementptr inbounds i32, i32* %12, i32 %14
  store i32 %10, i32* %arrayidx, align 4
  br label %return

return:                                           ; preds = %if.end, %if.then
  ret void
}

; Function Attrs: noinline nounwind optnone
define hidden i32 @parse_input(%struct.item_t** %ret) #0 {
entry:
  %ret.addr = alloca %struct.item_t**, align 4
  %n_items = alloca i32, align 4
  %i = alloca i32, align 4
  %parent = alloca i32, align 4
  %idx = alloca i32, align 4
  %list = alloca %struct.item_t*, align 4
  %s = alloca i8*, align 4
  %e = alloca i8*, align 4
  %word = alloca i8*, align 4
  %we = alloca i8*, align 4
  store %struct.item_t** %ret, %struct.item_t*** %ret.addr, align 4
  store i32 0, i32* %n_items, align 4
  store %struct.item_t* null, %struct.item_t** %list, align 4
  store i8* getelementptr inbounds ([583 x i8], [583 x i8]* @input, i32 0, i32 0), i8** %s, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc10, %entry
  %0 = load i8*, i8** %s, align 4
  %call = call i8* @strtok_r(i8* %0, i8* getelementptr inbounds ([2 x i8], [2 x i8]* @.str, i32 0, i32 0), i8** %e)
  store i8* %call, i8** %s, align 4
  %tobool = icmp ne i8* %call, null
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %for.cond
  br label %for.end11

if.end:                                           ; preds = %for.cond
  store i32 0, i32* %i, align 4
  %1 = load i8*, i8** %s, align 4
  store i8* %1, i8** %word, align 4
  br label %for.cond1

for.cond1:                                        ; preds = %for.inc, %if.end
  %2 = load i8*, i8** %word, align 4
  %call2 = call i8* @strtok_r(i8* %2, i8* getelementptr inbounds ([3 x i8], [3 x i8]* @.str.1, i32 0, i32 0), i8** %we)
  store i8* %call2, i8** %word, align 4
  %tobool3 = icmp ne i8* %call2, null
  br i1 %tobool3, label %if.end5, label %if.then4

if.then4:                                         ; preds = %for.cond1
  br label %for.end

if.end5:                                          ; preds = %for.cond1
  %3 = load i8*, i8** %word, align 4
  %call6 = call i32 @get_item(%struct.item_t** %list, i32* %n_items, i8* %3)
  store i32 %call6, i32* %idx, align 4
  %4 = load i32, i32* %i, align 4
  %tobool7 = icmp ne i32 %4, 0
  br i1 %tobool7, label %if.else, label %if.then8

if.then8:                                         ; preds = %if.end5
  %5 = load i32, i32* %idx, align 4
  store i32 %5, i32* %parent, align 4
  br label %if.end9

if.else:                                          ; preds = %if.end5
  %6 = load %struct.item_t*, %struct.item_t** %list, align 4
  %7 = load i32, i32* %parent, align 4
  %add.ptr = getelementptr inbounds %struct.item_t, %struct.item_t* %6, i32 %7
  %8 = load i32, i32* %idx, align 4
  call void @add_dep(%struct.item_t* %add.ptr, i32 %8)
  br label %if.end9

if.end9:                                          ; preds = %if.else, %if.then8
  br label %for.inc

for.inc:                                          ; preds = %if.end9
  %9 = load i32, i32* %i, align 4
  %inc = add nsw i32 %9, 1
  store i32 %inc, i32* %i, align 4
  store i8* null, i8** %word, align 4
  br label %for.cond1

for.end:                                          ; preds = %if.then4
  br label %for.inc10

for.inc10:                                        ; preds = %for.end
  store i8* null, i8** %s, align 4
  br label %for.cond

for.end11:                                        ; preds = %if.then
  %10 = load %struct.item_t*, %struct.item_t** %list, align 4
  %11 = load %struct.item_t**, %struct.item_t*** %ret.addr, align 4
  store %struct.item_t* %10, %struct.item_t** %11, align 4
  %12 = load i32, i32* %n_items, align 4
  ret i32 %12
}

declare i8* @strtok_r(i8* %0, i8* %1, i8** %2) #2

; Function Attrs: noinline nounwind optnone
define hidden i32 @get_depth(%struct.item_t* %list, i32 %idx, i32 %bad) #0 {
entry:
  %retval = alloca i32, align 4
  %list.addr = alloca %struct.item_t*, align 4
  %idx.addr = alloca i32, align 4
  %bad.addr = alloca i32, align 4
  %max = alloca i32, align 4
  %i = alloca i32, align 4
  %t = alloca i32, align 4
  store %struct.item_t* %list, %struct.item_t** %list.addr, align 4
  store i32 %idx, i32* %idx.addr, align 4
  store i32 %bad, i32* %bad.addr, align 4
  %0 = load %struct.item_t*, %struct.item_t** %list.addr, align 4
  %1 = load i32, i32* %idx.addr, align 4
  %arrayidx = getelementptr inbounds %struct.item_t, %struct.item_t* %0, i32 %1
  %deps = getelementptr inbounds %struct.item_t, %struct.item_t* %arrayidx, i32 0, i32 1
  %2 = load i32*, i32** %deps, align 4
  %tobool = icmp ne i32* %2, null
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  %3 = load %struct.item_t*, %struct.item_t** %list.addr, align 4
  %4 = load i32, i32* %idx.addr, align 4
  %arrayidx1 = getelementptr inbounds %struct.item_t, %struct.item_t* %3, i32 %4
  %depth = getelementptr inbounds %struct.item_t, %struct.item_t* %arrayidx1, i32 0, i32 4
  store i32 1, i32* %depth, align 4
  store i32 1, i32* %retval, align 4
  br label %return

if.end:                                           ; preds = %entry
  %5 = load %struct.item_t*, %struct.item_t** %list.addr, align 4
  %6 = load i32, i32* %idx.addr, align 4
  %arrayidx2 = getelementptr inbounds %struct.item_t, %struct.item_t* %5, i32 %6
  %depth3 = getelementptr inbounds %struct.item_t, %struct.item_t* %arrayidx2, i32 0, i32 4
  %7 = load i32, i32* %depth3, align 4
  store i32 %7, i32* %t, align 4
  %cmp = icmp slt i32 %7, 0
  br i1 %cmp, label %if.then4, label %if.end5

if.then4:                                         ; preds = %if.end
  %8 = load i32, i32* %t, align 4
  store i32 %8, i32* %retval, align 4
  br label %return

if.end5:                                          ; preds = %if.end
  %9 = load i32, i32* %bad.addr, align 4
  %10 = load %struct.item_t*, %struct.item_t** %list.addr, align 4
  %11 = load i32, i32* %idx.addr, align 4
  %arrayidx6 = getelementptr inbounds %struct.item_t, %struct.item_t* %10, i32 %11
  %depth7 = getelementptr inbounds %struct.item_t, %struct.item_t* %arrayidx6, i32 0, i32 4
  store i32 %9, i32* %depth7, align 4
  store i32 0, i32* %i, align 4
  store i32 0, i32* %max, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.end5
  %12 = load i32, i32* %i, align 4
  %13 = load %struct.item_t*, %struct.item_t** %list.addr, align 4
  %14 = load i32, i32* %idx.addr, align 4
  %arrayidx8 = getelementptr inbounds %struct.item_t, %struct.item_t* %13, i32 %14
  %n_deps = getelementptr inbounds %struct.item_t, %struct.item_t* %arrayidx8, i32 0, i32 2
  %15 = load i32, i32* %n_deps, align 4
  %cmp9 = icmp slt i32 %12, %15
  br i1 %cmp9, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %16 = load %struct.item_t*, %struct.item_t** %list.addr, align 4
  %17 = load %struct.item_t*, %struct.item_t** %list.addr, align 4
  %18 = load i32, i32* %idx.addr, align 4
  %arrayidx10 = getelementptr inbounds %struct.item_t, %struct.item_t* %17, i32 %18
  %deps11 = getelementptr inbounds %struct.item_t, %struct.item_t* %arrayidx10, i32 0, i32 1
  %19 = load i32*, i32** %deps11, align 4
  %20 = load i32, i32* %i, align 4
  %arrayidx12 = getelementptr inbounds i32, i32* %19, i32 %20
  %21 = load i32, i32* %arrayidx12, align 4
  %22 = load i32, i32* %bad.addr, align 4
  %call = call i32 @get_depth(%struct.item_t* %16, i32 %21, i32 %22)
  store i32 %call, i32* %t, align 4
  %cmp13 = icmp slt i32 %call, 0
  br i1 %cmp13, label %if.then14, label %if.end15

if.then14:                                        ; preds = %for.body
  %23 = load i32, i32* %t, align 4
  store i32 %23, i32* %max, align 4
  br label %for.end

if.end15:                                         ; preds = %for.body
  %24 = load i32, i32* %max, align 4
  %25 = load i32, i32* %t, align 4
  %add = add nsw i32 %25, 1
  %cmp16 = icmp slt i32 %24, %add
  br i1 %cmp16, label %if.then17, label %if.end19

if.then17:                                        ; preds = %if.end15
  %26 = load i32, i32* %t, align 4
  %add18 = add nsw i32 %26, 1
  store i32 %add18, i32* %max, align 4
  br label %if.end19

if.end19:                                         ; preds = %if.then17, %if.end15
  br label %for.inc

for.inc:                                          ; preds = %if.end19
  %27 = load i32, i32* %i, align 4
  %inc = add nsw i32 %27, 1
  store i32 %inc, i32* %i, align 4
  br label %for.cond

for.end:                                          ; preds = %if.then14, %for.cond
  %28 = load i32, i32* %max, align 4
  %29 = load %struct.item_t*, %struct.item_t** %list.addr, align 4
  %30 = load i32, i32* %idx.addr, align 4
  %arrayidx20 = getelementptr inbounds %struct.item_t, %struct.item_t* %29, i32 %30
  %depth21 = getelementptr inbounds %struct.item_t, %struct.item_t* %arrayidx20, i32 0, i32 4
  store i32 %28, i32* %depth21, align 4
  store i32 %28, i32* %retval, align 4
  br label %return

return:                                           ; preds = %for.end, %if.then4, %if.then
  %31 = load i32, i32* %retval, align 4
  ret i32 %31
}

; Function Attrs: noinline nounwind optnone
define hidden i32 @main() #0 {
entry:
  %retval = alloca i32, align 4
  %i = alloca i32, align 4
  %j = alloca i32, align 4
  %n = alloca i32, align 4
  %bad = alloca i32, align 4
  %max = alloca i32, align 4
  %min = alloca i32, align 4
  %items = alloca %struct.item_t*, align 4
  store i32 0, i32* %retval, align 4
  store i32 -1, i32* %bad, align 4
  %call = call i32 @parse_input(%struct.item_t** %items)
  store i32 %call, i32* %n, align 4
  store i32 0, i32* %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %0 = load i32, i32* %i, align 4
  %1 = load i32, i32* %n, align 4
  %cmp = icmp slt i32 %0, %1
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %2 = load %struct.item_t*, %struct.item_t** %items, align 4
  %3 = load i32, i32* %i, align 4
  %arrayidx = getelementptr inbounds %struct.item_t, %struct.item_t* %2, i32 %3
  %depth = getelementptr inbounds %struct.item_t, %struct.item_t* %arrayidx, i32 0, i32 4
  %4 = load i32, i32* %depth, align 4
  %tobool = icmp ne i32 %4, 0
  br i1 %tobool, label %if.end, label %land.lhs.true

land.lhs.true:                                    ; preds = %for.body
  %5 = load %struct.item_t*, %struct.item_t** %items, align 4
  %6 = load i32, i32* %i, align 4
  %7 = load i32, i32* %bad, align 4
  %call1 = call i32 @get_depth(%struct.item_t* %5, i32 %6, i32 %7)
  %cmp2 = icmp slt i32 %call1, 0
  br i1 %cmp2, label %if.then, label %if.end

if.then:                                          ; preds = %land.lhs.true
  %8 = load i32, i32* %bad, align 4
  %dec = add nsw i32 %8, -1
  store i32 %dec, i32* %bad, align 4
  br label %if.end

if.end:                                           ; preds = %if.then, %land.lhs.true, %for.body
  br label %for.inc

for.inc:                                          ; preds = %if.end
  %9 = load i32, i32* %i, align 4
  %inc = add nsw i32 %9, 1
  store i32 %inc, i32* %i, align 4
  br label %for.cond

for.end:                                          ; preds = %for.cond
  store i32 0, i32* %i, align 4
  store i32 0, i32* %min, align 4
  store i32 0, i32* %max, align 4
  br label %for.cond3

for.cond3:                                        ; preds = %for.inc20, %for.end
  %10 = load i32, i32* %i, align 4
  %11 = load i32, i32* %n, align 4
  %cmp4 = icmp slt i32 %10, %11
  br i1 %cmp4, label %for.body5, label %for.end22

for.body5:                                        ; preds = %for.cond3
  %12 = load %struct.item_t*, %struct.item_t** %items, align 4
  %13 = load i32, i32* %i, align 4
  %arrayidx6 = getelementptr inbounds %struct.item_t, %struct.item_t* %12, i32 %13
  %depth7 = getelementptr inbounds %struct.item_t, %struct.item_t* %arrayidx6, i32 0, i32 4
  %14 = load i32, i32* %depth7, align 4
  %15 = load i32, i32* %max, align 4
  %cmp8 = icmp sgt i32 %14, %15
  br i1 %cmp8, label %if.then9, label %if.end12

if.then9:                                         ; preds = %for.body5
  %16 = load %struct.item_t*, %struct.item_t** %items, align 4
  %17 = load i32, i32* %i, align 4
  %arrayidx10 = getelementptr inbounds %struct.item_t, %struct.item_t* %16, i32 %17
  %depth11 = getelementptr inbounds %struct.item_t, %struct.item_t* %arrayidx10, i32 0, i32 4
  %18 = load i32, i32* %depth11, align 4
  store i32 %18, i32* %max, align 4
  br label %if.end12

if.end12:                                         ; preds = %if.then9, %for.body5
  %19 = load %struct.item_t*, %struct.item_t** %items, align 4
  %20 = load i32, i32* %i, align 4
  %arrayidx13 = getelementptr inbounds %struct.item_t, %struct.item_t* %19, i32 %20
  %depth14 = getelementptr inbounds %struct.item_t, %struct.item_t* %arrayidx13, i32 0, i32 4
  %21 = load i32, i32* %depth14, align 4
  %22 = load i32, i32* %min, align 4
  %cmp15 = icmp slt i32 %21, %22
  br i1 %cmp15, label %if.then16, label %if.end19

if.then16:                                        ; preds = %if.end12
  %23 = load %struct.item_t*, %struct.item_t** %items, align 4
  %24 = load i32, i32* %i, align 4
  %arrayidx17 = getelementptr inbounds %struct.item_t, %struct.item_t* %23, i32 %24
  %depth18 = getelementptr inbounds %struct.item_t, %struct.item_t* %arrayidx17, i32 0, i32 4
  %25 = load i32, i32* %depth18, align 4
  store i32 %25, i32* %min, align 4
  br label %if.end19

if.end19:                                         ; preds = %if.then16, %if.end12
  br label %for.inc20

for.inc20:                                        ; preds = %if.end19
  %26 = load i32, i32* %i, align 4
  %inc21 = add nsw i32 %26, 1
  store i32 %inc21, i32* %i, align 4
  br label %for.cond3

for.end22:                                        ; preds = %for.cond3
  %call23 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([16 x i8], [16 x i8]* @.str.2, i32 0, i32 0))
  %27 = load i32, i32* %min, align 4
  store i32 %27, i32* %i, align 4
  br label %for.cond24

for.cond24:                                       ; preds = %for.inc50, %for.end22
  %28 = load i32, i32* %i, align 4
  %29 = load i32, i32* %max, align 4
  %cmp25 = icmp sle i32 %28, %29
  br i1 %cmp25, label %for.body26, label %for.end52

for.body26:                                       ; preds = %for.cond24
  %30 = load i32, i32* %i, align 4
  %tobool27 = icmp ne i32 %30, 0
  br i1 %tobool27, label %if.end29, label %if.then28

if.then28:                                        ; preds = %for.body26
  br label %for.inc50

if.end29:                                         ; preds = %for.body26
  %31 = load i32, i32* %i, align 4
  %cmp30 = icmp slt i32 %31, 0
  br i1 %cmp30, label %if.then31, label %if.else

if.then31:                                        ; preds = %if.end29
  %call32 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([17 x i8], [17 x i8]* @.str.3, i32 0, i32 0))
  br label %if.end34

if.else:                                          ; preds = %if.end29
  %32 = load i32, i32* %i, align 4
  %call33 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([4 x i8], [4 x i8]* @.str.4, i32 0, i32 0), i32 %32)
  br label %if.end34

if.end34:                                         ; preds = %if.else, %if.then31
  store i32 0, i32* %j, align 4
  br label %for.cond35

for.cond35:                                       ; preds = %for.inc47, %if.end34
  %33 = load i32, i32* %j, align 4
  %34 = load i32, i32* %n, align 4
  %cmp36 = icmp slt i32 %33, %34
  br i1 %cmp36, label %lor.end, label %lor.rhs

lor.rhs:                                          ; preds = %for.cond35
  %call37 = call i32 @putchar(i32 10)
  %tobool38 = icmp ne i32 %call37, 0
  %lnot = xor i1 %tobool38, true
  br label %lor.end

lor.end:                                          ; preds = %lor.rhs, %for.cond35
  %35 = phi i1 [ true, %for.cond35 ], [ %lnot, %lor.rhs ]
  br i1 %35, label %for.body39, label %for.end49

for.body39:                                       ; preds = %lor.end
  %36 = load %struct.item_t*, %struct.item_t** %items, align 4
  %37 = load i32, i32* %j, align 4
  %arrayidx40 = getelementptr inbounds %struct.item_t, %struct.item_t* %36, i32 %37
  %depth41 = getelementptr inbounds %struct.item_t, %struct.item_t* %arrayidx40, i32 0, i32 4
  %38 = load i32, i32* %depth41, align 4
  %39 = load i32, i32* %i, align 4
  %cmp42 = icmp eq i32 %38, %39
  br i1 %cmp42, label %if.then43, label %if.end46

if.then43:                                        ; preds = %for.body39
  %40 = load %struct.item_t*, %struct.item_t** %items, align 4
  %41 = load i32, i32* %j, align 4
  %arrayidx44 = getelementptr inbounds %struct.item_t, %struct.item_t* %40, i32 %41
  %name = getelementptr inbounds %struct.item_t, %struct.item_t* %arrayidx44, i32 0, i32 0
  %42 = load i8*, i8** %name, align 4
  %call45 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([4 x i8], [4 x i8]* @.str.5, i32 0, i32 0), i8* %42)
  br label %if.end46

if.end46:                                         ; preds = %if.then43, %for.body39
  br label %for.inc47

for.inc47:                                        ; preds = %if.end46
  %43 = load i32, i32* %j, align 4
  %inc48 = add nsw i32 %43, 1
  store i32 %inc48, i32* %j, align 4
  br label %for.cond35

for.end49:                                        ; preds = %lor.end
  br label %for.inc50

for.inc50:                                        ; preds = %for.end49, %if.then28
  %44 = load i32, i32* %i, align 4
  %inc51 = add nsw i32 %44, 1
  store i32 %inc51, i32* %i, align 4
  br label %for.cond24

for.end52:                                        ; preds = %for.cond24
  ret i32 0
}

declare i32 @printf(i8* %0, ...) #2

declare i32 @putchar(i32 %0) #2

attributes #0 = { noinline nounwind optnone "correctly-rounded-divide-sqrt-fp-math"="false" "disable-tail-calls"="false" "frame-pointer"="none" "less-precise-fpmad"="false" "min-legal-vector-width"="0" "no-infs-fp-math"="false" "no-jump-tables"="false" "no-nans-fp-math"="false" "no-signed-zeros-fp-math"="false" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="generic" "unsafe-fp-math"="false" "use-soft-float"="false" }
attributes #1 = { nounwind readonly "correctly-rounded-divide-sqrt-fp-math"="false" "disable-tail-calls"="false" "frame-pointer"="none" "less-precise-fpmad"="false" "no-infs-fp-math"="false" "no-nans-fp-math"="false" "no-signed-zeros-fp-math"="false" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="generic" "unsafe-fp-math"="false" "use-soft-float"="false" }
attributes #2 = { "correctly-rounded-divide-sqrt-fp-math"="false" "disable-tail-calls"="false" "frame-pointer"="none" "less-precise-fpmad"="false" "no-infs-fp-math"="false" "no-nans-fp-math"="false" "no-signed-zeros-fp-math"="false" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="generic" "unsafe-fp-math"="false" "use-soft-float"="false" }
attributes #3 = { argmemonly nounwind willreturn writeonly }
attributes #4 = { nounwind readonly }

!llvm.module.flags = !{!0}
!llvm.ident = !{!1}

!0 = !{i32 1, !"wchar_size", i32 4}
!1 = !{!"clang version 11.0.0 (https://github.com/Jacarte/llvm-project.git 0f6dea67136cc1e0b3d200eb2bb165628970c44b)"}

; extracted candidates

; *****
; For LLVM instruction:
;  %1 = load i32, i32* %idx, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %2 = load i32, i32* %i.addr, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %cmp = icmp eq i32 %1, %2
; Looking for a replacement for:
%0:i32 = var
%1:i32 = var
%2:i1 = eq %0, %1
infer %2

; *****
; For LLVM instruction:
;  %7 = load i32, i32* %n_deps, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %add = add nsw i32 %7, 1
; Looking for a replacement for:
%0:i32 = var
%1:i32 = addnsw 1:i32, %0
infer %1

; *****
; For LLVM instruction:
;  %mul = mul i32 %add, 4
; Looking for a replacement for:
%0:i32 = var
%1:i32 = addnsw 1:i32, %0
%2:i32 = mul 4:i32, %1
infer %2

; *****
; For LLVM instruction:
;  %10 = load i32, i32* %i.addr, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %14 = load i32, i32* %n_deps3, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %inc = add nsw i32 %14, 1
; Looking for a replacement for:
%0:i32 = var
%1:i32 = addnsw 1:i32, %0
infer %1
got 3 candidates from LHS

-------------------------------------------------
%0:i32 = var
%1:i32 = var
%2:i1 = eq %0, %1
infer %2


--------------------------------
guess 0

%0:i1 = var ; reservedconst_1

Cost = 0
first query is SAT, returning the model:
reservedconst_1: -1
0 th attempt: second query is SAT-- constant doesn't work
first query is SAT, returning the model:
reservedconst_1: 0
1 th attempt: second query is SAT-- constant doesn't work
first query is UNSAT-- no more guesses
Dataflow Pruned 0/0
There are 1 Guesses
There are 0 RHSs before deduplication
There are 0 RHSs after deduplication
got 3 candidates from LHS

-------------------------------------------------
%0:i32 = var
%1:i32 = addnsw 1:i32, %0
%2:i32 = mul 4:i32, %1
infer %2


--------------------------------
guess 0

%0:i32 = var ; reservedconst_1

Cost = 0
first query is SAT, returning the model:
reservedconst_1: 4
0 th attempt: second query is SAT-- constant doesn't work
first query is SAT, returning the model:
reservedconst_1: 1073741828
1 th attempt: second query is SAT-- constant doesn't work
first query is UNSAT-- no more guesses

--------------------------------
guess 1

%0:i32 = var

Cost = 0
second query is SAT-- constant doesn't work

--------------------------------
guess 2

%0:i32 = var
%1:i32 = addnsw 1:i32, %0

Cost = 1
second query is SAT-- constant doesn't work
Dataflow Pruned 0/0
There are 3 Guesses
There are 0 RHSs before deduplication
There are 0 RHSs after deduplication
#########################################################
; exiting Souper's runOnFunction() for add_dep()

; entering Souper's runOnFunction() for parse_input()

; ModuleID = './Topological_sort.c.bc'
source_filename = "./Topological_sort.c"
target datalayout = "e-m:e-p:32:32-i64:64-n32:64-S128"
target triple = "wasm32-unknown-wasi"

%struct.item_t = type { i8*, i32*, i32, i32, i32 }

@input = hidden global [583 x i8] c"des_system_lib   std synopsys std_cell_lib des_system_lib dw02 dw01 ramlib ieee\0Adw01             ieee dw01 dware gtech\0Adw02             ieee dw02 dware\0Adw03             std synopsys dware dw03 dw02 dw01 ieee gtech\0Adw04             dw04 ieee dw01 dware gtech\0Adw05             dw05 ieee dware\0Adw06             dw06 ieee dware\0Adw07             ieee dware\0Adware            ieee dware\0Agtech            ieee gtech\0Aramlib           std ieee\0Astd_cell_lib     ieee std_cell_lib\0Asynopsys\0Acycle_11\09  cycle_12\0Acycle_12\09  cycle_11\0Acycle_21\09  dw01 cycle_22 dw02 dw03\0Acycle_22\09  cycle_21 dw01 dw04\00", align 16
@.str = private unnamed_addr constant [2 x i8] c"\0A\00", align 1
@.str.1 = private unnamed_addr constant [3 x i8] c" \09\00", align 1
@.str.2 = private unnamed_addr constant [16 x i8] c"Compile order:\0A\00", align 1
@.str.3 = private unnamed_addr constant [17 x i8] c"   [unorderable]\00", align 1
@.str.4 = private unnamed_addr constant [4 x i8] c"%d:\00", align 1
@.str.5 = private unnamed_addr constant [4 x i8] c" %s\00", align 1
@llvm.used = appending global [1 x i8*] [i8* bitcast (i32 ()* @__main_void to i8*)], section "llvm.metadata"

@__main_void = alias i32 (), i32 ()* @main

; Function Attrs: noinline nounwind optnone
define hidden i32 @get_item(%struct.item_t** %list, i32* %len, i8* %name) #0 {
entry:
  %retval = alloca i32, align 4
  %list.addr = alloca %struct.item_t**, align 4
  %len.addr = alloca i32*, align 4
  %name.addr = alloca i8*, align 4
  %i = alloca i32, align 4
  %lst = alloca %struct.item_t*, align 4
  store %struct.item_t** %list, %struct.item_t*** %list.addr, align 4
  store i32* %len, i32** %len.addr, align 4
  store i8* %name, i8** %name.addr, align 4
  %0 = load %struct.item_t**, %struct.item_t*** %list.addr, align 4
  %1 = load %struct.item_t*, %struct.item_t** %0, align 4
  store %struct.item_t* %1, %struct.item_t** %lst, align 4
  store i32 0, i32* %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %2 = load i32, i32* %i, align 4
  %3 = load i32*, i32** %len.addr, align 4
  %4 = load i32, i32* %3, align 4
  %cmp = icmp slt i32 %2, %4
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %5 = load %struct.item_t*, %struct.item_t** %lst, align 4
  %6 = load i32, i32* %i, align 4
  %arrayidx = getelementptr inbounds %struct.item_t, %struct.item_t* %5, i32 %6
  %name1 = getelementptr inbounds %struct.item_t, %struct.item_t* %arrayidx, i32 0, i32 0
  %7 = load i8*, i8** %name1, align 4
  %8 = load i8*, i8** %name.addr, align 4
  %call = call i32 @strcmp(i8* %7, i8* %8) #4
  %tobool = icmp ne i32 %call, 0
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %for.body
  %9 = load i32, i32* %i, align 4
  store i32 %9, i32* %retval, align 4
  br label %return

if.end:                                           ; preds = %for.body
  br label %for.inc

for.inc:                                          ; preds = %if.end
  %10 = load i32, i32* %i, align 4
  %inc = add nsw i32 %10, 1
  store i32 %inc, i32* %i, align 4
  br label %for.cond

for.end:                                          ; preds = %for.cond
  %11 = load %struct.item_t*, %struct.item_t** %lst, align 4
  %12 = bitcast %struct.item_t* %11 to i8*
  %13 = load i32*, i32** %len.addr, align 4
  %14 = load i32, i32* %13, align 4
  %inc2 = add nsw i32 %14, 1
  store i32 %inc2, i32* %13, align 4
  %mul = mul i32 %inc2, 20
  %call3 = call i8* @realloc(i8* %12, i32 %mul)
  %15 = bitcast i8* %call3 to %struct.item_t*
  %16 = load %struct.item_t**, %struct.item_t*** %list.addr, align 4
  store %struct.item_t* %15, %struct.item_t** %16, align 4
  store %struct.item_t* %15, %struct.item_t** %lst, align 4
  %17 = load i32*, i32** %len.addr, align 4
  %18 = load i32, i32* %17, align 4
  %sub = sub nsw i32 %18, 1
  store i32 %sub, i32* %i, align 4
  %19 = load %struct.item_t*, %struct.item_t** %lst, align 4
  %20 = load i32, i32* %i, align 4
  %add.ptr = getelementptr inbounds %struct.item_t, %struct.item_t* %19, i32 %20
  %21 = bitcast %struct.item_t* %add.ptr to i8*
  call void @llvm.memset.p0i8.i32(i8* align 4 %21, i8 0, i32 20, i1 false)
  %22 = load i32, i32* %i, align 4
  %23 = load %struct.item_t*, %struct.item_t** %lst, align 4
  %24 = load i32, i32* %i, align 4
  %arrayidx4 = getelementptr inbounds %struct.item_t, %struct.item_t* %23, i32 %24
  %idx = getelementptr inbounds %struct.item_t, %struct.item_t* %arrayidx4, i32 0, i32 3
  store i32 %22, i32* %idx, align 4
  %25 = load i8*, i8** %name.addr, align 4
  %26 = load %struct.item_t*, %struct.item_t** %lst, align 4
  %27 = load i32, i32* %i, align 4
  %arrayidx5 = getelementptr inbounds %struct.item_t, %struct.item_t* %26, i32 %27
  %name6 = getelementptr inbounds %struct.item_t, %struct.item_t* %arrayidx5, i32 0, i32 0
  store i8* %25, i8** %name6, align 4
  %28 = load i32, i32* %i, align 4
  store i32 %28, i32* %retval, align 4
  br label %return

return:                                           ; preds = %for.end, %if.then
  %29 = load i32, i32* %retval, align 4
  ret i32 %29
}

; Function Attrs: nounwind readonly
declare i32 @strcmp(i8* %0, i8* %1) #1

declare i8* @realloc(i8* %0, i32 %1) #2

; Function Attrs: argmemonly nounwind willreturn writeonly
declare void @llvm.memset.p0i8.i32(i8* nocapture writeonly %0, i8 %1, i32 %2, i1 immarg %3) #3

; Function Attrs: noinline nounwind optnone
define hidden void @add_dep(%struct.item_t* %it, i32 %i) #0 {
entry:
  %it.addr = alloca %struct.item_t*, align 4
  %i.addr = alloca i32, align 4
  store %struct.item_t* %it, %struct.item_t** %it.addr, align 4
  store i32 %i, i32* %i.addr, align 4
  %0 = load %struct.item_t*, %struct.item_t** %it.addr, align 4
  %idx = getelementptr inbounds %struct.item_t, %struct.item_t* %0, i32 0, i32 3
  %1 = load i32, i32* %idx, align 4
  %2 = load i32, i32* %i.addr, align 4
  %cmp = icmp eq i32 %1, %2
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  br label %return

if.end:                                           ; preds = %entry
  %3 = load %struct.item_t*, %struct.item_t** %it.addr, align 4
  %deps = getelementptr inbounds %struct.item_t, %struct.item_t* %3, i32 0, i32 1
  %4 = load i32*, i32** %deps, align 4
  %5 = bitcast i32* %4 to i8*
  %6 = load %struct.item_t*, %struct.item_t** %it.addr, align 4
  %n_deps = getelementptr inbounds %struct.item_t, %struct.item_t* %6, i32 0, i32 2
  %7 = load i32, i32* %n_deps, align 4
  %add = add nsw i32 %7, 1
  %mul = mul i32 %add, 4
  %call = call i8* @realloc(i8* %5, i32 %mul)
  %8 = bitcast i8* %call to i32*
  %9 = load %struct.item_t*, %struct.item_t** %it.addr, align 4
  %deps1 = getelementptr inbounds %struct.item_t, %struct.item_t* %9, i32 0, i32 1
  store i32* %8, i32** %deps1, align 4
  %10 = load i32, i32* %i.addr, align 4
  %11 = load %struct.item_t*, %struct.item_t** %it.addr, align 4
  %deps2 = getelementptr inbounds %struct.item_t, %struct.item_t* %11, i32 0, i32 1
  %12 = load i32*, i32** %deps2, align 4
  %13 = load %struct.item_t*, %struct.item_t** %it.addr, align 4
  %n_deps3 = getelementptr inbounds %struct.item_t, %struct.item_t* %13, i32 0, i32 2
  %14 = load i32, i32* %n_deps3, align 4
  %inc = add nsw i32 %14, 1
  store i32 %inc, i32* %n_deps3, align 4
  %arrayidx = getelementptr inbounds i32, i32* %12, i32 %14
  store i32 %10, i32* %arrayidx, align 4
  br label %return

return:                                           ; preds = %if.end, %if.then
  ret void
}

; Function Attrs: noinline nounwind optnone
define hidden i32 @parse_input(%struct.item_t** %ret) #0 {
entry:
  %ret.addr = alloca %struct.item_t**, align 4
  %n_items = alloca i32, align 4
  %i = alloca i32, align 4
  %parent = alloca i32, align 4
  %idx = alloca i32, align 4
  %list = alloca %struct.item_t*, align 4
  %s = alloca i8*, align 4
  %e = alloca i8*, align 4
  %word = alloca i8*, align 4
  %we = alloca i8*, align 4
  store %struct.item_t** %ret, %struct.item_t*** %ret.addr, align 4
  store i32 0, i32* %n_items, align 4
  store %struct.item_t* null, %struct.item_t** %list, align 4
  store i8* getelementptr inbounds ([583 x i8], [583 x i8]* @input, i32 0, i32 0), i8** %s, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc10, %entry
  %0 = load i8*, i8** %s, align 4
  %call = call i8* @strtok_r(i8* %0, i8* getelementptr inbounds ([2 x i8], [2 x i8]* @.str, i32 0, i32 0), i8** %e)
  store i8* %call, i8** %s, align 4
  %tobool = icmp ne i8* %call, null
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %for.cond
  br label %for.end11

if.end:                                           ; preds = %for.cond
  store i32 0, i32* %i, align 4
  %1 = load i8*, i8** %s, align 4
  store i8* %1, i8** %word, align 4
  br label %for.cond1

for.cond1:                                        ; preds = %for.inc, %if.end
  %2 = load i8*, i8** %word, align 4
  %call2 = call i8* @strtok_r(i8* %2, i8* getelementptr inbounds ([3 x i8], [3 x i8]* @.str.1, i32 0, i32 0), i8** %we)
  store i8* %call2, i8** %word, align 4
  %tobool3 = icmp ne i8* %call2, null
  br i1 %tobool3, label %if.end5, label %if.then4

if.then4:                                         ; preds = %for.cond1
  br label %for.end

if.end5:                                          ; preds = %for.cond1
  %3 = load i8*, i8** %word, align 4
  %call6 = call i32 @get_item(%struct.item_t** %list, i32* %n_items, i8* %3)
  store i32 %call6, i32* %idx, align 4
  %4 = load i32, i32* %i, align 4
  %tobool7 = icmp ne i32 %4, 0
  br i1 %tobool7, label %if.else, label %if.then8

if.then8:                                         ; preds = %if.end5
  %5 = load i32, i32* %idx, align 4
  store i32 %5, i32* %parent, align 4
  br label %if.end9

if.else:                                          ; preds = %if.end5
  %6 = load %struct.item_t*, %struct.item_t** %list, align 4
  %7 = load i32, i32* %parent, align 4
  %add.ptr = getelementptr inbounds %struct.item_t, %struct.item_t* %6, i32 %7
  %8 = load i32, i32* %idx, align 4
  call void @add_dep(%struct.item_t* %add.ptr, i32 %8)
  br label %if.end9

if.end9:                                          ; preds = %if.else, %if.then8
  br label %for.inc

for.inc:                                          ; preds = %if.end9
  %9 = load i32, i32* %i, align 4
  %inc = add nsw i32 %9, 1
  store i32 %inc, i32* %i, align 4
  store i8* null, i8** %word, align 4
  br label %for.cond1

for.end:                                          ; preds = %if.then4
  br label %for.inc10

for.inc10:                                        ; preds = %for.end
  store i8* null, i8** %s, align 4
  br label %for.cond

for.end11:                                        ; preds = %if.then
  %10 = load %struct.item_t*, %struct.item_t** %list, align 4
  %11 = load %struct.item_t**, %struct.item_t*** %ret.addr, align 4
  store %struct.item_t* %10, %struct.item_t** %11, align 4
  %12 = load i32, i32* %n_items, align 4
  ret i32 %12
}

declare i8* @strtok_r(i8* %0, i8* %1, i8** %2) #2

; Function Attrs: noinline nounwind optnone
define hidden i32 @get_depth(%struct.item_t* %list, i32 %idx, i32 %bad) #0 {
entry:
  %retval = alloca i32, align 4
  %list.addr = alloca %struct.item_t*, align 4
  %idx.addr = alloca i32, align 4
  %bad.addr = alloca i32, align 4
  %max = alloca i32, align 4
  %i = alloca i32, align 4
  %t = alloca i32, align 4
  store %struct.item_t* %list, %struct.item_t** %list.addr, align 4
  store i32 %idx, i32* %idx.addr, align 4
  store i32 %bad, i32* %bad.addr, align 4
  %0 = load %struct.item_t*, %struct.item_t** %list.addr, align 4
  %1 = load i32, i32* %idx.addr, align 4
  %arrayidx = getelementptr inbounds %struct.item_t, %struct.item_t* %0, i32 %1
  %deps = getelementptr inbounds %struct.item_t, %struct.item_t* %arrayidx, i32 0, i32 1
  %2 = load i32*, i32** %deps, align 4
  %tobool = icmp ne i32* %2, null
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  %3 = load %struct.item_t*, %struct.item_t** %list.addr, align 4
  %4 = load i32, i32* %idx.addr, align 4
  %arrayidx1 = getelementptr inbounds %struct.item_t, %struct.item_t* %3, i32 %4
  %depth = getelementptr inbounds %struct.item_t, %struct.item_t* %arrayidx1, i32 0, i32 4
  store i32 1, i32* %depth, align 4
  store i32 1, i32* %retval, align 4
  br label %return

if.end:                                           ; preds = %entry
  %5 = load %struct.item_t*, %struct.item_t** %list.addr, align 4
  %6 = load i32, i32* %idx.addr, align 4
  %arrayidx2 = getelementptr inbounds %struct.item_t, %struct.item_t* %5, i32 %6
  %depth3 = getelementptr inbounds %struct.item_t, %struct.item_t* %arrayidx2, i32 0, i32 4
  %7 = load i32, i32* %depth3, align 4
  store i32 %7, i32* %t, align 4
  %cmp = icmp slt i32 %7, 0
  br i1 %cmp, label %if.then4, label %if.end5

if.then4:                                         ; preds = %if.end
  %8 = load i32, i32* %t, align 4
  store i32 %8, i32* %retval, align 4
  br label %return

if.end5:                                          ; preds = %if.end
  %9 = load i32, i32* %bad.addr, align 4
  %10 = load %struct.item_t*, %struct.item_t** %list.addr, align 4
  %11 = load i32, i32* %idx.addr, align 4
  %arrayidx6 = getelementptr inbounds %struct.item_t, %struct.item_t* %10, i32 %11
  %depth7 = getelementptr inbounds %struct.item_t, %struct.item_t* %arrayidx6, i32 0, i32 4
  store i32 %9, i32* %depth7, align 4
  store i32 0, i32* %i, align 4
  store i32 0, i32* %max, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.end5
  %12 = load i32, i32* %i, align 4
  %13 = load %struct.item_t*, %struct.item_t** %list.addr, align 4
  %14 = load i32, i32* %idx.addr, align 4
  %arrayidx8 = getelementptr inbounds %struct.item_t, %struct.item_t* %13, i32 %14
  %n_deps = getelementptr inbounds %struct.item_t, %struct.item_t* %arrayidx8, i32 0, i32 2
  %15 = load i32, i32* %n_deps, align 4
  %cmp9 = icmp slt i32 %12, %15
  br i1 %cmp9, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %16 = load %struct.item_t*, %struct.item_t** %list.addr, align 4
  %17 = load %struct.item_t*, %struct.item_t** %list.addr, align 4
  %18 = load i32, i32* %idx.addr, align 4
  %arrayidx10 = getelementptr inbounds %struct.item_t, %struct.item_t* %17, i32 %18
  %deps11 = getelementptr inbounds %struct.item_t, %struct.item_t* %arrayidx10, i32 0, i32 1
  %19 = load i32*, i32** %deps11, align 4
  %20 = load i32, i32* %i, align 4
  %arrayidx12 = getelementptr inbounds i32, i32* %19, i32 %20
  %21 = load i32, i32* %arrayidx12, align 4
  %22 = load i32, i32* %bad.addr, align 4
  %call = call i32 @get_depth(%struct.item_t* %16, i32 %21, i32 %22)
  store i32 %call, i32* %t, align 4
  %cmp13 = icmp slt i32 %call, 0
  br i1 %cmp13, label %if.then14, label %if.end15

if.then14:                                        ; preds = %for.body
  %23 = load i32, i32* %t, align 4
  store i32 %23, i32* %max, align 4
  br label %for.end

if.end15:                                         ; preds = %for.body
  %24 = load i32, i32* %max, align 4
  %25 = load i32, i32* %t, align 4
  %add = add nsw i32 %25, 1
  %cmp16 = icmp slt i32 %24, %add
  br i1 %cmp16, label %if.then17, label %if.end19

if.then17:                                        ; preds = %if.end15
  %26 = load i32, i32* %t, align 4
  %add18 = add nsw i32 %26, 1
  store i32 %add18, i32* %max, align 4
  br label %if.end19

if.end19:                                         ; preds = %if.then17, %if.end15
  br label %for.inc

for.inc:                                          ; preds = %if.end19
  %27 = load i32, i32* %i, align 4
  %inc = add nsw i32 %27, 1
  store i32 %inc, i32* %i, align 4
  br label %for.cond

for.end:                                          ; preds = %if.then14, %for.cond
  %28 = load i32, i32* %max, align 4
  %29 = load %struct.item_t*, %struct.item_t** %list.addr, align 4
  %30 = load i32, i32* %idx.addr, align 4
  %arrayidx20 = getelementptr inbounds %struct.item_t, %struct.item_t* %29, i32 %30
  %depth21 = getelementptr inbounds %struct.item_t, %struct.item_t* %arrayidx20, i32 0, i32 4
  store i32 %28, i32* %depth21, align 4
  store i32 %28, i32* %retval, align 4
  br label %return

return:                                           ; preds = %for.end, %if.then4, %if.then
  %31 = load i32, i32* %retval, align 4
  ret i32 %31
}

; Function Attrs: noinline nounwind optnone
define hidden i32 @main() #0 {
entry:
  %retval = alloca i32, align 4
  %i = alloca i32, align 4
  %j = alloca i32, align 4
  %n = alloca i32, align 4
  %bad = alloca i32, align 4
  %max = alloca i32, align 4
  %min = alloca i32, align 4
  %items = alloca %struct.item_t*, align 4
  store i32 0, i32* %retval, align 4
  store i32 -1, i32* %bad, align 4
  %call = call i32 @parse_input(%struct.item_t** %items)
  store i32 %call, i32* %n, align 4
  store i32 0, i32* %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %0 = load i32, i32* %i, align 4
  %1 = load i32, i32* %n, align 4
  %cmp = icmp slt i32 %0, %1
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %2 = load %struct.item_t*, %struct.item_t** %items, align 4
  %3 = load i32, i32* %i, align 4
  %arrayidx = getelementptr inbounds %struct.item_t, %struct.item_t* %2, i32 %3
  %depth = getelementptr inbounds %struct.item_t, %struct.item_t* %arrayidx, i32 0, i32 4
  %4 = load i32, i32* %depth, align 4
  %tobool = icmp ne i32 %4, 0
  br i1 %tobool, label %if.end, label %land.lhs.true

land.lhs.true:                                    ; preds = %for.body
  %5 = load %struct.item_t*, %struct.item_t** %items, align 4
  %6 = load i32, i32* %i, align 4
  %7 = load i32, i32* %bad, align 4
  %call1 = call i32 @get_depth(%struct.item_t* %5, i32 %6, i32 %7)
  %cmp2 = icmp slt i32 %call1, 0
  br i1 %cmp2, label %if.then, label %if.end

if.then:                                          ; preds = %land.lhs.true
  %8 = load i32, i32* %bad, align 4
  %dec = add nsw i32 %8, -1
  store i32 %dec, i32* %bad, align 4
  br label %if.end

if.end:                                           ; preds = %if.then, %land.lhs.true, %for.body
  br label %for.inc

for.inc:                                          ; preds = %if.end
  %9 = load i32, i32* %i, align 4
  %inc = add nsw i32 %9, 1
  store i32 %inc, i32* %i, align 4
  br label %for.cond

for.end:                                          ; preds = %for.cond
  store i32 0, i32* %i, align 4
  store i32 0, i32* %min, align 4
  store i32 0, i32* %max, align 4
  br label %for.cond3

for.cond3:                                        ; preds = %for.inc20, %for.end
  %10 = load i32, i32* %i, align 4
  %11 = load i32, i32* %n, align 4
  %cmp4 = icmp slt i32 %10, %11
  br i1 %cmp4, label %for.body5, label %for.end22

for.body5:                                        ; preds = %for.cond3
  %12 = load %struct.item_t*, %struct.item_t** %items, align 4
  %13 = load i32, i32* %i, align 4
  %arrayidx6 = getelementptr inbounds %struct.item_t, %struct.item_t* %12, i32 %13
  %depth7 = getelementptr inbounds %struct.item_t, %struct.item_t* %arrayidx6, i32 0, i32 4
  %14 = load i32, i32* %depth7, align 4
  %15 = load i32, i32* %max, align 4
  %cmp8 = icmp sgt i32 %14, %15
  br i1 %cmp8, label %if.then9, label %if.end12

if.then9:                                         ; preds = %for.body5
  %16 = load %struct.item_t*, %struct.item_t** %items, align 4
  %17 = load i32, i32* %i, align 4
  %arrayidx10 = getelementptr inbounds %struct.item_t, %struct.item_t* %16, i32 %17
  %depth11 = getelementptr inbounds %struct.item_t, %struct.item_t* %arrayidx10, i32 0, i32 4
  %18 = load i32, i32* %depth11, align 4
  store i32 %18, i32* %max, align 4
  br label %if.end12

if.end12:                                         ; preds = %if.then9, %for.body5
  %19 = load %struct.item_t*, %struct.item_t** %items, align 4
  %20 = load i32, i32* %i, align 4
  %arrayidx13 = getelementptr inbounds %struct.item_t, %struct.item_t* %19, i32 %20
  %depth14 = getelementptr inbounds %struct.item_t, %struct.item_t* %arrayidx13, i32 0, i32 4
  %21 = load i32, i32* %depth14, align 4
  %22 = load i32, i32* %min, align 4
  %cmp15 = icmp slt i32 %21, %22
  br i1 %cmp15, label %if.then16, label %if.end19

if.then16:                                        ; preds = %if.end12
  %23 = load %struct.item_t*, %struct.item_t** %items, align 4
  %24 = load i32, i32* %i, align 4
  %arrayidx17 = getelementptr inbounds %struct.item_t, %struct.item_t* %23, i32 %24
  %depth18 = getelementptr inbounds %struct.item_t, %struct.item_t* %arrayidx17, i32 0, i32 4
  %25 = load i32, i32* %depth18, align 4
  store i32 %25, i32* %min, align 4
  br label %if.end19

if.end19:                                         ; preds = %if.then16, %if.end12
  br label %for.inc20

for.inc20:                                        ; preds = %if.end19
  %26 = load i32, i32* %i, align 4
  %inc21 = add nsw i32 %26, 1
  store i32 %inc21, i32* %i, align 4
  br label %for.cond3

for.end22:                                        ; preds = %for.cond3
  %call23 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([16 x i8], [16 x i8]* @.str.2, i32 0, i32 0))
  %27 = load i32, i32* %min, align 4
  store i32 %27, i32* %i, align 4
  br label %for.cond24

for.cond24:                                       ; preds = %for.inc50, %for.end22
  %28 = load i32, i32* %i, align 4
  %29 = load i32, i32* %max, align 4
  %cmp25 = icmp sle i32 %28, %29
  br i1 %cmp25, label %for.body26, label %for.end52

for.body26:                                       ; preds = %for.cond24
  %30 = load i32, i32* %i, align 4
  %tobool27 = icmp ne i32 %30, 0
  br i1 %tobool27, label %if.end29, label %if.then28

if.then28:                                        ; preds = %for.body26
  br label %for.inc50

if.end29:                                         ; preds = %for.body26
  %31 = load i32, i32* %i, align 4
  %cmp30 = icmp slt i32 %31, 0
  br i1 %cmp30, label %if.then31, label %if.else

if.then31:                                        ; preds = %if.end29
  %call32 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([17 x i8], [17 x i8]* @.str.3, i32 0, i32 0))
  br label %if.end34

if.else:                                          ; preds = %if.end29
  %32 = load i32, i32* %i, align 4
  %call33 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([4 x i8], [4 x i8]* @.str.4, i32 0, i32 0), i32 %32)
  br label %if.end34

if.end34:                                         ; preds = %if.else, %if.then31
  store i32 0, i32* %j, align 4
  br label %for.cond35

for.cond35:                                       ; preds = %for.inc47, %if.end34
  %33 = load i32, i32* %j, align 4
  %34 = load i32, i32* %n, align 4
  %cmp36 = icmp slt i32 %33, %34
  br i1 %cmp36, label %lor.end, label %lor.rhs

lor.rhs:                                          ; preds = %for.cond35
  %call37 = call i32 @putchar(i32 10)
  %tobool38 = icmp ne i32 %call37, 0
  %lnot = xor i1 %tobool38, true
  br label %lor.end

lor.end:                                          ; preds = %lor.rhs, %for.cond35
  %35 = phi i1 [ true, %for.cond35 ], [ %lnot, %lor.rhs ]
  br i1 %35, label %for.body39, label %for.end49

for.body39:                                       ; preds = %lor.end
  %36 = load %struct.item_t*, %struct.item_t** %items, align 4
  %37 = load i32, i32* %j, align 4
  %arrayidx40 = getelementptr inbounds %struct.item_t, %struct.item_t* %36, i32 %37
  %depth41 = getelementptr inbounds %struct.item_t, %struct.item_t* %arrayidx40, i32 0, i32 4
  %38 = load i32, i32* %depth41, align 4
  %39 = load i32, i32* %i, align 4
  %cmp42 = icmp eq i32 %38, %39
  br i1 %cmp42, label %if.then43, label %if.end46

if.then43:                                        ; preds = %for.body39
  %40 = load %struct.item_t*, %struct.item_t** %items, align 4
  %41 = load i32, i32* %j, align 4
  %arrayidx44 = getelementptr inbounds %struct.item_t, %struct.item_t* %40, i32 %41
  %name = getelementptr inbounds %struct.item_t, %struct.item_t* %arrayidx44, i32 0, i32 0
  %42 = load i8*, i8** %name, align 4
  %call45 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([4 x i8], [4 x i8]* @.str.5, i32 0, i32 0), i8* %42)
  br label %if.end46

if.end46:                                         ; preds = %if.then43, %for.body39
  br label %for.inc47

for.inc47:                                        ; preds = %if.end46
  %43 = load i32, i32* %j, align 4
  %inc48 = add nsw i32 %43, 1
  store i32 %inc48, i32* %j, align 4
  br label %for.cond35

for.end49:                                        ; preds = %lor.end
  br label %for.inc50

for.inc50:                                        ; preds = %for.end49, %if.then28
  %44 = load i32, i32* %i, align 4
  %inc51 = add nsw i32 %44, 1
  store i32 %inc51, i32* %i, align 4
  br label %for.cond24

for.end52:                                        ; preds = %for.cond24
  ret i32 0
}

declare i32 @printf(i8* %0, ...) #2

declare i32 @putchar(i32 %0) #2

attributes #0 = { noinline nounwind optnone "correctly-rounded-divide-sqrt-fp-math"="false" "disable-tail-calls"="false" "frame-pointer"="none" "less-precise-fpmad"="false" "min-legal-vector-width"="0" "no-infs-fp-math"="false" "no-jump-tables"="false" "no-nans-fp-math"="false" "no-signed-zeros-fp-math"="false" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="generic" "unsafe-fp-math"="false" "use-soft-float"="false" }
attributes #1 = { nounwind readonly "correctly-rounded-divide-sqrt-fp-math"="false" "disable-tail-calls"="false" "frame-pointer"="none" "less-precise-fpmad"="false" "no-infs-fp-math"="false" "no-nans-fp-math"="false" "no-signed-zeros-fp-math"="false" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="generic" "unsafe-fp-math"="false" "use-soft-float"="false" }
attributes #2 = { "correctly-rounded-divide-sqrt-fp-math"="false" "disable-tail-calls"="false" "frame-pointer"="none" "less-precise-fpmad"="false" "no-infs-fp-math"="false" "no-nans-fp-math"="false" "no-signed-zeros-fp-math"="false" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="generic" "unsafe-fp-math"="false" "use-soft-float"="false" }
attributes #3 = { argmemonly nounwind willreturn writeonly }
attributes #4 = { nounwind readonly }

!llvm.module.flags = !{!0}
!llvm.ident = !{!1}

!0 = !{i32 1, !"wchar_size", i32 4}
!1 = !{!"clang version 11.0.0 (https://github.com/Jacarte/llvm-project.git 0f6dea67136cc1e0b3d200eb2bb165628970c44b)"}

; extracted candidates

; *****
; For LLVM instruction:
;  %tobool = icmp ne i8* %call, null
; Looking for a replacement for:
%0:i32 = var
%1:i1 = ne 0:i32, %0
infer %1

; *****
; For LLVM instruction:
;  %tobool3 = icmp ne i8* %call2, null
; Looking for a replacement for:
%0:i32 = var
%1:i1 = ne 0:i32, %0
infer %1

; *****
; For LLVM instruction:
;  %call6 = call i32 @get_item(%struct.item_t** %list, i32* %n_items, i8* %3)
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %4 = load i32, i32* %i, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %tobool7 = icmp ne i32 %4, 0
; Looking for a replacement for:
%0:i32 = var
%1:i1 = ne 0:i32, %0
infer %1

; *****
; For LLVM instruction:
;  %5 = load i32, i32* %idx, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %7 = load i32, i32* %parent, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %8 = load i32, i32* %idx, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %9 = load i32, i32* %i, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %inc = add nsw i32 %9, 1
; Looking for a replacement for:
%0:i32 = var
%1:i32 = addnsw 1:i32, %0
infer %1

; *****
; For LLVM instruction:
;  %12 = load i32, i32* %n_items, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0
#########################################################
; exiting Souper's runOnFunction() for parse_input()

; entering Souper's runOnFunction() for get_depth()

; ModuleID = './Topological_sort.c.bc'
source_filename = "./Topological_sort.c"
target datalayout = "e-m:e-p:32:32-i64:64-n32:64-S128"
target triple = "wasm32-unknown-wasi"

%struct.item_t = type { i8*, i32*, i32, i32, i32 }

@input = hidden global [583 x i8] c"des_system_lib   std synopsys std_cell_lib des_system_lib dw02 dw01 ramlib ieee\0Adw01             ieee dw01 dware gtech\0Adw02             ieee dw02 dware\0Adw03             std synopsys dware dw03 dw02 dw01 ieee gtech\0Adw04             dw04 ieee dw01 dware gtech\0Adw05             dw05 ieee dware\0Adw06             dw06 ieee dware\0Adw07             ieee dware\0Adware            ieee dware\0Agtech            ieee gtech\0Aramlib           std ieee\0Astd_cell_lib     ieee std_cell_lib\0Asynopsys\0Acycle_11\09  cycle_12\0Acycle_12\09  cycle_11\0Acycle_21\09  dw01 cycle_22 dw02 dw03\0Acycle_22\09  cycle_21 dw01 dw04\00", align 16
@.str = private unnamed_addr constant [2 x i8] c"\0A\00", align 1
@.str.1 = private unnamed_addr constant [3 x i8] c" \09\00", align 1
@.str.2 = private unnamed_addr constant [16 x i8] c"Compile order:\0A\00", align 1
@.str.3 = private unnamed_addr constant [17 x i8] c"   [unorderable]\00", align 1
@.str.4 = private unnamed_addr constant [4 x i8] c"%d:\00", align 1
@.str.5 = private unnamed_addr constant [4 x i8] c" %s\00", align 1
@llvm.used = appending global [1 x i8*] [i8* bitcast (i32 ()* @__main_void to i8*)], section "llvm.metadata"

@__main_void = alias i32 (), i32 ()* @main

; Function Attrs: noinline nounwind optnone
define hidden i32 @get_item(%struct.item_t** %list, i32* %len, i8* %name) #0 {
entry:
  %retval = alloca i32, align 4
  %list.addr = alloca %struct.item_t**, align 4
  %len.addr = alloca i32*, align 4
  %name.addr = alloca i8*, align 4
  %i = alloca i32, align 4
  %lst = alloca %struct.item_t*, align 4
  store %struct.item_t** %list, %struct.item_t*** %list.addr, align 4
  store i32* %len, i32** %len.addr, align 4
  store i8* %name, i8** %name.addr, align 4
  %0 = load %struct.item_t**, %struct.item_t*** %list.addr, align 4
  %1 = load %struct.item_t*, %struct.item_t** %0, align 4
  store %struct.item_t* %1, %struct.item_t** %lst, align 4
  store i32 0, i32* %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %2 = load i32, i32* %i, align 4
  %3 = load i32*, i32** %len.addr, align 4
  %4 = load i32, i32* %3, align 4
  %cmp = icmp slt i32 %2, %4
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %5 = load %struct.item_t*, %struct.item_t** %lst, align 4
  %6 = load i32, i32* %i, align 4
  %arrayidx = getelementptr inbounds %struct.item_t, %struct.item_t* %5, i32 %6
  %name1 = getelementptr inbounds %struct.item_t, %struct.item_t* %arrayidx, i32 0, i32 0
  %7 = load i8*, i8** %name1, align 4
  %8 = load i8*, i8** %name.addr, align 4
  %call = call i32 @strcmp(i8* %7, i8* %8) #4
  %tobool = icmp ne i32 %call, 0
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %for.body
  %9 = load i32, i32* %i, align 4
  store i32 %9, i32* %retval, align 4
  br label %return

if.end:                                           ; preds = %for.body
  br label %for.inc

for.inc:                                          ; preds = %if.end
  %10 = load i32, i32* %i, align 4
  %inc = add nsw i32 %10, 1
  store i32 %inc, i32* %i, align 4
  br label %for.cond

for.end:                                          ; preds = %for.cond
  %11 = load %struct.item_t*, %struct.item_t** %lst, align 4
  %12 = bitcast %struct.item_t* %11 to i8*
  %13 = load i32*, i32** %len.addr, align 4
  %14 = load i32, i32* %13, align 4
  %inc2 = add nsw i32 %14, 1
  store i32 %inc2, i32* %13, align 4
  %mul = mul i32 %inc2, 20
  %call3 = call i8* @realloc(i8* %12, i32 %mul)
  %15 = bitcast i8* %call3 to %struct.item_t*
  %16 = load %struct.item_t**, %struct.item_t*** %list.addr, align 4
  store %struct.item_t* %15, %struct.item_t** %16, align 4
  store %struct.item_t* %15, %struct.item_t** %lst, align 4
  %17 = load i32*, i32** %len.addr, align 4
  %18 = load i32, i32* %17, align 4
  %sub = sub nsw i32 %18, 1
  store i32 %sub, i32* %i, align 4
  %19 = load %struct.item_t*, %struct.item_t** %lst, align 4
  %20 = load i32, i32* %i, align 4
  %add.ptr = getelementptr inbounds %struct.item_t, %struct.item_t* %19, i32 %20
  %21 = bitcast %struct.item_t* %add.ptr to i8*
  call void @llvm.memset.p0i8.i32(i8* align 4 %21, i8 0, i32 20, i1 false)
  %22 = load i32, i32* %i, align 4
  %23 = load %struct.item_t*, %struct.item_t** %lst, align 4
  %24 = load i32, i32* %i, align 4
  %arrayidx4 = getelementptr inbounds %struct.item_t, %struct.item_t* %23, i32 %24
  %idx = getelementptr inbounds %struct.item_t, %struct.item_t* %arrayidx4, i32 0, i32 3
  store i32 %22, i32* %idx, align 4
  %25 = load i8*, i8** %name.addr, align 4
  %26 = load %struct.item_t*, %struct.item_t** %lst, align 4
  %27 = load i32, i32* %i, align 4
  %arrayidx5 = getelementptr inbounds %struct.item_t, %struct.item_t* %26, i32 %27
  %name6 = getelementptr inbounds %struct.item_t, %struct.item_t* %arrayidx5, i32 0, i32 0
  store i8* %25, i8** %name6, align 4
  %28 = load i32, i32* %i, align 4
  store i32 %28, i32* %retval, align 4
  br label %return

return:                                           ; preds = %for.end, %if.then
  %29 = load i32, i32* %retval, align 4
  ret i32 %29
}

; Function Attrs: nounwind readonly
declare i32 @strcmp(i8* %0, i8* %1) #1

declare i8* @realloc(i8* %0, i32 %1) #2

; Function Attrs: argmemonly nounwind willreturn writeonly
declare void @llvm.memset.p0i8.i32(i8* nocapture writeonly %0, i8 %1, i32 %2, i1 immarg %3) #3

; Function Attrs: noinline nounwind optnone
define hidden void @add_dep(%struct.item_t* %it, i32 %i) #0 {
entry:
  %it.addr = alloca %struct.item_t*, align 4
  %i.addr = alloca i32, align 4
  store %struct.item_t* %it, %struct.item_t** %it.addr, align 4
  store i32 %i, i32* %i.addr, align 4
  %0 = load %struct.item_t*, %struct.item_t** %it.addr, align 4
  %idx = getelementptr inbounds %struct.item_t, %struct.item_t* %0, i32 0, i32 3
  %1 = load i32, i32* %idx, align 4
  %2 = load i32, i32* %i.addr, align 4
  %cmp = icmp eq i32 %1, %2
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  br label %return

if.end:                                           ; preds = %entry
  %3 = load %struct.item_t*, %struct.item_t** %it.addr, align 4
  %deps = getelementptr inbounds %struct.item_t, %struct.item_t* %3, i32 0, i32 1
  %4 = load i32*, i32** %deps, align 4
  %5 = bitcast i32* %4 to i8*
  %6 = load %struct.item_t*, %struct.item_t** %it.addr, align 4
  %n_deps = getelementptr inbounds %struct.item_t, %struct.item_t* %6, i32 0, i32 2
  %7 = load i32, i32* %n_deps, align 4
  %add = add nsw i32 %7, 1
  %mul = mul i32 %add, 4
  %call = call i8* @realloc(i8* %5, i32 %mul)
  %8 = bitcast i8* %call to i32*
  %9 = load %struct.item_t*, %struct.item_t** %it.addr, align 4
  %deps1 = getelementptr inbounds %struct.item_t, %struct.item_t* %9, i32 0, i32 1
  store i32* %8, i32** %deps1, align 4
  %10 = load i32, i32* %i.addr, align 4
  %11 = load %struct.item_t*, %struct.item_t** %it.addr, align 4
  %deps2 = getelementptr inbounds %struct.item_t, %struct.item_t* %11, i32 0, i32 1
  %12 = load i32*, i32** %deps2, align 4
  %13 = load %struct.item_t*, %struct.item_t** %it.addr, align 4
  %n_deps3 = getelementptr inbounds %struct.item_t, %struct.item_t* %13, i32 0, i32 2
  %14 = load i32, i32* %n_deps3, align 4
  %inc = add nsw i32 %14, 1
  store i32 %inc, i32* %n_deps3, align 4
  %arrayidx = getelementptr inbounds i32, i32* %12, i32 %14
  store i32 %10, i32* %arrayidx, align 4
  br label %return

return:                                           ; preds = %if.end, %if.then
  ret void
}

; Function Attrs: noinline nounwind optnone
define hidden i32 @parse_input(%struct.item_t** %ret) #0 {
entry:
  %ret.addr = alloca %struct.item_t**, align 4
  %n_items = alloca i32, align 4
  %i = alloca i32, align 4
  %parent = alloca i32, align 4
  %idx = alloca i32, align 4
  %list = alloca %struct.item_t*, align 4
  %s = alloca i8*, align 4
  %e = alloca i8*, align 4
  %word = alloca i8*, align 4
  %we = alloca i8*, align 4
  store %struct.item_t** %ret, %struct.item_t*** %ret.addr, align 4
  store i32 0, i32* %n_items, align 4
  store %struct.item_t* null, %struct.item_t** %list, align 4
  store i8* getelementptr inbounds ([583 x i8], [583 x i8]* @input, i32 0, i32 0), i8** %s, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc10, %entry
  %0 = load i8*, i8** %s, align 4
  %call = call i8* @strtok_r(i8* %0, i8* getelementptr inbounds ([2 x i8], [2 x i8]* @.str, i32 0, i32 0), i8** %e)
  store i8* %call, i8** %s, align 4
  %tobool = icmp ne i8* %call, null
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %for.cond
  br label %for.end11

if.end:                                           ; preds = %for.cond
  store i32 0, i32* %i, align 4
  %1 = load i8*, i8** %s, align 4
  store i8* %1, i8** %word, align 4
  br label %for.cond1

for.cond1:                                        ; preds = %for.inc, %if.end
  %2 = load i8*, i8** %word, align 4
  %call2 = call i8* @strtok_r(i8* %2, i8* getelementptr inbounds ([3 x i8], [3 x i8]* @.str.1, i32 0, i32 0), i8** %we)
  store i8* %call2, i8** %word, align 4
  %tobool3 = icmp ne i8* %call2, null
  br i1 %tobool3, label %if.end5, label %if.then4

if.then4:                                         ; preds = %for.cond1
  br label %for.end

if.end5:                                          ; preds = %for.cond1
  %3 = load i8*, i8** %word, align 4
  %call6 = call i32 @get_item(%struct.item_t** %list, i32* %n_items, i8* %3)
  store i32 %call6, i32* %idx, align 4
  %4 = load i32, i32* %i, align 4
  %tobool7 = icmp ne i32 %4, 0
  br i1 %tobool7, label %if.else, label %if.then8

if.then8:                                         ; preds = %if.end5
  %5 = load i32, i32* %idx, align 4
  store i32 %5, i32* %parent, align 4
  br label %if.end9

if.else:                                          ; preds = %if.end5
  %6 = load %struct.item_t*, %struct.item_t** %list, align 4
  %7 = load i32, i32* %parent, align 4
  %add.ptr = getelementptr inbounds %struct.item_t, %struct.item_t* %6, i32 %7
  %8 = load i32, i32* %idx, align 4
  call void @add_dep(%struct.item_t* %add.ptr, i32 %8)
  br label %if.end9

if.end9:                                          ; preds = %if.else, %if.then8
  br label %for.inc

for.inc:                                          ; preds = %if.end9
  %9 = load i32, i32* %i, align 4
  %inc = add nsw i32 %9, 1
  store i32 %inc, i32* %i, align 4
  store i8* null, i8** %word, align 4
  br label %for.cond1

for.end:                                          ; preds = %if.then4
  br label %for.inc10

for.inc10:                                        ; preds = %for.end
  store i8* null, i8** %s, align 4
  br label %for.cond

for.end11:                                        ; preds = %if.then
  %10 = load %struct.item_t*, %struct.item_t** %list, align 4
  %11 = load %struct.item_t**, %struct.item_t*** %ret.addr, align 4
  store %struct.item_t* %10, %struct.item_t** %11, align 4
  %12 = load i32, i32* %n_items, align 4
  ret i32 %12
}

declare i8* @strtok_r(i8* %0, i8* %1, i8** %2) #2

; Function Attrs: noinline nounwind optnone
define hidden i32 @get_depth(%struct.item_t* %list, i32 %idx, i32 %bad) #0 {
entry:
  %retval = alloca i32, align 4
  %list.addr = alloca %struct.item_t*, align 4
  %idx.addr = alloca i32, align 4
  %bad.addr = alloca i32, align 4
  %max = alloca i32, align 4
  %i = alloca i32, align 4
  %t = alloca i32, align 4
  store %struct.item_t* %list, %struct.item_t** %list.addr, align 4
  store i32 %idx, i32* %idx.addr, align 4
  store i32 %bad, i32* %bad.addr, align 4
  %0 = load %struct.item_t*, %struct.item_t** %list.addr, align 4
  %1 = load i32, i32* %idx.addr, align 4
  %arrayidx = getelementptr inbounds %struct.item_t, %struct.item_t* %0, i32 %1
  %deps = getelementptr inbounds %struct.item_t, %struct.item_t* %arrayidx, i32 0, i32 1
  %2 = load i32*, i32** %deps, align 4
  %tobool = icmp ne i32* %2, null
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  %3 = load %struct.item_t*, %struct.item_t** %list.addr, align 4
  %4 = load i32, i32* %idx.addr, align 4
  %arrayidx1 = getelementptr inbounds %struct.item_t, %struct.item_t* %3, i32 %4
  %depth = getelementptr inbounds %struct.item_t, %struct.item_t* %arrayidx1, i32 0, i32 4
  store i32 1, i32* %depth, align 4
  store i32 1, i32* %retval, align 4
  br label %return

if.end:                                           ; preds = %entry
  %5 = load %struct.item_t*, %struct.item_t** %list.addr, align 4
  %6 = load i32, i32* %idx.addr, align 4
  %arrayidx2 = getelementptr inbounds %struct.item_t, %struct.item_t* %5, i32 %6
  %depth3 = getelementptr inbounds %struct.item_t, %struct.item_t* %arrayidx2, i32 0, i32 4
  %7 = load i32, i32* %depth3, align 4
  store i32 %7, i32* %t, align 4
  %cmp = icmp slt i32 %7, 0
  br i1 %cmp, label %if.then4, label %if.end5

if.then4:                                         ; preds = %if.end
  %8 = load i32, i32* %t, align 4
  store i32 %8, i32* %retval, align 4
  br label %return

if.end5:                                          ; preds = %if.end
  %9 = load i32, i32* %bad.addr, align 4
  %10 = load %struct.item_t*, %struct.item_t** %list.addr, align 4
  %11 = load i32, i32* %idx.addr, align 4
  %arrayidx6 = getelementptr inbounds %struct.item_t, %struct.item_t* %10, i32 %11
  %depth7 = getelementptr inbounds %struct.item_t, %struct.item_t* %arrayidx6, i32 0, i32 4
  store i32 %9, i32* %depth7, align 4
  store i32 0, i32* %i, align 4
  store i32 0, i32* %max, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.end5
  %12 = load i32, i32* %i, align 4
  %13 = load %struct.item_t*, %struct.item_t** %list.addr, align 4
  %14 = load i32, i32* %idx.addr, align 4
  %arrayidx8 = getelementptr inbounds %struct.item_t, %struct.item_t* %13, i32 %14
  %n_deps = getelementptr inbounds %struct.item_t, %struct.item_t* %arrayidx8, i32 0, i32 2
  %15 = load i32, i32* %n_deps, align 4
  %cmp9 = icmp slt i32 %12, %15
  br i1 %cmp9, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %16 = load %struct.item_t*, %struct.item_t** %list.addr, align 4
  %17 = load %struct.item_t*, %struct.item_t** %list.addr, align 4
  %18 = load i32, i32* %idx.addr, align 4
  %arrayidx10 = getelementptr inbounds %struct.item_t, %struct.item_t* %17, i32 %18
  %deps11 = getelementptr inbounds %struct.item_t, %struct.item_t* %arrayidx10, i32 0, i32 1
  %19 = load i32*, i32** %deps11, align 4
  %20 = load i32, i32* %i, align 4
  %arrayidx12 = getelementptr inbounds i32, i32* %19, i32 %20
  %21 = load i32, i32* %arrayidx12, align 4
  %22 = load i32, i32* %bad.addr, align 4
  %call = call i32 @get_depth(%struct.item_t* %16, i32 %21, i32 %22)
  store i32 %call, i32* %t, align 4
  %cmp13 = icmp slt i32 %call, 0
  br i1 %cmp13, label %if.then14, label %if.end15

if.then14:                                        ; preds = %for.body
  %23 = load i32, i32* %t, align 4
  store i32 %23, i32* %max, align 4
  br label %for.end

if.end15:                                         ; preds = %for.body
  %24 = load i32, i32* %max, align 4
  %25 = load i32, i32* %t, align 4
  %add = add nsw i32 %25, 1
  %cmp16 = icmp slt i32 %24, %add
  br i1 %cmp16, label %if.then17, label %if.end19

if.then17:                                        ; preds = %if.end15
  %26 = load i32, i32* %t, align 4
  %add18 = add nsw i32 %26, 1
  store i32 %add18, i32* %max, align 4
  br label %if.end19

if.end19:                                         ; preds = %if.then17, %if.end15
  br label %for.inc

for.inc:                                          ; preds = %if.end19
  %27 = load i32, i32* %i, align 4
  %inc = add nsw i32 %27, 1
  store i32 %inc, i32* %i, align 4
  br label %for.cond

for.end:                                          ; preds = %if.then14, %for.cond
  %28 = load i32, i32* %max, align 4
  %29 = load %struct.item_t*, %struct.item_t** %list.addr, align 4
  %30 = load i32, i32* %idx.addr, align 4
  %arrayidx20 = getelementptr inbounds %struct.item_t, %struct.item_t* %29, i32 %30
  %depth21 = getelementptr inbounds %struct.item_t, %struct.item_t* %arrayidx20, i32 0, i32 4
  store i32 %28, i32* %depth21, align 4
  store i32 %28, i32* %retval, align 4
  br label %return

return:                                           ; preds = %for.end, %if.then4, %if.then
  %31 = load i32, i32* %retval, align 4
  ret i32 %31
}

; Function Attrs: noinline nounwind optnone
define hidden i32 @main() #0 {
entry:
  %retval = alloca i32, align 4
  %i = alloca i32, align 4
  %j = alloca i32, align 4
  %n = alloca i32, align 4
  %bad = alloca i32, align 4
  %max = alloca i32, align 4
  %min = alloca i32, align 4
  %items = alloca %struct.item_t*, align 4
  store i32 0, i32* %retval, align 4
  store i32 -1, i32* %bad, align 4
  %call = call i32 @parse_input(%struct.item_t** %items)
  store i32 %call, i32* %n, align 4
  store i32 0, i32* %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %0 = load i32, i32* %i, align 4
  %1 = load i32, i32* %n, align 4
  %cmp = icmp slt i32 %0, %1
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %2 = load %struct.item_t*, %struct.item_t** %items, align 4
  %3 = load i32, i32* %i, align 4
  %arrayidx = getelementptr inbounds %struct.item_t, %struct.item_t* %2, i32 %3
  %depth = getelementptr inbounds %struct.item_t, %struct.item_t* %arrayidx, i32 0, i32 4
  %4 = load i32, i32* %depth, align 4
  %tobool = icmp ne i32 %4, 0
  br i1 %tobool, label %if.end, label %land.lhs.true

land.lhs.true:                                    ; preds = %for.body
  %5 = load %struct.item_t*, %struct.item_t** %items, align 4
  %6 = load i32, i32* %i, align 4
  %7 = load i32, i32* %bad, align 4
  %call1 = call i32 @get_depth(%struct.item_t* %5, i32 %6, i32 %7)
  %cmp2 = icmp slt i32 %call1, 0
  br i1 %cmp2, label %if.then, label %if.end

if.then:                                          ; preds = %land.lhs.true
  %8 = load i32, i32* %bad, align 4
  %dec = add nsw i32 %8, -1
  store i32 %dec, i32* %bad, align 4
  br label %if.end

if.end:                                           ; preds = %if.then, %land.lhs.true, %for.body
  br label %for.inc

for.inc:                                          ; preds = %if.end
  %9 = load i32, i32* %i, align 4
  %inc = add nsw i32 %9, 1
  store i32 %inc, i32* %i, align 4
  br label %for.cond

for.end:                                          ; preds = %for.cond
  store i32 0, i32* %i, align 4
  store i32 0, i32* %min, align 4
  store i32 0, i32* %max, align 4
  br label %for.cond3

for.cond3:                                        ; preds = %for.inc20, %for.end
  %10 = load i32, i32* %i, align 4
  %11 = load i32, i32* %n, align 4
  %cmp4 = icmp slt i32 %10, %11
  br i1 %cmp4, label %for.body5, label %for.end22

for.body5:                                        ; preds = %for.cond3
  %12 = load %struct.item_t*, %struct.item_t** %items, align 4
  %13 = load i32, i32* %i, align 4
  %arrayidx6 = getelementptr inbounds %struct.item_t, %struct.item_t* %12, i32 %13
  %depth7 = getelementptr inbounds %struct.item_t, %struct.item_t* %arrayidx6, i32 0, i32 4
  %14 = load i32, i32* %depth7, align 4
  %15 = load i32, i32* %max, align 4
  %cmp8 = icmp sgt i32 %14, %15
  br i1 %cmp8, label %if.then9, label %if.end12

if.then9:                                         ; preds = %for.body5
  %16 = load %struct.item_t*, %struct.item_t** %items, align 4
  %17 = load i32, i32* %i, align 4
  %arrayidx10 = getelementptr inbounds %struct.item_t, %struct.item_t* %16, i32 %17
  %depth11 = getelementptr inbounds %struct.item_t, %struct.item_t* %arrayidx10, i32 0, i32 4
  %18 = load i32, i32* %depth11, align 4
  store i32 %18, i32* %max, align 4
  br label %if.end12

if.end12:                                         ; preds = %if.then9, %for.body5
  %19 = load %struct.item_t*, %struct.item_t** %items, align 4
  %20 = load i32, i32* %i, align 4
  %arrayidx13 = getelementptr inbounds %struct.item_t, %struct.item_t* %19, i32 %20
  %depth14 = getelementptr inbounds %struct.item_t, %struct.item_t* %arrayidx13, i32 0, i32 4
  %21 = load i32, i32* %depth14, align 4
  %22 = load i32, i32* %min, align 4
  %cmp15 = icmp slt i32 %21, %22
  br i1 %cmp15, label %if.then16, label %if.end19

if.then16:                                        ; preds = %if.end12
  %23 = load %struct.item_t*, %struct.item_t** %items, align 4
  %24 = load i32, i32* %i, align 4
  %arrayidx17 = getelementptr inbounds %struct.item_t, %struct.item_t* %23, i32 %24
  %depth18 = getelementptr inbounds %struct.item_t, %struct.item_t* %arrayidx17, i32 0, i32 4
  %25 = load i32, i32* %depth18, align 4
  store i32 %25, i32* %min, align 4
  br label %if.end19

if.end19:                                         ; preds = %if.then16, %if.end12
  br label %for.inc20

for.inc20:                                        ; preds = %if.end19
  %26 = load i32, i32* %i, align 4
  %inc21 = add nsw i32 %26, 1
  store i32 %inc21, i32* %i, align 4
  br label %for.cond3

for.end22:                                        ; preds = %for.cond3
  %call23 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([16 x i8], [16 x i8]* @.str.2, i32 0, i32 0))
  %27 = load i32, i32* %min, align 4
  store i32 %27, i32* %i, align 4
  br label %for.cond24

for.cond24:                                       ; preds = %for.inc50, %for.end22
  %28 = load i32, i32* %i, align 4
  %29 = load i32, i32* %max, align 4
  %cmp25 = icmp sle i32 %28, %29
  br i1 %cmp25, label %for.body26, label %for.end52

for.body26:                                       ; preds = %for.cond24
  %30 = load i32, i32* %i, align 4
  %tobool27 = icmp ne i32 %30, 0
  br i1 %tobool27, label %if.end29, label %if.then28

if.then28:                                        ; preds = %for.body26
  br label %for.inc50

if.end29:                                         ; preds = %for.body26
  %31 = load i32, i32* %i, align 4
  %cmp30 = icmp slt i32 %31, 0
  br i1 %cmp30, label %if.then31, label %if.else

if.then31:                                        ; preds = %if.end29
  %call32 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([17 x i8], [17 x i8]* @.str.3, i32 0, i32 0))
  br label %if.end34

if.else:                                          ; preds = %if.end29
  %32 = load i32, i32* %i, align 4
  %call33 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([4 x i8], [4 x i8]* @.str.4, i32 0, i32 0), i32 %32)
  br label %if.end34

if.end34:                                         ; preds = %if.else, %if.then31
  store i32 0, i32* %j, align 4
  br label %for.cond35

for.cond35:                                       ; preds = %for.inc47, %if.end34
  %33 = load i32, i32* %j, align 4
  %34 = load i32, i32* %n, align 4
  %cmp36 = icmp slt i32 %33, %34
  br i1 %cmp36, label %lor.end, label %lor.rhs

lor.rhs:                                          ; preds = %for.cond35
  %call37 = call i32 @putchar(i32 10)
  %tobool38 = icmp ne i32 %call37, 0
  %lnot = xor i1 %tobool38, true
  br label %lor.end

lor.end:                                          ; preds = %lor.rhs, %for.cond35
  %35 = phi i1 [ true, %for.cond35 ], [ %lnot, %lor.rhs ]
  br i1 %35, label %for.body39, label %for.end49

for.body39:                                       ; preds = %lor.end
  %36 = load %struct.item_t*, %struct.item_t** %items, align 4
  %37 = load i32, i32* %j, align 4
  %arrayidx40 = getelementptr inbounds %struct.item_t, %struct.item_t* %36, i32 %37
  %depth41 = getelementptr inbounds %struct.item_t, %struct.item_t* %arrayidx40, i32 0, i32 4
  %38 = load i32, i32* %depth41, align 4
  %39 = load i32, i32* %i, align 4
  %cmp42 = icmp eq i32 %38, %39
  br i1 %cmp42, label %if.then43, label %if.end46

if.then43:                                        ; preds = %for.body39
  %40 = load %struct.item_t*, %struct.item_t** %items, align 4
  %41 = load i32, i32* %j, align 4
  %arrayidx44 = getelementptr inbounds %struct.item_t, %struct.item_t* %40, i32 %41
  %name = getelementptr inbounds %struct.item_t, %struct.item_t* %arrayidx44, i32 0, i32 0
  %42 = load i8*, i8** %name, align 4
  %call45 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([4 x i8], [4 x i8]* @.str.5, i32 0, i32 0), i8* %42)
  br label %if.end46

if.end46:                                         ; preds = %if.then43, %for.body39
  br label %for.inc47

for.inc47:                                        ; preds = %if.end46
  %43 = load i32, i32* %j, align 4
  %inc48 = add nsw i32 %43, 1
  store i32 %inc48, i32* %j, align 4
  br label %for.cond35

for.end49:                                        ; preds = %lor.end
  br label %for.inc50

for.inc50:                                        ; preds = %for.end49, %if.then28
  %44 = load i32, i32* %i, align 4
  %inc51 = add nsw i32 %44, 1
  store i32 %inc51, i32* %i, align 4
  br label %for.cond24

for.end52:                                        ; preds = %for.cond24
  ret i32 0
}

declare i32 @printf(i8* %0, ...) #2

declare i32 @putchar(i32 %0) #2

attributes #0 = { noinline nounwind optnone "correctly-rounded-divide-sqrt-fp-math"="false" "disable-tail-calls"="false" "frame-pointer"="none" "less-precise-fpmad"="false" "min-legal-vector-width"="0" "no-infs-fp-math"="false" "no-jump-tables"="false" "no-nans-fp-math"="false" "no-signed-zeros-fp-math"="false" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="generic" "unsafe-fp-math"="false" "use-soft-float"="false" }
attributes #1 = { nounwind readonly "correctly-rounded-divide-sqrt-fp-math"="false" "disable-tail-calls"="false" "frame-pointer"="none" "less-precise-fpmad"="false" "no-infs-fp-math"="false" "no-nans-fp-math"="false" "no-signed-zeros-fp-math"="false" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="generic" "unsafe-fp-math"="false" "use-soft-float"="false" }
attributes #2 = { "correctly-rounded-divide-sqrt-fp-math"="false" "disable-tail-calls"="false" "frame-pointer"="none" "less-precise-fpmad"="false" "no-infs-fp-math"="false" "no-nans-fp-math"="false" "no-signed-zeros-fp-math"="false" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="generic" "unsafe-fp-math"="false" "use-soft-float"="false" }
attributes #3 = { argmemonly nounwind willreturn writeonly }
attributes #4 = { nounwind readonly }

!llvm.module.flags = !{!0}
!llvm.ident = !{!1}

!0 = !{i32 1, !"wchar_size", i32 4}
!1 = !{!"clang version 11.0.0 (https://github.com/Jacarte/llvm-project.git 0f6dea67136cc1e0b3d200eb2bb165628970c44b)"}

; extracted candidates

; *****
; For LLVM instruction:
;  %1 = load i32, i32* %idx.addr, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %tobool = icmp ne i32* %2, null
; Looking for a replacement for:
%0:i32 = var
%1:i1 = ne 0:i32, %0
infer %1

; *****
; For LLVM instruction:
;  %4 = load i32, i32* %idx.addr, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %6 = load i32, i32* %idx.addr, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %7 = load i32, i32* %depth3, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %cmp = icmp slt i32 %7, 0
; Looking for a replacement for:
%0:i32 = var
%1:i1 = slt %0, 0:i32
infer %1

; *****
; For LLVM instruction:
;  %8 = load i32, i32* %t, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %9 = load i32, i32* %bad.addr, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %11 = load i32, i32* %idx.addr, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %12 = load i32, i32* %i, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %14 = load i32, i32* %idx.addr, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %15 = load i32, i32* %n_deps, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %cmp9 = icmp slt i32 %12, %15
; Looking for a replacement for:
%0:i32 = var
%1:i32 = var
%2:i1 = slt %0, %1
infer %2

; *****
; For LLVM instruction:
;  %18 = load i32, i32* %idx.addr, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %20 = load i32, i32* %i, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %21 = load i32, i32* %arrayidx12, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %22 = load i32, i32* %bad.addr, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %call = call i32 @get_depth(%struct.item_t* %16, i32 %21, i32 %22)
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %cmp13 = icmp slt i32 %call, 0
; Looking for a replacement for:
%0:i32 = var
%1:i1 = slt %0, 0:i32
infer %1

; *****
; For LLVM instruction:
;  %23 = load i32, i32* %t, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %24 = load i32, i32* %max, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %25 = load i32, i32* %t, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %add = add nsw i32 %25, 1
; Looking for a replacement for:
%0:i32 = var
%1:i32 = addnsw 1:i32, %0
infer %1

; *****
; For LLVM instruction:
;  %cmp16 = icmp slt i32 %24, %add
; Looking for a replacement for:
%0:i32 = var
%1:i32 = var
%2:i32 = addnsw 1:i32, %1
%3:i1 = slt %0, %2
infer %3

; *****
; For LLVM instruction:
;  %26 = load i32, i32* %t, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %add18 = add nsw i32 %26, 1
; Looking for a replacement for:
%0:i32 = var
%1:i32 = addnsw 1:i32, %0
infer %1

; *****
; For LLVM instruction:
;  %27 = load i32, i32* %i, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %inc = add nsw i32 %27, 1
; Looking for a replacement for:
%0:i32 = var
%1:i32 = addnsw 1:i32, %0
infer %1

; *****
; For LLVM instruction:
;  %28 = load i32, i32* %max, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %30 = load i32, i32* %idx.addr, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %31 = load i32, i32* %retval, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0
got 2 candidates from LHS

-------------------------------------------------
%0:i32 = var
%1:i1 = slt %0, 0:i32
infer %1


--------------------------------
guess 0

%0:i1 = var ; reservedconst_1

Cost = 0
first query is SAT, returning the model:
reservedconst_1: 0
0 th attempt: second query is SAT-- constant doesn't work
first query is SAT, returning the model:
reservedconst_1: -1
1 th attempt: second query is SAT-- constant doesn't work
first query is UNSAT-- no more guesses
Dataflow Pruned 0/0
There are 1 Guesses
There are 0 RHSs before deduplication
There are 0 RHSs after deduplication
got 4 candidates from LHS

-------------------------------------------------
%0:i32 = var
%1:i32 = var
%2:i32 = addnsw 1:i32, %1
%3:i1 = slt %0, %2
infer %3


--------------------------------
guess 0

%0:i1 = var ; reservedconst_1

Cost = 0
first query is SAT, returning the model:
reservedconst_1: -1
0 th attempt: second query is SAT-- constant doesn't work
first query is SAT, returning the model:
reservedconst_1: 0
1 th attempt: second query is SAT-- constant doesn't work
first query is UNSAT-- no more guesses
Dataflow Pruned 0/0
There are 1 Guesses
There are 0 RHSs before deduplication
There are 0 RHSs after deduplication
#########################################################
; exiting Souper's runOnFunction() for get_depth()

; entering Souper's runOnFunction() for main()

; ModuleID = './Topological_sort.c.bc'
source_filename = "./Topological_sort.c"
target datalayout = "e-m:e-p:32:32-i64:64-n32:64-S128"
target triple = "wasm32-unknown-wasi"

%struct.item_t = type { i8*, i32*, i32, i32, i32 }

@input = hidden global [583 x i8] c"des_system_lib   std synopsys std_cell_lib des_system_lib dw02 dw01 ramlib ieee\0Adw01             ieee dw01 dware gtech\0Adw02             ieee dw02 dware\0Adw03             std synopsys dware dw03 dw02 dw01 ieee gtech\0Adw04             dw04 ieee dw01 dware gtech\0Adw05             dw05 ieee dware\0Adw06             dw06 ieee dware\0Adw07             ieee dware\0Adware            ieee dware\0Agtech            ieee gtech\0Aramlib           std ieee\0Astd_cell_lib     ieee std_cell_lib\0Asynopsys\0Acycle_11\09  cycle_12\0Acycle_12\09  cycle_11\0Acycle_21\09  dw01 cycle_22 dw02 dw03\0Acycle_22\09  cycle_21 dw01 dw04\00", align 16
@.str = private unnamed_addr constant [2 x i8] c"\0A\00", align 1
@.str.1 = private unnamed_addr constant [3 x i8] c" \09\00", align 1
@.str.2 = private unnamed_addr constant [16 x i8] c"Compile order:\0A\00", align 1
@.str.3 = private unnamed_addr constant [17 x i8] c"   [unorderable]\00", align 1
@.str.4 = private unnamed_addr constant [4 x i8] c"%d:\00", align 1
@.str.5 = private unnamed_addr constant [4 x i8] c" %s\00", align 1
@llvm.used = appending global [1 x i8*] [i8* bitcast (i32 ()* @__main_void to i8*)], section "llvm.metadata"

@__main_void = alias i32 (), i32 ()* @main

; Function Attrs: noinline nounwind optnone
define hidden i32 @get_item(%struct.item_t** %list, i32* %len, i8* %name) #0 {
entry:
  %retval = alloca i32, align 4
  %list.addr = alloca %struct.item_t**, align 4
  %len.addr = alloca i32*, align 4
  %name.addr = alloca i8*, align 4
  %i = alloca i32, align 4
  %lst = alloca %struct.item_t*, align 4
  store %struct.item_t** %list, %struct.item_t*** %list.addr, align 4
  store i32* %len, i32** %len.addr, align 4
  store i8* %name, i8** %name.addr, align 4
  %0 = load %struct.item_t**, %struct.item_t*** %list.addr, align 4
  %1 = load %struct.item_t*, %struct.item_t** %0, align 4
  store %struct.item_t* %1, %struct.item_t** %lst, align 4
  store i32 0, i32* %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %2 = load i32, i32* %i, align 4
  %3 = load i32*, i32** %len.addr, align 4
  %4 = load i32, i32* %3, align 4
  %cmp = icmp slt i32 %2, %4
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %5 = load %struct.item_t*, %struct.item_t** %lst, align 4
  %6 = load i32, i32* %i, align 4
  %arrayidx = getelementptr inbounds %struct.item_t, %struct.item_t* %5, i32 %6
  %name1 = getelementptr inbounds %struct.item_t, %struct.item_t* %arrayidx, i32 0, i32 0
  %7 = load i8*, i8** %name1, align 4
  %8 = load i8*, i8** %name.addr, align 4
  %call = call i32 @strcmp(i8* %7, i8* %8) #4
  %tobool = icmp ne i32 %call, 0
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %for.body
  %9 = load i32, i32* %i, align 4
  store i32 %9, i32* %retval, align 4
  br label %return

if.end:                                           ; preds = %for.body
  br label %for.inc

for.inc:                                          ; preds = %if.end
  %10 = load i32, i32* %i, align 4
  %inc = add nsw i32 %10, 1
  store i32 %inc, i32* %i, align 4
  br label %for.cond

for.end:                                          ; preds = %for.cond
  %11 = load %struct.item_t*, %struct.item_t** %lst, align 4
  %12 = bitcast %struct.item_t* %11 to i8*
  %13 = load i32*, i32** %len.addr, align 4
  %14 = load i32, i32* %13, align 4
  %inc2 = add nsw i32 %14, 1
  store i32 %inc2, i32* %13, align 4
  %mul = mul i32 %inc2, 20
  %call3 = call i8* @realloc(i8* %12, i32 %mul)
  %15 = bitcast i8* %call3 to %struct.item_t*
  %16 = load %struct.item_t**, %struct.item_t*** %list.addr, align 4
  store %struct.item_t* %15, %struct.item_t** %16, align 4
  store %struct.item_t* %15, %struct.item_t** %lst, align 4
  %17 = load i32*, i32** %len.addr, align 4
  %18 = load i32, i32* %17, align 4
  %sub = sub nsw i32 %18, 1
  store i32 %sub, i32* %i, align 4
  %19 = load %struct.item_t*, %struct.item_t** %lst, align 4
  %20 = load i32, i32* %i, align 4
  %add.ptr = getelementptr inbounds %struct.item_t, %struct.item_t* %19, i32 %20
  %21 = bitcast %struct.item_t* %add.ptr to i8*
  call void @llvm.memset.p0i8.i32(i8* align 4 %21, i8 0, i32 20, i1 false)
  %22 = load i32, i32* %i, align 4
  %23 = load %struct.item_t*, %struct.item_t** %lst, align 4
  %24 = load i32, i32* %i, align 4
  %arrayidx4 = getelementptr inbounds %struct.item_t, %struct.item_t* %23, i32 %24
  %idx = getelementptr inbounds %struct.item_t, %struct.item_t* %arrayidx4, i32 0, i32 3
  store i32 %22, i32* %idx, align 4
  %25 = load i8*, i8** %name.addr, align 4
  %26 = load %struct.item_t*, %struct.item_t** %lst, align 4
  %27 = load i32, i32* %i, align 4
  %arrayidx5 = getelementptr inbounds %struct.item_t, %struct.item_t* %26, i32 %27
  %name6 = getelementptr inbounds %struct.item_t, %struct.item_t* %arrayidx5, i32 0, i32 0
  store i8* %25, i8** %name6, align 4
  %28 = load i32, i32* %i, align 4
  store i32 %28, i32* %retval, align 4
  br label %return

return:                                           ; preds = %for.end, %if.then
  %29 = load i32, i32* %retval, align 4
  ret i32 %29
}

; Function Attrs: nounwind readonly
declare i32 @strcmp(i8* %0, i8* %1) #1

declare i8* @realloc(i8* %0, i32 %1) #2

; Function Attrs: argmemonly nounwind willreturn writeonly
declare void @llvm.memset.p0i8.i32(i8* nocapture writeonly %0, i8 %1, i32 %2, i1 immarg %3) #3

; Function Attrs: noinline nounwind optnone
define hidden void @add_dep(%struct.item_t* %it, i32 %i) #0 {
entry:
  %it.addr = alloca %struct.item_t*, align 4
  %i.addr = alloca i32, align 4
  store %struct.item_t* %it, %struct.item_t** %it.addr, align 4
  store i32 %i, i32* %i.addr, align 4
  %0 = load %struct.item_t*, %struct.item_t** %it.addr, align 4
  %idx = getelementptr inbounds %struct.item_t, %struct.item_t* %0, i32 0, i32 3
  %1 = load i32, i32* %idx, align 4
  %2 = load i32, i32* %i.addr, align 4
  %cmp = icmp eq i32 %1, %2
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  br label %return

if.end:                                           ; preds = %entry
  %3 = load %struct.item_t*, %struct.item_t** %it.addr, align 4
  %deps = getelementptr inbounds %struct.item_t, %struct.item_t* %3, i32 0, i32 1
  %4 = load i32*, i32** %deps, align 4
  %5 = bitcast i32* %4 to i8*
  %6 = load %struct.item_t*, %struct.item_t** %it.addr, align 4
  %n_deps = getelementptr inbounds %struct.item_t, %struct.item_t* %6, i32 0, i32 2
  %7 = load i32, i32* %n_deps, align 4
  %add = add nsw i32 %7, 1
  %mul = mul i32 %add, 4
  %call = call i8* @realloc(i8* %5, i32 %mul)
  %8 = bitcast i8* %call to i32*
  %9 = load %struct.item_t*, %struct.item_t** %it.addr, align 4
  %deps1 = getelementptr inbounds %struct.item_t, %struct.item_t* %9, i32 0, i32 1
  store i32* %8, i32** %deps1, align 4
  %10 = load i32, i32* %i.addr, align 4
  %11 = load %struct.item_t*, %struct.item_t** %it.addr, align 4
  %deps2 = getelementptr inbounds %struct.item_t, %struct.item_t* %11, i32 0, i32 1
  %12 = load i32*, i32** %deps2, align 4
  %13 = load %struct.item_t*, %struct.item_t** %it.addr, align 4
  %n_deps3 = getelementptr inbounds %struct.item_t, %struct.item_t* %13, i32 0, i32 2
  %14 = load i32, i32* %n_deps3, align 4
  %inc = add nsw i32 %14, 1
  store i32 %inc, i32* %n_deps3, align 4
  %arrayidx = getelementptr inbounds i32, i32* %12, i32 %14
  store i32 %10, i32* %arrayidx, align 4
  br label %return

return:                                           ; preds = %if.end, %if.then
  ret void
}

; Function Attrs: noinline nounwind optnone
define hidden i32 @parse_input(%struct.item_t** %ret) #0 {
entry:
  %ret.addr = alloca %struct.item_t**, align 4
  %n_items = alloca i32, align 4
  %i = alloca i32, align 4
  %parent = alloca i32, align 4
  %idx = alloca i32, align 4
  %list = alloca %struct.item_t*, align 4
  %s = alloca i8*, align 4
  %e = alloca i8*, align 4
  %word = alloca i8*, align 4
  %we = alloca i8*, align 4
  store %struct.item_t** %ret, %struct.item_t*** %ret.addr, align 4
  store i32 0, i32* %n_items, align 4
  store %struct.item_t* null, %struct.item_t** %list, align 4
  store i8* getelementptr inbounds ([583 x i8], [583 x i8]* @input, i32 0, i32 0), i8** %s, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc10, %entry
  %0 = load i8*, i8** %s, align 4
  %call = call i8* @strtok_r(i8* %0, i8* getelementptr inbounds ([2 x i8], [2 x i8]* @.str, i32 0, i32 0), i8** %e)
  store i8* %call, i8** %s, align 4
  %tobool = icmp ne i8* %call, null
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %for.cond
  br label %for.end11

if.end:                                           ; preds = %for.cond
  store i32 0, i32* %i, align 4
  %1 = load i8*, i8** %s, align 4
  store i8* %1, i8** %word, align 4
  br label %for.cond1

for.cond1:                                        ; preds = %for.inc, %if.end
  %2 = load i8*, i8** %word, align 4
  %call2 = call i8* @strtok_r(i8* %2, i8* getelementptr inbounds ([3 x i8], [3 x i8]* @.str.1, i32 0, i32 0), i8** %we)
  store i8* %call2, i8** %word, align 4
  %tobool3 = icmp ne i8* %call2, null
  br i1 %tobool3, label %if.end5, label %if.then4

if.then4:                                         ; preds = %for.cond1
  br label %for.end

if.end5:                                          ; preds = %for.cond1
  %3 = load i8*, i8** %word, align 4
  %call6 = call i32 @get_item(%struct.item_t** %list, i32* %n_items, i8* %3)
  store i32 %call6, i32* %idx, align 4
  %4 = load i32, i32* %i, align 4
  %tobool7 = icmp ne i32 %4, 0
  br i1 %tobool7, label %if.else, label %if.then8

if.then8:                                         ; preds = %if.end5
  %5 = load i32, i32* %idx, align 4
  store i32 %5, i32* %parent, align 4
  br label %if.end9

if.else:                                          ; preds = %if.end5
  %6 = load %struct.item_t*, %struct.item_t** %list, align 4
  %7 = load i32, i32* %parent, align 4
  %add.ptr = getelementptr inbounds %struct.item_t, %struct.item_t* %6, i32 %7
  %8 = load i32, i32* %idx, align 4
  call void @add_dep(%struct.item_t* %add.ptr, i32 %8)
  br label %if.end9

if.end9:                                          ; preds = %if.else, %if.then8
  br label %for.inc

for.inc:                                          ; preds = %if.end9
  %9 = load i32, i32* %i, align 4
  %inc = add nsw i32 %9, 1
  store i32 %inc, i32* %i, align 4
  store i8* null, i8** %word, align 4
  br label %for.cond1

for.end:                                          ; preds = %if.then4
  br label %for.inc10

for.inc10:                                        ; preds = %for.end
  store i8* null, i8** %s, align 4
  br label %for.cond

for.end11:                                        ; preds = %if.then
  %10 = load %struct.item_t*, %struct.item_t** %list, align 4
  %11 = load %struct.item_t**, %struct.item_t*** %ret.addr, align 4
  store %struct.item_t* %10, %struct.item_t** %11, align 4
  %12 = load i32, i32* %n_items, align 4
  ret i32 %12
}

declare i8* @strtok_r(i8* %0, i8* %1, i8** %2) #2

; Function Attrs: noinline nounwind optnone
define hidden i32 @get_depth(%struct.item_t* %list, i32 %idx, i32 %bad) #0 {
entry:
  %retval = alloca i32, align 4
  %list.addr = alloca %struct.item_t*, align 4
  %idx.addr = alloca i32, align 4
  %bad.addr = alloca i32, align 4
  %max = alloca i32, align 4
  %i = alloca i32, align 4
  %t = alloca i32, align 4
  store %struct.item_t* %list, %struct.item_t** %list.addr, align 4
  store i32 %idx, i32* %idx.addr, align 4
  store i32 %bad, i32* %bad.addr, align 4
  %0 = load %struct.item_t*, %struct.item_t** %list.addr, align 4
  %1 = load i32, i32* %idx.addr, align 4
  %arrayidx = getelementptr inbounds %struct.item_t, %struct.item_t* %0, i32 %1
  %deps = getelementptr inbounds %struct.item_t, %struct.item_t* %arrayidx, i32 0, i32 1
  %2 = load i32*, i32** %deps, align 4
  %tobool = icmp ne i32* %2, null
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  %3 = load %struct.item_t*, %struct.item_t** %list.addr, align 4
  %4 = load i32, i32* %idx.addr, align 4
  %arrayidx1 = getelementptr inbounds %struct.item_t, %struct.item_t* %3, i32 %4
  %depth = getelementptr inbounds %struct.item_t, %struct.item_t* %arrayidx1, i32 0, i32 4
  store i32 1, i32* %depth, align 4
  store i32 1, i32* %retval, align 4
  br label %return

if.end:                                           ; preds = %entry
  %5 = load %struct.item_t*, %struct.item_t** %list.addr, align 4
  %6 = load i32, i32* %idx.addr, align 4
  %arrayidx2 = getelementptr inbounds %struct.item_t, %struct.item_t* %5, i32 %6
  %depth3 = getelementptr inbounds %struct.item_t, %struct.item_t* %arrayidx2, i32 0, i32 4
  %7 = load i32, i32* %depth3, align 4
  store i32 %7, i32* %t, align 4
  %cmp = icmp slt i32 %7, 0
  br i1 %cmp, label %if.then4, label %if.end5

if.then4:                                         ; preds = %if.end
  %8 = load i32, i32* %t, align 4
  store i32 %8, i32* %retval, align 4
  br label %return

if.end5:                                          ; preds = %if.end
  %9 = load i32, i32* %bad.addr, align 4
  %10 = load %struct.item_t*, %struct.item_t** %list.addr, align 4
  %11 = load i32, i32* %idx.addr, align 4
  %arrayidx6 = getelementptr inbounds %struct.item_t, %struct.item_t* %10, i32 %11
  %depth7 = getelementptr inbounds %struct.item_t, %struct.item_t* %arrayidx6, i32 0, i32 4
  store i32 %9, i32* %depth7, align 4
  store i32 0, i32* %i, align 4
  store i32 0, i32* %max, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.end5
  %12 = load i32, i32* %i, align 4
  %13 = load %struct.item_t*, %struct.item_t** %list.addr, align 4
  %14 = load i32, i32* %idx.addr, align 4
  %arrayidx8 = getelementptr inbounds %struct.item_t, %struct.item_t* %13, i32 %14
  %n_deps = getelementptr inbounds %struct.item_t, %struct.item_t* %arrayidx8, i32 0, i32 2
  %15 = load i32, i32* %n_deps, align 4
  %cmp9 = icmp slt i32 %12, %15
  br i1 %cmp9, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %16 = load %struct.item_t*, %struct.item_t** %list.addr, align 4
  %17 = load %struct.item_t*, %struct.item_t** %list.addr, align 4
  %18 = load i32, i32* %idx.addr, align 4
  %arrayidx10 = getelementptr inbounds %struct.item_t, %struct.item_t* %17, i32 %18
  %deps11 = getelementptr inbounds %struct.item_t, %struct.item_t* %arrayidx10, i32 0, i32 1
  %19 = load i32*, i32** %deps11, align 4
  %20 = load i32, i32* %i, align 4
  %arrayidx12 = getelementptr inbounds i32, i32* %19, i32 %20
  %21 = load i32, i32* %arrayidx12, align 4
  %22 = load i32, i32* %bad.addr, align 4
  %call = call i32 @get_depth(%struct.item_t* %16, i32 %21, i32 %22)
  store i32 %call, i32* %t, align 4
  %cmp13 = icmp slt i32 %call, 0
  br i1 %cmp13, label %if.then14, label %if.end15

if.then14:                                        ; preds = %for.body
  %23 = load i32, i32* %t, align 4
  store i32 %23, i32* %max, align 4
  br label %for.end

if.end15:                                         ; preds = %for.body
  %24 = load i32, i32* %max, align 4
  %25 = load i32, i32* %t, align 4
  %add = add nsw i32 %25, 1
  %cmp16 = icmp slt i32 %24, %add
  br i1 %cmp16, label %if.then17, label %if.end19

if.then17:                                        ; preds = %if.end15
  %26 = load i32, i32* %t, align 4
  %add18 = add nsw i32 %26, 1
  store i32 %add18, i32* %max, align 4
  br label %if.end19

if.end19:                                         ; preds = %if.then17, %if.end15
  br label %for.inc

for.inc:                                          ; preds = %if.end19
  %27 = load i32, i32* %i, align 4
  %inc = add nsw i32 %27, 1
  store i32 %inc, i32* %i, align 4
  br label %for.cond

for.end:                                          ; preds = %if.then14, %for.cond
  %28 = load i32, i32* %max, align 4
  %29 = load %struct.item_t*, %struct.item_t** %list.addr, align 4
  %30 = load i32, i32* %idx.addr, align 4
  %arrayidx20 = getelementptr inbounds %struct.item_t, %struct.item_t* %29, i32 %30
  %depth21 = getelementptr inbounds %struct.item_t, %struct.item_t* %arrayidx20, i32 0, i32 4
  store i32 %28, i32* %depth21, align 4
  store i32 %28, i32* %retval, align 4
  br label %return

return:                                           ; preds = %for.end, %if.then4, %if.then
  %31 = load i32, i32* %retval, align 4
  ret i32 %31
}

; Function Attrs: noinline nounwind optnone
define hidden i32 @main() #0 {
entry:
  %retval = alloca i32, align 4
  %i = alloca i32, align 4
  %j = alloca i32, align 4
  %n = alloca i32, align 4
  %bad = alloca i32, align 4
  %max = alloca i32, align 4
  %min = alloca i32, align 4
  %items = alloca %struct.item_t*, align 4
  store i32 0, i32* %retval, align 4
  store i32 -1, i32* %bad, align 4
  %call = call i32 @parse_input(%struct.item_t** %items)
  store i32 %call, i32* %n, align 4
  store i32 0, i32* %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %0 = load i32, i32* %i, align 4
  %1 = load i32, i32* %n, align 4
  %cmp = icmp slt i32 %0, %1
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %2 = load %struct.item_t*, %struct.item_t** %items, align 4
  %3 = load i32, i32* %i, align 4
  %arrayidx = getelementptr inbounds %struct.item_t, %struct.item_t* %2, i32 %3
  %depth = getelementptr inbounds %struct.item_t, %struct.item_t* %arrayidx, i32 0, i32 4
  %4 = load i32, i32* %depth, align 4
  %tobool = icmp ne i32 %4, 0
  br i1 %tobool, label %if.end, label %land.lhs.true

land.lhs.true:                                    ; preds = %for.body
  %5 = load %struct.item_t*, %struct.item_t** %items, align 4
  %6 = load i32, i32* %i, align 4
  %7 = load i32, i32* %bad, align 4
  %call1 = call i32 @get_depth(%struct.item_t* %5, i32 %6, i32 %7)
  %cmp2 = icmp slt i32 %call1, 0
  br i1 %cmp2, label %if.then, label %if.end

if.then:                                          ; preds = %land.lhs.true
  %8 = load i32, i32* %bad, align 4
  %dec = add nsw i32 %8, -1
  store i32 %dec, i32* %bad, align 4
  br label %if.end

if.end:                                           ; preds = %if.then, %land.lhs.true, %for.body
  br label %for.inc

for.inc:                                          ; preds = %if.end
  %9 = load i32, i32* %i, align 4
  %inc = add nsw i32 %9, 1
  store i32 %inc, i32* %i, align 4
  br label %for.cond

for.end:                                          ; preds = %for.cond
  store i32 0, i32* %i, align 4
  store i32 0, i32* %min, align 4
  store i32 0, i32* %max, align 4
  br label %for.cond3

for.cond3:                                        ; preds = %for.inc20, %for.end
  %10 = load i32, i32* %i, align 4
  %11 = load i32, i32* %n, align 4
  %cmp4 = icmp slt i32 %10, %11
  br i1 %cmp4, label %for.body5, label %for.end22

for.body5:                                        ; preds = %for.cond3
  %12 = load %struct.item_t*, %struct.item_t** %items, align 4
  %13 = load i32, i32* %i, align 4
  %arrayidx6 = getelementptr inbounds %struct.item_t, %struct.item_t* %12, i32 %13
  %depth7 = getelementptr inbounds %struct.item_t, %struct.item_t* %arrayidx6, i32 0, i32 4
  %14 = load i32, i32* %depth7, align 4
  %15 = load i32, i32* %max, align 4
  %cmp8 = icmp sgt i32 %14, %15
  br i1 %cmp8, label %if.then9, label %if.end12

if.then9:                                         ; preds = %for.body5
  %16 = load %struct.item_t*, %struct.item_t** %items, align 4
  %17 = load i32, i32* %i, align 4
  %arrayidx10 = getelementptr inbounds %struct.item_t, %struct.item_t* %16, i32 %17
  %depth11 = getelementptr inbounds %struct.item_t, %struct.item_t* %arrayidx10, i32 0, i32 4
  %18 = load i32, i32* %depth11, align 4
  store i32 %18, i32* %max, align 4
  br label %if.end12

if.end12:                                         ; preds = %if.then9, %for.body5
  %19 = load %struct.item_t*, %struct.item_t** %items, align 4
  %20 = load i32, i32* %i, align 4
  %arrayidx13 = getelementptr inbounds %struct.item_t, %struct.item_t* %19, i32 %20
  %depth14 = getelementptr inbounds %struct.item_t, %struct.item_t* %arrayidx13, i32 0, i32 4
  %21 = load i32, i32* %depth14, align 4
  %22 = load i32, i32* %min, align 4
  %cmp15 = icmp slt i32 %21, %22
  br i1 %cmp15, label %if.then16, label %if.end19

if.then16:                                        ; preds = %if.end12
  %23 = load %struct.item_t*, %struct.item_t** %items, align 4
  %24 = load i32, i32* %i, align 4
  %arrayidx17 = getelementptr inbounds %struct.item_t, %struct.item_t* %23, i32 %24
  %depth18 = getelementptr inbounds %struct.item_t, %struct.item_t* %arrayidx17, i32 0, i32 4
  %25 = load i32, i32* %depth18, align 4
  store i32 %25, i32* %min, align 4
  br label %if.end19

if.end19:                                         ; preds = %if.then16, %if.end12
  br label %for.inc20

for.inc20:                                        ; preds = %if.end19
  %26 = load i32, i32* %i, align 4
  %inc21 = add nsw i32 %26, 1
  store i32 %inc21, i32* %i, align 4
  br label %for.cond3

for.end22:                                        ; preds = %for.cond3
  %call23 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([16 x i8], [16 x i8]* @.str.2, i32 0, i32 0))
  %27 = load i32, i32* %min, align 4
  store i32 %27, i32* %i, align 4
  br label %for.cond24

for.cond24:                                       ; preds = %for.inc50, %for.end22
  %28 = load i32, i32* %i, align 4
  %29 = load i32, i32* %max, align 4
  %cmp25 = icmp sle i32 %28, %29
  br i1 %cmp25, label %for.body26, label %for.end52

for.body26:                                       ; preds = %for.cond24
  %30 = load i32, i32* %i, align 4
  %tobool27 = icmp ne i32 %30, 0
  br i1 %tobool27, label %if.end29, label %if.then28

if.then28:                                        ; preds = %for.body26
  br label %for.inc50

if.end29:                                         ; preds = %for.body26
  %31 = load i32, i32* %i, align 4
  %cmp30 = icmp slt i32 %31, 0
  br i1 %cmp30, label %if.then31, label %if.else

if.then31:                                        ; preds = %if.end29
  %call32 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([17 x i8], [17 x i8]* @.str.3, i32 0, i32 0))
  br label %if.end34

if.else:                                          ; preds = %if.end29
  %32 = load i32, i32* %i, align 4
  %call33 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([4 x i8], [4 x i8]* @.str.4, i32 0, i32 0), i32 %32)
  br label %if.end34

if.end34:                                         ; preds = %if.else, %if.then31
  store i32 0, i32* %j, align 4
  br label %for.cond35

for.cond35:                                       ; preds = %for.inc47, %if.end34
  %33 = load i32, i32* %j, align 4
  %34 = load i32, i32* %n, align 4
  %cmp36 = icmp slt i32 %33, %34
  br i1 %cmp36, label %lor.end, label %lor.rhs

lor.rhs:                                          ; preds = %for.cond35
  %call37 = call i32 @putchar(i32 10)
  %tobool38 = icmp ne i32 %call37, 0
  %lnot = xor i1 %tobool38, true
  br label %lor.end

lor.end:                                          ; preds = %lor.rhs, %for.cond35
  %35 = phi i1 [ true, %for.cond35 ], [ %lnot, %lor.rhs ]
  br i1 %35, label %for.body39, label %for.end49

for.body39:                                       ; preds = %lor.end
  %36 = load %struct.item_t*, %struct.item_t** %items, align 4
  %37 = load i32, i32* %j, align 4
  %arrayidx40 = getelementptr inbounds %struct.item_t, %struct.item_t* %36, i32 %37
  %depth41 = getelementptr inbounds %struct.item_t, %struct.item_t* %arrayidx40, i32 0, i32 4
  %38 = load i32, i32* %depth41, align 4
  %39 = load i32, i32* %i, align 4
  %cmp42 = icmp eq i32 %38, %39
  br i1 %cmp42, label %if.then43, label %if.end46

if.then43:                                        ; preds = %for.body39
  %40 = load %struct.item_t*, %struct.item_t** %items, align 4
  %41 = load i32, i32* %j, align 4
  %arrayidx44 = getelementptr inbounds %struct.item_t, %struct.item_t* %40, i32 %41
  %name = getelementptr inbounds %struct.item_t, %struct.item_t* %arrayidx44, i32 0, i32 0
  %42 = load i8*, i8** %name, align 4
  %call45 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([4 x i8], [4 x i8]* @.str.5, i32 0, i32 0), i8* %42)
  br label %if.end46

if.end46:                                         ; preds = %if.then43, %for.body39
  br label %for.inc47

for.inc47:                                        ; preds = %if.end46
  %43 = load i32, i32* %j, align 4
  %inc48 = add nsw i32 %43, 1
  store i32 %inc48, i32* %j, align 4
  br label %for.cond35

for.end49:                                        ; preds = %lor.end
  br label %for.inc50

for.inc50:                                        ; preds = %for.end49, %if.then28
  %44 = load i32, i32* %i, align 4
  %inc51 = add nsw i32 %44, 1
  store i32 %inc51, i32* %i, align 4
  br label %for.cond24

for.end52:                                        ; preds = %for.cond24
  ret i32 0
}

declare i32 @printf(i8* %0, ...) #2

declare i32 @putchar(i32 %0) #2

attributes #0 = { noinline nounwind optnone "correctly-rounded-divide-sqrt-fp-math"="false" "disable-tail-calls"="false" "frame-pointer"="none" "less-precise-fpmad"="false" "min-legal-vector-width"="0" "no-infs-fp-math"="false" "no-jump-tables"="false" "no-nans-fp-math"="false" "no-signed-zeros-fp-math"="false" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="generic" "unsafe-fp-math"="false" "use-soft-float"="false" }
attributes #1 = { nounwind readonly "correctly-rounded-divide-sqrt-fp-math"="false" "disable-tail-calls"="false" "frame-pointer"="none" "less-precise-fpmad"="false" "no-infs-fp-math"="false" "no-nans-fp-math"="false" "no-signed-zeros-fp-math"="false" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="generic" "unsafe-fp-math"="false" "use-soft-float"="false" }
attributes #2 = { "correctly-rounded-divide-sqrt-fp-math"="false" "disable-tail-calls"="false" "frame-pointer"="none" "less-precise-fpmad"="false" "no-infs-fp-math"="false" "no-nans-fp-math"="false" "no-signed-zeros-fp-math"="false" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="generic" "unsafe-fp-math"="false" "use-soft-float"="false" }
attributes #3 = { argmemonly nounwind willreturn writeonly }
attributes #4 = { nounwind readonly }

!llvm.module.flags = !{!0}
!llvm.ident = !{!1}

!0 = !{i32 1, !"wchar_size", i32 4}
!1 = !{!"clang version 11.0.0 (https://github.com/Jacarte/llvm-project.git 0f6dea67136cc1e0b3d200eb2bb165628970c44b)"}

; extracted candidates

; *****
; For LLVM instruction:
;  %call = call i32 @parse_input(%struct.item_t** %items)
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %0 = load i32, i32* %i, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %1 = load i32, i32* %n, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %cmp = icmp slt i32 %0, %1
; Looking for a replacement for:
%0:i32 = var
%1:i32 = var
%2:i1 = slt %0, %1
infer %2

; *****
; For LLVM instruction:
;  %3 = load i32, i32* %i, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %4 = load i32, i32* %depth, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %tobool = icmp ne i32 %4, 0
; Looking for a replacement for:
%0:i32 = var
%1:i1 = ne 0:i32, %0
infer %1

; *****
; For LLVM instruction:
;  %6 = load i32, i32* %i, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %7 = load i32, i32* %bad, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %call1 = call i32 @get_depth(%struct.item_t* %5, i32 %6, i32 %7)
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %cmp2 = icmp slt i32 %call1, 0
; Looking for a replacement for:
%0:i32 = var
%1:i1 = slt %0, 0:i32
infer %1

; *****
; For LLVM instruction:
;  %8 = load i32, i32* %bad, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %dec = add nsw i32 %8, -1
; Looking for a replacement for:
%0:i32 = var
%1:i32 = addnsw 4294967295:i32, %0
infer %1

; *****
; For LLVM instruction:
;  %9 = load i32, i32* %i, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %inc = add nsw i32 %9, 1
; Looking for a replacement for:
%0:i32 = var
%1:i32 = addnsw 1:i32, %0
infer %1

; *****
; For LLVM instruction:
;  %10 = load i32, i32* %i, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %11 = load i32, i32* %n, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %cmp4 = icmp slt i32 %10, %11
; Looking for a replacement for:
%0:i32 = var
%1:i32 = var
%2:i1 = slt %0, %1
infer %2

; *****
; For LLVM instruction:
;  %13 = load i32, i32* %i, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %14 = load i32, i32* %depth7, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %15 = load i32, i32* %max, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %cmp8 = icmp sgt i32 %14, %15
; Looking for a replacement for:
%0:i32 = var
%1:i32 = var
%2:i1 = slt %0, %1
infer %2

; *****
; For LLVM instruction:
;  %17 = load i32, i32* %i, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %18 = load i32, i32* %depth11, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %20 = load i32, i32* %i, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %21 = load i32, i32* %depth14, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %22 = load i32, i32* %min, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %cmp15 = icmp slt i32 %21, %22
; Looking for a replacement for:
%0:i32 = var
%1:i32 = var
%2:i1 = slt %0, %1
infer %2

; *****
; For LLVM instruction:
;  %24 = load i32, i32* %i, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %25 = load i32, i32* %depth18, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %26 = load i32, i32* %i, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %inc21 = add nsw i32 %26, 1
; Looking for a replacement for:
%0:i32 = var
%1:i32 = addnsw 1:i32, %0
infer %1

; *****
; For LLVM instruction:
;  %27 = load i32, i32* %min, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %28 = load i32, i32* %i, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %29 = load i32, i32* %max, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %cmp25 = icmp sle i32 %28, %29
; Looking for a replacement for:
%0:i32 = var
%1:i32 = var
%2:i1 = sle %0, %1
infer %2

; *****
; For LLVM instruction:
;  %30 = load i32, i32* %i, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %tobool27 = icmp ne i32 %30, 0
; Looking for a replacement for:
%0:i32 = var
%1:i1 = ne 0:i32, %0
infer %1

; *****
; For LLVM instruction:
;  %31 = load i32, i32* %i, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %cmp30 = icmp slt i32 %31, 0
; Looking for a replacement for:
%0:i32 = var
%1:i1 = slt %0, 0:i32
infer %1

; *****
; For LLVM instruction:
;  %32 = load i32, i32* %i, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %33 = load i32, i32* %j, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %34 = load i32, i32* %n, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %cmp36 = icmp slt i32 %33, %34
; Looking for a replacement for:
%0:i32 = var
%1:i32 = var
%2:i1 = slt %0, %1
infer %2

; *****
; For LLVM instruction:
;  %call37 = call i32 @putchar(i32 10)
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %tobool38 = icmp ne i32 %call37, 0
; Looking for a replacement for:
%0:i32 = var
%1:i1 = ne 0:i32, %0
infer %1

; *****
; For LLVM instruction:
;  %lnot = xor i1 %tobool38, true
; Looking for a replacement for:
%0:i32 = var
%1:i1 = ne 0:i32, %0
%2:i1 = xor 1:i1, %1
infer %2

; *****
; For LLVM instruction:
;  %35 = phi i1 [ true, %for.cond35 ], [ %lnot, %lor.rhs ]
; Looking for a replacement for:
%0:i1 = var
infer %0

; *****
; For LLVM instruction:
;  %37 = load i32, i32* %j, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %38 = load i32, i32* %depth41, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %39 = load i32, i32* %i, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %cmp42 = icmp eq i32 %38, %39
; Looking for a replacement for:
%0:i32 = var
%1:i32 = var
%2:i1 = eq %0, %1
infer %2

; *****
; For LLVM instruction:
;  %41 = load i32, i32* %j, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %43 = load i32, i32* %j, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %inc48 = add nsw i32 %43, 1
; Looking for a replacement for:
%0:i32 = var
%1:i32 = addnsw 1:i32, %0
infer %1

; *****
; For LLVM instruction:
;  %44 = load i32, i32* %i, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %inc51 = add nsw i32 %44, 1
; Looking for a replacement for:
%0:i32 = var
%1:i32 = addnsw 1:i32, %0
infer %1
got 2 candidates from LHS

-------------------------------------------------
%0:i32 = var
%1:i32 = addnsw 4294967295:i32, %0
infer %1


--------------------------------
guess 0

%0:i32 = var ; reservedconst_1

Cost = 0
first query is SAT, returning the model:
reservedconst_1: -1
0 th attempt: second query is SAT-- constant doesn't work
first query is SAT, returning the model:
reservedconst_1: 536870911
1 th attempt: second query is SAT-- constant doesn't work
first query is UNSAT-- no more guesses

--------------------------------
guess 1

%0:i32 = var

Cost = 0
second query is SAT-- constant doesn't work
Dataflow Pruned 0/0
There are 2 Guesses
There are 0 RHSs before deduplication
There are 0 RHSs after deduplication
got 3 candidates from LHS

-------------------------------------------------
%0:i32 = var
%1:i32 = var
%2:i1 = sle %0, %1
infer %2


--------------------------------
guess 0

%0:i1 = var ; reservedconst_1

Cost = 0
first query is SAT, returning the model:
reservedconst_1: -1
0 th attempt: second query is SAT-- constant doesn't work
first query is SAT, returning the model:
reservedconst_1: 0
1 th attempt: second query is SAT-- constant doesn't work
first query is UNSAT-- no more guesses
Dataflow Pruned 0/0
There are 1 Guesses
There are 0 RHSs before deduplication
There are 0 RHSs after deduplication
got 3 candidates from LHS

-------------------------------------------------
%0:i32 = var
%1:i1 = ne 0:i32, %0
%2:i1 = xor 1:i1, %1
infer %2


--------------------------------
guess 0

%0:i1 = var ; reservedconst_1

Cost = 0
first query is SAT, returning the model:
reservedconst_1: -1
0 th attempt: second query is SAT-- constant doesn't work
first query is SAT, returning the model:
reservedconst_1: 0
1 th attempt: second query is SAT-- constant doesn't work
first query is UNSAT-- no more guesses

--------------------------------
guess 1

%0:i32 = var
%1:i1 = ne 0:i32, %0

Cost = 1
second query is SAT-- constant doesn't work
Dataflow Pruned 0/0
There are 2 Guesses
There are 0 RHSs before deduplication
There are 0 RHSs after deduplication
got 1 candidates from LHS

-------------------------------------------------
%0:i1 = var
infer %0


--------------------------------
guess 0

%0:i1 = var ; reservedconst_1

Cost = 0
first query is SAT, returning the model:
reservedconst_1: 0
0 th attempt: second query is SAT-- constant doesn't work
first query is SAT, returning the model:
reservedconst_1: -1
1 th attempt: second query is SAT-- constant doesn't work
first query is UNSAT-- no more guesses
Dataflow Pruned 0/0
There are 1 Guesses
There are 0 RHSs before deduplication
There are 0 RHSs after deduplication
#########################################################
; exiting Souper's runOnFunction() for main()
Total of 0 replacements done on this module
Total of 0 replacements candidates on this module
