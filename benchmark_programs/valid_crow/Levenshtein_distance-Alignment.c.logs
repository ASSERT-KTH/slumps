
Entering the Souper pass's runOnModule()


; entering Souper's runOnFunction() for leven()

; ModuleID = './Levenshtein_distance-Alignment.c.bc'
source_filename = "./Levenshtein_distance-Alignment.c"
target datalayout = "e-m:e-p:32:32-i64:64-n32:64-S128"
target triple = "wasm32-unknown-wasi"

%struct.edit_s = type { i8, i8, i32, %struct.edit_s* }

@.str = private unnamed_addr constant [20 x i8] c"%s -> %s: %d edits\0A\00", align 1
@.str.1 = private unnamed_addr constant [3 x i8] c"%c\00", align 1
@.str.2 = private unnamed_addr constant [14 x i8] c"raisethysword\00", align 1
@.str.3 = private unnamed_addr constant [12 x i8] c"rosettacode\00", align 1
@llvm.used = appending global [1 x i8*] [i8* bitcast (i32 ()* @__main_void to i8*)], section "llvm.metadata"

@__main_void = alias i32 (), i32 ()* @main

; Function Attrs: noinline nounwind optnone
define hidden void @leven(i8* %a, i8* %b) #0 {
entry:
  %a.addr = alloca i8*, align 4
  %b.addr = alloca i8*, align 4
  %i = alloca i32, align 4
  %j = alloca i32, align 4
  %la = alloca i32, align 4
  %lb = alloca i32, align 4
  %tbl = alloca %struct.edit_s**, align 4
  %aa = alloca i8*, align 4
  %bb = alloca i8*, align 4
  %e = alloca %struct.edit_s*, align 4
  %repl = alloca %struct.edit_s*, align 4
  %dela = alloca %struct.edit_s*, align 4
  %delb = alloca %struct.edit_s*, align 4
  %p = alloca %struct.edit_s*, align 4
  store i8* %a, i8** %a.addr, align 4
  store i8* %b, i8** %b.addr, align 4
  %0 = load i8*, i8** %a.addr, align 4
  %call = call i32 @strlen(i8* %0) #3
  store i32 %call, i32* %la, align 4
  %1 = load i8*, i8** %b.addr, align 4
  %call1 = call i32 @strlen(i8* %1) #3
  store i32 %call1, i32* %lb, align 4
  %2 = load i32, i32* %la, align 4
  %add = add nsw i32 1, %2
  %mul = mul i32 4, %add
  %call2 = call noalias i8* @malloc(i32 %mul)
  %3 = bitcast i8* %call2 to %struct.edit_s**
  store %struct.edit_s** %3, %struct.edit_s*** %tbl, align 4
  %4 = load i32, i32* %la, align 4
  %add3 = add nsw i32 1, %4
  %5 = load i32, i32* %lb, align 4
  %add4 = add nsw i32 1, %5
  %mul5 = mul nsw i32 %add3, %add4
  %call6 = call noalias i8* @calloc(i32 %mul5, i32 12)
  %6 = bitcast i8* %call6 to %struct.edit_s*
  %7 = load %struct.edit_s**, %struct.edit_s*** %tbl, align 4
  %arrayidx = getelementptr inbounds %struct.edit_s*, %struct.edit_s** %7, i32 0
  store %struct.edit_s* %6, %struct.edit_s** %arrayidx, align 4
  store i32 1, i32* %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %8 = load i32, i32* %i, align 4
  %9 = load i32, i32* %la, align 4
  %cmp = icmp sle i32 %8, %9
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %10 = load %struct.edit_s**, %struct.edit_s*** %tbl, align 4
  %11 = load i32, i32* %i, align 4
  %sub = sub nsw i32 %11, 1
  %arrayidx7 = getelementptr inbounds %struct.edit_s*, %struct.edit_s** %10, i32 %sub
  %12 = load %struct.edit_s*, %struct.edit_s** %arrayidx7, align 4
  %13 = load i32, i32* %lb, align 4
  %add8 = add nsw i32 1, %13
  %add.ptr = getelementptr inbounds %struct.edit_s, %struct.edit_s* %12, i32 %add8
  %14 = load %struct.edit_s**, %struct.edit_s*** %tbl, align 4
  %15 = load i32, i32* %i, align 4
  %arrayidx9 = getelementptr inbounds %struct.edit_s*, %struct.edit_s** %14, i32 %15
  store %struct.edit_s* %add.ptr, %struct.edit_s** %arrayidx9, align 4
  br label %for.inc

for.inc:                                          ; preds = %for.body
  %16 = load i32, i32* %i, align 4
  %inc = add nsw i32 %16, 1
  store i32 %inc, i32* %i, align 4
  br label %for.cond

for.end:                                          ; preds = %for.cond
  %17 = load i32, i32* %la, align 4
  store i32 %17, i32* %i, align 4
  br label %for.cond10

for.cond10:                                       ; preds = %for.inc79, %for.end
  %18 = load i32, i32* %i, align 4
  %cmp11 = icmp sge i32 %18, 0
  br i1 %cmp11, label %for.body12, label %for.end81

for.body12:                                       ; preds = %for.cond10
  %19 = load i8*, i8** %a.addr, align 4
  %20 = load i32, i32* %i, align 4
  %add.ptr13 = getelementptr inbounds i8, i8* %19, i32 %20
  store i8* %add.ptr13, i8** %aa, align 4
  %21 = load i32, i32* %lb, align 4
  store i32 %21, i32* %j, align 4
  br label %for.cond14

for.cond14:                                       ; preds = %for.inc77, %for.body12
  %22 = load i32, i32* %j, align 4
  %cmp15 = icmp sge i32 %22, 0
  br i1 %cmp15, label %for.body16, label %for.end78

for.body16:                                       ; preds = %for.cond14
  %23 = load i8*, i8** %b.addr, align 4
  %24 = load i32, i32* %j, align 4
  %add.ptr17 = getelementptr inbounds i8, i8* %23, i32 %24
  store i8* %add.ptr17, i8** %bb, align 4
  %25 = load i8*, i8** %aa, align 4
  %26 = load i8, i8* %25, align 1
  %tobool = icmp ne i8 %26, 0
  br i1 %tobool, label %if.end, label %land.lhs.true

land.lhs.true:                                    ; preds = %for.body16
  %27 = load i8*, i8** %bb, align 4
  %28 = load i8, i8* %27, align 1
  %tobool18 = icmp ne i8 %28, 0
  br i1 %tobool18, label %if.end, label %if.then

if.then:                                          ; preds = %land.lhs.true
  br label %for.inc77

if.end:                                           ; preds = %land.lhs.true, %for.body16
  %29 = load %struct.edit_s**, %struct.edit_s*** %tbl, align 4
  %30 = load i32, i32* %i, align 4
  %arrayidx19 = getelementptr inbounds %struct.edit_s*, %struct.edit_s** %29, i32 %30
  %31 = load %struct.edit_s*, %struct.edit_s** %arrayidx19, align 4
  %32 = load i32, i32* %j, align 4
  %arrayidx20 = getelementptr inbounds %struct.edit_s, %struct.edit_s* %31, i32 %32
  store %struct.edit_s* %arrayidx20, %struct.edit_s** %e, align 4
  %33 = load %struct.edit_s**, %struct.edit_s*** %tbl, align 4
  %34 = load i32, i32* %i, align 4
  %add21 = add nsw i32 %34, 1
  %arrayidx22 = getelementptr inbounds %struct.edit_s*, %struct.edit_s** %33, i32 %add21
  %35 = load %struct.edit_s*, %struct.edit_s** %arrayidx22, align 4
  %36 = load i32, i32* %j, align 4
  %add23 = add nsw i32 %36, 1
  %arrayidx24 = getelementptr inbounds %struct.edit_s, %struct.edit_s* %35, i32 %add23
  store %struct.edit_s* %arrayidx24, %struct.edit_s** %repl, align 4
  %37 = load %struct.edit_s**, %struct.edit_s*** %tbl, align 4
  %38 = load i32, i32* %i, align 4
  %add25 = add nsw i32 %38, 1
  %arrayidx26 = getelementptr inbounds %struct.edit_s*, %struct.edit_s** %37, i32 %add25
  %39 = load %struct.edit_s*, %struct.edit_s** %arrayidx26, align 4
  %40 = load i32, i32* %j, align 4
  %arrayidx27 = getelementptr inbounds %struct.edit_s, %struct.edit_s* %39, i32 %40
  store %struct.edit_s* %arrayidx27, %struct.edit_s** %dela, align 4
  %41 = load %struct.edit_s**, %struct.edit_s*** %tbl, align 4
  %42 = load i32, i32* %i, align 4
  %arrayidx28 = getelementptr inbounds %struct.edit_s*, %struct.edit_s** %41, i32 %42
  %43 = load %struct.edit_s*, %struct.edit_s** %arrayidx28, align 4
  %44 = load i32, i32* %j, align 4
  %add29 = add nsw i32 %44, 1
  %arrayidx30 = getelementptr inbounds %struct.edit_s, %struct.edit_s* %43, i32 %add29
  store %struct.edit_s* %arrayidx30, %struct.edit_s** %delb, align 4
  %45 = load i8*, i8** %aa, align 4
  %46 = load i8, i8* %45, align 1
  %47 = load %struct.edit_s*, %struct.edit_s** %e, align 4
  %c1 = getelementptr inbounds %struct.edit_s, %struct.edit_s* %47, i32 0, i32 0
  store i8 %46, i8* %c1, align 4
  %48 = load i8*, i8** %bb, align 4
  %49 = load i8, i8* %48, align 1
  %50 = load %struct.edit_s*, %struct.edit_s** %e, align 4
  %c2 = getelementptr inbounds %struct.edit_s, %struct.edit_s* %50, i32 0, i32 1
  store i8 %49, i8* %c2, align 1
  %51 = load i8*, i8** %aa, align 4
  %52 = load i8, i8* %51, align 1
  %tobool31 = icmp ne i8 %52, 0
  br i1 %tobool31, label %if.end36, label %if.then32

if.then32:                                        ; preds = %if.end
  %53 = load %struct.edit_s*, %struct.edit_s** %delb, align 4
  %54 = load %struct.edit_s*, %struct.edit_s** %e, align 4
  %next = getelementptr inbounds %struct.edit_s, %struct.edit_s* %54, i32 0, i32 3
  store %struct.edit_s* %53, %struct.edit_s** %next, align 4
  %55 = load %struct.edit_s*, %struct.edit_s** %e, align 4
  %next33 = getelementptr inbounds %struct.edit_s, %struct.edit_s* %55, i32 0, i32 3
  %56 = load %struct.edit_s*, %struct.edit_s** %next33, align 4
  %n = getelementptr inbounds %struct.edit_s, %struct.edit_s* %56, i32 0, i32 2
  %57 = load i32, i32* %n, align 4
  %add34 = add nsw i32 %57, 1
  %58 = load %struct.edit_s*, %struct.edit_s** %e, align 4
  %n35 = getelementptr inbounds %struct.edit_s, %struct.edit_s* %58, i32 0, i32 2
  store i32 %add34, i32* %n35, align 4
  br label %for.inc77

if.end36:                                         ; preds = %if.end
  %59 = load i8*, i8** %bb, align 4
  %60 = load i8, i8* %59, align 1
  %tobool37 = icmp ne i8 %60, 0
  br i1 %tobool37, label %if.end44, label %if.then38

if.then38:                                        ; preds = %if.end36
  %61 = load %struct.edit_s*, %struct.edit_s** %dela, align 4
  %62 = load %struct.edit_s*, %struct.edit_s** %e, align 4
  %next39 = getelementptr inbounds %struct.edit_s, %struct.edit_s* %62, i32 0, i32 3
  store %struct.edit_s* %61, %struct.edit_s** %next39, align 4
  %63 = load %struct.edit_s*, %struct.edit_s** %e, align 4
  %next40 = getelementptr inbounds %struct.edit_s, %struct.edit_s* %63, i32 0, i32 3
  %64 = load %struct.edit_s*, %struct.edit_s** %next40, align 4
  %n41 = getelementptr inbounds %struct.edit_s, %struct.edit_s* %64, i32 0, i32 2
  %65 = load i32, i32* %n41, align 4
  %add42 = add nsw i32 %65, 1
  %66 = load %struct.edit_s*, %struct.edit_s** %e, align 4
  %n43 = getelementptr inbounds %struct.edit_s, %struct.edit_s* %66, i32 0, i32 2
  store i32 %add42, i32* %n43, align 4
  br label %for.inc77

if.end44:                                         ; preds = %if.end36
  %67 = load %struct.edit_s*, %struct.edit_s** %repl, align 4
  %68 = load %struct.edit_s*, %struct.edit_s** %e, align 4
  %next45 = getelementptr inbounds %struct.edit_s, %struct.edit_s* %68, i32 0, i32 3
  store %struct.edit_s* %67, %struct.edit_s** %next45, align 4
  %69 = load i8*, i8** %aa, align 4
  %70 = load i8, i8* %69, align 1
  %conv = sext i8 %70 to i32
  %71 = load i8*, i8** %bb, align 4
  %72 = load i8, i8* %71, align 1
  %conv46 = sext i8 %72 to i32
  %cmp47 = icmp eq i32 %conv, %conv46
  br i1 %cmp47, label %if.then49, label %if.end53

if.then49:                                        ; preds = %if.end44
  %73 = load %struct.edit_s*, %struct.edit_s** %e, align 4
  %next50 = getelementptr inbounds %struct.edit_s, %struct.edit_s* %73, i32 0, i32 3
  %74 = load %struct.edit_s*, %struct.edit_s** %next50, align 4
  %n51 = getelementptr inbounds %struct.edit_s, %struct.edit_s* %74, i32 0, i32 2
  %75 = load i32, i32* %n51, align 4
  %76 = load %struct.edit_s*, %struct.edit_s** %e, align 4
  %n52 = getelementptr inbounds %struct.edit_s, %struct.edit_s* %76, i32 0, i32 2
  store i32 %75, i32* %n52, align 4
  br label %for.inc77

if.end53:                                         ; preds = %if.end44
  %77 = load %struct.edit_s*, %struct.edit_s** %e, align 4
  %next54 = getelementptr inbounds %struct.edit_s, %struct.edit_s* %77, i32 0, i32 3
  %78 = load %struct.edit_s*, %struct.edit_s** %next54, align 4
  %n55 = getelementptr inbounds %struct.edit_s, %struct.edit_s* %78, i32 0, i32 2
  %79 = load i32, i32* %n55, align 4
  %80 = load %struct.edit_s*, %struct.edit_s** %delb, align 4
  %n56 = getelementptr inbounds %struct.edit_s, %struct.edit_s* %80, i32 0, i32 2
  %81 = load i32, i32* %n56, align 4
  %cmp57 = icmp sgt i32 %79, %81
  br i1 %cmp57, label %if.then59, label %if.end62

if.then59:                                        ; preds = %if.end53
  %82 = load %struct.edit_s*, %struct.edit_s** %delb, align 4
  %83 = load %struct.edit_s*, %struct.edit_s** %e, align 4
  %next60 = getelementptr inbounds %struct.edit_s, %struct.edit_s* %83, i32 0, i32 3
  store %struct.edit_s* %82, %struct.edit_s** %next60, align 4
  %84 = load %struct.edit_s*, %struct.edit_s** %e, align 4
  %c161 = getelementptr inbounds %struct.edit_s, %struct.edit_s* %84, i32 0, i32 0
  store i8 0, i8* %c161, align 4
  br label %if.end62

if.end62:                                         ; preds = %if.then59, %if.end53
  %85 = load %struct.edit_s*, %struct.edit_s** %e, align 4
  %next63 = getelementptr inbounds %struct.edit_s, %struct.edit_s* %85, i32 0, i32 3
  %86 = load %struct.edit_s*, %struct.edit_s** %next63, align 4
  %n64 = getelementptr inbounds %struct.edit_s, %struct.edit_s* %86, i32 0, i32 2
  %87 = load i32, i32* %n64, align 4
  %88 = load %struct.edit_s*, %struct.edit_s** %dela, align 4
  %n65 = getelementptr inbounds %struct.edit_s, %struct.edit_s* %88, i32 0, i32 2
  %89 = load i32, i32* %n65, align 4
  %cmp66 = icmp sgt i32 %87, %89
  br i1 %cmp66, label %if.then68, label %if.end72

if.then68:                                        ; preds = %if.end62
  %90 = load %struct.edit_s*, %struct.edit_s** %dela, align 4
  %91 = load %struct.edit_s*, %struct.edit_s** %e, align 4
  %next69 = getelementptr inbounds %struct.edit_s, %struct.edit_s* %91, i32 0, i32 3
  store %struct.edit_s* %90, %struct.edit_s** %next69, align 4
  %92 = load i8*, i8** %aa, align 4
  %93 = load i8, i8* %92, align 1
  %94 = load %struct.edit_s*, %struct.edit_s** %e, align 4
  %c170 = getelementptr inbounds %struct.edit_s, %struct.edit_s* %94, i32 0, i32 0
  store i8 %93, i8* %c170, align 4
  %95 = load %struct.edit_s*, %struct.edit_s** %e, align 4
  %c271 = getelementptr inbounds %struct.edit_s, %struct.edit_s* %95, i32 0, i32 1
  store i8 0, i8* %c271, align 1
  br label %if.end72

if.end72:                                         ; preds = %if.then68, %if.end62
  %96 = load %struct.edit_s*, %struct.edit_s** %e, align 4
  %next73 = getelementptr inbounds %struct.edit_s, %struct.edit_s* %96, i32 0, i32 3
  %97 = load %struct.edit_s*, %struct.edit_s** %next73, align 4
  %n74 = getelementptr inbounds %struct.edit_s, %struct.edit_s* %97, i32 0, i32 2
  %98 = load i32, i32* %n74, align 4
  %add75 = add nsw i32 %98, 1
  %99 = load %struct.edit_s*, %struct.edit_s** %e, align 4
  %n76 = getelementptr inbounds %struct.edit_s, %struct.edit_s* %99, i32 0, i32 2
  store i32 %add75, i32* %n76, align 4
  br label %for.inc77

for.inc77:                                        ; preds = %if.end72, %if.then49, %if.then38, %if.then32, %if.then
  %100 = load i32, i32* %j, align 4
  %dec = add nsw i32 %100, -1
  store i32 %dec, i32* %j, align 4
  br label %for.cond14

for.end78:                                        ; preds = %for.cond14
  br label %for.inc79

for.inc79:                                        ; preds = %for.end78
  %101 = load i32, i32* %i, align 4
  %dec80 = add nsw i32 %101, -1
  store i32 %dec80, i32* %i, align 4
  br label %for.cond10

for.end81:                                        ; preds = %for.cond10
  %102 = load %struct.edit_s**, %struct.edit_s*** %tbl, align 4
  %arrayidx82 = getelementptr inbounds %struct.edit_s*, %struct.edit_s** %102, i32 0
  %103 = load %struct.edit_s*, %struct.edit_s** %arrayidx82, align 4
  store %struct.edit_s* %103, %struct.edit_s** %p, align 4
  %104 = load i8*, i8** %a.addr, align 4
  %105 = load i8*, i8** %b.addr, align 4
  %106 = load %struct.edit_s*, %struct.edit_s** %p, align 4
  %n83 = getelementptr inbounds %struct.edit_s, %struct.edit_s* %106, i32 0, i32 2
  %107 = load i32, i32* %n83, align 4
  %call84 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([20 x i8], [20 x i8]* @.str, i32 0, i32 0), i8* %104, i8* %105, i32 %107)
  br label %while.cond

while.cond:                                       ; preds = %if.end114, %for.end81
  %108 = load %struct.edit_s*, %struct.edit_s** %p, align 4
  %next85 = getelementptr inbounds %struct.edit_s, %struct.edit_s* %108, i32 0, i32 3
  %109 = load %struct.edit_s*, %struct.edit_s** %next85, align 4
  %tobool86 = icmp ne %struct.edit_s* %109, null
  br i1 %tobool86, label %while.body, label %while.end

while.body:                                       ; preds = %while.cond
  %110 = load %struct.edit_s*, %struct.edit_s** %p, align 4
  %c187 = getelementptr inbounds %struct.edit_s, %struct.edit_s* %110, i32 0, i32 0
  %111 = load i8, i8* %c187, align 4
  %conv88 = sext i8 %111 to i32
  %112 = load %struct.edit_s*, %struct.edit_s** %p, align 4
  %c289 = getelementptr inbounds %struct.edit_s, %struct.edit_s* %112, i32 0, i32 1
  %113 = load i8, i8* %c289, align 1
  %conv90 = sext i8 %113 to i32
  %cmp91 = icmp eq i32 %conv88, %conv90
  br i1 %cmp91, label %if.then93, label %if.else

if.then93:                                        ; preds = %while.body
  %114 = load %struct.edit_s*, %struct.edit_s** %p, align 4
  %c194 = getelementptr inbounds %struct.edit_s, %struct.edit_s* %114, i32 0, i32 0
  %115 = load i8, i8* %c194, align 4
  %conv95 = sext i8 %115 to i32
  %call96 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([3 x i8], [3 x i8]* @.str.1, i32 0, i32 0), i32 %conv95)
  br label %if.end114

if.else:                                          ; preds = %while.body
  %call97 = call i32 @putchar(i32 40)
  %116 = load %struct.edit_s*, %struct.edit_s** %p, align 4
  %c198 = getelementptr inbounds %struct.edit_s, %struct.edit_s* %116, i32 0, i32 0
  %117 = load i8, i8* %c198, align 4
  %tobool99 = icmp ne i8 %117, 0
  br i1 %tobool99, label %if.then100, label %if.end104

if.then100:                                       ; preds = %if.else
  %118 = load %struct.edit_s*, %struct.edit_s** %p, align 4
  %c1101 = getelementptr inbounds %struct.edit_s, %struct.edit_s* %118, i32 0, i32 0
  %119 = load i8, i8* %c1101, align 4
  %conv102 = sext i8 %119 to i32
  %call103 = call i32 @putchar(i32 %conv102)
  br label %if.end104

if.end104:                                        ; preds = %if.then100, %if.else
  %call105 = call i32 @putchar(i32 44)
  %120 = load %struct.edit_s*, %struct.edit_s** %p, align 4
  %c2106 = getelementptr inbounds %struct.edit_s, %struct.edit_s* %120, i32 0, i32 1
  %121 = load i8, i8* %c2106, align 1
  %tobool107 = icmp ne i8 %121, 0
  br i1 %tobool107, label %if.then108, label %if.end112

if.then108:                                       ; preds = %if.end104
  %122 = load %struct.edit_s*, %struct.edit_s** %p, align 4
  %c2109 = getelementptr inbounds %struct.edit_s, %struct.edit_s* %122, i32 0, i32 1
  %123 = load i8, i8* %c2109, align 1
  %conv110 = sext i8 %123 to i32
  %call111 = call i32 @putchar(i32 %conv110)
  br label %if.end112

if.end112:                                        ; preds = %if.then108, %if.end104
  %call113 = call i32 @putchar(i32 41)
  br label %if.end114

if.end114:                                        ; preds = %if.end112, %if.then93
  %124 = load %struct.edit_s*, %struct.edit_s** %p, align 4
  %next115 = getelementptr inbounds %struct.edit_s, %struct.edit_s* %124, i32 0, i32 3
  %125 = load %struct.edit_s*, %struct.edit_s** %next115, align 4
  store %struct.edit_s* %125, %struct.edit_s** %p, align 4
  br label %while.cond

while.end:                                        ; preds = %while.cond
  %call116 = call i32 @putchar(i32 10)
  %126 = load %struct.edit_s**, %struct.edit_s*** %tbl, align 4
  %arrayidx117 = getelementptr inbounds %struct.edit_s*, %struct.edit_s** %126, i32 0
  %127 = load %struct.edit_s*, %struct.edit_s** %arrayidx117, align 4
  %128 = bitcast %struct.edit_s* %127 to i8*
  call void @free(i8* %128)
  %129 = load %struct.edit_s**, %struct.edit_s*** %tbl, align 4
  %130 = bitcast %struct.edit_s** %129 to i8*
  call void @free(i8* %130)
  ret void
}

; Function Attrs: nounwind readonly
declare i32 @strlen(i8* %0) #1

declare noalias i8* @malloc(i32 %0) #2

declare noalias i8* @calloc(i32 %0, i32 %1) #2

declare i32 @printf(i8* %0, ...) #2

declare i32 @putchar(i32 %0) #2

declare void @free(i8* %0) #2

; Function Attrs: noinline nounwind optnone
define hidden i32 @main() #0 {
entry:
  %retval = alloca i32, align 4
  store i32 0, i32* %retval, align 4
  call void @leven(i8* getelementptr inbounds ([14 x i8], [14 x i8]* @.str.2, i32 0, i32 0), i8* getelementptr inbounds ([12 x i8], [12 x i8]* @.str.3, i32 0, i32 0))
  ret i32 0
}

attributes #0 = { noinline nounwind optnone "correctly-rounded-divide-sqrt-fp-math"="false" "disable-tail-calls"="false" "frame-pointer"="none" "less-precise-fpmad"="false" "min-legal-vector-width"="0" "no-infs-fp-math"="false" "no-jump-tables"="false" "no-nans-fp-math"="false" "no-signed-zeros-fp-math"="false" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="generic" "unsafe-fp-math"="false" "use-soft-float"="false" }
attributes #1 = { nounwind readonly "correctly-rounded-divide-sqrt-fp-math"="false" "disable-tail-calls"="false" "frame-pointer"="none" "less-precise-fpmad"="false" "no-infs-fp-math"="false" "no-nans-fp-math"="false" "no-signed-zeros-fp-math"="false" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="generic" "unsafe-fp-math"="false" "use-soft-float"="false" }
attributes #2 = { "correctly-rounded-divide-sqrt-fp-math"="false" "disable-tail-calls"="false" "frame-pointer"="none" "less-precise-fpmad"="false" "no-infs-fp-math"="false" "no-nans-fp-math"="false" "no-signed-zeros-fp-math"="false" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="generic" "unsafe-fp-math"="false" "use-soft-float"="false" }
attributes #3 = { nounwind readonly }

!llvm.module.flags = !{!0}
!llvm.ident = !{!1}

!0 = !{i32 1, !"wchar_size", i32 4}
!1 = !{!"clang version 11.0.0 (https://github.com/Jacarte/llvm-project.git 0f6dea67136cc1e0b3d200eb2bb165628970c44b)"}

; extracted candidates

; *****
; For LLVM instruction:
;  %call = call i32 @strlen(i8* %0) #3
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %call1 = call i32 @strlen(i8* %1) #3
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %2 = load i32, i32* %la, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %add = add nsw i32 1, %2
; Looking for a replacement for:
%0:i32 = var
%1:i32 = addnsw 1:i32, %0
infer %1

; *****
; For LLVM instruction:
;  %mul = mul i32 4, %add
; Looking for a replacement for:
%0:i32 = var
%1:i32 = addnsw 1:i32, %0
%2:i32 = mul 4:i32, %1
infer %2

; *****
; For LLVM instruction:
;  %4 = load i32, i32* %la, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %add3 = add nsw i32 1, %4
; Looking for a replacement for:
%0:i32 = var
%1:i32 = addnsw 1:i32, %0
infer %1

; *****
; For LLVM instruction:
;  %5 = load i32, i32* %lb, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %add4 = add nsw i32 1, %5
; Looking for a replacement for:
%0:i32 = var
%1:i32 = addnsw 1:i32, %0
infer %1

; *****
; For LLVM instruction:
;  %mul5 = mul nsw i32 %add3, %add4
; Looking for a replacement for:
%0:i32 = var
%1:i32 = addnsw 1:i32, %0
%2:i32 = var
%3:i32 = addnsw 1:i32, %2
%4:i32 = mulnsw %1, %3
infer %4

; *****
; For LLVM instruction:
;  %8 = load i32, i32* %i, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %9 = load i32, i32* %la, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %cmp = icmp sle i32 %8, %9
; Looking for a replacement for:
%0:i32 = var
%1:i32 = var
%2:i1 = sle %0, %1
infer %2

; *****
; For LLVM instruction:
;  %11 = load i32, i32* %i, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %sub = sub nsw i32 %11, 1
; Looking for a replacement for:
%0:i32 = var
%1:i32 = subnsw %0, 1:i32
infer %1

; *****
; For LLVM instruction:
;  %13 = load i32, i32* %lb, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %add8 = add nsw i32 1, %13
; Looking for a replacement for:
%0:i32 = var
%1:i32 = addnsw 1:i32, %0
infer %1

; *****
; For LLVM instruction:
;  %15 = load i32, i32* %i, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %16 = load i32, i32* %i, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %inc = add nsw i32 %16, 1
; Looking for a replacement for:
%0:i32 = var
%1:i32 = addnsw 1:i32, %0
infer %1

; *****
; For LLVM instruction:
;  %17 = load i32, i32* %la, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %18 = load i32, i32* %i, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %cmp11 = icmp sge i32 %18, 0
; Looking for a replacement for:
%0:i32 = var
%1:i1 = sle 0:i32, %0
infer %1

; *****
; For LLVM instruction:
;  %20 = load i32, i32* %i, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %21 = load i32, i32* %lb, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %22 = load i32, i32* %j, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %cmp15 = icmp sge i32 %22, 0
; Looking for a replacement for:
%0:i32 = var
%1:i1 = sle 0:i32, %0
infer %1

; *****
; For LLVM instruction:
;  %24 = load i32, i32* %j, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %26 = load i8, i8* %25, align 1
; Looking for a replacement for:
%0:i8 = var
infer %0

; *****
; For LLVM instruction:
;  %tobool = icmp ne i8 %26, 0
; Looking for a replacement for:
%0:i8 = var
%1:i1 = ne 0:i8, %0
infer %1

; *****
; For LLVM instruction:
;  %28 = load i8, i8* %27, align 1
; Looking for a replacement for:
%0:i8 = var
infer %0

; *****
; For LLVM instruction:
;  %tobool18 = icmp ne i8 %28, 0
; Looking for a replacement for:
%0:i8 = var
%1:i1 = ne 0:i8, %0
infer %1

; *****
; For LLVM instruction:
;  %30 = load i32, i32* %i, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %32 = load i32, i32* %j, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %34 = load i32, i32* %i, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %add21 = add nsw i32 %34, 1
; Looking for a replacement for:
%0:i32 = var
%1:i32 = addnsw 1:i32, %0
infer %1

; *****
; For LLVM instruction:
;  %36 = load i32, i32* %j, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %add23 = add nsw i32 %36, 1
; Looking for a replacement for:
%0:i32 = var
%1:i32 = addnsw 1:i32, %0
infer %1

; *****
; For LLVM instruction:
;  %38 = load i32, i32* %i, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %add25 = add nsw i32 %38, 1
; Looking for a replacement for:
%0:i32 = var
%1:i32 = addnsw 1:i32, %0
infer %1

; *****
; For LLVM instruction:
;  %40 = load i32, i32* %j, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %42 = load i32, i32* %i, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %44 = load i32, i32* %j, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %add29 = add nsw i32 %44, 1
; Looking for a replacement for:
%0:i32 = var
%1:i32 = addnsw 1:i32, %0
infer %1

; *****
; For LLVM instruction:
;  %46 = load i8, i8* %45, align 1
; Looking for a replacement for:
%0:i8 = var
infer %0

; *****
; For LLVM instruction:
;  %49 = load i8, i8* %48, align 1
; Looking for a replacement for:
%0:i8 = var
infer %0

; *****
; For LLVM instruction:
;  %52 = load i8, i8* %51, align 1
; Looking for a replacement for:
%0:i8 = var
infer %0

; *****
; For LLVM instruction:
;  %tobool31 = icmp ne i8 %52, 0
; Looking for a replacement for:
%0:i8 = var
%1:i1 = ne 0:i8, %0
infer %1

; *****
; For LLVM instruction:
;  %57 = load i32, i32* %n, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %add34 = add nsw i32 %57, 1
; Looking for a replacement for:
%0:i32 = var
%1:i32 = addnsw 1:i32, %0
infer %1

; *****
; For LLVM instruction:
;  %60 = load i8, i8* %59, align 1
; Looking for a replacement for:
%0:i8 = var
infer %0

; *****
; For LLVM instruction:
;  %tobool37 = icmp ne i8 %60, 0
; Looking for a replacement for:
%0:i8 = var
%1:i1 = ne 0:i8, %0
infer %1

; *****
; For LLVM instruction:
;  %65 = load i32, i32* %n41, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %add42 = add nsw i32 %65, 1
; Looking for a replacement for:
%0:i32 = var
%1:i32 = addnsw 1:i32, %0
infer %1

; *****
; For LLVM instruction:
;  %70 = load i8, i8* %69, align 1
; Looking for a replacement for:
%0:i8 = var
infer %0

; *****
; For LLVM instruction:
;  %conv = sext i8 %70 to i32
; Looking for a replacement for:
%0:i8 = var
%1:i32 = sext %0
infer %1

; *****
; For LLVM instruction:
;  %72 = load i8, i8* %71, align 1
; Looking for a replacement for:
%0:i8 = var
infer %0

; *****
; For LLVM instruction:
;  %conv46 = sext i8 %72 to i32
; Looking for a replacement for:
%0:i8 = var
%1:i32 = sext %0
infer %1

; *****
; For LLVM instruction:
;  %cmp47 = icmp eq i32 %conv, %conv46
; Looking for a replacement for:
%0:i8 = var
%1:i32 = sext %0
%2:i8 = var
%3:i32 = sext %2
%4:i1 = eq %1, %3
infer %4

; *****
; For LLVM instruction:
;  %75 = load i32, i32* %n51, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %79 = load i32, i32* %n55, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %81 = load i32, i32* %n56, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %cmp57 = icmp sgt i32 %79, %81
; Looking for a replacement for:
%0:i32 = var
%1:i32 = var
%2:i1 = slt %0, %1
infer %2

; *****
; For LLVM instruction:
;  %87 = load i32, i32* %n64, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %89 = load i32, i32* %n65, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %cmp66 = icmp sgt i32 %87, %89
; Looking for a replacement for:
%0:i32 = var
%1:i32 = var
%2:i1 = slt %0, %1
infer %2

; *****
; For LLVM instruction:
;  %93 = load i8, i8* %92, align 1
; Looking for a replacement for:
%0:i8 = var
infer %0

; *****
; For LLVM instruction:
;  %98 = load i32, i32* %n74, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %add75 = add nsw i32 %98, 1
; Looking for a replacement for:
%0:i32 = var
%1:i32 = addnsw 1:i32, %0
infer %1

; *****
; For LLVM instruction:
;  %100 = load i32, i32* %j, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %dec = add nsw i32 %100, -1
; Looking for a replacement for:
%0:i32 = var
%1:i32 = addnsw 4294967295:i32, %0
infer %1

; *****
; For LLVM instruction:
;  %101 = load i32, i32* %i, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %dec80 = add nsw i32 %101, -1
; Looking for a replacement for:
%0:i32 = var
%1:i32 = addnsw 4294967295:i32, %0
infer %1

; *****
; For LLVM instruction:
;  %107 = load i32, i32* %n83, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %tobool86 = icmp ne %struct.edit_s* %109, null
; Looking for a replacement for:
%0:i32 = var
%1:i1 = ne 0:i32, %0
infer %1

; *****
; For LLVM instruction:
;  %111 = load i8, i8* %c187, align 4
; Looking for a replacement for:
%0:i8 = var
infer %0

; *****
; For LLVM instruction:
;  %conv88 = sext i8 %111 to i32
; Looking for a replacement for:
%0:i8 = var
%1:i32 = sext %0
infer %1

; *****
; For LLVM instruction:
;  %113 = load i8, i8* %c289, align 1
; Looking for a replacement for:
%0:i8 = var
infer %0

; *****
; For LLVM instruction:
;  %conv90 = sext i8 %113 to i32
; Looking for a replacement for:
%0:i8 = var
%1:i32 = sext %0
infer %1

; *****
; For LLVM instruction:
;  %cmp91 = icmp eq i32 %conv88, %conv90
; Looking for a replacement for:
%0:i8 = var
%1:i32 = sext %0
%2:i8 = var
%3:i32 = sext %2
%4:i1 = eq %1, %3
infer %4

; *****
; For LLVM instruction:
;  %115 = load i8, i8* %c194, align 4
; Looking for a replacement for:
%0:i8 = var
infer %0

; *****
; For LLVM instruction:
;  %conv95 = sext i8 %115 to i32
; Looking for a replacement for:
%0:i8 = var
%1:i32 = sext %0
infer %1

; *****
; For LLVM instruction:
;  %117 = load i8, i8* %c198, align 4
; Looking for a replacement for:
%0:i8 = var
infer %0

; *****
; For LLVM instruction:
;  %tobool99 = icmp ne i8 %117, 0
; Looking for a replacement for:
%0:i8 = var
%1:i1 = ne 0:i8, %0
infer %1

; *****
; For LLVM instruction:
;  %119 = load i8, i8* %c1101, align 4
; Looking for a replacement for:
%0:i8 = var
infer %0

; *****
; For LLVM instruction:
;  %conv102 = sext i8 %119 to i32
; Looking for a replacement for:
%0:i8 = var
%1:i32 = sext %0
infer %1

; *****
; For LLVM instruction:
;  %121 = load i8, i8* %c2106, align 1
; Looking for a replacement for:
%0:i8 = var
infer %0

; *****
; For LLVM instruction:
;  %tobool107 = icmp ne i8 %121, 0
; Looking for a replacement for:
%0:i8 = var
%1:i1 = ne 0:i8, %0
infer %1

; *****
; For LLVM instruction:
;  %123 = load i8, i8* %c2109, align 1
; Looking for a replacement for:
%0:i8 = var
infer %0

; *****
; For LLVM instruction:
;  %conv110 = sext i8 %123 to i32
; Looking for a replacement for:
%0:i8 = var
%1:i32 = sext %0
infer %1
got 1 candidates from LHS

-------------------------------------------------
%0:i32 = var
infer %0


--------------------------------
guess 0

%0:i32 = var ; reservedconst_1

Cost = 0
first query is SAT, returning the model:
reservedconst_1: 0
0 th attempt: second query is SAT-- constant doesn't work
first query is SAT, returning the model:
reservedconst_1: -1
1 th attempt: second query is SAT-- constant doesn't work
first query is UNSAT-- no more guesses
Dataflow Pruned 0/0
There are 1 Guesses
There are 0 RHSs before deduplication
There are 0 RHSs after deduplication
got 2 candidates from LHS

-------------------------------------------------
%0:i32 = var
%1:i32 = addnsw 1:i32, %0
infer %1


--------------------------------
guess 0

%0:i32 = var ; reservedconst_1

Cost = 0
first query is SAT, returning the model:
reservedconst_1: 1
0 th attempt: second query is SAT-- constant doesn't work
first query is SAT, returning the model:
reservedconst_1: 268435457
1 th attempt: second query is SAT-- constant doesn't work
first query is UNSAT-- no more guesses

--------------------------------
guess 1

%0:i32 = var

Cost = 0
second query is SAT-- constant doesn't work
Dataflow Pruned 0/0
There are 2 Guesses
There are 0 RHSs before deduplication
There are 0 RHSs after deduplication
got 3 candidates from LHS

-------------------------------------------------
%0:i32 = var
%1:i32 = addnsw 1:i32, %0
%2:i32 = mul 4:i32, %1
infer %2


--------------------------------
guess 0

%0:i32 = var ; reservedconst_1

Cost = 0
first query is SAT, returning the model:
reservedconst_1: 4
0 th attempt: second query is SAT-- constant doesn't work
first query is SAT, returning the model:
reservedconst_1: 1073741828
1 th attempt: second query is SAT-- constant doesn't work
first query is UNSAT-- no more guesses

--------------------------------
guess 1

%0:i32 = var

Cost = 0
second query is SAT-- constant doesn't work

--------------------------------
guess 2

%0:i32 = var
%1:i32 = addnsw 1:i32, %0

Cost = 1
second query is SAT-- constant doesn't work
Dataflow Pruned 0/0
There are 3 Guesses
There are 0 RHSs before deduplication
There are 0 RHSs after deduplication
got 5 candidates from LHS

-------------------------------------------------
%0:i32 = var
%1:i32 = addnsw 1:i32, %0
%2:i32 = var
%3:i32 = addnsw 1:i32, %2
%4:i32 = mulnsw %1, %3
infer %4


--------------------------------
guess 0

%0:i32 = var ; reservedconst_1

Cost = 0
first query is SAT, returning the model:
reservedconst_1: 1
ConstantSynthesis: solver returns error on second query

--------------------------------
guess 1

%0:i32 = var

Cost = 0
second query is SAT-- constant doesn't work

--------------------------------
guess 2

%0:i32 = var

Cost = 0
verification query failed!
Dataflow Pruned 0/0
There are 5 Guesses
There are 0 RHSs before deduplication
There are 0 RHSs after deduplication
got 3 candidates from LHS

-------------------------------------------------
%0:i32 = var
%1:i32 = var
%2:i1 = sle %0, %1
infer %2


--------------------------------
guess 0

%0:i1 = var ; reservedconst_1

Cost = 0
first query is SAT, returning the model:
reservedconst_1: -1
0 th attempt: second query is SAT-- constant doesn't work
first query is SAT, returning the model:
reservedconst_1: 0
1 th attempt: second query is SAT-- constant doesn't work
first query is UNSAT-- no more guesses
Dataflow Pruned 0/0
There are 1 Guesses
There are 0 RHSs before deduplication
There are 0 RHSs after deduplication
got 2 candidates from LHS

-------------------------------------------------
%0:i32 = var
%1:i32 = subnsw %0, 1:i32
infer %1


--------------------------------
guess 0

%0:i32 = var ; reservedconst_1

Cost = 0
first query is SAT, returning the model:
reservedconst_1: -1
0 th attempt: second query is SAT-- constant doesn't work
first query is SAT, returning the model:
reservedconst_1: 536870911
1 th attempt: second query is SAT-- constant doesn't work
first query is UNSAT-- no more guesses

--------------------------------
guess 1

%0:i32 = var

Cost = 0
second query is SAT-- constant doesn't work
Dataflow Pruned 0/0
There are 2 Guesses
There are 0 RHSs before deduplication
There are 0 RHSs after deduplication
got 2 candidates from LHS

-------------------------------------------------
%0:i32 = var
%1:i1 = sle 0:i32, %0
infer %1


--------------------------------
guess 0

%0:i1 = var ; reservedconst_1

Cost = 0
first query is SAT, returning the model:
reservedconst_1: -1
0 th attempt: second query is SAT-- constant doesn't work
first query is SAT, returning the model:
reservedconst_1: 0
1 th attempt: second query is SAT-- constant doesn't work
first query is UNSAT-- no more guesses
Dataflow Pruned 0/0
There are 1 Guesses
There are 0 RHSs before deduplication
There are 0 RHSs after deduplication
got 1 candidates from LHS

-------------------------------------------------
%0:i8 = var
infer %0


--------------------------------
guess 0

%0:i8 = var ; reservedconst_1

Cost = 0
first query is SAT, returning the model:
reservedconst_1: 0
0 th attempt: second query is SAT-- constant doesn't work
first query is SAT, returning the model:
reservedconst_1: -1
1 th attempt: second query is SAT-- constant doesn't work
first query is UNSAT-- no more guesses
Dataflow Pruned 0/0
There are 1 Guesses
There are 0 RHSs before deduplication
There are 0 RHSs after deduplication
got 2 candidates from LHS

-------------------------------------------------
%0:i8 = var
%1:i1 = ne 0:i8, %0
infer %1


--------------------------------
guess 0

%0:i1 = var ; reservedconst_1

Cost = 0
first query is SAT, returning the model:
reservedconst_1: 0
0 th attempt: second query is SAT-- constant doesn't work
first query is SAT, returning the model:
reservedconst_1: -1
1 th attempt: second query is SAT-- constant doesn't work
first query is UNSAT-- no more guesses
Dataflow Pruned 0/0
There are 1 Guesses
There are 0 RHSs before deduplication
There are 0 RHSs after deduplication
got 2 candidates from LHS

-------------------------------------------------
%0:i8 = var
%1:i32 = sext %0
infer %1


--------------------------------
guess 0

%0:i32 = var ; reservedconst_1

Cost = 0
first query is SAT, returning the model:
reservedconst_1: 0
0 th attempt: second query is SAT-- constant doesn't work
first query is SAT, returning the model:
reservedconst_1: -1
1 th attempt: second query is SAT-- constant doesn't work
first query is UNSAT-- no more guesses
Dataflow Pruned 0/0
There are 1 Guesses
There are 0 RHSs before deduplication
There are 0 RHSs after deduplication
got 5 candidates from LHS

-------------------------------------------------
%0:i8 = var
%1:i32 = sext %0
%2:i8 = var
%3:i32 = sext %2
%4:i1 = eq %1, %3
infer %4


--------------------------------
guess 0

%0:i1 = var ; reservedconst_1

Cost = 0
first query is SAT, returning the model:
reservedconst_1: -1
0 th attempt: second query is SAT-- constant doesn't work
first query is SAT, returning the model:
reservedconst_1: 0
1 th attempt: second query is SAT-- constant doesn't work
first query is UNSAT-- no more guesses
Dataflow Pruned 0/0
There are 1 Guesses
There are 0 RHSs before deduplication
There are 0 RHSs after deduplication
got 3 candidates from LHS

-------------------------------------------------
%0:i32 = var
%1:i32 = var
%2:i1 = slt %0, %1
infer %2


--------------------------------
guess 0

%0:i1 = var ; reservedconst_1

Cost = 0
first query is SAT, returning the model:
reservedconst_1: 0
0 th attempt: second query is SAT-- constant doesn't work
first query is SAT, returning the model:
reservedconst_1: -1
1 th attempt: second query is SAT-- constant doesn't work
first query is UNSAT-- no more guesses
Dataflow Pruned 0/0
There are 1 Guesses
There are 0 RHSs before deduplication
There are 0 RHSs after deduplication
got 2 candidates from LHS

-------------------------------------------------
%0:i32 = var
%1:i32 = addnsw 4294967295:i32, %0
infer %1


--------------------------------
guess 0

%0:i32 = var ; reservedconst_1

Cost = 0
first query is SAT, returning the model:
reservedconst_1: -1
0 th attempt: second query is SAT-- constant doesn't work
first query is SAT, returning the model:
reservedconst_1: 536870911
1 th attempt: second query is SAT-- constant doesn't work
first query is UNSAT-- no more guesses

--------------------------------
guess 1

%0:i32 = var

Cost = 0
second query is SAT-- constant doesn't work
Dataflow Pruned 0/0
There are 2 Guesses
There are 0 RHSs before deduplication
There are 0 RHSs after deduplication
got 2 candidates from LHS

-------------------------------------------------
%0:i32 = var
%1:i1 = ne 0:i32, %0
infer %1


--------------------------------
guess 0

%0:i1 = var ; reservedconst_1

Cost = 0
first query is SAT, returning the model:
reservedconst_1: 0
0 th attempt: second query is SAT-- constant doesn't work
first query is SAT, returning the model:
reservedconst_1: -1
1 th attempt: second query is SAT-- constant doesn't work
first query is UNSAT-- no more guesses
Dataflow Pruned 0/0
There are 1 Guesses
There are 0 RHSs before deduplication
There are 0 RHSs after deduplication
#########################################################
; exiting Souper's runOnFunction() for leven()

; entering Souper's runOnFunction() for main()

; ModuleID = './Levenshtein_distance-Alignment.c.bc'
source_filename = "./Levenshtein_distance-Alignment.c"
target datalayout = "e-m:e-p:32:32-i64:64-n32:64-S128"
target triple = "wasm32-unknown-wasi"

%struct.edit_s = type { i8, i8, i32, %struct.edit_s* }

@.str = private unnamed_addr constant [20 x i8] c"%s -> %s: %d edits\0A\00", align 1
@.str.1 = private unnamed_addr constant [3 x i8] c"%c\00", align 1
@.str.2 = private unnamed_addr constant [14 x i8] c"raisethysword\00", align 1
@.str.3 = private unnamed_addr constant [12 x i8] c"rosettacode\00", align 1
@llvm.used = appending global [1 x i8*] [i8* bitcast (i32 ()* @__main_void to i8*)], section "llvm.metadata"

@__main_void = alias i32 (), i32 ()* @main

; Function Attrs: noinline nounwind optnone
define hidden void @leven(i8* %a, i8* %b) #0 {
entry:
  %a.addr = alloca i8*, align 4
  %b.addr = alloca i8*, align 4
  %i = alloca i32, align 4
  %j = alloca i32, align 4
  %la = alloca i32, align 4
  %lb = alloca i32, align 4
  %tbl = alloca %struct.edit_s**, align 4
  %aa = alloca i8*, align 4
  %bb = alloca i8*, align 4
  %e = alloca %struct.edit_s*, align 4
  %repl = alloca %struct.edit_s*, align 4
  %dela = alloca %struct.edit_s*, align 4
  %delb = alloca %struct.edit_s*, align 4
  %p = alloca %struct.edit_s*, align 4
  store i8* %a, i8** %a.addr, align 4
  store i8* %b, i8** %b.addr, align 4
  %0 = load i8*, i8** %a.addr, align 4
  %call = call i32 @strlen(i8* %0) #3
  store i32 %call, i32* %la, align 4
  %1 = load i8*, i8** %b.addr, align 4
  %call1 = call i32 @strlen(i8* %1) #3
  store i32 %call1, i32* %lb, align 4
  %2 = load i32, i32* %la, align 4
  %add = add nsw i32 1, %2
  %mul = mul i32 4, %add
  %call2 = call noalias i8* @malloc(i32 %mul)
  %3 = bitcast i8* %call2 to %struct.edit_s**
  store %struct.edit_s** %3, %struct.edit_s*** %tbl, align 4
  %4 = load i32, i32* %la, align 4
  %add3 = add nsw i32 1, %4
  %5 = load i32, i32* %lb, align 4
  %add4 = add nsw i32 1, %5
  %mul5 = mul nsw i32 %add3, %add4
  %call6 = call noalias i8* @calloc(i32 %mul5, i32 12)
  %6 = bitcast i8* %call6 to %struct.edit_s*
  %7 = load %struct.edit_s**, %struct.edit_s*** %tbl, align 4
  %arrayidx = getelementptr inbounds %struct.edit_s*, %struct.edit_s** %7, i32 0
  store %struct.edit_s* %6, %struct.edit_s** %arrayidx, align 4
  store i32 1, i32* %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %8 = load i32, i32* %i, align 4
  %9 = load i32, i32* %la, align 4
  %cmp = icmp sle i32 %8, %9
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %10 = load %struct.edit_s**, %struct.edit_s*** %tbl, align 4
  %11 = load i32, i32* %i, align 4
  %sub = sub nsw i32 %11, 1
  %arrayidx7 = getelementptr inbounds %struct.edit_s*, %struct.edit_s** %10, i32 %sub
  %12 = load %struct.edit_s*, %struct.edit_s** %arrayidx7, align 4
  %13 = load i32, i32* %lb, align 4
  %add8 = add nsw i32 1, %13
  %add.ptr = getelementptr inbounds %struct.edit_s, %struct.edit_s* %12, i32 %add8
  %14 = load %struct.edit_s**, %struct.edit_s*** %tbl, align 4
  %15 = load i32, i32* %i, align 4
  %arrayidx9 = getelementptr inbounds %struct.edit_s*, %struct.edit_s** %14, i32 %15
  store %struct.edit_s* %add.ptr, %struct.edit_s** %arrayidx9, align 4
  br label %for.inc

for.inc:                                          ; preds = %for.body
  %16 = load i32, i32* %i, align 4
  %inc = add nsw i32 %16, 1
  store i32 %inc, i32* %i, align 4
  br label %for.cond

for.end:                                          ; preds = %for.cond
  %17 = load i32, i32* %la, align 4
  store i32 %17, i32* %i, align 4
  br label %for.cond10

for.cond10:                                       ; preds = %for.inc79, %for.end
  %18 = load i32, i32* %i, align 4
  %cmp11 = icmp sge i32 %18, 0
  br i1 %cmp11, label %for.body12, label %for.end81

for.body12:                                       ; preds = %for.cond10
  %19 = load i8*, i8** %a.addr, align 4
  %20 = load i32, i32* %i, align 4
  %add.ptr13 = getelementptr inbounds i8, i8* %19, i32 %20
  store i8* %add.ptr13, i8** %aa, align 4
  %21 = load i32, i32* %lb, align 4
  store i32 %21, i32* %j, align 4
  br label %for.cond14

for.cond14:                                       ; preds = %for.inc77, %for.body12
  %22 = load i32, i32* %j, align 4
  %cmp15 = icmp sge i32 %22, 0
  br i1 %cmp15, label %for.body16, label %for.end78

for.body16:                                       ; preds = %for.cond14
  %23 = load i8*, i8** %b.addr, align 4
  %24 = load i32, i32* %j, align 4
  %add.ptr17 = getelementptr inbounds i8, i8* %23, i32 %24
  store i8* %add.ptr17, i8** %bb, align 4
  %25 = load i8*, i8** %aa, align 4
  %26 = load i8, i8* %25, align 1
  %tobool = icmp ne i8 %26, 0
  br i1 %tobool, label %if.end, label %land.lhs.true

land.lhs.true:                                    ; preds = %for.body16
  %27 = load i8*, i8** %bb, align 4
  %28 = load i8, i8* %27, align 1
  %tobool18 = icmp ne i8 %28, 0
  br i1 %tobool18, label %if.end, label %if.then

if.then:                                          ; preds = %land.lhs.true
  br label %for.inc77

if.end:                                           ; preds = %land.lhs.true, %for.body16
  %29 = load %struct.edit_s**, %struct.edit_s*** %tbl, align 4
  %30 = load i32, i32* %i, align 4
  %arrayidx19 = getelementptr inbounds %struct.edit_s*, %struct.edit_s** %29, i32 %30
  %31 = load %struct.edit_s*, %struct.edit_s** %arrayidx19, align 4
  %32 = load i32, i32* %j, align 4
  %arrayidx20 = getelementptr inbounds %struct.edit_s, %struct.edit_s* %31, i32 %32
  store %struct.edit_s* %arrayidx20, %struct.edit_s** %e, align 4
  %33 = load %struct.edit_s**, %struct.edit_s*** %tbl, align 4
  %34 = load i32, i32* %i, align 4
  %add21 = add nsw i32 %34, 1
  %arrayidx22 = getelementptr inbounds %struct.edit_s*, %struct.edit_s** %33, i32 %add21
  %35 = load %struct.edit_s*, %struct.edit_s** %arrayidx22, align 4
  %36 = load i32, i32* %j, align 4
  %add23 = add nsw i32 %36, 1
  %arrayidx24 = getelementptr inbounds %struct.edit_s, %struct.edit_s* %35, i32 %add23
  store %struct.edit_s* %arrayidx24, %struct.edit_s** %repl, align 4
  %37 = load %struct.edit_s**, %struct.edit_s*** %tbl, align 4
  %38 = load i32, i32* %i, align 4
  %add25 = add nsw i32 %38, 1
  %arrayidx26 = getelementptr inbounds %struct.edit_s*, %struct.edit_s** %37, i32 %add25
  %39 = load %struct.edit_s*, %struct.edit_s** %arrayidx26, align 4
  %40 = load i32, i32* %j, align 4
  %arrayidx27 = getelementptr inbounds %struct.edit_s, %struct.edit_s* %39, i32 %40
  store %struct.edit_s* %arrayidx27, %struct.edit_s** %dela, align 4
  %41 = load %struct.edit_s**, %struct.edit_s*** %tbl, align 4
  %42 = load i32, i32* %i, align 4
  %arrayidx28 = getelementptr inbounds %struct.edit_s*, %struct.edit_s** %41, i32 %42
  %43 = load %struct.edit_s*, %struct.edit_s** %arrayidx28, align 4
  %44 = load i32, i32* %j, align 4
  %add29 = add nsw i32 %44, 1
  %arrayidx30 = getelementptr inbounds %struct.edit_s, %struct.edit_s* %43, i32 %add29
  store %struct.edit_s* %arrayidx30, %struct.edit_s** %delb, align 4
  %45 = load i8*, i8** %aa, align 4
  %46 = load i8, i8* %45, align 1
  %47 = load %struct.edit_s*, %struct.edit_s** %e, align 4
  %c1 = getelementptr inbounds %struct.edit_s, %struct.edit_s* %47, i32 0, i32 0
  store i8 %46, i8* %c1, align 4
  %48 = load i8*, i8** %bb, align 4
  %49 = load i8, i8* %48, align 1
  %50 = load %struct.edit_s*, %struct.edit_s** %e, align 4
  %c2 = getelementptr inbounds %struct.edit_s, %struct.edit_s* %50, i32 0, i32 1
  store i8 %49, i8* %c2, align 1
  %51 = load i8*, i8** %aa, align 4
  %52 = load i8, i8* %51, align 1
  %tobool31 = icmp ne i8 %52, 0
  br i1 %tobool31, label %if.end36, label %if.then32

if.then32:                                        ; preds = %if.end
  %53 = load %struct.edit_s*, %struct.edit_s** %delb, align 4
  %54 = load %struct.edit_s*, %struct.edit_s** %e, align 4
  %next = getelementptr inbounds %struct.edit_s, %struct.edit_s* %54, i32 0, i32 3
  store %struct.edit_s* %53, %struct.edit_s** %next, align 4
  %55 = load %struct.edit_s*, %struct.edit_s** %e, align 4
  %next33 = getelementptr inbounds %struct.edit_s, %struct.edit_s* %55, i32 0, i32 3
  %56 = load %struct.edit_s*, %struct.edit_s** %next33, align 4
  %n = getelementptr inbounds %struct.edit_s, %struct.edit_s* %56, i32 0, i32 2
  %57 = load i32, i32* %n, align 4
  %add34 = add nsw i32 %57, 1
  %58 = load %struct.edit_s*, %struct.edit_s** %e, align 4
  %n35 = getelementptr inbounds %struct.edit_s, %struct.edit_s* %58, i32 0, i32 2
  store i32 %add34, i32* %n35, align 4
  br label %for.inc77

if.end36:                                         ; preds = %if.end
  %59 = load i8*, i8** %bb, align 4
  %60 = load i8, i8* %59, align 1
  %tobool37 = icmp ne i8 %60, 0
  br i1 %tobool37, label %if.end44, label %if.then38

if.then38:                                        ; preds = %if.end36
  %61 = load %struct.edit_s*, %struct.edit_s** %dela, align 4
  %62 = load %struct.edit_s*, %struct.edit_s** %e, align 4
  %next39 = getelementptr inbounds %struct.edit_s, %struct.edit_s* %62, i32 0, i32 3
  store %struct.edit_s* %61, %struct.edit_s** %next39, align 4
  %63 = load %struct.edit_s*, %struct.edit_s** %e, align 4
  %next40 = getelementptr inbounds %struct.edit_s, %struct.edit_s* %63, i32 0, i32 3
  %64 = load %struct.edit_s*, %struct.edit_s** %next40, align 4
  %n41 = getelementptr inbounds %struct.edit_s, %struct.edit_s* %64, i32 0, i32 2
  %65 = load i32, i32* %n41, align 4
  %add42 = add nsw i32 %65, 1
  %66 = load %struct.edit_s*, %struct.edit_s** %e, align 4
  %n43 = getelementptr inbounds %struct.edit_s, %struct.edit_s* %66, i32 0, i32 2
  store i32 %add42, i32* %n43, align 4
  br label %for.inc77

if.end44:                                         ; preds = %if.end36
  %67 = load %struct.edit_s*, %struct.edit_s** %repl, align 4
  %68 = load %struct.edit_s*, %struct.edit_s** %e, align 4
  %next45 = getelementptr inbounds %struct.edit_s, %struct.edit_s* %68, i32 0, i32 3
  store %struct.edit_s* %67, %struct.edit_s** %next45, align 4
  %69 = load i8*, i8** %aa, align 4
  %70 = load i8, i8* %69, align 1
  %conv = sext i8 %70 to i32
  %71 = load i8*, i8** %bb, align 4
  %72 = load i8, i8* %71, align 1
  %conv46 = sext i8 %72 to i32
  %cmp47 = icmp eq i32 %conv, %conv46
  br i1 %cmp47, label %if.then49, label %if.end53

if.then49:                                        ; preds = %if.end44
  %73 = load %struct.edit_s*, %struct.edit_s** %e, align 4
  %next50 = getelementptr inbounds %struct.edit_s, %struct.edit_s* %73, i32 0, i32 3
  %74 = load %struct.edit_s*, %struct.edit_s** %next50, align 4
  %n51 = getelementptr inbounds %struct.edit_s, %struct.edit_s* %74, i32 0, i32 2
  %75 = load i32, i32* %n51, align 4
  %76 = load %struct.edit_s*, %struct.edit_s** %e, align 4
  %n52 = getelementptr inbounds %struct.edit_s, %struct.edit_s* %76, i32 0, i32 2
  store i32 %75, i32* %n52, align 4
  br label %for.inc77

if.end53:                                         ; preds = %if.end44
  %77 = load %struct.edit_s*, %struct.edit_s** %e, align 4
  %next54 = getelementptr inbounds %struct.edit_s, %struct.edit_s* %77, i32 0, i32 3
  %78 = load %struct.edit_s*, %struct.edit_s** %next54, align 4
  %n55 = getelementptr inbounds %struct.edit_s, %struct.edit_s* %78, i32 0, i32 2
  %79 = load i32, i32* %n55, align 4
  %80 = load %struct.edit_s*, %struct.edit_s** %delb, align 4
  %n56 = getelementptr inbounds %struct.edit_s, %struct.edit_s* %80, i32 0, i32 2
  %81 = load i32, i32* %n56, align 4
  %cmp57 = icmp sgt i32 %79, %81
  br i1 %cmp57, label %if.then59, label %if.end62

if.then59:                                        ; preds = %if.end53
  %82 = load %struct.edit_s*, %struct.edit_s** %delb, align 4
  %83 = load %struct.edit_s*, %struct.edit_s** %e, align 4
  %next60 = getelementptr inbounds %struct.edit_s, %struct.edit_s* %83, i32 0, i32 3
  store %struct.edit_s* %82, %struct.edit_s** %next60, align 4
  %84 = load %struct.edit_s*, %struct.edit_s** %e, align 4
  %c161 = getelementptr inbounds %struct.edit_s, %struct.edit_s* %84, i32 0, i32 0
  store i8 0, i8* %c161, align 4
  br label %if.end62

if.end62:                                         ; preds = %if.then59, %if.end53
  %85 = load %struct.edit_s*, %struct.edit_s** %e, align 4
  %next63 = getelementptr inbounds %struct.edit_s, %struct.edit_s* %85, i32 0, i32 3
  %86 = load %struct.edit_s*, %struct.edit_s** %next63, align 4
  %n64 = getelementptr inbounds %struct.edit_s, %struct.edit_s* %86, i32 0, i32 2
  %87 = load i32, i32* %n64, align 4
  %88 = load %struct.edit_s*, %struct.edit_s** %dela, align 4
  %n65 = getelementptr inbounds %struct.edit_s, %struct.edit_s* %88, i32 0, i32 2
  %89 = load i32, i32* %n65, align 4
  %cmp66 = icmp sgt i32 %87, %89
  br i1 %cmp66, label %if.then68, label %if.end72

if.then68:                                        ; preds = %if.end62
  %90 = load %struct.edit_s*, %struct.edit_s** %dela, align 4
  %91 = load %struct.edit_s*, %struct.edit_s** %e, align 4
  %next69 = getelementptr inbounds %struct.edit_s, %struct.edit_s* %91, i32 0, i32 3
  store %struct.edit_s* %90, %struct.edit_s** %next69, align 4
  %92 = load i8*, i8** %aa, align 4
  %93 = load i8, i8* %92, align 1
  %94 = load %struct.edit_s*, %struct.edit_s** %e, align 4
  %c170 = getelementptr inbounds %struct.edit_s, %struct.edit_s* %94, i32 0, i32 0
  store i8 %93, i8* %c170, align 4
  %95 = load %struct.edit_s*, %struct.edit_s** %e, align 4
  %c271 = getelementptr inbounds %struct.edit_s, %struct.edit_s* %95, i32 0, i32 1
  store i8 0, i8* %c271, align 1
  br label %if.end72

if.end72:                                         ; preds = %if.then68, %if.end62
  %96 = load %struct.edit_s*, %struct.edit_s** %e, align 4
  %next73 = getelementptr inbounds %struct.edit_s, %struct.edit_s* %96, i32 0, i32 3
  %97 = load %struct.edit_s*, %struct.edit_s** %next73, align 4
  %n74 = getelementptr inbounds %struct.edit_s, %struct.edit_s* %97, i32 0, i32 2
  %98 = load i32, i32* %n74, align 4
  %add75 = add nsw i32 %98, 1
  %99 = load %struct.edit_s*, %struct.edit_s** %e, align 4
  %n76 = getelementptr inbounds %struct.edit_s, %struct.edit_s* %99, i32 0, i32 2
  store i32 %add75, i32* %n76, align 4
  br label %for.inc77

for.inc77:                                        ; preds = %if.end72, %if.then49, %if.then38, %if.then32, %if.then
  %100 = load i32, i32* %j, align 4
  %dec = add nsw i32 %100, -1
  store i32 %dec, i32* %j, align 4
  br label %for.cond14

for.end78:                                        ; preds = %for.cond14
  br label %for.inc79

for.inc79:                                        ; preds = %for.end78
  %101 = load i32, i32* %i, align 4
  %dec80 = add nsw i32 %101, -1
  store i32 %dec80, i32* %i, align 4
  br label %for.cond10

for.end81:                                        ; preds = %for.cond10
  %102 = load %struct.edit_s**, %struct.edit_s*** %tbl, align 4
  %arrayidx82 = getelementptr inbounds %struct.edit_s*, %struct.edit_s** %102, i32 0
  %103 = load %struct.edit_s*, %struct.edit_s** %arrayidx82, align 4
  store %struct.edit_s* %103, %struct.edit_s** %p, align 4
  %104 = load i8*, i8** %a.addr, align 4
  %105 = load i8*, i8** %b.addr, align 4
  %106 = load %struct.edit_s*, %struct.edit_s** %p, align 4
  %n83 = getelementptr inbounds %struct.edit_s, %struct.edit_s* %106, i32 0, i32 2
  %107 = load i32, i32* %n83, align 4
  %call84 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([20 x i8], [20 x i8]* @.str, i32 0, i32 0), i8* %104, i8* %105, i32 %107)
  br label %while.cond

while.cond:                                       ; preds = %if.end114, %for.end81
  %108 = load %struct.edit_s*, %struct.edit_s** %p, align 4
  %next85 = getelementptr inbounds %struct.edit_s, %struct.edit_s* %108, i32 0, i32 3
  %109 = load %struct.edit_s*, %struct.edit_s** %next85, align 4
  %tobool86 = icmp ne %struct.edit_s* %109, null
  br i1 %tobool86, label %while.body, label %while.end

while.body:                                       ; preds = %while.cond
  %110 = load %struct.edit_s*, %struct.edit_s** %p, align 4
  %c187 = getelementptr inbounds %struct.edit_s, %struct.edit_s* %110, i32 0, i32 0
  %111 = load i8, i8* %c187, align 4
  %conv88 = sext i8 %111 to i32
  %112 = load %struct.edit_s*, %struct.edit_s** %p, align 4
  %c289 = getelementptr inbounds %struct.edit_s, %struct.edit_s* %112, i32 0, i32 1
  %113 = load i8, i8* %c289, align 1
  %conv90 = sext i8 %113 to i32
  %cmp91 = icmp eq i32 %conv88, %conv90
  br i1 %cmp91, label %if.then93, label %if.else

if.then93:                                        ; preds = %while.body
  %114 = load %struct.edit_s*, %struct.edit_s** %p, align 4
  %c194 = getelementptr inbounds %struct.edit_s, %struct.edit_s* %114, i32 0, i32 0
  %115 = load i8, i8* %c194, align 4
  %conv95 = sext i8 %115 to i32
  %call96 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([3 x i8], [3 x i8]* @.str.1, i32 0, i32 0), i32 %conv95)
  br label %if.end114

if.else:                                          ; preds = %while.body
  %call97 = call i32 @putchar(i32 40)
  %116 = load %struct.edit_s*, %struct.edit_s** %p, align 4
  %c198 = getelementptr inbounds %struct.edit_s, %struct.edit_s* %116, i32 0, i32 0
  %117 = load i8, i8* %c198, align 4
  %tobool99 = icmp ne i8 %117, 0
  br i1 %tobool99, label %if.then100, label %if.end104

if.then100:                                       ; preds = %if.else
  %118 = load %struct.edit_s*, %struct.edit_s** %p, align 4
  %c1101 = getelementptr inbounds %struct.edit_s, %struct.edit_s* %118, i32 0, i32 0
  %119 = load i8, i8* %c1101, align 4
  %conv102 = sext i8 %119 to i32
  %call103 = call i32 @putchar(i32 %conv102)
  br label %if.end104

if.end104:                                        ; preds = %if.then100, %if.else
  %call105 = call i32 @putchar(i32 44)
  %120 = load %struct.edit_s*, %struct.edit_s** %p, align 4
  %c2106 = getelementptr inbounds %struct.edit_s, %struct.edit_s* %120, i32 0, i32 1
  %121 = load i8, i8* %c2106, align 1
  %tobool107 = icmp ne i8 %121, 0
  br i1 %tobool107, label %if.then108, label %if.end112

if.then108:                                       ; preds = %if.end104
  %122 = load %struct.edit_s*, %struct.edit_s** %p, align 4
  %c2109 = getelementptr inbounds %struct.edit_s, %struct.edit_s* %122, i32 0, i32 1
  %123 = load i8, i8* %c2109, align 1
  %conv110 = sext i8 %123 to i32
  %call111 = call i32 @putchar(i32 %conv110)
  br label %if.end112

if.end112:                                        ; preds = %if.then108, %if.end104
  %call113 = call i32 @putchar(i32 41)
  br label %if.end114

if.end114:                                        ; preds = %if.end112, %if.then93
  %124 = load %struct.edit_s*, %struct.edit_s** %p, align 4
  %next115 = getelementptr inbounds %struct.edit_s, %struct.edit_s* %124, i32 0, i32 3
  %125 = load %struct.edit_s*, %struct.edit_s** %next115, align 4
  store %struct.edit_s* %125, %struct.edit_s** %p, align 4
  br label %while.cond

while.end:                                        ; preds = %while.cond
  %call116 = call i32 @putchar(i32 10)
  %126 = load %struct.edit_s**, %struct.edit_s*** %tbl, align 4
  %arrayidx117 = getelementptr inbounds %struct.edit_s*, %struct.edit_s** %126, i32 0
  %127 = load %struct.edit_s*, %struct.edit_s** %arrayidx117, align 4
  %128 = bitcast %struct.edit_s* %127 to i8*
  call void @free(i8* %128)
  %129 = load %struct.edit_s**, %struct.edit_s*** %tbl, align 4
  %130 = bitcast %struct.edit_s** %129 to i8*
  call void @free(i8* %130)
  ret void
}

; Function Attrs: nounwind readonly
declare i32 @strlen(i8* %0) #1

declare noalias i8* @malloc(i32 %0) #2

declare noalias i8* @calloc(i32 %0, i32 %1) #2

declare i32 @printf(i8* %0, ...) #2

declare i32 @putchar(i32 %0) #2

declare void @free(i8* %0) #2

; Function Attrs: noinline nounwind optnone
define hidden i32 @main() #0 {
entry:
  %retval = alloca i32, align 4
  store i32 0, i32* %retval, align 4
  call void @leven(i8* getelementptr inbounds ([14 x i8], [14 x i8]* @.str.2, i32 0, i32 0), i8* getelementptr inbounds ([12 x i8], [12 x i8]* @.str.3, i32 0, i32 0))
  ret i32 0
}

attributes #0 = { noinline nounwind optnone "correctly-rounded-divide-sqrt-fp-math"="false" "disable-tail-calls"="false" "frame-pointer"="none" "less-precise-fpmad"="false" "min-legal-vector-width"="0" "no-infs-fp-math"="false" "no-jump-tables"="false" "no-nans-fp-math"="false" "no-signed-zeros-fp-math"="false" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="generic" "unsafe-fp-math"="false" "use-soft-float"="false" }
attributes #1 = { nounwind readonly "correctly-rounded-divide-sqrt-fp-math"="false" "disable-tail-calls"="false" "frame-pointer"="none" "less-precise-fpmad"="false" "no-infs-fp-math"="false" "no-nans-fp-math"="false" "no-signed-zeros-fp-math"="false" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="generic" "unsafe-fp-math"="false" "use-soft-float"="false" }
attributes #2 = { "correctly-rounded-divide-sqrt-fp-math"="false" "disable-tail-calls"="false" "frame-pointer"="none" "less-precise-fpmad"="false" "no-infs-fp-math"="false" "no-nans-fp-math"="false" "no-signed-zeros-fp-math"="false" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="generic" "unsafe-fp-math"="false" "use-soft-float"="false" }
attributes #3 = { nounwind readonly }

!llvm.module.flags = !{!0}
!llvm.ident = !{!1}

!0 = !{i32 1, !"wchar_size", i32 4}
!1 = !{!"clang version 11.0.0 (https://github.com/Jacarte/llvm-project.git 0f6dea67136cc1e0b3d200eb2bb165628970c44b)"}

; extracted candidates
#########################################################
; exiting Souper's runOnFunction() for main()
Total of 0 replacements done on this module
Total of 0 replacements candidates on this module
