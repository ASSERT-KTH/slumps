
Entering the Souper pass's runOnModule()


; entering Souper's runOnFunction() for month_days()

; ModuleID = './Holidays_related_to_Easter.c.bc'
source_filename = "./Holidays_related_to_Easter.c"
target datalayout = "e-m:e-p:32:32-i64:64-n32:64-S128"
target triple = "wasm32-unknown-wasi"

%struct.date_t = type { i32, i32, i32, i32 }
%struct.easter_related_t = type { %struct.date_t, %struct.date_t, %struct.date_t, %struct.date_t, %struct.date_t }

@.str = private unnamed_addr constant [4 x i8] c"Jan\00", align 1
@.str.1 = private unnamed_addr constant [4 x i8] c"Feb\00", align 1
@.str.2 = private unnamed_addr constant [4 x i8] c"Mar\00", align 1
@.str.3 = private unnamed_addr constant [4 x i8] c"Apr\00", align 1
@.str.4 = private unnamed_addr constant [4 x i8] c"May\00", align 1
@.str.5 = private unnamed_addr constant [4 x i8] c"Jun\00", align 1
@.str.6 = private unnamed_addr constant [4 x i8] c"Jul\00", align 1
@.str.7 = private unnamed_addr constant [4 x i8] c"Aug\00", align 1
@.str.8 = private unnamed_addr constant [4 x i8] c"Sep\00", align 1
@.str.9 = private unnamed_addr constant [4 x i8] c"Oct\00", align 1
@.str.10 = private unnamed_addr constant [4 x i8] c"Nov\00", align 1
@.str.11 = private unnamed_addr constant [4 x i8] c"Dec\00", align 1
@mon_fmt = hidden global [13 x i8*] [i8* null, i8* getelementptr inbounds ([4 x i8], [4 x i8]* @.str, i32 0, i32 0), i8* getelementptr inbounds ([4 x i8], [4 x i8]* @.str.1, i32 0, i32 0), i8* getelementptr inbounds ([4 x i8], [4 x i8]* @.str.2, i32 0, i32 0), i8* getelementptr inbounds ([4 x i8], [4 x i8]* @.str.3, i32 0, i32 0), i8* getelementptr inbounds ([4 x i8], [4 x i8]* @.str.4, i32 0, i32 0), i8* getelementptr inbounds ([4 x i8], [4 x i8]* @.str.5, i32 0, i32 0), i8* getelementptr inbounds ([4 x i8], [4 x i8]* @.str.6, i32 0, i32 0), i8* getelementptr inbounds ([4 x i8], [4 x i8]* @.str.7, i32 0, i32 0), i8* getelementptr inbounds ([4 x i8], [4 x i8]* @.str.8, i32 0, i32 0), i8* getelementptr inbounds ([4 x i8], [4 x i8]* @.str.9, i32 0, i32 0), i8* getelementptr inbounds ([4 x i8], [4 x i8]* @.str.10, i32 0, i32 0), i8* getelementptr inbounds ([4 x i8], [4 x i8]* @.str.11, i32 0, i32 0)], align 16
@.str.12 = private unnamed_addr constant [4 x i8] c"Sat\00", align 1
@.str.13 = private unnamed_addr constant [4 x i8] c"Sun\00", align 1
@.str.14 = private unnamed_addr constant [4 x i8] c"Mon\00", align 1
@.str.15 = private unnamed_addr constant [4 x i8] c"Tue\00", align 1
@.str.16 = private unnamed_addr constant [4 x i8] c"Wed\00", align 1
@.str.17 = private unnamed_addr constant [4 x i8] c"Thu\00", align 1
@.str.18 = private unnamed_addr constant [4 x i8] c"Fri\00", align 1
@week_day_fmt = hidden global [8 x i8*] [i8* null, i8* getelementptr inbounds ([4 x i8], [4 x i8]* @.str.12, i32 0, i32 0), i8* getelementptr inbounds ([4 x i8], [4 x i8]* @.str.13, i32 0, i32 0), i8* getelementptr inbounds ([4 x i8], [4 x i8]* @.str.14, i32 0, i32 0), i8* getelementptr inbounds ([4 x i8], [4 x i8]* @.str.15, i32 0, i32 0), i8* getelementptr inbounds ([4 x i8], [4 x i8]* @.str.16, i32 0, i32 0), i8* getelementptr inbounds ([4 x i8], [4 x i8]* @.str.17, i32 0, i32 0), i8* getelementptr inbounds ([4 x i8], [4 x i8]* @.str.18, i32 0, i32 0)], align 16
@__const.month_days.days = private unnamed_addr constant [13 x i32] [i32 0, i32 31, i32 28, i32 31, i32 30, i32 31, i32 30, i32 31, i32 31, i32 30, i32 31, i32 30, i32 31], align 16
@year_months = hidden global i32 12, align 4
@week_days = hidden global i32 7, align 4
@.str.19 = private unnamed_addr constant [106 x i8] c"%4d Easter: %s %2d %s, Ascension: %s %2d %s, Pentecost: %s %2d %s, Trinity: %s %2d %s, Corpus: %s %2d %s\0A\00", align 1
@.str.20 = private unnamed_addr constant [81 x i8] c"Christian holidays, related to Easter, for each centennial from 400 to 2100 CE:\0A\00", align 1
@.str.21 = private unnamed_addr constant [73 x i8] c"\0AChristian holidays, related to Easter, for years from 2010 to 2020 CE:\0A\00", align 1
@llvm.used = appending global [1 x i8*] [i8* bitcast (i32 ()* @__main_void to i8*)], section "llvm.metadata"

@__main_void = alias i32 (), i32 ()* @main

; Function Attrs: noinline nounwind optnone
define hidden i32 @month_days(i32 %year, i32 %month) #0 {
entry:
  %year.addr = alloca i32, align 4
  %month.addr = alloca i32, align 4
  %days = alloca [13 x i32], align 16
  store i32 %year, i32* %year.addr, align 4
  store i32 %month, i32* %month.addr, align 4
  %0 = bitcast [13 x i32]* %days to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 16 %0, i8* align 16 bitcast ([13 x i32]* @__const.month_days.days to i8*), i32 52, i1 false)
  %1 = load i32, i32* %month.addr, align 4
  %cmp = icmp eq i32 %1, 2
  br i1 %cmp, label %cond.true, label %cond.false

cond.true:                                        ; preds = %entry
  %2 = load i32, i32* %year.addr, align 4
  %rem = srem i32 %2, 4
  %cmp1 = icmp eq i32 %rem, 0
  br i1 %cmp1, label %land.lhs.true, label %lor.rhs

land.lhs.true:                                    ; preds = %cond.true
  %3 = load i32, i32* %year.addr, align 4
  %rem2 = srem i32 %3, 100
  %cmp3 = icmp ne i32 %rem2, 0
  br i1 %cmp3, label %lor.end, label %lor.rhs

lor.rhs:                                          ; preds = %land.lhs.true, %cond.true
  %4 = load i32, i32* %year.addr, align 4
  %rem4 = srem i32 %4, 400
  %cmp5 = icmp eq i32 %rem4, 0
  br label %lor.end

lor.end:                                          ; preds = %lor.rhs, %land.lhs.true
  %5 = phi i1 [ true, %land.lhs.true ], [ %cmp5, %lor.rhs ]
  %lor.ext = zext i1 %5 to i32
  %add = add nsw i32 28, %lor.ext
  br label %cond.end

cond.false:                                       ; preds = %entry
  %6 = load i32, i32* %month.addr, align 4
  %arrayidx = getelementptr inbounds [13 x i32], [13 x i32]* %days, i32 0, i32 %6
  %7 = load i32, i32* %arrayidx, align 4
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %lor.end
  %cond = phi i32 [ %add, %lor.end ], [ %7, %cond.false ]
  ret i32 %cond
}

; Function Attrs: argmemonly nounwind willreturn
declare void @llvm.memcpy.p0i8.p0i8.i32(i8* noalias nocapture writeonly %0, i8* noalias nocapture readonly %1, i32 %2, i1 immarg %3) #1

; Function Attrs: noinline nounwind optnone
define hidden i32 @year_days(i32 %year) #0 {
entry:
  %year.addr = alloca i32, align 4
  store i32 %year, i32* %year.addr, align 4
  %0 = load i32, i32* %year.addr, align 4
  %call = call i32 @month_days(i32 %0, i32 2)
  %cmp = icmp eq i32 %call, 28
  %1 = zext i1 %cmp to i64
  %cond = select i1 %cmp, i32 365, i32 366
  ret i32 %cond
}

; Function Attrs: noinline nounwind optnone
define hidden void @plusab(%struct.date_t* noalias sret align 4 %agg.result, %struct.date_t* %date, i32 %days) #0 {
entry:
  %date.addr = alloca %struct.date_t*, align 4
  %days.addr = alloca i32, align 4
  store %struct.date_t* %date, %struct.date_t** %date.addr, align 4
  store i32 %days, i32* %days.addr, align 4
  br label %while.cond

while.cond:                                       ; preds = %while.body, %entry
  %0 = load i32, i32* %days.addr, align 4
  %cmp = icmp slt i32 %0, 0
  br i1 %cmp, label %while.body, label %while.end

while.body:                                       ; preds = %while.cond
  %1 = load %struct.date_t*, %struct.date_t** %date.addr, align 4
  %year = getelementptr inbounds %struct.date_t, %struct.date_t* %1, i32 0, i32 0
  %2 = load i32, i32* %year, align 4
  %sub = sub nsw i32 %2, 1
  store i32 %sub, i32* %year, align 4
  %3 = load %struct.date_t*, %struct.date_t** %date.addr, align 4
  %year1 = getelementptr inbounds %struct.date_t, %struct.date_t* %3, i32 0, i32 0
  %4 = load i32, i32* %year1, align 4
  %call = call i32 @year_days(i32 %4)
  %5 = load i32, i32* %days.addr, align 4
  %add = add nsw i32 %5, %call
  store i32 %add, i32* %days.addr, align 4
  br label %while.cond

while.end:                                        ; preds = %while.cond
  br label %while.cond2

while.cond2:                                      ; preds = %while.body6, %while.end
  %6 = load i32, i32* %days.addr, align 4
  %7 = load %struct.date_t*, %struct.date_t** %date.addr, align 4
  %year3 = getelementptr inbounds %struct.date_t, %struct.date_t* %7, i32 0, i32 0
  %8 = load i32, i32* %year3, align 4
  %call4 = call i32 @year_days(i32 %8)
  %cmp5 = icmp sgt i32 %6, %call4
  br i1 %cmp5, label %while.body6, label %while.end12

while.body6:                                      ; preds = %while.cond2
  %9 = load %struct.date_t*, %struct.date_t** %date.addr, align 4
  %year7 = getelementptr inbounds %struct.date_t, %struct.date_t* %9, i32 0, i32 0
  %10 = load i32, i32* %year7, align 4
  %call8 = call i32 @year_days(i32 %10)
  %11 = load i32, i32* %days.addr, align 4
  %sub9 = sub nsw i32 %11, %call8
  store i32 %sub9, i32* %days.addr, align 4
  %12 = load %struct.date_t*, %struct.date_t** %date.addr, align 4
  %year10 = getelementptr inbounds %struct.date_t, %struct.date_t* %12, i32 0, i32 0
  %13 = load i32, i32* %year10, align 4
  %add11 = add nsw i32 %13, 1
  store i32 %add11, i32* %year10, align 4
  br label %while.cond2

while.end12:                                      ; preds = %while.cond2
  %14 = load i32, i32* %days.addr, align 4
  %15 = load %struct.date_t*, %struct.date_t** %date.addr, align 4
  %month_day = getelementptr inbounds %struct.date_t, %struct.date_t* %15, i32 0, i32 2
  %16 = load i32, i32* %month_day, align 4
  %add13 = add nsw i32 %16, %14
  store i32 %add13, i32* %month_day, align 4
  br label %while.cond14

while.cond14:                                     ; preds = %if.end, %while.end12
  %17 = load %struct.date_t*, %struct.date_t** %date.addr, align 4
  %month_day15 = getelementptr inbounds %struct.date_t, %struct.date_t* %17, i32 0, i32 2
  %18 = load i32, i32* %month_day15, align 4
  %19 = load %struct.date_t*, %struct.date_t** %date.addr, align 4
  %year16 = getelementptr inbounds %struct.date_t, %struct.date_t* %19, i32 0, i32 0
  %20 = load i32, i32* %year16, align 4
  %21 = load %struct.date_t*, %struct.date_t** %date.addr, align 4
  %month = getelementptr inbounds %struct.date_t, %struct.date_t* %21, i32 0, i32 1
  %22 = load i32, i32* %month, align 4
  %call17 = call i32 @month_days(i32 %20, i32 %22)
  %cmp18 = icmp sgt i32 %18, %call17
  br i1 %cmp18, label %while.body19, label %while.end33

while.body19:                                     ; preds = %while.cond14
  %23 = load %struct.date_t*, %struct.date_t** %date.addr, align 4
  %year20 = getelementptr inbounds %struct.date_t, %struct.date_t* %23, i32 0, i32 0
  %24 = load i32, i32* %year20, align 4
  %25 = load %struct.date_t*, %struct.date_t** %date.addr, align 4
  %month21 = getelementptr inbounds %struct.date_t, %struct.date_t* %25, i32 0, i32 1
  %26 = load i32, i32* %month21, align 4
  %call22 = call i32 @month_days(i32 %24, i32 %26)
  %27 = load %struct.date_t*, %struct.date_t** %date.addr, align 4
  %month_day23 = getelementptr inbounds %struct.date_t, %struct.date_t* %27, i32 0, i32 2
  %28 = load i32, i32* %month_day23, align 4
  %sub24 = sub nsw i32 %28, %call22
  store i32 %sub24, i32* %month_day23, align 4
  %29 = load %struct.date_t*, %struct.date_t** %date.addr, align 4
  %month25 = getelementptr inbounds %struct.date_t, %struct.date_t* %29, i32 0, i32 1
  %30 = load i32, i32* %month25, align 4
  %add26 = add nsw i32 %30, 1
  store i32 %add26, i32* %month25, align 4
  %31 = load %struct.date_t*, %struct.date_t** %date.addr, align 4
  %month27 = getelementptr inbounds %struct.date_t, %struct.date_t* %31, i32 0, i32 1
  %32 = load i32, i32* %month27, align 4
  %33 = load i32, i32* @year_months, align 4
  %cmp28 = icmp sgt i32 %32, %33
  br i1 %cmp28, label %if.then, label %if.end

if.then:                                          ; preds = %while.body19
  %34 = load i32, i32* @year_months, align 4
  %35 = load %struct.date_t*, %struct.date_t** %date.addr, align 4
  %month29 = getelementptr inbounds %struct.date_t, %struct.date_t* %35, i32 0, i32 1
  %36 = load i32, i32* %month29, align 4
  %sub30 = sub nsw i32 %36, %34
  store i32 %sub30, i32* %month29, align 4
  %37 = load %struct.date_t*, %struct.date_t** %date.addr, align 4
  %year31 = getelementptr inbounds %struct.date_t, %struct.date_t* %37, i32 0, i32 0
  %38 = load i32, i32* %year31, align 4
  %add32 = add nsw i32 %38, 1
  store i32 %add32, i32* %year31, align 4
  br label %if.end

if.end:                                           ; preds = %if.then, %while.body19
  br label %while.cond14

while.end33:                                      ; preds = %while.cond14
  %39 = load %struct.date_t*, %struct.date_t** %date.addr, align 4
  %call34 = call i32 @week_day(%struct.date_t* byval(%struct.date_t) align 4 %39)
  %40 = load %struct.date_t*, %struct.date_t** %date.addr, align 4
  %week_day = getelementptr inbounds %struct.date_t, %struct.date_t* %40, i32 0, i32 3
  store i32 %call34, i32* %week_day, align 4
  %41 = load %struct.date_t*, %struct.date_t** %date.addr, align 4
  %42 = bitcast %struct.date_t* %agg.result to i8*
  %43 = bitcast %struct.date_t* %41 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 4 %42, i8* align 4 %43, i32 16, i1 false)
  ret void
}

; Function Attrs: noinline nounwind optnone
define hidden void @easter(%struct.date_t* noalias sret align 4 %agg.result, i32 %year) #0 {
entry:
  %year.addr = alloca i32, align 4
  %c = alloca i32, align 4
  %n = alloca i32, align 4
  %i = alloca i32, align 4
  %l = alloca i32, align 4
  store i32 %year, i32* %year.addr, align 4
  %0 = load i32, i32* %year.addr, align 4
  %year1 = getelementptr inbounds %struct.date_t, %struct.date_t* %agg.result, i32 0, i32 0
  store i32 %0, i32* %year1, align 4
  %1 = load i32, i32* %year.addr, align 4
  %div = sdiv i32 %1, 100
  store i32 %div, i32* %c, align 4
  %2 = load i32, i32* %year.addr, align 4
  %rem = srem i32 %2, 19
  store i32 %rem, i32* %n, align 4
  %3 = load i32, i32* %c, align 4
  %4 = load i32, i32* %c, align 4
  %div2 = sdiv i32 %4, 4
  %sub = sub nsw i32 %3, %div2
  %5 = load i32, i32* %c, align 4
  %6 = load i32, i32* %c, align 4
  %sub3 = sub nsw i32 %6, 17
  %div4 = sdiv i32 %sub3, 25
  %sub5 = sub nsw i32 %5, %div4
  %div6 = sdiv i32 %sub5, 3
  %sub7 = sub nsw i32 %sub, %div6
  %7 = load i32, i32* %n, align 4
  %mul = mul nsw i32 19, %7
  %add = add nsw i32 %sub7, %mul
  %add8 = add nsw i32 %add, 15
  %rem9 = srem i32 %add8, 30
  store i32 %rem9, i32* %i, align 4
  %8 = load i32, i32* %i, align 4
  %div10 = sdiv i32 %8, 28
  %9 = load i32, i32* %i, align 4
  %div11 = sdiv i32 %9, 28
  %10 = load i32, i32* %i, align 4
  %add12 = add nsw i32 %10, 1
  %div13 = sdiv i32 29, %add12
  %mul14 = mul nsw i32 %div11, %div13
  %11 = load i32, i32* %n, align 4
  %sub15 = sub nsw i32 21, %11
  %div16 = sdiv i32 %sub15, 11
  %mul17 = mul nsw i32 %mul14, %div16
  %sub18 = sub nsw i32 1, %mul17
  %mul19 = mul nsw i32 %div10, %sub18
  %12 = load i32, i32* %i, align 4
  %sub20 = sub nsw i32 %12, %mul19
  store i32 %sub20, i32* %i, align 4
  %13 = load i32, i32* %i, align 4
  %14 = load i32, i32* %year.addr, align 4
  %15 = load i32, i32* %year.addr, align 4
  %div21 = sdiv i32 %15, 4
  %add22 = add nsw i32 %14, %div21
  %16 = load i32, i32* %i, align 4
  %add23 = add nsw i32 %add22, %16
  %add24 = add nsw i32 %add23, 2
  %17 = load i32, i32* %c, align 4
  %sub25 = sub nsw i32 %add24, %17
  %18 = load i32, i32* %c, align 4
  %div26 = sdiv i32 %18, 4
  %add27 = add nsw i32 %sub25, %div26
  %rem28 = srem i32 %add27, 7
  %sub29 = sub nsw i32 %13, %rem28
  store i32 %sub29, i32* %l, align 4
  %19 = load i32, i32* %l, align 4
  %add30 = add nsw i32 %19, 40
  %div31 = sdiv i32 %add30, 44
  %add32 = add nsw i32 3, %div31
  %month = getelementptr inbounds %struct.date_t, %struct.date_t* %agg.result, i32 0, i32 1
  store i32 %add32, i32* %month, align 4
  %20 = load i32, i32* %l, align 4
  %add33 = add nsw i32 %20, 28
  %month34 = getelementptr inbounds %struct.date_t, %struct.date_t* %agg.result, i32 0, i32 1
  %21 = load i32, i32* %month34, align 4
  %div35 = sdiv i32 %21, 4
  %mul36 = mul nsw i32 31, %div35
  %sub37 = sub nsw i32 %add33, %mul36
  %month_day = getelementptr inbounds %struct.date_t, %struct.date_t* %agg.result, i32 0, i32 2
  store i32 %sub37, i32* %month_day, align 4
  %call = call i32 @week_day(%struct.date_t* byval(%struct.date_t) align 4 %agg.result)
  %week_day = getelementptr inbounds %struct.date_t, %struct.date_t* %agg.result, i32 0, i32 3
  store i32 %call, i32* %week_day, align 4
  ret void
}

; Function Attrs: noinline nounwind optnone
define hidden i32 @week_day(%struct.date_t* byval(%struct.date_t) align 4 %date) #0 {
entry:
  %year = alloca i32, align 4
  %month = alloca i32, align 4
  %month_day = alloca i32, align 4
  %c = alloca i32, align 4
  %year1 = getelementptr inbounds %struct.date_t, %struct.date_t* %date, i32 0, i32 0
  %0 = load i32, i32* %year1, align 4
  store i32 %0, i32* %year, align 4
  %month2 = getelementptr inbounds %struct.date_t, %struct.date_t* %date, i32 0, i32 1
  %1 = load i32, i32* %month2, align 4
  store i32 %1, i32* %month, align 4
  %month_day3 = getelementptr inbounds %struct.date_t, %struct.date_t* %date, i32 0, i32 2
  %2 = load i32, i32* %month_day3, align 4
  store i32 %2, i32* %month_day, align 4
  %3 = load i32, i32* %month, align 4
  %cmp = icmp sle i32 %3, 2
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %4 = load i32, i32* %month, align 4
  %add = add nsw i32 %4, 12
  store i32 %add, i32* %month, align 4
  %5 = load i32, i32* %year, align 4
  %sub = sub nsw i32 %5, 1
  store i32 %sub, i32* %year, align 4
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  %6 = load i32, i32* %year, align 4
  %div = sdiv i32 %6, 100
  store i32 %div, i32* %c, align 4
  %7 = load i32, i32* %year, align 4
  %rem = srem i32 %7, 100
  store i32 %rem, i32* %year, align 4
  %8 = load i32, i32* %month_day, align 4
  %9 = load i32, i32* %month, align 4
  %add4 = add nsw i32 %9, 1
  %mul = mul nsw i32 %add4, 26
  %div5 = sdiv i32 %mul, 10
  %add6 = add nsw i32 %8, %div5
  %10 = load i32, i32* %year, align 4
  %add7 = add nsw i32 %add6, %10
  %11 = load i32, i32* %year, align 4
  %div8 = sdiv i32 %11, 4
  %add9 = add nsw i32 %add7, %div8
  %12 = load i32, i32* %c, align 4
  %div10 = sdiv i32 %12, 4
  %add11 = add nsw i32 %add9, %div10
  %13 = load i32, i32* %c, align 4
  %mul12 = mul nsw i32 2, %13
  %sub13 = sub nsw i32 %add11, %mul12
  %rem14 = srem i32 %sub13, 7
  %add15 = add nsw i32 %rem14, 7
  %rem16 = srem i32 %add15, 7
  %add17 = add nsw i32 1, %rem16
  ret i32 %add17
}

; Function Attrs: noinline nounwind optnone
define hidden void @easter_related_init(%struct.easter_related_t* noalias sret align 4 %agg.result, i32 %year) #0 {
entry:
  %year.addr = alloca i32, align 4
  %date = alloca %struct.date_t, align 4
  %tmp = alloca %struct.date_t, align 4
  %tmp1 = alloca %struct.date_t, align 4
  %tmp2 = alloca %struct.date_t, align 4
  %tmp3 = alloca %struct.date_t, align 4
  %tmp4 = alloca %struct.date_t, align 4
  store i32 %year, i32* %year.addr, align 4
  %easter = getelementptr inbounds %struct.easter_related_t, %struct.easter_related_t* %agg.result, i32 0, i32 0
  %0 = load i32, i32* %year.addr, align 4
  call void @easter(%struct.date_t* sret align 4 %tmp, i32 %0)
  %1 = bitcast %struct.date_t* %date to i8*
  %2 = bitcast %struct.date_t* %tmp to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 4 %1, i8* align 4 %2, i32 16, i1 false)
  %3 = bitcast %struct.date_t* %easter to i8*
  %4 = bitcast %struct.date_t* %date to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 4 %3, i8* align 4 %4, i32 16, i1 false)
  %ascension = getelementptr inbounds %struct.easter_related_t, %struct.easter_related_t* %agg.result, i32 0, i32 1
  call void @plusab(%struct.date_t* sret align 4 %tmp1, %struct.date_t* %date, i32 39)
  %5 = bitcast %struct.date_t* %ascension to i8*
  %6 = bitcast %struct.date_t* %tmp1 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 4 %5, i8* align 4 %6, i32 16, i1 false)
  %pentecost = getelementptr inbounds %struct.easter_related_t, %struct.easter_related_t* %agg.result, i32 0, i32 2
  call void @plusab(%struct.date_t* sret align 4 %tmp2, %struct.date_t* %date, i32 10)
  %7 = bitcast %struct.date_t* %pentecost to i8*
  %8 = bitcast %struct.date_t* %tmp2 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 4 %7, i8* align 4 %8, i32 16, i1 false)
  %trinity = getelementptr inbounds %struct.easter_related_t, %struct.easter_related_t* %agg.result, i32 0, i32 3
  call void @plusab(%struct.date_t* sret align 4 %tmp3, %struct.date_t* %date, i32 7)
  %9 = bitcast %struct.date_t* %trinity to i8*
  %10 = bitcast %struct.date_t* %tmp3 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 4 %9, i8* align 4 %10, i32 16, i1 false)
  %corpus_christi = getelementptr inbounds %struct.easter_related_t, %struct.easter_related_t* %agg.result, i32 0, i32 4
  call void @plusab(%struct.date_t* sret align 4 %tmp4, %struct.date_t* %date, i32 4)
  %11 = bitcast %struct.date_t* %corpus_christi to i8*
  %12 = bitcast %struct.date_t* %tmp4 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 4 %11, i8* align 4 %12, i32 16, i1 false)
  ret void
}

; Function Attrs: noinline nounwind optnone
define hidden void @easter_related_print(i32 %year) #0 {
entry:
  %year.addr = alloca i32, align 4
  %holidays = alloca %struct.easter_related_t, align 4
  store i32 %year, i32* %year.addr, align 4
  %0 = load i32, i32* %year.addr, align 4
  call void @easter_related_init(%struct.easter_related_t* sret align 4 %holidays, i32 %0)
  %1 = load i32, i32* %year.addr, align 4
  %easter = getelementptr inbounds %struct.easter_related_t, %struct.easter_related_t* %holidays, i32 0, i32 0
  %week_day = getelementptr inbounds %struct.date_t, %struct.date_t* %easter, i32 0, i32 3
  %2 = load i32, i32* %week_day, align 4
  %arrayidx = getelementptr inbounds [8 x i8*], [8 x i8*]* @week_day_fmt, i32 0, i32 %2
  %3 = load i8*, i8** %arrayidx, align 4
  %easter1 = getelementptr inbounds %struct.easter_related_t, %struct.easter_related_t* %holidays, i32 0, i32 0
  %month_day = getelementptr inbounds %struct.date_t, %struct.date_t* %easter1, i32 0, i32 2
  %4 = load i32, i32* %month_day, align 4
  %easter2 = getelementptr inbounds %struct.easter_related_t, %struct.easter_related_t* %holidays, i32 0, i32 0
  %month = getelementptr inbounds %struct.date_t, %struct.date_t* %easter2, i32 0, i32 1
  %5 = load i32, i32* %month, align 4
  %arrayidx3 = getelementptr inbounds [13 x i8*], [13 x i8*]* @mon_fmt, i32 0, i32 %5
  %6 = load i8*, i8** %arrayidx3, align 4
  %ascension = getelementptr inbounds %struct.easter_related_t, %struct.easter_related_t* %holidays, i32 0, i32 1
  %week_day4 = getelementptr inbounds %struct.date_t, %struct.date_t* %ascension, i32 0, i32 3
  %7 = load i32, i32* %week_day4, align 4
  %arrayidx5 = getelementptr inbounds [8 x i8*], [8 x i8*]* @week_day_fmt, i32 0, i32 %7
  %8 = load i8*, i8** %arrayidx5, align 4
  %ascension6 = getelementptr inbounds %struct.easter_related_t, %struct.easter_related_t* %holidays, i32 0, i32 1
  %month_day7 = getelementptr inbounds %struct.date_t, %struct.date_t* %ascension6, i32 0, i32 2
  %9 = load i32, i32* %month_day7, align 4
  %ascension8 = getelementptr inbounds %struct.easter_related_t, %struct.easter_related_t* %holidays, i32 0, i32 1
  %month9 = getelementptr inbounds %struct.date_t, %struct.date_t* %ascension8, i32 0, i32 1
  %10 = load i32, i32* %month9, align 4
  %arrayidx10 = getelementptr inbounds [13 x i8*], [13 x i8*]* @mon_fmt, i32 0, i32 %10
  %11 = load i8*, i8** %arrayidx10, align 4
  %pentecost = getelementptr inbounds %struct.easter_related_t, %struct.easter_related_t* %holidays, i32 0, i32 2
  %week_day11 = getelementptr inbounds %struct.date_t, %struct.date_t* %pentecost, i32 0, i32 3
  %12 = load i32, i32* %week_day11, align 4
  %arrayidx12 = getelementptr inbounds [8 x i8*], [8 x i8*]* @week_day_fmt, i32 0, i32 %12
  %13 = load i8*, i8** %arrayidx12, align 4
  %pentecost13 = getelementptr inbounds %struct.easter_related_t, %struct.easter_related_t* %holidays, i32 0, i32 2
  %month_day14 = getelementptr inbounds %struct.date_t, %struct.date_t* %pentecost13, i32 0, i32 2
  %14 = load i32, i32* %month_day14, align 4
  %pentecost15 = getelementptr inbounds %struct.easter_related_t, %struct.easter_related_t* %holidays, i32 0, i32 2
  %month16 = getelementptr inbounds %struct.date_t, %struct.date_t* %pentecost15, i32 0, i32 1
  %15 = load i32, i32* %month16, align 4
  %arrayidx17 = getelementptr inbounds [13 x i8*], [13 x i8*]* @mon_fmt, i32 0, i32 %15
  %16 = load i8*, i8** %arrayidx17, align 4
  %trinity = getelementptr inbounds %struct.easter_related_t, %struct.easter_related_t* %holidays, i32 0, i32 3
  %week_day18 = getelementptr inbounds %struct.date_t, %struct.date_t* %trinity, i32 0, i32 3
  %17 = load i32, i32* %week_day18, align 4
  %arrayidx19 = getelementptr inbounds [8 x i8*], [8 x i8*]* @week_day_fmt, i32 0, i32 %17
  %18 = load i8*, i8** %arrayidx19, align 4
  %trinity20 = getelementptr inbounds %struct.easter_related_t, %struct.easter_related_t* %holidays, i32 0, i32 3
  %month_day21 = getelementptr inbounds %struct.date_t, %struct.date_t* %trinity20, i32 0, i32 2
  %19 = load i32, i32* %month_day21, align 4
  %trinity22 = getelementptr inbounds %struct.easter_related_t, %struct.easter_related_t* %holidays, i32 0, i32 3
  %month23 = getelementptr inbounds %struct.date_t, %struct.date_t* %trinity22, i32 0, i32 1
  %20 = load i32, i32* %month23, align 4
  %arrayidx24 = getelementptr inbounds [13 x i8*], [13 x i8*]* @mon_fmt, i32 0, i32 %20
  %21 = load i8*, i8** %arrayidx24, align 4
  %corpus_christi = getelementptr inbounds %struct.easter_related_t, %struct.easter_related_t* %holidays, i32 0, i32 4
  %week_day25 = getelementptr inbounds %struct.date_t, %struct.date_t* %corpus_christi, i32 0, i32 3
  %22 = load i32, i32* %week_day25, align 4
  %arrayidx26 = getelementptr inbounds [8 x i8*], [8 x i8*]* @week_day_fmt, i32 0, i32 %22
  %23 = load i8*, i8** %arrayidx26, align 4
  %corpus_christi27 = getelementptr inbounds %struct.easter_related_t, %struct.easter_related_t* %holidays, i32 0, i32 4
  %month_day28 = getelementptr inbounds %struct.date_t, %struct.date_t* %corpus_christi27, i32 0, i32 2
  %24 = load i32, i32* %month_day28, align 4
  %corpus_christi29 = getelementptr inbounds %struct.easter_related_t, %struct.easter_related_t* %holidays, i32 0, i32 4
  %month30 = getelementptr inbounds %struct.date_t, %struct.date_t* %corpus_christi29, i32 0, i32 1
  %25 = load i32, i32* %month30, align 4
  %arrayidx31 = getelementptr inbounds [13 x i8*], [13 x i8*]* @mon_fmt, i32 0, i32 %25
  %26 = load i8*, i8** %arrayidx31, align 4
  %call = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([106 x i8], [106 x i8]* @.str.19, i32 0, i32 0), i32 %1, i8* %3, i32 %4, i8* %6, i8* %8, i32 %9, i8* %11, i8* %13, i32 %14, i8* %16, i8* %18, i32 %19, i8* %21, i8* %23, i32 %24, i8* %26)
  ret void
}

declare i32 @printf(i8* %0, ...) #2

; Function Attrs: noinline nounwind optnone
define hidden i32 @main() #0 {
entry:
  %retval = alloca i32, align 4
  %year = alloca i32, align 4
  store i32 0, i32* %retval, align 4
  %call = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([81 x i8], [81 x i8]* @.str.20, i32 0, i32 0))
  store i32 400, i32* %year, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %0 = load i32, i32* %year, align 4
  %cmp = icmp sle i32 %0, 2100
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %1 = load i32, i32* %year, align 4
  call void @easter_related_print(i32 %1)
  br label %for.inc

for.inc:                                          ; preds = %for.body
  %2 = load i32, i32* %year, align 4
  %add = add nsw i32 %2, 100
  store i32 %add, i32* %year, align 4
  br label %for.cond

for.end:                                          ; preds = %for.cond
  %call1 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([73 x i8], [73 x i8]* @.str.21, i32 0, i32 0))
  store i32 2010, i32* %year, align 4
  br label %for.cond2

for.cond2:                                        ; preds = %for.inc5, %for.end
  %3 = load i32, i32* %year, align 4
  %cmp3 = icmp sle i32 %3, 2020
  br i1 %cmp3, label %for.body4, label %for.end6

for.body4:                                        ; preds = %for.cond2
  %4 = load i32, i32* %year, align 4
  call void @easter_related_print(i32 %4)
  br label %for.inc5

for.inc5:                                         ; preds = %for.body4
  %5 = load i32, i32* %year, align 4
  %inc = add nsw i32 %5, 1
  store i32 %inc, i32* %year, align 4
  br label %for.cond2

for.end6:                                         ; preds = %for.cond2
  ret i32 0
}

attributes #0 = { noinline nounwind optnone "correctly-rounded-divide-sqrt-fp-math"="false" "disable-tail-calls"="false" "frame-pointer"="none" "less-precise-fpmad"="false" "min-legal-vector-width"="0" "no-infs-fp-math"="false" "no-jump-tables"="false" "no-nans-fp-math"="false" "no-signed-zeros-fp-math"="false" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="generic" "unsafe-fp-math"="false" "use-soft-float"="false" }
attributes #1 = { argmemonly nounwind willreturn }
attributes #2 = { "correctly-rounded-divide-sqrt-fp-math"="false" "disable-tail-calls"="false" "frame-pointer"="none" "less-precise-fpmad"="false" "no-infs-fp-math"="false" "no-nans-fp-math"="false" "no-signed-zeros-fp-math"="false" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="generic" "unsafe-fp-math"="false" "use-soft-float"="false" }

!llvm.module.flags = !{!0}
!llvm.ident = !{!1}

!0 = !{i32 1, !"wchar_size", i32 4}
!1 = !{!"clang version 11.0.0 (https://github.com/Jacarte/llvm-project.git 0f6dea67136cc1e0b3d200eb2bb165628970c44b)"}

; extracted candidates

; *****
; For LLVM instruction:
;  %1 = load i32, i32* %month.addr, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %cmp = icmp eq i32 %1, 2
; Looking for a replacement for:
%0:i32 = var
%1:i1 = eq 2:i32, %0
infer %1

; *****
; For LLVM instruction:
;  %2 = load i32, i32* %year.addr, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %rem = srem i32 %2, 4
; Looking for a replacement for:
%0:i32 = var
%1:i32 = srem %0, 4:i32
infer %1

; *****
; For LLVM instruction:
;  %cmp1 = icmp eq i32 %rem, 0
; Looking for a replacement for:
%0:i32 = var
%1:i32 = srem %0, 4:i32
%2:i1 = eq 0:i32, %1
infer %2

; *****
; For LLVM instruction:
;  %3 = load i32, i32* %year.addr, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %rem2 = srem i32 %3, 100
; Looking for a replacement for:
%0:i32 = var
%1:i32 = srem %0, 100:i32
infer %1

; *****
; For LLVM instruction:
;  %cmp3 = icmp ne i32 %rem2, 0
; Looking for a replacement for:
%0:i32 = var
%1:i32 = srem %0, 100:i32
%2:i1 = ne 0:i32, %1
infer %2

; *****
; For LLVM instruction:
;  %4 = load i32, i32* %year.addr, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %rem4 = srem i32 %4, 400
; Looking for a replacement for:
%0:i32 = var
%1:i32 = srem %0, 400:i32
infer %1

; *****
; For LLVM instruction:
;  %cmp5 = icmp eq i32 %rem4, 0
; Looking for a replacement for:
%0:i32 = var
%1:i32 = srem %0, 400:i32
%2:i1 = eq 0:i32, %1
infer %2

; *****
; For LLVM instruction:
;  %5 = phi i1 [ true, %land.lhs.true ], [ %cmp5, %lor.rhs ]
; Looking for a replacement for:
%0 = block 2
%1:i32 = var
%2:i32 = srem %1, 400:i32
%3:i1 = eq 0:i32, %2
%4:i1 = phi %0, 1:i1, %3
infer %4

; *****
; For LLVM instruction:
;  %lor.ext = zext i1 %5 to i32
; Looking for a replacement for:
%0 = block 2
%1:i32 = var
%2:i32 = srem %1, 400:i32
%3:i1 = eq 0:i32, %2
%4:i1 = phi %0, 1:i1, %3
%5:i32 = zext %4
infer %5

; *****
; For LLVM instruction:
;  %add = add nsw i32 28, %lor.ext
; Looking for a replacement for:
%0 = block 2
%1:i32 = var
%2:i32 = srem %1, 400:i32
%3:i1 = eq 0:i32, %2
%4:i1 = phi %0, 1:i1, %3
%5:i32 = zext %4
%6:i32 = addnsw 28:i32, %5
infer %6

; *****
; For LLVM instruction:
;  %6 = load i32, i32* %month.addr, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %7 = load i32, i32* %arrayidx, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %cond = phi i32 [ %add, %lor.end ], [ %7, %cond.false ]
; Looking for a replacement for:
%0 = block 2
%1 = block 2
%2:i32 = var
%3:i32 = srem %2, 400:i32
%4:i1 = eq 0:i32, %3
%5:i1 = phi %1, 1:i1, %4
%6:i32 = zext %5
%7:i32 = addnsw 28:i32, %6
%8:i32 = var
%9:i32 = phi %0, %7, %8
infer %9
got 1 candidates from LHS

-------------------------------------------------
%0:i32 = var
infer %0


--------------------------------
guess 0

%0:i32 = var ; reservedconst_1

Cost = 0
first query is SAT, returning the model:
reservedconst_1: 0
0 th attempt: second query is SAT-- constant doesn't work
first query is SAT, returning the model:
reservedconst_1: -1
1 th attempt: second query is SAT-- constant doesn't work
first query is UNSAT-- no more guesses
Dataflow Pruned 0/0
There are 1 Guesses
There are 0 RHSs before deduplication
There are 0 RHSs after deduplication
got 2 candidates from LHS

-------------------------------------------------
%0:i32 = var
%1:i1 = eq 2:i32, %0
infer %1


--------------------------------
guess 0

%0:i1 = var ; reservedconst_1

Cost = 0
first query is SAT, returning the model:
reservedconst_1: 0
0 th attempt: second query is SAT-- constant doesn't work
first query is SAT, returning the model:
reservedconst_1: -1
1 th attempt: second query is SAT-- constant doesn't work
first query is UNSAT-- no more guesses
Dataflow Pruned 0/0
There are 1 Guesses
There are 0 RHSs before deduplication
There are 0 RHSs after deduplication
got 2 candidates from LHS

-------------------------------------------------
%0:i32 = var
%1:i32 = srem %0, 4:i32
infer %1


--------------------------------
guess 0

%0:i32 = var ; reservedconst_1

Cost = 0
first query is SAT, returning the model:
reservedconst_1: 0
0 th attempt: second query is SAT-- constant doesn't work
first query is SAT, returning the model:
reservedconst_1: -3
1 th attempt: second query is SAT-- constant doesn't work
first query is UNSAT-- no more guesses

--------------------------------
guess 1

%0:i32 = var

Cost = 0
second query is SAT-- constant doesn't work
Dataflow Pruned 0/0
There are 2 Guesses
There are 0 RHSs before deduplication
There are 0 RHSs after deduplication
got 3 candidates from LHS

-------------------------------------------------
%0:i32 = var
%1:i32 = srem %0, 4:i32
%2:i1 = eq 0:i32, %1
infer %2


--------------------------------
guess 0

%0:i1 = var ; reservedconst_1

Cost = 0
first query is SAT, returning the model:
reservedconst_1: -1
0 th attempt: second query is SAT-- constant doesn't work
first query is SAT, returning the model:
reservedconst_1: 0
1 th attempt: second query is SAT-- constant doesn't work
first query is UNSAT-- no more guesses
Dataflow Pruned 0/0
There are 1 Guesses
There are 0 RHSs before deduplication
There are 0 RHSs after deduplication
got 2 candidates from LHS

-------------------------------------------------
%0:i32 = var
%1:i32 = srem %0, 100:i32
infer %1


--------------------------------
guess 0

%0:i32 = var ; reservedconst_1

Cost = 0
first query is SAT, returning the model:
reservedconst_1: 0
0 th attempt: second query is SAT-- constant doesn't work
first query is SAT, returning the model:
reservedconst_1: 85
1 th attempt: second query is SAT-- constant doesn't work
first query is UNSAT-- no more guesses

--------------------------------
guess 1

%0:i32 = var

Cost = 0
second query is SAT-- constant doesn't work
Dataflow Pruned 0/0
There are 2 Guesses
There are 0 RHSs before deduplication
There are 0 RHSs after deduplication
got 3 candidates from LHS

-------------------------------------------------
%0:i32 = var
%1:i32 = srem %0, 100:i32
%2:i1 = ne 0:i32, %1
infer %2


--------------------------------
guess 0

%0:i1 = var ; reservedconst_1

Cost = 0
first query is SAT, returning the model:
reservedconst_1: 0
0 th attempt: second query is SAT-- constant doesn't work
first query is SAT, returning the model:
reservedconst_1: -1
1 th attempt: second query is SAT-- constant doesn't work
first query is UNSAT-- no more guesses
Dataflow Pruned 0/0
There are 1 Guesses
There are 0 RHSs before deduplication
There are 0 RHSs after deduplication
got 2 candidates from LHS

-------------------------------------------------
%0:i32 = var
%1:i32 = srem %0, 400:i32
infer %1


--------------------------------
guess 0

%0:i32 = var ; reservedconst_1

Cost = 0
first query is SAT, returning the model:
reservedconst_1: 0
0 th attempt: second query is SAT-- constant doesn't work
first query is SAT, returning the model:
reservedconst_1: 128
1 th attempt: second query is SAT-- constant doesn't work
first query is UNSAT-- no more guesses

--------------------------------
guess 1

%0:i32 = var

Cost = 0
second query is SAT-- constant doesn't work
Dataflow Pruned 0/0
There are 2 Guesses
There are 0 RHSs before deduplication
There are 0 RHSs after deduplication
got 3 candidates from LHS

-------------------------------------------------
%0:i32 = var
%1:i32 = srem %0, 400:i32
%2:i1 = eq 0:i32, %1
infer %2


--------------------------------
guess 0

%0:i1 = var ; reservedconst_1

Cost = 0
first query is SAT, returning the model:
reservedconst_1: -1
0 th attempt: second query is SAT-- constant doesn't work
first query is SAT, returning the model:
reservedconst_1: 0
1 th attempt: second query is SAT-- constant doesn't work
first query is UNSAT-- no more guesses
Dataflow Pruned 0/0
There are 1 Guesses
There are 0 RHSs before deduplication
There are 0 RHSs after deduplication
got 4 candidates from LHS

-------------------------------------------------
%0 = block 2
%1:i32 = var
%2:i32 = srem %1, 400:i32
%3:i1 = eq 0:i32, %2
%4:i1 = phi %0, 1:i1, %3
infer %4


--------------------------------
guess 0

%0:i1 = var ; reservedconst_1

Cost = 0
first query is SAT, returning the model:
reservedconst_1: -1
0 th attempt: second query is SAT-- constant doesn't work
first query is SAT, returning the model:
reservedconst_1: 0
1 th attempt: second query is SAT-- constant doesn't work
first query is UNSAT-- no more guesses

--------------------------------
guess 1

%0:i32 = var
%1:i32 = srem %0, 400:i32
%2:i1 = eq 0:i32, %1

Cost = 6
second query is SAT-- constant doesn't work
Dataflow Pruned 0/0
There are 2 Guesses
There are 0 RHSs before deduplication
There are 0 RHSs after deduplication
got 5 candidates from LHS

-------------------------------------------------
%0 = block 2
%1:i32 = var
%2:i32 = srem %1, 400:i32
%3:i1 = eq 0:i32, %2
%4:i1 = phi %0, 1:i1, %3
%5:i32 = zext %4
infer %5


--------------------------------
guess 0

%0:i32 = var ; reservedconst_1

Cost = 0
first query is SAT, returning the model:
reservedconst_1: 1
0 th attempt: second query is SAT-- constant doesn't work
first query is SAT, returning the model:
reservedconst_1: 0
1 th attempt: second query is SAT-- constant doesn't work
first query is UNSAT-- no more guesses

--------------------------------
guess 1

%0:i32 = var

Cost = 0
second query is SAT-- constant doesn't work

--------------------------------
guess 2

%0:i32 = var
%1:i32 = srem %0, 400:i32

Cost = 5
second query is SAT-- constant doesn't work
Dataflow Pruned 0/0
There are 3 Guesses
There are 0 RHSs before deduplication
There are 0 RHSs after deduplication
got 6 candidates from LHS

-------------------------------------------------
%0 = block 2
%1:i32 = var
%2:i32 = srem %1, 400:i32
%3:i1 = eq 0:i32, %2
%4:i1 = phi %0, 1:i1, %3
%5:i32 = zext %4
%6:i32 = addnsw 28:i32, %5
infer %6


--------------------------------
guess 0

%0:i32 = var ; reservedconst_1

Cost = 0
first query is SAT, returning the model:
reservedconst_1: 29
0 th attempt: second query is SAT-- constant doesn't work
first query is SAT, returning the model:
reservedconst_1: 28
1 th attempt: second query is SAT-- constant doesn't work
first query is UNSAT-- no more guesses

--------------------------------
guess 1

%0:i32 = var

Cost = 0
second query is SAT-- constant doesn't work

--------------------------------
guess 2

%0:i32 = var
%1:i32 = srem %0, 400:i32

Cost = 5
second query is SAT-- constant doesn't work

--------------------------------
guess 3

%0 = block 2
%1:i32 = var
%2:i32 = srem %1, 400:i32
%3:i1 = eq 0:i32, %2
%4:i1 = phi %0, 1:i1, %3
%5:i32 = zext %4

Cost = 8
second query is SAT-- constant doesn't work
Dataflow Pruned 0/0
There are 4 Guesses
There are 0 RHSs before deduplication
There are 0 RHSs after deduplication
got 8 candidates from LHS

-------------------------------------------------
%0 = block 2
%1 = block 2
%2:i32 = var
%3:i32 = srem %2, 400:i32
%4:i1 = eq 0:i32, %3
%5:i1 = phi %1, 1:i1, %4
%6:i32 = zext %5
%7:i32 = addnsw 28:i32, %6
%8:i32 = var
%9:i32 = phi %0, %7, %8
infer %9


--------------------------------
guess 0

%0:i32 = var ; reservedconst_1

Cost = 0
first query is SAT, returning the model:
reservedconst_1: 0
0 th attempt: second query is SAT-- constant doesn't work
first query is SAT, returning the model:
reservedconst_1: 29
1 th attempt: second query is SAT-- constant doesn't work
first query is UNSAT-- no more guesses

--------------------------------
guess 1

%0:i32 = var

Cost = 0
second query is SAT-- constant doesn't work

--------------------------------
guess 2

%0:i32 = var

Cost = 0
second query is SAT-- constant doesn't work

--------------------------------
guess 3

%0:i32 = var
%1:i32 = srem %0, 400:i32

Cost = 5
second query is SAT-- constant doesn't work

--------------------------------
guess 4

%0 = block 2
%1:i32 = var
%2:i32 = srem %1, 400:i32
%3:i1 = eq 0:i32, %2
%4:i1 = phi %0, 1:i1, %3
%5:i32 = zext %4

Cost = 8
second query is SAT-- constant doesn't work

--------------------------------
guess 5

%0 = block 2
%1:i32 = var
%2:i32 = srem %1, 400:i32
%3:i1 = eq 0:i32, %2
%4:i1 = phi %0, 1:i1, %3
%5:i32 = zext %4
%6:i32 = addnsw 28:i32, %5

Cost = 9
second query is SAT-- constant doesn't work
Dataflow Pruned 0/0
There are 6 Guesses
There are 0 RHSs before deduplication
There are 0 RHSs after deduplication
#########################################################
; exiting Souper's runOnFunction() for month_days()

; entering Souper's runOnFunction() for year_days()

; ModuleID = './Holidays_related_to_Easter.c.bc'
source_filename = "./Holidays_related_to_Easter.c"
target datalayout = "e-m:e-p:32:32-i64:64-n32:64-S128"
target triple = "wasm32-unknown-wasi"

%struct.date_t = type { i32, i32, i32, i32 }
%struct.easter_related_t = type { %struct.date_t, %struct.date_t, %struct.date_t, %struct.date_t, %struct.date_t }

@.str = private unnamed_addr constant [4 x i8] c"Jan\00", align 1
@.str.1 = private unnamed_addr constant [4 x i8] c"Feb\00", align 1
@.str.2 = private unnamed_addr constant [4 x i8] c"Mar\00", align 1
@.str.3 = private unnamed_addr constant [4 x i8] c"Apr\00", align 1
@.str.4 = private unnamed_addr constant [4 x i8] c"May\00", align 1
@.str.5 = private unnamed_addr constant [4 x i8] c"Jun\00", align 1
@.str.6 = private unnamed_addr constant [4 x i8] c"Jul\00", align 1
@.str.7 = private unnamed_addr constant [4 x i8] c"Aug\00", align 1
@.str.8 = private unnamed_addr constant [4 x i8] c"Sep\00", align 1
@.str.9 = private unnamed_addr constant [4 x i8] c"Oct\00", align 1
@.str.10 = private unnamed_addr constant [4 x i8] c"Nov\00", align 1
@.str.11 = private unnamed_addr constant [4 x i8] c"Dec\00", align 1
@mon_fmt = hidden global [13 x i8*] [i8* null, i8* getelementptr inbounds ([4 x i8], [4 x i8]* @.str, i32 0, i32 0), i8* getelementptr inbounds ([4 x i8], [4 x i8]* @.str.1, i32 0, i32 0), i8* getelementptr inbounds ([4 x i8], [4 x i8]* @.str.2, i32 0, i32 0), i8* getelementptr inbounds ([4 x i8], [4 x i8]* @.str.3, i32 0, i32 0), i8* getelementptr inbounds ([4 x i8], [4 x i8]* @.str.4, i32 0, i32 0), i8* getelementptr inbounds ([4 x i8], [4 x i8]* @.str.5, i32 0, i32 0), i8* getelementptr inbounds ([4 x i8], [4 x i8]* @.str.6, i32 0, i32 0), i8* getelementptr inbounds ([4 x i8], [4 x i8]* @.str.7, i32 0, i32 0), i8* getelementptr inbounds ([4 x i8], [4 x i8]* @.str.8, i32 0, i32 0), i8* getelementptr inbounds ([4 x i8], [4 x i8]* @.str.9, i32 0, i32 0), i8* getelementptr inbounds ([4 x i8], [4 x i8]* @.str.10, i32 0, i32 0), i8* getelementptr inbounds ([4 x i8], [4 x i8]* @.str.11, i32 0, i32 0)], align 16
@.str.12 = private unnamed_addr constant [4 x i8] c"Sat\00", align 1
@.str.13 = private unnamed_addr constant [4 x i8] c"Sun\00", align 1
@.str.14 = private unnamed_addr constant [4 x i8] c"Mon\00", align 1
@.str.15 = private unnamed_addr constant [4 x i8] c"Tue\00", align 1
@.str.16 = private unnamed_addr constant [4 x i8] c"Wed\00", align 1
@.str.17 = private unnamed_addr constant [4 x i8] c"Thu\00", align 1
@.str.18 = private unnamed_addr constant [4 x i8] c"Fri\00", align 1
@week_day_fmt = hidden global [8 x i8*] [i8* null, i8* getelementptr inbounds ([4 x i8], [4 x i8]* @.str.12, i32 0, i32 0), i8* getelementptr inbounds ([4 x i8], [4 x i8]* @.str.13, i32 0, i32 0), i8* getelementptr inbounds ([4 x i8], [4 x i8]* @.str.14, i32 0, i32 0), i8* getelementptr inbounds ([4 x i8], [4 x i8]* @.str.15, i32 0, i32 0), i8* getelementptr inbounds ([4 x i8], [4 x i8]* @.str.16, i32 0, i32 0), i8* getelementptr inbounds ([4 x i8], [4 x i8]* @.str.17, i32 0, i32 0), i8* getelementptr inbounds ([4 x i8], [4 x i8]* @.str.18, i32 0, i32 0)], align 16
@__const.month_days.days = private unnamed_addr constant [13 x i32] [i32 0, i32 31, i32 28, i32 31, i32 30, i32 31, i32 30, i32 31, i32 31, i32 30, i32 31, i32 30, i32 31], align 16
@year_months = hidden global i32 12, align 4
@week_days = hidden global i32 7, align 4
@.str.19 = private unnamed_addr constant [106 x i8] c"%4d Easter: %s %2d %s, Ascension: %s %2d %s, Pentecost: %s %2d %s, Trinity: %s %2d %s, Corpus: %s %2d %s\0A\00", align 1
@.str.20 = private unnamed_addr constant [81 x i8] c"Christian holidays, related to Easter, for each centennial from 400 to 2100 CE:\0A\00", align 1
@.str.21 = private unnamed_addr constant [73 x i8] c"\0AChristian holidays, related to Easter, for years from 2010 to 2020 CE:\0A\00", align 1
@llvm.used = appending global [1 x i8*] [i8* bitcast (i32 ()* @__main_void to i8*)], section "llvm.metadata"

@__main_void = alias i32 (), i32 ()* @main

; Function Attrs: noinline nounwind optnone
define hidden i32 @month_days(i32 %year, i32 %month) #0 {
entry:
  %year.addr = alloca i32, align 4
  %month.addr = alloca i32, align 4
  %days = alloca [13 x i32], align 16
  store i32 %year, i32* %year.addr, align 4
  store i32 %month, i32* %month.addr, align 4
  %0 = bitcast [13 x i32]* %days to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 16 %0, i8* align 16 bitcast ([13 x i32]* @__const.month_days.days to i8*), i32 52, i1 false)
  %1 = load i32, i32* %month.addr, align 4
  %cmp = icmp eq i32 %1, 2
  br i1 %cmp, label %cond.true, label %cond.false

cond.true:                                        ; preds = %entry
  %2 = load i32, i32* %year.addr, align 4
  %rem = srem i32 %2, 4
  %cmp1 = icmp eq i32 %rem, 0
  br i1 %cmp1, label %land.lhs.true, label %lor.rhs

land.lhs.true:                                    ; preds = %cond.true
  %3 = load i32, i32* %year.addr, align 4
  %rem2 = srem i32 %3, 100
  %cmp3 = icmp ne i32 %rem2, 0
  br i1 %cmp3, label %lor.end, label %lor.rhs

lor.rhs:                                          ; preds = %land.lhs.true, %cond.true
  %4 = load i32, i32* %year.addr, align 4
  %rem4 = srem i32 %4, 400
  %cmp5 = icmp eq i32 %rem4, 0
  br label %lor.end

lor.end:                                          ; preds = %lor.rhs, %land.lhs.true
  %5 = phi i1 [ true, %land.lhs.true ], [ %cmp5, %lor.rhs ]
  %lor.ext = zext i1 %5 to i32
  %add = add nsw i32 28, %lor.ext
  br label %cond.end

cond.false:                                       ; preds = %entry
  %6 = load i32, i32* %month.addr, align 4
  %arrayidx = getelementptr inbounds [13 x i32], [13 x i32]* %days, i32 0, i32 %6
  %7 = load i32, i32* %arrayidx, align 4
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %lor.end
  %cond = phi i32 [ %add, %lor.end ], [ %7, %cond.false ]
  ret i32 %cond
}

; Function Attrs: argmemonly nounwind willreturn
declare void @llvm.memcpy.p0i8.p0i8.i32(i8* noalias nocapture writeonly %0, i8* noalias nocapture readonly %1, i32 %2, i1 immarg %3) #1

; Function Attrs: noinline nounwind optnone
define hidden i32 @year_days(i32 %year) #0 {
entry:
  %year.addr = alloca i32, align 4
  store i32 %year, i32* %year.addr, align 4
  %0 = load i32, i32* %year.addr, align 4
  %call = call i32 @month_days(i32 %0, i32 2)
  %cmp = icmp eq i32 %call, 28
  %1 = zext i1 %cmp to i64
  %cond = select i1 %cmp, i32 365, i32 366
  ret i32 %cond
}

; Function Attrs: noinline nounwind optnone
define hidden void @plusab(%struct.date_t* noalias sret align 4 %agg.result, %struct.date_t* %date, i32 %days) #0 {
entry:
  %date.addr = alloca %struct.date_t*, align 4
  %days.addr = alloca i32, align 4
  store %struct.date_t* %date, %struct.date_t** %date.addr, align 4
  store i32 %days, i32* %days.addr, align 4
  br label %while.cond

while.cond:                                       ; preds = %while.body, %entry
  %0 = load i32, i32* %days.addr, align 4
  %cmp = icmp slt i32 %0, 0
  br i1 %cmp, label %while.body, label %while.end

while.body:                                       ; preds = %while.cond
  %1 = load %struct.date_t*, %struct.date_t** %date.addr, align 4
  %year = getelementptr inbounds %struct.date_t, %struct.date_t* %1, i32 0, i32 0
  %2 = load i32, i32* %year, align 4
  %sub = sub nsw i32 %2, 1
  store i32 %sub, i32* %year, align 4
  %3 = load %struct.date_t*, %struct.date_t** %date.addr, align 4
  %year1 = getelementptr inbounds %struct.date_t, %struct.date_t* %3, i32 0, i32 0
  %4 = load i32, i32* %year1, align 4
  %call = call i32 @year_days(i32 %4)
  %5 = load i32, i32* %days.addr, align 4
  %add = add nsw i32 %5, %call
  store i32 %add, i32* %days.addr, align 4
  br label %while.cond

while.end:                                        ; preds = %while.cond
  br label %while.cond2

while.cond2:                                      ; preds = %while.body6, %while.end
  %6 = load i32, i32* %days.addr, align 4
  %7 = load %struct.date_t*, %struct.date_t** %date.addr, align 4
  %year3 = getelementptr inbounds %struct.date_t, %struct.date_t* %7, i32 0, i32 0
  %8 = load i32, i32* %year3, align 4
  %call4 = call i32 @year_days(i32 %8)
  %cmp5 = icmp sgt i32 %6, %call4
  br i1 %cmp5, label %while.body6, label %while.end12

while.body6:                                      ; preds = %while.cond2
  %9 = load %struct.date_t*, %struct.date_t** %date.addr, align 4
  %year7 = getelementptr inbounds %struct.date_t, %struct.date_t* %9, i32 0, i32 0
  %10 = load i32, i32* %year7, align 4
  %call8 = call i32 @year_days(i32 %10)
  %11 = load i32, i32* %days.addr, align 4
  %sub9 = sub nsw i32 %11, %call8
  store i32 %sub9, i32* %days.addr, align 4
  %12 = load %struct.date_t*, %struct.date_t** %date.addr, align 4
  %year10 = getelementptr inbounds %struct.date_t, %struct.date_t* %12, i32 0, i32 0
  %13 = load i32, i32* %year10, align 4
  %add11 = add nsw i32 %13, 1
  store i32 %add11, i32* %year10, align 4
  br label %while.cond2

while.end12:                                      ; preds = %while.cond2
  %14 = load i32, i32* %days.addr, align 4
  %15 = load %struct.date_t*, %struct.date_t** %date.addr, align 4
  %month_day = getelementptr inbounds %struct.date_t, %struct.date_t* %15, i32 0, i32 2
  %16 = load i32, i32* %month_day, align 4
  %add13 = add nsw i32 %16, %14
  store i32 %add13, i32* %month_day, align 4
  br label %while.cond14

while.cond14:                                     ; preds = %if.end, %while.end12
  %17 = load %struct.date_t*, %struct.date_t** %date.addr, align 4
  %month_day15 = getelementptr inbounds %struct.date_t, %struct.date_t* %17, i32 0, i32 2
  %18 = load i32, i32* %month_day15, align 4
  %19 = load %struct.date_t*, %struct.date_t** %date.addr, align 4
  %year16 = getelementptr inbounds %struct.date_t, %struct.date_t* %19, i32 0, i32 0
  %20 = load i32, i32* %year16, align 4
  %21 = load %struct.date_t*, %struct.date_t** %date.addr, align 4
  %month = getelementptr inbounds %struct.date_t, %struct.date_t* %21, i32 0, i32 1
  %22 = load i32, i32* %month, align 4
  %call17 = call i32 @month_days(i32 %20, i32 %22)
  %cmp18 = icmp sgt i32 %18, %call17
  br i1 %cmp18, label %while.body19, label %while.end33

while.body19:                                     ; preds = %while.cond14
  %23 = load %struct.date_t*, %struct.date_t** %date.addr, align 4
  %year20 = getelementptr inbounds %struct.date_t, %struct.date_t* %23, i32 0, i32 0
  %24 = load i32, i32* %year20, align 4
  %25 = load %struct.date_t*, %struct.date_t** %date.addr, align 4
  %month21 = getelementptr inbounds %struct.date_t, %struct.date_t* %25, i32 0, i32 1
  %26 = load i32, i32* %month21, align 4
  %call22 = call i32 @month_days(i32 %24, i32 %26)
  %27 = load %struct.date_t*, %struct.date_t** %date.addr, align 4
  %month_day23 = getelementptr inbounds %struct.date_t, %struct.date_t* %27, i32 0, i32 2
  %28 = load i32, i32* %month_day23, align 4
  %sub24 = sub nsw i32 %28, %call22
  store i32 %sub24, i32* %month_day23, align 4
  %29 = load %struct.date_t*, %struct.date_t** %date.addr, align 4
  %month25 = getelementptr inbounds %struct.date_t, %struct.date_t* %29, i32 0, i32 1
  %30 = load i32, i32* %month25, align 4
  %add26 = add nsw i32 %30, 1
  store i32 %add26, i32* %month25, align 4
  %31 = load %struct.date_t*, %struct.date_t** %date.addr, align 4
  %month27 = getelementptr inbounds %struct.date_t, %struct.date_t* %31, i32 0, i32 1
  %32 = load i32, i32* %month27, align 4
  %33 = load i32, i32* @year_months, align 4
  %cmp28 = icmp sgt i32 %32, %33
  br i1 %cmp28, label %if.then, label %if.end

if.then:                                          ; preds = %while.body19
  %34 = load i32, i32* @year_months, align 4
  %35 = load %struct.date_t*, %struct.date_t** %date.addr, align 4
  %month29 = getelementptr inbounds %struct.date_t, %struct.date_t* %35, i32 0, i32 1
  %36 = load i32, i32* %month29, align 4
  %sub30 = sub nsw i32 %36, %34
  store i32 %sub30, i32* %month29, align 4
  %37 = load %struct.date_t*, %struct.date_t** %date.addr, align 4
  %year31 = getelementptr inbounds %struct.date_t, %struct.date_t* %37, i32 0, i32 0
  %38 = load i32, i32* %year31, align 4
  %add32 = add nsw i32 %38, 1
  store i32 %add32, i32* %year31, align 4
  br label %if.end

if.end:                                           ; preds = %if.then, %while.body19
  br label %while.cond14

while.end33:                                      ; preds = %while.cond14
  %39 = load %struct.date_t*, %struct.date_t** %date.addr, align 4
  %call34 = call i32 @week_day(%struct.date_t* byval(%struct.date_t) align 4 %39)
  %40 = load %struct.date_t*, %struct.date_t** %date.addr, align 4
  %week_day = getelementptr inbounds %struct.date_t, %struct.date_t* %40, i32 0, i32 3
  store i32 %call34, i32* %week_day, align 4
  %41 = load %struct.date_t*, %struct.date_t** %date.addr, align 4
  %42 = bitcast %struct.date_t* %agg.result to i8*
  %43 = bitcast %struct.date_t* %41 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 4 %42, i8* align 4 %43, i32 16, i1 false)
  ret void
}

; Function Attrs: noinline nounwind optnone
define hidden void @easter(%struct.date_t* noalias sret align 4 %agg.result, i32 %year) #0 {
entry:
  %year.addr = alloca i32, align 4
  %c = alloca i32, align 4
  %n = alloca i32, align 4
  %i = alloca i32, align 4
  %l = alloca i32, align 4
  store i32 %year, i32* %year.addr, align 4
  %0 = load i32, i32* %year.addr, align 4
  %year1 = getelementptr inbounds %struct.date_t, %struct.date_t* %agg.result, i32 0, i32 0
  store i32 %0, i32* %year1, align 4
  %1 = load i32, i32* %year.addr, align 4
  %div = sdiv i32 %1, 100
  store i32 %div, i32* %c, align 4
  %2 = load i32, i32* %year.addr, align 4
  %rem = srem i32 %2, 19
  store i32 %rem, i32* %n, align 4
  %3 = load i32, i32* %c, align 4
  %4 = load i32, i32* %c, align 4
  %div2 = sdiv i32 %4, 4
  %sub = sub nsw i32 %3, %div2
  %5 = load i32, i32* %c, align 4
  %6 = load i32, i32* %c, align 4
  %sub3 = sub nsw i32 %6, 17
  %div4 = sdiv i32 %sub3, 25
  %sub5 = sub nsw i32 %5, %div4
  %div6 = sdiv i32 %sub5, 3
  %sub7 = sub nsw i32 %sub, %div6
  %7 = load i32, i32* %n, align 4
  %mul = mul nsw i32 19, %7
  %add = add nsw i32 %sub7, %mul
  %add8 = add nsw i32 %add, 15
  %rem9 = srem i32 %add8, 30
  store i32 %rem9, i32* %i, align 4
  %8 = load i32, i32* %i, align 4
  %div10 = sdiv i32 %8, 28
  %9 = load i32, i32* %i, align 4
  %div11 = sdiv i32 %9, 28
  %10 = load i32, i32* %i, align 4
  %add12 = add nsw i32 %10, 1
  %div13 = sdiv i32 29, %add12
  %mul14 = mul nsw i32 %div11, %div13
  %11 = load i32, i32* %n, align 4
  %sub15 = sub nsw i32 21, %11
  %div16 = sdiv i32 %sub15, 11
  %mul17 = mul nsw i32 %mul14, %div16
  %sub18 = sub nsw i32 1, %mul17
  %mul19 = mul nsw i32 %div10, %sub18
  %12 = load i32, i32* %i, align 4
  %sub20 = sub nsw i32 %12, %mul19
  store i32 %sub20, i32* %i, align 4
  %13 = load i32, i32* %i, align 4
  %14 = load i32, i32* %year.addr, align 4
  %15 = load i32, i32* %year.addr, align 4
  %div21 = sdiv i32 %15, 4
  %add22 = add nsw i32 %14, %div21
  %16 = load i32, i32* %i, align 4
  %add23 = add nsw i32 %add22, %16
  %add24 = add nsw i32 %add23, 2
  %17 = load i32, i32* %c, align 4
  %sub25 = sub nsw i32 %add24, %17
  %18 = load i32, i32* %c, align 4
  %div26 = sdiv i32 %18, 4
  %add27 = add nsw i32 %sub25, %div26
  %rem28 = srem i32 %add27, 7
  %sub29 = sub nsw i32 %13, %rem28
  store i32 %sub29, i32* %l, align 4
  %19 = load i32, i32* %l, align 4
  %add30 = add nsw i32 %19, 40
  %div31 = sdiv i32 %add30, 44
  %add32 = add nsw i32 3, %div31
  %month = getelementptr inbounds %struct.date_t, %struct.date_t* %agg.result, i32 0, i32 1
  store i32 %add32, i32* %month, align 4
  %20 = load i32, i32* %l, align 4
  %add33 = add nsw i32 %20, 28
  %month34 = getelementptr inbounds %struct.date_t, %struct.date_t* %agg.result, i32 0, i32 1
  %21 = load i32, i32* %month34, align 4
  %div35 = sdiv i32 %21, 4
  %mul36 = mul nsw i32 31, %div35
  %sub37 = sub nsw i32 %add33, %mul36
  %month_day = getelementptr inbounds %struct.date_t, %struct.date_t* %agg.result, i32 0, i32 2
  store i32 %sub37, i32* %month_day, align 4
  %call = call i32 @week_day(%struct.date_t* byval(%struct.date_t) align 4 %agg.result)
  %week_day = getelementptr inbounds %struct.date_t, %struct.date_t* %agg.result, i32 0, i32 3
  store i32 %call, i32* %week_day, align 4
  ret void
}

; Function Attrs: noinline nounwind optnone
define hidden i32 @week_day(%struct.date_t* byval(%struct.date_t) align 4 %date) #0 {
entry:
  %year = alloca i32, align 4
  %month = alloca i32, align 4
  %month_day = alloca i32, align 4
  %c = alloca i32, align 4
  %year1 = getelementptr inbounds %struct.date_t, %struct.date_t* %date, i32 0, i32 0
  %0 = load i32, i32* %year1, align 4
  store i32 %0, i32* %year, align 4
  %month2 = getelementptr inbounds %struct.date_t, %struct.date_t* %date, i32 0, i32 1
  %1 = load i32, i32* %month2, align 4
  store i32 %1, i32* %month, align 4
  %month_day3 = getelementptr inbounds %struct.date_t, %struct.date_t* %date, i32 0, i32 2
  %2 = load i32, i32* %month_day3, align 4
  store i32 %2, i32* %month_day, align 4
  %3 = load i32, i32* %month, align 4
  %cmp = icmp sle i32 %3, 2
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %4 = load i32, i32* %month, align 4
  %add = add nsw i32 %4, 12
  store i32 %add, i32* %month, align 4
  %5 = load i32, i32* %year, align 4
  %sub = sub nsw i32 %5, 1
  store i32 %sub, i32* %year, align 4
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  %6 = load i32, i32* %year, align 4
  %div = sdiv i32 %6, 100
  store i32 %div, i32* %c, align 4
  %7 = load i32, i32* %year, align 4
  %rem = srem i32 %7, 100
  store i32 %rem, i32* %year, align 4
  %8 = load i32, i32* %month_day, align 4
  %9 = load i32, i32* %month, align 4
  %add4 = add nsw i32 %9, 1
  %mul = mul nsw i32 %add4, 26
  %div5 = sdiv i32 %mul, 10
  %add6 = add nsw i32 %8, %div5
  %10 = load i32, i32* %year, align 4
  %add7 = add nsw i32 %add6, %10
  %11 = load i32, i32* %year, align 4
  %div8 = sdiv i32 %11, 4
  %add9 = add nsw i32 %add7, %div8
  %12 = load i32, i32* %c, align 4
  %div10 = sdiv i32 %12, 4
  %add11 = add nsw i32 %add9, %div10
  %13 = load i32, i32* %c, align 4
  %mul12 = mul nsw i32 2, %13
  %sub13 = sub nsw i32 %add11, %mul12
  %rem14 = srem i32 %sub13, 7
  %add15 = add nsw i32 %rem14, 7
  %rem16 = srem i32 %add15, 7
  %add17 = add nsw i32 1, %rem16
  ret i32 %add17
}

; Function Attrs: noinline nounwind optnone
define hidden void @easter_related_init(%struct.easter_related_t* noalias sret align 4 %agg.result, i32 %year) #0 {
entry:
  %year.addr = alloca i32, align 4
  %date = alloca %struct.date_t, align 4
  %tmp = alloca %struct.date_t, align 4
  %tmp1 = alloca %struct.date_t, align 4
  %tmp2 = alloca %struct.date_t, align 4
  %tmp3 = alloca %struct.date_t, align 4
  %tmp4 = alloca %struct.date_t, align 4
  store i32 %year, i32* %year.addr, align 4
  %easter = getelementptr inbounds %struct.easter_related_t, %struct.easter_related_t* %agg.result, i32 0, i32 0
  %0 = load i32, i32* %year.addr, align 4
  call void @easter(%struct.date_t* sret align 4 %tmp, i32 %0)
  %1 = bitcast %struct.date_t* %date to i8*
  %2 = bitcast %struct.date_t* %tmp to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 4 %1, i8* align 4 %2, i32 16, i1 false)
  %3 = bitcast %struct.date_t* %easter to i8*
  %4 = bitcast %struct.date_t* %date to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 4 %3, i8* align 4 %4, i32 16, i1 false)
  %ascension = getelementptr inbounds %struct.easter_related_t, %struct.easter_related_t* %agg.result, i32 0, i32 1
  call void @plusab(%struct.date_t* sret align 4 %tmp1, %struct.date_t* %date, i32 39)
  %5 = bitcast %struct.date_t* %ascension to i8*
  %6 = bitcast %struct.date_t* %tmp1 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 4 %5, i8* align 4 %6, i32 16, i1 false)
  %pentecost = getelementptr inbounds %struct.easter_related_t, %struct.easter_related_t* %agg.result, i32 0, i32 2
  call void @plusab(%struct.date_t* sret align 4 %tmp2, %struct.date_t* %date, i32 10)
  %7 = bitcast %struct.date_t* %pentecost to i8*
  %8 = bitcast %struct.date_t* %tmp2 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 4 %7, i8* align 4 %8, i32 16, i1 false)
  %trinity = getelementptr inbounds %struct.easter_related_t, %struct.easter_related_t* %agg.result, i32 0, i32 3
  call void @plusab(%struct.date_t* sret align 4 %tmp3, %struct.date_t* %date, i32 7)
  %9 = bitcast %struct.date_t* %trinity to i8*
  %10 = bitcast %struct.date_t* %tmp3 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 4 %9, i8* align 4 %10, i32 16, i1 false)
  %corpus_christi = getelementptr inbounds %struct.easter_related_t, %struct.easter_related_t* %agg.result, i32 0, i32 4
  call void @plusab(%struct.date_t* sret align 4 %tmp4, %struct.date_t* %date, i32 4)
  %11 = bitcast %struct.date_t* %corpus_christi to i8*
  %12 = bitcast %struct.date_t* %tmp4 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 4 %11, i8* align 4 %12, i32 16, i1 false)
  ret void
}

; Function Attrs: noinline nounwind optnone
define hidden void @easter_related_print(i32 %year) #0 {
entry:
  %year.addr = alloca i32, align 4
  %holidays = alloca %struct.easter_related_t, align 4
  store i32 %year, i32* %year.addr, align 4
  %0 = load i32, i32* %year.addr, align 4
  call void @easter_related_init(%struct.easter_related_t* sret align 4 %holidays, i32 %0)
  %1 = load i32, i32* %year.addr, align 4
  %easter = getelementptr inbounds %struct.easter_related_t, %struct.easter_related_t* %holidays, i32 0, i32 0
  %week_day = getelementptr inbounds %struct.date_t, %struct.date_t* %easter, i32 0, i32 3
  %2 = load i32, i32* %week_day, align 4
  %arrayidx = getelementptr inbounds [8 x i8*], [8 x i8*]* @week_day_fmt, i32 0, i32 %2
  %3 = load i8*, i8** %arrayidx, align 4
  %easter1 = getelementptr inbounds %struct.easter_related_t, %struct.easter_related_t* %holidays, i32 0, i32 0
  %month_day = getelementptr inbounds %struct.date_t, %struct.date_t* %easter1, i32 0, i32 2
  %4 = load i32, i32* %month_day, align 4
  %easter2 = getelementptr inbounds %struct.easter_related_t, %struct.easter_related_t* %holidays, i32 0, i32 0
  %month = getelementptr inbounds %struct.date_t, %struct.date_t* %easter2, i32 0, i32 1
  %5 = load i32, i32* %month, align 4
  %arrayidx3 = getelementptr inbounds [13 x i8*], [13 x i8*]* @mon_fmt, i32 0, i32 %5
  %6 = load i8*, i8** %arrayidx3, align 4
  %ascension = getelementptr inbounds %struct.easter_related_t, %struct.easter_related_t* %holidays, i32 0, i32 1
  %week_day4 = getelementptr inbounds %struct.date_t, %struct.date_t* %ascension, i32 0, i32 3
  %7 = load i32, i32* %week_day4, align 4
  %arrayidx5 = getelementptr inbounds [8 x i8*], [8 x i8*]* @week_day_fmt, i32 0, i32 %7
  %8 = load i8*, i8** %arrayidx5, align 4
  %ascension6 = getelementptr inbounds %struct.easter_related_t, %struct.easter_related_t* %holidays, i32 0, i32 1
  %month_day7 = getelementptr inbounds %struct.date_t, %struct.date_t* %ascension6, i32 0, i32 2
  %9 = load i32, i32* %month_day7, align 4
  %ascension8 = getelementptr inbounds %struct.easter_related_t, %struct.easter_related_t* %holidays, i32 0, i32 1
  %month9 = getelementptr inbounds %struct.date_t, %struct.date_t* %ascension8, i32 0, i32 1
  %10 = load i32, i32* %month9, align 4
  %arrayidx10 = getelementptr inbounds [13 x i8*], [13 x i8*]* @mon_fmt, i32 0, i32 %10
  %11 = load i8*, i8** %arrayidx10, align 4
  %pentecost = getelementptr inbounds %struct.easter_related_t, %struct.easter_related_t* %holidays, i32 0, i32 2
  %week_day11 = getelementptr inbounds %struct.date_t, %struct.date_t* %pentecost, i32 0, i32 3
  %12 = load i32, i32* %week_day11, align 4
  %arrayidx12 = getelementptr inbounds [8 x i8*], [8 x i8*]* @week_day_fmt, i32 0, i32 %12
  %13 = load i8*, i8** %arrayidx12, align 4
  %pentecost13 = getelementptr inbounds %struct.easter_related_t, %struct.easter_related_t* %holidays, i32 0, i32 2
  %month_day14 = getelementptr inbounds %struct.date_t, %struct.date_t* %pentecost13, i32 0, i32 2
  %14 = load i32, i32* %month_day14, align 4
  %pentecost15 = getelementptr inbounds %struct.easter_related_t, %struct.easter_related_t* %holidays, i32 0, i32 2
  %month16 = getelementptr inbounds %struct.date_t, %struct.date_t* %pentecost15, i32 0, i32 1
  %15 = load i32, i32* %month16, align 4
  %arrayidx17 = getelementptr inbounds [13 x i8*], [13 x i8*]* @mon_fmt, i32 0, i32 %15
  %16 = load i8*, i8** %arrayidx17, align 4
  %trinity = getelementptr inbounds %struct.easter_related_t, %struct.easter_related_t* %holidays, i32 0, i32 3
  %week_day18 = getelementptr inbounds %struct.date_t, %struct.date_t* %trinity, i32 0, i32 3
  %17 = load i32, i32* %week_day18, align 4
  %arrayidx19 = getelementptr inbounds [8 x i8*], [8 x i8*]* @week_day_fmt, i32 0, i32 %17
  %18 = load i8*, i8** %arrayidx19, align 4
  %trinity20 = getelementptr inbounds %struct.easter_related_t, %struct.easter_related_t* %holidays, i32 0, i32 3
  %month_day21 = getelementptr inbounds %struct.date_t, %struct.date_t* %trinity20, i32 0, i32 2
  %19 = load i32, i32* %month_day21, align 4
  %trinity22 = getelementptr inbounds %struct.easter_related_t, %struct.easter_related_t* %holidays, i32 0, i32 3
  %month23 = getelementptr inbounds %struct.date_t, %struct.date_t* %trinity22, i32 0, i32 1
  %20 = load i32, i32* %month23, align 4
  %arrayidx24 = getelementptr inbounds [13 x i8*], [13 x i8*]* @mon_fmt, i32 0, i32 %20
  %21 = load i8*, i8** %arrayidx24, align 4
  %corpus_christi = getelementptr inbounds %struct.easter_related_t, %struct.easter_related_t* %holidays, i32 0, i32 4
  %week_day25 = getelementptr inbounds %struct.date_t, %struct.date_t* %corpus_christi, i32 0, i32 3
  %22 = load i32, i32* %week_day25, align 4
  %arrayidx26 = getelementptr inbounds [8 x i8*], [8 x i8*]* @week_day_fmt, i32 0, i32 %22
  %23 = load i8*, i8** %arrayidx26, align 4
  %corpus_christi27 = getelementptr inbounds %struct.easter_related_t, %struct.easter_related_t* %holidays, i32 0, i32 4
  %month_day28 = getelementptr inbounds %struct.date_t, %struct.date_t* %corpus_christi27, i32 0, i32 2
  %24 = load i32, i32* %month_day28, align 4
  %corpus_christi29 = getelementptr inbounds %struct.easter_related_t, %struct.easter_related_t* %holidays, i32 0, i32 4
  %month30 = getelementptr inbounds %struct.date_t, %struct.date_t* %corpus_christi29, i32 0, i32 1
  %25 = load i32, i32* %month30, align 4
  %arrayidx31 = getelementptr inbounds [13 x i8*], [13 x i8*]* @mon_fmt, i32 0, i32 %25
  %26 = load i8*, i8** %arrayidx31, align 4
  %call = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([106 x i8], [106 x i8]* @.str.19, i32 0, i32 0), i32 %1, i8* %3, i32 %4, i8* %6, i8* %8, i32 %9, i8* %11, i8* %13, i32 %14, i8* %16, i8* %18, i32 %19, i8* %21, i8* %23, i32 %24, i8* %26)
  ret void
}

declare i32 @printf(i8* %0, ...) #2

; Function Attrs: noinline nounwind optnone
define hidden i32 @main() #0 {
entry:
  %retval = alloca i32, align 4
  %year = alloca i32, align 4
  store i32 0, i32* %retval, align 4
  %call = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([81 x i8], [81 x i8]* @.str.20, i32 0, i32 0))
  store i32 400, i32* %year, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %0 = load i32, i32* %year, align 4
  %cmp = icmp sle i32 %0, 2100
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %1 = load i32, i32* %year, align 4
  call void @easter_related_print(i32 %1)
  br label %for.inc

for.inc:                                          ; preds = %for.body
  %2 = load i32, i32* %year, align 4
  %add = add nsw i32 %2, 100
  store i32 %add, i32* %year, align 4
  br label %for.cond

for.end:                                          ; preds = %for.cond
  %call1 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([73 x i8], [73 x i8]* @.str.21, i32 0, i32 0))
  store i32 2010, i32* %year, align 4
  br label %for.cond2

for.cond2:                                        ; preds = %for.inc5, %for.end
  %3 = load i32, i32* %year, align 4
  %cmp3 = icmp sle i32 %3, 2020
  br i1 %cmp3, label %for.body4, label %for.end6

for.body4:                                        ; preds = %for.cond2
  %4 = load i32, i32* %year, align 4
  call void @easter_related_print(i32 %4)
  br label %for.inc5

for.inc5:                                         ; preds = %for.body4
  %5 = load i32, i32* %year, align 4
  %inc = add nsw i32 %5, 1
  store i32 %inc, i32* %year, align 4
  br label %for.cond2

for.end6:                                         ; preds = %for.cond2
  ret i32 0
}

attributes #0 = { noinline nounwind optnone "correctly-rounded-divide-sqrt-fp-math"="false" "disable-tail-calls"="false" "frame-pointer"="none" "less-precise-fpmad"="false" "min-legal-vector-width"="0" "no-infs-fp-math"="false" "no-jump-tables"="false" "no-nans-fp-math"="false" "no-signed-zeros-fp-math"="false" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="generic" "unsafe-fp-math"="false" "use-soft-float"="false" }
attributes #1 = { argmemonly nounwind willreturn }
attributes #2 = { "correctly-rounded-divide-sqrt-fp-math"="false" "disable-tail-calls"="false" "frame-pointer"="none" "less-precise-fpmad"="false" "no-infs-fp-math"="false" "no-nans-fp-math"="false" "no-signed-zeros-fp-math"="false" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="generic" "unsafe-fp-math"="false" "use-soft-float"="false" }

!llvm.module.flags = !{!0}
!llvm.ident = !{!1}

!0 = !{i32 1, !"wchar_size", i32 4}
!1 = !{!"clang version 11.0.0 (https://github.com/Jacarte/llvm-project.git 0f6dea67136cc1e0b3d200eb2bb165628970c44b)"}

; extracted candidates

; *****
; For LLVM instruction:
;  %0 = load i32, i32* %year.addr, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %call = call i32 @month_days(i32 %0, i32 2)
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %cmp = icmp eq i32 %call, 28
; Looking for a replacement for:
%0:i32 = var
%1:i1 = eq 28:i32, %0
infer %1

; *****
; For LLVM instruction:
;  %cond = select i1 %cmp, i32 365, i32 366
; Looking for a replacement for:
%0:i32 = var
%1:i1 = eq 28:i32, %0 (hasExternalUses)
%2:i32 = select %1, 365:i32, 366:i32
infer %2
got 2 candidates from LHS

-------------------------------------------------
%0:i32 = var
%1:i1 = eq 28:i32, %0
infer %1


--------------------------------
guess 0

%0:i1 = var ; reservedconst_1

Cost = 0
first query is SAT, returning the model:
reservedconst_1: 0
0 th attempt: second query is SAT-- constant doesn't work
first query is SAT, returning the model:
reservedconst_1: -1
1 th attempt: second query is SAT-- constant doesn't work
first query is UNSAT-- no more guesses
Dataflow Pruned 0/0
There are 1 Guesses
There are 0 RHSs before deduplication
There are 0 RHSs after deduplication
got 3 candidates from LHS

-------------------------------------------------
%0:i32 = var
%1:i1 = eq 28:i32, %0 (hasExternalUses)
%2:i32 = select %1, 365:i32, 366:i32
infer %2


--------------------------------
guess 0

%0:i32 = var ; reservedconst_1

Cost = 0
first query is SAT, returning the model:
reservedconst_1: 366
0 th attempt: second query is SAT-- constant doesn't work
first query is SAT, returning the model:
reservedconst_1: 365
1 th attempt: second query is SAT-- constant doesn't work
first query is UNSAT-- no more guesses

--------------------------------
guess 1

%0:i32 = var

Cost = 0
second query is SAT-- constant doesn't work
Dataflow Pruned 0/0
There are 2 Guesses
There are 0 RHSs before deduplication
There are 0 RHSs after deduplication
#########################################################
; exiting Souper's runOnFunction() for year_days()

; entering Souper's runOnFunction() for plusab()

; ModuleID = './Holidays_related_to_Easter.c.bc'
source_filename = "./Holidays_related_to_Easter.c"
target datalayout = "e-m:e-p:32:32-i64:64-n32:64-S128"
target triple = "wasm32-unknown-wasi"

%struct.date_t = type { i32, i32, i32, i32 }
%struct.easter_related_t = type { %struct.date_t, %struct.date_t, %struct.date_t, %struct.date_t, %struct.date_t }

@.str = private unnamed_addr constant [4 x i8] c"Jan\00", align 1
@.str.1 = private unnamed_addr constant [4 x i8] c"Feb\00", align 1
@.str.2 = private unnamed_addr constant [4 x i8] c"Mar\00", align 1
@.str.3 = private unnamed_addr constant [4 x i8] c"Apr\00", align 1
@.str.4 = private unnamed_addr constant [4 x i8] c"May\00", align 1
@.str.5 = private unnamed_addr constant [4 x i8] c"Jun\00", align 1
@.str.6 = private unnamed_addr constant [4 x i8] c"Jul\00", align 1
@.str.7 = private unnamed_addr constant [4 x i8] c"Aug\00", align 1
@.str.8 = private unnamed_addr constant [4 x i8] c"Sep\00", align 1
@.str.9 = private unnamed_addr constant [4 x i8] c"Oct\00", align 1
@.str.10 = private unnamed_addr constant [4 x i8] c"Nov\00", align 1
@.str.11 = private unnamed_addr constant [4 x i8] c"Dec\00", align 1
@mon_fmt = hidden global [13 x i8*] [i8* null, i8* getelementptr inbounds ([4 x i8], [4 x i8]* @.str, i32 0, i32 0), i8* getelementptr inbounds ([4 x i8], [4 x i8]* @.str.1, i32 0, i32 0), i8* getelementptr inbounds ([4 x i8], [4 x i8]* @.str.2, i32 0, i32 0), i8* getelementptr inbounds ([4 x i8], [4 x i8]* @.str.3, i32 0, i32 0), i8* getelementptr inbounds ([4 x i8], [4 x i8]* @.str.4, i32 0, i32 0), i8* getelementptr inbounds ([4 x i8], [4 x i8]* @.str.5, i32 0, i32 0), i8* getelementptr inbounds ([4 x i8], [4 x i8]* @.str.6, i32 0, i32 0), i8* getelementptr inbounds ([4 x i8], [4 x i8]* @.str.7, i32 0, i32 0), i8* getelementptr inbounds ([4 x i8], [4 x i8]* @.str.8, i32 0, i32 0), i8* getelementptr inbounds ([4 x i8], [4 x i8]* @.str.9, i32 0, i32 0), i8* getelementptr inbounds ([4 x i8], [4 x i8]* @.str.10, i32 0, i32 0), i8* getelementptr inbounds ([4 x i8], [4 x i8]* @.str.11, i32 0, i32 0)], align 16
@.str.12 = private unnamed_addr constant [4 x i8] c"Sat\00", align 1
@.str.13 = private unnamed_addr constant [4 x i8] c"Sun\00", align 1
@.str.14 = private unnamed_addr constant [4 x i8] c"Mon\00", align 1
@.str.15 = private unnamed_addr constant [4 x i8] c"Tue\00", align 1
@.str.16 = private unnamed_addr constant [4 x i8] c"Wed\00", align 1
@.str.17 = private unnamed_addr constant [4 x i8] c"Thu\00", align 1
@.str.18 = private unnamed_addr constant [4 x i8] c"Fri\00", align 1
@week_day_fmt = hidden global [8 x i8*] [i8* null, i8* getelementptr inbounds ([4 x i8], [4 x i8]* @.str.12, i32 0, i32 0), i8* getelementptr inbounds ([4 x i8], [4 x i8]* @.str.13, i32 0, i32 0), i8* getelementptr inbounds ([4 x i8], [4 x i8]* @.str.14, i32 0, i32 0), i8* getelementptr inbounds ([4 x i8], [4 x i8]* @.str.15, i32 0, i32 0), i8* getelementptr inbounds ([4 x i8], [4 x i8]* @.str.16, i32 0, i32 0), i8* getelementptr inbounds ([4 x i8], [4 x i8]* @.str.17, i32 0, i32 0), i8* getelementptr inbounds ([4 x i8], [4 x i8]* @.str.18, i32 0, i32 0)], align 16
@__const.month_days.days = private unnamed_addr constant [13 x i32] [i32 0, i32 31, i32 28, i32 31, i32 30, i32 31, i32 30, i32 31, i32 31, i32 30, i32 31, i32 30, i32 31], align 16
@year_months = hidden global i32 12, align 4
@week_days = hidden global i32 7, align 4
@.str.19 = private unnamed_addr constant [106 x i8] c"%4d Easter: %s %2d %s, Ascension: %s %2d %s, Pentecost: %s %2d %s, Trinity: %s %2d %s, Corpus: %s %2d %s\0A\00", align 1
@.str.20 = private unnamed_addr constant [81 x i8] c"Christian holidays, related to Easter, for each centennial from 400 to 2100 CE:\0A\00", align 1
@.str.21 = private unnamed_addr constant [73 x i8] c"\0AChristian holidays, related to Easter, for years from 2010 to 2020 CE:\0A\00", align 1
@llvm.used = appending global [1 x i8*] [i8* bitcast (i32 ()* @__main_void to i8*)], section "llvm.metadata"

@__main_void = alias i32 (), i32 ()* @main

; Function Attrs: noinline nounwind optnone
define hidden i32 @month_days(i32 %year, i32 %month) #0 {
entry:
  %year.addr = alloca i32, align 4
  %month.addr = alloca i32, align 4
  %days = alloca [13 x i32], align 16
  store i32 %year, i32* %year.addr, align 4
  store i32 %month, i32* %month.addr, align 4
  %0 = bitcast [13 x i32]* %days to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 16 %0, i8* align 16 bitcast ([13 x i32]* @__const.month_days.days to i8*), i32 52, i1 false)
  %1 = load i32, i32* %month.addr, align 4
  %cmp = icmp eq i32 %1, 2
  br i1 %cmp, label %cond.true, label %cond.false

cond.true:                                        ; preds = %entry
  %2 = load i32, i32* %year.addr, align 4
  %rem = srem i32 %2, 4
  %cmp1 = icmp eq i32 %rem, 0
  br i1 %cmp1, label %land.lhs.true, label %lor.rhs

land.lhs.true:                                    ; preds = %cond.true
  %3 = load i32, i32* %year.addr, align 4
  %rem2 = srem i32 %3, 100
  %cmp3 = icmp ne i32 %rem2, 0
  br i1 %cmp3, label %lor.end, label %lor.rhs

lor.rhs:                                          ; preds = %land.lhs.true, %cond.true
  %4 = load i32, i32* %year.addr, align 4
  %rem4 = srem i32 %4, 400
  %cmp5 = icmp eq i32 %rem4, 0
  br label %lor.end

lor.end:                                          ; preds = %lor.rhs, %land.lhs.true
  %5 = phi i1 [ true, %land.lhs.true ], [ %cmp5, %lor.rhs ]
  %lor.ext = zext i1 %5 to i32
  %add = add nsw i32 28, %lor.ext
  br label %cond.end

cond.false:                                       ; preds = %entry
  %6 = load i32, i32* %month.addr, align 4
  %arrayidx = getelementptr inbounds [13 x i32], [13 x i32]* %days, i32 0, i32 %6
  %7 = load i32, i32* %arrayidx, align 4
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %lor.end
  %cond = phi i32 [ %add, %lor.end ], [ %7, %cond.false ]
  ret i32 %cond
}

; Function Attrs: argmemonly nounwind willreturn
declare void @llvm.memcpy.p0i8.p0i8.i32(i8* noalias nocapture writeonly %0, i8* noalias nocapture readonly %1, i32 %2, i1 immarg %3) #1

; Function Attrs: noinline nounwind optnone
define hidden i32 @year_days(i32 %year) #0 {
entry:
  %year.addr = alloca i32, align 4
  store i32 %year, i32* %year.addr, align 4
  %0 = load i32, i32* %year.addr, align 4
  %call = call i32 @month_days(i32 %0, i32 2)
  %cmp = icmp eq i32 %call, 28
  %1 = zext i1 %cmp to i64
  %cond = select i1 %cmp, i32 365, i32 366
  ret i32 %cond
}

; Function Attrs: noinline nounwind optnone
define hidden void @plusab(%struct.date_t* noalias sret align 4 %agg.result, %struct.date_t* %date, i32 %days) #0 {
entry:
  %date.addr = alloca %struct.date_t*, align 4
  %days.addr = alloca i32, align 4
  store %struct.date_t* %date, %struct.date_t** %date.addr, align 4
  store i32 %days, i32* %days.addr, align 4
  br label %while.cond

while.cond:                                       ; preds = %while.body, %entry
  %0 = load i32, i32* %days.addr, align 4
  %cmp = icmp slt i32 %0, 0
  br i1 %cmp, label %while.body, label %while.end

while.body:                                       ; preds = %while.cond
  %1 = load %struct.date_t*, %struct.date_t** %date.addr, align 4
  %year = getelementptr inbounds %struct.date_t, %struct.date_t* %1, i32 0, i32 0
  %2 = load i32, i32* %year, align 4
  %sub = sub nsw i32 %2, 1
  store i32 %sub, i32* %year, align 4
  %3 = load %struct.date_t*, %struct.date_t** %date.addr, align 4
  %year1 = getelementptr inbounds %struct.date_t, %struct.date_t* %3, i32 0, i32 0
  %4 = load i32, i32* %year1, align 4
  %call = call i32 @year_days(i32 %4)
  %5 = load i32, i32* %days.addr, align 4
  %add = add nsw i32 %5, %call
  store i32 %add, i32* %days.addr, align 4
  br label %while.cond

while.end:                                        ; preds = %while.cond
  br label %while.cond2

while.cond2:                                      ; preds = %while.body6, %while.end
  %6 = load i32, i32* %days.addr, align 4
  %7 = load %struct.date_t*, %struct.date_t** %date.addr, align 4
  %year3 = getelementptr inbounds %struct.date_t, %struct.date_t* %7, i32 0, i32 0
  %8 = load i32, i32* %year3, align 4
  %call4 = call i32 @year_days(i32 %8)
  %cmp5 = icmp sgt i32 %6, %call4
  br i1 %cmp5, label %while.body6, label %while.end12

while.body6:                                      ; preds = %while.cond2
  %9 = load %struct.date_t*, %struct.date_t** %date.addr, align 4
  %year7 = getelementptr inbounds %struct.date_t, %struct.date_t* %9, i32 0, i32 0
  %10 = load i32, i32* %year7, align 4
  %call8 = call i32 @year_days(i32 %10)
  %11 = load i32, i32* %days.addr, align 4
  %sub9 = sub nsw i32 %11, %call8
  store i32 %sub9, i32* %days.addr, align 4
  %12 = load %struct.date_t*, %struct.date_t** %date.addr, align 4
  %year10 = getelementptr inbounds %struct.date_t, %struct.date_t* %12, i32 0, i32 0
  %13 = load i32, i32* %year10, align 4
  %add11 = add nsw i32 %13, 1
  store i32 %add11, i32* %year10, align 4
  br label %while.cond2

while.end12:                                      ; preds = %while.cond2
  %14 = load i32, i32* %days.addr, align 4
  %15 = load %struct.date_t*, %struct.date_t** %date.addr, align 4
  %month_day = getelementptr inbounds %struct.date_t, %struct.date_t* %15, i32 0, i32 2
  %16 = load i32, i32* %month_day, align 4
  %add13 = add nsw i32 %16, %14
  store i32 %add13, i32* %month_day, align 4
  br label %while.cond14

while.cond14:                                     ; preds = %if.end, %while.end12
  %17 = load %struct.date_t*, %struct.date_t** %date.addr, align 4
  %month_day15 = getelementptr inbounds %struct.date_t, %struct.date_t* %17, i32 0, i32 2
  %18 = load i32, i32* %month_day15, align 4
  %19 = load %struct.date_t*, %struct.date_t** %date.addr, align 4
  %year16 = getelementptr inbounds %struct.date_t, %struct.date_t* %19, i32 0, i32 0
  %20 = load i32, i32* %year16, align 4
  %21 = load %struct.date_t*, %struct.date_t** %date.addr, align 4
  %month = getelementptr inbounds %struct.date_t, %struct.date_t* %21, i32 0, i32 1
  %22 = load i32, i32* %month, align 4
  %call17 = call i32 @month_days(i32 %20, i32 %22)
  %cmp18 = icmp sgt i32 %18, %call17
  br i1 %cmp18, label %while.body19, label %while.end33

while.body19:                                     ; preds = %while.cond14
  %23 = load %struct.date_t*, %struct.date_t** %date.addr, align 4
  %year20 = getelementptr inbounds %struct.date_t, %struct.date_t* %23, i32 0, i32 0
  %24 = load i32, i32* %year20, align 4
  %25 = load %struct.date_t*, %struct.date_t** %date.addr, align 4
  %month21 = getelementptr inbounds %struct.date_t, %struct.date_t* %25, i32 0, i32 1
  %26 = load i32, i32* %month21, align 4
  %call22 = call i32 @month_days(i32 %24, i32 %26)
  %27 = load %struct.date_t*, %struct.date_t** %date.addr, align 4
  %month_day23 = getelementptr inbounds %struct.date_t, %struct.date_t* %27, i32 0, i32 2
  %28 = load i32, i32* %month_day23, align 4
  %sub24 = sub nsw i32 %28, %call22
  store i32 %sub24, i32* %month_day23, align 4
  %29 = load %struct.date_t*, %struct.date_t** %date.addr, align 4
  %month25 = getelementptr inbounds %struct.date_t, %struct.date_t* %29, i32 0, i32 1
  %30 = load i32, i32* %month25, align 4
  %add26 = add nsw i32 %30, 1
  store i32 %add26, i32* %month25, align 4
  %31 = load %struct.date_t*, %struct.date_t** %date.addr, align 4
  %month27 = getelementptr inbounds %struct.date_t, %struct.date_t* %31, i32 0, i32 1
  %32 = load i32, i32* %month27, align 4
  %33 = load i32, i32* @year_months, align 4
  %cmp28 = icmp sgt i32 %32, %33
  br i1 %cmp28, label %if.then, label %if.end

if.then:                                          ; preds = %while.body19
  %34 = load i32, i32* @year_months, align 4
  %35 = load %struct.date_t*, %struct.date_t** %date.addr, align 4
  %month29 = getelementptr inbounds %struct.date_t, %struct.date_t* %35, i32 0, i32 1
  %36 = load i32, i32* %month29, align 4
  %sub30 = sub nsw i32 %36, %34
  store i32 %sub30, i32* %month29, align 4
  %37 = load %struct.date_t*, %struct.date_t** %date.addr, align 4
  %year31 = getelementptr inbounds %struct.date_t, %struct.date_t* %37, i32 0, i32 0
  %38 = load i32, i32* %year31, align 4
  %add32 = add nsw i32 %38, 1
  store i32 %add32, i32* %year31, align 4
  br label %if.end

if.end:                                           ; preds = %if.then, %while.body19
  br label %while.cond14

while.end33:                                      ; preds = %while.cond14
  %39 = load %struct.date_t*, %struct.date_t** %date.addr, align 4
  %call34 = call i32 @week_day(%struct.date_t* byval(%struct.date_t) align 4 %39)
  %40 = load %struct.date_t*, %struct.date_t** %date.addr, align 4
  %week_day = getelementptr inbounds %struct.date_t, %struct.date_t* %40, i32 0, i32 3
  store i32 %call34, i32* %week_day, align 4
  %41 = load %struct.date_t*, %struct.date_t** %date.addr, align 4
  %42 = bitcast %struct.date_t* %agg.result to i8*
  %43 = bitcast %struct.date_t* %41 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 4 %42, i8* align 4 %43, i32 16, i1 false)
  ret void
}

; Function Attrs: noinline nounwind optnone
define hidden void @easter(%struct.date_t* noalias sret align 4 %agg.result, i32 %year) #0 {
entry:
  %year.addr = alloca i32, align 4
  %c = alloca i32, align 4
  %n = alloca i32, align 4
  %i = alloca i32, align 4
  %l = alloca i32, align 4
  store i32 %year, i32* %year.addr, align 4
  %0 = load i32, i32* %year.addr, align 4
  %year1 = getelementptr inbounds %struct.date_t, %struct.date_t* %agg.result, i32 0, i32 0
  store i32 %0, i32* %year1, align 4
  %1 = load i32, i32* %year.addr, align 4
  %div = sdiv i32 %1, 100
  store i32 %div, i32* %c, align 4
  %2 = load i32, i32* %year.addr, align 4
  %rem = srem i32 %2, 19
  store i32 %rem, i32* %n, align 4
  %3 = load i32, i32* %c, align 4
  %4 = load i32, i32* %c, align 4
  %div2 = sdiv i32 %4, 4
  %sub = sub nsw i32 %3, %div2
  %5 = load i32, i32* %c, align 4
  %6 = load i32, i32* %c, align 4
  %sub3 = sub nsw i32 %6, 17
  %div4 = sdiv i32 %sub3, 25
  %sub5 = sub nsw i32 %5, %div4
  %div6 = sdiv i32 %sub5, 3
  %sub7 = sub nsw i32 %sub, %div6
  %7 = load i32, i32* %n, align 4
  %mul = mul nsw i32 19, %7
  %add = add nsw i32 %sub7, %mul
  %add8 = add nsw i32 %add, 15
  %rem9 = srem i32 %add8, 30
  store i32 %rem9, i32* %i, align 4
  %8 = load i32, i32* %i, align 4
  %div10 = sdiv i32 %8, 28
  %9 = load i32, i32* %i, align 4
  %div11 = sdiv i32 %9, 28
  %10 = load i32, i32* %i, align 4
  %add12 = add nsw i32 %10, 1
  %div13 = sdiv i32 29, %add12
  %mul14 = mul nsw i32 %div11, %div13
  %11 = load i32, i32* %n, align 4
  %sub15 = sub nsw i32 21, %11
  %div16 = sdiv i32 %sub15, 11
  %mul17 = mul nsw i32 %mul14, %div16
  %sub18 = sub nsw i32 1, %mul17
  %mul19 = mul nsw i32 %div10, %sub18
  %12 = load i32, i32* %i, align 4
  %sub20 = sub nsw i32 %12, %mul19
  store i32 %sub20, i32* %i, align 4
  %13 = load i32, i32* %i, align 4
  %14 = load i32, i32* %year.addr, align 4
  %15 = load i32, i32* %year.addr, align 4
  %div21 = sdiv i32 %15, 4
  %add22 = add nsw i32 %14, %div21
  %16 = load i32, i32* %i, align 4
  %add23 = add nsw i32 %add22, %16
  %add24 = add nsw i32 %add23, 2
  %17 = load i32, i32* %c, align 4
  %sub25 = sub nsw i32 %add24, %17
  %18 = load i32, i32* %c, align 4
  %div26 = sdiv i32 %18, 4
  %add27 = add nsw i32 %sub25, %div26
  %rem28 = srem i32 %add27, 7
  %sub29 = sub nsw i32 %13, %rem28
  store i32 %sub29, i32* %l, align 4
  %19 = load i32, i32* %l, align 4
  %add30 = add nsw i32 %19, 40
  %div31 = sdiv i32 %add30, 44
  %add32 = add nsw i32 3, %div31
  %month = getelementptr inbounds %struct.date_t, %struct.date_t* %agg.result, i32 0, i32 1
  store i32 %add32, i32* %month, align 4
  %20 = load i32, i32* %l, align 4
  %add33 = add nsw i32 %20, 28
  %month34 = getelementptr inbounds %struct.date_t, %struct.date_t* %agg.result, i32 0, i32 1
  %21 = load i32, i32* %month34, align 4
  %div35 = sdiv i32 %21, 4
  %mul36 = mul nsw i32 31, %div35
  %sub37 = sub nsw i32 %add33, %mul36
  %month_day = getelementptr inbounds %struct.date_t, %struct.date_t* %agg.result, i32 0, i32 2
  store i32 %sub37, i32* %month_day, align 4
  %call = call i32 @week_day(%struct.date_t* byval(%struct.date_t) align 4 %agg.result)
  %week_day = getelementptr inbounds %struct.date_t, %struct.date_t* %agg.result, i32 0, i32 3
  store i32 %call, i32* %week_day, align 4
  ret void
}

; Function Attrs: noinline nounwind optnone
define hidden i32 @week_day(%struct.date_t* byval(%struct.date_t) align 4 %date) #0 {
entry:
  %year = alloca i32, align 4
  %month = alloca i32, align 4
  %month_day = alloca i32, align 4
  %c = alloca i32, align 4
  %year1 = getelementptr inbounds %struct.date_t, %struct.date_t* %date, i32 0, i32 0
  %0 = load i32, i32* %year1, align 4
  store i32 %0, i32* %year, align 4
  %month2 = getelementptr inbounds %struct.date_t, %struct.date_t* %date, i32 0, i32 1
  %1 = load i32, i32* %month2, align 4
  store i32 %1, i32* %month, align 4
  %month_day3 = getelementptr inbounds %struct.date_t, %struct.date_t* %date, i32 0, i32 2
  %2 = load i32, i32* %month_day3, align 4
  store i32 %2, i32* %month_day, align 4
  %3 = load i32, i32* %month, align 4
  %cmp = icmp sle i32 %3, 2
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %4 = load i32, i32* %month, align 4
  %add = add nsw i32 %4, 12
  store i32 %add, i32* %month, align 4
  %5 = load i32, i32* %year, align 4
  %sub = sub nsw i32 %5, 1
  store i32 %sub, i32* %year, align 4
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  %6 = load i32, i32* %year, align 4
  %div = sdiv i32 %6, 100
  store i32 %div, i32* %c, align 4
  %7 = load i32, i32* %year, align 4
  %rem = srem i32 %7, 100
  store i32 %rem, i32* %year, align 4
  %8 = load i32, i32* %month_day, align 4
  %9 = load i32, i32* %month, align 4
  %add4 = add nsw i32 %9, 1
  %mul = mul nsw i32 %add4, 26
  %div5 = sdiv i32 %mul, 10
  %add6 = add nsw i32 %8, %div5
  %10 = load i32, i32* %year, align 4
  %add7 = add nsw i32 %add6, %10
  %11 = load i32, i32* %year, align 4
  %div8 = sdiv i32 %11, 4
  %add9 = add nsw i32 %add7, %div8
  %12 = load i32, i32* %c, align 4
  %div10 = sdiv i32 %12, 4
  %add11 = add nsw i32 %add9, %div10
  %13 = load i32, i32* %c, align 4
  %mul12 = mul nsw i32 2, %13
  %sub13 = sub nsw i32 %add11, %mul12
  %rem14 = srem i32 %sub13, 7
  %add15 = add nsw i32 %rem14, 7
  %rem16 = srem i32 %add15, 7
  %add17 = add nsw i32 1, %rem16
  ret i32 %add17
}

; Function Attrs: noinline nounwind optnone
define hidden void @easter_related_init(%struct.easter_related_t* noalias sret align 4 %agg.result, i32 %year) #0 {
entry:
  %year.addr = alloca i32, align 4
  %date = alloca %struct.date_t, align 4
  %tmp = alloca %struct.date_t, align 4
  %tmp1 = alloca %struct.date_t, align 4
  %tmp2 = alloca %struct.date_t, align 4
  %tmp3 = alloca %struct.date_t, align 4
  %tmp4 = alloca %struct.date_t, align 4
  store i32 %year, i32* %year.addr, align 4
  %easter = getelementptr inbounds %struct.easter_related_t, %struct.easter_related_t* %agg.result, i32 0, i32 0
  %0 = load i32, i32* %year.addr, align 4
  call void @easter(%struct.date_t* sret align 4 %tmp, i32 %0)
  %1 = bitcast %struct.date_t* %date to i8*
  %2 = bitcast %struct.date_t* %tmp to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 4 %1, i8* align 4 %2, i32 16, i1 false)
  %3 = bitcast %struct.date_t* %easter to i8*
  %4 = bitcast %struct.date_t* %date to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 4 %3, i8* align 4 %4, i32 16, i1 false)
  %ascension = getelementptr inbounds %struct.easter_related_t, %struct.easter_related_t* %agg.result, i32 0, i32 1
  call void @plusab(%struct.date_t* sret align 4 %tmp1, %struct.date_t* %date, i32 39)
  %5 = bitcast %struct.date_t* %ascension to i8*
  %6 = bitcast %struct.date_t* %tmp1 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 4 %5, i8* align 4 %6, i32 16, i1 false)
  %pentecost = getelementptr inbounds %struct.easter_related_t, %struct.easter_related_t* %agg.result, i32 0, i32 2
  call void @plusab(%struct.date_t* sret align 4 %tmp2, %struct.date_t* %date, i32 10)
  %7 = bitcast %struct.date_t* %pentecost to i8*
  %8 = bitcast %struct.date_t* %tmp2 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 4 %7, i8* align 4 %8, i32 16, i1 false)
  %trinity = getelementptr inbounds %struct.easter_related_t, %struct.easter_related_t* %agg.result, i32 0, i32 3
  call void @plusab(%struct.date_t* sret align 4 %tmp3, %struct.date_t* %date, i32 7)
  %9 = bitcast %struct.date_t* %trinity to i8*
  %10 = bitcast %struct.date_t* %tmp3 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 4 %9, i8* align 4 %10, i32 16, i1 false)
  %corpus_christi = getelementptr inbounds %struct.easter_related_t, %struct.easter_related_t* %agg.result, i32 0, i32 4
  call void @plusab(%struct.date_t* sret align 4 %tmp4, %struct.date_t* %date, i32 4)
  %11 = bitcast %struct.date_t* %corpus_christi to i8*
  %12 = bitcast %struct.date_t* %tmp4 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 4 %11, i8* align 4 %12, i32 16, i1 false)
  ret void
}

; Function Attrs: noinline nounwind optnone
define hidden void @easter_related_print(i32 %year) #0 {
entry:
  %year.addr = alloca i32, align 4
  %holidays = alloca %struct.easter_related_t, align 4
  store i32 %year, i32* %year.addr, align 4
  %0 = load i32, i32* %year.addr, align 4
  call void @easter_related_init(%struct.easter_related_t* sret align 4 %holidays, i32 %0)
  %1 = load i32, i32* %year.addr, align 4
  %easter = getelementptr inbounds %struct.easter_related_t, %struct.easter_related_t* %holidays, i32 0, i32 0
  %week_day = getelementptr inbounds %struct.date_t, %struct.date_t* %easter, i32 0, i32 3
  %2 = load i32, i32* %week_day, align 4
  %arrayidx = getelementptr inbounds [8 x i8*], [8 x i8*]* @week_day_fmt, i32 0, i32 %2
  %3 = load i8*, i8** %arrayidx, align 4
  %easter1 = getelementptr inbounds %struct.easter_related_t, %struct.easter_related_t* %holidays, i32 0, i32 0
  %month_day = getelementptr inbounds %struct.date_t, %struct.date_t* %easter1, i32 0, i32 2
  %4 = load i32, i32* %month_day, align 4
  %easter2 = getelementptr inbounds %struct.easter_related_t, %struct.easter_related_t* %holidays, i32 0, i32 0
  %month = getelementptr inbounds %struct.date_t, %struct.date_t* %easter2, i32 0, i32 1
  %5 = load i32, i32* %month, align 4
  %arrayidx3 = getelementptr inbounds [13 x i8*], [13 x i8*]* @mon_fmt, i32 0, i32 %5
  %6 = load i8*, i8** %arrayidx3, align 4
  %ascension = getelementptr inbounds %struct.easter_related_t, %struct.easter_related_t* %holidays, i32 0, i32 1
  %week_day4 = getelementptr inbounds %struct.date_t, %struct.date_t* %ascension, i32 0, i32 3
  %7 = load i32, i32* %week_day4, align 4
  %arrayidx5 = getelementptr inbounds [8 x i8*], [8 x i8*]* @week_day_fmt, i32 0, i32 %7
  %8 = load i8*, i8** %arrayidx5, align 4
  %ascension6 = getelementptr inbounds %struct.easter_related_t, %struct.easter_related_t* %holidays, i32 0, i32 1
  %month_day7 = getelementptr inbounds %struct.date_t, %struct.date_t* %ascension6, i32 0, i32 2
  %9 = load i32, i32* %month_day7, align 4
  %ascension8 = getelementptr inbounds %struct.easter_related_t, %struct.easter_related_t* %holidays, i32 0, i32 1
  %month9 = getelementptr inbounds %struct.date_t, %struct.date_t* %ascension8, i32 0, i32 1
  %10 = load i32, i32* %month9, align 4
  %arrayidx10 = getelementptr inbounds [13 x i8*], [13 x i8*]* @mon_fmt, i32 0, i32 %10
  %11 = load i8*, i8** %arrayidx10, align 4
  %pentecost = getelementptr inbounds %struct.easter_related_t, %struct.easter_related_t* %holidays, i32 0, i32 2
  %week_day11 = getelementptr inbounds %struct.date_t, %struct.date_t* %pentecost, i32 0, i32 3
  %12 = load i32, i32* %week_day11, align 4
  %arrayidx12 = getelementptr inbounds [8 x i8*], [8 x i8*]* @week_day_fmt, i32 0, i32 %12
  %13 = load i8*, i8** %arrayidx12, align 4
  %pentecost13 = getelementptr inbounds %struct.easter_related_t, %struct.easter_related_t* %holidays, i32 0, i32 2
  %month_day14 = getelementptr inbounds %struct.date_t, %struct.date_t* %pentecost13, i32 0, i32 2
  %14 = load i32, i32* %month_day14, align 4
  %pentecost15 = getelementptr inbounds %struct.easter_related_t, %struct.easter_related_t* %holidays, i32 0, i32 2
  %month16 = getelementptr inbounds %struct.date_t, %struct.date_t* %pentecost15, i32 0, i32 1
  %15 = load i32, i32* %month16, align 4
  %arrayidx17 = getelementptr inbounds [13 x i8*], [13 x i8*]* @mon_fmt, i32 0, i32 %15
  %16 = load i8*, i8** %arrayidx17, align 4
  %trinity = getelementptr inbounds %struct.easter_related_t, %struct.easter_related_t* %holidays, i32 0, i32 3
  %week_day18 = getelementptr inbounds %struct.date_t, %struct.date_t* %trinity, i32 0, i32 3
  %17 = load i32, i32* %week_day18, align 4
  %arrayidx19 = getelementptr inbounds [8 x i8*], [8 x i8*]* @week_day_fmt, i32 0, i32 %17
  %18 = load i8*, i8** %arrayidx19, align 4
  %trinity20 = getelementptr inbounds %struct.easter_related_t, %struct.easter_related_t* %holidays, i32 0, i32 3
  %month_day21 = getelementptr inbounds %struct.date_t, %struct.date_t* %trinity20, i32 0, i32 2
  %19 = load i32, i32* %month_day21, align 4
  %trinity22 = getelementptr inbounds %struct.easter_related_t, %struct.easter_related_t* %holidays, i32 0, i32 3
  %month23 = getelementptr inbounds %struct.date_t, %struct.date_t* %trinity22, i32 0, i32 1
  %20 = load i32, i32* %month23, align 4
  %arrayidx24 = getelementptr inbounds [13 x i8*], [13 x i8*]* @mon_fmt, i32 0, i32 %20
  %21 = load i8*, i8** %arrayidx24, align 4
  %corpus_christi = getelementptr inbounds %struct.easter_related_t, %struct.easter_related_t* %holidays, i32 0, i32 4
  %week_day25 = getelementptr inbounds %struct.date_t, %struct.date_t* %corpus_christi, i32 0, i32 3
  %22 = load i32, i32* %week_day25, align 4
  %arrayidx26 = getelementptr inbounds [8 x i8*], [8 x i8*]* @week_day_fmt, i32 0, i32 %22
  %23 = load i8*, i8** %arrayidx26, align 4
  %corpus_christi27 = getelementptr inbounds %struct.easter_related_t, %struct.easter_related_t* %holidays, i32 0, i32 4
  %month_day28 = getelementptr inbounds %struct.date_t, %struct.date_t* %corpus_christi27, i32 0, i32 2
  %24 = load i32, i32* %month_day28, align 4
  %corpus_christi29 = getelementptr inbounds %struct.easter_related_t, %struct.easter_related_t* %holidays, i32 0, i32 4
  %month30 = getelementptr inbounds %struct.date_t, %struct.date_t* %corpus_christi29, i32 0, i32 1
  %25 = load i32, i32* %month30, align 4
  %arrayidx31 = getelementptr inbounds [13 x i8*], [13 x i8*]* @mon_fmt, i32 0, i32 %25
  %26 = load i8*, i8** %arrayidx31, align 4
  %call = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([106 x i8], [106 x i8]* @.str.19, i32 0, i32 0), i32 %1, i8* %3, i32 %4, i8* %6, i8* %8, i32 %9, i8* %11, i8* %13, i32 %14, i8* %16, i8* %18, i32 %19, i8* %21, i8* %23, i32 %24, i8* %26)
  ret void
}

declare i32 @printf(i8* %0, ...) #2

; Function Attrs: noinline nounwind optnone
define hidden i32 @main() #0 {
entry:
  %retval = alloca i32, align 4
  %year = alloca i32, align 4
  store i32 0, i32* %retval, align 4
  %call = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([81 x i8], [81 x i8]* @.str.20, i32 0, i32 0))
  store i32 400, i32* %year, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %0 = load i32, i32* %year, align 4
  %cmp = icmp sle i32 %0, 2100
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %1 = load i32, i32* %year, align 4
  call void @easter_related_print(i32 %1)
  br label %for.inc

for.inc:                                          ; preds = %for.body
  %2 = load i32, i32* %year, align 4
  %add = add nsw i32 %2, 100
  store i32 %add, i32* %year, align 4
  br label %for.cond

for.end:                                          ; preds = %for.cond
  %call1 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([73 x i8], [73 x i8]* @.str.21, i32 0, i32 0))
  store i32 2010, i32* %year, align 4
  br label %for.cond2

for.cond2:                                        ; preds = %for.inc5, %for.end
  %3 = load i32, i32* %year, align 4
  %cmp3 = icmp sle i32 %3, 2020
  br i1 %cmp3, label %for.body4, label %for.end6

for.body4:                                        ; preds = %for.cond2
  %4 = load i32, i32* %year, align 4
  call void @easter_related_print(i32 %4)
  br label %for.inc5

for.inc5:                                         ; preds = %for.body4
  %5 = load i32, i32* %year, align 4
  %inc = add nsw i32 %5, 1
  store i32 %inc, i32* %year, align 4
  br label %for.cond2

for.end6:                                         ; preds = %for.cond2
  ret i32 0
}

attributes #0 = { noinline nounwind optnone "correctly-rounded-divide-sqrt-fp-math"="false" "disable-tail-calls"="false" "frame-pointer"="none" "less-precise-fpmad"="false" "min-legal-vector-width"="0" "no-infs-fp-math"="false" "no-jump-tables"="false" "no-nans-fp-math"="false" "no-signed-zeros-fp-math"="false" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="generic" "unsafe-fp-math"="false" "use-soft-float"="false" }
attributes #1 = { argmemonly nounwind willreturn }
attributes #2 = { "correctly-rounded-divide-sqrt-fp-math"="false" "disable-tail-calls"="false" "frame-pointer"="none" "less-precise-fpmad"="false" "no-infs-fp-math"="false" "no-nans-fp-math"="false" "no-signed-zeros-fp-math"="false" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="generic" "unsafe-fp-math"="false" "use-soft-float"="false" }

!llvm.module.flags = !{!0}
!llvm.ident = !{!1}

!0 = !{i32 1, !"wchar_size", i32 4}
!1 = !{!"clang version 11.0.0 (https://github.com/Jacarte/llvm-project.git 0f6dea67136cc1e0b3d200eb2bb165628970c44b)"}

; extracted candidates

; *****
; For LLVM instruction:
;  %0 = load i32, i32* %days.addr, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %cmp = icmp slt i32 %0, 0
; Looking for a replacement for:
%0:i32 = var
%1:i1 = slt %0, 0:i32
infer %1

; *****
; For LLVM instruction:
;  %2 = load i32, i32* %year, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %sub = sub nsw i32 %2, 1
; Looking for a replacement for:
%0:i32 = var
%1:i32 = subnsw %0, 1:i32
infer %1

; *****
; For LLVM instruction:
;  %4 = load i32, i32* %year1, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %call = call i32 @year_days(i32 %4)
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %5 = load i32, i32* %days.addr, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %add = add nsw i32 %5, %call
; Looking for a replacement for:
%0:i32 = var
%1:i32 = var
%2:i32 = addnsw %0, %1
infer %2

; *****
; For LLVM instruction:
;  %6 = load i32, i32* %days.addr, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %8 = load i32, i32* %year3, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %call4 = call i32 @year_days(i32 %8)
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %cmp5 = icmp sgt i32 %6, %call4
; Looking for a replacement for:
%0:i32 = var
%1:i32 = var
%2:i1 = slt %0, %1
infer %2

; *****
; For LLVM instruction:
;  %10 = load i32, i32* %year7, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %call8 = call i32 @year_days(i32 %10)
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %11 = load i32, i32* %days.addr, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %sub9 = sub nsw i32 %11, %call8
; Looking for a replacement for:
%0:i32 = var
%1:i32 = var
%2:i32 = subnsw %0, %1
infer %2

; *****
; For LLVM instruction:
;  %13 = load i32, i32* %year10, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %add11 = add nsw i32 %13, 1
; Looking for a replacement for:
%0:i32 = var
%1:i32 = addnsw 1:i32, %0
infer %1

; *****
; For LLVM instruction:
;  %14 = load i32, i32* %days.addr, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %16 = load i32, i32* %month_day, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %add13 = add nsw i32 %16, %14
; Looking for a replacement for:
%0:i32 = var
%1:i32 = var
%2:i32 = addnsw %0, %1
infer %2

; *****
; For LLVM instruction:
;  %18 = load i32, i32* %month_day15, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %20 = load i32, i32* %year16, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %22 = load i32, i32* %month, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %call17 = call i32 @month_days(i32 %20, i32 %22)
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %cmp18 = icmp sgt i32 %18, %call17
; Looking for a replacement for:
%0:i32 = var
%1:i32 = var
%2:i1 = slt %0, %1
infer %2

; *****
; For LLVM instruction:
;  %24 = load i32, i32* %year20, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %26 = load i32, i32* %month21, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %call22 = call i32 @month_days(i32 %24, i32 %26)
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %28 = load i32, i32* %month_day23, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %sub24 = sub nsw i32 %28, %call22
; Looking for a replacement for:
%0:i32 = var
%1:i32 = var
%2:i32 = subnsw %0, %1
infer %2

; *****
; For LLVM instruction:
;  %30 = load i32, i32* %month25, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %add26 = add nsw i32 %30, 1
; Looking for a replacement for:
%0:i32 = var
%1:i32 = addnsw 1:i32, %0
infer %1

; *****
; For LLVM instruction:
;  %32 = load i32, i32* %month27, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %33 = load i32, i32* @year_months, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %cmp28 = icmp sgt i32 %32, %33
; Looking for a replacement for:
%0:i32 = var
%1:i32 = var
%2:i1 = slt %0, %1
infer %2

; *****
; For LLVM instruction:
;  %34 = load i32, i32* @year_months, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %36 = load i32, i32* %month29, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %sub30 = sub nsw i32 %36, %34
; Looking for a replacement for:
%0:i32 = var
%1:i32 = var
%2:i32 = subnsw %0, %1
infer %2

; *****
; For LLVM instruction:
;  %38 = load i32, i32* %year31, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %add32 = add nsw i32 %38, 1
; Looking for a replacement for:
%0:i32 = var
%1:i32 = addnsw 1:i32, %0
infer %1

; *****
; For LLVM instruction:
;  %call34 = call i32 @week_day(%struct.date_t* byval(%struct.date_t) align 4 %39)
; Looking for a replacement for:
%0:i32 = var
infer %0
got 2 candidates from LHS

-------------------------------------------------
%0:i32 = var
%1:i1 = slt %0, 0:i32
infer %1


--------------------------------
guess 0

%0:i1 = var ; reservedconst_1

Cost = 0
first query is SAT, returning the model:
reservedconst_1: 0
0 th attempt: second query is SAT-- constant doesn't work
first query is SAT, returning the model:
reservedconst_1: -1
1 th attempt: second query is SAT-- constant doesn't work
first query is UNSAT-- no more guesses
Dataflow Pruned 0/0
There are 1 Guesses
There are 0 RHSs before deduplication
There are 0 RHSs after deduplication
got 2 candidates from LHS

-------------------------------------------------
%0:i32 = var
%1:i32 = subnsw %0, 1:i32
infer %1


--------------------------------
guess 0

%0:i32 = var ; reservedconst_1

Cost = 0
first query is SAT, returning the model:
reservedconst_1: -1
0 th attempt: second query is SAT-- constant doesn't work
first query is SAT, returning the model:
reservedconst_1: 536870911
1 th attempt: second query is SAT-- constant doesn't work
first query is UNSAT-- no more guesses

--------------------------------
guess 1

%0:i32 = var

Cost = 0
second query is SAT-- constant doesn't work
Dataflow Pruned 0/0
There are 2 Guesses
There are 0 RHSs before deduplication
There are 0 RHSs after deduplication
got 3 candidates from LHS

-------------------------------------------------
%0:i32 = var
%1:i32 = var
%2:i32 = addnsw %0, %1
infer %2


--------------------------------
guess 0

%0:i32 = var ; reservedconst_1

Cost = 0
first query is SAT, returning the model:
reservedconst_1: 0
0 th attempt: second query is SAT-- constant doesn't work
first query is SAT, returning the model:
reservedconst_1: -2
1 th attempt: second query is SAT-- constant doesn't work
first query is UNSAT-- no more guesses

--------------------------------
guess 1

%0:i32 = var

Cost = 0
second query is SAT-- constant doesn't work

--------------------------------
guess 2

%0:i32 = var

Cost = 0
second query is SAT-- constant doesn't work
Dataflow Pruned 0/0
There are 3 Guesses
There are 0 RHSs before deduplication
There are 0 RHSs after deduplication
got 3 candidates from LHS

-------------------------------------------------
%0:i32 = var
%1:i32 = var
%2:i1 = slt %0, %1
infer %2


--------------------------------
guess 0

%0:i1 = var ; reservedconst_1

Cost = 0
first query is SAT, returning the model:
reservedconst_1: 0
0 th attempt: second query is SAT-- constant doesn't work
first query is SAT, returning the model:
reservedconst_1: -1
1 th attempt: second query is SAT-- constant doesn't work
first query is UNSAT-- no more guesses
Dataflow Pruned 0/0
There are 1 Guesses
There are 0 RHSs before deduplication
There are 0 RHSs after deduplication
got 3 candidates from LHS

-------------------------------------------------
%0:i32 = var
%1:i32 = var
%2:i32 = subnsw %0, %1
infer %2


--------------------------------
guess 0

%0:i32 = var ; reservedconst_1

Cost = 0
first query is SAT, returning the model:
reservedconst_1: 0
0 th attempt: second query is SAT-- constant doesn't work
first query is SAT, returning the model:
reservedconst_1: -2147483648
1 th attempt: second query is SAT-- constant doesn't work
first query is UNSAT-- no more guesses

--------------------------------
guess 1

%0:i32 = var

Cost = 0
second query is SAT-- constant doesn't work

--------------------------------
guess 2

%0:i32 = var

Cost = 0
second query is SAT-- constant doesn't work
Dataflow Pruned 0/0
There are 3 Guesses
There are 0 RHSs before deduplication
There are 0 RHSs after deduplication
got 2 candidates from LHS

-------------------------------------------------
%0:i32 = var
%1:i32 = addnsw 1:i32, %0
infer %1


--------------------------------
guess 0

%0:i32 = var ; reservedconst_1

Cost = 0
first query is SAT, returning the model:
reservedconst_1: 1
0 th attempt: second query is SAT-- constant doesn't work
first query is SAT, returning the model:
reservedconst_1: 268435457
1 th attempt: second query is SAT-- constant doesn't work
first query is UNSAT-- no more guesses

--------------------------------
guess 1

%0:i32 = var

Cost = 0
second query is SAT-- constant doesn't work
Dataflow Pruned 0/0
There are 2 Guesses
There are 0 RHSs before deduplication
There are 0 RHSs after deduplication
#########################################################
; exiting Souper's runOnFunction() for plusab()

; entering Souper's runOnFunction() for easter()

; ModuleID = './Holidays_related_to_Easter.c.bc'
source_filename = "./Holidays_related_to_Easter.c"
target datalayout = "e-m:e-p:32:32-i64:64-n32:64-S128"
target triple = "wasm32-unknown-wasi"

%struct.date_t = type { i32, i32, i32, i32 }
%struct.easter_related_t = type { %struct.date_t, %struct.date_t, %struct.date_t, %struct.date_t, %struct.date_t }

@.str = private unnamed_addr constant [4 x i8] c"Jan\00", align 1
@.str.1 = private unnamed_addr constant [4 x i8] c"Feb\00", align 1
@.str.2 = private unnamed_addr constant [4 x i8] c"Mar\00", align 1
@.str.3 = private unnamed_addr constant [4 x i8] c"Apr\00", align 1
@.str.4 = private unnamed_addr constant [4 x i8] c"May\00", align 1
@.str.5 = private unnamed_addr constant [4 x i8] c"Jun\00", align 1
@.str.6 = private unnamed_addr constant [4 x i8] c"Jul\00", align 1
@.str.7 = private unnamed_addr constant [4 x i8] c"Aug\00", align 1
@.str.8 = private unnamed_addr constant [4 x i8] c"Sep\00", align 1
@.str.9 = private unnamed_addr constant [4 x i8] c"Oct\00", align 1
@.str.10 = private unnamed_addr constant [4 x i8] c"Nov\00", align 1
@.str.11 = private unnamed_addr constant [4 x i8] c"Dec\00", align 1
@mon_fmt = hidden global [13 x i8*] [i8* null, i8* getelementptr inbounds ([4 x i8], [4 x i8]* @.str, i32 0, i32 0), i8* getelementptr inbounds ([4 x i8], [4 x i8]* @.str.1, i32 0, i32 0), i8* getelementptr inbounds ([4 x i8], [4 x i8]* @.str.2, i32 0, i32 0), i8* getelementptr inbounds ([4 x i8], [4 x i8]* @.str.3, i32 0, i32 0), i8* getelementptr inbounds ([4 x i8], [4 x i8]* @.str.4, i32 0, i32 0), i8* getelementptr inbounds ([4 x i8], [4 x i8]* @.str.5, i32 0, i32 0), i8* getelementptr inbounds ([4 x i8], [4 x i8]* @.str.6, i32 0, i32 0), i8* getelementptr inbounds ([4 x i8], [4 x i8]* @.str.7, i32 0, i32 0), i8* getelementptr inbounds ([4 x i8], [4 x i8]* @.str.8, i32 0, i32 0), i8* getelementptr inbounds ([4 x i8], [4 x i8]* @.str.9, i32 0, i32 0), i8* getelementptr inbounds ([4 x i8], [4 x i8]* @.str.10, i32 0, i32 0), i8* getelementptr inbounds ([4 x i8], [4 x i8]* @.str.11, i32 0, i32 0)], align 16
@.str.12 = private unnamed_addr constant [4 x i8] c"Sat\00", align 1
@.str.13 = private unnamed_addr constant [4 x i8] c"Sun\00", align 1
@.str.14 = private unnamed_addr constant [4 x i8] c"Mon\00", align 1
@.str.15 = private unnamed_addr constant [4 x i8] c"Tue\00", align 1
@.str.16 = private unnamed_addr constant [4 x i8] c"Wed\00", align 1
@.str.17 = private unnamed_addr constant [4 x i8] c"Thu\00", align 1
@.str.18 = private unnamed_addr constant [4 x i8] c"Fri\00", align 1
@week_day_fmt = hidden global [8 x i8*] [i8* null, i8* getelementptr inbounds ([4 x i8], [4 x i8]* @.str.12, i32 0, i32 0), i8* getelementptr inbounds ([4 x i8], [4 x i8]* @.str.13, i32 0, i32 0), i8* getelementptr inbounds ([4 x i8], [4 x i8]* @.str.14, i32 0, i32 0), i8* getelementptr inbounds ([4 x i8], [4 x i8]* @.str.15, i32 0, i32 0), i8* getelementptr inbounds ([4 x i8], [4 x i8]* @.str.16, i32 0, i32 0), i8* getelementptr inbounds ([4 x i8], [4 x i8]* @.str.17, i32 0, i32 0), i8* getelementptr inbounds ([4 x i8], [4 x i8]* @.str.18, i32 0, i32 0)], align 16
@__const.month_days.days = private unnamed_addr constant [13 x i32] [i32 0, i32 31, i32 28, i32 31, i32 30, i32 31, i32 30, i32 31, i32 31, i32 30, i32 31, i32 30, i32 31], align 16
@year_months = hidden global i32 12, align 4
@week_days = hidden global i32 7, align 4
@.str.19 = private unnamed_addr constant [106 x i8] c"%4d Easter: %s %2d %s, Ascension: %s %2d %s, Pentecost: %s %2d %s, Trinity: %s %2d %s, Corpus: %s %2d %s\0A\00", align 1
@.str.20 = private unnamed_addr constant [81 x i8] c"Christian holidays, related to Easter, for each centennial from 400 to 2100 CE:\0A\00", align 1
@.str.21 = private unnamed_addr constant [73 x i8] c"\0AChristian holidays, related to Easter, for years from 2010 to 2020 CE:\0A\00", align 1
@llvm.used = appending global [1 x i8*] [i8* bitcast (i32 ()* @__main_void to i8*)], section "llvm.metadata"

@__main_void = alias i32 (), i32 ()* @main

; Function Attrs: noinline nounwind optnone
define hidden i32 @month_days(i32 %year, i32 %month) #0 {
entry:
  %year.addr = alloca i32, align 4
  %month.addr = alloca i32, align 4
  %days = alloca [13 x i32], align 16
  store i32 %year, i32* %year.addr, align 4
  store i32 %month, i32* %month.addr, align 4
  %0 = bitcast [13 x i32]* %days to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 16 %0, i8* align 16 bitcast ([13 x i32]* @__const.month_days.days to i8*), i32 52, i1 false)
  %1 = load i32, i32* %month.addr, align 4
  %cmp = icmp eq i32 %1, 2
  br i1 %cmp, label %cond.true, label %cond.false

cond.true:                                        ; preds = %entry
  %2 = load i32, i32* %year.addr, align 4
  %rem = srem i32 %2, 4
  %cmp1 = icmp eq i32 %rem, 0
  br i1 %cmp1, label %land.lhs.true, label %lor.rhs

land.lhs.true:                                    ; preds = %cond.true
  %3 = load i32, i32* %year.addr, align 4
  %rem2 = srem i32 %3, 100
  %cmp3 = icmp ne i32 %rem2, 0
  br i1 %cmp3, label %lor.end, label %lor.rhs

lor.rhs:                                          ; preds = %land.lhs.true, %cond.true
  %4 = load i32, i32* %year.addr, align 4
  %rem4 = srem i32 %4, 400
  %cmp5 = icmp eq i32 %rem4, 0
  br label %lor.end

lor.end:                                          ; preds = %lor.rhs, %land.lhs.true
  %5 = phi i1 [ true, %land.lhs.true ], [ %cmp5, %lor.rhs ]
  %lor.ext = zext i1 %5 to i32
  %add = add nsw i32 28, %lor.ext
  br label %cond.end

cond.false:                                       ; preds = %entry
  %6 = load i32, i32* %month.addr, align 4
  %arrayidx = getelementptr inbounds [13 x i32], [13 x i32]* %days, i32 0, i32 %6
  %7 = load i32, i32* %arrayidx, align 4
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %lor.end
  %cond = phi i32 [ %add, %lor.end ], [ %7, %cond.false ]
  ret i32 %cond
}

; Function Attrs: argmemonly nounwind willreturn
declare void @llvm.memcpy.p0i8.p0i8.i32(i8* noalias nocapture writeonly %0, i8* noalias nocapture readonly %1, i32 %2, i1 immarg %3) #1

; Function Attrs: noinline nounwind optnone
define hidden i32 @year_days(i32 %year) #0 {
entry:
  %year.addr = alloca i32, align 4
  store i32 %year, i32* %year.addr, align 4
  %0 = load i32, i32* %year.addr, align 4
  %call = call i32 @month_days(i32 %0, i32 2)
  %cmp = icmp eq i32 %call, 28
  %1 = zext i1 %cmp to i64
  %cond = select i1 %cmp, i32 365, i32 366
  ret i32 %cond
}

; Function Attrs: noinline nounwind optnone
define hidden void @plusab(%struct.date_t* noalias sret align 4 %agg.result, %struct.date_t* %date, i32 %days) #0 {
entry:
  %date.addr = alloca %struct.date_t*, align 4
  %days.addr = alloca i32, align 4
  store %struct.date_t* %date, %struct.date_t** %date.addr, align 4
  store i32 %days, i32* %days.addr, align 4
  br label %while.cond

while.cond:                                       ; preds = %while.body, %entry
  %0 = load i32, i32* %days.addr, align 4
  %cmp = icmp slt i32 %0, 0
  br i1 %cmp, label %while.body, label %while.end

while.body:                                       ; preds = %while.cond
  %1 = load %struct.date_t*, %struct.date_t** %date.addr, align 4
  %year = getelementptr inbounds %struct.date_t, %struct.date_t* %1, i32 0, i32 0
  %2 = load i32, i32* %year, align 4
  %sub = sub nsw i32 %2, 1
  store i32 %sub, i32* %year, align 4
  %3 = load %struct.date_t*, %struct.date_t** %date.addr, align 4
  %year1 = getelementptr inbounds %struct.date_t, %struct.date_t* %3, i32 0, i32 0
  %4 = load i32, i32* %year1, align 4
  %call = call i32 @year_days(i32 %4)
  %5 = load i32, i32* %days.addr, align 4
  %add = add nsw i32 %5, %call
  store i32 %add, i32* %days.addr, align 4
  br label %while.cond

while.end:                                        ; preds = %while.cond
  br label %while.cond2

while.cond2:                                      ; preds = %while.body6, %while.end
  %6 = load i32, i32* %days.addr, align 4
  %7 = load %struct.date_t*, %struct.date_t** %date.addr, align 4
  %year3 = getelementptr inbounds %struct.date_t, %struct.date_t* %7, i32 0, i32 0
  %8 = load i32, i32* %year3, align 4
  %call4 = call i32 @year_days(i32 %8)
  %cmp5 = icmp sgt i32 %6, %call4
  br i1 %cmp5, label %while.body6, label %while.end12

while.body6:                                      ; preds = %while.cond2
  %9 = load %struct.date_t*, %struct.date_t** %date.addr, align 4
  %year7 = getelementptr inbounds %struct.date_t, %struct.date_t* %9, i32 0, i32 0
  %10 = load i32, i32* %year7, align 4
  %call8 = call i32 @year_days(i32 %10)
  %11 = load i32, i32* %days.addr, align 4
  %sub9 = sub nsw i32 %11, %call8
  store i32 %sub9, i32* %days.addr, align 4
  %12 = load %struct.date_t*, %struct.date_t** %date.addr, align 4
  %year10 = getelementptr inbounds %struct.date_t, %struct.date_t* %12, i32 0, i32 0
  %13 = load i32, i32* %year10, align 4
  %add11 = add nsw i32 %13, 1
  store i32 %add11, i32* %year10, align 4
  br label %while.cond2

while.end12:                                      ; preds = %while.cond2
  %14 = load i32, i32* %days.addr, align 4
  %15 = load %struct.date_t*, %struct.date_t** %date.addr, align 4
  %month_day = getelementptr inbounds %struct.date_t, %struct.date_t* %15, i32 0, i32 2
  %16 = load i32, i32* %month_day, align 4
  %add13 = add nsw i32 %16, %14
  store i32 %add13, i32* %month_day, align 4
  br label %while.cond14

while.cond14:                                     ; preds = %if.end, %while.end12
  %17 = load %struct.date_t*, %struct.date_t** %date.addr, align 4
  %month_day15 = getelementptr inbounds %struct.date_t, %struct.date_t* %17, i32 0, i32 2
  %18 = load i32, i32* %month_day15, align 4
  %19 = load %struct.date_t*, %struct.date_t** %date.addr, align 4
  %year16 = getelementptr inbounds %struct.date_t, %struct.date_t* %19, i32 0, i32 0
  %20 = load i32, i32* %year16, align 4
  %21 = load %struct.date_t*, %struct.date_t** %date.addr, align 4
  %month = getelementptr inbounds %struct.date_t, %struct.date_t* %21, i32 0, i32 1
  %22 = load i32, i32* %month, align 4
  %call17 = call i32 @month_days(i32 %20, i32 %22)
  %cmp18 = icmp sgt i32 %18, %call17
  br i1 %cmp18, label %while.body19, label %while.end33

while.body19:                                     ; preds = %while.cond14
  %23 = load %struct.date_t*, %struct.date_t** %date.addr, align 4
  %year20 = getelementptr inbounds %struct.date_t, %struct.date_t* %23, i32 0, i32 0
  %24 = load i32, i32* %year20, align 4
  %25 = load %struct.date_t*, %struct.date_t** %date.addr, align 4
  %month21 = getelementptr inbounds %struct.date_t, %struct.date_t* %25, i32 0, i32 1
  %26 = load i32, i32* %month21, align 4
  %call22 = call i32 @month_days(i32 %24, i32 %26)
  %27 = load %struct.date_t*, %struct.date_t** %date.addr, align 4
  %month_day23 = getelementptr inbounds %struct.date_t, %struct.date_t* %27, i32 0, i32 2
  %28 = load i32, i32* %month_day23, align 4
  %sub24 = sub nsw i32 %28, %call22
  store i32 %sub24, i32* %month_day23, align 4
  %29 = load %struct.date_t*, %struct.date_t** %date.addr, align 4
  %month25 = getelementptr inbounds %struct.date_t, %struct.date_t* %29, i32 0, i32 1
  %30 = load i32, i32* %month25, align 4
  %add26 = add nsw i32 %30, 1
  store i32 %add26, i32* %month25, align 4
  %31 = load %struct.date_t*, %struct.date_t** %date.addr, align 4
  %month27 = getelementptr inbounds %struct.date_t, %struct.date_t* %31, i32 0, i32 1
  %32 = load i32, i32* %month27, align 4
  %33 = load i32, i32* @year_months, align 4
  %cmp28 = icmp sgt i32 %32, %33
  br i1 %cmp28, label %if.then, label %if.end

if.then:                                          ; preds = %while.body19
  %34 = load i32, i32* @year_months, align 4
  %35 = load %struct.date_t*, %struct.date_t** %date.addr, align 4
  %month29 = getelementptr inbounds %struct.date_t, %struct.date_t* %35, i32 0, i32 1
  %36 = load i32, i32* %month29, align 4
  %sub30 = sub nsw i32 %36, %34
  store i32 %sub30, i32* %month29, align 4
  %37 = load %struct.date_t*, %struct.date_t** %date.addr, align 4
  %year31 = getelementptr inbounds %struct.date_t, %struct.date_t* %37, i32 0, i32 0
  %38 = load i32, i32* %year31, align 4
  %add32 = add nsw i32 %38, 1
  store i32 %add32, i32* %year31, align 4
  br label %if.end

if.end:                                           ; preds = %if.then, %while.body19
  br label %while.cond14

while.end33:                                      ; preds = %while.cond14
  %39 = load %struct.date_t*, %struct.date_t** %date.addr, align 4
  %call34 = call i32 @week_day(%struct.date_t* byval(%struct.date_t) align 4 %39)
  %40 = load %struct.date_t*, %struct.date_t** %date.addr, align 4
  %week_day = getelementptr inbounds %struct.date_t, %struct.date_t* %40, i32 0, i32 3
  store i32 %call34, i32* %week_day, align 4
  %41 = load %struct.date_t*, %struct.date_t** %date.addr, align 4
  %42 = bitcast %struct.date_t* %agg.result to i8*
  %43 = bitcast %struct.date_t* %41 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 4 %42, i8* align 4 %43, i32 16, i1 false)
  ret void
}

; Function Attrs: noinline nounwind optnone
define hidden void @easter(%struct.date_t* noalias sret align 4 %agg.result, i32 %year) #0 {
entry:
  %year.addr = alloca i32, align 4
  %c = alloca i32, align 4
  %n = alloca i32, align 4
  %i = alloca i32, align 4
  %l = alloca i32, align 4
  store i32 %year, i32* %year.addr, align 4
  %0 = load i32, i32* %year.addr, align 4
  %year1 = getelementptr inbounds %struct.date_t, %struct.date_t* %agg.result, i32 0, i32 0
  store i32 %0, i32* %year1, align 4
  %1 = load i32, i32* %year.addr, align 4
  %div = sdiv i32 %1, 100
  store i32 %div, i32* %c, align 4
  %2 = load i32, i32* %year.addr, align 4
  %rem = srem i32 %2, 19
  store i32 %rem, i32* %n, align 4
  %3 = load i32, i32* %c, align 4
  %4 = load i32, i32* %c, align 4
  %div2 = sdiv i32 %4, 4
  %sub = sub nsw i32 %3, %div2
  %5 = load i32, i32* %c, align 4
  %6 = load i32, i32* %c, align 4
  %sub3 = sub nsw i32 %6, 17
  %div4 = sdiv i32 %sub3, 25
  %sub5 = sub nsw i32 %5, %div4
  %div6 = sdiv i32 %sub5, 3
  %sub7 = sub nsw i32 %sub, %div6
  %7 = load i32, i32* %n, align 4
  %mul = mul nsw i32 19, %7
  %add = add nsw i32 %sub7, %mul
  %add8 = add nsw i32 %add, 15
  %rem9 = srem i32 %add8, 30
  store i32 %rem9, i32* %i, align 4
  %8 = load i32, i32* %i, align 4
  %div10 = sdiv i32 %8, 28
  %9 = load i32, i32* %i, align 4
  %div11 = sdiv i32 %9, 28
  %10 = load i32, i32* %i, align 4
  %add12 = add nsw i32 %10, 1
  %div13 = sdiv i32 29, %add12
  %mul14 = mul nsw i32 %div11, %div13
  %11 = load i32, i32* %n, align 4
  %sub15 = sub nsw i32 21, %11
  %div16 = sdiv i32 %sub15, 11
  %mul17 = mul nsw i32 %mul14, %div16
  %sub18 = sub nsw i32 1, %mul17
  %mul19 = mul nsw i32 %div10, %sub18
  %12 = load i32, i32* %i, align 4
  %sub20 = sub nsw i32 %12, %mul19
  store i32 %sub20, i32* %i, align 4
  %13 = load i32, i32* %i, align 4
  %14 = load i32, i32* %year.addr, align 4
  %15 = load i32, i32* %year.addr, align 4
  %div21 = sdiv i32 %15, 4
  %add22 = add nsw i32 %14, %div21
  %16 = load i32, i32* %i, align 4
  %add23 = add nsw i32 %add22, %16
  %add24 = add nsw i32 %add23, 2
  %17 = load i32, i32* %c, align 4
  %sub25 = sub nsw i32 %add24, %17
  %18 = load i32, i32* %c, align 4
  %div26 = sdiv i32 %18, 4
  %add27 = add nsw i32 %sub25, %div26
  %rem28 = srem i32 %add27, 7
  %sub29 = sub nsw i32 %13, %rem28
  store i32 %sub29, i32* %l, align 4
  %19 = load i32, i32* %l, align 4
  %add30 = add nsw i32 %19, 40
  %div31 = sdiv i32 %add30, 44
  %add32 = add nsw i32 3, %div31
  %month = getelementptr inbounds %struct.date_t, %struct.date_t* %agg.result, i32 0, i32 1
  store i32 %add32, i32* %month, align 4
  %20 = load i32, i32* %l, align 4
  %add33 = add nsw i32 %20, 28
  %month34 = getelementptr inbounds %struct.date_t, %struct.date_t* %agg.result, i32 0, i32 1
  %21 = load i32, i32* %month34, align 4
  %div35 = sdiv i32 %21, 4
  %mul36 = mul nsw i32 31, %div35
  %sub37 = sub nsw i32 %add33, %mul36
  %month_day = getelementptr inbounds %struct.date_t, %struct.date_t* %agg.result, i32 0, i32 2
  store i32 %sub37, i32* %month_day, align 4
  %call = call i32 @week_day(%struct.date_t* byval(%struct.date_t) align 4 %agg.result)
  %week_day = getelementptr inbounds %struct.date_t, %struct.date_t* %agg.result, i32 0, i32 3
  store i32 %call, i32* %week_day, align 4
  ret void
}

; Function Attrs: noinline nounwind optnone
define hidden i32 @week_day(%struct.date_t* byval(%struct.date_t) align 4 %date) #0 {
entry:
  %year = alloca i32, align 4
  %month = alloca i32, align 4
  %month_day = alloca i32, align 4
  %c = alloca i32, align 4
  %year1 = getelementptr inbounds %struct.date_t, %struct.date_t* %date, i32 0, i32 0
  %0 = load i32, i32* %year1, align 4
  store i32 %0, i32* %year, align 4
  %month2 = getelementptr inbounds %struct.date_t, %struct.date_t* %date, i32 0, i32 1
  %1 = load i32, i32* %month2, align 4
  store i32 %1, i32* %month, align 4
  %month_day3 = getelementptr inbounds %struct.date_t, %struct.date_t* %date, i32 0, i32 2
  %2 = load i32, i32* %month_day3, align 4
  store i32 %2, i32* %month_day, align 4
  %3 = load i32, i32* %month, align 4
  %cmp = icmp sle i32 %3, 2
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %4 = load i32, i32* %month, align 4
  %add = add nsw i32 %4, 12
  store i32 %add, i32* %month, align 4
  %5 = load i32, i32* %year, align 4
  %sub = sub nsw i32 %5, 1
  store i32 %sub, i32* %year, align 4
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  %6 = load i32, i32* %year, align 4
  %div = sdiv i32 %6, 100
  store i32 %div, i32* %c, align 4
  %7 = load i32, i32* %year, align 4
  %rem = srem i32 %7, 100
  store i32 %rem, i32* %year, align 4
  %8 = load i32, i32* %month_day, align 4
  %9 = load i32, i32* %month, align 4
  %add4 = add nsw i32 %9, 1
  %mul = mul nsw i32 %add4, 26
  %div5 = sdiv i32 %mul, 10
  %add6 = add nsw i32 %8, %div5
  %10 = load i32, i32* %year, align 4
  %add7 = add nsw i32 %add6, %10
  %11 = load i32, i32* %year, align 4
  %div8 = sdiv i32 %11, 4
  %add9 = add nsw i32 %add7, %div8
  %12 = load i32, i32* %c, align 4
  %div10 = sdiv i32 %12, 4
  %add11 = add nsw i32 %add9, %div10
  %13 = load i32, i32* %c, align 4
  %mul12 = mul nsw i32 2, %13
  %sub13 = sub nsw i32 %add11, %mul12
  %rem14 = srem i32 %sub13, 7
  %add15 = add nsw i32 %rem14, 7
  %rem16 = srem i32 %add15, 7
  %add17 = add nsw i32 1, %rem16
  ret i32 %add17
}

; Function Attrs: noinline nounwind optnone
define hidden void @easter_related_init(%struct.easter_related_t* noalias sret align 4 %agg.result, i32 %year) #0 {
entry:
  %year.addr = alloca i32, align 4
  %date = alloca %struct.date_t, align 4
  %tmp = alloca %struct.date_t, align 4
  %tmp1 = alloca %struct.date_t, align 4
  %tmp2 = alloca %struct.date_t, align 4
  %tmp3 = alloca %struct.date_t, align 4
  %tmp4 = alloca %struct.date_t, align 4
  store i32 %year, i32* %year.addr, align 4
  %easter = getelementptr inbounds %struct.easter_related_t, %struct.easter_related_t* %agg.result, i32 0, i32 0
  %0 = load i32, i32* %year.addr, align 4
  call void @easter(%struct.date_t* sret align 4 %tmp, i32 %0)
  %1 = bitcast %struct.date_t* %date to i8*
  %2 = bitcast %struct.date_t* %tmp to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 4 %1, i8* align 4 %2, i32 16, i1 false)
  %3 = bitcast %struct.date_t* %easter to i8*
  %4 = bitcast %struct.date_t* %date to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 4 %3, i8* align 4 %4, i32 16, i1 false)
  %ascension = getelementptr inbounds %struct.easter_related_t, %struct.easter_related_t* %agg.result, i32 0, i32 1
  call void @plusab(%struct.date_t* sret align 4 %tmp1, %struct.date_t* %date, i32 39)
  %5 = bitcast %struct.date_t* %ascension to i8*
  %6 = bitcast %struct.date_t* %tmp1 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 4 %5, i8* align 4 %6, i32 16, i1 false)
  %pentecost = getelementptr inbounds %struct.easter_related_t, %struct.easter_related_t* %agg.result, i32 0, i32 2
  call void @plusab(%struct.date_t* sret align 4 %tmp2, %struct.date_t* %date, i32 10)
  %7 = bitcast %struct.date_t* %pentecost to i8*
  %8 = bitcast %struct.date_t* %tmp2 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 4 %7, i8* align 4 %8, i32 16, i1 false)
  %trinity = getelementptr inbounds %struct.easter_related_t, %struct.easter_related_t* %agg.result, i32 0, i32 3
  call void @plusab(%struct.date_t* sret align 4 %tmp3, %struct.date_t* %date, i32 7)
  %9 = bitcast %struct.date_t* %trinity to i8*
  %10 = bitcast %struct.date_t* %tmp3 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 4 %9, i8* align 4 %10, i32 16, i1 false)
  %corpus_christi = getelementptr inbounds %struct.easter_related_t, %struct.easter_related_t* %agg.result, i32 0, i32 4
  call void @plusab(%struct.date_t* sret align 4 %tmp4, %struct.date_t* %date, i32 4)
  %11 = bitcast %struct.date_t* %corpus_christi to i8*
  %12 = bitcast %struct.date_t* %tmp4 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 4 %11, i8* align 4 %12, i32 16, i1 false)
  ret void
}

; Function Attrs: noinline nounwind optnone
define hidden void @easter_related_print(i32 %year) #0 {
entry:
  %year.addr = alloca i32, align 4
  %holidays = alloca %struct.easter_related_t, align 4
  store i32 %year, i32* %year.addr, align 4
  %0 = load i32, i32* %year.addr, align 4
  call void @easter_related_init(%struct.easter_related_t* sret align 4 %holidays, i32 %0)
  %1 = load i32, i32* %year.addr, align 4
  %easter = getelementptr inbounds %struct.easter_related_t, %struct.easter_related_t* %holidays, i32 0, i32 0
  %week_day = getelementptr inbounds %struct.date_t, %struct.date_t* %easter, i32 0, i32 3
  %2 = load i32, i32* %week_day, align 4
  %arrayidx = getelementptr inbounds [8 x i8*], [8 x i8*]* @week_day_fmt, i32 0, i32 %2
  %3 = load i8*, i8** %arrayidx, align 4
  %easter1 = getelementptr inbounds %struct.easter_related_t, %struct.easter_related_t* %holidays, i32 0, i32 0
  %month_day = getelementptr inbounds %struct.date_t, %struct.date_t* %easter1, i32 0, i32 2
  %4 = load i32, i32* %month_day, align 4
  %easter2 = getelementptr inbounds %struct.easter_related_t, %struct.easter_related_t* %holidays, i32 0, i32 0
  %month = getelementptr inbounds %struct.date_t, %struct.date_t* %easter2, i32 0, i32 1
  %5 = load i32, i32* %month, align 4
  %arrayidx3 = getelementptr inbounds [13 x i8*], [13 x i8*]* @mon_fmt, i32 0, i32 %5
  %6 = load i8*, i8** %arrayidx3, align 4
  %ascension = getelementptr inbounds %struct.easter_related_t, %struct.easter_related_t* %holidays, i32 0, i32 1
  %week_day4 = getelementptr inbounds %struct.date_t, %struct.date_t* %ascension, i32 0, i32 3
  %7 = load i32, i32* %week_day4, align 4
  %arrayidx5 = getelementptr inbounds [8 x i8*], [8 x i8*]* @week_day_fmt, i32 0, i32 %7
  %8 = load i8*, i8** %arrayidx5, align 4
  %ascension6 = getelementptr inbounds %struct.easter_related_t, %struct.easter_related_t* %holidays, i32 0, i32 1
  %month_day7 = getelementptr inbounds %struct.date_t, %struct.date_t* %ascension6, i32 0, i32 2
  %9 = load i32, i32* %month_day7, align 4
  %ascension8 = getelementptr inbounds %struct.easter_related_t, %struct.easter_related_t* %holidays, i32 0, i32 1
  %month9 = getelementptr inbounds %struct.date_t, %struct.date_t* %ascension8, i32 0, i32 1
  %10 = load i32, i32* %month9, align 4
  %arrayidx10 = getelementptr inbounds [13 x i8*], [13 x i8*]* @mon_fmt, i32 0, i32 %10
  %11 = load i8*, i8** %arrayidx10, align 4
  %pentecost = getelementptr inbounds %struct.easter_related_t, %struct.easter_related_t* %holidays, i32 0, i32 2
  %week_day11 = getelementptr inbounds %struct.date_t, %struct.date_t* %pentecost, i32 0, i32 3
  %12 = load i32, i32* %week_day11, align 4
  %arrayidx12 = getelementptr inbounds [8 x i8*], [8 x i8*]* @week_day_fmt, i32 0, i32 %12
  %13 = load i8*, i8** %arrayidx12, align 4
  %pentecost13 = getelementptr inbounds %struct.easter_related_t, %struct.easter_related_t* %holidays, i32 0, i32 2
  %month_day14 = getelementptr inbounds %struct.date_t, %struct.date_t* %pentecost13, i32 0, i32 2
  %14 = load i32, i32* %month_day14, align 4
  %pentecost15 = getelementptr inbounds %struct.easter_related_t, %struct.easter_related_t* %holidays, i32 0, i32 2
  %month16 = getelementptr inbounds %struct.date_t, %struct.date_t* %pentecost15, i32 0, i32 1
  %15 = load i32, i32* %month16, align 4
  %arrayidx17 = getelementptr inbounds [13 x i8*], [13 x i8*]* @mon_fmt, i32 0, i32 %15
  %16 = load i8*, i8** %arrayidx17, align 4
  %trinity = getelementptr inbounds %struct.easter_related_t, %struct.easter_related_t* %holidays, i32 0, i32 3
  %week_day18 = getelementptr inbounds %struct.date_t, %struct.date_t* %trinity, i32 0, i32 3
  %17 = load i32, i32* %week_day18, align 4
  %arrayidx19 = getelementptr inbounds [8 x i8*], [8 x i8*]* @week_day_fmt, i32 0, i32 %17
  %18 = load i8*, i8** %arrayidx19, align 4
  %trinity20 = getelementptr inbounds %struct.easter_related_t, %struct.easter_related_t* %holidays, i32 0, i32 3
  %month_day21 = getelementptr inbounds %struct.date_t, %struct.date_t* %trinity20, i32 0, i32 2
  %19 = load i32, i32* %month_day21, align 4
  %trinity22 = getelementptr inbounds %struct.easter_related_t, %struct.easter_related_t* %holidays, i32 0, i32 3
  %month23 = getelementptr inbounds %struct.date_t, %struct.date_t* %trinity22, i32 0, i32 1
  %20 = load i32, i32* %month23, align 4
  %arrayidx24 = getelementptr inbounds [13 x i8*], [13 x i8*]* @mon_fmt, i32 0, i32 %20
  %21 = load i8*, i8** %arrayidx24, align 4
  %corpus_christi = getelementptr inbounds %struct.easter_related_t, %struct.easter_related_t* %holidays, i32 0, i32 4
  %week_day25 = getelementptr inbounds %struct.date_t, %struct.date_t* %corpus_christi, i32 0, i32 3
  %22 = load i32, i32* %week_day25, align 4
  %arrayidx26 = getelementptr inbounds [8 x i8*], [8 x i8*]* @week_day_fmt, i32 0, i32 %22
  %23 = load i8*, i8** %arrayidx26, align 4
  %corpus_christi27 = getelementptr inbounds %struct.easter_related_t, %struct.easter_related_t* %holidays, i32 0, i32 4
  %month_day28 = getelementptr inbounds %struct.date_t, %struct.date_t* %corpus_christi27, i32 0, i32 2
  %24 = load i32, i32* %month_day28, align 4
  %corpus_christi29 = getelementptr inbounds %struct.easter_related_t, %struct.easter_related_t* %holidays, i32 0, i32 4
  %month30 = getelementptr inbounds %struct.date_t, %struct.date_t* %corpus_christi29, i32 0, i32 1
  %25 = load i32, i32* %month30, align 4
  %arrayidx31 = getelementptr inbounds [13 x i8*], [13 x i8*]* @mon_fmt, i32 0, i32 %25
  %26 = load i8*, i8** %arrayidx31, align 4
  %call = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([106 x i8], [106 x i8]* @.str.19, i32 0, i32 0), i32 %1, i8* %3, i32 %4, i8* %6, i8* %8, i32 %9, i8* %11, i8* %13, i32 %14, i8* %16, i8* %18, i32 %19, i8* %21, i8* %23, i32 %24, i8* %26)
  ret void
}

declare i32 @printf(i8* %0, ...) #2

; Function Attrs: noinline nounwind optnone
define hidden i32 @main() #0 {
entry:
  %retval = alloca i32, align 4
  %year = alloca i32, align 4
  store i32 0, i32* %retval, align 4
  %call = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([81 x i8], [81 x i8]* @.str.20, i32 0, i32 0))
  store i32 400, i32* %year, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %0 = load i32, i32* %year, align 4
  %cmp = icmp sle i32 %0, 2100
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %1 = load i32, i32* %year, align 4
  call void @easter_related_print(i32 %1)
  br label %for.inc

for.inc:                                          ; preds = %for.body
  %2 = load i32, i32* %year, align 4
  %add = add nsw i32 %2, 100
  store i32 %add, i32* %year, align 4
  br label %for.cond

for.end:                                          ; preds = %for.cond
  %call1 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([73 x i8], [73 x i8]* @.str.21, i32 0, i32 0))
  store i32 2010, i32* %year, align 4
  br label %for.cond2

for.cond2:                                        ; preds = %for.inc5, %for.end
  %3 = load i32, i32* %year, align 4
  %cmp3 = icmp sle i32 %3, 2020
  br i1 %cmp3, label %for.body4, label %for.end6

for.body4:                                        ; preds = %for.cond2
  %4 = load i32, i32* %year, align 4
  call void @easter_related_print(i32 %4)
  br label %for.inc5

for.inc5:                                         ; preds = %for.body4
  %5 = load i32, i32* %year, align 4
  %inc = add nsw i32 %5, 1
  store i32 %inc, i32* %year, align 4
  br label %for.cond2

for.end6:                                         ; preds = %for.cond2
  ret i32 0
}

attributes #0 = { noinline nounwind optnone "correctly-rounded-divide-sqrt-fp-math"="false" "disable-tail-calls"="false" "frame-pointer"="none" "less-precise-fpmad"="false" "min-legal-vector-width"="0" "no-infs-fp-math"="false" "no-jump-tables"="false" "no-nans-fp-math"="false" "no-signed-zeros-fp-math"="false" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="generic" "unsafe-fp-math"="false" "use-soft-float"="false" }
attributes #1 = { argmemonly nounwind willreturn }
attributes #2 = { "correctly-rounded-divide-sqrt-fp-math"="false" "disable-tail-calls"="false" "frame-pointer"="none" "less-precise-fpmad"="false" "no-infs-fp-math"="false" "no-nans-fp-math"="false" "no-signed-zeros-fp-math"="false" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="generic" "unsafe-fp-math"="false" "use-soft-float"="false" }

!llvm.module.flags = !{!0}
!llvm.ident = !{!1}

!0 = !{i32 1, !"wchar_size", i32 4}
!1 = !{!"clang version 11.0.0 (https://github.com/Jacarte/llvm-project.git 0f6dea67136cc1e0b3d200eb2bb165628970c44b)"}

; extracted candidates

; *****
; For LLVM instruction:
;  %0 = load i32, i32* %year.addr, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %1 = load i32, i32* %year.addr, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %div = sdiv i32 %1, 100
; Looking for a replacement for:
%0:i32 = var
%1:i32 = sdiv %0, 100:i32
infer %1

; *****
; For LLVM instruction:
;  %2 = load i32, i32* %year.addr, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %rem = srem i32 %2, 19
; Looking for a replacement for:
%0:i32 = var
%1:i32 = srem %0, 19:i32
infer %1

; *****
; For LLVM instruction:
;  %3 = load i32, i32* %c, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %4 = load i32, i32* %c, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %div2 = sdiv i32 %4, 4
; Looking for a replacement for:
%0:i32 = var
%1:i32 = sdiv %0, 4:i32
infer %1

; *****
; For LLVM instruction:
;  %sub = sub nsw i32 %3, %div2
; Looking for a replacement for:
%0:i32 = var
%1:i32 = var
%2:i32 = sdiv %1, 4:i32
%3:i32 = subnsw %0, %2
infer %3

; *****
; For LLVM instruction:
;  %5 = load i32, i32* %c, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %6 = load i32, i32* %c, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %sub3 = sub nsw i32 %6, 17
; Looking for a replacement for:
%0:i32 = var
%1:i32 = subnsw %0, 17:i32
infer %1

; *****
; For LLVM instruction:
;  %div4 = sdiv i32 %sub3, 25
; Looking for a replacement for:
%0:i32 = var
%1:i32 = subnsw %0, 17:i32
%2:i32 = sdiv %1, 25:i32
infer %2

; *****
; For LLVM instruction:
;  %sub5 = sub nsw i32 %5, %div4
; Looking for a replacement for:
%0:i32 = var
%1:i32 = var
%2:i32 = subnsw %1, 17:i32
%3:i32 = sdiv %2, 25:i32
%4:i32 = subnsw %0, %3
infer %4

; *****
; For LLVM instruction:
;  %div6 = sdiv i32 %sub5, 3
; Looking for a replacement for:
%0:i32 = var
%1:i32 = var
%2:i32 = subnsw %1, 17:i32
%3:i32 = sdiv %2, 25:i32
%4:i32 = subnsw %0, %3
%5:i32 = sdiv %4, 3:i32
infer %5

; *****
; For LLVM instruction:
;  %sub7 = sub nsw i32 %sub, %div6
; Looking for a replacement for:
%0:i32 = var
%1:i32 = var
%2:i32 = sdiv %1, 4:i32
%3:i32 = subnsw %0, %2
%4:i32 = var
%5:i32 = var
%6:i32 = subnsw %5, 17:i32
%7:i32 = sdiv %6, 25:i32
%8:i32 = subnsw %4, %7
%9:i32 = sdiv %8, 3:i32
%10:i32 = subnsw %3, %9
infer %10

; *****
; For LLVM instruction:
;  %7 = load i32, i32* %n, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %mul = mul nsw i32 19, %7
; Looking for a replacement for:
%0:i32 = var
%1:i32 = mulnsw 19:i32, %0
infer %1

; *****
; For LLVM instruction:
;  %add = add nsw i32 %sub7, %mul
; Looking for a replacement for:
%0:i32 = var
%1:i32 = var
%2:i32 = sdiv %1, 4:i32
%3:i32 = subnsw %0, %2
%4:i32 = var
%5:i32 = var
%6:i32 = subnsw %5, 17:i32
%7:i32 = sdiv %6, 25:i32
%8:i32 = subnsw %4, %7
%9:i32 = sdiv %8, 3:i32
%10:i32 = subnsw %3, %9
%11:i32 = var
%12:i32 = mulnsw 19:i32, %11
%13:i32 = addnsw %10, %12
infer %13

; *****
; For LLVM instruction:
;  %add8 = add nsw i32 %add, 15
; Looking for a replacement for:
%0:i32 = var
%1:i32 = var
%2:i32 = sdiv %1, 4:i32
%3:i32 = subnsw %0, %2
%4:i32 = var
%5:i32 = var
%6:i32 = subnsw %5, 17:i32
%7:i32 = sdiv %6, 25:i32
%8:i32 = subnsw %4, %7
%9:i32 = sdiv %8, 3:i32
%10:i32 = subnsw %3, %9
%11:i32 = var
%12:i32 = mulnsw 19:i32, %11
%13:i32 = addnsw %10, %12
%14:i32 = addnsw 15:i32, %13
infer %14

; *****
; For LLVM instruction:
;  %rem9 = srem i32 %add8, 30
; Looking for a replacement for:
%0:i32 = var
%1:i32 = var
%2:i32 = sdiv %1, 4:i32
%3:i32 = subnsw %0, %2
%4:i32 = var
%5:i32 = var
%6:i32 = subnsw %5, 17:i32
%7:i32 = sdiv %6, 25:i32
%8:i32 = subnsw %4, %7
%9:i32 = sdiv %8, 3:i32
%10:i32 = subnsw %3, %9
%11:i32 = var
%12:i32 = mulnsw 19:i32, %11
%13:i32 = addnsw %10, %12
%14:i32 = addnsw 15:i32, %13
%15:i32 = srem %14, 30:i32
infer %15

; *****
; For LLVM instruction:
;  %8 = load i32, i32* %i, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %div10 = sdiv i32 %8, 28
; Looking for a replacement for:
%0:i32 = var
%1:i32 = sdiv %0, 28:i32
infer %1

; *****
; For LLVM instruction:
;  %9 = load i32, i32* %i, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %div11 = sdiv i32 %9, 28
; Looking for a replacement for:
%0:i32 = var
%1:i32 = sdiv %0, 28:i32
infer %1

; *****
; For LLVM instruction:
;  %10 = load i32, i32* %i, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %add12 = add nsw i32 %10, 1
; Looking for a replacement for:
%0:i32 = var
%1:i32 = addnsw 1:i32, %0
infer %1

; *****
; For LLVM instruction:
;  %div13 = sdiv i32 29, %add12
; Looking for a replacement for:
%0:i32 = var
%1:i32 = addnsw 1:i32, %0
%2:i32 = sdiv 29:i32, %1
infer %2

; *****
; For LLVM instruction:
;  %mul14 = mul nsw i32 %div11, %div13
; Looking for a replacement for:
%0:i32 = var
%1:i32 = addnsw 1:i32, %0
%2:i32 = sdiv 29:i32, %1
%3:i32 = var
%4:i32 = sdiv %3, 28:i32
%5:i32 = mulnsw %2, %4
infer %5

; *****
; For LLVM instruction:
;  %11 = load i32, i32* %n, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %sub15 = sub nsw i32 21, %11
; Looking for a replacement for:
%0:i32 = var
%1:i32 = subnsw 21:i32, %0
infer %1

; *****
; For LLVM instruction:
;  %div16 = sdiv i32 %sub15, 11
; Looking for a replacement for:
%0:i32 = var
%1:i32 = subnsw 21:i32, %0
%2:i32 = sdiv %1, 11:i32
infer %2

; *****
; For LLVM instruction:
;  %mul17 = mul nsw i32 %mul14, %div16
; Looking for a replacement for:
%0:i32 = var
%1:i32 = addnsw 1:i32, %0
%2:i32 = sdiv 29:i32, %1
%3:i32 = var
%4:i32 = sdiv %3, 28:i32
%5:i32 = mulnsw %2, %4
%6:i32 = var
%7:i32 = subnsw 21:i32, %6
%8:i32 = sdiv %7, 11:i32
%9:i32 = mulnsw %5, %8
infer %9

; *****
; For LLVM instruction:
;  %sub18 = sub nsw i32 1, %mul17
; Looking for a replacement for:
%0:i32 = var
%1:i32 = addnsw 1:i32, %0
%2:i32 = sdiv 29:i32, %1
%3:i32 = var
%4:i32 = sdiv %3, 28:i32
%5:i32 = mulnsw %2, %4
%6:i32 = var
%7:i32 = subnsw 21:i32, %6
%8:i32 = sdiv %7, 11:i32
%9:i32 = mulnsw %5, %8
%10:i32 = subnsw 1:i32, %9
infer %10

; *****
; For LLVM instruction:
;  %mul19 = mul nsw i32 %div10, %sub18
; Looking for a replacement for:
%0:i32 = var
%1:i32 = addnsw 1:i32, %0
%2:i32 = sdiv 29:i32, %1
%3:i32 = var
%4:i32 = sdiv %3, 28:i32
%5:i32 = mulnsw %2, %4
%6:i32 = var
%7:i32 = subnsw 21:i32, %6
%8:i32 = sdiv %7, 11:i32
%9:i32 = mulnsw %5, %8
%10:i32 = subnsw 1:i32, %9
%11:i32 = var
%12:i32 = sdiv %11, 28:i32
%13:i32 = mulnsw %10, %12
infer %13

; *****
; For LLVM instruction:
;  %12 = load i32, i32* %i, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %sub20 = sub nsw i32 %12, %mul19
; Looking for a replacement for:
%0:i32 = var
%1:i32 = var
%2:i32 = addnsw 1:i32, %1
%3:i32 = sdiv 29:i32, %2
%4:i32 = var
%5:i32 = sdiv %4, 28:i32
%6:i32 = mulnsw %3, %5
%7:i32 = var
%8:i32 = subnsw 21:i32, %7
%9:i32 = sdiv %8, 11:i32
%10:i32 = mulnsw %6, %9
%11:i32 = subnsw 1:i32, %10
%12:i32 = var
%13:i32 = sdiv %12, 28:i32
%14:i32 = mulnsw %11, %13
%15:i32 = subnsw %0, %14
infer %15

; *****
; For LLVM instruction:
;  %13 = load i32, i32* %i, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %14 = load i32, i32* %year.addr, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %15 = load i32, i32* %year.addr, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %div21 = sdiv i32 %15, 4
; Looking for a replacement for:
%0:i32 = var
%1:i32 = sdiv %0, 4:i32
infer %1

; *****
; For LLVM instruction:
;  %add22 = add nsw i32 %14, %div21
; Looking for a replacement for:
%0:i32 = var
%1:i32 = var
%2:i32 = sdiv %1, 4:i32
%3:i32 = addnsw %0, %2
infer %3

; *****
; For LLVM instruction:
;  %16 = load i32, i32* %i, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %add23 = add nsw i32 %add22, %16
; Looking for a replacement for:
%0:i32 = var
%1:i32 = var
%2:i32 = var
%3:i32 = sdiv %2, 4:i32
%4:i32 = addnsw %1, %3
%5:i32 = addnsw %0, %4
infer %5

; *****
; For LLVM instruction:
;  %add24 = add nsw i32 %add23, 2
; Looking for a replacement for:
%0:i32 = var
%1:i32 = var
%2:i32 = var
%3:i32 = sdiv %2, 4:i32
%4:i32 = addnsw %1, %3
%5:i32 = addnsw %0, %4
%6:i32 = addnsw 2:i32, %5
infer %6

; *****
; For LLVM instruction:
;  %17 = load i32, i32* %c, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %sub25 = sub nsw i32 %add24, %17
; Looking for a replacement for:
%0:i32 = var
%1:i32 = var
%2:i32 = var
%3:i32 = sdiv %2, 4:i32
%4:i32 = addnsw %1, %3
%5:i32 = addnsw %0, %4
%6:i32 = addnsw 2:i32, %5
%7:i32 = var
%8:i32 = subnsw %6, %7
infer %8

; *****
; For LLVM instruction:
;  %18 = load i32, i32* %c, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %div26 = sdiv i32 %18, 4
; Looking for a replacement for:
%0:i32 = var
%1:i32 = sdiv %0, 4:i32
infer %1

; *****
; For LLVM instruction:
;  %add27 = add nsw i32 %sub25, %div26
; Looking for a replacement for:
%0:i32 = var
%1:i32 = var
%2:i32 = var
%3:i32 = sdiv %2, 4:i32
%4:i32 = addnsw %1, %3
%5:i32 = addnsw %0, %4
%6:i32 = addnsw 2:i32, %5
%7:i32 = var
%8:i32 = subnsw %6, %7
%9:i32 = var
%10:i32 = sdiv %9, 4:i32
%11:i32 = addnsw %8, %10
infer %11

; *****
; For LLVM instruction:
;  %rem28 = srem i32 %add27, 7
; Looking for a replacement for:
%0:i32 = var
%1:i32 = var
%2:i32 = var
%3:i32 = sdiv %2, 4:i32
%4:i32 = addnsw %1, %3
%5:i32 = addnsw %0, %4
%6:i32 = addnsw 2:i32, %5
%7:i32 = var
%8:i32 = subnsw %6, %7
%9:i32 = var
%10:i32 = sdiv %9, 4:i32
%11:i32 = addnsw %8, %10
%12:i32 = srem %11, 7:i32
infer %12

; *****
; For LLVM instruction:
;  %sub29 = sub nsw i32 %13, %rem28
; Looking for a replacement for:
%0:i32 = var
%1:i32 = var
%2:i32 = var
%3:i32 = var
%4:i32 = sdiv %3, 4:i32
%5:i32 = addnsw %2, %4
%6:i32 = addnsw %1, %5
%7:i32 = addnsw 2:i32, %6
%8:i32 = var
%9:i32 = subnsw %7, %8
%10:i32 = var
%11:i32 = sdiv %10, 4:i32
%12:i32 = addnsw %9, %11
%13:i32 = srem %12, 7:i32
%14:i32 = subnsw %0, %13
infer %14

; *****
; For LLVM instruction:
;  %19 = load i32, i32* %l, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %add30 = add nsw i32 %19, 40
; Looking for a replacement for:
%0:i32 = var
%1:i32 = addnsw 40:i32, %0
infer %1

; *****
; For LLVM instruction:
;  %div31 = sdiv i32 %add30, 44
; Looking for a replacement for:
%0:i32 = var
%1:i32 = addnsw 40:i32, %0
%2:i32 = sdiv %1, 44:i32
infer %2

; *****
; For LLVM instruction:
;  %add32 = add nsw i32 3, %div31
; Looking for a replacement for:
%0:i32 = var
%1:i32 = addnsw 40:i32, %0
%2:i32 = sdiv %1, 44:i32
%3:i32 = addnsw 3:i32, %2
infer %3

; *****
; For LLVM instruction:
;  %20 = load i32, i32* %l, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %add33 = add nsw i32 %20, 28
; Looking for a replacement for:
%0:i32 = var
%1:i32 = addnsw 28:i32, %0
infer %1

; *****
; For LLVM instruction:
;  %21 = load i32, i32* %month34, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %div35 = sdiv i32 %21, 4
; Looking for a replacement for:
%0:i32 = var
%1:i32 = sdiv %0, 4:i32
infer %1

; *****
; For LLVM instruction:
;  %mul36 = mul nsw i32 31, %div35
; Looking for a replacement for:
%0:i32 = var
%1:i32 = sdiv %0, 4:i32
%2:i32 = mulnsw 31:i32, %1
infer %2

; *****
; For LLVM instruction:
;  %sub37 = sub nsw i32 %add33, %mul36
; Looking for a replacement for:
%0:i32 = var
%1:i32 = addnsw 28:i32, %0
%2:i32 = var
%3:i32 = sdiv %2, 4:i32
%4:i32 = mulnsw 31:i32, %3
%5:i32 = subnsw %1, %4
infer %5

; *****
; For LLVM instruction:
;  %call = call i32 @week_day(%struct.date_t* byval(%struct.date_t) align 4 %agg.result)
; Looking for a replacement for:
%0:i32 = var
infer %0
got 2 candidates from LHS

-------------------------------------------------
%0:i32 = var
%1:i32 = sdiv %0, 100:i32
infer %1


--------------------------------
guess 0

%0:i32 = var ; reservedconst_1

Cost = 0
first query is SAT, returning the model:
reservedconst_1: 0
0 th attempt: second query is SAT-- constant doesn't work
first query is SAT, returning the model:
reservedconst_1: 18612224
1 th attempt: second query is SAT-- constant doesn't work
first query is UNSAT-- no more guesses

--------------------------------
guess 1

%0:i32 = var

Cost = 0
second query is SAT-- constant doesn't work
Dataflow Pruned 0/0
There are 2 Guesses
There are 0 RHSs before deduplication
There are 0 RHSs after deduplication
got 2 candidates from LHS

-------------------------------------------------
%0:i32 = var
%1:i32 = srem %0, 19:i32
infer %1


--------------------------------
guess 0

%0:i32 = var ; reservedconst_1

Cost = 0
first query is SAT, returning the model:
reservedconst_1: 0
0 th attempt: second query is SAT-- constant doesn't work
first query is SAT, returning the model:
reservedconst_1: -3
1 th attempt: second query is SAT-- constant doesn't work
first query is UNSAT-- no more guesses

--------------------------------
guess 1

%0:i32 = var

Cost = 0
second query is SAT-- constant doesn't work
Dataflow Pruned 0/0
There are 2 Guesses
There are 0 RHSs before deduplication
There are 0 RHSs after deduplication
got 2 candidates from LHS

-------------------------------------------------
%0:i32 = var
%1:i32 = sdiv %0, 4:i32
infer %1


--------------------------------
guess 0

%0:i32 = var ; reservedconst_1

Cost = 0
first query is SAT, returning the model:
reservedconst_1: 0
0 th attempt: second query is SAT-- constant doesn't work
first query is SAT, returning the model:
reservedconst_1: 161982144
1 th attempt: second query is SAT-- constant doesn't work
first query is UNSAT-- no more guesses

--------------------------------
guess 1

%0:i32 = var

Cost = 0
second query is SAT-- constant doesn't work
Dataflow Pruned 0/0
There are 2 Guesses
There are 0 RHSs before deduplication
There are 0 RHSs after deduplication
got 4 candidates from LHS

-------------------------------------------------
%0:i32 = var
%1:i32 = var
%2:i32 = sdiv %1, 4:i32
%3:i32 = subnsw %0, %2
infer %3


--------------------------------
guess 0

%0:i32 = var ; reservedconst_1

Cost = 0
first query is SAT, returning the model:
reservedconst_1: 0
0 th attempt: second query is SAT-- constant doesn't work
first query is SAT, returning the model:
reservedconst_1: 12189794
1 th attempt: second query is SAT-- constant doesn't work
first query is UNSAT-- no more guesses

--------------------------------
guess 1

%0:i32 = var

Cost = 0
second query is SAT-- constant doesn't work

--------------------------------
guess 2

%0:i32 = var

Cost = 0
second query is SAT-- constant doesn't work

--------------------------------
guess 3

%0:i32 = var
%1:i32 = sdiv %0, 4:i32

Cost = 5
second query is SAT-- constant doesn't work
Dataflow Pruned 0/0
There are 4 Guesses
There are 0 RHSs before deduplication
There are 0 RHSs after deduplication
got 2 candidates from LHS

-------------------------------------------------
%0:i32 = var
%1:i32 = subnsw %0, 17:i32
infer %1


--------------------------------
guess 0

%0:i32 = var ; reservedconst_1

Cost = 0
first query is SAT, returning the model:
reservedconst_1: -17
0 th attempt: second query is SAT-- constant doesn't work
first query is SAT, returning the model:
reservedconst_1: 0
1 th attempt: second query is SAT-- constant doesn't work
first query is UNSAT-- no more guesses

--------------------------------
guess 1

%0:i32 = var

Cost = 0
second query is SAT-- constant doesn't work
Dataflow Pruned 0/0
There are 2 Guesses
There are 0 RHSs before deduplication
There are 0 RHSs after deduplication
got 3 candidates from LHS

-------------------------------------------------
%0:i32 = var
%1:i32 = subnsw %0, 17:i32
%2:i32 = sdiv %1, 25:i32
infer %2


--------------------------------
guess 0

%0:i32 = var ; reservedconst_1

Cost = 0
first query is SAT, returning the model:
reservedconst_1: 0
0 th attempt: second query is SAT-- constant doesn't work
first query is SAT, returning the model:
reservedconst_1: 67108864
1 th attempt: second query is SAT-- constant doesn't work
first query is UNSAT-- no more guesses

--------------------------------
guess 1

%0:i32 = var

Cost = 0
second query is SAT-- constant doesn't work

--------------------------------
guess 2

%0:i32 = var
%1:i32 = subnsw %0, 17:i32

Cost = 1
second query is SAT-- constant doesn't work
Dataflow Pruned 0/0
There are 3 Guesses
There are 0 RHSs before deduplication
There are 0 RHSs after deduplication
got 5 candidates from LHS

-------------------------------------------------
%0:i32 = var
%1:i32 = var
%2:i32 = subnsw %1, 17:i32
%3:i32 = sdiv %2, 25:i32
%4:i32 = subnsw %0, %3
infer %4


--------------------------------
guess 0

%0:i32 = var ; reservedconst_1

Cost = 0
first query is SAT, returning the model:
reservedconst_1: 0
0 th attempt: second query is SAT-- constant doesn't work
first query is SAT, returning the model:
reservedconst_1: 325585913
1 th attempt: second query is SAT-- constant doesn't work
first query is UNSAT-- no more guesses

--------------------------------
guess 1

%0:i32 = var

Cost = 0
second query is SAT-- constant doesn't work

--------------------------------
guess 2

%0:i32 = var

Cost = 0
second query is SAT-- constant doesn't work

--------------------------------
guess 3

%0:i32 = var
%1:i32 = subnsw %0, 17:i32

Cost = 1
second query is SAT-- constant doesn't work

--------------------------------
guess 4

%0:i32 = var
%1:i32 = subnsw %0, 17:i32
%2:i32 = sdiv %1, 25:i32

Cost = 6
second query is SAT-- constant doesn't work
Dataflow Pruned 0/0
There are 5 Guesses
There are 0 RHSs before deduplication
There are 0 RHSs after deduplication
got 6 candidates from LHS

-------------------------------------------------
%0:i32 = var
%1:i32 = var
%2:i32 = subnsw %1, 17:i32
%3:i32 = sdiv %2, 25:i32
%4:i32 = subnsw %0, %3
%5:i32 = sdiv %4, 3:i32
infer %5


--------------------------------
guess 0

%0:i32 = var ; reservedconst_1

Cost = 0
first query is SAT, returning the model:
reservedconst_1: 0
0 th attempt: second query is SAT-- constant doesn't work
first query is SAT, returning the model:
reservedconst_1: -587202560
1 th attempt: second query is SAT-- constant doesn't work
first query is UNSAT-- no more guesses

--------------------------------
guess 1

%0:i32 = var

Cost = 0
second query is SAT-- constant doesn't work

--------------------------------
guess 2

%0:i32 = var

Cost = 0
second query is SAT-- constant doesn't work

--------------------------------
guess 3

%0:i32 = var
%1:i32 = subnsw %0, 17:i32

Cost = 1
second query is SAT-- constant doesn't work

--------------------------------
guess 4

%0:i32 = var
%1:i32 = subnsw %0, 17:i32
%2:i32 = sdiv %1, 25:i32

Cost = 6
second query is SAT-- constant doesn't work

--------------------------------
guess 5

%0:i32 = var
%1:i32 = var
%2:i32 = subnsw %1, 17:i32
%3:i32 = sdiv %2, 25:i32
%4:i32 = subnsw %0, %3

Cost = 7
second query is SAT-- constant doesn't work
Dataflow Pruned 0/0
There are 6 Guesses
There are 0 RHSs before deduplication
There are 0 RHSs after deduplication
got 8 candidates from LHS

-------------------------------------------------
%0:i32 = var
%1:i32 = var
%2:i32 = sdiv %1, 4:i32
%3:i32 = subnsw %0, %2
%4:i32 = var
%5:i32 = var
%6:i32 = subnsw %5, 17:i32
%7:i32 = sdiv %6, 25:i32
%8:i32 = subnsw %4, %7
%9:i32 = sdiv %8, 3:i32
%10:i32 = subnsw %3, %9
infer %10


--------------------------------
guess 0

%0:i32 = var ; reservedconst_1

Cost = 0
first query is SAT, returning the model:
reservedconst_1: 0
0 th attempt: second query is SAT-- constant doesn't work
first query is SAT, returning the model:
reservedconst_1: 404884075
1 th attempt: second query is SAT-- constant doesn't work
first query is UNSAT-- no more guesses

--------------------------------
guess 1

%0:i32 = var

Cost = 0
second query is SAT-- constant doesn't work

--------------------------------
guess 2

%0:i32 = var

Cost = 0
second query is SAT-- constant doesn't work

--------------------------------
guess 3

%0:i32 = var

Cost = 0
second query is SAT-- constant doesn't work

--------------------------------
guess 4

%0:i32 = var
%1:i32 = sdiv %0, 4:i32

Cost = 5
second query is SAT-- constant doesn't work

--------------------------------
guess 5

%0:i32 = var
%1:i32 = var
%2:i32 = sdiv %1, 4:i32
%3:i32 = subnsw %0, %2

Cost = 6
second query is SAT-- constant doesn't work

--------------------------------
guess 6

%0:i32 = var
%1:i32 = var
%2:i32 = subnsw %1, 17:i32
%3:i32 = sdiv %2, 25:i32
%4:i32 = subnsw %0, %3

Cost = 7
second query is SAT-- constant doesn't work

--------------------------------
guess 7

%0:i32 = var
%1:i32 = var
%2:i32 = subnsw %1, 17:i32
%3:i32 = sdiv %2, 25:i32
%4:i32 = subnsw %0, %3
%5:i32 = sdiv %4, 3:i32

Cost = 12
second query is SAT-- constant doesn't work
Dataflow Pruned 0/0
There are 8 Guesses
There are 0 RHSs before deduplication
There are 0 RHSs after deduplication
got 2 candidates from LHS

-------------------------------------------------
%0:i32 = var
%1:i32 = mulnsw 19:i32, %0
infer %1


--------------------------------
guess 0

%0:i32 = var ; reservedconst_1

Cost = 0
first query is SAT, returning the model:
reservedconst_1: 0
0 th attempt: second query is SAT-- constant doesn't work
first query is SAT, returning the model:
reservedconst_1: 1207926368
1 th attempt: second query is SAT-- constant doesn't work
first query is UNSAT-- no more guesses

--------------------------------
guess 1

%0:i32 = var

Cost = 0
second query is SAT-- constant doesn't work
Dataflow Pruned 0/0
There are 2 Guesses
There are 0 RHSs before deduplication
There are 0 RHSs after deduplication
got 8 candidates from LHS

-------------------------------------------------
%0:i32 = var
%1:i32 = var
%2:i32 = sdiv %1, 4:i32
%3:i32 = subnsw %0, %2
%4:i32 = var
%5:i32 = var
%6:i32 = subnsw %5, 17:i32
%7:i32 = sdiv %6, 25:i32
%8:i32 = subnsw %4, %7
%9:i32 = sdiv %8, 3:i32
%10:i32 = subnsw %3, %9
%11:i32 = var
%12:i32 = mulnsw 19:i32, %11
%13:i32 = addnsw %10, %12
infer %13


--------------------------------
guess 0

%0:i32 = var ; reservedconst_1

Cost = 0
first query is SAT, returning the model:
reservedconst_1: 0
0 th attempt: second query is SAT-- constant doesn't work
first query is SAT, returning the model:
reservedconst_1: -1308663932
1 th attempt: second query is SAT-- constant doesn't work
first query is UNSAT-- no more guesses

--------------------------------
guess 1

%0:i32 = var

Cost = 0
second query is SAT-- constant doesn't work

--------------------------------
guess 2

%0:i32 = var

Cost = 0
second query is SAT-- constant doesn't work

--------------------------------
guess 3

%0:i32 = var
%1:i32 = mulnsw 19:i32, %0

Cost = 1
second query is SAT-- constant doesn't work

--------------------------------
guess 4

%0:i32 = var
%1:i32 = sdiv %0, 4:i32

Cost = 5
second query is SAT-- constant doesn't work

--------------------------------
guess 5

%0:i32 = var
%1:i32 = var
%2:i32 = sdiv %1, 4:i32
%3:i32 = subnsw %0, %2

Cost = 6
second query is SAT-- constant doesn't work

--------------------------------
guess 6

%0:i32 = var
%1:i32 = var
%2:i32 = subnsw %1, 17:i32
%3:i32 = sdiv %2, 25:i32
%4:i32 = subnsw %0, %3
%5:i32 = sdiv %4, 3:i32

Cost = 12
second query is SAT-- constant doesn't work

--------------------------------
guess 7

%0:i32 = var
%1:i32 = var
%2:i32 = sdiv %1, 4:i32
%3:i32 = subnsw %0, %2
%4:i32 = var
%5:i32 = var
%6:i32 = subnsw %5, 17:i32
%7:i32 = sdiv %6, 25:i32
%8:i32 = subnsw %4, %7
%9:i32 = sdiv %8, 3:i32
%10:i32 = subnsw %3, %9

Cost = 19
second query is SAT-- constant doesn't work
Dataflow Pruned 0/0
There are 8 Guesses
There are 0 RHSs before deduplication
There are 0 RHSs after deduplication
got 8 candidates from LHS

-------------------------------------------------
%0:i32 = var
%1:i32 = var
%2:i32 = sdiv %1, 4:i32
%3:i32 = subnsw %0, %2
%4:i32 = var
%5:i32 = var
%6:i32 = subnsw %5, 17:i32
%7:i32 = sdiv %6, 25:i32
%8:i32 = subnsw %4, %7
%9:i32 = sdiv %8, 3:i32
%10:i32 = subnsw %3, %9
%11:i32 = var
%12:i32 = mulnsw 19:i32, %11
%13:i32 = addnsw %10, %12
%14:i32 = addnsw 15:i32, %13
infer %14


--------------------------------
guess 0

%0:i32 = var ; reservedconst_1

Cost = 0
first query is SAT, returning the model:
reservedconst_1: 15
0 th attempt: second query is SAT-- constant doesn't work
first query is SAT, returning the model:
reservedconst_1: -2146695085
1 th attempt: second query is SAT-- constant doesn't work
first query is UNSAT-- no more guesses

--------------------------------
guess 1

%0:i32 = var

Cost = 0
second query is SAT-- constant doesn't work

--------------------------------
guess 2

%0:i32 = var

Cost = 0
second query is SAT-- constant doesn't work

--------------------------------
guess 3

%0:i32 = var
%1:i32 = mulnsw 19:i32, %0

Cost = 1
second query is SAT-- constant doesn't work

--------------------------------
guess 4

%0:i32 = var
%1:i32 = var
%2:i32 = sdiv %1, 4:i32
%3:i32 = subnsw %0, %2

Cost = 6
second query is SAT-- constant doesn't work

--------------------------------
guess 5

%0:i32 = var
%1:i32 = var
%2:i32 = subnsw %1, 17:i32
%3:i32 = sdiv %2, 25:i32
%4:i32 = subnsw %0, %3
%5:i32 = sdiv %4, 3:i32

Cost = 12
second query is SAT-- constant doesn't work

--------------------------------
guess 6

%0:i32 = var
%1:i32 = var
%2:i32 = sdiv %1, 4:i32
%3:i32 = subnsw %0, %2
%4:i32 = var
%5:i32 = var
%6:i32 = subnsw %5, 17:i32
%7:i32 = sdiv %6, 25:i32
%8:i32 = subnsw %4, %7
%9:i32 = sdiv %8, 3:i32
%10:i32 = subnsw %3, %9

Cost = 19
second query is SAT-- constant doesn't work

--------------------------------
guess 7

%0:i32 = var
%1:i32 = var
%2:i32 = sdiv %1, 4:i32
%3:i32 = subnsw %0, %2
%4:i32 = var
%5:i32 = var
%6:i32 = subnsw %5, 17:i32
%7:i32 = sdiv %6, 25:i32
%8:i32 = subnsw %4, %7
%9:i32 = sdiv %8, 3:i32
%10:i32 = subnsw %3, %9
%11:i32 = var
%12:i32 = mulnsw 19:i32, %11
%13:i32 = addnsw %10, %12

Cost = 21
second query is SAT-- constant doesn't work
Dataflow Pruned 0/0
There are 8 Guesses
There are 0 RHSs before deduplication
There are 0 RHSs after deduplication
got 8 candidates from LHS

-------------------------------------------------
%0:i32 = var
%1:i32 = var
%2:i32 = sdiv %1, 4:i32
%3:i32 = subnsw %0, %2
%4:i32 = var
%5:i32 = var
%6:i32 = subnsw %5, 17:i32
%7:i32 = sdiv %6, 25:i32
%8:i32 = subnsw %4, %7
%9:i32 = sdiv %8, 3:i32
%10:i32 = subnsw %3, %9
%11:i32 = var
%12:i32 = mulnsw 19:i32, %11
%13:i32 = addnsw %10, %12
%14:i32 = addnsw 15:i32, %13
%15:i32 = srem %14, 30:i32
infer %15


--------------------------------
guess 0

%0:i32 = var ; reservedconst_1

Cost = 0
first query is SAT, returning the model:
reservedconst_1: 15
0 th attempt: second query is SAT-- constant doesn't work
first query is SAT, returning the model:
reservedconst_1: -7
1 th attempt: second query is SAT-- constant doesn't work
first query is UNSAT-- no more guesses

--------------------------------
guess 1

%0:i32 = var

Cost = 0
second query is SAT-- constant doesn't work

--------------------------------
guess 2

%0:i32 = var
%1:i32 = mulnsw 19:i32, %0

Cost = 1
second query is SAT-- constant doesn't work

--------------------------------
guess 3

%0:i32 = var
%1:i32 = var
%2:i32 = sdiv %1, 4:i32
%3:i32 = subnsw %0, %2

Cost = 6
second query is SAT-- constant doesn't work

--------------------------------
guess 4

%0:i32 = var
%1:i32 = var
%2:i32 = subnsw %1, 17:i32
%3:i32 = sdiv %2, 25:i32
%4:i32 = subnsw %0, %3
%5:i32 = sdiv %4, 3:i32

Cost = 12
second query is SAT-- constant doesn't work

--------------------------------
guess 5

%0:i32 = var
%1:i32 = var
%2:i32 = sdiv %1, 4:i32
%3:i32 = subnsw %0, %2
%4:i32 = var
%5:i32 = var
%6:i32 = subnsw %5, 17:i32
%7:i32 = sdiv %6, 25:i32
%8:i32 = subnsw %4, %7
%9:i32 = sdiv %8, 3:i32
%10:i32 = subnsw %3, %9

Cost = 19
second query is SAT-- constant doesn't work

--------------------------------
guess 6

%0:i32 = var
%1:i32 = var
%2:i32 = sdiv %1, 4:i32
%3:i32 = subnsw %0, %2
%4:i32 = var
%5:i32 = var
%6:i32 = subnsw %5, 17:i32
%7:i32 = sdiv %6, 25:i32
%8:i32 = subnsw %4, %7
%9:i32 = sdiv %8, 3:i32
%10:i32 = subnsw %3, %9
%11:i32 = var
%12:i32 = mulnsw 19:i32, %11
%13:i32 = addnsw %10, %12

Cost = 21
second query is SAT-- constant doesn't work

--------------------------------
guess 7

%0:i32 = var
%1:i32 = var
%2:i32 = sdiv %1, 4:i32
%3:i32 = subnsw %0, %2
%4:i32 = var
%5:i32 = var
%6:i32 = subnsw %5, 17:i32
%7:i32 = sdiv %6, 25:i32
%8:i32 = subnsw %4, %7
%9:i32 = sdiv %8, 3:i32
%10:i32 = subnsw %3, %9
%11:i32 = var
%12:i32 = mulnsw 19:i32, %11
%13:i32 = addnsw %10, %12
%14:i32 = addnsw 15:i32, %13

Cost = 22
second query is SAT-- constant doesn't work
Dataflow Pruned 0/0
There are 8 Guesses
There are 0 RHSs before deduplication
There are 0 RHSs after deduplication
got 2 candidates from LHS

-------------------------------------------------
%0:i32 = var
%1:i32 = sdiv %0, 28:i32
infer %1


--------------------------------
guess 0

%0:i32 = var ; reservedconst_1

Cost = 0
first query is SAT, returning the model:
reservedconst_1: 0
0 th attempt: second query is SAT-- constant doesn't work
first query is SAT, returning the model:
reservedconst_1: 33554432
1 th attempt: second query is SAT-- constant doesn't work
first query is UNSAT-- no more guesses

--------------------------------
guess 1

%0:i32 = var

Cost = 0
second query is SAT-- constant doesn't work
Dataflow Pruned 0/0
There are 2 Guesses
There are 0 RHSs before deduplication
There are 0 RHSs after deduplication
got 3 candidates from LHS

-------------------------------------------------
%0:i32 = var
%1:i32 = addnsw 1:i32, %0
%2:i32 = sdiv 29:i32, %1
infer %2


--------------------------------
guess 0

%0:i32 = var ; reservedconst_1

Cost = 0
first query is SAT, returning the model:
reservedconst_1: 29
0 th attempt: second query is SAT-- constant doesn't work
first query is SAT, returning the model:
reservedconst_1: 0
1 th attempt: second query is SAT-- constant doesn't work
first query is UNSAT-- no more guesses

--------------------------------
guess 1

%0:i32 = var

Cost = 0
second query is SAT-- constant doesn't work

--------------------------------
guess 2

%0:i32 = var
%1:i32 = addnsw 1:i32, %0

Cost = 1
second query is SAT-- constant doesn't work
Dataflow Pruned 0/0
There are 3 Guesses
There are 0 RHSs before deduplication
There are 0 RHSs after deduplication
got 6 candidates from LHS

-------------------------------------------------
%0:i32 = var
%1:i32 = addnsw 1:i32, %0
%2:i32 = sdiv 29:i32, %1
%3:i32 = var
%4:i32 = sdiv %3, 28:i32
%5:i32 = mulnsw %2, %4
infer %5


--------------------------------
guess 0

%0:i32 = var ; reservedconst_1

Cost = 0
first query is SAT, returning the model:
reservedconst_1: 0
0 th attempt: second query is SAT-- constant doesn't work
first query is SAT, returning the model:
reservedconst_1: 57991136
1 th attempt: second query is SAT-- constant doesn't work
first query is UNSAT-- no more guesses

--------------------------------
guess 1

%0:i32 = var

Cost = 0
second query is SAT-- constant doesn't work

--------------------------------
guess 2

%0:i32 = var

Cost = 0
second query is SAT-- constant doesn't work

--------------------------------
guess 3

%0:i32 = var
%1:i32 = addnsw 1:i32, %0

Cost = 1
second query is SAT-- constant doesn't work

--------------------------------
guess 4

%0:i32 = var
%1:i32 = sdiv %0, 28:i32

Cost = 5
second query is SAT-- constant doesn't work

--------------------------------
guess 5

%0:i32 = var
%1:i32 = addnsw 1:i32, %0
%2:i32 = sdiv 29:i32, %1

Cost = 6
second query is SAT-- constant doesn't work
Dataflow Pruned 0/0
There are 6 Guesses
There are 0 RHSs before deduplication
There are 0 RHSs after deduplication
got 2 candidates from LHS

-------------------------------------------------
%0:i32 = var
%1:i32 = subnsw 21:i32, %0
infer %1


--------------------------------
guess 0

%0:i32 = var ; reservedconst_1

Cost = 0
first query is SAT, returning the model:
reservedconst_1: 21
0 th attempt: second query is SAT-- constant doesn't work
first query is SAT, returning the model:
reservedconst_1: -32747
1 th attempt: second query is SAT-- constant doesn't work
first query is UNSAT-- no more guesses

--------------------------------
guess 1

%0:i32 = var

Cost = 0
second query is SAT-- constant doesn't work
Dataflow Pruned 0/0
There are 2 Guesses
There are 0 RHSs before deduplication
There are 0 RHSs after deduplication
got 3 candidates from LHS

-------------------------------------------------
%0:i32 = var
%1:i32 = subnsw 21:i32, %0
%2:i32 = sdiv %1, 11:i32
infer %2


--------------------------------
guess 0

%0:i32 = var ; reservedconst_1

Cost = 0
first query is SAT, returning the model:
reservedconst_1: 1
0 th attempt: second query is SAT-- constant doesn't work
first query is SAT, returning the model:
reservedconst_1: 106922893
1 th attempt: second query is SAT-- constant doesn't work
first query is UNSAT-- no more guesses

--------------------------------
guess 1

%0:i32 = var

Cost = 0
second query is SAT-- constant doesn't work

--------------------------------
guess 2

%0:i32 = var
%1:i32 = subnsw 21:i32, %0

Cost = 1
second query is SAT-- constant doesn't work
Dataflow Pruned 0/0
There are 3 Guesses
There are 0 RHSs before deduplication
There are 0 RHSs after deduplication
got 8 candidates from LHS

-------------------------------------------------
%0:i32 = var
%1:i32 = addnsw 1:i32, %0
%2:i32 = sdiv 29:i32, %1
%3:i32 = var
%4:i32 = sdiv %3, 28:i32
%5:i32 = mulnsw %2, %4
%6:i32 = var
%7:i32 = subnsw 21:i32, %6
%8:i32 = sdiv %7, 11:i32
%9:i32 = mulnsw %5, %8
infer %9


--------------------------------
guess 0

%0:i32 = var ; reservedconst_1

Cost = 0
first query is SAT, returning the model:
reservedconst_1: 0
ConstantSynthesis: solver returns error on second query

--------------------------------
guess 1

%0:i32 = var

Cost = 0
verification query failed!
Dataflow Pruned 0/0
There are 8 Guesses
There are 0 RHSs before deduplication
There are 0 RHSs after deduplication
got 8 candidates from LHS

-------------------------------------------------
%0:i32 = var
%1:i32 = addnsw 1:i32, %0
%2:i32 = sdiv 29:i32, %1
%3:i32 = var
%4:i32 = sdiv %3, 28:i32
%5:i32 = mulnsw %2, %4
%6:i32 = var
%7:i32 = subnsw 21:i32, %6
%8:i32 = sdiv %7, 11:i32
%9:i32 = mulnsw %5, %8
%10:i32 = subnsw 1:i32, %9
infer %10


--------------------------------
guess 0

%0:i32 = var ; reservedconst_1

Cost = 0
first query is SAT, returning the model:
reservedconst_1: 1
ConstantSynthesis: solver returns error on second query

--------------------------------
guess 1

%0:i32 = var
%1:i32 = subnsw 21:i32, %0

Cost = 1
verification query failed!
Dataflow Pruned 0/0
There are 8 Guesses
There are 0 RHSs before deduplication
There are 0 RHSs after deduplication
got 8 candidates from LHS

-------------------------------------------------
%0:i32 = var
%1:i32 = addnsw 1:i32, %0
%2:i32 = sdiv 29:i32, %1
%3:i32 = var
%4:i32 = sdiv %3, 28:i32
%5:i32 = mulnsw %2, %4
%6:i32 = var
%7:i32 = subnsw 21:i32, %6
%8:i32 = sdiv %7, 11:i32
%9:i32 = mulnsw %5, %8
%10:i32 = subnsw 1:i32, %9
%11:i32 = var
%12:i32 = sdiv %11, 28:i32
%13:i32 = mulnsw %10, %12
infer %13


--------------------------------
guess 0

%0:i32 = var ; reservedconst_1

Cost = 0
first query is SAT, returning the model:
reservedconst_1: 0
ConstantSynthesis: solver returns error on second query

--------------------------------
guess 1

%0:i32 = var

Cost = 0
verification query failed!
Dataflow Pruned 0/0
There are 8 Guesses
There are 0 RHSs before deduplication
There are 0 RHSs after deduplication
got 8 candidates from LHS

-------------------------------------------------
%0:i32 = var
%1:i32 = var
%2:i32 = addnsw 1:i32, %1
%3:i32 = sdiv 29:i32, %2
%4:i32 = var
%5:i32 = sdiv %4, 28:i32
%6:i32 = mulnsw %3, %5
%7:i32 = var
%8:i32 = subnsw 21:i32, %7
%9:i32 = sdiv %8, 11:i32
%10:i32 = mulnsw %6, %9
%11:i32 = subnsw 1:i32, %10
%12:i32 = var
%13:i32 = sdiv %12, 28:i32
%14:i32 = mulnsw %11, %13
%15:i32 = subnsw %0, %14
infer %15


--------------------------------
guess 0

%0:i32 = var ; reservedconst_1

Cost = 0
first query is SAT, returning the model:
reservedconst_1: 0
ConstantSynthesis: solver returns error on second query

--------------------------------
guess 1

%0:i32 = var

Cost = 0
verification query failed!
Dataflow Pruned 0/0
There are 8 Guesses
There are 0 RHSs before deduplication
There are 0 RHSs after deduplication
got 4 candidates from LHS

-------------------------------------------------
%0:i32 = var
%1:i32 = var
%2:i32 = sdiv %1, 4:i32
%3:i32 = addnsw %0, %2
infer %3


--------------------------------
guess 0

%0:i32 = var ; reservedconst_1

Cost = 0
first query is SAT, returning the model:
reservedconst_1: 0
0 th attempt: second query is SAT-- constant doesn't work
first query is SAT, returning the model:
reservedconst_1: 16771216
1 th attempt: second query is SAT-- constant doesn't work
first query is UNSAT-- no more guesses

--------------------------------
guess 1

%0:i32 = var

Cost = 0
second query is SAT-- constant doesn't work

--------------------------------
guess 2

%0:i32 = var

Cost = 0
second query is SAT-- constant doesn't work

--------------------------------
guess 3

%0:i32 = var
%1:i32 = sdiv %0, 4:i32

Cost = 5
second query is SAT-- constant doesn't work
Dataflow Pruned 0/0
There are 4 Guesses
There are 0 RHSs before deduplication
There are 0 RHSs after deduplication
got 6 candidates from LHS

-------------------------------------------------
%0:i32 = var
%1:i32 = var
%2:i32 = var
%3:i32 = sdiv %2, 4:i32
%4:i32 = addnsw %1, %3
%5:i32 = addnsw %0, %4
infer %5


--------------------------------
guess 0

%0:i32 = var ; reservedconst_1

Cost = 0
first query is SAT, returning the model:
reservedconst_1: 0
0 th attempt: second query is SAT-- constant doesn't work
first query is SAT, returning the model:
reservedconst_1: -1
1 th attempt: second query is SAT-- constant doesn't work
first query is UNSAT-- no more guesses

--------------------------------
guess 1

%0:i32 = var

Cost = 0
second query is SAT-- constant doesn't work

--------------------------------
guess 2

%0:i32 = var

Cost = 0
second query is SAT-- constant doesn't work

--------------------------------
guess 3

%0:i32 = var

Cost = 0
second query is SAT-- constant doesn't work

--------------------------------
guess 4

%0:i32 = var
%1:i32 = sdiv %0, 4:i32

Cost = 5
second query is SAT-- constant doesn't work

--------------------------------
guess 5

%0:i32 = var
%1:i32 = var
%2:i32 = sdiv %1, 4:i32
%3:i32 = addnsw %0, %2

Cost = 6
second query is SAT-- constant doesn't work
Dataflow Pruned 0/0
There are 6 Guesses
There are 0 RHSs before deduplication
There are 0 RHSs after deduplication
got 7 candidates from LHS

-------------------------------------------------
%0:i32 = var
%1:i32 = var
%2:i32 = var
%3:i32 = sdiv %2, 4:i32
%4:i32 = addnsw %1, %3
%5:i32 = addnsw %0, %4
%6:i32 = addnsw 2:i32, %5
infer %6


--------------------------------
guess 0

%0:i32 = var ; reservedconst_1

Cost = 0
first query is SAT, returning the model:
reservedconst_1: 2
0 th attempt: second query is SAT-- constant doesn't work
first query is SAT, returning the model:
reservedconst_1: -97519821
1 th attempt: second query is SAT-- constant doesn't work
first query is UNSAT-- no more guesses

--------------------------------
guess 1

%0:i32 = var

Cost = 0
second query is SAT-- constant doesn't work

--------------------------------
guess 2

%0:i32 = var

Cost = 0
second query is SAT-- constant doesn't work

--------------------------------
guess 3

%0:i32 = var

Cost = 0
second query is SAT-- constant doesn't work

--------------------------------
guess 4

%0:i32 = var
%1:i32 = sdiv %0, 4:i32

Cost = 5
second query is SAT-- constant doesn't work

--------------------------------
guess 5

%0:i32 = var
%1:i32 = var
%2:i32 = sdiv %1, 4:i32
%3:i32 = addnsw %0, %2

Cost = 6
second query is SAT-- constant doesn't work

--------------------------------
guess 6

%0:i32 = var
%1:i32 = var
%2:i32 = var
%3:i32 = sdiv %2, 4:i32
%4:i32 = addnsw %1, %3
%5:i32 = addnsw %0, %4

Cost = 7
second query is SAT-- constant doesn't work
Dataflow Pruned 0/0
There are 7 Guesses
There are 0 RHSs before deduplication
There are 0 RHSs after deduplication
got 8 candidates from LHS

-------------------------------------------------
%0:i32 = var
%1:i32 = var
%2:i32 = var
%3:i32 = sdiv %2, 4:i32
%4:i32 = addnsw %1, %3
%5:i32 = addnsw %0, %4
%6:i32 = addnsw 2:i32, %5
%7:i32 = var
%8:i32 = subnsw %6, %7
infer %8


--------------------------------
guess 0

%0:i32 = var ; reservedconst_1

Cost = 0
first query is SAT, returning the model:
reservedconst_1: 2
0 th attempt: second query is SAT-- constant doesn't work
first query is SAT, returning the model:
reservedconst_1: 0
1 th attempt: second query is SAT-- constant doesn't work
first query is UNSAT-- no more guesses

--------------------------------
guess 1

%0:i32 = var

Cost = 0
second query is SAT-- constant doesn't work

--------------------------------
guess 2

%0:i32 = var

Cost = 0
second query is SAT-- constant doesn't work

--------------------------------
guess 3

%0:i32 = var

Cost = 0
second query is SAT-- constant doesn't work

--------------------------------
guess 4

%0:i32 = var
%1:i32 = sdiv %0, 4:i32

Cost = 5
second query is SAT-- constant doesn't work

--------------------------------
guess 5

%0:i32 = var
%1:i32 = var
%2:i32 = sdiv %1, 4:i32
%3:i32 = addnsw %0, %2

Cost = 6
second query is SAT-- constant doesn't work

--------------------------------
guess 6

%0:i32 = var
%1:i32 = var
%2:i32 = var
%3:i32 = sdiv %2, 4:i32
%4:i32 = addnsw %1, %3
%5:i32 = addnsw %0, %4

Cost = 7
second query is SAT-- constant doesn't work

--------------------------------
guess 7

%0:i32 = var
%1:i32 = var
%2:i32 = var
%3:i32 = sdiv %2, 4:i32
%4:i32 = addnsw %1, %3
%5:i32 = addnsw %0, %4
%6:i32 = addnsw 2:i32, %5

Cost = 8
second query is SAT-- constant doesn't work
Dataflow Pruned 0/0
There are 8 Guesses
There are 0 RHSs before deduplication
There are 0 RHSs after deduplication
got 8 candidates from LHS

-------------------------------------------------
%0:i32 = var
%1:i32 = var
%2:i32 = var
%3:i32 = sdiv %2, 4:i32
%4:i32 = addnsw %1, %3
%5:i32 = addnsw %0, %4
%6:i32 = addnsw 2:i32, %5
%7:i32 = var
%8:i32 = subnsw %6, %7
%9:i32 = var
%10:i32 = sdiv %9, 4:i32
%11:i32 = addnsw %8, %10
infer %11


--------------------------------
guess 0

%0:i32 = var ; reservedconst_1

Cost = 0
first query is SAT, returning the model:
reservedconst_1: 2
0 th attempt: second query is SAT-- constant doesn't work
first query is SAT, returning the model:
reservedconst_1: -7553
1 th attempt: second query is SAT-- constant doesn't work
first query is UNSAT-- no more guesses

--------------------------------
guess 1

%0:i32 = var

Cost = 0
second query is SAT-- constant doesn't work

--------------------------------
guess 2

%0:i32 = var

Cost = 0
second query is SAT-- constant doesn't work

--------------------------------
guess 3

%0:i32 = var

Cost = 0
second query is SAT-- constant doesn't work

--------------------------------
guess 4

%0:i32 = var
%1:i32 = sdiv %0, 4:i32

Cost = 5
second query is SAT-- constant doesn't work

--------------------------------
guess 5

%0:i32 = var
%1:i32 = var
%2:i32 = var
%3:i32 = sdiv %2, 4:i32
%4:i32 = addnsw %1, %3
%5:i32 = addnsw %0, %4

Cost = 7
second query is SAT-- constant doesn't work

--------------------------------
guess 6

%0:i32 = var
%1:i32 = var
%2:i32 = var
%3:i32 = sdiv %2, 4:i32
%4:i32 = addnsw %1, %3
%5:i32 = addnsw %0, %4
%6:i32 = addnsw 2:i32, %5

Cost = 8
second query is SAT-- constant doesn't work

--------------------------------
guess 7

%0:i32 = var
%1:i32 = var
%2:i32 = var
%3:i32 = sdiv %2, 4:i32
%4:i32 = addnsw %1, %3
%5:i32 = addnsw %0, %4
%6:i32 = addnsw 2:i32, %5
%7:i32 = var
%8:i32 = subnsw %6, %7

Cost = 9
second query is SAT-- constant doesn't work
Dataflow Pruned 0/0
There are 8 Guesses
There are 0 RHSs before deduplication
There are 0 RHSs after deduplication
got 8 candidates from LHS

-------------------------------------------------
%0:i32 = var
%1:i32 = var
%2:i32 = var
%3:i32 = sdiv %2, 4:i32
%4:i32 = addnsw %1, %3
%5:i32 = addnsw %0, %4
%6:i32 = addnsw 2:i32, %5
%7:i32 = var
%8:i32 = subnsw %6, %7
%9:i32 = var
%10:i32 = sdiv %9, 4:i32
%11:i32 = addnsw %8, %10
%12:i32 = srem %11, 7:i32
infer %12


--------------------------------
guess 0

%0:i32 = var ; reservedconst_1

Cost = 0
first query is SAT, returning the model:
reservedconst_1: 2
0 th attempt: second query is SAT-- constant doesn't work
first query is SAT, returning the model:
reservedconst_1: 3
1 th attempt: second query is SAT-- constant doesn't work
first query is UNSAT-- no more guesses

--------------------------------
guess 1

%0:i32 = var

Cost = 0
second query is SAT-- constant doesn't work

--------------------------------
guess 2

%0:i32 = var

Cost = 0
second query is SAT-- constant doesn't work

--------------------------------
guess 3

%0:i32 = var
%1:i32 = sdiv %0, 4:i32

Cost = 5
second query is SAT-- constant doesn't work

--------------------------------
guess 4

%0:i32 = var
%1:i32 = var
%2:i32 = var
%3:i32 = sdiv %2, 4:i32
%4:i32 = addnsw %1, %3
%5:i32 = addnsw %0, %4

Cost = 7
second query is SAT-- constant doesn't work

--------------------------------
guess 5

%0:i32 = var
%1:i32 = var
%2:i32 = var
%3:i32 = sdiv %2, 4:i32
%4:i32 = addnsw %1, %3
%5:i32 = addnsw %0, %4
%6:i32 = addnsw 2:i32, %5

Cost = 8
second query is SAT-- constant doesn't work

--------------------------------
guess 6

%0:i32 = var
%1:i32 = var
%2:i32 = var
%3:i32 = sdiv %2, 4:i32
%4:i32 = addnsw %1, %3
%5:i32 = addnsw %0, %4
%6:i32 = addnsw 2:i32, %5
%7:i32 = var
%8:i32 = subnsw %6, %7

Cost = 9
second query is SAT-- constant doesn't work

--------------------------------
guess 7

%0:i32 = var
%1:i32 = var
%2:i32 = var
%3:i32 = sdiv %2, 4:i32
%4:i32 = addnsw %1, %3
%5:i32 = addnsw %0, %4
%6:i32 = addnsw 2:i32, %5
%7:i32 = var
%8:i32 = subnsw %6, %7
%9:i32 = var
%10:i32 = sdiv %9, 4:i32
%11:i32 = addnsw %8, %10

Cost = 15
second query is SAT-- constant doesn't work
Dataflow Pruned 0/0
There are 8 Guesses
There are 0 RHSs before deduplication
There are 0 RHSs after deduplication
got 8 candidates from LHS

-------------------------------------------------
%0:i32 = var
%1:i32 = var
%2:i32 = var
%3:i32 = var
%4:i32 = sdiv %3, 4:i32
%5:i32 = addnsw %2, %4
%6:i32 = addnsw %1, %5
%7:i32 = addnsw 2:i32, %6
%8:i32 = var
%9:i32 = subnsw %7, %8
%10:i32 = var
%11:i32 = sdiv %10, 4:i32
%12:i32 = addnsw %9, %11
%13:i32 = srem %12, 7:i32
%14:i32 = subnsw %0, %13
infer %14


--------------------------------
guess 0

%0:i32 = var ; reservedconst_1

Cost = 0
first query is SAT, returning the model:
reservedconst_1: -2
0 th attempt: second query is SAT-- constant doesn't work
first query is SAT, returning the model:
reservedconst_1: 1073741822
1 th attempt: second query is SAT-- constant doesn't work
first query is UNSAT-- no more guesses

--------------------------------
guess 1

%0:i32 = var

Cost = 0
second query is SAT-- constant doesn't work

--------------------------------
guess 2

%0:i32 = var

Cost = 0
second query is SAT-- constant doesn't work

--------------------------------
guess 3

%0:i32 = var
%1:i32 = sdiv %0, 4:i32

Cost = 5
second query is SAT-- constant doesn't work

--------------------------------
guess 4

%0:i32 = var
%1:i32 = var
%2:i32 = var
%3:i32 = sdiv %2, 4:i32
%4:i32 = addnsw %1, %3
%5:i32 = addnsw %0, %4
%6:i32 = addnsw 2:i32, %5

Cost = 8
second query is SAT-- constant doesn't work

--------------------------------
guess 5

%0:i32 = var
%1:i32 = var
%2:i32 = var
%3:i32 = sdiv %2, 4:i32
%4:i32 = addnsw %1, %3
%5:i32 = addnsw %0, %4
%6:i32 = addnsw 2:i32, %5
%7:i32 = var
%8:i32 = subnsw %6, %7

Cost = 9
second query is SAT-- constant doesn't work

--------------------------------
guess 6

%0:i32 = var
%1:i32 = var
%2:i32 = var
%3:i32 = sdiv %2, 4:i32
%4:i32 = addnsw %1, %3
%5:i32 = addnsw %0, %4
%6:i32 = addnsw 2:i32, %5
%7:i32 = var
%8:i32 = subnsw %6, %7
%9:i32 = var
%10:i32 = sdiv %9, 4:i32
%11:i32 = addnsw %8, %10

Cost = 15
second query is SAT-- constant doesn't work

--------------------------------
guess 7

%0:i32 = var
%1:i32 = var
%2:i32 = var
%3:i32 = sdiv %2, 4:i32
%4:i32 = addnsw %1, %3
%5:i32 = addnsw %0, %4
%6:i32 = addnsw 2:i32, %5
%7:i32 = var
%8:i32 = subnsw %6, %7
%9:i32 = var
%10:i32 = sdiv %9, 4:i32
%11:i32 = addnsw %8, %10
%12:i32 = srem %11, 7:i32

Cost = 20
second query is SAT-- constant doesn't work
Dataflow Pruned 0/0
There are 8 Guesses
There are 0 RHSs before deduplication
There are 0 RHSs after deduplication
got 2 candidates from LHS

-------------------------------------------------
%0:i32 = var
%1:i32 = addnsw 40:i32, %0
infer %1


--------------------------------
guess 0

%0:i32 = var ; reservedconst_1

Cost = 0
first query is SAT, returning the model:
reservedconst_1: 40
0 th attempt: second query is SAT-- constant doesn't work
first query is SAT, returning the model:
reservedconst_1: 41
1 th attempt: second query is SAT-- constant doesn't work
first query is UNSAT-- no more guesses

--------------------------------
guess 1

%0:i32 = var

Cost = 0
second query is SAT-- constant doesn't work
Dataflow Pruned 0/0
There are 2 Guesses
There are 0 RHSs before deduplication
There are 0 RHSs after deduplication
got 3 candidates from LHS

-------------------------------------------------
%0:i32 = var
%1:i32 = addnsw 40:i32, %0
%2:i32 = sdiv %1, 44:i32
infer %2


--------------------------------
guess 0

%0:i32 = var ; reservedconst_1

Cost = 0
first query is SAT, returning the model:
reservedconst_1: 0
0 th attempt: second query is SAT-- constant doesn't work
first query is SAT, returning the model:
reservedconst_1: 48234496
1 th attempt: second query is SAT-- constant doesn't work
first query is UNSAT-- no more guesses

--------------------------------
guess 1

%0:i32 = var

Cost = 0
second query is SAT-- constant doesn't work

--------------------------------
guess 2

%0:i32 = var
%1:i32 = addnsw 40:i32, %0

Cost = 1
second query is SAT-- constant doesn't work
Dataflow Pruned 0/0
There are 3 Guesses
There are 0 RHSs before deduplication
There are 0 RHSs after deduplication
got 4 candidates from LHS

-------------------------------------------------
%0:i32 = var
%1:i32 = addnsw 40:i32, %0
%2:i32 = sdiv %1, 44:i32
%3:i32 = addnsw 3:i32, %2
infer %3


--------------------------------
guess 0

%0:i32 = var ; reservedconst_1

Cost = 0
first query is SAT, returning the model:
reservedconst_1: 3
0 th attempt: second query is SAT-- constant doesn't work
first query is SAT, returning the model:
reservedconst_1: 34664451
1 th attempt: second query is SAT-- constant doesn't work
first query is UNSAT-- no more guesses

--------------------------------
guess 1

%0:i32 = var

Cost = 0
second query is SAT-- constant doesn't work

--------------------------------
guess 2

%0:i32 = var
%1:i32 = addnsw 40:i32, %0

Cost = 1
second query is SAT-- constant doesn't work

--------------------------------
guess 3

%0:i32 = var
%1:i32 = addnsw 40:i32, %0
%2:i32 = sdiv %1, 44:i32

Cost = 6
second query is SAT-- constant doesn't work
Dataflow Pruned 0/0
There are 4 Guesses
There are 0 RHSs before deduplication
There are 0 RHSs after deduplication
got 2 candidates from LHS

-------------------------------------------------
%0:i32 = var
%1:i32 = addnsw 28:i32, %0
infer %1


--------------------------------
guess 0

%0:i32 = var ; reservedconst_1

Cost = 0
first query is SAT, returning the model:
reservedconst_1: 28
0 th attempt: second query is SAT-- constant doesn't work
first query is SAT, returning the model:
reservedconst_1: 29
1 th attempt: second query is SAT-- constant doesn't work
first query is UNSAT-- no more guesses

--------------------------------
guess 1

%0:i32 = var

Cost = 0
second query is SAT-- constant doesn't work
Dataflow Pruned 0/0
There are 2 Guesses
There are 0 RHSs before deduplication
There are 0 RHSs after deduplication
got 3 candidates from LHS

-------------------------------------------------
%0:i32 = var
%1:i32 = sdiv %0, 4:i32
%2:i32 = mulnsw 31:i32, %1
infer %2


--------------------------------
guess 0

%0:i32 = var ; reservedconst_1

Cost = 0
first query is SAT, returning the model:
reservedconst_1: 0
0 th attempt: second query is SAT-- constant doesn't work
first query is SAT, returning the model:
reservedconst_1: 1017730682
1 th attempt: second query is SAT-- constant doesn't work
first query is UNSAT-- no more guesses

--------------------------------
guess 1

%0:i32 = var

Cost = 0
second query is SAT-- constant doesn't work

--------------------------------
guess 2

%0:i32 = var
%1:i32 = sdiv %0, 4:i32

Cost = 5
second query is SAT-- constant doesn't work
Dataflow Pruned 0/0
There are 3 Guesses
There are 0 RHSs before deduplication
There are 0 RHSs after deduplication
got 6 candidates from LHS

-------------------------------------------------
%0:i32 = var
%1:i32 = addnsw 28:i32, %0
%2:i32 = var
%3:i32 = sdiv %2, 4:i32
%4:i32 = mulnsw 31:i32, %3
%5:i32 = subnsw %1, %4
infer %5


--------------------------------
guess 0

%0:i32 = var ; reservedconst_1

Cost = 0
first query is SAT, returning the model:
reservedconst_1: 28
0 th attempt: second query is SAT-- constant doesn't work
first query is SAT, returning the model:
reservedconst_1: -2147483633
1 th attempt: second query is SAT-- constant doesn't work
first query is UNSAT-- no more guesses

--------------------------------
guess 1

%0:i32 = var

Cost = 0
second query is SAT-- constant doesn't work

--------------------------------
guess 2

%0:i32 = var

Cost = 0
second query is SAT-- constant doesn't work

--------------------------------
guess 3

%0:i32 = var
%1:i32 = addnsw 28:i32, %0

Cost = 1
second query is SAT-- constant doesn't work

--------------------------------
guess 4

%0:i32 = var
%1:i32 = sdiv %0, 4:i32

Cost = 5
second query is SAT-- constant doesn't work

--------------------------------
guess 5

%0:i32 = var
%1:i32 = sdiv %0, 4:i32
%2:i32 = mulnsw 31:i32, %1

Cost = 6
second query is SAT-- constant doesn't work
Dataflow Pruned 0/0
There are 6 Guesses
There are 0 RHSs before deduplication
There are 0 RHSs after deduplication
#########################################################
; exiting Souper's runOnFunction() for easter()

; entering Souper's runOnFunction() for week_day()

; ModuleID = './Holidays_related_to_Easter.c.bc'
source_filename = "./Holidays_related_to_Easter.c"
target datalayout = "e-m:e-p:32:32-i64:64-n32:64-S128"
target triple = "wasm32-unknown-wasi"

%struct.date_t = type { i32, i32, i32, i32 }
%struct.easter_related_t = type { %struct.date_t, %struct.date_t, %struct.date_t, %struct.date_t, %struct.date_t }

@.str = private unnamed_addr constant [4 x i8] c"Jan\00", align 1
@.str.1 = private unnamed_addr constant [4 x i8] c"Feb\00", align 1
@.str.2 = private unnamed_addr constant [4 x i8] c"Mar\00", align 1
@.str.3 = private unnamed_addr constant [4 x i8] c"Apr\00", align 1
@.str.4 = private unnamed_addr constant [4 x i8] c"May\00", align 1
@.str.5 = private unnamed_addr constant [4 x i8] c"Jun\00", align 1
@.str.6 = private unnamed_addr constant [4 x i8] c"Jul\00", align 1
@.str.7 = private unnamed_addr constant [4 x i8] c"Aug\00", align 1
@.str.8 = private unnamed_addr constant [4 x i8] c"Sep\00", align 1
@.str.9 = private unnamed_addr constant [4 x i8] c"Oct\00", align 1
@.str.10 = private unnamed_addr constant [4 x i8] c"Nov\00", align 1
@.str.11 = private unnamed_addr constant [4 x i8] c"Dec\00", align 1
@mon_fmt = hidden global [13 x i8*] [i8* null, i8* getelementptr inbounds ([4 x i8], [4 x i8]* @.str, i32 0, i32 0), i8* getelementptr inbounds ([4 x i8], [4 x i8]* @.str.1, i32 0, i32 0), i8* getelementptr inbounds ([4 x i8], [4 x i8]* @.str.2, i32 0, i32 0), i8* getelementptr inbounds ([4 x i8], [4 x i8]* @.str.3, i32 0, i32 0), i8* getelementptr inbounds ([4 x i8], [4 x i8]* @.str.4, i32 0, i32 0), i8* getelementptr inbounds ([4 x i8], [4 x i8]* @.str.5, i32 0, i32 0), i8* getelementptr inbounds ([4 x i8], [4 x i8]* @.str.6, i32 0, i32 0), i8* getelementptr inbounds ([4 x i8], [4 x i8]* @.str.7, i32 0, i32 0), i8* getelementptr inbounds ([4 x i8], [4 x i8]* @.str.8, i32 0, i32 0), i8* getelementptr inbounds ([4 x i8], [4 x i8]* @.str.9, i32 0, i32 0), i8* getelementptr inbounds ([4 x i8], [4 x i8]* @.str.10, i32 0, i32 0), i8* getelementptr inbounds ([4 x i8], [4 x i8]* @.str.11, i32 0, i32 0)], align 16
@.str.12 = private unnamed_addr constant [4 x i8] c"Sat\00", align 1
@.str.13 = private unnamed_addr constant [4 x i8] c"Sun\00", align 1
@.str.14 = private unnamed_addr constant [4 x i8] c"Mon\00", align 1
@.str.15 = private unnamed_addr constant [4 x i8] c"Tue\00", align 1
@.str.16 = private unnamed_addr constant [4 x i8] c"Wed\00", align 1
@.str.17 = private unnamed_addr constant [4 x i8] c"Thu\00", align 1
@.str.18 = private unnamed_addr constant [4 x i8] c"Fri\00", align 1
@week_day_fmt = hidden global [8 x i8*] [i8* null, i8* getelementptr inbounds ([4 x i8], [4 x i8]* @.str.12, i32 0, i32 0), i8* getelementptr inbounds ([4 x i8], [4 x i8]* @.str.13, i32 0, i32 0), i8* getelementptr inbounds ([4 x i8], [4 x i8]* @.str.14, i32 0, i32 0), i8* getelementptr inbounds ([4 x i8], [4 x i8]* @.str.15, i32 0, i32 0), i8* getelementptr inbounds ([4 x i8], [4 x i8]* @.str.16, i32 0, i32 0), i8* getelementptr inbounds ([4 x i8], [4 x i8]* @.str.17, i32 0, i32 0), i8* getelementptr inbounds ([4 x i8], [4 x i8]* @.str.18, i32 0, i32 0)], align 16
@__const.month_days.days = private unnamed_addr constant [13 x i32] [i32 0, i32 31, i32 28, i32 31, i32 30, i32 31, i32 30, i32 31, i32 31, i32 30, i32 31, i32 30, i32 31], align 16
@year_months = hidden global i32 12, align 4
@week_days = hidden global i32 7, align 4
@.str.19 = private unnamed_addr constant [106 x i8] c"%4d Easter: %s %2d %s, Ascension: %s %2d %s, Pentecost: %s %2d %s, Trinity: %s %2d %s, Corpus: %s %2d %s\0A\00", align 1
@.str.20 = private unnamed_addr constant [81 x i8] c"Christian holidays, related to Easter, for each centennial from 400 to 2100 CE:\0A\00", align 1
@.str.21 = private unnamed_addr constant [73 x i8] c"\0AChristian holidays, related to Easter, for years from 2010 to 2020 CE:\0A\00", align 1
@llvm.used = appending global [1 x i8*] [i8* bitcast (i32 ()* @__main_void to i8*)], section "llvm.metadata"

@__main_void = alias i32 (), i32 ()* @main

; Function Attrs: noinline nounwind optnone
define hidden i32 @month_days(i32 %year, i32 %month) #0 {
entry:
  %year.addr = alloca i32, align 4
  %month.addr = alloca i32, align 4
  %days = alloca [13 x i32], align 16
  store i32 %year, i32* %year.addr, align 4
  store i32 %month, i32* %month.addr, align 4
  %0 = bitcast [13 x i32]* %days to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 16 %0, i8* align 16 bitcast ([13 x i32]* @__const.month_days.days to i8*), i32 52, i1 false)
  %1 = load i32, i32* %month.addr, align 4
  %cmp = icmp eq i32 %1, 2
  br i1 %cmp, label %cond.true, label %cond.false

cond.true:                                        ; preds = %entry
  %2 = load i32, i32* %year.addr, align 4
  %rem = srem i32 %2, 4
  %cmp1 = icmp eq i32 %rem, 0
  br i1 %cmp1, label %land.lhs.true, label %lor.rhs

land.lhs.true:                                    ; preds = %cond.true
  %3 = load i32, i32* %year.addr, align 4
  %rem2 = srem i32 %3, 100
  %cmp3 = icmp ne i32 %rem2, 0
  br i1 %cmp3, label %lor.end, label %lor.rhs

lor.rhs:                                          ; preds = %land.lhs.true, %cond.true
  %4 = load i32, i32* %year.addr, align 4
  %rem4 = srem i32 %4, 400
  %cmp5 = icmp eq i32 %rem4, 0
  br label %lor.end

lor.end:                                          ; preds = %lor.rhs, %land.lhs.true
  %5 = phi i1 [ true, %land.lhs.true ], [ %cmp5, %lor.rhs ]
  %lor.ext = zext i1 %5 to i32
  %add = add nsw i32 28, %lor.ext
  br label %cond.end

cond.false:                                       ; preds = %entry
  %6 = load i32, i32* %month.addr, align 4
  %arrayidx = getelementptr inbounds [13 x i32], [13 x i32]* %days, i32 0, i32 %6
  %7 = load i32, i32* %arrayidx, align 4
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %lor.end
  %cond = phi i32 [ %add, %lor.end ], [ %7, %cond.false ]
  ret i32 %cond
}

; Function Attrs: argmemonly nounwind willreturn
declare void @llvm.memcpy.p0i8.p0i8.i32(i8* noalias nocapture writeonly %0, i8* noalias nocapture readonly %1, i32 %2, i1 immarg %3) #1

; Function Attrs: noinline nounwind optnone
define hidden i32 @year_days(i32 %year) #0 {
entry:
  %year.addr = alloca i32, align 4
  store i32 %year, i32* %year.addr, align 4
  %0 = load i32, i32* %year.addr, align 4
  %call = call i32 @month_days(i32 %0, i32 2)
  %cmp = icmp eq i32 %call, 28
  %1 = zext i1 %cmp to i64
  %cond = select i1 %cmp, i32 365, i32 366
  ret i32 %cond
}

; Function Attrs: noinline nounwind optnone
define hidden void @plusab(%struct.date_t* noalias sret align 4 %agg.result, %struct.date_t* %date, i32 %days) #0 {
entry:
  %date.addr = alloca %struct.date_t*, align 4
  %days.addr = alloca i32, align 4
  store %struct.date_t* %date, %struct.date_t** %date.addr, align 4
  store i32 %days, i32* %days.addr, align 4
  br label %while.cond

while.cond:                                       ; preds = %while.body, %entry
  %0 = load i32, i32* %days.addr, align 4
  %cmp = icmp slt i32 %0, 0
  br i1 %cmp, label %while.body, label %while.end

while.body:                                       ; preds = %while.cond
  %1 = load %struct.date_t*, %struct.date_t** %date.addr, align 4
  %year = getelementptr inbounds %struct.date_t, %struct.date_t* %1, i32 0, i32 0
  %2 = load i32, i32* %year, align 4
  %sub = sub nsw i32 %2, 1
  store i32 %sub, i32* %year, align 4
  %3 = load %struct.date_t*, %struct.date_t** %date.addr, align 4
  %year1 = getelementptr inbounds %struct.date_t, %struct.date_t* %3, i32 0, i32 0
  %4 = load i32, i32* %year1, align 4
  %call = call i32 @year_days(i32 %4)
  %5 = load i32, i32* %days.addr, align 4
  %add = add nsw i32 %5, %call
  store i32 %add, i32* %days.addr, align 4
  br label %while.cond

while.end:                                        ; preds = %while.cond
  br label %while.cond2

while.cond2:                                      ; preds = %while.body6, %while.end
  %6 = load i32, i32* %days.addr, align 4
  %7 = load %struct.date_t*, %struct.date_t** %date.addr, align 4
  %year3 = getelementptr inbounds %struct.date_t, %struct.date_t* %7, i32 0, i32 0
  %8 = load i32, i32* %year3, align 4
  %call4 = call i32 @year_days(i32 %8)
  %cmp5 = icmp sgt i32 %6, %call4
  br i1 %cmp5, label %while.body6, label %while.end12

while.body6:                                      ; preds = %while.cond2
  %9 = load %struct.date_t*, %struct.date_t** %date.addr, align 4
  %year7 = getelementptr inbounds %struct.date_t, %struct.date_t* %9, i32 0, i32 0
  %10 = load i32, i32* %year7, align 4
  %call8 = call i32 @year_days(i32 %10)
  %11 = load i32, i32* %days.addr, align 4
  %sub9 = sub nsw i32 %11, %call8
  store i32 %sub9, i32* %days.addr, align 4
  %12 = load %struct.date_t*, %struct.date_t** %date.addr, align 4
  %year10 = getelementptr inbounds %struct.date_t, %struct.date_t* %12, i32 0, i32 0
  %13 = load i32, i32* %year10, align 4
  %add11 = add nsw i32 %13, 1
  store i32 %add11, i32* %year10, align 4
  br label %while.cond2

while.end12:                                      ; preds = %while.cond2
  %14 = load i32, i32* %days.addr, align 4
  %15 = load %struct.date_t*, %struct.date_t** %date.addr, align 4
  %month_day = getelementptr inbounds %struct.date_t, %struct.date_t* %15, i32 0, i32 2
  %16 = load i32, i32* %month_day, align 4
  %add13 = add nsw i32 %16, %14
  store i32 %add13, i32* %month_day, align 4
  br label %while.cond14

while.cond14:                                     ; preds = %if.end, %while.end12
  %17 = load %struct.date_t*, %struct.date_t** %date.addr, align 4
  %month_day15 = getelementptr inbounds %struct.date_t, %struct.date_t* %17, i32 0, i32 2
  %18 = load i32, i32* %month_day15, align 4
  %19 = load %struct.date_t*, %struct.date_t** %date.addr, align 4
  %year16 = getelementptr inbounds %struct.date_t, %struct.date_t* %19, i32 0, i32 0
  %20 = load i32, i32* %year16, align 4
  %21 = load %struct.date_t*, %struct.date_t** %date.addr, align 4
  %month = getelementptr inbounds %struct.date_t, %struct.date_t* %21, i32 0, i32 1
  %22 = load i32, i32* %month, align 4
  %call17 = call i32 @month_days(i32 %20, i32 %22)
  %cmp18 = icmp sgt i32 %18, %call17
  br i1 %cmp18, label %while.body19, label %while.end33

while.body19:                                     ; preds = %while.cond14
  %23 = load %struct.date_t*, %struct.date_t** %date.addr, align 4
  %year20 = getelementptr inbounds %struct.date_t, %struct.date_t* %23, i32 0, i32 0
  %24 = load i32, i32* %year20, align 4
  %25 = load %struct.date_t*, %struct.date_t** %date.addr, align 4
  %month21 = getelementptr inbounds %struct.date_t, %struct.date_t* %25, i32 0, i32 1
  %26 = load i32, i32* %month21, align 4
  %call22 = call i32 @month_days(i32 %24, i32 %26)
  %27 = load %struct.date_t*, %struct.date_t** %date.addr, align 4
  %month_day23 = getelementptr inbounds %struct.date_t, %struct.date_t* %27, i32 0, i32 2
  %28 = load i32, i32* %month_day23, align 4
  %sub24 = sub nsw i32 %28, %call22
  store i32 %sub24, i32* %month_day23, align 4
  %29 = load %struct.date_t*, %struct.date_t** %date.addr, align 4
  %month25 = getelementptr inbounds %struct.date_t, %struct.date_t* %29, i32 0, i32 1
  %30 = load i32, i32* %month25, align 4
  %add26 = add nsw i32 %30, 1
  store i32 %add26, i32* %month25, align 4
  %31 = load %struct.date_t*, %struct.date_t** %date.addr, align 4
  %month27 = getelementptr inbounds %struct.date_t, %struct.date_t* %31, i32 0, i32 1
  %32 = load i32, i32* %month27, align 4
  %33 = load i32, i32* @year_months, align 4
  %cmp28 = icmp sgt i32 %32, %33
  br i1 %cmp28, label %if.then, label %if.end

if.then:                                          ; preds = %while.body19
  %34 = load i32, i32* @year_months, align 4
  %35 = load %struct.date_t*, %struct.date_t** %date.addr, align 4
  %month29 = getelementptr inbounds %struct.date_t, %struct.date_t* %35, i32 0, i32 1
  %36 = load i32, i32* %month29, align 4
  %sub30 = sub nsw i32 %36, %34
  store i32 %sub30, i32* %month29, align 4
  %37 = load %struct.date_t*, %struct.date_t** %date.addr, align 4
  %year31 = getelementptr inbounds %struct.date_t, %struct.date_t* %37, i32 0, i32 0
  %38 = load i32, i32* %year31, align 4
  %add32 = add nsw i32 %38, 1
  store i32 %add32, i32* %year31, align 4
  br label %if.end

if.end:                                           ; preds = %if.then, %while.body19
  br label %while.cond14

while.end33:                                      ; preds = %while.cond14
  %39 = load %struct.date_t*, %struct.date_t** %date.addr, align 4
  %call34 = call i32 @week_day(%struct.date_t* byval(%struct.date_t) align 4 %39)
  %40 = load %struct.date_t*, %struct.date_t** %date.addr, align 4
  %week_day = getelementptr inbounds %struct.date_t, %struct.date_t* %40, i32 0, i32 3
  store i32 %call34, i32* %week_day, align 4
  %41 = load %struct.date_t*, %struct.date_t** %date.addr, align 4
  %42 = bitcast %struct.date_t* %agg.result to i8*
  %43 = bitcast %struct.date_t* %41 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 4 %42, i8* align 4 %43, i32 16, i1 false)
  ret void
}

; Function Attrs: noinline nounwind optnone
define hidden void @easter(%struct.date_t* noalias sret align 4 %agg.result, i32 %year) #0 {
entry:
  %year.addr = alloca i32, align 4
  %c = alloca i32, align 4
  %n = alloca i32, align 4
  %i = alloca i32, align 4
  %l = alloca i32, align 4
  store i32 %year, i32* %year.addr, align 4
  %0 = load i32, i32* %year.addr, align 4
  %year1 = getelementptr inbounds %struct.date_t, %struct.date_t* %agg.result, i32 0, i32 0
  store i32 %0, i32* %year1, align 4
  %1 = load i32, i32* %year.addr, align 4
  %div = sdiv i32 %1, 100
  store i32 %div, i32* %c, align 4
  %2 = load i32, i32* %year.addr, align 4
  %rem = srem i32 %2, 19
  store i32 %rem, i32* %n, align 4
  %3 = load i32, i32* %c, align 4
  %4 = load i32, i32* %c, align 4
  %div2 = sdiv i32 %4, 4
  %sub = sub nsw i32 %3, %div2
  %5 = load i32, i32* %c, align 4
  %6 = load i32, i32* %c, align 4
  %sub3 = sub nsw i32 %6, 17
  %div4 = sdiv i32 %sub3, 25
  %sub5 = sub nsw i32 %5, %div4
  %div6 = sdiv i32 %sub5, 3
  %sub7 = sub nsw i32 %sub, %div6
  %7 = load i32, i32* %n, align 4
  %mul = mul nsw i32 19, %7
  %add = add nsw i32 %sub7, %mul
  %add8 = add nsw i32 %add, 15
  %rem9 = srem i32 %add8, 30
  store i32 %rem9, i32* %i, align 4
  %8 = load i32, i32* %i, align 4
  %div10 = sdiv i32 %8, 28
  %9 = load i32, i32* %i, align 4
  %div11 = sdiv i32 %9, 28
  %10 = load i32, i32* %i, align 4
  %add12 = add nsw i32 %10, 1
  %div13 = sdiv i32 29, %add12
  %mul14 = mul nsw i32 %div11, %div13
  %11 = load i32, i32* %n, align 4
  %sub15 = sub nsw i32 21, %11
  %div16 = sdiv i32 %sub15, 11
  %mul17 = mul nsw i32 %mul14, %div16
  %sub18 = sub nsw i32 1, %mul17
  %mul19 = mul nsw i32 %div10, %sub18
  %12 = load i32, i32* %i, align 4
  %sub20 = sub nsw i32 %12, %mul19
  store i32 %sub20, i32* %i, align 4
  %13 = load i32, i32* %i, align 4
  %14 = load i32, i32* %year.addr, align 4
  %15 = load i32, i32* %year.addr, align 4
  %div21 = sdiv i32 %15, 4
  %add22 = add nsw i32 %14, %div21
  %16 = load i32, i32* %i, align 4
  %add23 = add nsw i32 %add22, %16
  %add24 = add nsw i32 %add23, 2
  %17 = load i32, i32* %c, align 4
  %sub25 = sub nsw i32 %add24, %17
  %18 = load i32, i32* %c, align 4
  %div26 = sdiv i32 %18, 4
  %add27 = add nsw i32 %sub25, %div26
  %rem28 = srem i32 %add27, 7
  %sub29 = sub nsw i32 %13, %rem28
  store i32 %sub29, i32* %l, align 4
  %19 = load i32, i32* %l, align 4
  %add30 = add nsw i32 %19, 40
  %div31 = sdiv i32 %add30, 44
  %add32 = add nsw i32 3, %div31
  %month = getelementptr inbounds %struct.date_t, %struct.date_t* %agg.result, i32 0, i32 1
  store i32 %add32, i32* %month, align 4
  %20 = load i32, i32* %l, align 4
  %add33 = add nsw i32 %20, 28
  %month34 = getelementptr inbounds %struct.date_t, %struct.date_t* %agg.result, i32 0, i32 1
  %21 = load i32, i32* %month34, align 4
  %div35 = sdiv i32 %21, 4
  %mul36 = mul nsw i32 31, %div35
  %sub37 = sub nsw i32 %add33, %mul36
  %month_day = getelementptr inbounds %struct.date_t, %struct.date_t* %agg.result, i32 0, i32 2
  store i32 %sub37, i32* %month_day, align 4
  %call = call i32 @week_day(%struct.date_t* byval(%struct.date_t) align 4 %agg.result)
  %week_day = getelementptr inbounds %struct.date_t, %struct.date_t* %agg.result, i32 0, i32 3
  store i32 %call, i32* %week_day, align 4
  ret void
}

; Function Attrs: noinline nounwind optnone
define hidden i32 @week_day(%struct.date_t* byval(%struct.date_t) align 4 %date) #0 {
entry:
  %year = alloca i32, align 4
  %month = alloca i32, align 4
  %month_day = alloca i32, align 4
  %c = alloca i32, align 4
  %year1 = getelementptr inbounds %struct.date_t, %struct.date_t* %date, i32 0, i32 0
  %0 = load i32, i32* %year1, align 4
  store i32 %0, i32* %year, align 4
  %month2 = getelementptr inbounds %struct.date_t, %struct.date_t* %date, i32 0, i32 1
  %1 = load i32, i32* %month2, align 4
  store i32 %1, i32* %month, align 4
  %month_day3 = getelementptr inbounds %struct.date_t, %struct.date_t* %date, i32 0, i32 2
  %2 = load i32, i32* %month_day3, align 4
  store i32 %2, i32* %month_day, align 4
  %3 = load i32, i32* %month, align 4
  %cmp = icmp sle i32 %3, 2
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %4 = load i32, i32* %month, align 4
  %add = add nsw i32 %4, 12
  store i32 %add, i32* %month, align 4
  %5 = load i32, i32* %year, align 4
  %sub = sub nsw i32 %5, 1
  store i32 %sub, i32* %year, align 4
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  %6 = load i32, i32* %year, align 4
  %div = sdiv i32 %6, 100
  store i32 %div, i32* %c, align 4
  %7 = load i32, i32* %year, align 4
  %rem = srem i32 %7, 100
  store i32 %rem, i32* %year, align 4
  %8 = load i32, i32* %month_day, align 4
  %9 = load i32, i32* %month, align 4
  %add4 = add nsw i32 %9, 1
  %mul = mul nsw i32 %add4, 26
  %div5 = sdiv i32 %mul, 10
  %add6 = add nsw i32 %8, %div5
  %10 = load i32, i32* %year, align 4
  %add7 = add nsw i32 %add6, %10
  %11 = load i32, i32* %year, align 4
  %div8 = sdiv i32 %11, 4
  %add9 = add nsw i32 %add7, %div8
  %12 = load i32, i32* %c, align 4
  %div10 = sdiv i32 %12, 4
  %add11 = add nsw i32 %add9, %div10
  %13 = load i32, i32* %c, align 4
  %mul12 = mul nsw i32 2, %13
  %sub13 = sub nsw i32 %add11, %mul12
  %rem14 = srem i32 %sub13, 7
  %add15 = add nsw i32 %rem14, 7
  %rem16 = srem i32 %add15, 7
  %add17 = add nsw i32 1, %rem16
  ret i32 %add17
}

; Function Attrs: noinline nounwind optnone
define hidden void @easter_related_init(%struct.easter_related_t* noalias sret align 4 %agg.result, i32 %year) #0 {
entry:
  %year.addr = alloca i32, align 4
  %date = alloca %struct.date_t, align 4
  %tmp = alloca %struct.date_t, align 4
  %tmp1 = alloca %struct.date_t, align 4
  %tmp2 = alloca %struct.date_t, align 4
  %tmp3 = alloca %struct.date_t, align 4
  %tmp4 = alloca %struct.date_t, align 4
  store i32 %year, i32* %year.addr, align 4
  %easter = getelementptr inbounds %struct.easter_related_t, %struct.easter_related_t* %agg.result, i32 0, i32 0
  %0 = load i32, i32* %year.addr, align 4
  call void @easter(%struct.date_t* sret align 4 %tmp, i32 %0)
  %1 = bitcast %struct.date_t* %date to i8*
  %2 = bitcast %struct.date_t* %tmp to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 4 %1, i8* align 4 %2, i32 16, i1 false)
  %3 = bitcast %struct.date_t* %easter to i8*
  %4 = bitcast %struct.date_t* %date to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 4 %3, i8* align 4 %4, i32 16, i1 false)
  %ascension = getelementptr inbounds %struct.easter_related_t, %struct.easter_related_t* %agg.result, i32 0, i32 1
  call void @plusab(%struct.date_t* sret align 4 %tmp1, %struct.date_t* %date, i32 39)
  %5 = bitcast %struct.date_t* %ascension to i8*
  %6 = bitcast %struct.date_t* %tmp1 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 4 %5, i8* align 4 %6, i32 16, i1 false)
  %pentecost = getelementptr inbounds %struct.easter_related_t, %struct.easter_related_t* %agg.result, i32 0, i32 2
  call void @plusab(%struct.date_t* sret align 4 %tmp2, %struct.date_t* %date, i32 10)
  %7 = bitcast %struct.date_t* %pentecost to i8*
  %8 = bitcast %struct.date_t* %tmp2 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 4 %7, i8* align 4 %8, i32 16, i1 false)
  %trinity = getelementptr inbounds %struct.easter_related_t, %struct.easter_related_t* %agg.result, i32 0, i32 3
  call void @plusab(%struct.date_t* sret align 4 %tmp3, %struct.date_t* %date, i32 7)
  %9 = bitcast %struct.date_t* %trinity to i8*
  %10 = bitcast %struct.date_t* %tmp3 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 4 %9, i8* align 4 %10, i32 16, i1 false)
  %corpus_christi = getelementptr inbounds %struct.easter_related_t, %struct.easter_related_t* %agg.result, i32 0, i32 4
  call void @plusab(%struct.date_t* sret align 4 %tmp4, %struct.date_t* %date, i32 4)
  %11 = bitcast %struct.date_t* %corpus_christi to i8*
  %12 = bitcast %struct.date_t* %tmp4 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 4 %11, i8* align 4 %12, i32 16, i1 false)
  ret void
}

; Function Attrs: noinline nounwind optnone
define hidden void @easter_related_print(i32 %year) #0 {
entry:
  %year.addr = alloca i32, align 4
  %holidays = alloca %struct.easter_related_t, align 4
  store i32 %year, i32* %year.addr, align 4
  %0 = load i32, i32* %year.addr, align 4
  call void @easter_related_init(%struct.easter_related_t* sret align 4 %holidays, i32 %0)
  %1 = load i32, i32* %year.addr, align 4
  %easter = getelementptr inbounds %struct.easter_related_t, %struct.easter_related_t* %holidays, i32 0, i32 0
  %week_day = getelementptr inbounds %struct.date_t, %struct.date_t* %easter, i32 0, i32 3
  %2 = load i32, i32* %week_day, align 4
  %arrayidx = getelementptr inbounds [8 x i8*], [8 x i8*]* @week_day_fmt, i32 0, i32 %2
  %3 = load i8*, i8** %arrayidx, align 4
  %easter1 = getelementptr inbounds %struct.easter_related_t, %struct.easter_related_t* %holidays, i32 0, i32 0
  %month_day = getelementptr inbounds %struct.date_t, %struct.date_t* %easter1, i32 0, i32 2
  %4 = load i32, i32* %month_day, align 4
  %easter2 = getelementptr inbounds %struct.easter_related_t, %struct.easter_related_t* %holidays, i32 0, i32 0
  %month = getelementptr inbounds %struct.date_t, %struct.date_t* %easter2, i32 0, i32 1
  %5 = load i32, i32* %month, align 4
  %arrayidx3 = getelementptr inbounds [13 x i8*], [13 x i8*]* @mon_fmt, i32 0, i32 %5
  %6 = load i8*, i8** %arrayidx3, align 4
  %ascension = getelementptr inbounds %struct.easter_related_t, %struct.easter_related_t* %holidays, i32 0, i32 1
  %week_day4 = getelementptr inbounds %struct.date_t, %struct.date_t* %ascension, i32 0, i32 3
  %7 = load i32, i32* %week_day4, align 4
  %arrayidx5 = getelementptr inbounds [8 x i8*], [8 x i8*]* @week_day_fmt, i32 0, i32 %7
  %8 = load i8*, i8** %arrayidx5, align 4
  %ascension6 = getelementptr inbounds %struct.easter_related_t, %struct.easter_related_t* %holidays, i32 0, i32 1
  %month_day7 = getelementptr inbounds %struct.date_t, %struct.date_t* %ascension6, i32 0, i32 2
  %9 = load i32, i32* %month_day7, align 4
  %ascension8 = getelementptr inbounds %struct.easter_related_t, %struct.easter_related_t* %holidays, i32 0, i32 1
  %month9 = getelementptr inbounds %struct.date_t, %struct.date_t* %ascension8, i32 0, i32 1
  %10 = load i32, i32* %month9, align 4
  %arrayidx10 = getelementptr inbounds [13 x i8*], [13 x i8*]* @mon_fmt, i32 0, i32 %10
  %11 = load i8*, i8** %arrayidx10, align 4
  %pentecost = getelementptr inbounds %struct.easter_related_t, %struct.easter_related_t* %holidays, i32 0, i32 2
  %week_day11 = getelementptr inbounds %struct.date_t, %struct.date_t* %pentecost, i32 0, i32 3
  %12 = load i32, i32* %week_day11, align 4
  %arrayidx12 = getelementptr inbounds [8 x i8*], [8 x i8*]* @week_day_fmt, i32 0, i32 %12
  %13 = load i8*, i8** %arrayidx12, align 4
  %pentecost13 = getelementptr inbounds %struct.easter_related_t, %struct.easter_related_t* %holidays, i32 0, i32 2
  %month_day14 = getelementptr inbounds %struct.date_t, %struct.date_t* %pentecost13, i32 0, i32 2
  %14 = load i32, i32* %month_day14, align 4
  %pentecost15 = getelementptr inbounds %struct.easter_related_t, %struct.easter_related_t* %holidays, i32 0, i32 2
  %month16 = getelementptr inbounds %struct.date_t, %struct.date_t* %pentecost15, i32 0, i32 1
  %15 = load i32, i32* %month16, align 4
  %arrayidx17 = getelementptr inbounds [13 x i8*], [13 x i8*]* @mon_fmt, i32 0, i32 %15
  %16 = load i8*, i8** %arrayidx17, align 4
  %trinity = getelementptr inbounds %struct.easter_related_t, %struct.easter_related_t* %holidays, i32 0, i32 3
  %week_day18 = getelementptr inbounds %struct.date_t, %struct.date_t* %trinity, i32 0, i32 3
  %17 = load i32, i32* %week_day18, align 4
  %arrayidx19 = getelementptr inbounds [8 x i8*], [8 x i8*]* @week_day_fmt, i32 0, i32 %17
  %18 = load i8*, i8** %arrayidx19, align 4
  %trinity20 = getelementptr inbounds %struct.easter_related_t, %struct.easter_related_t* %holidays, i32 0, i32 3
  %month_day21 = getelementptr inbounds %struct.date_t, %struct.date_t* %trinity20, i32 0, i32 2
  %19 = load i32, i32* %month_day21, align 4
  %trinity22 = getelementptr inbounds %struct.easter_related_t, %struct.easter_related_t* %holidays, i32 0, i32 3
  %month23 = getelementptr inbounds %struct.date_t, %struct.date_t* %trinity22, i32 0, i32 1
  %20 = load i32, i32* %month23, align 4
  %arrayidx24 = getelementptr inbounds [13 x i8*], [13 x i8*]* @mon_fmt, i32 0, i32 %20
  %21 = load i8*, i8** %arrayidx24, align 4
  %corpus_christi = getelementptr inbounds %struct.easter_related_t, %struct.easter_related_t* %holidays, i32 0, i32 4
  %week_day25 = getelementptr inbounds %struct.date_t, %struct.date_t* %corpus_christi, i32 0, i32 3
  %22 = load i32, i32* %week_day25, align 4
  %arrayidx26 = getelementptr inbounds [8 x i8*], [8 x i8*]* @week_day_fmt, i32 0, i32 %22
  %23 = load i8*, i8** %arrayidx26, align 4
  %corpus_christi27 = getelementptr inbounds %struct.easter_related_t, %struct.easter_related_t* %holidays, i32 0, i32 4
  %month_day28 = getelementptr inbounds %struct.date_t, %struct.date_t* %corpus_christi27, i32 0, i32 2
  %24 = load i32, i32* %month_day28, align 4
  %corpus_christi29 = getelementptr inbounds %struct.easter_related_t, %struct.easter_related_t* %holidays, i32 0, i32 4
  %month30 = getelementptr inbounds %struct.date_t, %struct.date_t* %corpus_christi29, i32 0, i32 1
  %25 = load i32, i32* %month30, align 4
  %arrayidx31 = getelementptr inbounds [13 x i8*], [13 x i8*]* @mon_fmt, i32 0, i32 %25
  %26 = load i8*, i8** %arrayidx31, align 4
  %call = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([106 x i8], [106 x i8]* @.str.19, i32 0, i32 0), i32 %1, i8* %3, i32 %4, i8* %6, i8* %8, i32 %9, i8* %11, i8* %13, i32 %14, i8* %16, i8* %18, i32 %19, i8* %21, i8* %23, i32 %24, i8* %26)
  ret void
}

declare i32 @printf(i8* %0, ...) #2

; Function Attrs: noinline nounwind optnone
define hidden i32 @main() #0 {
entry:
  %retval = alloca i32, align 4
  %year = alloca i32, align 4
  store i32 0, i32* %retval, align 4
  %call = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([81 x i8], [81 x i8]* @.str.20, i32 0, i32 0))
  store i32 400, i32* %year, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %0 = load i32, i32* %year, align 4
  %cmp = icmp sle i32 %0, 2100
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %1 = load i32, i32* %year, align 4
  call void @easter_related_print(i32 %1)
  br label %for.inc

for.inc:                                          ; preds = %for.body
  %2 = load i32, i32* %year, align 4
  %add = add nsw i32 %2, 100
  store i32 %add, i32* %year, align 4
  br label %for.cond

for.end:                                          ; preds = %for.cond
  %call1 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([73 x i8], [73 x i8]* @.str.21, i32 0, i32 0))
  store i32 2010, i32* %year, align 4
  br label %for.cond2

for.cond2:                                        ; preds = %for.inc5, %for.end
  %3 = load i32, i32* %year, align 4
  %cmp3 = icmp sle i32 %3, 2020
  br i1 %cmp3, label %for.body4, label %for.end6

for.body4:                                        ; preds = %for.cond2
  %4 = load i32, i32* %year, align 4
  call void @easter_related_print(i32 %4)
  br label %for.inc5

for.inc5:                                         ; preds = %for.body4
  %5 = load i32, i32* %year, align 4
  %inc = add nsw i32 %5, 1
  store i32 %inc, i32* %year, align 4
  br label %for.cond2

for.end6:                                         ; preds = %for.cond2
  ret i32 0
}

attributes #0 = { noinline nounwind optnone "correctly-rounded-divide-sqrt-fp-math"="false" "disable-tail-calls"="false" "frame-pointer"="none" "less-precise-fpmad"="false" "min-legal-vector-width"="0" "no-infs-fp-math"="false" "no-jump-tables"="false" "no-nans-fp-math"="false" "no-signed-zeros-fp-math"="false" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="generic" "unsafe-fp-math"="false" "use-soft-float"="false" }
attributes #1 = { argmemonly nounwind willreturn }
attributes #2 = { "correctly-rounded-divide-sqrt-fp-math"="false" "disable-tail-calls"="false" "frame-pointer"="none" "less-precise-fpmad"="false" "no-infs-fp-math"="false" "no-nans-fp-math"="false" "no-signed-zeros-fp-math"="false" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="generic" "unsafe-fp-math"="false" "use-soft-float"="false" }

!llvm.module.flags = !{!0}
!llvm.ident = !{!1}

!0 = !{i32 1, !"wchar_size", i32 4}
!1 = !{!"clang version 11.0.0 (https://github.com/Jacarte/llvm-project.git 0f6dea67136cc1e0b3d200eb2bb165628970c44b)"}

; extracted candidates

; *****
; For LLVM instruction:
;  %0 = load i32, i32* %year1, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %1 = load i32, i32* %month2, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %2 = load i32, i32* %month_day3, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %3 = load i32, i32* %month, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %cmp = icmp sle i32 %3, 2
; Looking for a replacement for:
%0:i32 = var
%1:i1 = sle %0, 2:i32
infer %1

; *****
; For LLVM instruction:
;  %4 = load i32, i32* %month, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %add = add nsw i32 %4, 12
; Looking for a replacement for:
%0:i32 = var
%1:i32 = addnsw 12:i32, %0
infer %1

; *****
; For LLVM instruction:
;  %5 = load i32, i32* %year, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %sub = sub nsw i32 %5, 1
; Looking for a replacement for:
%0:i32 = var
%1:i32 = subnsw %0, 1:i32
infer %1

; *****
; For LLVM instruction:
;  %6 = load i32, i32* %year, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %div = sdiv i32 %6, 100
; Looking for a replacement for:
%0:i32 = var
%1:i32 = sdiv %0, 100:i32
infer %1

; *****
; For LLVM instruction:
;  %7 = load i32, i32* %year, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %rem = srem i32 %7, 100
; Looking for a replacement for:
%0:i32 = var
%1:i32 = srem %0, 100:i32
infer %1

; *****
; For LLVM instruction:
;  %8 = load i32, i32* %month_day, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %9 = load i32, i32* %month, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %add4 = add nsw i32 %9, 1
; Looking for a replacement for:
%0:i32 = var
%1:i32 = addnsw 1:i32, %0
infer %1

; *****
; For LLVM instruction:
;  %mul = mul nsw i32 %add4, 26
; Looking for a replacement for:
%0:i32 = var
%1:i32 = addnsw 1:i32, %0
%2:i32 = mulnsw 26:i32, %1
infer %2

; *****
; For LLVM instruction:
;  %div5 = sdiv i32 %mul, 10
; Looking for a replacement for:
%0:i32 = var
%1:i32 = addnsw 1:i32, %0
%2:i32 = mulnsw 26:i32, %1
%3:i32 = sdiv %2, 10:i32
infer %3

; *****
; For LLVM instruction:
;  %add6 = add nsw i32 %8, %div5
; Looking for a replacement for:
%0:i32 = var
%1:i32 = var
%2:i32 = addnsw 1:i32, %1
%3:i32 = mulnsw 26:i32, %2
%4:i32 = sdiv %3, 10:i32
%5:i32 = addnsw %0, %4
infer %5

; *****
; For LLVM instruction:
;  %10 = load i32, i32* %year, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %add7 = add nsw i32 %add6, %10
; Looking for a replacement for:
%0:i32 = var
%1:i32 = var
%2:i32 = var
%3:i32 = addnsw 1:i32, %2
%4:i32 = mulnsw 26:i32, %3
%5:i32 = sdiv %4, 10:i32
%6:i32 = addnsw %1, %5
%7:i32 = addnsw %0, %6
infer %7

; *****
; For LLVM instruction:
;  %11 = load i32, i32* %year, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %div8 = sdiv i32 %11, 4
; Looking for a replacement for:
%0:i32 = var
%1:i32 = sdiv %0, 4:i32
infer %1

; *****
; For LLVM instruction:
;  %add9 = add nsw i32 %add7, %div8
; Looking for a replacement for:
%0:i32 = var
%1:i32 = var
%2:i32 = var
%3:i32 = addnsw 1:i32, %2
%4:i32 = mulnsw 26:i32, %3
%5:i32 = sdiv %4, 10:i32
%6:i32 = addnsw %1, %5
%7:i32 = addnsw %0, %6
%8:i32 = var
%9:i32 = sdiv %8, 4:i32
%10:i32 = addnsw %7, %9
infer %10

; *****
; For LLVM instruction:
;  %12 = load i32, i32* %c, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %div10 = sdiv i32 %12, 4
; Looking for a replacement for:
%0:i32 = var
%1:i32 = sdiv %0, 4:i32
infer %1

; *****
; For LLVM instruction:
;  %add11 = add nsw i32 %add9, %div10
; Looking for a replacement for:
%0:i32 = var
%1:i32 = var
%2:i32 = var
%3:i32 = addnsw 1:i32, %2
%4:i32 = mulnsw 26:i32, %3
%5:i32 = sdiv %4, 10:i32
%6:i32 = addnsw %1, %5
%7:i32 = addnsw %0, %6
%8:i32 = var
%9:i32 = sdiv %8, 4:i32
%10:i32 = addnsw %7, %9
%11:i32 = var
%12:i32 = sdiv %11, 4:i32
%13:i32 = addnsw %10, %12
infer %13

; *****
; For LLVM instruction:
;  %13 = load i32, i32* %c, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %mul12 = mul nsw i32 2, %13
; Looking for a replacement for:
%0:i32 = var
%1:i32 = mulnsw 2:i32, %0
infer %1

; *****
; For LLVM instruction:
;  %sub13 = sub nsw i32 %add11, %mul12
; Looking for a replacement for:
%0:i32 = var
%1:i32 = var
%2:i32 = var
%3:i32 = addnsw 1:i32, %2
%4:i32 = mulnsw 26:i32, %3
%5:i32 = sdiv %4, 10:i32
%6:i32 = addnsw %1, %5
%7:i32 = addnsw %0, %6
%8:i32 = var
%9:i32 = sdiv %8, 4:i32
%10:i32 = addnsw %7, %9
%11:i32 = var
%12:i32 = sdiv %11, 4:i32
%13:i32 = addnsw %10, %12
%14:i32 = var
%15:i32 = mulnsw 2:i32, %14
%16:i32 = subnsw %13, %15
infer %16

; *****
; For LLVM instruction:
;  %rem14 = srem i32 %sub13, 7
; Looking for a replacement for:
%0:i32 = var
%1:i32 = var
%2:i32 = var
%3:i32 = addnsw 1:i32, %2
%4:i32 = mulnsw 26:i32, %3
%5:i32 = sdiv %4, 10:i32
%6:i32 = addnsw %1, %5
%7:i32 = addnsw %0, %6
%8:i32 = var
%9:i32 = sdiv %8, 4:i32
%10:i32 = addnsw %7, %9
%11:i32 = var
%12:i32 = sdiv %11, 4:i32
%13:i32 = addnsw %10, %12
%14:i32 = var
%15:i32 = mulnsw 2:i32, %14
%16:i32 = subnsw %13, %15
%17:i32 = srem %16, 7:i32
infer %17

; *****
; For LLVM instruction:
;  %add15 = add nsw i32 %rem14, 7
; Looking for a replacement for:
%0:i32 = var
%1:i32 = var
%2:i32 = var
%3:i32 = addnsw 1:i32, %2
%4:i32 = mulnsw 26:i32, %3
%5:i32 = sdiv %4, 10:i32
%6:i32 = addnsw %1, %5
%7:i32 = addnsw %0, %6
%8:i32 = var
%9:i32 = sdiv %8, 4:i32
%10:i32 = addnsw %7, %9
%11:i32 = var
%12:i32 = sdiv %11, 4:i32
%13:i32 = addnsw %10, %12
%14:i32 = var
%15:i32 = mulnsw 2:i32, %14
%16:i32 = subnsw %13, %15
%17:i32 = srem %16, 7:i32
%18:i32 = addnsw 7:i32, %17
infer %18

; *****
; For LLVM instruction:
;  %rem16 = srem i32 %add15, 7
; Looking for a replacement for:
%0:i32 = var
%1:i32 = var
%2:i32 = var
%3:i32 = addnsw 1:i32, %2
%4:i32 = mulnsw 26:i32, %3
%5:i32 = sdiv %4, 10:i32
%6:i32 = addnsw %1, %5
%7:i32 = addnsw %0, %6
%8:i32 = var
%9:i32 = sdiv %8, 4:i32
%10:i32 = addnsw %7, %9
%11:i32 = var
%12:i32 = sdiv %11, 4:i32
%13:i32 = addnsw %10, %12
%14:i32 = var
%15:i32 = mulnsw 2:i32, %14
%16:i32 = subnsw %13, %15
%17:i32 = srem %16, 7:i32
%18:i32 = addnsw 7:i32, %17
%19:i32 = srem %18, 7:i32
infer %19

; *****
; For LLVM instruction:
;  %add17 = add nsw i32 1, %rem16
; Looking for a replacement for:
%0:i32 = var
%1:i32 = var
%2:i32 = var
%3:i32 = addnsw 1:i32, %2
%4:i32 = mulnsw 26:i32, %3
%5:i32 = sdiv %4, 10:i32
%6:i32 = addnsw %1, %5
%7:i32 = addnsw %0, %6
%8:i32 = var
%9:i32 = sdiv %8, 4:i32
%10:i32 = addnsw %7, %9
%11:i32 = var
%12:i32 = sdiv %11, 4:i32
%13:i32 = addnsw %10, %12
%14:i32 = var
%15:i32 = mulnsw 2:i32, %14
%16:i32 = subnsw %13, %15
%17:i32 = srem %16, 7:i32
%18:i32 = addnsw 7:i32, %17
%19:i32 = srem %18, 7:i32
%20:i32 = addnsw 1:i32, %19
infer %20
got 2 candidates from LHS

-------------------------------------------------
%0:i32 = var
%1:i1 = sle %0, 2:i32
infer %1


--------------------------------
guess 0

%0:i1 = var ; reservedconst_1

Cost = 0
first query is SAT, returning the model:
reservedconst_1: -1
0 th attempt: second query is SAT-- constant doesn't work
first query is SAT, returning the model:
reservedconst_1: 0
1 th attempt: second query is SAT-- constant doesn't work
first query is UNSAT-- no more guesses
Dataflow Pruned 0/0
There are 1 Guesses
There are 0 RHSs before deduplication
There are 0 RHSs after deduplication
got 2 candidates from LHS

-------------------------------------------------
%0:i32 = var
%1:i32 = addnsw 12:i32, %0
infer %1


--------------------------------
guess 0

%0:i32 = var ; reservedconst_1

Cost = 0
first query is SAT, returning the model:
reservedconst_1: 12
0 th attempt: second query is SAT-- constant doesn't work
first query is SAT, returning the model:
reservedconst_1: 13
1 th attempt: second query is SAT-- constant doesn't work
first query is UNSAT-- no more guesses

--------------------------------
guess 1

%0:i32 = var

Cost = 0
second query is SAT-- constant doesn't work
Dataflow Pruned 0/0
There are 2 Guesses
There are 0 RHSs before deduplication
There are 0 RHSs after deduplication
got 3 candidates from LHS

-------------------------------------------------
%0:i32 = var
%1:i32 = addnsw 1:i32, %0
%2:i32 = mulnsw 26:i32, %1
infer %2


--------------------------------
guess 0

%0:i32 = var ; reservedconst_1

Cost = 0
first query is SAT, returning the model:
reservedconst_1: 26
0 th attempt: second query is SAT-- constant doesn't work
first query is SAT, returning the model:
reservedconst_1: 4108
1 th attempt: second query is SAT-- constant doesn't work
first query is UNSAT-- no more guesses

--------------------------------
guess 1

%0:i32 = var

Cost = 0
second query is SAT-- constant doesn't work

--------------------------------
guess 2

%0:i32 = var
%1:i32 = addnsw 1:i32, %0

Cost = 1
second query is SAT-- constant doesn't work
Dataflow Pruned 0/0
There are 3 Guesses
There are 0 RHSs before deduplication
There are 0 RHSs after deduplication
got 4 candidates from LHS

-------------------------------------------------
%0:i32 = var
%1:i32 = addnsw 1:i32, %0
%2:i32 = mulnsw 26:i32, %1
%3:i32 = sdiv %2, 10:i32
infer %3


--------------------------------
guess 0

%0:i32 = var ; reservedconst_1

Cost = 0
first query is SAT, returning the model:
reservedconst_1: 2
0 th attempt: second query is SAT-- constant doesn't work
first query is SAT, returning the model:
reservedconst_1: 0
1 th attempt: second query is SAT-- constant doesn't work
first query is UNSAT-- no more guesses

--------------------------------
guess 1

%0:i32 = var

Cost = 0
second query is SAT-- constant doesn't work

--------------------------------
guess 2

%0:i32 = var
%1:i32 = addnsw 1:i32, %0

Cost = 1
second query is SAT-- constant doesn't work

--------------------------------
guess 3

%0:i32 = var
%1:i32 = addnsw 1:i32, %0
%2:i32 = mulnsw 26:i32, %1

Cost = 2
second query is SAT-- constant doesn't work
Dataflow Pruned 0/0
There are 4 Guesses
There are 0 RHSs before deduplication
There are 0 RHSs after deduplication
got 6 candidates from LHS

-------------------------------------------------
%0:i32 = var
%1:i32 = var
%2:i32 = addnsw 1:i32, %1
%3:i32 = mulnsw 26:i32, %2
%4:i32 = sdiv %3, 10:i32
%5:i32 = addnsw %0, %4
infer %5


--------------------------------
guess 0

%0:i32 = var ; reservedconst_1

Cost = 0
first query is SAT, returning the model:
reservedconst_1: 2
0 th attempt: second query is SAT-- constant doesn't work
first query is SAT, returning the model:
reservedconst_1: -1994811126
1 th attempt: second query is SAT-- constant doesn't work
first query is UNSAT-- no more guesses

--------------------------------
guess 1

%0:i32 = var

Cost = 0
second query is SAT-- constant doesn't work

--------------------------------
guess 2

%0:i32 = var

Cost = 0
second query is SAT-- constant doesn't work

--------------------------------
guess 3

%0:i32 = var
%1:i32 = addnsw 1:i32, %0

Cost = 1
second query is SAT-- constant doesn't work

--------------------------------
guess 4

%0:i32 = var
%1:i32 = addnsw 1:i32, %0
%2:i32 = mulnsw 26:i32, %1

Cost = 2
second query is SAT-- constant doesn't work

--------------------------------
guess 5

%0:i32 = var
%1:i32 = addnsw 1:i32, %0
%2:i32 = mulnsw 26:i32, %1
%3:i32 = sdiv %2, 10:i32

Cost = 7
second query is SAT-- constant doesn't work
Dataflow Pruned 0/0
There are 6 Guesses
There are 0 RHSs before deduplication
There are 0 RHSs after deduplication
got 8 candidates from LHS

-------------------------------------------------
%0:i32 = var
%1:i32 = var
%2:i32 = var
%3:i32 = addnsw 1:i32, %2
%4:i32 = mulnsw 26:i32, %3
%5:i32 = sdiv %4, 10:i32
%6:i32 = addnsw %1, %5
%7:i32 = addnsw %0, %6
infer %7


--------------------------------
guess 0

%0:i32 = var ; reservedconst_1

Cost = 0
first query is SAT, returning the model:
reservedconst_1: 2
0 th attempt: second query is SAT-- constant doesn't work
first query is SAT, returning the model:
reservedconst_1: 536805376
1 th attempt: second query is SAT-- constant doesn't work
first query is UNSAT-- no more guesses

--------------------------------
guess 1

%0:i32 = var

Cost = 0
second query is SAT-- constant doesn't work

--------------------------------
guess 2

%0:i32 = var

Cost = 0
second query is SAT-- constant doesn't work

--------------------------------
guess 3

%0:i32 = var

Cost = 0
second query is SAT-- constant doesn't work

--------------------------------
guess 4

%0:i32 = var
%1:i32 = addnsw 1:i32, %0

Cost = 1
second query is SAT-- constant doesn't work

--------------------------------
guess 5

%0:i32 = var
%1:i32 = addnsw 1:i32, %0
%2:i32 = mulnsw 26:i32, %1

Cost = 2
second query is SAT-- constant doesn't work

--------------------------------
guess 6

%0:i32 = var
%1:i32 = addnsw 1:i32, %0
%2:i32 = mulnsw 26:i32, %1
%3:i32 = sdiv %2, 10:i32

Cost = 7
second query is SAT-- constant doesn't work

--------------------------------
guess 7

%0:i32 = var
%1:i32 = var
%2:i32 = addnsw 1:i32, %1
%3:i32 = mulnsw 26:i32, %2
%4:i32 = sdiv %3, 10:i32
%5:i32 = addnsw %0, %4

Cost = 8
second query is SAT-- constant doesn't work
Dataflow Pruned 0/0
There are 8 Guesses
There are 0 RHSs before deduplication
There are 0 RHSs after deduplication
got 8 candidates from LHS

-------------------------------------------------
%0:i32 = var
%1:i32 = var
%2:i32 = var
%3:i32 = addnsw 1:i32, %2
%4:i32 = mulnsw 26:i32, %3
%5:i32 = sdiv %4, 10:i32
%6:i32 = addnsw %1, %5
%7:i32 = addnsw %0, %6
%8:i32 = var
%9:i32 = sdiv %8, 4:i32
%10:i32 = addnsw %7, %9
infer %10


--------------------------------
guess 0

%0:i32 = var ; reservedconst_1

Cost = 0
first query is SAT, returning the model:
reservedconst_1: 2
0 th attempt: second query is SAT-- constant doesn't work
first query is SAT, returning the model:
reservedconst_1: 1102026406
1 th attempt: second query is SAT-- constant doesn't work
first query is UNSAT-- no more guesses

--------------------------------
guess 1

%0:i32 = var

Cost = 0
second query is SAT-- constant doesn't work

--------------------------------
guess 2

%0:i32 = var

Cost = 0
second query is SAT-- constant doesn't work

--------------------------------
guess 3

%0:i32 = var

Cost = 0
second query is SAT-- constant doesn't work

--------------------------------
guess 4

%0:i32 = var
%1:i32 = sdiv %0, 4:i32

Cost = 5
second query is SAT-- constant doesn't work

--------------------------------
guess 5

%0:i32 = var
%1:i32 = addnsw 1:i32, %0
%2:i32 = mulnsw 26:i32, %1
%3:i32 = sdiv %2, 10:i32

Cost = 7
second query is SAT-- constant doesn't work

--------------------------------
guess 6

%0:i32 = var
%1:i32 = var
%2:i32 = addnsw 1:i32, %1
%3:i32 = mulnsw 26:i32, %2
%4:i32 = sdiv %3, 10:i32
%5:i32 = addnsw %0, %4

Cost = 8
second query is SAT-- constant doesn't work

--------------------------------
guess 7

%0:i32 = var
%1:i32 = var
%2:i32 = var
%3:i32 = addnsw 1:i32, %2
%4:i32 = mulnsw 26:i32, %3
%5:i32 = sdiv %4, 10:i32
%6:i32 = addnsw %1, %5
%7:i32 = addnsw %0, %6

Cost = 9
second query is SAT-- constant doesn't work
Dataflow Pruned 0/0
There are 8 Guesses
There are 0 RHSs before deduplication
There are 0 RHSs after deduplication
got 8 candidates from LHS

-------------------------------------------------
%0:i32 = var
%1:i32 = var
%2:i32 = var
%3:i32 = addnsw 1:i32, %2
%4:i32 = mulnsw 26:i32, %3
%5:i32 = sdiv %4, 10:i32
%6:i32 = addnsw %1, %5
%7:i32 = addnsw %0, %6
%8:i32 = var
%9:i32 = sdiv %8, 4:i32
%10:i32 = addnsw %7, %9
%11:i32 = var
%12:i32 = sdiv %11, 4:i32
%13:i32 = addnsw %10, %12
infer %13


--------------------------------
guess 0

%0:i32 = var ; reservedconst_1

Cost = 0
first query is SAT, returning the model:
reservedconst_1: 2
0 th attempt: second query is SAT-- constant doesn't work
first query is SAT, returning the model:
reservedconst_1: -2147483646
1 th attempt: second query is SAT-- constant doesn't work
first query is UNSAT-- no more guesses

--------------------------------
guess 1

%0:i32 = var

Cost = 0
second query is SAT-- constant doesn't work

--------------------------------
guess 2

%0:i32 = var

Cost = 0
second query is SAT-- constant doesn't work

--------------------------------
guess 3

%0:i32 = var
%1:i32 = sdiv %0, 4:i32

Cost = 5
second query is SAT-- constant doesn't work

--------------------------------
guess 4

%0:i32 = var
%1:i32 = sdiv %0, 4:i32

Cost = 5
second query is SAT-- constant doesn't work

--------------------------------
guess 5

%0:i32 = var
%1:i32 = var
%2:i32 = addnsw 1:i32, %1
%3:i32 = mulnsw 26:i32, %2
%4:i32 = sdiv %3, 10:i32
%5:i32 = addnsw %0, %4

Cost = 8
second query is SAT-- constant doesn't work

--------------------------------
guess 6

%0:i32 = var
%1:i32 = var
%2:i32 = var
%3:i32 = addnsw 1:i32, %2
%4:i32 = mulnsw 26:i32, %3
%5:i32 = sdiv %4, 10:i32
%6:i32 = addnsw %1, %5
%7:i32 = addnsw %0, %6

Cost = 9
second query is SAT-- constant doesn't work

--------------------------------
guess 7

%0:i32 = var
%1:i32 = var
%2:i32 = var
%3:i32 = addnsw 1:i32, %2
%4:i32 = mulnsw 26:i32, %3
%5:i32 = sdiv %4, 10:i32
%6:i32 = addnsw %1, %5
%7:i32 = addnsw %0, %6
%8:i32 = var
%9:i32 = sdiv %8, 4:i32
%10:i32 = addnsw %7, %9

Cost = 15
second query is SAT-- constant doesn't work
Dataflow Pruned 0/0
There are 8 Guesses
There are 0 RHSs before deduplication
There are 0 RHSs after deduplication
got 2 candidates from LHS

-------------------------------------------------
%0:i32 = var
%1:i32 = mulnsw 2:i32, %0
infer %1


--------------------------------
guess 0

%0:i32 = var ; reservedconst_1

Cost = 0
first query is SAT, returning the model:
reservedconst_1: 0
0 th attempt: second query is SAT-- constant doesn't work
first query is SAT, returning the model:
reservedconst_1: 1073741824
1 th attempt: second query is SAT-- constant doesn't work
first query is UNSAT-- no more guesses

--------------------------------
guess 1

%0:i32 = var

Cost = 0
second query is SAT-- constant doesn't work
Dataflow Pruned 0/0
There are 2 Guesses
There are 0 RHSs before deduplication
There are 0 RHSs after deduplication
got 8 candidates from LHS

-------------------------------------------------
%0:i32 = var
%1:i32 = var
%2:i32 = var
%3:i32 = addnsw 1:i32, %2
%4:i32 = mulnsw 26:i32, %3
%5:i32 = sdiv %4, 10:i32
%6:i32 = addnsw %1, %5
%7:i32 = addnsw %0, %6
%8:i32 = var
%9:i32 = sdiv %8, 4:i32
%10:i32 = addnsw %7, %9
%11:i32 = var
%12:i32 = sdiv %11, 4:i32
%13:i32 = addnsw %10, %12
%14:i32 = var
%15:i32 = mulnsw 2:i32, %14
%16:i32 = subnsw %13, %15
infer %16


--------------------------------
guess 0

%0:i32 = var ; reservedconst_1

Cost = 0
first query is SAT, returning the model:
reservedconst_1: 2
0 th attempt: second query is SAT-- constant doesn't work
first query is SAT, returning the model:
reservedconst_1: 268418993
1 th attempt: second query is SAT-- constant doesn't work
first query is UNSAT-- no more guesses

--------------------------------
guess 1

%0:i32 = var

Cost = 0
second query is SAT-- constant doesn't work

--------------------------------
guess 2

%0:i32 = var

Cost = 0
second query is SAT-- constant doesn't work

--------------------------------
guess 3

%0:i32 = var
%1:i32 = mulnsw 2:i32, %0

Cost = 1
second query is SAT-- constant doesn't work

--------------------------------
guess 4

%0:i32 = var
%1:i32 = sdiv %0, 4:i32

Cost = 5
second query is SAT-- constant doesn't work

--------------------------------
guess 5

%0:i32 = var
%1:i32 = sdiv %0, 4:i32

Cost = 5
second query is SAT-- constant doesn't work

--------------------------------
guess 6

%0:i32 = var
%1:i32 = var
%2:i32 = var
%3:i32 = addnsw 1:i32, %2
%4:i32 = mulnsw 26:i32, %3
%5:i32 = sdiv %4, 10:i32
%6:i32 = addnsw %1, %5
%7:i32 = addnsw %0, %6
%8:i32 = var
%9:i32 = sdiv %8, 4:i32
%10:i32 = addnsw %7, %9

Cost = 15
second query is SAT-- constant doesn't work

--------------------------------
guess 7

%0:i32 = var
%1:i32 = var
%2:i32 = var
%3:i32 = addnsw 1:i32, %2
%4:i32 = mulnsw 26:i32, %3
%5:i32 = sdiv %4, 10:i32
%6:i32 = addnsw %1, %5
%7:i32 = addnsw %0, %6
%8:i32 = var
%9:i32 = sdiv %8, 4:i32
%10:i32 = addnsw %7, %9
%11:i32 = var
%12:i32 = sdiv %11, 4:i32
%13:i32 = addnsw %10, %12

Cost = 21
second query is SAT-- constant doesn't work
Dataflow Pruned 0/0
There are 8 Guesses
There are 0 RHSs before deduplication
There are 0 RHSs after deduplication
got 8 candidates from LHS

-------------------------------------------------
%0:i32 = var
%1:i32 = var
%2:i32 = var
%3:i32 = addnsw 1:i32, %2
%4:i32 = mulnsw 26:i32, %3
%5:i32 = sdiv %4, 10:i32
%6:i32 = addnsw %1, %5
%7:i32 = addnsw %0, %6
%8:i32 = var
%9:i32 = sdiv %8, 4:i32
%10:i32 = addnsw %7, %9
%11:i32 = var
%12:i32 = sdiv %11, 4:i32
%13:i32 = addnsw %10, %12
%14:i32 = var
%15:i32 = mulnsw 2:i32, %14
%16:i32 = subnsw %13, %15
%17:i32 = srem %16, 7:i32
infer %17


--------------------------------
guess 0

%0:i32 = var ; reservedconst_1

Cost = 0
first query is SAT, returning the model:
reservedconst_1: 2
0 th attempt: second query is SAT-- constant doesn't work
first query is SAT, returning the model:
reservedconst_1: 0
1 th attempt: second query is SAT-- constant doesn't work
first query is UNSAT-- no more guesses

--------------------------------
guess 1

%0:i32 = var

Cost = 0
second query is SAT-- constant doesn't work

--------------------------------
guess 2

%0:i32 = var

Cost = 0
second query is SAT-- constant doesn't work

--------------------------------
guess 3

%0:i32 = var
%1:i32 = mulnsw 2:i32, %0

Cost = 1
second query is SAT-- constant doesn't work

--------------------------------
guess 4

%0:i32 = var
%1:i32 = sdiv %0, 4:i32

Cost = 5
second query is SAT-- constant doesn't work

--------------------------------
guess 5

%0:i32 = var
%1:i32 = var
%2:i32 = var
%3:i32 = addnsw 1:i32, %2
%4:i32 = mulnsw 26:i32, %3
%5:i32 = sdiv %4, 10:i32
%6:i32 = addnsw %1, %5
%7:i32 = addnsw %0, %6
%8:i32 = var
%9:i32 = sdiv %8, 4:i32
%10:i32 = addnsw %7, %9

Cost = 15
second query is SAT-- constant doesn't work

--------------------------------
guess 6

%0:i32 = var
%1:i32 = var
%2:i32 = var
%3:i32 = addnsw 1:i32, %2
%4:i32 = mulnsw 26:i32, %3
%5:i32 = sdiv %4, 10:i32
%6:i32 = addnsw %1, %5
%7:i32 = addnsw %0, %6
%8:i32 = var
%9:i32 = sdiv %8, 4:i32
%10:i32 = addnsw %7, %9
%11:i32 = var
%12:i32 = sdiv %11, 4:i32
%13:i32 = addnsw %10, %12

Cost = 21
second query is SAT-- constant doesn't work

--------------------------------
guess 7

%0:i32 = var
%1:i32 = var
%2:i32 = var
%3:i32 = addnsw 1:i32, %2
%4:i32 = mulnsw 26:i32, %3
%5:i32 = sdiv %4, 10:i32
%6:i32 = addnsw %1, %5
%7:i32 = addnsw %0, %6
%8:i32 = var
%9:i32 = sdiv %8, 4:i32
%10:i32 = addnsw %7, %9
%11:i32 = var
%12:i32 = sdiv %11, 4:i32
%13:i32 = addnsw %10, %12
%14:i32 = var
%15:i32 = mulnsw 2:i32, %14
%16:i32 = subnsw %13, %15

Cost = 23
second query is SAT-- constant doesn't work
Dataflow Pruned 0/0
There are 8 Guesses
There are 0 RHSs before deduplication
There are 0 RHSs after deduplication
got 8 candidates from LHS

-------------------------------------------------
%0:i32 = var
%1:i32 = var
%2:i32 = var
%3:i32 = addnsw 1:i32, %2
%4:i32 = mulnsw 26:i32, %3
%5:i32 = sdiv %4, 10:i32
%6:i32 = addnsw %1, %5
%7:i32 = addnsw %0, %6
%8:i32 = var
%9:i32 = sdiv %8, 4:i32
%10:i32 = addnsw %7, %9
%11:i32 = var
%12:i32 = sdiv %11, 4:i32
%13:i32 = addnsw %10, %12
%14:i32 = var
%15:i32 = mulnsw 2:i32, %14
%16:i32 = subnsw %13, %15
%17:i32 = srem %16, 7:i32
%18:i32 = addnsw 7:i32, %17
infer %18


--------------------------------
guess 0

%0:i32 = var ; reservedconst_1

Cost = 0
first query is SAT, returning the model:
reservedconst_1: 9
0 th attempt: second query is SAT-- constant doesn't work
first query is SAT, returning the model:
reservedconst_1: 2
1 th attempt: second query is SAT-- constant doesn't work
first query is UNSAT-- no more guesses

--------------------------------
guess 1

%0:i32 = var

Cost = 0
second query is SAT-- constant doesn't work

--------------------------------
guess 2

%0:i32 = var
%1:i32 = mulnsw 2:i32, %0

Cost = 1
second query is SAT-- constant doesn't work

--------------------------------
guess 3

%0:i32 = var
%1:i32 = sdiv %0, 4:i32

Cost = 5
second query is SAT-- constant doesn't work

--------------------------------
guess 4

%0:i32 = var
%1:i32 = var
%2:i32 = var
%3:i32 = addnsw 1:i32, %2
%4:i32 = mulnsw 26:i32, %3
%5:i32 = sdiv %4, 10:i32
%6:i32 = addnsw %1, %5
%7:i32 = addnsw %0, %6
%8:i32 = var
%9:i32 = sdiv %8, 4:i32
%10:i32 = addnsw %7, %9

Cost = 15
second query is SAT-- constant doesn't work

--------------------------------
guess 5

%0:i32 = var
%1:i32 = var
%2:i32 = var
%3:i32 = addnsw 1:i32, %2
%4:i32 = mulnsw 26:i32, %3
%5:i32 = sdiv %4, 10:i32
%6:i32 = addnsw %1, %5
%7:i32 = addnsw %0, %6
%8:i32 = var
%9:i32 = sdiv %8, 4:i32
%10:i32 = addnsw %7, %9
%11:i32 = var
%12:i32 = sdiv %11, 4:i32
%13:i32 = addnsw %10, %12

Cost = 21
second query is SAT-- constant doesn't work

--------------------------------
guess 6

%0:i32 = var
%1:i32 = var
%2:i32 = var
%3:i32 = addnsw 1:i32, %2
%4:i32 = mulnsw 26:i32, %3
%5:i32 = sdiv %4, 10:i32
%6:i32 = addnsw %1, %5
%7:i32 = addnsw %0, %6
%8:i32 = var
%9:i32 = sdiv %8, 4:i32
%10:i32 = addnsw %7, %9
%11:i32 = var
%12:i32 = sdiv %11, 4:i32
%13:i32 = addnsw %10, %12
%14:i32 = var
%15:i32 = mulnsw 2:i32, %14
%16:i32 = subnsw %13, %15

Cost = 23
second query is SAT-- constant doesn't work

--------------------------------
guess 7

%0:i32 = var
%1:i32 = var
%2:i32 = var
%3:i32 = addnsw 1:i32, %2
%4:i32 = mulnsw 26:i32, %3
%5:i32 = sdiv %4, 10:i32
%6:i32 = addnsw %1, %5
%7:i32 = addnsw %0, %6
%8:i32 = var
%9:i32 = sdiv %8, 4:i32
%10:i32 = addnsw %7, %9
%11:i32 = var
%12:i32 = sdiv %11, 4:i32
%13:i32 = addnsw %10, %12
%14:i32 = var
%15:i32 = mulnsw 2:i32, %14
%16:i32 = subnsw %13, %15
%17:i32 = srem %16, 7:i32

Cost = 28
second query is SAT-- constant doesn't work
Dataflow Pruned 0/0
There are 8 Guesses
There are 0 RHSs before deduplication
There are 0 RHSs after deduplication
got 8 candidates from LHS

-------------------------------------------------
%0:i32 = var
%1:i32 = var
%2:i32 = var
%3:i32 = addnsw 1:i32, %2
%4:i32 = mulnsw 26:i32, %3
%5:i32 = sdiv %4, 10:i32
%6:i32 = addnsw %1, %5
%7:i32 = addnsw %0, %6
%8:i32 = var
%9:i32 = sdiv %8, 4:i32
%10:i32 = addnsw %7, %9
%11:i32 = var
%12:i32 = sdiv %11, 4:i32
%13:i32 = addnsw %10, %12
%14:i32 = var
%15:i32 = mulnsw 2:i32, %14
%16:i32 = subnsw %13, %15
%17:i32 = srem %16, 7:i32
%18:i32 = addnsw 7:i32, %17
%19:i32 = srem %18, 7:i32
infer %19


--------------------------------
guess 0

%0:i32 = var ; reservedconst_1

Cost = 0
first query is SAT, returning the model:
reservedconst_1: 2
0 th attempt: second query is SAT-- constant doesn't work
first query is SAT, returning the model:
reservedconst_1: 0
1 th attempt: second query is SAT-- constant doesn't work
first query is UNSAT-- no more guesses

--------------------------------
guess 1

%0:i32 = var
%1:i32 = mulnsw 2:i32, %0

Cost = 1
second query is SAT-- constant doesn't work

--------------------------------
guess 2

%0:i32 = var
%1:i32 = sdiv %0, 4:i32

Cost = 5
second query is SAT-- constant doesn't work

--------------------------------
guess 3

%0:i32 = var
%1:i32 = var
%2:i32 = var
%3:i32 = addnsw 1:i32, %2
%4:i32 = mulnsw 26:i32, %3
%5:i32 = sdiv %4, 10:i32
%6:i32 = addnsw %1, %5
%7:i32 = addnsw %0, %6
%8:i32 = var
%9:i32 = sdiv %8, 4:i32
%10:i32 = addnsw %7, %9

Cost = 15
second query is SAT-- constant doesn't work

--------------------------------
guess 4

%0:i32 = var
%1:i32 = var
%2:i32 = var
%3:i32 = addnsw 1:i32, %2
%4:i32 = mulnsw 26:i32, %3
%5:i32 = sdiv %4, 10:i32
%6:i32 = addnsw %1, %5
%7:i32 = addnsw %0, %6
%8:i32 = var
%9:i32 = sdiv %8, 4:i32
%10:i32 = addnsw %7, %9
%11:i32 = var
%12:i32 = sdiv %11, 4:i32
%13:i32 = addnsw %10, %12

Cost = 21
second query is SAT-- constant doesn't work

--------------------------------
guess 5

%0:i32 = var
%1:i32 = var
%2:i32 = var
%3:i32 = addnsw 1:i32, %2
%4:i32 = mulnsw 26:i32, %3
%5:i32 = sdiv %4, 10:i32
%6:i32 = addnsw %1, %5
%7:i32 = addnsw %0, %6
%8:i32 = var
%9:i32 = sdiv %8, 4:i32
%10:i32 = addnsw %7, %9
%11:i32 = var
%12:i32 = sdiv %11, 4:i32
%13:i32 = addnsw %10, %12
%14:i32 = var
%15:i32 = mulnsw 2:i32, %14
%16:i32 = subnsw %13, %15

Cost = 23
second query is SAT-- constant doesn't work

--------------------------------
guess 6

%0:i32 = var
%1:i32 = var
%2:i32 = var
%3:i32 = addnsw 1:i32, %2
%4:i32 = mulnsw 26:i32, %3
%5:i32 = sdiv %4, 10:i32
%6:i32 = addnsw %1, %5
%7:i32 = addnsw %0, %6
%8:i32 = var
%9:i32 = sdiv %8, 4:i32
%10:i32 = addnsw %7, %9
%11:i32 = var
%12:i32 = sdiv %11, 4:i32
%13:i32 = addnsw %10, %12
%14:i32 = var
%15:i32 = mulnsw 2:i32, %14
%16:i32 = subnsw %13, %15
%17:i32 = srem %16, 7:i32

Cost = 28
second query is SAT-- constant doesn't work

--------------------------------
guess 7

%0:i32 = var
%1:i32 = var
%2:i32 = var
%3:i32 = addnsw 1:i32, %2
%4:i32 = mulnsw 26:i32, %3
%5:i32 = sdiv %4, 10:i32
%6:i32 = addnsw %1, %5
%7:i32 = addnsw %0, %6
%8:i32 = var
%9:i32 = sdiv %8, 4:i32
%10:i32 = addnsw %7, %9
%11:i32 = var
%12:i32 = sdiv %11, 4:i32
%13:i32 = addnsw %10, %12
%14:i32 = var
%15:i32 = mulnsw 2:i32, %14
%16:i32 = subnsw %13, %15
%17:i32 = srem %16, 7:i32
%18:i32 = addnsw 7:i32, %17

Cost = 29
second query is SAT-- constant doesn't work
Dataflow Pruned 0/0
There are 8 Guesses
There are 0 RHSs before deduplication
There are 0 RHSs after deduplication
got 8 candidates from LHS

-------------------------------------------------
%0:i32 = var
%1:i32 = var
%2:i32 = var
%3:i32 = addnsw 1:i32, %2
%4:i32 = mulnsw 26:i32, %3
%5:i32 = sdiv %4, 10:i32
%6:i32 = addnsw %1, %5
%7:i32 = addnsw %0, %6
%8:i32 = var
%9:i32 = sdiv %8, 4:i32
%10:i32 = addnsw %7, %9
%11:i32 = var
%12:i32 = sdiv %11, 4:i32
%13:i32 = addnsw %10, %12
%14:i32 = var
%15:i32 = mulnsw 2:i32, %14
%16:i32 = subnsw %13, %15
%17:i32 = srem %16, 7:i32
%18:i32 = addnsw 7:i32, %17
%19:i32 = srem %18, 7:i32
%20:i32 = addnsw 1:i32, %19
infer %20


--------------------------------
guess 0

%0:i32 = var ; reservedconst_1

Cost = 0
first query is SAT, returning the model:
reservedconst_1: 3
0 th attempt: second query is SAT-- constant doesn't work
first query is SAT, returning the model:
reservedconst_1: 2
1 th attempt: second query is SAT-- constant doesn't work
first query is UNSAT-- no more guesses

--------------------------------
guess 1

%0:i32 = var
%1:i32 = mulnsw 2:i32, %0

Cost = 1
second query is SAT-- constant doesn't work

--------------------------------
guess 2

%0:i32 = var
%1:i32 = sdiv %0, 4:i32

Cost = 5
second query is SAT-- constant doesn't work

--------------------------------
guess 3

%0:i32 = var
%1:i32 = var
%2:i32 = var
%3:i32 = addnsw 1:i32, %2
%4:i32 = mulnsw 26:i32, %3
%5:i32 = sdiv %4, 10:i32
%6:i32 = addnsw %1, %5
%7:i32 = addnsw %0, %6
%8:i32 = var
%9:i32 = sdiv %8, 4:i32
%10:i32 = addnsw %7, %9
%11:i32 = var
%12:i32 = sdiv %11, 4:i32
%13:i32 = addnsw %10, %12

Cost = 21
second query is SAT-- constant doesn't work

--------------------------------
guess 4

%0:i32 = var
%1:i32 = var
%2:i32 = var
%3:i32 = addnsw 1:i32, %2
%4:i32 = mulnsw 26:i32, %3
%5:i32 = sdiv %4, 10:i32
%6:i32 = addnsw %1, %5
%7:i32 = addnsw %0, %6
%8:i32 = var
%9:i32 = sdiv %8, 4:i32
%10:i32 = addnsw %7, %9
%11:i32 = var
%12:i32 = sdiv %11, 4:i32
%13:i32 = addnsw %10, %12
%14:i32 = var
%15:i32 = mulnsw 2:i32, %14
%16:i32 = subnsw %13, %15

Cost = 23
second query is SAT-- constant doesn't work

--------------------------------
guess 5

%0:i32 = var
%1:i32 = var
%2:i32 = var
%3:i32 = addnsw 1:i32, %2
%4:i32 = mulnsw 26:i32, %3
%5:i32 = sdiv %4, 10:i32
%6:i32 = addnsw %1, %5
%7:i32 = addnsw %0, %6
%8:i32 = var
%9:i32 = sdiv %8, 4:i32
%10:i32 = addnsw %7, %9
%11:i32 = var
%12:i32 = sdiv %11, 4:i32
%13:i32 = addnsw %10, %12
%14:i32 = var
%15:i32 = mulnsw 2:i32, %14
%16:i32 = subnsw %13, %15
%17:i32 = srem %16, 7:i32

Cost = 28
second query is SAT-- constant doesn't work

--------------------------------
guess 6

%0:i32 = var
%1:i32 = var
%2:i32 = var
%3:i32 = addnsw 1:i32, %2
%4:i32 = mulnsw 26:i32, %3
%5:i32 = sdiv %4, 10:i32
%6:i32 = addnsw %1, %5
%7:i32 = addnsw %0, %6
%8:i32 = var
%9:i32 = sdiv %8, 4:i32
%10:i32 = addnsw %7, %9
%11:i32 = var
%12:i32 = sdiv %11, 4:i32
%13:i32 = addnsw %10, %12
%14:i32 = var
%15:i32 = mulnsw 2:i32, %14
%16:i32 = subnsw %13, %15
%17:i32 = srem %16, 7:i32
%18:i32 = addnsw 7:i32, %17

Cost = 29
second query is SAT-- constant doesn't work

--------------------------------
guess 7

%0:i32 = var
%1:i32 = var
%2:i32 = var
%3:i32 = addnsw 1:i32, %2
%4:i32 = mulnsw 26:i32, %3
%5:i32 = sdiv %4, 10:i32
%6:i32 = addnsw %1, %5
%7:i32 = addnsw %0, %6
%8:i32 = var
%9:i32 = sdiv %8, 4:i32
%10:i32 = addnsw %7, %9
%11:i32 = var
%12:i32 = sdiv %11, 4:i32
%13:i32 = addnsw %10, %12
%14:i32 = var
%15:i32 = mulnsw 2:i32, %14
%16:i32 = subnsw %13, %15
%17:i32 = srem %16, 7:i32
%18:i32 = addnsw 7:i32, %17
%19:i32 = srem %18, 7:i32

Cost = 34
second query is SAT-- constant doesn't work
Dataflow Pruned 0/0
There are 8 Guesses
There are 0 RHSs before deduplication
There are 0 RHSs after deduplication
#########################################################
; exiting Souper's runOnFunction() for week_day()

; entering Souper's runOnFunction() for easter_related_init()

; ModuleID = './Holidays_related_to_Easter.c.bc'
source_filename = "./Holidays_related_to_Easter.c"
target datalayout = "e-m:e-p:32:32-i64:64-n32:64-S128"
target triple = "wasm32-unknown-wasi"

%struct.date_t = type { i32, i32, i32, i32 }
%struct.easter_related_t = type { %struct.date_t, %struct.date_t, %struct.date_t, %struct.date_t, %struct.date_t }

@.str = private unnamed_addr constant [4 x i8] c"Jan\00", align 1
@.str.1 = private unnamed_addr constant [4 x i8] c"Feb\00", align 1
@.str.2 = private unnamed_addr constant [4 x i8] c"Mar\00", align 1
@.str.3 = private unnamed_addr constant [4 x i8] c"Apr\00", align 1
@.str.4 = private unnamed_addr constant [4 x i8] c"May\00", align 1
@.str.5 = private unnamed_addr constant [4 x i8] c"Jun\00", align 1
@.str.6 = private unnamed_addr constant [4 x i8] c"Jul\00", align 1
@.str.7 = private unnamed_addr constant [4 x i8] c"Aug\00", align 1
@.str.8 = private unnamed_addr constant [4 x i8] c"Sep\00", align 1
@.str.9 = private unnamed_addr constant [4 x i8] c"Oct\00", align 1
@.str.10 = private unnamed_addr constant [4 x i8] c"Nov\00", align 1
@.str.11 = private unnamed_addr constant [4 x i8] c"Dec\00", align 1
@mon_fmt = hidden global [13 x i8*] [i8* null, i8* getelementptr inbounds ([4 x i8], [4 x i8]* @.str, i32 0, i32 0), i8* getelementptr inbounds ([4 x i8], [4 x i8]* @.str.1, i32 0, i32 0), i8* getelementptr inbounds ([4 x i8], [4 x i8]* @.str.2, i32 0, i32 0), i8* getelementptr inbounds ([4 x i8], [4 x i8]* @.str.3, i32 0, i32 0), i8* getelementptr inbounds ([4 x i8], [4 x i8]* @.str.4, i32 0, i32 0), i8* getelementptr inbounds ([4 x i8], [4 x i8]* @.str.5, i32 0, i32 0), i8* getelementptr inbounds ([4 x i8], [4 x i8]* @.str.6, i32 0, i32 0), i8* getelementptr inbounds ([4 x i8], [4 x i8]* @.str.7, i32 0, i32 0), i8* getelementptr inbounds ([4 x i8], [4 x i8]* @.str.8, i32 0, i32 0), i8* getelementptr inbounds ([4 x i8], [4 x i8]* @.str.9, i32 0, i32 0), i8* getelementptr inbounds ([4 x i8], [4 x i8]* @.str.10, i32 0, i32 0), i8* getelementptr inbounds ([4 x i8], [4 x i8]* @.str.11, i32 0, i32 0)], align 16
@.str.12 = private unnamed_addr constant [4 x i8] c"Sat\00", align 1
@.str.13 = private unnamed_addr constant [4 x i8] c"Sun\00", align 1
@.str.14 = private unnamed_addr constant [4 x i8] c"Mon\00", align 1
@.str.15 = private unnamed_addr constant [4 x i8] c"Tue\00", align 1
@.str.16 = private unnamed_addr constant [4 x i8] c"Wed\00", align 1
@.str.17 = private unnamed_addr constant [4 x i8] c"Thu\00", align 1
@.str.18 = private unnamed_addr constant [4 x i8] c"Fri\00", align 1
@week_day_fmt = hidden global [8 x i8*] [i8* null, i8* getelementptr inbounds ([4 x i8], [4 x i8]* @.str.12, i32 0, i32 0), i8* getelementptr inbounds ([4 x i8], [4 x i8]* @.str.13, i32 0, i32 0), i8* getelementptr inbounds ([4 x i8], [4 x i8]* @.str.14, i32 0, i32 0), i8* getelementptr inbounds ([4 x i8], [4 x i8]* @.str.15, i32 0, i32 0), i8* getelementptr inbounds ([4 x i8], [4 x i8]* @.str.16, i32 0, i32 0), i8* getelementptr inbounds ([4 x i8], [4 x i8]* @.str.17, i32 0, i32 0), i8* getelementptr inbounds ([4 x i8], [4 x i8]* @.str.18, i32 0, i32 0)], align 16
@__const.month_days.days = private unnamed_addr constant [13 x i32] [i32 0, i32 31, i32 28, i32 31, i32 30, i32 31, i32 30, i32 31, i32 31, i32 30, i32 31, i32 30, i32 31], align 16
@year_months = hidden global i32 12, align 4
@week_days = hidden global i32 7, align 4
@.str.19 = private unnamed_addr constant [106 x i8] c"%4d Easter: %s %2d %s, Ascension: %s %2d %s, Pentecost: %s %2d %s, Trinity: %s %2d %s, Corpus: %s %2d %s\0A\00", align 1
@.str.20 = private unnamed_addr constant [81 x i8] c"Christian holidays, related to Easter, for each centennial from 400 to 2100 CE:\0A\00", align 1
@.str.21 = private unnamed_addr constant [73 x i8] c"\0AChristian holidays, related to Easter, for years from 2010 to 2020 CE:\0A\00", align 1
@llvm.used = appending global [1 x i8*] [i8* bitcast (i32 ()* @__main_void to i8*)], section "llvm.metadata"

@__main_void = alias i32 (), i32 ()* @main

; Function Attrs: noinline nounwind optnone
define hidden i32 @month_days(i32 %year, i32 %month) #0 {
entry:
  %year.addr = alloca i32, align 4
  %month.addr = alloca i32, align 4
  %days = alloca [13 x i32], align 16
  store i32 %year, i32* %year.addr, align 4
  store i32 %month, i32* %month.addr, align 4
  %0 = bitcast [13 x i32]* %days to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 16 %0, i8* align 16 bitcast ([13 x i32]* @__const.month_days.days to i8*), i32 52, i1 false)
  %1 = load i32, i32* %month.addr, align 4
  %cmp = icmp eq i32 %1, 2
  br i1 %cmp, label %cond.true, label %cond.false

cond.true:                                        ; preds = %entry
  %2 = load i32, i32* %year.addr, align 4
  %rem = srem i32 %2, 4
  %cmp1 = icmp eq i32 %rem, 0
  br i1 %cmp1, label %land.lhs.true, label %lor.rhs

land.lhs.true:                                    ; preds = %cond.true
  %3 = load i32, i32* %year.addr, align 4
  %rem2 = srem i32 %3, 100
  %cmp3 = icmp ne i32 %rem2, 0
  br i1 %cmp3, label %lor.end, label %lor.rhs

lor.rhs:                                          ; preds = %land.lhs.true, %cond.true
  %4 = load i32, i32* %year.addr, align 4
  %rem4 = srem i32 %4, 400
  %cmp5 = icmp eq i32 %rem4, 0
  br label %lor.end

lor.end:                                          ; preds = %lor.rhs, %land.lhs.true
  %5 = phi i1 [ true, %land.lhs.true ], [ %cmp5, %lor.rhs ]
  %lor.ext = zext i1 %5 to i32
  %add = add nsw i32 28, %lor.ext
  br label %cond.end

cond.false:                                       ; preds = %entry
  %6 = load i32, i32* %month.addr, align 4
  %arrayidx = getelementptr inbounds [13 x i32], [13 x i32]* %days, i32 0, i32 %6
  %7 = load i32, i32* %arrayidx, align 4
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %lor.end
  %cond = phi i32 [ %add, %lor.end ], [ %7, %cond.false ]
  ret i32 %cond
}

; Function Attrs: argmemonly nounwind willreturn
declare void @llvm.memcpy.p0i8.p0i8.i32(i8* noalias nocapture writeonly %0, i8* noalias nocapture readonly %1, i32 %2, i1 immarg %3) #1

; Function Attrs: noinline nounwind optnone
define hidden i32 @year_days(i32 %year) #0 {
entry:
  %year.addr = alloca i32, align 4
  store i32 %year, i32* %year.addr, align 4
  %0 = load i32, i32* %year.addr, align 4
  %call = call i32 @month_days(i32 %0, i32 2)
  %cmp = icmp eq i32 %call, 28
  %1 = zext i1 %cmp to i64
  %cond = select i1 %cmp, i32 365, i32 366
  ret i32 %cond
}

; Function Attrs: noinline nounwind optnone
define hidden void @plusab(%struct.date_t* noalias sret align 4 %agg.result, %struct.date_t* %date, i32 %days) #0 {
entry:
  %date.addr = alloca %struct.date_t*, align 4
  %days.addr = alloca i32, align 4
  store %struct.date_t* %date, %struct.date_t** %date.addr, align 4
  store i32 %days, i32* %days.addr, align 4
  br label %while.cond

while.cond:                                       ; preds = %while.body, %entry
  %0 = load i32, i32* %days.addr, align 4
  %cmp = icmp slt i32 %0, 0
  br i1 %cmp, label %while.body, label %while.end

while.body:                                       ; preds = %while.cond
  %1 = load %struct.date_t*, %struct.date_t** %date.addr, align 4
  %year = getelementptr inbounds %struct.date_t, %struct.date_t* %1, i32 0, i32 0
  %2 = load i32, i32* %year, align 4
  %sub = sub nsw i32 %2, 1
  store i32 %sub, i32* %year, align 4
  %3 = load %struct.date_t*, %struct.date_t** %date.addr, align 4
  %year1 = getelementptr inbounds %struct.date_t, %struct.date_t* %3, i32 0, i32 0
  %4 = load i32, i32* %year1, align 4
  %call = call i32 @year_days(i32 %4)
  %5 = load i32, i32* %days.addr, align 4
  %add = add nsw i32 %5, %call
  store i32 %add, i32* %days.addr, align 4
  br label %while.cond

while.end:                                        ; preds = %while.cond
  br label %while.cond2

while.cond2:                                      ; preds = %while.body6, %while.end
  %6 = load i32, i32* %days.addr, align 4
  %7 = load %struct.date_t*, %struct.date_t** %date.addr, align 4
  %year3 = getelementptr inbounds %struct.date_t, %struct.date_t* %7, i32 0, i32 0
  %8 = load i32, i32* %year3, align 4
  %call4 = call i32 @year_days(i32 %8)
  %cmp5 = icmp sgt i32 %6, %call4
  br i1 %cmp5, label %while.body6, label %while.end12

while.body6:                                      ; preds = %while.cond2
  %9 = load %struct.date_t*, %struct.date_t** %date.addr, align 4
  %year7 = getelementptr inbounds %struct.date_t, %struct.date_t* %9, i32 0, i32 0
  %10 = load i32, i32* %year7, align 4
  %call8 = call i32 @year_days(i32 %10)
  %11 = load i32, i32* %days.addr, align 4
  %sub9 = sub nsw i32 %11, %call8
  store i32 %sub9, i32* %days.addr, align 4
  %12 = load %struct.date_t*, %struct.date_t** %date.addr, align 4
  %year10 = getelementptr inbounds %struct.date_t, %struct.date_t* %12, i32 0, i32 0
  %13 = load i32, i32* %year10, align 4
  %add11 = add nsw i32 %13, 1
  store i32 %add11, i32* %year10, align 4
  br label %while.cond2

while.end12:                                      ; preds = %while.cond2
  %14 = load i32, i32* %days.addr, align 4
  %15 = load %struct.date_t*, %struct.date_t** %date.addr, align 4
  %month_day = getelementptr inbounds %struct.date_t, %struct.date_t* %15, i32 0, i32 2
  %16 = load i32, i32* %month_day, align 4
  %add13 = add nsw i32 %16, %14
  store i32 %add13, i32* %month_day, align 4
  br label %while.cond14

while.cond14:                                     ; preds = %if.end, %while.end12
  %17 = load %struct.date_t*, %struct.date_t** %date.addr, align 4
  %month_day15 = getelementptr inbounds %struct.date_t, %struct.date_t* %17, i32 0, i32 2
  %18 = load i32, i32* %month_day15, align 4
  %19 = load %struct.date_t*, %struct.date_t** %date.addr, align 4
  %year16 = getelementptr inbounds %struct.date_t, %struct.date_t* %19, i32 0, i32 0
  %20 = load i32, i32* %year16, align 4
  %21 = load %struct.date_t*, %struct.date_t** %date.addr, align 4
  %month = getelementptr inbounds %struct.date_t, %struct.date_t* %21, i32 0, i32 1
  %22 = load i32, i32* %month, align 4
  %call17 = call i32 @month_days(i32 %20, i32 %22)
  %cmp18 = icmp sgt i32 %18, %call17
  br i1 %cmp18, label %while.body19, label %while.end33

while.body19:                                     ; preds = %while.cond14
  %23 = load %struct.date_t*, %struct.date_t** %date.addr, align 4
  %year20 = getelementptr inbounds %struct.date_t, %struct.date_t* %23, i32 0, i32 0
  %24 = load i32, i32* %year20, align 4
  %25 = load %struct.date_t*, %struct.date_t** %date.addr, align 4
  %month21 = getelementptr inbounds %struct.date_t, %struct.date_t* %25, i32 0, i32 1
  %26 = load i32, i32* %month21, align 4
  %call22 = call i32 @month_days(i32 %24, i32 %26)
  %27 = load %struct.date_t*, %struct.date_t** %date.addr, align 4
  %month_day23 = getelementptr inbounds %struct.date_t, %struct.date_t* %27, i32 0, i32 2
  %28 = load i32, i32* %month_day23, align 4
  %sub24 = sub nsw i32 %28, %call22
  store i32 %sub24, i32* %month_day23, align 4
  %29 = load %struct.date_t*, %struct.date_t** %date.addr, align 4
  %month25 = getelementptr inbounds %struct.date_t, %struct.date_t* %29, i32 0, i32 1
  %30 = load i32, i32* %month25, align 4
  %add26 = add nsw i32 %30, 1
  store i32 %add26, i32* %month25, align 4
  %31 = load %struct.date_t*, %struct.date_t** %date.addr, align 4
  %month27 = getelementptr inbounds %struct.date_t, %struct.date_t* %31, i32 0, i32 1
  %32 = load i32, i32* %month27, align 4
  %33 = load i32, i32* @year_months, align 4
  %cmp28 = icmp sgt i32 %32, %33
  br i1 %cmp28, label %if.then, label %if.end

if.then:                                          ; preds = %while.body19
  %34 = load i32, i32* @year_months, align 4
  %35 = load %struct.date_t*, %struct.date_t** %date.addr, align 4
  %month29 = getelementptr inbounds %struct.date_t, %struct.date_t* %35, i32 0, i32 1
  %36 = load i32, i32* %month29, align 4
  %sub30 = sub nsw i32 %36, %34
  store i32 %sub30, i32* %month29, align 4
  %37 = load %struct.date_t*, %struct.date_t** %date.addr, align 4
  %year31 = getelementptr inbounds %struct.date_t, %struct.date_t* %37, i32 0, i32 0
  %38 = load i32, i32* %year31, align 4
  %add32 = add nsw i32 %38, 1
  store i32 %add32, i32* %year31, align 4
  br label %if.end

if.end:                                           ; preds = %if.then, %while.body19
  br label %while.cond14

while.end33:                                      ; preds = %while.cond14
  %39 = load %struct.date_t*, %struct.date_t** %date.addr, align 4
  %call34 = call i32 @week_day(%struct.date_t* byval(%struct.date_t) align 4 %39)
  %40 = load %struct.date_t*, %struct.date_t** %date.addr, align 4
  %week_day = getelementptr inbounds %struct.date_t, %struct.date_t* %40, i32 0, i32 3
  store i32 %call34, i32* %week_day, align 4
  %41 = load %struct.date_t*, %struct.date_t** %date.addr, align 4
  %42 = bitcast %struct.date_t* %agg.result to i8*
  %43 = bitcast %struct.date_t* %41 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 4 %42, i8* align 4 %43, i32 16, i1 false)
  ret void
}

; Function Attrs: noinline nounwind optnone
define hidden void @easter(%struct.date_t* noalias sret align 4 %agg.result, i32 %year) #0 {
entry:
  %year.addr = alloca i32, align 4
  %c = alloca i32, align 4
  %n = alloca i32, align 4
  %i = alloca i32, align 4
  %l = alloca i32, align 4
  store i32 %year, i32* %year.addr, align 4
  %0 = load i32, i32* %year.addr, align 4
  %year1 = getelementptr inbounds %struct.date_t, %struct.date_t* %agg.result, i32 0, i32 0
  store i32 %0, i32* %year1, align 4
  %1 = load i32, i32* %year.addr, align 4
  %div = sdiv i32 %1, 100
  store i32 %div, i32* %c, align 4
  %2 = load i32, i32* %year.addr, align 4
  %rem = srem i32 %2, 19
  store i32 %rem, i32* %n, align 4
  %3 = load i32, i32* %c, align 4
  %4 = load i32, i32* %c, align 4
  %div2 = sdiv i32 %4, 4
  %sub = sub nsw i32 %3, %div2
  %5 = load i32, i32* %c, align 4
  %6 = load i32, i32* %c, align 4
  %sub3 = sub nsw i32 %6, 17
  %div4 = sdiv i32 %sub3, 25
  %sub5 = sub nsw i32 %5, %div4
  %div6 = sdiv i32 %sub5, 3
  %sub7 = sub nsw i32 %sub, %div6
  %7 = load i32, i32* %n, align 4
  %mul = mul nsw i32 19, %7
  %add = add nsw i32 %sub7, %mul
  %add8 = add nsw i32 %add, 15
  %rem9 = srem i32 %add8, 30
  store i32 %rem9, i32* %i, align 4
  %8 = load i32, i32* %i, align 4
  %div10 = sdiv i32 %8, 28
  %9 = load i32, i32* %i, align 4
  %div11 = sdiv i32 %9, 28
  %10 = load i32, i32* %i, align 4
  %add12 = add nsw i32 %10, 1
  %div13 = sdiv i32 29, %add12
  %mul14 = mul nsw i32 %div11, %div13
  %11 = load i32, i32* %n, align 4
  %sub15 = sub nsw i32 21, %11
  %div16 = sdiv i32 %sub15, 11
  %mul17 = mul nsw i32 %mul14, %div16
  %sub18 = sub nsw i32 1, %mul17
  %mul19 = mul nsw i32 %div10, %sub18
  %12 = load i32, i32* %i, align 4
  %sub20 = sub nsw i32 %12, %mul19
  store i32 %sub20, i32* %i, align 4
  %13 = load i32, i32* %i, align 4
  %14 = load i32, i32* %year.addr, align 4
  %15 = load i32, i32* %year.addr, align 4
  %div21 = sdiv i32 %15, 4
  %add22 = add nsw i32 %14, %div21
  %16 = load i32, i32* %i, align 4
  %add23 = add nsw i32 %add22, %16
  %add24 = add nsw i32 %add23, 2
  %17 = load i32, i32* %c, align 4
  %sub25 = sub nsw i32 %add24, %17
  %18 = load i32, i32* %c, align 4
  %div26 = sdiv i32 %18, 4
  %add27 = add nsw i32 %sub25, %div26
  %rem28 = srem i32 %add27, 7
  %sub29 = sub nsw i32 %13, %rem28
  store i32 %sub29, i32* %l, align 4
  %19 = load i32, i32* %l, align 4
  %add30 = add nsw i32 %19, 40
  %div31 = sdiv i32 %add30, 44
  %add32 = add nsw i32 3, %div31
  %month = getelementptr inbounds %struct.date_t, %struct.date_t* %agg.result, i32 0, i32 1
  store i32 %add32, i32* %month, align 4
  %20 = load i32, i32* %l, align 4
  %add33 = add nsw i32 %20, 28
  %month34 = getelementptr inbounds %struct.date_t, %struct.date_t* %agg.result, i32 0, i32 1
  %21 = load i32, i32* %month34, align 4
  %div35 = sdiv i32 %21, 4
  %mul36 = mul nsw i32 31, %div35
  %sub37 = sub nsw i32 %add33, %mul36
  %month_day = getelementptr inbounds %struct.date_t, %struct.date_t* %agg.result, i32 0, i32 2
  store i32 %sub37, i32* %month_day, align 4
  %call = call i32 @week_day(%struct.date_t* byval(%struct.date_t) align 4 %agg.result)
  %week_day = getelementptr inbounds %struct.date_t, %struct.date_t* %agg.result, i32 0, i32 3
  store i32 %call, i32* %week_day, align 4
  ret void
}

; Function Attrs: noinline nounwind optnone
define hidden i32 @week_day(%struct.date_t* byval(%struct.date_t) align 4 %date) #0 {
entry:
  %year = alloca i32, align 4
  %month = alloca i32, align 4
  %month_day = alloca i32, align 4
  %c = alloca i32, align 4
  %year1 = getelementptr inbounds %struct.date_t, %struct.date_t* %date, i32 0, i32 0
  %0 = load i32, i32* %year1, align 4
  store i32 %0, i32* %year, align 4
  %month2 = getelementptr inbounds %struct.date_t, %struct.date_t* %date, i32 0, i32 1
  %1 = load i32, i32* %month2, align 4
  store i32 %1, i32* %month, align 4
  %month_day3 = getelementptr inbounds %struct.date_t, %struct.date_t* %date, i32 0, i32 2
  %2 = load i32, i32* %month_day3, align 4
  store i32 %2, i32* %month_day, align 4
  %3 = load i32, i32* %month, align 4
  %cmp = icmp sle i32 %3, 2
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %4 = load i32, i32* %month, align 4
  %add = add nsw i32 %4, 12
  store i32 %add, i32* %month, align 4
  %5 = load i32, i32* %year, align 4
  %sub = sub nsw i32 %5, 1
  store i32 %sub, i32* %year, align 4
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  %6 = load i32, i32* %year, align 4
  %div = sdiv i32 %6, 100
  store i32 %div, i32* %c, align 4
  %7 = load i32, i32* %year, align 4
  %rem = srem i32 %7, 100
  store i32 %rem, i32* %year, align 4
  %8 = load i32, i32* %month_day, align 4
  %9 = load i32, i32* %month, align 4
  %add4 = add nsw i32 %9, 1
  %mul = mul nsw i32 %add4, 26
  %div5 = sdiv i32 %mul, 10
  %add6 = add nsw i32 %8, %div5
  %10 = load i32, i32* %year, align 4
  %add7 = add nsw i32 %add6, %10
  %11 = load i32, i32* %year, align 4
  %div8 = sdiv i32 %11, 4
  %add9 = add nsw i32 %add7, %div8
  %12 = load i32, i32* %c, align 4
  %div10 = sdiv i32 %12, 4
  %add11 = add nsw i32 %add9, %div10
  %13 = load i32, i32* %c, align 4
  %mul12 = mul nsw i32 2, %13
  %sub13 = sub nsw i32 %add11, %mul12
  %rem14 = srem i32 %sub13, 7
  %add15 = add nsw i32 %rem14, 7
  %rem16 = srem i32 %add15, 7
  %add17 = add nsw i32 1, %rem16
  ret i32 %add17
}

; Function Attrs: noinline nounwind optnone
define hidden void @easter_related_init(%struct.easter_related_t* noalias sret align 4 %agg.result, i32 %year) #0 {
entry:
  %year.addr = alloca i32, align 4
  %date = alloca %struct.date_t, align 4
  %tmp = alloca %struct.date_t, align 4
  %tmp1 = alloca %struct.date_t, align 4
  %tmp2 = alloca %struct.date_t, align 4
  %tmp3 = alloca %struct.date_t, align 4
  %tmp4 = alloca %struct.date_t, align 4
  store i32 %year, i32* %year.addr, align 4
  %easter = getelementptr inbounds %struct.easter_related_t, %struct.easter_related_t* %agg.result, i32 0, i32 0
  %0 = load i32, i32* %year.addr, align 4
  call void @easter(%struct.date_t* sret align 4 %tmp, i32 %0)
  %1 = bitcast %struct.date_t* %date to i8*
  %2 = bitcast %struct.date_t* %tmp to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 4 %1, i8* align 4 %2, i32 16, i1 false)
  %3 = bitcast %struct.date_t* %easter to i8*
  %4 = bitcast %struct.date_t* %date to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 4 %3, i8* align 4 %4, i32 16, i1 false)
  %ascension = getelementptr inbounds %struct.easter_related_t, %struct.easter_related_t* %agg.result, i32 0, i32 1
  call void @plusab(%struct.date_t* sret align 4 %tmp1, %struct.date_t* %date, i32 39)
  %5 = bitcast %struct.date_t* %ascension to i8*
  %6 = bitcast %struct.date_t* %tmp1 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 4 %5, i8* align 4 %6, i32 16, i1 false)
  %pentecost = getelementptr inbounds %struct.easter_related_t, %struct.easter_related_t* %agg.result, i32 0, i32 2
  call void @plusab(%struct.date_t* sret align 4 %tmp2, %struct.date_t* %date, i32 10)
  %7 = bitcast %struct.date_t* %pentecost to i8*
  %8 = bitcast %struct.date_t* %tmp2 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 4 %7, i8* align 4 %8, i32 16, i1 false)
  %trinity = getelementptr inbounds %struct.easter_related_t, %struct.easter_related_t* %agg.result, i32 0, i32 3
  call void @plusab(%struct.date_t* sret align 4 %tmp3, %struct.date_t* %date, i32 7)
  %9 = bitcast %struct.date_t* %trinity to i8*
  %10 = bitcast %struct.date_t* %tmp3 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 4 %9, i8* align 4 %10, i32 16, i1 false)
  %corpus_christi = getelementptr inbounds %struct.easter_related_t, %struct.easter_related_t* %agg.result, i32 0, i32 4
  call void @plusab(%struct.date_t* sret align 4 %tmp4, %struct.date_t* %date, i32 4)
  %11 = bitcast %struct.date_t* %corpus_christi to i8*
  %12 = bitcast %struct.date_t* %tmp4 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 4 %11, i8* align 4 %12, i32 16, i1 false)
  ret void
}

; Function Attrs: noinline nounwind optnone
define hidden void @easter_related_print(i32 %year) #0 {
entry:
  %year.addr = alloca i32, align 4
  %holidays = alloca %struct.easter_related_t, align 4
  store i32 %year, i32* %year.addr, align 4
  %0 = load i32, i32* %year.addr, align 4
  call void @easter_related_init(%struct.easter_related_t* sret align 4 %holidays, i32 %0)
  %1 = load i32, i32* %year.addr, align 4
  %easter = getelementptr inbounds %struct.easter_related_t, %struct.easter_related_t* %holidays, i32 0, i32 0
  %week_day = getelementptr inbounds %struct.date_t, %struct.date_t* %easter, i32 0, i32 3
  %2 = load i32, i32* %week_day, align 4
  %arrayidx = getelementptr inbounds [8 x i8*], [8 x i8*]* @week_day_fmt, i32 0, i32 %2
  %3 = load i8*, i8** %arrayidx, align 4
  %easter1 = getelementptr inbounds %struct.easter_related_t, %struct.easter_related_t* %holidays, i32 0, i32 0
  %month_day = getelementptr inbounds %struct.date_t, %struct.date_t* %easter1, i32 0, i32 2
  %4 = load i32, i32* %month_day, align 4
  %easter2 = getelementptr inbounds %struct.easter_related_t, %struct.easter_related_t* %holidays, i32 0, i32 0
  %month = getelementptr inbounds %struct.date_t, %struct.date_t* %easter2, i32 0, i32 1
  %5 = load i32, i32* %month, align 4
  %arrayidx3 = getelementptr inbounds [13 x i8*], [13 x i8*]* @mon_fmt, i32 0, i32 %5
  %6 = load i8*, i8** %arrayidx3, align 4
  %ascension = getelementptr inbounds %struct.easter_related_t, %struct.easter_related_t* %holidays, i32 0, i32 1
  %week_day4 = getelementptr inbounds %struct.date_t, %struct.date_t* %ascension, i32 0, i32 3
  %7 = load i32, i32* %week_day4, align 4
  %arrayidx5 = getelementptr inbounds [8 x i8*], [8 x i8*]* @week_day_fmt, i32 0, i32 %7
  %8 = load i8*, i8** %arrayidx5, align 4
  %ascension6 = getelementptr inbounds %struct.easter_related_t, %struct.easter_related_t* %holidays, i32 0, i32 1
  %month_day7 = getelementptr inbounds %struct.date_t, %struct.date_t* %ascension6, i32 0, i32 2
  %9 = load i32, i32* %month_day7, align 4
  %ascension8 = getelementptr inbounds %struct.easter_related_t, %struct.easter_related_t* %holidays, i32 0, i32 1
  %month9 = getelementptr inbounds %struct.date_t, %struct.date_t* %ascension8, i32 0, i32 1
  %10 = load i32, i32* %month9, align 4
  %arrayidx10 = getelementptr inbounds [13 x i8*], [13 x i8*]* @mon_fmt, i32 0, i32 %10
  %11 = load i8*, i8** %arrayidx10, align 4
  %pentecost = getelementptr inbounds %struct.easter_related_t, %struct.easter_related_t* %holidays, i32 0, i32 2
  %week_day11 = getelementptr inbounds %struct.date_t, %struct.date_t* %pentecost, i32 0, i32 3
  %12 = load i32, i32* %week_day11, align 4
  %arrayidx12 = getelementptr inbounds [8 x i8*], [8 x i8*]* @week_day_fmt, i32 0, i32 %12
  %13 = load i8*, i8** %arrayidx12, align 4
  %pentecost13 = getelementptr inbounds %struct.easter_related_t, %struct.easter_related_t* %holidays, i32 0, i32 2
  %month_day14 = getelementptr inbounds %struct.date_t, %struct.date_t* %pentecost13, i32 0, i32 2
  %14 = load i32, i32* %month_day14, align 4
  %pentecost15 = getelementptr inbounds %struct.easter_related_t, %struct.easter_related_t* %holidays, i32 0, i32 2
  %month16 = getelementptr inbounds %struct.date_t, %struct.date_t* %pentecost15, i32 0, i32 1
  %15 = load i32, i32* %month16, align 4
  %arrayidx17 = getelementptr inbounds [13 x i8*], [13 x i8*]* @mon_fmt, i32 0, i32 %15
  %16 = load i8*, i8** %arrayidx17, align 4
  %trinity = getelementptr inbounds %struct.easter_related_t, %struct.easter_related_t* %holidays, i32 0, i32 3
  %week_day18 = getelementptr inbounds %struct.date_t, %struct.date_t* %trinity, i32 0, i32 3
  %17 = load i32, i32* %week_day18, align 4
  %arrayidx19 = getelementptr inbounds [8 x i8*], [8 x i8*]* @week_day_fmt, i32 0, i32 %17
  %18 = load i8*, i8** %arrayidx19, align 4
  %trinity20 = getelementptr inbounds %struct.easter_related_t, %struct.easter_related_t* %holidays, i32 0, i32 3
  %month_day21 = getelementptr inbounds %struct.date_t, %struct.date_t* %trinity20, i32 0, i32 2
  %19 = load i32, i32* %month_day21, align 4
  %trinity22 = getelementptr inbounds %struct.easter_related_t, %struct.easter_related_t* %holidays, i32 0, i32 3
  %month23 = getelementptr inbounds %struct.date_t, %struct.date_t* %trinity22, i32 0, i32 1
  %20 = load i32, i32* %month23, align 4
  %arrayidx24 = getelementptr inbounds [13 x i8*], [13 x i8*]* @mon_fmt, i32 0, i32 %20
  %21 = load i8*, i8** %arrayidx24, align 4
  %corpus_christi = getelementptr inbounds %struct.easter_related_t, %struct.easter_related_t* %holidays, i32 0, i32 4
  %week_day25 = getelementptr inbounds %struct.date_t, %struct.date_t* %corpus_christi, i32 0, i32 3
  %22 = load i32, i32* %week_day25, align 4
  %arrayidx26 = getelementptr inbounds [8 x i8*], [8 x i8*]* @week_day_fmt, i32 0, i32 %22
  %23 = load i8*, i8** %arrayidx26, align 4
  %corpus_christi27 = getelementptr inbounds %struct.easter_related_t, %struct.easter_related_t* %holidays, i32 0, i32 4
  %month_day28 = getelementptr inbounds %struct.date_t, %struct.date_t* %corpus_christi27, i32 0, i32 2
  %24 = load i32, i32* %month_day28, align 4
  %corpus_christi29 = getelementptr inbounds %struct.easter_related_t, %struct.easter_related_t* %holidays, i32 0, i32 4
  %month30 = getelementptr inbounds %struct.date_t, %struct.date_t* %corpus_christi29, i32 0, i32 1
  %25 = load i32, i32* %month30, align 4
  %arrayidx31 = getelementptr inbounds [13 x i8*], [13 x i8*]* @mon_fmt, i32 0, i32 %25
  %26 = load i8*, i8** %arrayidx31, align 4
  %call = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([106 x i8], [106 x i8]* @.str.19, i32 0, i32 0), i32 %1, i8* %3, i32 %4, i8* %6, i8* %8, i32 %9, i8* %11, i8* %13, i32 %14, i8* %16, i8* %18, i32 %19, i8* %21, i8* %23, i32 %24, i8* %26)
  ret void
}

declare i32 @printf(i8* %0, ...) #2

; Function Attrs: noinline nounwind optnone
define hidden i32 @main() #0 {
entry:
  %retval = alloca i32, align 4
  %year = alloca i32, align 4
  store i32 0, i32* %retval, align 4
  %call = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([81 x i8], [81 x i8]* @.str.20, i32 0, i32 0))
  store i32 400, i32* %year, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %0 = load i32, i32* %year, align 4
  %cmp = icmp sle i32 %0, 2100
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %1 = load i32, i32* %year, align 4
  call void @easter_related_print(i32 %1)
  br label %for.inc

for.inc:                                          ; preds = %for.body
  %2 = load i32, i32* %year, align 4
  %add = add nsw i32 %2, 100
  store i32 %add, i32* %year, align 4
  br label %for.cond

for.end:                                          ; preds = %for.cond
  %call1 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([73 x i8], [73 x i8]* @.str.21, i32 0, i32 0))
  store i32 2010, i32* %year, align 4
  br label %for.cond2

for.cond2:                                        ; preds = %for.inc5, %for.end
  %3 = load i32, i32* %year, align 4
  %cmp3 = icmp sle i32 %3, 2020
  br i1 %cmp3, label %for.body4, label %for.end6

for.body4:                                        ; preds = %for.cond2
  %4 = load i32, i32* %year, align 4
  call void @easter_related_print(i32 %4)
  br label %for.inc5

for.inc5:                                         ; preds = %for.body4
  %5 = load i32, i32* %year, align 4
  %inc = add nsw i32 %5, 1
  store i32 %inc, i32* %year, align 4
  br label %for.cond2

for.end6:                                         ; preds = %for.cond2
  ret i32 0
}

attributes #0 = { noinline nounwind optnone "correctly-rounded-divide-sqrt-fp-math"="false" "disable-tail-calls"="false" "frame-pointer"="none" "less-precise-fpmad"="false" "min-legal-vector-width"="0" "no-infs-fp-math"="false" "no-jump-tables"="false" "no-nans-fp-math"="false" "no-signed-zeros-fp-math"="false" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="generic" "unsafe-fp-math"="false" "use-soft-float"="false" }
attributes #1 = { argmemonly nounwind willreturn }
attributes #2 = { "correctly-rounded-divide-sqrt-fp-math"="false" "disable-tail-calls"="false" "frame-pointer"="none" "less-precise-fpmad"="false" "no-infs-fp-math"="false" "no-nans-fp-math"="false" "no-signed-zeros-fp-math"="false" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="generic" "unsafe-fp-math"="false" "use-soft-float"="false" }

!llvm.module.flags = !{!0}
!llvm.ident = !{!1}

!0 = !{i32 1, !"wchar_size", i32 4}
!1 = !{!"clang version 11.0.0 (https://github.com/Jacarte/llvm-project.git 0f6dea67136cc1e0b3d200eb2bb165628970c44b)"}

; extracted candidates

; *****
; For LLVM instruction:
;  %0 = load i32, i32* %year.addr, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0
#########################################################
; exiting Souper's runOnFunction() for easter_related_init()

; entering Souper's runOnFunction() for easter_related_print()

; ModuleID = './Holidays_related_to_Easter.c.bc'
source_filename = "./Holidays_related_to_Easter.c"
target datalayout = "e-m:e-p:32:32-i64:64-n32:64-S128"
target triple = "wasm32-unknown-wasi"

%struct.date_t = type { i32, i32, i32, i32 }
%struct.easter_related_t = type { %struct.date_t, %struct.date_t, %struct.date_t, %struct.date_t, %struct.date_t }

@.str = private unnamed_addr constant [4 x i8] c"Jan\00", align 1
@.str.1 = private unnamed_addr constant [4 x i8] c"Feb\00", align 1
@.str.2 = private unnamed_addr constant [4 x i8] c"Mar\00", align 1
@.str.3 = private unnamed_addr constant [4 x i8] c"Apr\00", align 1
@.str.4 = private unnamed_addr constant [4 x i8] c"May\00", align 1
@.str.5 = private unnamed_addr constant [4 x i8] c"Jun\00", align 1
@.str.6 = private unnamed_addr constant [4 x i8] c"Jul\00", align 1
@.str.7 = private unnamed_addr constant [4 x i8] c"Aug\00", align 1
@.str.8 = private unnamed_addr constant [4 x i8] c"Sep\00", align 1
@.str.9 = private unnamed_addr constant [4 x i8] c"Oct\00", align 1
@.str.10 = private unnamed_addr constant [4 x i8] c"Nov\00", align 1
@.str.11 = private unnamed_addr constant [4 x i8] c"Dec\00", align 1
@mon_fmt = hidden global [13 x i8*] [i8* null, i8* getelementptr inbounds ([4 x i8], [4 x i8]* @.str, i32 0, i32 0), i8* getelementptr inbounds ([4 x i8], [4 x i8]* @.str.1, i32 0, i32 0), i8* getelementptr inbounds ([4 x i8], [4 x i8]* @.str.2, i32 0, i32 0), i8* getelementptr inbounds ([4 x i8], [4 x i8]* @.str.3, i32 0, i32 0), i8* getelementptr inbounds ([4 x i8], [4 x i8]* @.str.4, i32 0, i32 0), i8* getelementptr inbounds ([4 x i8], [4 x i8]* @.str.5, i32 0, i32 0), i8* getelementptr inbounds ([4 x i8], [4 x i8]* @.str.6, i32 0, i32 0), i8* getelementptr inbounds ([4 x i8], [4 x i8]* @.str.7, i32 0, i32 0), i8* getelementptr inbounds ([4 x i8], [4 x i8]* @.str.8, i32 0, i32 0), i8* getelementptr inbounds ([4 x i8], [4 x i8]* @.str.9, i32 0, i32 0), i8* getelementptr inbounds ([4 x i8], [4 x i8]* @.str.10, i32 0, i32 0), i8* getelementptr inbounds ([4 x i8], [4 x i8]* @.str.11, i32 0, i32 0)], align 16
@.str.12 = private unnamed_addr constant [4 x i8] c"Sat\00", align 1
@.str.13 = private unnamed_addr constant [4 x i8] c"Sun\00", align 1
@.str.14 = private unnamed_addr constant [4 x i8] c"Mon\00", align 1
@.str.15 = private unnamed_addr constant [4 x i8] c"Tue\00", align 1
@.str.16 = private unnamed_addr constant [4 x i8] c"Wed\00", align 1
@.str.17 = private unnamed_addr constant [4 x i8] c"Thu\00", align 1
@.str.18 = private unnamed_addr constant [4 x i8] c"Fri\00", align 1
@week_day_fmt = hidden global [8 x i8*] [i8* null, i8* getelementptr inbounds ([4 x i8], [4 x i8]* @.str.12, i32 0, i32 0), i8* getelementptr inbounds ([4 x i8], [4 x i8]* @.str.13, i32 0, i32 0), i8* getelementptr inbounds ([4 x i8], [4 x i8]* @.str.14, i32 0, i32 0), i8* getelementptr inbounds ([4 x i8], [4 x i8]* @.str.15, i32 0, i32 0), i8* getelementptr inbounds ([4 x i8], [4 x i8]* @.str.16, i32 0, i32 0), i8* getelementptr inbounds ([4 x i8], [4 x i8]* @.str.17, i32 0, i32 0), i8* getelementptr inbounds ([4 x i8], [4 x i8]* @.str.18, i32 0, i32 0)], align 16
@__const.month_days.days = private unnamed_addr constant [13 x i32] [i32 0, i32 31, i32 28, i32 31, i32 30, i32 31, i32 30, i32 31, i32 31, i32 30, i32 31, i32 30, i32 31], align 16
@year_months = hidden global i32 12, align 4
@week_days = hidden global i32 7, align 4
@.str.19 = private unnamed_addr constant [106 x i8] c"%4d Easter: %s %2d %s, Ascension: %s %2d %s, Pentecost: %s %2d %s, Trinity: %s %2d %s, Corpus: %s %2d %s\0A\00", align 1
@.str.20 = private unnamed_addr constant [81 x i8] c"Christian holidays, related to Easter, for each centennial from 400 to 2100 CE:\0A\00", align 1
@.str.21 = private unnamed_addr constant [73 x i8] c"\0AChristian holidays, related to Easter, for years from 2010 to 2020 CE:\0A\00", align 1
@llvm.used = appending global [1 x i8*] [i8* bitcast (i32 ()* @__main_void to i8*)], section "llvm.metadata"

@__main_void = alias i32 (), i32 ()* @main

; Function Attrs: noinline nounwind optnone
define hidden i32 @month_days(i32 %year, i32 %month) #0 {
entry:
  %year.addr = alloca i32, align 4
  %month.addr = alloca i32, align 4
  %days = alloca [13 x i32], align 16
  store i32 %year, i32* %year.addr, align 4
  store i32 %month, i32* %month.addr, align 4
  %0 = bitcast [13 x i32]* %days to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 16 %0, i8* align 16 bitcast ([13 x i32]* @__const.month_days.days to i8*), i32 52, i1 false)
  %1 = load i32, i32* %month.addr, align 4
  %cmp = icmp eq i32 %1, 2
  br i1 %cmp, label %cond.true, label %cond.false

cond.true:                                        ; preds = %entry
  %2 = load i32, i32* %year.addr, align 4
  %rem = srem i32 %2, 4
  %cmp1 = icmp eq i32 %rem, 0
  br i1 %cmp1, label %land.lhs.true, label %lor.rhs

land.lhs.true:                                    ; preds = %cond.true
  %3 = load i32, i32* %year.addr, align 4
  %rem2 = srem i32 %3, 100
  %cmp3 = icmp ne i32 %rem2, 0
  br i1 %cmp3, label %lor.end, label %lor.rhs

lor.rhs:                                          ; preds = %land.lhs.true, %cond.true
  %4 = load i32, i32* %year.addr, align 4
  %rem4 = srem i32 %4, 400
  %cmp5 = icmp eq i32 %rem4, 0
  br label %lor.end

lor.end:                                          ; preds = %lor.rhs, %land.lhs.true
  %5 = phi i1 [ true, %land.lhs.true ], [ %cmp5, %lor.rhs ]
  %lor.ext = zext i1 %5 to i32
  %add = add nsw i32 28, %lor.ext
  br label %cond.end

cond.false:                                       ; preds = %entry
  %6 = load i32, i32* %month.addr, align 4
  %arrayidx = getelementptr inbounds [13 x i32], [13 x i32]* %days, i32 0, i32 %6
  %7 = load i32, i32* %arrayidx, align 4
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %lor.end
  %cond = phi i32 [ %add, %lor.end ], [ %7, %cond.false ]
  ret i32 %cond
}

; Function Attrs: argmemonly nounwind willreturn
declare void @llvm.memcpy.p0i8.p0i8.i32(i8* noalias nocapture writeonly %0, i8* noalias nocapture readonly %1, i32 %2, i1 immarg %3) #1

; Function Attrs: noinline nounwind optnone
define hidden i32 @year_days(i32 %year) #0 {
entry:
  %year.addr = alloca i32, align 4
  store i32 %year, i32* %year.addr, align 4
  %0 = load i32, i32* %year.addr, align 4
  %call = call i32 @month_days(i32 %0, i32 2)
  %cmp = icmp eq i32 %call, 28
  %1 = zext i1 %cmp to i64
  %cond = select i1 %cmp, i32 365, i32 366
  ret i32 %cond
}

; Function Attrs: noinline nounwind optnone
define hidden void @plusab(%struct.date_t* noalias sret align 4 %agg.result, %struct.date_t* %date, i32 %days) #0 {
entry:
  %date.addr = alloca %struct.date_t*, align 4
  %days.addr = alloca i32, align 4
  store %struct.date_t* %date, %struct.date_t** %date.addr, align 4
  store i32 %days, i32* %days.addr, align 4
  br label %while.cond

while.cond:                                       ; preds = %while.body, %entry
  %0 = load i32, i32* %days.addr, align 4
  %cmp = icmp slt i32 %0, 0
  br i1 %cmp, label %while.body, label %while.end

while.body:                                       ; preds = %while.cond
  %1 = load %struct.date_t*, %struct.date_t** %date.addr, align 4
  %year = getelementptr inbounds %struct.date_t, %struct.date_t* %1, i32 0, i32 0
  %2 = load i32, i32* %year, align 4
  %sub = sub nsw i32 %2, 1
  store i32 %sub, i32* %year, align 4
  %3 = load %struct.date_t*, %struct.date_t** %date.addr, align 4
  %year1 = getelementptr inbounds %struct.date_t, %struct.date_t* %3, i32 0, i32 0
  %4 = load i32, i32* %year1, align 4
  %call = call i32 @year_days(i32 %4)
  %5 = load i32, i32* %days.addr, align 4
  %add = add nsw i32 %5, %call
  store i32 %add, i32* %days.addr, align 4
  br label %while.cond

while.end:                                        ; preds = %while.cond
  br label %while.cond2

while.cond2:                                      ; preds = %while.body6, %while.end
  %6 = load i32, i32* %days.addr, align 4
  %7 = load %struct.date_t*, %struct.date_t** %date.addr, align 4
  %year3 = getelementptr inbounds %struct.date_t, %struct.date_t* %7, i32 0, i32 0
  %8 = load i32, i32* %year3, align 4
  %call4 = call i32 @year_days(i32 %8)
  %cmp5 = icmp sgt i32 %6, %call4
  br i1 %cmp5, label %while.body6, label %while.end12

while.body6:                                      ; preds = %while.cond2
  %9 = load %struct.date_t*, %struct.date_t** %date.addr, align 4
  %year7 = getelementptr inbounds %struct.date_t, %struct.date_t* %9, i32 0, i32 0
  %10 = load i32, i32* %year7, align 4
  %call8 = call i32 @year_days(i32 %10)
  %11 = load i32, i32* %days.addr, align 4
  %sub9 = sub nsw i32 %11, %call8
  store i32 %sub9, i32* %days.addr, align 4
  %12 = load %struct.date_t*, %struct.date_t** %date.addr, align 4
  %year10 = getelementptr inbounds %struct.date_t, %struct.date_t* %12, i32 0, i32 0
  %13 = load i32, i32* %year10, align 4
  %add11 = add nsw i32 %13, 1
  store i32 %add11, i32* %year10, align 4
  br label %while.cond2

while.end12:                                      ; preds = %while.cond2
  %14 = load i32, i32* %days.addr, align 4
  %15 = load %struct.date_t*, %struct.date_t** %date.addr, align 4
  %month_day = getelementptr inbounds %struct.date_t, %struct.date_t* %15, i32 0, i32 2
  %16 = load i32, i32* %month_day, align 4
  %add13 = add nsw i32 %16, %14
  store i32 %add13, i32* %month_day, align 4
  br label %while.cond14

while.cond14:                                     ; preds = %if.end, %while.end12
  %17 = load %struct.date_t*, %struct.date_t** %date.addr, align 4
  %month_day15 = getelementptr inbounds %struct.date_t, %struct.date_t* %17, i32 0, i32 2
  %18 = load i32, i32* %month_day15, align 4
  %19 = load %struct.date_t*, %struct.date_t** %date.addr, align 4
  %year16 = getelementptr inbounds %struct.date_t, %struct.date_t* %19, i32 0, i32 0
  %20 = load i32, i32* %year16, align 4
  %21 = load %struct.date_t*, %struct.date_t** %date.addr, align 4
  %month = getelementptr inbounds %struct.date_t, %struct.date_t* %21, i32 0, i32 1
  %22 = load i32, i32* %month, align 4
  %call17 = call i32 @month_days(i32 %20, i32 %22)
  %cmp18 = icmp sgt i32 %18, %call17
  br i1 %cmp18, label %while.body19, label %while.end33

while.body19:                                     ; preds = %while.cond14
  %23 = load %struct.date_t*, %struct.date_t** %date.addr, align 4
  %year20 = getelementptr inbounds %struct.date_t, %struct.date_t* %23, i32 0, i32 0
  %24 = load i32, i32* %year20, align 4
  %25 = load %struct.date_t*, %struct.date_t** %date.addr, align 4
  %month21 = getelementptr inbounds %struct.date_t, %struct.date_t* %25, i32 0, i32 1
  %26 = load i32, i32* %month21, align 4
  %call22 = call i32 @month_days(i32 %24, i32 %26)
  %27 = load %struct.date_t*, %struct.date_t** %date.addr, align 4
  %month_day23 = getelementptr inbounds %struct.date_t, %struct.date_t* %27, i32 0, i32 2
  %28 = load i32, i32* %month_day23, align 4
  %sub24 = sub nsw i32 %28, %call22
  store i32 %sub24, i32* %month_day23, align 4
  %29 = load %struct.date_t*, %struct.date_t** %date.addr, align 4
  %month25 = getelementptr inbounds %struct.date_t, %struct.date_t* %29, i32 0, i32 1
  %30 = load i32, i32* %month25, align 4
  %add26 = add nsw i32 %30, 1
  store i32 %add26, i32* %month25, align 4
  %31 = load %struct.date_t*, %struct.date_t** %date.addr, align 4
  %month27 = getelementptr inbounds %struct.date_t, %struct.date_t* %31, i32 0, i32 1
  %32 = load i32, i32* %month27, align 4
  %33 = load i32, i32* @year_months, align 4
  %cmp28 = icmp sgt i32 %32, %33
  br i1 %cmp28, label %if.then, label %if.end

if.then:                                          ; preds = %while.body19
  %34 = load i32, i32* @year_months, align 4
  %35 = load %struct.date_t*, %struct.date_t** %date.addr, align 4
  %month29 = getelementptr inbounds %struct.date_t, %struct.date_t* %35, i32 0, i32 1
  %36 = load i32, i32* %month29, align 4
  %sub30 = sub nsw i32 %36, %34
  store i32 %sub30, i32* %month29, align 4
  %37 = load %struct.date_t*, %struct.date_t** %date.addr, align 4
  %year31 = getelementptr inbounds %struct.date_t, %struct.date_t* %37, i32 0, i32 0
  %38 = load i32, i32* %year31, align 4
  %add32 = add nsw i32 %38, 1
  store i32 %add32, i32* %year31, align 4
  br label %if.end

if.end:                                           ; preds = %if.then, %while.body19
  br label %while.cond14

while.end33:                                      ; preds = %while.cond14
  %39 = load %struct.date_t*, %struct.date_t** %date.addr, align 4
  %call34 = call i32 @week_day(%struct.date_t* byval(%struct.date_t) align 4 %39)
  %40 = load %struct.date_t*, %struct.date_t** %date.addr, align 4
  %week_day = getelementptr inbounds %struct.date_t, %struct.date_t* %40, i32 0, i32 3
  store i32 %call34, i32* %week_day, align 4
  %41 = load %struct.date_t*, %struct.date_t** %date.addr, align 4
  %42 = bitcast %struct.date_t* %agg.result to i8*
  %43 = bitcast %struct.date_t* %41 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 4 %42, i8* align 4 %43, i32 16, i1 false)
  ret void
}

; Function Attrs: noinline nounwind optnone
define hidden void @easter(%struct.date_t* noalias sret align 4 %agg.result, i32 %year) #0 {
entry:
  %year.addr = alloca i32, align 4
  %c = alloca i32, align 4
  %n = alloca i32, align 4
  %i = alloca i32, align 4
  %l = alloca i32, align 4
  store i32 %year, i32* %year.addr, align 4
  %0 = load i32, i32* %year.addr, align 4
  %year1 = getelementptr inbounds %struct.date_t, %struct.date_t* %agg.result, i32 0, i32 0
  store i32 %0, i32* %year1, align 4
  %1 = load i32, i32* %year.addr, align 4
  %div = sdiv i32 %1, 100
  store i32 %div, i32* %c, align 4
  %2 = load i32, i32* %year.addr, align 4
  %rem = srem i32 %2, 19
  store i32 %rem, i32* %n, align 4
  %3 = load i32, i32* %c, align 4
  %4 = load i32, i32* %c, align 4
  %div2 = sdiv i32 %4, 4
  %sub = sub nsw i32 %3, %div2
  %5 = load i32, i32* %c, align 4
  %6 = load i32, i32* %c, align 4
  %sub3 = sub nsw i32 %6, 17
  %div4 = sdiv i32 %sub3, 25
  %sub5 = sub nsw i32 %5, %div4
  %div6 = sdiv i32 %sub5, 3
  %sub7 = sub nsw i32 %sub, %div6
  %7 = load i32, i32* %n, align 4
  %mul = mul nsw i32 19, %7
  %add = add nsw i32 %sub7, %mul
  %add8 = add nsw i32 %add, 15
  %rem9 = srem i32 %add8, 30
  store i32 %rem9, i32* %i, align 4
  %8 = load i32, i32* %i, align 4
  %div10 = sdiv i32 %8, 28
  %9 = load i32, i32* %i, align 4
  %div11 = sdiv i32 %9, 28
  %10 = load i32, i32* %i, align 4
  %add12 = add nsw i32 %10, 1
  %div13 = sdiv i32 29, %add12
  %mul14 = mul nsw i32 %div11, %div13
  %11 = load i32, i32* %n, align 4
  %sub15 = sub nsw i32 21, %11
  %div16 = sdiv i32 %sub15, 11
  %mul17 = mul nsw i32 %mul14, %div16
  %sub18 = sub nsw i32 1, %mul17
  %mul19 = mul nsw i32 %div10, %sub18
  %12 = load i32, i32* %i, align 4
  %sub20 = sub nsw i32 %12, %mul19
  store i32 %sub20, i32* %i, align 4
  %13 = load i32, i32* %i, align 4
  %14 = load i32, i32* %year.addr, align 4
  %15 = load i32, i32* %year.addr, align 4
  %div21 = sdiv i32 %15, 4
  %add22 = add nsw i32 %14, %div21
  %16 = load i32, i32* %i, align 4
  %add23 = add nsw i32 %add22, %16
  %add24 = add nsw i32 %add23, 2
  %17 = load i32, i32* %c, align 4
  %sub25 = sub nsw i32 %add24, %17
  %18 = load i32, i32* %c, align 4
  %div26 = sdiv i32 %18, 4
  %add27 = add nsw i32 %sub25, %div26
  %rem28 = srem i32 %add27, 7
  %sub29 = sub nsw i32 %13, %rem28
  store i32 %sub29, i32* %l, align 4
  %19 = load i32, i32* %l, align 4
  %add30 = add nsw i32 %19, 40
  %div31 = sdiv i32 %add30, 44
  %add32 = add nsw i32 3, %div31
  %month = getelementptr inbounds %struct.date_t, %struct.date_t* %agg.result, i32 0, i32 1
  store i32 %add32, i32* %month, align 4
  %20 = load i32, i32* %l, align 4
  %add33 = add nsw i32 %20, 28
  %month34 = getelementptr inbounds %struct.date_t, %struct.date_t* %agg.result, i32 0, i32 1
  %21 = load i32, i32* %month34, align 4
  %div35 = sdiv i32 %21, 4
  %mul36 = mul nsw i32 31, %div35
  %sub37 = sub nsw i32 %add33, %mul36
  %month_day = getelementptr inbounds %struct.date_t, %struct.date_t* %agg.result, i32 0, i32 2
  store i32 %sub37, i32* %month_day, align 4
  %call = call i32 @week_day(%struct.date_t* byval(%struct.date_t) align 4 %agg.result)
  %week_day = getelementptr inbounds %struct.date_t, %struct.date_t* %agg.result, i32 0, i32 3
  store i32 %call, i32* %week_day, align 4
  ret void
}

; Function Attrs: noinline nounwind optnone
define hidden i32 @week_day(%struct.date_t* byval(%struct.date_t) align 4 %date) #0 {
entry:
  %year = alloca i32, align 4
  %month = alloca i32, align 4
  %month_day = alloca i32, align 4
  %c = alloca i32, align 4
  %year1 = getelementptr inbounds %struct.date_t, %struct.date_t* %date, i32 0, i32 0
  %0 = load i32, i32* %year1, align 4
  store i32 %0, i32* %year, align 4
  %month2 = getelementptr inbounds %struct.date_t, %struct.date_t* %date, i32 0, i32 1
  %1 = load i32, i32* %month2, align 4
  store i32 %1, i32* %month, align 4
  %month_day3 = getelementptr inbounds %struct.date_t, %struct.date_t* %date, i32 0, i32 2
  %2 = load i32, i32* %month_day3, align 4
  store i32 %2, i32* %month_day, align 4
  %3 = load i32, i32* %month, align 4
  %cmp = icmp sle i32 %3, 2
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %4 = load i32, i32* %month, align 4
  %add = add nsw i32 %4, 12
  store i32 %add, i32* %month, align 4
  %5 = load i32, i32* %year, align 4
  %sub = sub nsw i32 %5, 1
  store i32 %sub, i32* %year, align 4
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  %6 = load i32, i32* %year, align 4
  %div = sdiv i32 %6, 100
  store i32 %div, i32* %c, align 4
  %7 = load i32, i32* %year, align 4
  %rem = srem i32 %7, 100
  store i32 %rem, i32* %year, align 4
  %8 = load i32, i32* %month_day, align 4
  %9 = load i32, i32* %month, align 4
  %add4 = add nsw i32 %9, 1
  %mul = mul nsw i32 %add4, 26
  %div5 = sdiv i32 %mul, 10
  %add6 = add nsw i32 %8, %div5
  %10 = load i32, i32* %year, align 4
  %add7 = add nsw i32 %add6, %10
  %11 = load i32, i32* %year, align 4
  %div8 = sdiv i32 %11, 4
  %add9 = add nsw i32 %add7, %div8
  %12 = load i32, i32* %c, align 4
  %div10 = sdiv i32 %12, 4
  %add11 = add nsw i32 %add9, %div10
  %13 = load i32, i32* %c, align 4
  %mul12 = mul nsw i32 2, %13
  %sub13 = sub nsw i32 %add11, %mul12
  %rem14 = srem i32 %sub13, 7
  %add15 = add nsw i32 %rem14, 7
  %rem16 = srem i32 %add15, 7
  %add17 = add nsw i32 1, %rem16
  ret i32 %add17
}

; Function Attrs: noinline nounwind optnone
define hidden void @easter_related_init(%struct.easter_related_t* noalias sret align 4 %agg.result, i32 %year) #0 {
entry:
  %year.addr = alloca i32, align 4
  %date = alloca %struct.date_t, align 4
  %tmp = alloca %struct.date_t, align 4
  %tmp1 = alloca %struct.date_t, align 4
  %tmp2 = alloca %struct.date_t, align 4
  %tmp3 = alloca %struct.date_t, align 4
  %tmp4 = alloca %struct.date_t, align 4
  store i32 %year, i32* %year.addr, align 4
  %easter = getelementptr inbounds %struct.easter_related_t, %struct.easter_related_t* %agg.result, i32 0, i32 0
  %0 = load i32, i32* %year.addr, align 4
  call void @easter(%struct.date_t* sret align 4 %tmp, i32 %0)
  %1 = bitcast %struct.date_t* %date to i8*
  %2 = bitcast %struct.date_t* %tmp to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 4 %1, i8* align 4 %2, i32 16, i1 false)
  %3 = bitcast %struct.date_t* %easter to i8*
  %4 = bitcast %struct.date_t* %date to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 4 %3, i8* align 4 %4, i32 16, i1 false)
  %ascension = getelementptr inbounds %struct.easter_related_t, %struct.easter_related_t* %agg.result, i32 0, i32 1
  call void @plusab(%struct.date_t* sret align 4 %tmp1, %struct.date_t* %date, i32 39)
  %5 = bitcast %struct.date_t* %ascension to i8*
  %6 = bitcast %struct.date_t* %tmp1 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 4 %5, i8* align 4 %6, i32 16, i1 false)
  %pentecost = getelementptr inbounds %struct.easter_related_t, %struct.easter_related_t* %agg.result, i32 0, i32 2
  call void @plusab(%struct.date_t* sret align 4 %tmp2, %struct.date_t* %date, i32 10)
  %7 = bitcast %struct.date_t* %pentecost to i8*
  %8 = bitcast %struct.date_t* %tmp2 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 4 %7, i8* align 4 %8, i32 16, i1 false)
  %trinity = getelementptr inbounds %struct.easter_related_t, %struct.easter_related_t* %agg.result, i32 0, i32 3
  call void @plusab(%struct.date_t* sret align 4 %tmp3, %struct.date_t* %date, i32 7)
  %9 = bitcast %struct.date_t* %trinity to i8*
  %10 = bitcast %struct.date_t* %tmp3 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 4 %9, i8* align 4 %10, i32 16, i1 false)
  %corpus_christi = getelementptr inbounds %struct.easter_related_t, %struct.easter_related_t* %agg.result, i32 0, i32 4
  call void @plusab(%struct.date_t* sret align 4 %tmp4, %struct.date_t* %date, i32 4)
  %11 = bitcast %struct.date_t* %corpus_christi to i8*
  %12 = bitcast %struct.date_t* %tmp4 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 4 %11, i8* align 4 %12, i32 16, i1 false)
  ret void
}

; Function Attrs: noinline nounwind optnone
define hidden void @easter_related_print(i32 %year) #0 {
entry:
  %year.addr = alloca i32, align 4
  %holidays = alloca %struct.easter_related_t, align 4
  store i32 %year, i32* %year.addr, align 4
  %0 = load i32, i32* %year.addr, align 4
  call void @easter_related_init(%struct.easter_related_t* sret align 4 %holidays, i32 %0)
  %1 = load i32, i32* %year.addr, align 4
  %easter = getelementptr inbounds %struct.easter_related_t, %struct.easter_related_t* %holidays, i32 0, i32 0
  %week_day = getelementptr inbounds %struct.date_t, %struct.date_t* %easter, i32 0, i32 3
  %2 = load i32, i32* %week_day, align 4
  %arrayidx = getelementptr inbounds [8 x i8*], [8 x i8*]* @week_day_fmt, i32 0, i32 %2
  %3 = load i8*, i8** %arrayidx, align 4
  %easter1 = getelementptr inbounds %struct.easter_related_t, %struct.easter_related_t* %holidays, i32 0, i32 0
  %month_day = getelementptr inbounds %struct.date_t, %struct.date_t* %easter1, i32 0, i32 2
  %4 = load i32, i32* %month_day, align 4
  %easter2 = getelementptr inbounds %struct.easter_related_t, %struct.easter_related_t* %holidays, i32 0, i32 0
  %month = getelementptr inbounds %struct.date_t, %struct.date_t* %easter2, i32 0, i32 1
  %5 = load i32, i32* %month, align 4
  %arrayidx3 = getelementptr inbounds [13 x i8*], [13 x i8*]* @mon_fmt, i32 0, i32 %5
  %6 = load i8*, i8** %arrayidx3, align 4
  %ascension = getelementptr inbounds %struct.easter_related_t, %struct.easter_related_t* %holidays, i32 0, i32 1
  %week_day4 = getelementptr inbounds %struct.date_t, %struct.date_t* %ascension, i32 0, i32 3
  %7 = load i32, i32* %week_day4, align 4
  %arrayidx5 = getelementptr inbounds [8 x i8*], [8 x i8*]* @week_day_fmt, i32 0, i32 %7
  %8 = load i8*, i8** %arrayidx5, align 4
  %ascension6 = getelementptr inbounds %struct.easter_related_t, %struct.easter_related_t* %holidays, i32 0, i32 1
  %month_day7 = getelementptr inbounds %struct.date_t, %struct.date_t* %ascension6, i32 0, i32 2
  %9 = load i32, i32* %month_day7, align 4
  %ascension8 = getelementptr inbounds %struct.easter_related_t, %struct.easter_related_t* %holidays, i32 0, i32 1
  %month9 = getelementptr inbounds %struct.date_t, %struct.date_t* %ascension8, i32 0, i32 1
  %10 = load i32, i32* %month9, align 4
  %arrayidx10 = getelementptr inbounds [13 x i8*], [13 x i8*]* @mon_fmt, i32 0, i32 %10
  %11 = load i8*, i8** %arrayidx10, align 4
  %pentecost = getelementptr inbounds %struct.easter_related_t, %struct.easter_related_t* %holidays, i32 0, i32 2
  %week_day11 = getelementptr inbounds %struct.date_t, %struct.date_t* %pentecost, i32 0, i32 3
  %12 = load i32, i32* %week_day11, align 4
  %arrayidx12 = getelementptr inbounds [8 x i8*], [8 x i8*]* @week_day_fmt, i32 0, i32 %12
  %13 = load i8*, i8** %arrayidx12, align 4
  %pentecost13 = getelementptr inbounds %struct.easter_related_t, %struct.easter_related_t* %holidays, i32 0, i32 2
  %month_day14 = getelementptr inbounds %struct.date_t, %struct.date_t* %pentecost13, i32 0, i32 2
  %14 = load i32, i32* %month_day14, align 4
  %pentecost15 = getelementptr inbounds %struct.easter_related_t, %struct.easter_related_t* %holidays, i32 0, i32 2
  %month16 = getelementptr inbounds %struct.date_t, %struct.date_t* %pentecost15, i32 0, i32 1
  %15 = load i32, i32* %month16, align 4
  %arrayidx17 = getelementptr inbounds [13 x i8*], [13 x i8*]* @mon_fmt, i32 0, i32 %15
  %16 = load i8*, i8** %arrayidx17, align 4
  %trinity = getelementptr inbounds %struct.easter_related_t, %struct.easter_related_t* %holidays, i32 0, i32 3
  %week_day18 = getelementptr inbounds %struct.date_t, %struct.date_t* %trinity, i32 0, i32 3
  %17 = load i32, i32* %week_day18, align 4
  %arrayidx19 = getelementptr inbounds [8 x i8*], [8 x i8*]* @week_day_fmt, i32 0, i32 %17
  %18 = load i8*, i8** %arrayidx19, align 4
  %trinity20 = getelementptr inbounds %struct.easter_related_t, %struct.easter_related_t* %holidays, i32 0, i32 3
  %month_day21 = getelementptr inbounds %struct.date_t, %struct.date_t* %trinity20, i32 0, i32 2
  %19 = load i32, i32* %month_day21, align 4
  %trinity22 = getelementptr inbounds %struct.easter_related_t, %struct.easter_related_t* %holidays, i32 0, i32 3
  %month23 = getelementptr inbounds %struct.date_t, %struct.date_t* %trinity22, i32 0, i32 1
  %20 = load i32, i32* %month23, align 4
  %arrayidx24 = getelementptr inbounds [13 x i8*], [13 x i8*]* @mon_fmt, i32 0, i32 %20
  %21 = load i8*, i8** %arrayidx24, align 4
  %corpus_christi = getelementptr inbounds %struct.easter_related_t, %struct.easter_related_t* %holidays, i32 0, i32 4
  %week_day25 = getelementptr inbounds %struct.date_t, %struct.date_t* %corpus_christi, i32 0, i32 3
  %22 = load i32, i32* %week_day25, align 4
  %arrayidx26 = getelementptr inbounds [8 x i8*], [8 x i8*]* @week_day_fmt, i32 0, i32 %22
  %23 = load i8*, i8** %arrayidx26, align 4
  %corpus_christi27 = getelementptr inbounds %struct.easter_related_t, %struct.easter_related_t* %holidays, i32 0, i32 4
  %month_day28 = getelementptr inbounds %struct.date_t, %struct.date_t* %corpus_christi27, i32 0, i32 2
  %24 = load i32, i32* %month_day28, align 4
  %corpus_christi29 = getelementptr inbounds %struct.easter_related_t, %struct.easter_related_t* %holidays, i32 0, i32 4
  %month30 = getelementptr inbounds %struct.date_t, %struct.date_t* %corpus_christi29, i32 0, i32 1
  %25 = load i32, i32* %month30, align 4
  %arrayidx31 = getelementptr inbounds [13 x i8*], [13 x i8*]* @mon_fmt, i32 0, i32 %25
  %26 = load i8*, i8** %arrayidx31, align 4
  %call = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([106 x i8], [106 x i8]* @.str.19, i32 0, i32 0), i32 %1, i8* %3, i32 %4, i8* %6, i8* %8, i32 %9, i8* %11, i8* %13, i32 %14, i8* %16, i8* %18, i32 %19, i8* %21, i8* %23, i32 %24, i8* %26)
  ret void
}

declare i32 @printf(i8* %0, ...) #2

; Function Attrs: noinline nounwind optnone
define hidden i32 @main() #0 {
entry:
  %retval = alloca i32, align 4
  %year = alloca i32, align 4
  store i32 0, i32* %retval, align 4
  %call = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([81 x i8], [81 x i8]* @.str.20, i32 0, i32 0))
  store i32 400, i32* %year, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %0 = load i32, i32* %year, align 4
  %cmp = icmp sle i32 %0, 2100
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %1 = load i32, i32* %year, align 4
  call void @easter_related_print(i32 %1)
  br label %for.inc

for.inc:                                          ; preds = %for.body
  %2 = load i32, i32* %year, align 4
  %add = add nsw i32 %2, 100
  store i32 %add, i32* %year, align 4
  br label %for.cond

for.end:                                          ; preds = %for.cond
  %call1 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([73 x i8], [73 x i8]* @.str.21, i32 0, i32 0))
  store i32 2010, i32* %year, align 4
  br label %for.cond2

for.cond2:                                        ; preds = %for.inc5, %for.end
  %3 = load i32, i32* %year, align 4
  %cmp3 = icmp sle i32 %3, 2020
  br i1 %cmp3, label %for.body4, label %for.end6

for.body4:                                        ; preds = %for.cond2
  %4 = load i32, i32* %year, align 4
  call void @easter_related_print(i32 %4)
  br label %for.inc5

for.inc5:                                         ; preds = %for.body4
  %5 = load i32, i32* %year, align 4
  %inc = add nsw i32 %5, 1
  store i32 %inc, i32* %year, align 4
  br label %for.cond2

for.end6:                                         ; preds = %for.cond2
  ret i32 0
}

attributes #0 = { noinline nounwind optnone "correctly-rounded-divide-sqrt-fp-math"="false" "disable-tail-calls"="false" "frame-pointer"="none" "less-precise-fpmad"="false" "min-legal-vector-width"="0" "no-infs-fp-math"="false" "no-jump-tables"="false" "no-nans-fp-math"="false" "no-signed-zeros-fp-math"="false" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="generic" "unsafe-fp-math"="false" "use-soft-float"="false" }
attributes #1 = { argmemonly nounwind willreturn }
attributes #2 = { "correctly-rounded-divide-sqrt-fp-math"="false" "disable-tail-calls"="false" "frame-pointer"="none" "less-precise-fpmad"="false" "no-infs-fp-math"="false" "no-nans-fp-math"="false" "no-signed-zeros-fp-math"="false" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="generic" "unsafe-fp-math"="false" "use-soft-float"="false" }

!llvm.module.flags = !{!0}
!llvm.ident = !{!1}

!0 = !{i32 1, !"wchar_size", i32 4}
!1 = !{!"clang version 11.0.0 (https://github.com/Jacarte/llvm-project.git 0f6dea67136cc1e0b3d200eb2bb165628970c44b)"}

; extracted candidates

; *****
; For LLVM instruction:
;  %0 = load i32, i32* %year.addr, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %1 = load i32, i32* %year.addr, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %2 = load i32, i32* %week_day, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %4 = load i32, i32* %month_day, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %5 = load i32, i32* %month, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %7 = load i32, i32* %week_day4, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %9 = load i32, i32* %month_day7, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %10 = load i32, i32* %month9, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %12 = load i32, i32* %week_day11, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %14 = load i32, i32* %month_day14, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %15 = load i32, i32* %month16, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %17 = load i32, i32* %week_day18, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %19 = load i32, i32* %month_day21, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %20 = load i32, i32* %month23, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %22 = load i32, i32* %week_day25, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %24 = load i32, i32* %month_day28, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %25 = load i32, i32* %month30, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0
#########################################################
; exiting Souper's runOnFunction() for easter_related_print()

; entering Souper's runOnFunction() for main()

; ModuleID = './Holidays_related_to_Easter.c.bc'
source_filename = "./Holidays_related_to_Easter.c"
target datalayout = "e-m:e-p:32:32-i64:64-n32:64-S128"
target triple = "wasm32-unknown-wasi"

%struct.date_t = type { i32, i32, i32, i32 }
%struct.easter_related_t = type { %struct.date_t, %struct.date_t, %struct.date_t, %struct.date_t, %struct.date_t }

@.str = private unnamed_addr constant [4 x i8] c"Jan\00", align 1
@.str.1 = private unnamed_addr constant [4 x i8] c"Feb\00", align 1
@.str.2 = private unnamed_addr constant [4 x i8] c"Mar\00", align 1
@.str.3 = private unnamed_addr constant [4 x i8] c"Apr\00", align 1
@.str.4 = private unnamed_addr constant [4 x i8] c"May\00", align 1
@.str.5 = private unnamed_addr constant [4 x i8] c"Jun\00", align 1
@.str.6 = private unnamed_addr constant [4 x i8] c"Jul\00", align 1
@.str.7 = private unnamed_addr constant [4 x i8] c"Aug\00", align 1
@.str.8 = private unnamed_addr constant [4 x i8] c"Sep\00", align 1
@.str.9 = private unnamed_addr constant [4 x i8] c"Oct\00", align 1
@.str.10 = private unnamed_addr constant [4 x i8] c"Nov\00", align 1
@.str.11 = private unnamed_addr constant [4 x i8] c"Dec\00", align 1
@mon_fmt = hidden global [13 x i8*] [i8* null, i8* getelementptr inbounds ([4 x i8], [4 x i8]* @.str, i32 0, i32 0), i8* getelementptr inbounds ([4 x i8], [4 x i8]* @.str.1, i32 0, i32 0), i8* getelementptr inbounds ([4 x i8], [4 x i8]* @.str.2, i32 0, i32 0), i8* getelementptr inbounds ([4 x i8], [4 x i8]* @.str.3, i32 0, i32 0), i8* getelementptr inbounds ([4 x i8], [4 x i8]* @.str.4, i32 0, i32 0), i8* getelementptr inbounds ([4 x i8], [4 x i8]* @.str.5, i32 0, i32 0), i8* getelementptr inbounds ([4 x i8], [4 x i8]* @.str.6, i32 0, i32 0), i8* getelementptr inbounds ([4 x i8], [4 x i8]* @.str.7, i32 0, i32 0), i8* getelementptr inbounds ([4 x i8], [4 x i8]* @.str.8, i32 0, i32 0), i8* getelementptr inbounds ([4 x i8], [4 x i8]* @.str.9, i32 0, i32 0), i8* getelementptr inbounds ([4 x i8], [4 x i8]* @.str.10, i32 0, i32 0), i8* getelementptr inbounds ([4 x i8], [4 x i8]* @.str.11, i32 0, i32 0)], align 16
@.str.12 = private unnamed_addr constant [4 x i8] c"Sat\00", align 1
@.str.13 = private unnamed_addr constant [4 x i8] c"Sun\00", align 1
@.str.14 = private unnamed_addr constant [4 x i8] c"Mon\00", align 1
@.str.15 = private unnamed_addr constant [4 x i8] c"Tue\00", align 1
@.str.16 = private unnamed_addr constant [4 x i8] c"Wed\00", align 1
@.str.17 = private unnamed_addr constant [4 x i8] c"Thu\00", align 1
@.str.18 = private unnamed_addr constant [4 x i8] c"Fri\00", align 1
@week_day_fmt = hidden global [8 x i8*] [i8* null, i8* getelementptr inbounds ([4 x i8], [4 x i8]* @.str.12, i32 0, i32 0), i8* getelementptr inbounds ([4 x i8], [4 x i8]* @.str.13, i32 0, i32 0), i8* getelementptr inbounds ([4 x i8], [4 x i8]* @.str.14, i32 0, i32 0), i8* getelementptr inbounds ([4 x i8], [4 x i8]* @.str.15, i32 0, i32 0), i8* getelementptr inbounds ([4 x i8], [4 x i8]* @.str.16, i32 0, i32 0), i8* getelementptr inbounds ([4 x i8], [4 x i8]* @.str.17, i32 0, i32 0), i8* getelementptr inbounds ([4 x i8], [4 x i8]* @.str.18, i32 0, i32 0)], align 16
@__const.month_days.days = private unnamed_addr constant [13 x i32] [i32 0, i32 31, i32 28, i32 31, i32 30, i32 31, i32 30, i32 31, i32 31, i32 30, i32 31, i32 30, i32 31], align 16
@year_months = hidden global i32 12, align 4
@week_days = hidden global i32 7, align 4
@.str.19 = private unnamed_addr constant [106 x i8] c"%4d Easter: %s %2d %s, Ascension: %s %2d %s, Pentecost: %s %2d %s, Trinity: %s %2d %s, Corpus: %s %2d %s\0A\00", align 1
@.str.20 = private unnamed_addr constant [81 x i8] c"Christian holidays, related to Easter, for each centennial from 400 to 2100 CE:\0A\00", align 1
@.str.21 = private unnamed_addr constant [73 x i8] c"\0AChristian holidays, related to Easter, for years from 2010 to 2020 CE:\0A\00", align 1
@llvm.used = appending global [1 x i8*] [i8* bitcast (i32 ()* @__main_void to i8*)], section "llvm.metadata"

@__main_void = alias i32 (), i32 ()* @main

; Function Attrs: noinline nounwind optnone
define hidden i32 @month_days(i32 %year, i32 %month) #0 {
entry:
  %year.addr = alloca i32, align 4
  %month.addr = alloca i32, align 4
  %days = alloca [13 x i32], align 16
  store i32 %year, i32* %year.addr, align 4
  store i32 %month, i32* %month.addr, align 4
  %0 = bitcast [13 x i32]* %days to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 16 %0, i8* align 16 bitcast ([13 x i32]* @__const.month_days.days to i8*), i32 52, i1 false)
  %1 = load i32, i32* %month.addr, align 4
  %cmp = icmp eq i32 %1, 2
  br i1 %cmp, label %cond.true, label %cond.false

cond.true:                                        ; preds = %entry
  %2 = load i32, i32* %year.addr, align 4
  %rem = srem i32 %2, 4
  %cmp1 = icmp eq i32 %rem, 0
  br i1 %cmp1, label %land.lhs.true, label %lor.rhs

land.lhs.true:                                    ; preds = %cond.true
  %3 = load i32, i32* %year.addr, align 4
  %rem2 = srem i32 %3, 100
  %cmp3 = icmp ne i32 %rem2, 0
  br i1 %cmp3, label %lor.end, label %lor.rhs

lor.rhs:                                          ; preds = %land.lhs.true, %cond.true
  %4 = load i32, i32* %year.addr, align 4
  %rem4 = srem i32 %4, 400
  %cmp5 = icmp eq i32 %rem4, 0
  br label %lor.end

lor.end:                                          ; preds = %lor.rhs, %land.lhs.true
  %5 = phi i1 [ true, %land.lhs.true ], [ %cmp5, %lor.rhs ]
  %lor.ext = zext i1 %5 to i32
  %add = add nsw i32 28, %lor.ext
  br label %cond.end

cond.false:                                       ; preds = %entry
  %6 = load i32, i32* %month.addr, align 4
  %arrayidx = getelementptr inbounds [13 x i32], [13 x i32]* %days, i32 0, i32 %6
  %7 = load i32, i32* %arrayidx, align 4
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %lor.end
  %cond = phi i32 [ %add, %lor.end ], [ %7, %cond.false ]
  ret i32 %cond
}

; Function Attrs: argmemonly nounwind willreturn
declare void @llvm.memcpy.p0i8.p0i8.i32(i8* noalias nocapture writeonly %0, i8* noalias nocapture readonly %1, i32 %2, i1 immarg %3) #1

; Function Attrs: noinline nounwind optnone
define hidden i32 @year_days(i32 %year) #0 {
entry:
  %year.addr = alloca i32, align 4
  store i32 %year, i32* %year.addr, align 4
  %0 = load i32, i32* %year.addr, align 4
  %call = call i32 @month_days(i32 %0, i32 2)
  %cmp = icmp eq i32 %call, 28
  %1 = zext i1 %cmp to i64
  %cond = select i1 %cmp, i32 365, i32 366
  ret i32 %cond
}

; Function Attrs: noinline nounwind optnone
define hidden void @plusab(%struct.date_t* noalias sret align 4 %agg.result, %struct.date_t* %date, i32 %days) #0 {
entry:
  %date.addr = alloca %struct.date_t*, align 4
  %days.addr = alloca i32, align 4
  store %struct.date_t* %date, %struct.date_t** %date.addr, align 4
  store i32 %days, i32* %days.addr, align 4
  br label %while.cond

while.cond:                                       ; preds = %while.body, %entry
  %0 = load i32, i32* %days.addr, align 4
  %cmp = icmp slt i32 %0, 0
  br i1 %cmp, label %while.body, label %while.end

while.body:                                       ; preds = %while.cond
  %1 = load %struct.date_t*, %struct.date_t** %date.addr, align 4
  %year = getelementptr inbounds %struct.date_t, %struct.date_t* %1, i32 0, i32 0
  %2 = load i32, i32* %year, align 4
  %sub = sub nsw i32 %2, 1
  store i32 %sub, i32* %year, align 4
  %3 = load %struct.date_t*, %struct.date_t** %date.addr, align 4
  %year1 = getelementptr inbounds %struct.date_t, %struct.date_t* %3, i32 0, i32 0
  %4 = load i32, i32* %year1, align 4
  %call = call i32 @year_days(i32 %4)
  %5 = load i32, i32* %days.addr, align 4
  %add = add nsw i32 %5, %call
  store i32 %add, i32* %days.addr, align 4
  br label %while.cond

while.end:                                        ; preds = %while.cond
  br label %while.cond2

while.cond2:                                      ; preds = %while.body6, %while.end
  %6 = load i32, i32* %days.addr, align 4
  %7 = load %struct.date_t*, %struct.date_t** %date.addr, align 4
  %year3 = getelementptr inbounds %struct.date_t, %struct.date_t* %7, i32 0, i32 0
  %8 = load i32, i32* %year3, align 4
  %call4 = call i32 @year_days(i32 %8)
  %cmp5 = icmp sgt i32 %6, %call4
  br i1 %cmp5, label %while.body6, label %while.end12

while.body6:                                      ; preds = %while.cond2
  %9 = load %struct.date_t*, %struct.date_t** %date.addr, align 4
  %year7 = getelementptr inbounds %struct.date_t, %struct.date_t* %9, i32 0, i32 0
  %10 = load i32, i32* %year7, align 4
  %call8 = call i32 @year_days(i32 %10)
  %11 = load i32, i32* %days.addr, align 4
  %sub9 = sub nsw i32 %11, %call8
  store i32 %sub9, i32* %days.addr, align 4
  %12 = load %struct.date_t*, %struct.date_t** %date.addr, align 4
  %year10 = getelementptr inbounds %struct.date_t, %struct.date_t* %12, i32 0, i32 0
  %13 = load i32, i32* %year10, align 4
  %add11 = add nsw i32 %13, 1
  store i32 %add11, i32* %year10, align 4
  br label %while.cond2

while.end12:                                      ; preds = %while.cond2
  %14 = load i32, i32* %days.addr, align 4
  %15 = load %struct.date_t*, %struct.date_t** %date.addr, align 4
  %month_day = getelementptr inbounds %struct.date_t, %struct.date_t* %15, i32 0, i32 2
  %16 = load i32, i32* %month_day, align 4
  %add13 = add nsw i32 %16, %14
  store i32 %add13, i32* %month_day, align 4
  br label %while.cond14

while.cond14:                                     ; preds = %if.end, %while.end12
  %17 = load %struct.date_t*, %struct.date_t** %date.addr, align 4
  %month_day15 = getelementptr inbounds %struct.date_t, %struct.date_t* %17, i32 0, i32 2
  %18 = load i32, i32* %month_day15, align 4
  %19 = load %struct.date_t*, %struct.date_t** %date.addr, align 4
  %year16 = getelementptr inbounds %struct.date_t, %struct.date_t* %19, i32 0, i32 0
  %20 = load i32, i32* %year16, align 4
  %21 = load %struct.date_t*, %struct.date_t** %date.addr, align 4
  %month = getelementptr inbounds %struct.date_t, %struct.date_t* %21, i32 0, i32 1
  %22 = load i32, i32* %month, align 4
  %call17 = call i32 @month_days(i32 %20, i32 %22)
  %cmp18 = icmp sgt i32 %18, %call17
  br i1 %cmp18, label %while.body19, label %while.end33

while.body19:                                     ; preds = %while.cond14
  %23 = load %struct.date_t*, %struct.date_t** %date.addr, align 4
  %year20 = getelementptr inbounds %struct.date_t, %struct.date_t* %23, i32 0, i32 0
  %24 = load i32, i32* %year20, align 4
  %25 = load %struct.date_t*, %struct.date_t** %date.addr, align 4
  %month21 = getelementptr inbounds %struct.date_t, %struct.date_t* %25, i32 0, i32 1
  %26 = load i32, i32* %month21, align 4
  %call22 = call i32 @month_days(i32 %24, i32 %26)
  %27 = load %struct.date_t*, %struct.date_t** %date.addr, align 4
  %month_day23 = getelementptr inbounds %struct.date_t, %struct.date_t* %27, i32 0, i32 2
  %28 = load i32, i32* %month_day23, align 4
  %sub24 = sub nsw i32 %28, %call22
  store i32 %sub24, i32* %month_day23, align 4
  %29 = load %struct.date_t*, %struct.date_t** %date.addr, align 4
  %month25 = getelementptr inbounds %struct.date_t, %struct.date_t* %29, i32 0, i32 1
  %30 = load i32, i32* %month25, align 4
  %add26 = add nsw i32 %30, 1
  store i32 %add26, i32* %month25, align 4
  %31 = load %struct.date_t*, %struct.date_t** %date.addr, align 4
  %month27 = getelementptr inbounds %struct.date_t, %struct.date_t* %31, i32 0, i32 1
  %32 = load i32, i32* %month27, align 4
  %33 = load i32, i32* @year_months, align 4
  %cmp28 = icmp sgt i32 %32, %33
  br i1 %cmp28, label %if.then, label %if.end

if.then:                                          ; preds = %while.body19
  %34 = load i32, i32* @year_months, align 4
  %35 = load %struct.date_t*, %struct.date_t** %date.addr, align 4
  %month29 = getelementptr inbounds %struct.date_t, %struct.date_t* %35, i32 0, i32 1
  %36 = load i32, i32* %month29, align 4
  %sub30 = sub nsw i32 %36, %34
  store i32 %sub30, i32* %month29, align 4
  %37 = load %struct.date_t*, %struct.date_t** %date.addr, align 4
  %year31 = getelementptr inbounds %struct.date_t, %struct.date_t* %37, i32 0, i32 0
  %38 = load i32, i32* %year31, align 4
  %add32 = add nsw i32 %38, 1
  store i32 %add32, i32* %year31, align 4
  br label %if.end

if.end:                                           ; preds = %if.then, %while.body19
  br label %while.cond14

while.end33:                                      ; preds = %while.cond14
  %39 = load %struct.date_t*, %struct.date_t** %date.addr, align 4
  %call34 = call i32 @week_day(%struct.date_t* byval(%struct.date_t) align 4 %39)
  %40 = load %struct.date_t*, %struct.date_t** %date.addr, align 4
  %week_day = getelementptr inbounds %struct.date_t, %struct.date_t* %40, i32 0, i32 3
  store i32 %call34, i32* %week_day, align 4
  %41 = load %struct.date_t*, %struct.date_t** %date.addr, align 4
  %42 = bitcast %struct.date_t* %agg.result to i8*
  %43 = bitcast %struct.date_t* %41 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 4 %42, i8* align 4 %43, i32 16, i1 false)
  ret void
}

; Function Attrs: noinline nounwind optnone
define hidden void @easter(%struct.date_t* noalias sret align 4 %agg.result, i32 %year) #0 {
entry:
  %year.addr = alloca i32, align 4
  %c = alloca i32, align 4
  %n = alloca i32, align 4
  %i = alloca i32, align 4
  %l = alloca i32, align 4
  store i32 %year, i32* %year.addr, align 4
  %0 = load i32, i32* %year.addr, align 4
  %year1 = getelementptr inbounds %struct.date_t, %struct.date_t* %agg.result, i32 0, i32 0
  store i32 %0, i32* %year1, align 4
  %1 = load i32, i32* %year.addr, align 4
  %div = sdiv i32 %1, 100
  store i32 %div, i32* %c, align 4
  %2 = load i32, i32* %year.addr, align 4
  %rem = srem i32 %2, 19
  store i32 %rem, i32* %n, align 4
  %3 = load i32, i32* %c, align 4
  %4 = load i32, i32* %c, align 4
  %div2 = sdiv i32 %4, 4
  %sub = sub nsw i32 %3, %div2
  %5 = load i32, i32* %c, align 4
  %6 = load i32, i32* %c, align 4
  %sub3 = sub nsw i32 %6, 17
  %div4 = sdiv i32 %sub3, 25
  %sub5 = sub nsw i32 %5, %div4
  %div6 = sdiv i32 %sub5, 3
  %sub7 = sub nsw i32 %sub, %div6
  %7 = load i32, i32* %n, align 4
  %mul = mul nsw i32 19, %7
  %add = add nsw i32 %sub7, %mul
  %add8 = add nsw i32 %add, 15
  %rem9 = srem i32 %add8, 30
  store i32 %rem9, i32* %i, align 4
  %8 = load i32, i32* %i, align 4
  %div10 = sdiv i32 %8, 28
  %9 = load i32, i32* %i, align 4
  %div11 = sdiv i32 %9, 28
  %10 = load i32, i32* %i, align 4
  %add12 = add nsw i32 %10, 1
  %div13 = sdiv i32 29, %add12
  %mul14 = mul nsw i32 %div11, %div13
  %11 = load i32, i32* %n, align 4
  %sub15 = sub nsw i32 21, %11
  %div16 = sdiv i32 %sub15, 11
  %mul17 = mul nsw i32 %mul14, %div16
  %sub18 = sub nsw i32 1, %mul17
  %mul19 = mul nsw i32 %div10, %sub18
  %12 = load i32, i32* %i, align 4
  %sub20 = sub nsw i32 %12, %mul19
  store i32 %sub20, i32* %i, align 4
  %13 = load i32, i32* %i, align 4
  %14 = load i32, i32* %year.addr, align 4
  %15 = load i32, i32* %year.addr, align 4
  %div21 = sdiv i32 %15, 4
  %add22 = add nsw i32 %14, %div21
  %16 = load i32, i32* %i, align 4
  %add23 = add nsw i32 %add22, %16
  %add24 = add nsw i32 %add23, 2
  %17 = load i32, i32* %c, align 4
  %sub25 = sub nsw i32 %add24, %17
  %18 = load i32, i32* %c, align 4
  %div26 = sdiv i32 %18, 4
  %add27 = add nsw i32 %sub25, %div26
  %rem28 = srem i32 %add27, 7
  %sub29 = sub nsw i32 %13, %rem28
  store i32 %sub29, i32* %l, align 4
  %19 = load i32, i32* %l, align 4
  %add30 = add nsw i32 %19, 40
  %div31 = sdiv i32 %add30, 44
  %add32 = add nsw i32 3, %div31
  %month = getelementptr inbounds %struct.date_t, %struct.date_t* %agg.result, i32 0, i32 1
  store i32 %add32, i32* %month, align 4
  %20 = load i32, i32* %l, align 4
  %add33 = add nsw i32 %20, 28
  %month34 = getelementptr inbounds %struct.date_t, %struct.date_t* %agg.result, i32 0, i32 1
  %21 = load i32, i32* %month34, align 4
  %div35 = sdiv i32 %21, 4
  %mul36 = mul nsw i32 31, %div35
  %sub37 = sub nsw i32 %add33, %mul36
  %month_day = getelementptr inbounds %struct.date_t, %struct.date_t* %agg.result, i32 0, i32 2
  store i32 %sub37, i32* %month_day, align 4
  %call = call i32 @week_day(%struct.date_t* byval(%struct.date_t) align 4 %agg.result)
  %week_day = getelementptr inbounds %struct.date_t, %struct.date_t* %agg.result, i32 0, i32 3
  store i32 %call, i32* %week_day, align 4
  ret void
}

; Function Attrs: noinline nounwind optnone
define hidden i32 @week_day(%struct.date_t* byval(%struct.date_t) align 4 %date) #0 {
entry:
  %year = alloca i32, align 4
  %month = alloca i32, align 4
  %month_day = alloca i32, align 4
  %c = alloca i32, align 4
  %year1 = getelementptr inbounds %struct.date_t, %struct.date_t* %date, i32 0, i32 0
  %0 = load i32, i32* %year1, align 4
  store i32 %0, i32* %year, align 4
  %month2 = getelementptr inbounds %struct.date_t, %struct.date_t* %date, i32 0, i32 1
  %1 = load i32, i32* %month2, align 4
  store i32 %1, i32* %month, align 4
  %month_day3 = getelementptr inbounds %struct.date_t, %struct.date_t* %date, i32 0, i32 2
  %2 = load i32, i32* %month_day3, align 4
  store i32 %2, i32* %month_day, align 4
  %3 = load i32, i32* %month, align 4
  %cmp = icmp sle i32 %3, 2
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %4 = load i32, i32* %month, align 4
  %add = add nsw i32 %4, 12
  store i32 %add, i32* %month, align 4
  %5 = load i32, i32* %year, align 4
  %sub = sub nsw i32 %5, 1
  store i32 %sub, i32* %year, align 4
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  %6 = load i32, i32* %year, align 4
  %div = sdiv i32 %6, 100
  store i32 %div, i32* %c, align 4
  %7 = load i32, i32* %year, align 4
  %rem = srem i32 %7, 100
  store i32 %rem, i32* %year, align 4
  %8 = load i32, i32* %month_day, align 4
  %9 = load i32, i32* %month, align 4
  %add4 = add nsw i32 %9, 1
  %mul = mul nsw i32 %add4, 26
  %div5 = sdiv i32 %mul, 10
  %add6 = add nsw i32 %8, %div5
  %10 = load i32, i32* %year, align 4
  %add7 = add nsw i32 %add6, %10
  %11 = load i32, i32* %year, align 4
  %div8 = sdiv i32 %11, 4
  %add9 = add nsw i32 %add7, %div8
  %12 = load i32, i32* %c, align 4
  %div10 = sdiv i32 %12, 4
  %add11 = add nsw i32 %add9, %div10
  %13 = load i32, i32* %c, align 4
  %mul12 = mul nsw i32 2, %13
  %sub13 = sub nsw i32 %add11, %mul12
  %rem14 = srem i32 %sub13, 7
  %add15 = add nsw i32 %rem14, 7
  %rem16 = srem i32 %add15, 7
  %add17 = add nsw i32 1, %rem16
  ret i32 %add17
}

; Function Attrs: noinline nounwind optnone
define hidden void @easter_related_init(%struct.easter_related_t* noalias sret align 4 %agg.result, i32 %year) #0 {
entry:
  %year.addr = alloca i32, align 4
  %date = alloca %struct.date_t, align 4
  %tmp = alloca %struct.date_t, align 4
  %tmp1 = alloca %struct.date_t, align 4
  %tmp2 = alloca %struct.date_t, align 4
  %tmp3 = alloca %struct.date_t, align 4
  %tmp4 = alloca %struct.date_t, align 4
  store i32 %year, i32* %year.addr, align 4
  %easter = getelementptr inbounds %struct.easter_related_t, %struct.easter_related_t* %agg.result, i32 0, i32 0
  %0 = load i32, i32* %year.addr, align 4
  call void @easter(%struct.date_t* sret align 4 %tmp, i32 %0)
  %1 = bitcast %struct.date_t* %date to i8*
  %2 = bitcast %struct.date_t* %tmp to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 4 %1, i8* align 4 %2, i32 16, i1 false)
  %3 = bitcast %struct.date_t* %easter to i8*
  %4 = bitcast %struct.date_t* %date to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 4 %3, i8* align 4 %4, i32 16, i1 false)
  %ascension = getelementptr inbounds %struct.easter_related_t, %struct.easter_related_t* %agg.result, i32 0, i32 1
  call void @plusab(%struct.date_t* sret align 4 %tmp1, %struct.date_t* %date, i32 39)
  %5 = bitcast %struct.date_t* %ascension to i8*
  %6 = bitcast %struct.date_t* %tmp1 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 4 %5, i8* align 4 %6, i32 16, i1 false)
  %pentecost = getelementptr inbounds %struct.easter_related_t, %struct.easter_related_t* %agg.result, i32 0, i32 2
  call void @plusab(%struct.date_t* sret align 4 %tmp2, %struct.date_t* %date, i32 10)
  %7 = bitcast %struct.date_t* %pentecost to i8*
  %8 = bitcast %struct.date_t* %tmp2 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 4 %7, i8* align 4 %8, i32 16, i1 false)
  %trinity = getelementptr inbounds %struct.easter_related_t, %struct.easter_related_t* %agg.result, i32 0, i32 3
  call void @plusab(%struct.date_t* sret align 4 %tmp3, %struct.date_t* %date, i32 7)
  %9 = bitcast %struct.date_t* %trinity to i8*
  %10 = bitcast %struct.date_t* %tmp3 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 4 %9, i8* align 4 %10, i32 16, i1 false)
  %corpus_christi = getelementptr inbounds %struct.easter_related_t, %struct.easter_related_t* %agg.result, i32 0, i32 4
  call void @plusab(%struct.date_t* sret align 4 %tmp4, %struct.date_t* %date, i32 4)
  %11 = bitcast %struct.date_t* %corpus_christi to i8*
  %12 = bitcast %struct.date_t* %tmp4 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 4 %11, i8* align 4 %12, i32 16, i1 false)
  ret void
}

; Function Attrs: noinline nounwind optnone
define hidden void @easter_related_print(i32 %year) #0 {
entry:
  %year.addr = alloca i32, align 4
  %holidays = alloca %struct.easter_related_t, align 4
  store i32 %year, i32* %year.addr, align 4
  %0 = load i32, i32* %year.addr, align 4
  call void @easter_related_init(%struct.easter_related_t* sret align 4 %holidays, i32 %0)
  %1 = load i32, i32* %year.addr, align 4
  %easter = getelementptr inbounds %struct.easter_related_t, %struct.easter_related_t* %holidays, i32 0, i32 0
  %week_day = getelementptr inbounds %struct.date_t, %struct.date_t* %easter, i32 0, i32 3
  %2 = load i32, i32* %week_day, align 4
  %arrayidx = getelementptr inbounds [8 x i8*], [8 x i8*]* @week_day_fmt, i32 0, i32 %2
  %3 = load i8*, i8** %arrayidx, align 4
  %easter1 = getelementptr inbounds %struct.easter_related_t, %struct.easter_related_t* %holidays, i32 0, i32 0
  %month_day = getelementptr inbounds %struct.date_t, %struct.date_t* %easter1, i32 0, i32 2
  %4 = load i32, i32* %month_day, align 4
  %easter2 = getelementptr inbounds %struct.easter_related_t, %struct.easter_related_t* %holidays, i32 0, i32 0
  %month = getelementptr inbounds %struct.date_t, %struct.date_t* %easter2, i32 0, i32 1
  %5 = load i32, i32* %month, align 4
  %arrayidx3 = getelementptr inbounds [13 x i8*], [13 x i8*]* @mon_fmt, i32 0, i32 %5
  %6 = load i8*, i8** %arrayidx3, align 4
  %ascension = getelementptr inbounds %struct.easter_related_t, %struct.easter_related_t* %holidays, i32 0, i32 1
  %week_day4 = getelementptr inbounds %struct.date_t, %struct.date_t* %ascension, i32 0, i32 3
  %7 = load i32, i32* %week_day4, align 4
  %arrayidx5 = getelementptr inbounds [8 x i8*], [8 x i8*]* @week_day_fmt, i32 0, i32 %7
  %8 = load i8*, i8** %arrayidx5, align 4
  %ascension6 = getelementptr inbounds %struct.easter_related_t, %struct.easter_related_t* %holidays, i32 0, i32 1
  %month_day7 = getelementptr inbounds %struct.date_t, %struct.date_t* %ascension6, i32 0, i32 2
  %9 = load i32, i32* %month_day7, align 4
  %ascension8 = getelementptr inbounds %struct.easter_related_t, %struct.easter_related_t* %holidays, i32 0, i32 1
  %month9 = getelementptr inbounds %struct.date_t, %struct.date_t* %ascension8, i32 0, i32 1
  %10 = load i32, i32* %month9, align 4
  %arrayidx10 = getelementptr inbounds [13 x i8*], [13 x i8*]* @mon_fmt, i32 0, i32 %10
  %11 = load i8*, i8** %arrayidx10, align 4
  %pentecost = getelementptr inbounds %struct.easter_related_t, %struct.easter_related_t* %holidays, i32 0, i32 2
  %week_day11 = getelementptr inbounds %struct.date_t, %struct.date_t* %pentecost, i32 0, i32 3
  %12 = load i32, i32* %week_day11, align 4
  %arrayidx12 = getelementptr inbounds [8 x i8*], [8 x i8*]* @week_day_fmt, i32 0, i32 %12
  %13 = load i8*, i8** %arrayidx12, align 4
  %pentecost13 = getelementptr inbounds %struct.easter_related_t, %struct.easter_related_t* %holidays, i32 0, i32 2
  %month_day14 = getelementptr inbounds %struct.date_t, %struct.date_t* %pentecost13, i32 0, i32 2
  %14 = load i32, i32* %month_day14, align 4
  %pentecost15 = getelementptr inbounds %struct.easter_related_t, %struct.easter_related_t* %holidays, i32 0, i32 2
  %month16 = getelementptr inbounds %struct.date_t, %struct.date_t* %pentecost15, i32 0, i32 1
  %15 = load i32, i32* %month16, align 4
  %arrayidx17 = getelementptr inbounds [13 x i8*], [13 x i8*]* @mon_fmt, i32 0, i32 %15
  %16 = load i8*, i8** %arrayidx17, align 4
  %trinity = getelementptr inbounds %struct.easter_related_t, %struct.easter_related_t* %holidays, i32 0, i32 3
  %week_day18 = getelementptr inbounds %struct.date_t, %struct.date_t* %trinity, i32 0, i32 3
  %17 = load i32, i32* %week_day18, align 4
  %arrayidx19 = getelementptr inbounds [8 x i8*], [8 x i8*]* @week_day_fmt, i32 0, i32 %17
  %18 = load i8*, i8** %arrayidx19, align 4
  %trinity20 = getelementptr inbounds %struct.easter_related_t, %struct.easter_related_t* %holidays, i32 0, i32 3
  %month_day21 = getelementptr inbounds %struct.date_t, %struct.date_t* %trinity20, i32 0, i32 2
  %19 = load i32, i32* %month_day21, align 4
  %trinity22 = getelementptr inbounds %struct.easter_related_t, %struct.easter_related_t* %holidays, i32 0, i32 3
  %month23 = getelementptr inbounds %struct.date_t, %struct.date_t* %trinity22, i32 0, i32 1
  %20 = load i32, i32* %month23, align 4
  %arrayidx24 = getelementptr inbounds [13 x i8*], [13 x i8*]* @mon_fmt, i32 0, i32 %20
  %21 = load i8*, i8** %arrayidx24, align 4
  %corpus_christi = getelementptr inbounds %struct.easter_related_t, %struct.easter_related_t* %holidays, i32 0, i32 4
  %week_day25 = getelementptr inbounds %struct.date_t, %struct.date_t* %corpus_christi, i32 0, i32 3
  %22 = load i32, i32* %week_day25, align 4
  %arrayidx26 = getelementptr inbounds [8 x i8*], [8 x i8*]* @week_day_fmt, i32 0, i32 %22
  %23 = load i8*, i8** %arrayidx26, align 4
  %corpus_christi27 = getelementptr inbounds %struct.easter_related_t, %struct.easter_related_t* %holidays, i32 0, i32 4
  %month_day28 = getelementptr inbounds %struct.date_t, %struct.date_t* %corpus_christi27, i32 0, i32 2
  %24 = load i32, i32* %month_day28, align 4
  %corpus_christi29 = getelementptr inbounds %struct.easter_related_t, %struct.easter_related_t* %holidays, i32 0, i32 4
  %month30 = getelementptr inbounds %struct.date_t, %struct.date_t* %corpus_christi29, i32 0, i32 1
  %25 = load i32, i32* %month30, align 4
  %arrayidx31 = getelementptr inbounds [13 x i8*], [13 x i8*]* @mon_fmt, i32 0, i32 %25
  %26 = load i8*, i8** %arrayidx31, align 4
  %call = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([106 x i8], [106 x i8]* @.str.19, i32 0, i32 0), i32 %1, i8* %3, i32 %4, i8* %6, i8* %8, i32 %9, i8* %11, i8* %13, i32 %14, i8* %16, i8* %18, i32 %19, i8* %21, i8* %23, i32 %24, i8* %26)
  ret void
}

declare i32 @printf(i8* %0, ...) #2

; Function Attrs: noinline nounwind optnone
define hidden i32 @main() #0 {
entry:
  %retval = alloca i32, align 4
  %year = alloca i32, align 4
  store i32 0, i32* %retval, align 4
  %call = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([81 x i8], [81 x i8]* @.str.20, i32 0, i32 0))
  store i32 400, i32* %year, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %0 = load i32, i32* %year, align 4
  %cmp = icmp sle i32 %0, 2100
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %1 = load i32, i32* %year, align 4
  call void @easter_related_print(i32 %1)
  br label %for.inc

for.inc:                                          ; preds = %for.body
  %2 = load i32, i32* %year, align 4
  %add = add nsw i32 %2, 100
  store i32 %add, i32* %year, align 4
  br label %for.cond

for.end:                                          ; preds = %for.cond
  %call1 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([73 x i8], [73 x i8]* @.str.21, i32 0, i32 0))
  store i32 2010, i32* %year, align 4
  br label %for.cond2

for.cond2:                                        ; preds = %for.inc5, %for.end
  %3 = load i32, i32* %year, align 4
  %cmp3 = icmp sle i32 %3, 2020
  br i1 %cmp3, label %for.body4, label %for.end6

for.body4:                                        ; preds = %for.cond2
  %4 = load i32, i32* %year, align 4
  call void @easter_related_print(i32 %4)
  br label %for.inc5

for.inc5:                                         ; preds = %for.body4
  %5 = load i32, i32* %year, align 4
  %inc = add nsw i32 %5, 1
  store i32 %inc, i32* %year, align 4
  br label %for.cond2

for.end6:                                         ; preds = %for.cond2
  ret i32 0
}

attributes #0 = { noinline nounwind optnone "correctly-rounded-divide-sqrt-fp-math"="false" "disable-tail-calls"="false" "frame-pointer"="none" "less-precise-fpmad"="false" "min-legal-vector-width"="0" "no-infs-fp-math"="false" "no-jump-tables"="false" "no-nans-fp-math"="false" "no-signed-zeros-fp-math"="false" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="generic" "unsafe-fp-math"="false" "use-soft-float"="false" }
attributes #1 = { argmemonly nounwind willreturn }
attributes #2 = { "correctly-rounded-divide-sqrt-fp-math"="false" "disable-tail-calls"="false" "frame-pointer"="none" "less-precise-fpmad"="false" "no-infs-fp-math"="false" "no-nans-fp-math"="false" "no-signed-zeros-fp-math"="false" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="generic" "unsafe-fp-math"="false" "use-soft-float"="false" }

!llvm.module.flags = !{!0}
!llvm.ident = !{!1}

!0 = !{i32 1, !"wchar_size", i32 4}
!1 = !{!"clang version 11.0.0 (https://github.com/Jacarte/llvm-project.git 0f6dea67136cc1e0b3d200eb2bb165628970c44b)"}

; extracted candidates

; *****
; For LLVM instruction:
;  %0 = load i32, i32* %year, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %cmp = icmp sle i32 %0, 2100
; Looking for a replacement for:
%0:i32 = var
%1:i1 = sle %0, 2100:i32
infer %1

; *****
; For LLVM instruction:
;  %1 = load i32, i32* %year, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %2 = load i32, i32* %year, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %add = add nsw i32 %2, 100
; Looking for a replacement for:
%0:i32 = var
%1:i32 = addnsw 100:i32, %0
infer %1

; *****
; For LLVM instruction:
;  %3 = load i32, i32* %year, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %cmp3 = icmp sle i32 %3, 2020
; Looking for a replacement for:
%0:i32 = var
%1:i1 = sle %0, 2020:i32
infer %1

; *****
; For LLVM instruction:
;  %4 = load i32, i32* %year, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %5 = load i32, i32* %year, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %inc = add nsw i32 %5, 1
; Looking for a replacement for:
%0:i32 = var
%1:i32 = addnsw 1:i32, %0
infer %1
got 2 candidates from LHS

-------------------------------------------------
%0:i32 = var
%1:i1 = sle %0, 2100:i32
infer %1


--------------------------------
guess 0

%0:i1 = var ; reservedconst_1

Cost = 0
first query is SAT, returning the model:
reservedconst_1: -1
0 th attempt: second query is SAT-- constant doesn't work
first query is SAT, returning the model:
reservedconst_1: 0
1 th attempt: second query is SAT-- constant doesn't work
first query is UNSAT-- no more guesses
Dataflow Pruned 0/0
There are 1 Guesses
There are 0 RHSs before deduplication
There are 0 RHSs after deduplication
got 2 candidates from LHS

-------------------------------------------------
%0:i32 = var
%1:i32 = addnsw 100:i32, %0
infer %1


--------------------------------
guess 0

%0:i32 = var ; reservedconst_1

Cost = 0
first query is SAT, returning the model:
reservedconst_1: 100
0 th attempt: second query is SAT-- constant doesn't work
first query is SAT, returning the model:
reservedconst_1: 101
1 th attempt: second query is SAT-- constant doesn't work
first query is UNSAT-- no more guesses

--------------------------------
guess 1

%0:i32 = var

Cost = 0
second query is SAT-- constant doesn't work
Dataflow Pruned 0/0
There are 2 Guesses
There are 0 RHSs before deduplication
There are 0 RHSs after deduplication
got 2 candidates from LHS

-------------------------------------------------
%0:i32 = var
%1:i1 = sle %0, 2020:i32
infer %1


--------------------------------
guess 0

%0:i1 = var ; reservedconst_1

Cost = 0
first query is SAT, returning the model:
reservedconst_1: -1
0 th attempt: second query is SAT-- constant doesn't work
first query is SAT, returning the model:
reservedconst_1: 0
1 th attempt: second query is SAT-- constant doesn't work
first query is UNSAT-- no more guesses
Dataflow Pruned 0/0
There are 1 Guesses
There are 0 RHSs before deduplication
There are 0 RHSs after deduplication
#########################################################
; exiting Souper's runOnFunction() for main()
Total of 0 replacements done on this module
Total of 0 replacements candidates on this module
