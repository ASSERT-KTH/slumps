
Entering the Souper pass's runOnModule()


; entering Souper's runOnFunction() for main()

; ModuleID = './Test_integerness.c.bc'
source_filename = "./Test_integerness.c"
target datalayout = "e-m:e-p:32:32-i64:64-n32:64-S128"
target triple = "wasm32-unknown-wasi"

@.str = private unnamed_addr constant [3 x i8] c"%d\00", align 1
@.str.1 = private unnamed_addr constant [7 x i8] c" = %s\0A\00", align 1
@.str.2 = private unnamed_addr constant [5 x i8] c"true\00", align 1
@.str.3 = private unnamed_addr constant [6 x i8] c"false\00", align 1
@.str.4 = private unnamed_addr constant [3 x i8] c"%f\00", align 1
@.str.5 = private unnamed_addr constant [4 x i8] c" + \00", align 1
@.str.6 = private unnamed_addr constant [8 x i8] c"i = %s\0A\00", align 1
@.str.7 = private unnamed_addr constant [19 x i8] c"Test 1 (5+i) = %s\0A\00", align 1
@.str.8 = private unnamed_addr constant [22 x i8] c"Test 2 (3.4+0i) = %s\0A\00", align 1
@.str.9 = private unnamed_addr constant [20 x i8] c"Test 3 (3+0i) = %s\0A\00", align 1
@.str.10 = private unnamed_addr constant [22 x i8] c"Test 4 (0+1.2i) = %s\0A\00", align 1
@llvm.used = appending global [1 x i8*] [i8* bitcast (i32 ()* @__main_void to i8*)], section "llvm.metadata"

@__main_void = alias i32 (), i32 ()* @main

; Function Attrs: noinline nounwind optnone
define hidden i32 @main() #0 {
entry:
  %retval = alloca i32, align 4
  %indirect-arg-temp = alloca { fp128, fp128 }, align 16
  %indirect-arg-temp4 = alloca { fp128, fp128 }, align 16
  %indirect-arg-temp10 = alloca { fp128, fp128 }, align 16
  %indirect-arg-temp16 = alloca { fp128, fp128 }, align 16
  %indirect-arg-temp22 = alloca { fp128, fp128 }, align 16
  %indirect-arg-temp28 = alloca { fp128, fp128 }, align 16
  %indirect-arg-temp34 = alloca { fp128, fp128 }, align 16
  %indirect-arg-temp40 = alloca { fp128, fp128 }, align 16
  %indirect-arg-temp46 = alloca { fp128, fp128 }, align 16
  %indirect-arg-temp52 = alloca { fp128, fp128 }, align 16
  %indirect-arg-temp60 = alloca { fp128, fp128 }, align 16
  %indirect-arg-temp68 = alloca { fp128, fp128 }, align 16
  %indirect-arg-temp76 = alloca { fp128, fp128 }, align 16
  %indirect-arg-temp84 = alloca { fp128, fp128 }, align 16
  %test1 = alloca { double, double }, align 8
  %tmp = alloca { float, float }, align 4
  %test2 = alloca { double, double }, align 8
  %test3 = alloca { double, double }, align 8
  %test4 = alloca { double, double }, align 8
  %indirect-arg-temp94 = alloca { fp128, fp128 }, align 16
  %indirect-arg-temp103 = alloca { fp128, fp128 }, align 16
  %indirect-arg-temp112 = alloca { fp128, fp128 }, align 16
  %indirect-arg-temp121 = alloca { fp128, fp128 }, align 16
  store i32 0, i32* %retval, align 4
  %call = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([3 x i8], [3 x i8]* @.str, i32 0, i32 0), i32 0)
  %indirect-arg-temp.realp = getelementptr inbounds { fp128, fp128 }, { fp128, fp128 }* %indirect-arg-temp, i32 0, i32 0
  %indirect-arg-temp.imagp = getelementptr inbounds { fp128, fp128 }, { fp128, fp128 }* %indirect-arg-temp, i32 0, i32 1
  store fp128 0xL00000000000000000000000000000000, fp128* %indirect-arg-temp.realp, align 16
  store fp128 0xL00000000000000000000000000000000, fp128* %indirect-arg-temp.imagp, align 16
  %call1 = call i32 @isint({ fp128, fp128 }* byval({ fp128, fp128 }) align 16 %indirect-arg-temp)
  %tobool = icmp ne i32 %call1, 0
  %0 = zext i1 %tobool to i64
  %cond = select i1 %tobool, i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.2, i32 0, i32 0), i8* getelementptr inbounds ([6 x i8], [6 x i8]* @.str.3, i32 0, i32 0)
  %call2 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([7 x i8], [7 x i8]* @.str.1, i32 0, i32 0), i8* %cond)
  %call3 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([3 x i8], [3 x i8]* @.str, i32 0, i32 0), i32 0)
  %indirect-arg-temp4.realp = getelementptr inbounds { fp128, fp128 }, { fp128, fp128 }* %indirect-arg-temp4, i32 0, i32 0
  %indirect-arg-temp4.imagp = getelementptr inbounds { fp128, fp128 }, { fp128, fp128 }* %indirect-arg-temp4, i32 0, i32 1
  store fp128 0xL00000000000000000000000000000000, fp128* %indirect-arg-temp4.realp, align 16
  store fp128 0xL00000000000000000000000000000000, fp128* %indirect-arg-temp4.imagp, align 16
  %call5 = call i32 @isint({ fp128, fp128 }* byval({ fp128, fp128 }) align 16 %indirect-arg-temp4)
  %tobool6 = icmp ne i32 %call5, 0
  %1 = zext i1 %tobool6 to i64
  %cond7 = select i1 %tobool6, i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.2, i32 0, i32 0), i8* getelementptr inbounds ([6 x i8], [6 x i8]* @.str.3, i32 0, i32 0)
  %call8 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([7 x i8], [7 x i8]* @.str.1, i32 0, i32 0), i8* %cond7)
  %call9 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([3 x i8], [3 x i8]* @.str, i32 0, i32 0), i32 -2)
  %indirect-arg-temp10.realp = getelementptr inbounds { fp128, fp128 }, { fp128, fp128 }* %indirect-arg-temp10, i32 0, i32 0
  %indirect-arg-temp10.imagp = getelementptr inbounds { fp128, fp128 }, { fp128, fp128 }* %indirect-arg-temp10, i32 0, i32 1
  store fp128 0xL0000000000000000C000000000000000, fp128* %indirect-arg-temp10.realp, align 16
  store fp128 0xL00000000000000000000000000000000, fp128* %indirect-arg-temp10.imagp, align 16
  %call11 = call i32 @isint({ fp128, fp128 }* byval({ fp128, fp128 }) align 16 %indirect-arg-temp10)
  %tobool12 = icmp ne i32 %call11, 0
  %2 = zext i1 %tobool12 to i64
  %cond13 = select i1 %tobool12, i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.2, i32 0, i32 0), i8* getelementptr inbounds ([6 x i8], [6 x i8]* @.str.3, i32 0, i32 0)
  %call14 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([7 x i8], [7 x i8]* @.str.1, i32 0, i32 0), i8* %cond13)
  %call15 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([3 x i8], [3 x i8]* @.str.4, i32 0, i32 0), double 0xC000000000000017)
  %indirect-arg-temp16.realp = getelementptr inbounds { fp128, fp128 }, { fp128, fp128 }* %indirect-arg-temp16, i32 0, i32 0
  %indirect-arg-temp16.imagp = getelementptr inbounds { fp128, fp128 }, { fp128, fp128 }* %indirect-arg-temp16, i32 0, i32 1
  store fp128 0xL7000000000000000C000000000000001, fp128* %indirect-arg-temp16.realp, align 16
  store fp128 0xL00000000000000000000000000000000, fp128* %indirect-arg-temp16.imagp, align 16
  %call17 = call i32 @isint({ fp128, fp128 }* byval({ fp128, fp128 }) align 16 %indirect-arg-temp16)
  %tobool18 = icmp ne i32 %call17, 0
  %3 = zext i1 %tobool18 to i64
  %cond19 = select i1 %tobool18, i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.2, i32 0, i32 0), i8* getelementptr inbounds ([6 x i8], [6 x i8]* @.str.3, i32 0, i32 0)
  %call20 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([7 x i8], [7 x i8]* @.str.1, i32 0, i32 0), i8* %cond19)
  %call21 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([3 x i8], [3 x i8]* @.str, i32 0, i32 0), i32 5)
  %indirect-arg-temp22.realp = getelementptr inbounds { fp128, fp128 }, { fp128, fp128 }* %indirect-arg-temp22, i32 0, i32 0
  %indirect-arg-temp22.imagp = getelementptr inbounds { fp128, fp128 }, { fp128, fp128 }* %indirect-arg-temp22, i32 0, i32 1
  store fp128 0xL00000000000000004001400000000000, fp128* %indirect-arg-temp22.realp, align 16
  store fp128 0xL00000000000000000000000000000000, fp128* %indirect-arg-temp22.imagp, align 16
  %call23 = call i32 @isint({ fp128, fp128 }* byval({ fp128, fp128 }) align 16 %indirect-arg-temp22)
  %tobool24 = icmp ne i32 %call23, 0
  %4 = zext i1 %tobool24 to i64
  %cond25 = select i1 %tobool24, i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.2, i32 0, i32 0), i8* getelementptr inbounds ([6 x i8], [6 x i8]* @.str.3, i32 0, i32 0)
  %call26 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([7 x i8], [7 x i8]* @.str.1, i32 0, i32 0), i8* %cond25)
  %call27 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([3 x i8], [3 x i8]* @.str.4, i32 0, i32 0), double 0x401D555555555530)
  %indirect-arg-temp28.realp = getelementptr inbounds { fp128, fp128 }, { fp128, fp128 }* %indirect-arg-temp28, i32 0, i32 0
  %indirect-arg-temp28.imagp = getelementptr inbounds { fp128, fp128 }, { fp128, fp128 }* %indirect-arg-temp28, i32 0, i32 1
  store fp128 0xL00000000000000004001D55555555553, fp128* %indirect-arg-temp28.realp, align 16
  store fp128 0xL00000000000000000000000000000000, fp128* %indirect-arg-temp28.imagp, align 16
  %call29 = call i32 @isint({ fp128, fp128 }* byval({ fp128, fp128 }) align 16 %indirect-arg-temp28)
  %tobool30 = icmp ne i32 %call29, 0
  %5 = zext i1 %tobool30 to i64
  %cond31 = select i1 %tobool30, i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.2, i32 0, i32 0), i8* getelementptr inbounds ([6 x i8], [6 x i8]* @.str.3, i32 0, i32 0)
  %call32 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([7 x i8], [7 x i8]* @.str.1, i32 0, i32 0), i8* %cond31)
  %call33 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([3 x i8], [3 x i8]* @.str.4, i32 0, i32 0), double 0x400921FB5444261E)
  %indirect-arg-temp34.realp = getelementptr inbounds { fp128, fp128 }, { fp128, fp128 }* %indirect-arg-temp34, i32 0, i32 0
  %indirect-arg-temp34.imagp = getelementptr inbounds { fp128, fp128 }, { fp128, fp128 }* %indirect-arg-temp34, i32 0, i32 1
  store fp128 0xLE0000000000000004000921FB5444261, fp128* %indirect-arg-temp34.realp, align 16
  store fp128 0xL00000000000000000000000000000000, fp128* %indirect-arg-temp34.imagp, align 16
  %call35 = call i32 @isint({ fp128, fp128 }* byval({ fp128, fp128 }) align 16 %indirect-arg-temp34)
  %tobool36 = icmp ne i32 %call35, 0
  %6 = zext i1 %tobool36 to i64
  %cond37 = select i1 %tobool36, i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.2, i32 0, i32 0), i8* getelementptr inbounds ([6 x i8], [6 x i8]* @.str.3, i32 0, i32 0)
  %call38 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([7 x i8], [7 x i8]* @.str.1, i32 0, i32 0), i8* %cond37)
  %call39 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([3 x i8], [3 x i8]* @.str.4, i32 0, i32 0), double 0xC3E0000000000000)
  %indirect-arg-temp40.realp = getelementptr inbounds { fp128, fp128 }, { fp128, fp128 }* %indirect-arg-temp40, i32 0, i32 0
  %indirect-arg-temp40.imagp = getelementptr inbounds { fp128, fp128 }, { fp128, fp128 }* %indirect-arg-temp40, i32 0, i32 1
  store fp128 0xL0000000000000000C03E000000000000, fp128* %indirect-arg-temp40.realp, align 16
  store fp128 0xL00000000000000000000000000000000, fp128* %indirect-arg-temp40.imagp, align 16
  %call41 = call i32 @isint({ fp128, fp128 }* byval({ fp128, fp128 }) align 16 %indirect-arg-temp40)
  %tobool42 = icmp ne i32 %call41, 0
  %7 = zext i1 %tobool42 to i64
  %cond43 = select i1 %tobool42, i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.2, i32 0, i32 0), i8* getelementptr inbounds ([6 x i8], [6 x i8]* @.str.3, i32 0, i32 0)
  %call44 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([7 x i8], [7 x i8]* @.str.1, i32 0, i32 0), i8* %cond43)
  %call45 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([3 x i8], [3 x i8]* @.str.4, i32 0, i32 0), double 4.940660e-324)
  %indirect-arg-temp46.realp = getelementptr inbounds { fp128, fp128 }, { fp128, fp128 }* %indirect-arg-temp46, i32 0, i32 0
  %indirect-arg-temp46.imagp = getelementptr inbounds { fp128, fp128 }, { fp128, fp128 }* %indirect-arg-temp46, i32 0, i32 1
  store fp128 0xL00000000000000003BCD000000000000, fp128* %indirect-arg-temp46.realp, align 16
  store fp128 0xL00000000000000000000000000000000, fp128* %indirect-arg-temp46.imagp, align 16
  %call47 = call i32 @isint({ fp128, fp128 }* byval({ fp128, fp128 }) align 16 %indirect-arg-temp46)
  %tobool48 = icmp ne i32 %call47, 0
  %8 = zext i1 %tobool48 to i64
  %cond49 = select i1 %tobool48, i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.2, i32 0, i32 0), i8* getelementptr inbounds ([6 x i8], [6 x i8]* @.str.3, i32 0, i32 0)
  %call50 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([7 x i8], [7 x i8]* @.str.1, i32 0, i32 0), i8* %cond49)
  %call51 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([3 x i8], [3 x i8]* @.str.4, i32 0, i32 0), double 0x7FF8000000000000)
  %indirect-arg-temp52.realp = getelementptr inbounds { fp128, fp128 }, { fp128, fp128 }* %indirect-arg-temp52, i32 0, i32 0
  %indirect-arg-temp52.imagp = getelementptr inbounds { fp128, fp128 }, { fp128, fp128 }* %indirect-arg-temp52, i32 0, i32 1
  store fp128 0xL00000000000000007FFF800000000000, fp128* %indirect-arg-temp52.realp, align 16
  store fp128 0xL00000000000000000000000000000000, fp128* %indirect-arg-temp52.imagp, align 16
  %call53 = call i32 @isint({ fp128, fp128 }* byval({ fp128, fp128 }) align 16 %indirect-arg-temp52)
  %tobool54 = icmp ne i32 %call53, 0
  %9 = zext i1 %tobool54 to i64
  %cond55 = select i1 %tobool54, i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.2, i32 0, i32 0), i8* getelementptr inbounds ([6 x i8], [6 x i8]* @.str.3, i32 0, i32 0)
  %call56 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([7 x i8], [7 x i8]* @.str.1, i32 0, i32 0), i8* %cond55)
  %call57 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([3 x i8], [3 x i8]* @.str, i32 0, i32 0), i32 6)
  %call58 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([4 x i8], [4 x i8]* @.str.5, i32 0, i32 0))
  %call59 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([3 x i8], [3 x i8]* @.str, i32 0, i32 0), i32 0)
  %indirect-arg-temp60.realp = getelementptr inbounds { fp128, fp128 }, { fp128, fp128 }* %indirect-arg-temp60, i32 0, i32 0
  %indirect-arg-temp60.imagp = getelementptr inbounds { fp128, fp128 }, { fp128, fp128 }* %indirect-arg-temp60, i32 0, i32 1
  store fp128 0xL00000000000000004001800000000000, fp128* %indirect-arg-temp60.realp, align 16
  store fp128 0xL00000000000000000000000000000000, fp128* %indirect-arg-temp60.imagp, align 16
  %call61 = call i32 @isint({ fp128, fp128 }* byval({ fp128, fp128 }) align 16 %indirect-arg-temp60)
  %tobool62 = icmp ne i32 %call61, 0
  %10 = zext i1 %tobool62 to i64
  %cond63 = select i1 %tobool62, i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.2, i32 0, i32 0), i8* getelementptr inbounds ([6 x i8], [6 x i8]* @.str.3, i32 0, i32 0)
  %call64 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str.6, i32 0, i32 0), i8* %cond63)
  %call65 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([3 x i8], [3 x i8]* @.str, i32 0, i32 0), i32 0)
  %call66 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([4 x i8], [4 x i8]* @.str.5, i32 0, i32 0))
  %call67 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([3 x i8], [3 x i8]* @.str, i32 0, i32 0), i32 1)
  %indirect-arg-temp68.realp = getelementptr inbounds { fp128, fp128 }, { fp128, fp128 }* %indirect-arg-temp68, i32 0, i32 0
  %indirect-arg-temp68.imagp = getelementptr inbounds { fp128, fp128 }, { fp128, fp128 }* %indirect-arg-temp68, i32 0, i32 1
  store fp128 0xL00000000000000000000000000000000, fp128* %indirect-arg-temp68.realp, align 16
  store fp128 0xL00000000000000003FFF000000000000, fp128* %indirect-arg-temp68.imagp, align 16
  %call69 = call i32 @isint({ fp128, fp128 }* byval({ fp128, fp128 }) align 16 %indirect-arg-temp68)
  %tobool70 = icmp ne i32 %call69, 0
  %11 = zext i1 %tobool70 to i64
  %cond71 = select i1 %tobool70, i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.2, i32 0, i32 0), i8* getelementptr inbounds ([6 x i8], [6 x i8]* @.str.3, i32 0, i32 0)
  %call72 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str.6, i32 0, i32 0), i8* %cond71)
  %call73 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([3 x i8], [3 x i8]* @.str, i32 0, i32 0), i32 0)
  %call74 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([4 x i8], [4 x i8]* @.str.5, i32 0, i32 0))
  %call75 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([3 x i8], [3 x i8]* @.str, i32 0, i32 0), i32 0)
  %indirect-arg-temp76.realp = getelementptr inbounds { fp128, fp128 }, { fp128, fp128 }* %indirect-arg-temp76, i32 0, i32 0
  %indirect-arg-temp76.imagp = getelementptr inbounds { fp128, fp128 }, { fp128, fp128 }* %indirect-arg-temp76, i32 0, i32 1
  store fp128 0xL00000000000000000000000000000000, fp128* %indirect-arg-temp76.realp, align 16
  store fp128 0xL00000000000000000000000000000000, fp128* %indirect-arg-temp76.imagp, align 16
  %call77 = call i32 @isint({ fp128, fp128 }* byval({ fp128, fp128 }) align 16 %indirect-arg-temp76)
  %tobool78 = icmp ne i32 %call77, 0
  %12 = zext i1 %tobool78 to i64
  %cond79 = select i1 %tobool78, i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.2, i32 0, i32 0), i8* getelementptr inbounds ([6 x i8], [6 x i8]* @.str.3, i32 0, i32 0)
  %call80 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str.6, i32 0, i32 0), i8* %cond79)
  %call81 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([3 x i8], [3 x i8]* @.str.4, i32 0, i32 0), double 3.400000e+00)
  %call82 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([4 x i8], [4 x i8]* @.str.5, i32 0, i32 0))
  %call83 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([3 x i8], [3 x i8]* @.str, i32 0, i32 0), i32 0)
  %indirect-arg-temp84.realp = getelementptr inbounds { fp128, fp128 }, { fp128, fp128 }* %indirect-arg-temp84, i32 0, i32 0
  %indirect-arg-temp84.imagp = getelementptr inbounds { fp128, fp128 }, { fp128, fp128 }* %indirect-arg-temp84, i32 0, i32 1
  store fp128 0xL30000000000000004000B33333333333, fp128* %indirect-arg-temp84.realp, align 16
  store fp128 0xL00000000000000000000000000000000, fp128* %indirect-arg-temp84.imagp, align 16
  %call85 = call i32 @isint({ fp128, fp128 }* byval({ fp128, fp128 }) align 16 %indirect-arg-temp84)
  %tobool86 = icmp ne i32 %call85, 0
  %13 = zext i1 %tobool86 to i64
  %cond87 = select i1 %tobool86, i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.2, i32 0, i32 0), i8* getelementptr inbounds ([6 x i8], [6 x i8]* @.str.3, i32 0, i32 0)
  %call88 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str.6, i32 0, i32 0), i8* %cond87)
  br i1 false, label %complex_mul_imag_nan, label %complex_mul_cont, !prof !2

complex_mul_imag_nan:                             ; preds = %entry
  br i1 false, label %complex_mul_libcall, label %complex_mul_cont, !prof !2

complex_mul_libcall:                              ; preds = %complex_mul_imag_nan
  call void @__mulsc3({ float, float }* sret align 4 %tmp, float 0.000000e+00, float 0.000000e+00, float 0.000000e+00, float 1.000000e+00) #3
  %tmp.realp = getelementptr inbounds { float, float }, { float, float }* %tmp, i32 0, i32 0
  %tmp.real = load float, float* %tmp.realp, align 4
  %tmp.imagp = getelementptr inbounds { float, float }, { float, float }* %tmp, i32 0, i32 1
  %tmp.imag = load float, float* %tmp.imagp, align 4
  br label %complex_mul_cont

complex_mul_cont:                                 ; preds = %complex_mul_libcall, %complex_mul_imag_nan, %entry
  %real_mul_phi = phi float [ 0.000000e+00, %entry ], [ 0.000000e+00, %complex_mul_imag_nan ], [ %tmp.real, %complex_mul_libcall ]
  %imag_mul_phi = phi float [ 0.000000e+00, %entry ], [ 0.000000e+00, %complex_mul_imag_nan ], [ %tmp.imag, %complex_mul_libcall ]
  %add.r = fadd float 5.000000e+00, %real_mul_phi
  %add.i = fadd float 0.000000e+00, %imag_mul_phi
  %conv = fpext float %add.r to double
  %conv89 = fpext float %add.i to double
  %test1.realp = getelementptr inbounds { double, double }, { double, double }* %test1, i32 0, i32 0
  %test1.imagp = getelementptr inbounds { double, double }, { double, double }* %test1, i32 0, i32 1
  store double %conv, double* %test1.realp, align 8
  store double %conv89, double* %test1.imagp, align 8
  %test2.realp = getelementptr inbounds { double, double }, { double, double }* %test2, i32 0, i32 0
  %test2.imagp = getelementptr inbounds { double, double }, { double, double }* %test2, i32 0, i32 1
  store double 0x400B333340000000, double* %test2.realp, align 8
  store double 0.000000e+00, double* %test2.imagp, align 8
  %test3.realp = getelementptr inbounds { double, double }, { double, double }* %test3, i32 0, i32 0
  %test3.imagp = getelementptr inbounds { double, double }, { double, double }* %test3, i32 0, i32 1
  store double 3.000000e+00, double* %test3.realp, align 8
  store double 0.000000e+00, double* %test3.imagp, align 8
  %test4.realp = getelementptr inbounds { double, double }, { double, double }* %test4, i32 0, i32 0
  %test4.imagp = getelementptr inbounds { double, double }, { double, double }* %test4, i32 0, i32 1
  store double 0.000000e+00, double* %test4.realp, align 8
  store double 1.200000e+00, double* %test4.imagp, align 8
  %test1.realp90 = getelementptr inbounds { double, double }, { double, double }* %test1, i32 0, i32 0
  %test1.real = load double, double* %test1.realp90, align 8
  %test1.imagp91 = getelementptr inbounds { double, double }, { double, double }* %test1, i32 0, i32 1
  %test1.imag = load double, double* %test1.imagp91, align 8
  %conv92 = fpext double %test1.real to fp128
  %conv93 = fpext double %test1.imag to fp128
  %indirect-arg-temp94.realp = getelementptr inbounds { fp128, fp128 }, { fp128, fp128 }* %indirect-arg-temp94, i32 0, i32 0
  %indirect-arg-temp94.imagp = getelementptr inbounds { fp128, fp128 }, { fp128, fp128 }* %indirect-arg-temp94, i32 0, i32 1
  store fp128 %conv92, fp128* %indirect-arg-temp94.realp, align 16
  store fp128 %conv93, fp128* %indirect-arg-temp94.imagp, align 16
  %call95 = call i32 @isint({ fp128, fp128 }* byval({ fp128, fp128 }) align 16 %indirect-arg-temp94)
  %tobool96 = icmp ne i32 %call95, 0
  %14 = zext i1 %tobool96 to i64
  %cond97 = select i1 %tobool96, i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.2, i32 0, i32 0), i8* getelementptr inbounds ([6 x i8], [6 x i8]* @.str.3, i32 0, i32 0)
  %call98 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([19 x i8], [19 x i8]* @.str.7, i32 0, i32 0), i8* %cond97)
  %test2.realp99 = getelementptr inbounds { double, double }, { double, double }* %test2, i32 0, i32 0
  %test2.real = load double, double* %test2.realp99, align 8
  %test2.imagp100 = getelementptr inbounds { double, double }, { double, double }* %test2, i32 0, i32 1
  %test2.imag = load double, double* %test2.imagp100, align 8
  %conv101 = fpext double %test2.real to fp128
  %conv102 = fpext double %test2.imag to fp128
  %indirect-arg-temp103.realp = getelementptr inbounds { fp128, fp128 }, { fp128, fp128 }* %indirect-arg-temp103, i32 0, i32 0
  %indirect-arg-temp103.imagp = getelementptr inbounds { fp128, fp128 }, { fp128, fp128 }* %indirect-arg-temp103, i32 0, i32 1
  store fp128 %conv101, fp128* %indirect-arg-temp103.realp, align 16
  store fp128 %conv102, fp128* %indirect-arg-temp103.imagp, align 16
  %call104 = call i32 @isint({ fp128, fp128 }* byval({ fp128, fp128 }) align 16 %indirect-arg-temp103)
  %tobool105 = icmp ne i32 %call104, 0
  %15 = zext i1 %tobool105 to i64
  %cond106 = select i1 %tobool105, i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.2, i32 0, i32 0), i8* getelementptr inbounds ([6 x i8], [6 x i8]* @.str.3, i32 0, i32 0)
  %call107 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([22 x i8], [22 x i8]* @.str.8, i32 0, i32 0), i8* %cond106)
  %test3.realp108 = getelementptr inbounds { double, double }, { double, double }* %test3, i32 0, i32 0
  %test3.real = load double, double* %test3.realp108, align 8
  %test3.imagp109 = getelementptr inbounds { double, double }, { double, double }* %test3, i32 0, i32 1
  %test3.imag = load double, double* %test3.imagp109, align 8
  %conv110 = fpext double %test3.real to fp128
  %conv111 = fpext double %test3.imag to fp128
  %indirect-arg-temp112.realp = getelementptr inbounds { fp128, fp128 }, { fp128, fp128 }* %indirect-arg-temp112, i32 0, i32 0
  %indirect-arg-temp112.imagp = getelementptr inbounds { fp128, fp128 }, { fp128, fp128 }* %indirect-arg-temp112, i32 0, i32 1
  store fp128 %conv110, fp128* %indirect-arg-temp112.realp, align 16
  store fp128 %conv111, fp128* %indirect-arg-temp112.imagp, align 16
  %call113 = call i32 @isint({ fp128, fp128 }* byval({ fp128, fp128 }) align 16 %indirect-arg-temp112)
  %tobool114 = icmp ne i32 %call113, 0
  %16 = zext i1 %tobool114 to i64
  %cond115 = select i1 %tobool114, i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.2, i32 0, i32 0), i8* getelementptr inbounds ([6 x i8], [6 x i8]* @.str.3, i32 0, i32 0)
  %call116 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([20 x i8], [20 x i8]* @.str.9, i32 0, i32 0), i8* %cond115)
  %test4.realp117 = getelementptr inbounds { double, double }, { double, double }* %test4, i32 0, i32 0
  %test4.real = load double, double* %test4.realp117, align 8
  %test4.imagp118 = getelementptr inbounds { double, double }, { double, double }* %test4, i32 0, i32 1
  %test4.imag = load double, double* %test4.imagp118, align 8
  %conv119 = fpext double %test4.real to fp128
  %conv120 = fpext double %test4.imag to fp128
  %indirect-arg-temp121.realp = getelementptr inbounds { fp128, fp128 }, { fp128, fp128 }* %indirect-arg-temp121, i32 0, i32 0
  %indirect-arg-temp121.imagp = getelementptr inbounds { fp128, fp128 }, { fp128, fp128 }* %indirect-arg-temp121, i32 0, i32 1
  store fp128 %conv119, fp128* %indirect-arg-temp121.realp, align 16
  store fp128 %conv120, fp128* %indirect-arg-temp121.imagp, align 16
  %call122 = call i32 @isint({ fp128, fp128 }* byval({ fp128, fp128 }) align 16 %indirect-arg-temp121)
  %tobool123 = icmp ne i32 %call122, 0
  %17 = zext i1 %tobool123 to i64
  %cond124 = select i1 %tobool123, i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.2, i32 0, i32 0), i8* getelementptr inbounds ([6 x i8], [6 x i8]* @.str.3, i32 0, i32 0)
  %call125 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([22 x i8], [22 x i8]* @.str.10, i32 0, i32 0), i8* %cond124)
  %18 = load i32, i32* %retval, align 4
  ret i32 %18
}

declare i32 @printf(i8* %0, ...) #1

; Function Attrs: noinline nounwind optnone
define internal i32 @isint({ fp128, fp128 }* byval({ fp128, fp128 }) align 16 %n) #0 {
entry:
  %n.realp = getelementptr inbounds { fp128, fp128 }, { fp128, fp128 }* %n, i32 0, i32 0
  %n.real = load fp128, fp128* %n.realp, align 16
  %n.imagp = getelementptr inbounds { fp128, fp128 }, { fp128, fp128 }* %n, i32 0, i32 1
  %n.imag = load fp128, fp128* %n.imagp, align 16
  %cmp = fcmp oeq fp128 %n.imag, 0xL00000000000000000000000000000000
  br i1 %cmp, label %land.rhs, label %land.end

land.rhs:                                         ; preds = %entry
  %n.realp1 = getelementptr inbounds { fp128, fp128 }, { fp128, fp128 }* %n, i32 0, i32 0
  %n.real2 = load fp128, fp128* %n.realp1, align 16
  %n.imagp3 = getelementptr inbounds { fp128, fp128 }, { fp128, fp128 }* %n, i32 0, i32 1
  %n.imag4 = load fp128, fp128* %n.imagp3, align 16
  %0 = call fp128 @llvm.nearbyint.f128(fp128 %n.real2)
  %n.realp5 = getelementptr inbounds { fp128, fp128 }, { fp128, fp128 }* %n, i32 0, i32 0
  %n.real6 = load fp128, fp128* %n.realp5, align 16
  %n.imagp7 = getelementptr inbounds { fp128, fp128 }, { fp128, fp128 }* %n, i32 0, i32 1
  %n.imag8 = load fp128, fp128* %n.imagp7, align 16
  %cmp9 = fcmp oeq fp128 %0, %n.real6
  br label %land.end

land.end:                                         ; preds = %land.rhs, %entry
  %1 = phi i1 [ false, %entry ], [ %cmp9, %land.rhs ]
  %land.ext = zext i1 %1 to i32
  ret i32 %land.ext
}

declare void @__mulsc3({ float, float }* %0, float %1, float %2, float %3, float %4)

; Function Attrs: nounwind readnone speculatable willreturn
declare fp128 @llvm.nearbyint.f128(fp128 %0) #2

attributes #0 = { noinline nounwind optnone "correctly-rounded-divide-sqrt-fp-math"="false" "disable-tail-calls"="false" "frame-pointer"="none" "less-precise-fpmad"="false" "min-legal-vector-width"="0" "no-infs-fp-math"="false" "no-jump-tables"="false" "no-nans-fp-math"="false" "no-signed-zeros-fp-math"="false" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="generic" "unsafe-fp-math"="false" "use-soft-float"="false" }
attributes #1 = { "correctly-rounded-divide-sqrt-fp-math"="false" "disable-tail-calls"="false" "frame-pointer"="none" "less-precise-fpmad"="false" "no-infs-fp-math"="false" "no-nans-fp-math"="false" "no-signed-zeros-fp-math"="false" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="generic" "unsafe-fp-math"="false" "use-soft-float"="false" }
attributes #2 = { nounwind readnone speculatable willreturn }
attributes #3 = { nounwind }

!llvm.module.flags = !{!0}
!llvm.ident = !{!1}

!0 = !{i32 1, !"wchar_size", i32 4}
!1 = !{!"clang version 11.0.0 (https://github.com/Jacarte/llvm-project.git 0f6dea67136cc1e0b3d200eb2bb165628970c44b)"}
!2 = !{!"branch_weights", i32 1, i32 1048575}

; extracted candidates

; *****
; For LLVM instruction:
;  %call1 = call i32 @isint({ fp128, fp128 }* byval({ fp128, fp128 }) align 16 %indirect-arg-temp)
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %tobool = icmp ne i32 %call1, 0
; Looking for a replacement for:
%0:i32 = var
%1:i1 = ne 0:i32, %0
infer %1

; *****
; For LLVM instruction:
;  %call5 = call i32 @isint({ fp128, fp128 }* byval({ fp128, fp128 }) align 16 %indirect-arg-temp4)
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %tobool6 = icmp ne i32 %call5, 0
; Looking for a replacement for:
%0:i32 = var
%1:i1 = ne 0:i32, %0
infer %1

; *****
; For LLVM instruction:
;  %call11 = call i32 @isint({ fp128, fp128 }* byval({ fp128, fp128 }) align 16 %indirect-arg-temp10)
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %tobool12 = icmp ne i32 %call11, 0
; Looking for a replacement for:
%0:i32 = var
%1:i1 = ne 0:i32, %0
infer %1

; *****
; For LLVM instruction:
;  %call17 = call i32 @isint({ fp128, fp128 }* byval({ fp128, fp128 }) align 16 %indirect-arg-temp16)
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %tobool18 = icmp ne i32 %call17, 0
; Looking for a replacement for:
%0:i32 = var
%1:i1 = ne 0:i32, %0
infer %1

; *****
; For LLVM instruction:
;  %call23 = call i32 @isint({ fp128, fp128 }* byval({ fp128, fp128 }) align 16 %indirect-arg-temp22)
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %tobool24 = icmp ne i32 %call23, 0
; Looking for a replacement for:
%0:i32 = var
%1:i1 = ne 0:i32, %0
infer %1

; *****
; For LLVM instruction:
;  %call29 = call i32 @isint({ fp128, fp128 }* byval({ fp128, fp128 }) align 16 %indirect-arg-temp28)
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %tobool30 = icmp ne i32 %call29, 0
; Looking for a replacement for:
%0:i32 = var
%1:i1 = ne 0:i32, %0
infer %1

; *****
; For LLVM instruction:
;  %call35 = call i32 @isint({ fp128, fp128 }* byval({ fp128, fp128 }) align 16 %indirect-arg-temp34)
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %tobool36 = icmp ne i32 %call35, 0
; Looking for a replacement for:
%0:i32 = var
%1:i1 = ne 0:i32, %0
infer %1

; *****
; For LLVM instruction:
;  %call41 = call i32 @isint({ fp128, fp128 }* byval({ fp128, fp128 }) align 16 %indirect-arg-temp40)
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %tobool42 = icmp ne i32 %call41, 0
; Looking for a replacement for:
%0:i32 = var
%1:i1 = ne 0:i32, %0
infer %1

; *****
; For LLVM instruction:
;  %call47 = call i32 @isint({ fp128, fp128 }* byval({ fp128, fp128 }) align 16 %indirect-arg-temp46)
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %tobool48 = icmp ne i32 %call47, 0
; Looking for a replacement for:
%0:i32 = var
%1:i1 = ne 0:i32, %0
infer %1

; *****
; For LLVM instruction:
;  %call53 = call i32 @isint({ fp128, fp128 }* byval({ fp128, fp128 }) align 16 %indirect-arg-temp52)
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %tobool54 = icmp ne i32 %call53, 0
; Looking for a replacement for:
%0:i32 = var
%1:i1 = ne 0:i32, %0
infer %1

; *****
; For LLVM instruction:
;  %call61 = call i32 @isint({ fp128, fp128 }* byval({ fp128, fp128 }) align 16 %indirect-arg-temp60)
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %tobool62 = icmp ne i32 %call61, 0
; Looking for a replacement for:
%0:i32 = var
%1:i1 = ne 0:i32, %0
infer %1

; *****
; For LLVM instruction:
;  %call69 = call i32 @isint({ fp128, fp128 }* byval({ fp128, fp128 }) align 16 %indirect-arg-temp68)
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %tobool70 = icmp ne i32 %call69, 0
; Looking for a replacement for:
%0:i32 = var
%1:i1 = ne 0:i32, %0
infer %1

; *****
; For LLVM instruction:
;  %call77 = call i32 @isint({ fp128, fp128 }* byval({ fp128, fp128 }) align 16 %indirect-arg-temp76)
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %tobool78 = icmp ne i32 %call77, 0
; Looking for a replacement for:
%0:i32 = var
%1:i1 = ne 0:i32, %0
infer %1

; *****
; For LLVM instruction:
;  %call85 = call i32 @isint({ fp128, fp128 }* byval({ fp128, fp128 }) align 16 %indirect-arg-temp84)
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %tobool86 = icmp ne i32 %call85, 0
; Looking for a replacement for:
%0:i32 = var
%1:i1 = ne 0:i32, %0
infer %1

; *****
; For LLVM instruction:
;  %call95 = call i32 @isint({ fp128, fp128 }* byval({ fp128, fp128 }) align 16 %indirect-arg-temp94)
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %tobool96 = icmp ne i32 %call95, 0
; Looking for a replacement for:
%0:i32 = var
%1:i1 = ne 0:i32, %0
infer %1

; *****
; For LLVM instruction:
;  %call104 = call i32 @isint({ fp128, fp128 }* byval({ fp128, fp128 }) align 16 %indirect-arg-temp103)
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %tobool105 = icmp ne i32 %call104, 0
; Looking for a replacement for:
%0:i32 = var
%1:i1 = ne 0:i32, %0
infer %1

; *****
; For LLVM instruction:
;  %call113 = call i32 @isint({ fp128, fp128 }* byval({ fp128, fp128 }) align 16 %indirect-arg-temp112)
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %tobool114 = icmp ne i32 %call113, 0
; Looking for a replacement for:
%0:i32 = var
%1:i1 = ne 0:i32, %0
infer %1

; *****
; For LLVM instruction:
;  %call122 = call i32 @isint({ fp128, fp128 }* byval({ fp128, fp128 }) align 16 %indirect-arg-temp121)
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %tobool123 = icmp ne i32 %call122, 0
; Looking for a replacement for:
%0:i32 = var
%1:i1 = ne 0:i32, %0
infer %1

; *****
; For LLVM instruction:
;  %18 = load i32, i32* %retval, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0
got 1 candidates from LHS

-------------------------------------------------
%0:i32 = var
infer %0


--------------------------------
guess 0

%0:i32 = var ; reservedconst_1

Cost = 0
first query is SAT, returning the model:
reservedconst_1: 0
0 th attempt: second query is SAT-- constant doesn't work
first query is SAT, returning the model:
reservedconst_1: -1
1 th attempt: second query is SAT-- constant doesn't work
first query is UNSAT-- no more guesses
Dataflow Pruned 0/0
There are 1 Guesses
There are 0 RHSs before deduplication
There are 0 RHSs after deduplication
got 2 candidates from LHS

-------------------------------------------------
%0:i32 = var
%1:i1 = ne 0:i32, %0
infer %1


--------------------------------
guess 0

%0:i1 = var ; reservedconst_1

Cost = 0
first query is SAT, returning the model:
reservedconst_1: 0
0 th attempt: second query is SAT-- constant doesn't work
first query is SAT, returning the model:
reservedconst_1: -1
1 th attempt: second query is SAT-- constant doesn't work
first query is UNSAT-- no more guesses
Dataflow Pruned 0/0
There are 1 Guesses
There are 0 RHSs before deduplication
There are 0 RHSs after deduplication
#########################################################
; exiting Souper's runOnFunction() for main()

; entering Souper's runOnFunction() for ./Test_integerness.c.bc:isint()

; ModuleID = './Test_integerness.c.bc'
source_filename = "./Test_integerness.c"
target datalayout = "e-m:e-p:32:32-i64:64-n32:64-S128"
target triple = "wasm32-unknown-wasi"

@.str = private unnamed_addr constant [3 x i8] c"%d\00", align 1
@.str.1 = private unnamed_addr constant [7 x i8] c" = %s\0A\00", align 1
@.str.2 = private unnamed_addr constant [5 x i8] c"true\00", align 1
@.str.3 = private unnamed_addr constant [6 x i8] c"false\00", align 1
@.str.4 = private unnamed_addr constant [3 x i8] c"%f\00", align 1
@.str.5 = private unnamed_addr constant [4 x i8] c" + \00", align 1
@.str.6 = private unnamed_addr constant [8 x i8] c"i = %s\0A\00", align 1
@.str.7 = private unnamed_addr constant [19 x i8] c"Test 1 (5+i) = %s\0A\00", align 1
@.str.8 = private unnamed_addr constant [22 x i8] c"Test 2 (3.4+0i) = %s\0A\00", align 1
@.str.9 = private unnamed_addr constant [20 x i8] c"Test 3 (3+0i) = %s\0A\00", align 1
@.str.10 = private unnamed_addr constant [22 x i8] c"Test 4 (0+1.2i) = %s\0A\00", align 1
@llvm.used = appending global [1 x i8*] [i8* bitcast (i32 ()* @__main_void to i8*)], section "llvm.metadata"

@__main_void = alias i32 (), i32 ()* @main

; Function Attrs: noinline nounwind optnone
define hidden i32 @main() #0 {
entry:
  %retval = alloca i32, align 4
  %indirect-arg-temp = alloca { fp128, fp128 }, align 16
  %indirect-arg-temp4 = alloca { fp128, fp128 }, align 16
  %indirect-arg-temp10 = alloca { fp128, fp128 }, align 16
  %indirect-arg-temp16 = alloca { fp128, fp128 }, align 16
  %indirect-arg-temp22 = alloca { fp128, fp128 }, align 16
  %indirect-arg-temp28 = alloca { fp128, fp128 }, align 16
  %indirect-arg-temp34 = alloca { fp128, fp128 }, align 16
  %indirect-arg-temp40 = alloca { fp128, fp128 }, align 16
  %indirect-arg-temp46 = alloca { fp128, fp128 }, align 16
  %indirect-arg-temp52 = alloca { fp128, fp128 }, align 16
  %indirect-arg-temp60 = alloca { fp128, fp128 }, align 16
  %indirect-arg-temp68 = alloca { fp128, fp128 }, align 16
  %indirect-arg-temp76 = alloca { fp128, fp128 }, align 16
  %indirect-arg-temp84 = alloca { fp128, fp128 }, align 16
  %test1 = alloca { double, double }, align 8
  %tmp = alloca { float, float }, align 4
  %test2 = alloca { double, double }, align 8
  %test3 = alloca { double, double }, align 8
  %test4 = alloca { double, double }, align 8
  %indirect-arg-temp94 = alloca { fp128, fp128 }, align 16
  %indirect-arg-temp103 = alloca { fp128, fp128 }, align 16
  %indirect-arg-temp112 = alloca { fp128, fp128 }, align 16
  %indirect-arg-temp121 = alloca { fp128, fp128 }, align 16
  store i32 0, i32* %retval, align 4
  %call = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([3 x i8], [3 x i8]* @.str, i32 0, i32 0), i32 0)
  %indirect-arg-temp.realp = getelementptr inbounds { fp128, fp128 }, { fp128, fp128 }* %indirect-arg-temp, i32 0, i32 0
  %indirect-arg-temp.imagp = getelementptr inbounds { fp128, fp128 }, { fp128, fp128 }* %indirect-arg-temp, i32 0, i32 1
  store fp128 0xL00000000000000000000000000000000, fp128* %indirect-arg-temp.realp, align 16
  store fp128 0xL00000000000000000000000000000000, fp128* %indirect-arg-temp.imagp, align 16
  %call1 = call i32 @isint({ fp128, fp128 }* byval({ fp128, fp128 }) align 16 %indirect-arg-temp)
  %tobool = icmp ne i32 %call1, 0
  %0 = zext i1 %tobool to i64
  %cond = select i1 %tobool, i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.2, i32 0, i32 0), i8* getelementptr inbounds ([6 x i8], [6 x i8]* @.str.3, i32 0, i32 0)
  %call2 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([7 x i8], [7 x i8]* @.str.1, i32 0, i32 0), i8* %cond)
  %call3 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([3 x i8], [3 x i8]* @.str, i32 0, i32 0), i32 0)
  %indirect-arg-temp4.realp = getelementptr inbounds { fp128, fp128 }, { fp128, fp128 }* %indirect-arg-temp4, i32 0, i32 0
  %indirect-arg-temp4.imagp = getelementptr inbounds { fp128, fp128 }, { fp128, fp128 }* %indirect-arg-temp4, i32 0, i32 1
  store fp128 0xL00000000000000000000000000000000, fp128* %indirect-arg-temp4.realp, align 16
  store fp128 0xL00000000000000000000000000000000, fp128* %indirect-arg-temp4.imagp, align 16
  %call5 = call i32 @isint({ fp128, fp128 }* byval({ fp128, fp128 }) align 16 %indirect-arg-temp4)
  %tobool6 = icmp ne i32 %call5, 0
  %1 = zext i1 %tobool6 to i64
  %cond7 = select i1 %tobool6, i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.2, i32 0, i32 0), i8* getelementptr inbounds ([6 x i8], [6 x i8]* @.str.3, i32 0, i32 0)
  %call8 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([7 x i8], [7 x i8]* @.str.1, i32 0, i32 0), i8* %cond7)
  %call9 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([3 x i8], [3 x i8]* @.str, i32 0, i32 0), i32 -2)
  %indirect-arg-temp10.realp = getelementptr inbounds { fp128, fp128 }, { fp128, fp128 }* %indirect-arg-temp10, i32 0, i32 0
  %indirect-arg-temp10.imagp = getelementptr inbounds { fp128, fp128 }, { fp128, fp128 }* %indirect-arg-temp10, i32 0, i32 1
  store fp128 0xL0000000000000000C000000000000000, fp128* %indirect-arg-temp10.realp, align 16
  store fp128 0xL00000000000000000000000000000000, fp128* %indirect-arg-temp10.imagp, align 16
  %call11 = call i32 @isint({ fp128, fp128 }* byval({ fp128, fp128 }) align 16 %indirect-arg-temp10)
  %tobool12 = icmp ne i32 %call11, 0
  %2 = zext i1 %tobool12 to i64
  %cond13 = select i1 %tobool12, i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.2, i32 0, i32 0), i8* getelementptr inbounds ([6 x i8], [6 x i8]* @.str.3, i32 0, i32 0)
  %call14 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([7 x i8], [7 x i8]* @.str.1, i32 0, i32 0), i8* %cond13)
  %call15 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([3 x i8], [3 x i8]* @.str.4, i32 0, i32 0), double 0xC000000000000017)
  %indirect-arg-temp16.realp = getelementptr inbounds { fp128, fp128 }, { fp128, fp128 }* %indirect-arg-temp16, i32 0, i32 0
  %indirect-arg-temp16.imagp = getelementptr inbounds { fp128, fp128 }, { fp128, fp128 }* %indirect-arg-temp16, i32 0, i32 1
  store fp128 0xL7000000000000000C000000000000001, fp128* %indirect-arg-temp16.realp, align 16
  store fp128 0xL00000000000000000000000000000000, fp128* %indirect-arg-temp16.imagp, align 16
  %call17 = call i32 @isint({ fp128, fp128 }* byval({ fp128, fp128 }) align 16 %indirect-arg-temp16)
  %tobool18 = icmp ne i32 %call17, 0
  %3 = zext i1 %tobool18 to i64
  %cond19 = select i1 %tobool18, i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.2, i32 0, i32 0), i8* getelementptr inbounds ([6 x i8], [6 x i8]* @.str.3, i32 0, i32 0)
  %call20 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([7 x i8], [7 x i8]* @.str.1, i32 0, i32 0), i8* %cond19)
  %call21 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([3 x i8], [3 x i8]* @.str, i32 0, i32 0), i32 5)
  %indirect-arg-temp22.realp = getelementptr inbounds { fp128, fp128 }, { fp128, fp128 }* %indirect-arg-temp22, i32 0, i32 0
  %indirect-arg-temp22.imagp = getelementptr inbounds { fp128, fp128 }, { fp128, fp128 }* %indirect-arg-temp22, i32 0, i32 1
  store fp128 0xL00000000000000004001400000000000, fp128* %indirect-arg-temp22.realp, align 16
  store fp128 0xL00000000000000000000000000000000, fp128* %indirect-arg-temp22.imagp, align 16
  %call23 = call i32 @isint({ fp128, fp128 }* byval({ fp128, fp128 }) align 16 %indirect-arg-temp22)
  %tobool24 = icmp ne i32 %call23, 0
  %4 = zext i1 %tobool24 to i64
  %cond25 = select i1 %tobool24, i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.2, i32 0, i32 0), i8* getelementptr inbounds ([6 x i8], [6 x i8]* @.str.3, i32 0, i32 0)
  %call26 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([7 x i8], [7 x i8]* @.str.1, i32 0, i32 0), i8* %cond25)
  %call27 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([3 x i8], [3 x i8]* @.str.4, i32 0, i32 0), double 0x401D555555555530)
  %indirect-arg-temp28.realp = getelementptr inbounds { fp128, fp128 }, { fp128, fp128 }* %indirect-arg-temp28, i32 0, i32 0
  %indirect-arg-temp28.imagp = getelementptr inbounds { fp128, fp128 }, { fp128, fp128 }* %indirect-arg-temp28, i32 0, i32 1
  store fp128 0xL00000000000000004001D55555555553, fp128* %indirect-arg-temp28.realp, align 16
  store fp128 0xL00000000000000000000000000000000, fp128* %indirect-arg-temp28.imagp, align 16
  %call29 = call i32 @isint({ fp128, fp128 }* byval({ fp128, fp128 }) align 16 %indirect-arg-temp28)
  %tobool30 = icmp ne i32 %call29, 0
  %5 = zext i1 %tobool30 to i64
  %cond31 = select i1 %tobool30, i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.2, i32 0, i32 0), i8* getelementptr inbounds ([6 x i8], [6 x i8]* @.str.3, i32 0, i32 0)
  %call32 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([7 x i8], [7 x i8]* @.str.1, i32 0, i32 0), i8* %cond31)
  %call33 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([3 x i8], [3 x i8]* @.str.4, i32 0, i32 0), double 0x400921FB5444261E)
  %indirect-arg-temp34.realp = getelementptr inbounds { fp128, fp128 }, { fp128, fp128 }* %indirect-arg-temp34, i32 0, i32 0
  %indirect-arg-temp34.imagp = getelementptr inbounds { fp128, fp128 }, { fp128, fp128 }* %indirect-arg-temp34, i32 0, i32 1
  store fp128 0xLE0000000000000004000921FB5444261, fp128* %indirect-arg-temp34.realp, align 16
  store fp128 0xL00000000000000000000000000000000, fp128* %indirect-arg-temp34.imagp, align 16
  %call35 = call i32 @isint({ fp128, fp128 }* byval({ fp128, fp128 }) align 16 %indirect-arg-temp34)
  %tobool36 = icmp ne i32 %call35, 0
  %6 = zext i1 %tobool36 to i64
  %cond37 = select i1 %tobool36, i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.2, i32 0, i32 0), i8* getelementptr inbounds ([6 x i8], [6 x i8]* @.str.3, i32 0, i32 0)
  %call38 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([7 x i8], [7 x i8]* @.str.1, i32 0, i32 0), i8* %cond37)
  %call39 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([3 x i8], [3 x i8]* @.str.4, i32 0, i32 0), double 0xC3E0000000000000)
  %indirect-arg-temp40.realp = getelementptr inbounds { fp128, fp128 }, { fp128, fp128 }* %indirect-arg-temp40, i32 0, i32 0
  %indirect-arg-temp40.imagp = getelementptr inbounds { fp128, fp128 }, { fp128, fp128 }* %indirect-arg-temp40, i32 0, i32 1
  store fp128 0xL0000000000000000C03E000000000000, fp128* %indirect-arg-temp40.realp, align 16
  store fp128 0xL00000000000000000000000000000000, fp128* %indirect-arg-temp40.imagp, align 16
  %call41 = call i32 @isint({ fp128, fp128 }* byval({ fp128, fp128 }) align 16 %indirect-arg-temp40)
  %tobool42 = icmp ne i32 %call41, 0
  %7 = zext i1 %tobool42 to i64
  %cond43 = select i1 %tobool42, i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.2, i32 0, i32 0), i8* getelementptr inbounds ([6 x i8], [6 x i8]* @.str.3, i32 0, i32 0)
  %call44 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([7 x i8], [7 x i8]* @.str.1, i32 0, i32 0), i8* %cond43)
  %call45 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([3 x i8], [3 x i8]* @.str.4, i32 0, i32 0), double 4.940660e-324)
  %indirect-arg-temp46.realp = getelementptr inbounds { fp128, fp128 }, { fp128, fp128 }* %indirect-arg-temp46, i32 0, i32 0
  %indirect-arg-temp46.imagp = getelementptr inbounds { fp128, fp128 }, { fp128, fp128 }* %indirect-arg-temp46, i32 0, i32 1
  store fp128 0xL00000000000000003BCD000000000000, fp128* %indirect-arg-temp46.realp, align 16
  store fp128 0xL00000000000000000000000000000000, fp128* %indirect-arg-temp46.imagp, align 16
  %call47 = call i32 @isint({ fp128, fp128 }* byval({ fp128, fp128 }) align 16 %indirect-arg-temp46)
  %tobool48 = icmp ne i32 %call47, 0
  %8 = zext i1 %tobool48 to i64
  %cond49 = select i1 %tobool48, i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.2, i32 0, i32 0), i8* getelementptr inbounds ([6 x i8], [6 x i8]* @.str.3, i32 0, i32 0)
  %call50 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([7 x i8], [7 x i8]* @.str.1, i32 0, i32 0), i8* %cond49)
  %call51 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([3 x i8], [3 x i8]* @.str.4, i32 0, i32 0), double 0x7FF8000000000000)
  %indirect-arg-temp52.realp = getelementptr inbounds { fp128, fp128 }, { fp128, fp128 }* %indirect-arg-temp52, i32 0, i32 0
  %indirect-arg-temp52.imagp = getelementptr inbounds { fp128, fp128 }, { fp128, fp128 }* %indirect-arg-temp52, i32 0, i32 1
  store fp128 0xL00000000000000007FFF800000000000, fp128* %indirect-arg-temp52.realp, align 16
  store fp128 0xL00000000000000000000000000000000, fp128* %indirect-arg-temp52.imagp, align 16
  %call53 = call i32 @isint({ fp128, fp128 }* byval({ fp128, fp128 }) align 16 %indirect-arg-temp52)
  %tobool54 = icmp ne i32 %call53, 0
  %9 = zext i1 %tobool54 to i64
  %cond55 = select i1 %tobool54, i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.2, i32 0, i32 0), i8* getelementptr inbounds ([6 x i8], [6 x i8]* @.str.3, i32 0, i32 0)
  %call56 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([7 x i8], [7 x i8]* @.str.1, i32 0, i32 0), i8* %cond55)
  %call57 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([3 x i8], [3 x i8]* @.str, i32 0, i32 0), i32 6)
  %call58 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([4 x i8], [4 x i8]* @.str.5, i32 0, i32 0))
  %call59 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([3 x i8], [3 x i8]* @.str, i32 0, i32 0), i32 0)
  %indirect-arg-temp60.realp = getelementptr inbounds { fp128, fp128 }, { fp128, fp128 }* %indirect-arg-temp60, i32 0, i32 0
  %indirect-arg-temp60.imagp = getelementptr inbounds { fp128, fp128 }, { fp128, fp128 }* %indirect-arg-temp60, i32 0, i32 1
  store fp128 0xL00000000000000004001800000000000, fp128* %indirect-arg-temp60.realp, align 16
  store fp128 0xL00000000000000000000000000000000, fp128* %indirect-arg-temp60.imagp, align 16
  %call61 = call i32 @isint({ fp128, fp128 }* byval({ fp128, fp128 }) align 16 %indirect-arg-temp60)
  %tobool62 = icmp ne i32 %call61, 0
  %10 = zext i1 %tobool62 to i64
  %cond63 = select i1 %tobool62, i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.2, i32 0, i32 0), i8* getelementptr inbounds ([6 x i8], [6 x i8]* @.str.3, i32 0, i32 0)
  %call64 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str.6, i32 0, i32 0), i8* %cond63)
  %call65 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([3 x i8], [3 x i8]* @.str, i32 0, i32 0), i32 0)
  %call66 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([4 x i8], [4 x i8]* @.str.5, i32 0, i32 0))
  %call67 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([3 x i8], [3 x i8]* @.str, i32 0, i32 0), i32 1)
  %indirect-arg-temp68.realp = getelementptr inbounds { fp128, fp128 }, { fp128, fp128 }* %indirect-arg-temp68, i32 0, i32 0
  %indirect-arg-temp68.imagp = getelementptr inbounds { fp128, fp128 }, { fp128, fp128 }* %indirect-arg-temp68, i32 0, i32 1
  store fp128 0xL00000000000000000000000000000000, fp128* %indirect-arg-temp68.realp, align 16
  store fp128 0xL00000000000000003FFF000000000000, fp128* %indirect-arg-temp68.imagp, align 16
  %call69 = call i32 @isint({ fp128, fp128 }* byval({ fp128, fp128 }) align 16 %indirect-arg-temp68)
  %tobool70 = icmp ne i32 %call69, 0
  %11 = zext i1 %tobool70 to i64
  %cond71 = select i1 %tobool70, i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.2, i32 0, i32 0), i8* getelementptr inbounds ([6 x i8], [6 x i8]* @.str.3, i32 0, i32 0)
  %call72 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str.6, i32 0, i32 0), i8* %cond71)
  %call73 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([3 x i8], [3 x i8]* @.str, i32 0, i32 0), i32 0)
  %call74 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([4 x i8], [4 x i8]* @.str.5, i32 0, i32 0))
  %call75 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([3 x i8], [3 x i8]* @.str, i32 0, i32 0), i32 0)
  %indirect-arg-temp76.realp = getelementptr inbounds { fp128, fp128 }, { fp128, fp128 }* %indirect-arg-temp76, i32 0, i32 0
  %indirect-arg-temp76.imagp = getelementptr inbounds { fp128, fp128 }, { fp128, fp128 }* %indirect-arg-temp76, i32 0, i32 1
  store fp128 0xL00000000000000000000000000000000, fp128* %indirect-arg-temp76.realp, align 16
  store fp128 0xL00000000000000000000000000000000, fp128* %indirect-arg-temp76.imagp, align 16
  %call77 = call i32 @isint({ fp128, fp128 }* byval({ fp128, fp128 }) align 16 %indirect-arg-temp76)
  %tobool78 = icmp ne i32 %call77, 0
  %12 = zext i1 %tobool78 to i64
  %cond79 = select i1 %tobool78, i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.2, i32 0, i32 0), i8* getelementptr inbounds ([6 x i8], [6 x i8]* @.str.3, i32 0, i32 0)
  %call80 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str.6, i32 0, i32 0), i8* %cond79)
  %call81 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([3 x i8], [3 x i8]* @.str.4, i32 0, i32 0), double 3.400000e+00)
  %call82 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([4 x i8], [4 x i8]* @.str.5, i32 0, i32 0))
  %call83 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([3 x i8], [3 x i8]* @.str, i32 0, i32 0), i32 0)
  %indirect-arg-temp84.realp = getelementptr inbounds { fp128, fp128 }, { fp128, fp128 }* %indirect-arg-temp84, i32 0, i32 0
  %indirect-arg-temp84.imagp = getelementptr inbounds { fp128, fp128 }, { fp128, fp128 }* %indirect-arg-temp84, i32 0, i32 1
  store fp128 0xL30000000000000004000B33333333333, fp128* %indirect-arg-temp84.realp, align 16
  store fp128 0xL00000000000000000000000000000000, fp128* %indirect-arg-temp84.imagp, align 16
  %call85 = call i32 @isint({ fp128, fp128 }* byval({ fp128, fp128 }) align 16 %indirect-arg-temp84)
  %tobool86 = icmp ne i32 %call85, 0
  %13 = zext i1 %tobool86 to i64
  %cond87 = select i1 %tobool86, i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.2, i32 0, i32 0), i8* getelementptr inbounds ([6 x i8], [6 x i8]* @.str.3, i32 0, i32 0)
  %call88 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str.6, i32 0, i32 0), i8* %cond87)
  br i1 false, label %complex_mul_imag_nan, label %complex_mul_cont, !prof !2

complex_mul_imag_nan:                             ; preds = %entry
  br i1 false, label %complex_mul_libcall, label %complex_mul_cont, !prof !2

complex_mul_libcall:                              ; preds = %complex_mul_imag_nan
  call void @__mulsc3({ float, float }* sret align 4 %tmp, float 0.000000e+00, float 0.000000e+00, float 0.000000e+00, float 1.000000e+00) #3
  %tmp.realp = getelementptr inbounds { float, float }, { float, float }* %tmp, i32 0, i32 0
  %tmp.real = load float, float* %tmp.realp, align 4
  %tmp.imagp = getelementptr inbounds { float, float }, { float, float }* %tmp, i32 0, i32 1
  %tmp.imag = load float, float* %tmp.imagp, align 4
  br label %complex_mul_cont

complex_mul_cont:                                 ; preds = %complex_mul_libcall, %complex_mul_imag_nan, %entry
  %real_mul_phi = phi float [ 0.000000e+00, %entry ], [ 0.000000e+00, %complex_mul_imag_nan ], [ %tmp.real, %complex_mul_libcall ]
  %imag_mul_phi = phi float [ 0.000000e+00, %entry ], [ 0.000000e+00, %complex_mul_imag_nan ], [ %tmp.imag, %complex_mul_libcall ]
  %add.r = fadd float 5.000000e+00, %real_mul_phi
  %add.i = fadd float 0.000000e+00, %imag_mul_phi
  %conv = fpext float %add.r to double
  %conv89 = fpext float %add.i to double
  %test1.realp = getelementptr inbounds { double, double }, { double, double }* %test1, i32 0, i32 0
  %test1.imagp = getelementptr inbounds { double, double }, { double, double }* %test1, i32 0, i32 1
  store double %conv, double* %test1.realp, align 8
  store double %conv89, double* %test1.imagp, align 8
  %test2.realp = getelementptr inbounds { double, double }, { double, double }* %test2, i32 0, i32 0
  %test2.imagp = getelementptr inbounds { double, double }, { double, double }* %test2, i32 0, i32 1
  store double 0x400B333340000000, double* %test2.realp, align 8
  store double 0.000000e+00, double* %test2.imagp, align 8
  %test3.realp = getelementptr inbounds { double, double }, { double, double }* %test3, i32 0, i32 0
  %test3.imagp = getelementptr inbounds { double, double }, { double, double }* %test3, i32 0, i32 1
  store double 3.000000e+00, double* %test3.realp, align 8
  store double 0.000000e+00, double* %test3.imagp, align 8
  %test4.realp = getelementptr inbounds { double, double }, { double, double }* %test4, i32 0, i32 0
  %test4.imagp = getelementptr inbounds { double, double }, { double, double }* %test4, i32 0, i32 1
  store double 0.000000e+00, double* %test4.realp, align 8
  store double 1.200000e+00, double* %test4.imagp, align 8
  %test1.realp90 = getelementptr inbounds { double, double }, { double, double }* %test1, i32 0, i32 0
  %test1.real = load double, double* %test1.realp90, align 8
  %test1.imagp91 = getelementptr inbounds { double, double }, { double, double }* %test1, i32 0, i32 1
  %test1.imag = load double, double* %test1.imagp91, align 8
  %conv92 = fpext double %test1.real to fp128
  %conv93 = fpext double %test1.imag to fp128
  %indirect-arg-temp94.realp = getelementptr inbounds { fp128, fp128 }, { fp128, fp128 }* %indirect-arg-temp94, i32 0, i32 0
  %indirect-arg-temp94.imagp = getelementptr inbounds { fp128, fp128 }, { fp128, fp128 }* %indirect-arg-temp94, i32 0, i32 1
  store fp128 %conv92, fp128* %indirect-arg-temp94.realp, align 16
  store fp128 %conv93, fp128* %indirect-arg-temp94.imagp, align 16
  %call95 = call i32 @isint({ fp128, fp128 }* byval({ fp128, fp128 }) align 16 %indirect-arg-temp94)
  %tobool96 = icmp ne i32 %call95, 0
  %14 = zext i1 %tobool96 to i64
  %cond97 = select i1 %tobool96, i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.2, i32 0, i32 0), i8* getelementptr inbounds ([6 x i8], [6 x i8]* @.str.3, i32 0, i32 0)
  %call98 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([19 x i8], [19 x i8]* @.str.7, i32 0, i32 0), i8* %cond97)
  %test2.realp99 = getelementptr inbounds { double, double }, { double, double }* %test2, i32 0, i32 0
  %test2.real = load double, double* %test2.realp99, align 8
  %test2.imagp100 = getelementptr inbounds { double, double }, { double, double }* %test2, i32 0, i32 1
  %test2.imag = load double, double* %test2.imagp100, align 8
  %conv101 = fpext double %test2.real to fp128
  %conv102 = fpext double %test2.imag to fp128
  %indirect-arg-temp103.realp = getelementptr inbounds { fp128, fp128 }, { fp128, fp128 }* %indirect-arg-temp103, i32 0, i32 0
  %indirect-arg-temp103.imagp = getelementptr inbounds { fp128, fp128 }, { fp128, fp128 }* %indirect-arg-temp103, i32 0, i32 1
  store fp128 %conv101, fp128* %indirect-arg-temp103.realp, align 16
  store fp128 %conv102, fp128* %indirect-arg-temp103.imagp, align 16
  %call104 = call i32 @isint({ fp128, fp128 }* byval({ fp128, fp128 }) align 16 %indirect-arg-temp103)
  %tobool105 = icmp ne i32 %call104, 0
  %15 = zext i1 %tobool105 to i64
  %cond106 = select i1 %tobool105, i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.2, i32 0, i32 0), i8* getelementptr inbounds ([6 x i8], [6 x i8]* @.str.3, i32 0, i32 0)
  %call107 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([22 x i8], [22 x i8]* @.str.8, i32 0, i32 0), i8* %cond106)
  %test3.realp108 = getelementptr inbounds { double, double }, { double, double }* %test3, i32 0, i32 0
  %test3.real = load double, double* %test3.realp108, align 8
  %test3.imagp109 = getelementptr inbounds { double, double }, { double, double }* %test3, i32 0, i32 1
  %test3.imag = load double, double* %test3.imagp109, align 8
  %conv110 = fpext double %test3.real to fp128
  %conv111 = fpext double %test3.imag to fp128
  %indirect-arg-temp112.realp = getelementptr inbounds { fp128, fp128 }, { fp128, fp128 }* %indirect-arg-temp112, i32 0, i32 0
  %indirect-arg-temp112.imagp = getelementptr inbounds { fp128, fp128 }, { fp128, fp128 }* %indirect-arg-temp112, i32 0, i32 1
  store fp128 %conv110, fp128* %indirect-arg-temp112.realp, align 16
  store fp128 %conv111, fp128* %indirect-arg-temp112.imagp, align 16
  %call113 = call i32 @isint({ fp128, fp128 }* byval({ fp128, fp128 }) align 16 %indirect-arg-temp112)
  %tobool114 = icmp ne i32 %call113, 0
  %16 = zext i1 %tobool114 to i64
  %cond115 = select i1 %tobool114, i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.2, i32 0, i32 0), i8* getelementptr inbounds ([6 x i8], [6 x i8]* @.str.3, i32 0, i32 0)
  %call116 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([20 x i8], [20 x i8]* @.str.9, i32 0, i32 0), i8* %cond115)
  %test4.realp117 = getelementptr inbounds { double, double }, { double, double }* %test4, i32 0, i32 0
  %test4.real = load double, double* %test4.realp117, align 8
  %test4.imagp118 = getelementptr inbounds { double, double }, { double, double }* %test4, i32 0, i32 1
  %test4.imag = load double, double* %test4.imagp118, align 8
  %conv119 = fpext double %test4.real to fp128
  %conv120 = fpext double %test4.imag to fp128
  %indirect-arg-temp121.realp = getelementptr inbounds { fp128, fp128 }, { fp128, fp128 }* %indirect-arg-temp121, i32 0, i32 0
  %indirect-arg-temp121.imagp = getelementptr inbounds { fp128, fp128 }, { fp128, fp128 }* %indirect-arg-temp121, i32 0, i32 1
  store fp128 %conv119, fp128* %indirect-arg-temp121.realp, align 16
  store fp128 %conv120, fp128* %indirect-arg-temp121.imagp, align 16
  %call122 = call i32 @isint({ fp128, fp128 }* byval({ fp128, fp128 }) align 16 %indirect-arg-temp121)
  %tobool123 = icmp ne i32 %call122, 0
  %17 = zext i1 %tobool123 to i64
  %cond124 = select i1 %tobool123, i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.2, i32 0, i32 0), i8* getelementptr inbounds ([6 x i8], [6 x i8]* @.str.3, i32 0, i32 0)
  %call125 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([22 x i8], [22 x i8]* @.str.10, i32 0, i32 0), i8* %cond124)
  %18 = load i32, i32* %retval, align 4
  ret i32 %18
}

declare i32 @printf(i8* %0, ...) #1

; Function Attrs: noinline nounwind optnone
define internal i32 @isint({ fp128, fp128 }* byval({ fp128, fp128 }) align 16 %n) #0 {
entry:
  %n.realp = getelementptr inbounds { fp128, fp128 }, { fp128, fp128 }* %n, i32 0, i32 0
  %n.real = load fp128, fp128* %n.realp, align 16
  %n.imagp = getelementptr inbounds { fp128, fp128 }, { fp128, fp128 }* %n, i32 0, i32 1
  %n.imag = load fp128, fp128* %n.imagp, align 16
  %cmp = fcmp oeq fp128 %n.imag, 0xL00000000000000000000000000000000
  br i1 %cmp, label %land.rhs, label %land.end

land.rhs:                                         ; preds = %entry
  %n.realp1 = getelementptr inbounds { fp128, fp128 }, { fp128, fp128 }* %n, i32 0, i32 0
  %n.real2 = load fp128, fp128* %n.realp1, align 16
  %n.imagp3 = getelementptr inbounds { fp128, fp128 }, { fp128, fp128 }* %n, i32 0, i32 1
  %n.imag4 = load fp128, fp128* %n.imagp3, align 16
  %0 = call fp128 @llvm.nearbyint.f128(fp128 %n.real2)
  %n.realp5 = getelementptr inbounds { fp128, fp128 }, { fp128, fp128 }* %n, i32 0, i32 0
  %n.real6 = load fp128, fp128* %n.realp5, align 16
  %n.imagp7 = getelementptr inbounds { fp128, fp128 }, { fp128, fp128 }* %n, i32 0, i32 1
  %n.imag8 = load fp128, fp128* %n.imagp7, align 16
  %cmp9 = fcmp oeq fp128 %0, %n.real6
  br label %land.end

land.end:                                         ; preds = %land.rhs, %entry
  %1 = phi i1 [ false, %entry ], [ %cmp9, %land.rhs ]
  %land.ext = zext i1 %1 to i32
  ret i32 %land.ext
}

declare void @__mulsc3({ float, float }* %0, float %1, float %2, float %3, float %4)

; Function Attrs: nounwind readnone speculatable willreturn
declare fp128 @llvm.nearbyint.f128(fp128 %0) #2

attributes #0 = { noinline nounwind optnone "correctly-rounded-divide-sqrt-fp-math"="false" "disable-tail-calls"="false" "frame-pointer"="none" "less-precise-fpmad"="false" "min-legal-vector-width"="0" "no-infs-fp-math"="false" "no-jump-tables"="false" "no-nans-fp-math"="false" "no-signed-zeros-fp-math"="false" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="generic" "unsafe-fp-math"="false" "use-soft-float"="false" }
attributes #1 = { "correctly-rounded-divide-sqrt-fp-math"="false" "disable-tail-calls"="false" "frame-pointer"="none" "less-precise-fpmad"="false" "no-infs-fp-math"="false" "no-nans-fp-math"="false" "no-signed-zeros-fp-math"="false" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="generic" "unsafe-fp-math"="false" "use-soft-float"="false" }
attributes #2 = { nounwind readnone speculatable willreturn }
attributes #3 = { nounwind }

!llvm.module.flags = !{!0}
!llvm.ident = !{!1}

!0 = !{i32 1, !"wchar_size", i32 4}
!1 = !{!"clang version 11.0.0 (https://github.com/Jacarte/llvm-project.git 0f6dea67136cc1e0b3d200eb2bb165628970c44b)"}
!2 = !{!"branch_weights", i32 1, i32 1048575}

; extracted candidates

; *****
; For LLVM instruction:
;  %cmp = fcmp oeq fp128 %n.imag, 0xL00000000000000000000000000000000
; Looking for a replacement for:
%0:i1 = var
infer %0

; *****
; For LLVM instruction:
;  %cmp9 = fcmp oeq fp128 %0, %n.real6
; Looking for a replacement for:
%0:i1 = var
infer %0

; *****
; For LLVM instruction:
;  %1 = phi i1 [ false, %entry ], [ %cmp9, %land.rhs ]
; Looking for a replacement for:
%0 = block 2
%1:i1 = var
%2:i1 = phi %0, 0:i1, %1
infer %2

; *****
; For LLVM instruction:
;  %land.ext = zext i1 %1 to i32
; Looking for a replacement for:
%0 = block 2
%1:i1 = var
%2:i1 = phi %0, 0:i1, %1
%3:i32 = zext %2
infer %3
got 1 candidates from LHS

-------------------------------------------------
%0:i1 = var
infer %0


--------------------------------
guess 0

%0:i1 = var ; reservedconst_1

Cost = 0
first query is SAT, returning the model:
reservedconst_1: 0
0 th attempt: second query is SAT-- constant doesn't work
first query is SAT, returning the model:
reservedconst_1: -1
1 th attempt: second query is SAT-- constant doesn't work
first query is UNSAT-- no more guesses
Dataflow Pruned 0/0
There are 1 Guesses
There are 0 RHSs before deduplication
There are 0 RHSs after deduplication
got 2 candidates from LHS

-------------------------------------------------
%0 = block 2
%1:i1 = var
%2:i1 = phi %0, 0:i1, %1
infer %2


--------------------------------
guess 0

%0:i1 = var ; reservedconst_1

Cost = 0
first query is SAT, returning the model:
reservedconst_1: 0
0 th attempt: second query is SAT-- constant doesn't work
first query is SAT, returning the model:
reservedconst_1: -1
1 th attempt: second query is SAT-- constant doesn't work
first query is UNSAT-- no more guesses

--------------------------------
guess 1

%0:i1 = var

Cost = 0
second query is SAT-- constant doesn't work
Dataflow Pruned 0/0
There are 2 Guesses
There are 0 RHSs before deduplication
There are 0 RHSs after deduplication
got 3 candidates from LHS

-------------------------------------------------
%0 = block 2
%1:i1 = var
%2:i1 = phi %0, 0:i1, %1
%3:i32 = zext %2
infer %3


--------------------------------
guess 0

%0:i32 = var ; reservedconst_1

Cost = 0
first query is SAT, returning the model:
reservedconst_1: 0
0 th attempt: second query is SAT-- constant doesn't work
first query is SAT, returning the model:
reservedconst_1: 1
1 th attempt: second query is SAT-- constant doesn't work
first query is UNSAT-- no more guesses
Dataflow Pruned 0/0
There are 1 Guesses
There are 0 RHSs before deduplication
There are 0 RHSs after deduplication
#########################################################
; exiting Souper's runOnFunction() for ./Test_integerness.c.bc:isint()
Total of 0 replacements done on this module
Total of 0 replacements candidates on this module
