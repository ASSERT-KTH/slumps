
Entering the Souper pass's runOnModule()


; entering Souper's runOnFunction() for median()

; ModuleID = './Fivenum.c.bc'
source_filename = "./Fivenum.c"
target datalayout = "e-m:e-p:32:32-i64:64-n32:64-S128"
target triple = "wasm32-unknown-wasi"

@.str = private unnamed_addr constant [29 x i8] c"Array slice cannot be empty\0A\00", align 1
@.str.1 = private unnamed_addr constant [44 x i8] c"Unable to deal with arrays containing NaN\0A\0A\00", align 1
@.str.2 = private unnamed_addr constant [8 x i8] c"%%.%dlf\00", align 1
@.str.3 = private unnamed_addr constant [2 x i8] c"[\00", align 1
@.str.4 = private unnamed_addr constant [3 x i8] c", \00", align 1
@.str.5 = private unnamed_addr constant [4 x i8] c"]\0A\0A\00", align 1
@__const.main.x1 = private unnamed_addr constant [11 x double] [double 1.500000e+01, double 6.000000e+00, double 4.200000e+01, double 4.100000e+01, double 7.000000e+00, double 3.600000e+01, double 4.900000e+01, double 4.000000e+01, double 3.900000e+01, double 4.700000e+01, double 4.300000e+01], align 16
@__const.main.x3 = private unnamed_addr constant [20 x double] [double 0x3FC206A9BD53322C, double 9.748790e-02, double 0x3FFBB3776E4B8D1C, double 0x3FEC0B2450C23A4D, double 0xBFFF35A416A02A82, double 0x3FE780161FFCF58A, double 0xBF9F15F93B95AD51, double 0x3FF777D904E973CD, double 0xBFE7E0FB1CEC49EB, double 0xBFE73A78E23EF9E6, double 0x3FE4731C574E9B6F, double 0x3FE3AE3480E6197A, double 0xBFEFACC0526B06DF, double 0xBFF012584C9D3C91, double 0xBFE4154175962F2C, double 0x3FE52F9BDF192A9E, double 0x3FF0B09EB1059BF6, double 0xBFBA61BCB37A1570, double 0x3FE83F8A39545F7E, double 0x3FD4D7B548A1AF68], align 16
@llvm.used = appending global [1 x i8*] [i8* bitcast (i32 ()* @__main_void to i8*)], section "llvm.metadata"

@__main_void = alias i32 (), i32 ()* @main

; Function Attrs: noinline nounwind optnone
define hidden double @median(double* %x, i32 %start, i32 %end_inclusive) #0 {
entry:
  %retval = alloca double, align 8
  %x.addr = alloca double*, align 4
  %start.addr = alloca i32, align 4
  %end_inclusive.addr = alloca i32, align 4
  %size = alloca i32, align 4
  %m = alloca i32, align 4
  store double* %x, double** %x.addr, align 4
  store i32 %start, i32* %start.addr, align 4
  store i32 %end_inclusive, i32* %end_inclusive.addr, align 4
  %0 = load i32, i32* %end_inclusive.addr, align 4
  %1 = load i32, i32* %start.addr, align 4
  %sub = sub nsw i32 %0, %1
  %add = add nsw i32 %sub, 1
  store i32 %add, i32* %size, align 4
  %2 = load i32, i32* %size, align 4
  %cmp = icmp sle i32 %2, 0
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %call = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([29 x i8], [29 x i8]* @.str, i32 0, i32 0))
  call void @exit(i32 1) #5
  unreachable

if.end:                                           ; preds = %entry
  %3 = load i32, i32* %start.addr, align 4
  %4 = load i32, i32* %size, align 4
  %div = sdiv i32 %4, 2
  %add1 = add nsw i32 %3, %div
  store i32 %add1, i32* %m, align 4
  %5 = load i32, i32* %size, align 4
  %rem = srem i32 %5, 2
  %tobool = icmp ne i32 %rem, 0
  br i1 %tobool, label %if.then2, label %if.end3

if.then2:                                         ; preds = %if.end
  %6 = load double*, double** %x.addr, align 4
  %7 = load i32, i32* %m, align 4
  %arrayidx = getelementptr inbounds double, double* %6, i32 %7
  %8 = load double, double* %arrayidx, align 8
  store double %8, double* %retval, align 8
  br label %return

if.end3:                                          ; preds = %if.end
  %9 = load double*, double** %x.addr, align 4
  %10 = load i32, i32* %m, align 4
  %sub4 = sub nsw i32 %10, 1
  %arrayidx5 = getelementptr inbounds double, double* %9, i32 %sub4
  %11 = load double, double* %arrayidx5, align 8
  %12 = load double*, double** %x.addr, align 4
  %13 = load i32, i32* %m, align 4
  %arrayidx6 = getelementptr inbounds double, double* %12, i32 %13
  %14 = load double, double* %arrayidx6, align 8
  %add7 = fadd double %11, %14
  %div8 = fdiv double %add7, 2.000000e+00
  store double %div8, double* %retval, align 8
  br label %return

return:                                           ; preds = %if.end3, %if.then2
  %15 = load double, double* %retval, align 8
  ret double %15
}

declare i32 @printf(i8* %0, ...) #1

; Function Attrs: noreturn
declare void @exit(i32 %0) #2

; Function Attrs: noinline nounwind optnone
define hidden i32 @compare(i8* %a, i8* %b) #0 {
entry:
  %retval = alloca i32, align 4
  %a.addr = alloca i8*, align 4
  %b.addr = alloca i8*, align 4
  %aa = alloca double, align 8
  %bb = alloca double, align 8
  store i8* %a, i8** %a.addr, align 4
  store i8* %b, i8** %b.addr, align 4
  %0 = load i8*, i8** %a.addr, align 4
  %1 = bitcast i8* %0 to double*
  %2 = load double, double* %1, align 8
  store double %2, double* %aa, align 8
  %3 = load i8*, i8** %b.addr, align 4
  %4 = bitcast i8* %3 to double*
  %5 = load double, double* %4, align 8
  store double %5, double* %bb, align 8
  %6 = load double, double* %aa, align 8
  %7 = load double, double* %bb, align 8
  %cmp = fcmp ogt double %6, %7
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  store i32 1, i32* %retval, align 4
  br label %return

if.end:                                           ; preds = %entry
  %8 = load double, double* %aa, align 8
  %9 = load double, double* %bb, align 8
  %cmp1 = fcmp olt double %8, %9
  br i1 %cmp1, label %if.then2, label %if.end3

if.then2:                                         ; preds = %if.end
  store i32 -1, i32* %retval, align 4
  br label %return

if.end3:                                          ; preds = %if.end
  store i32 0, i32* %retval, align 4
  br label %return

return:                                           ; preds = %if.end3, %if.then2, %if.then
  %10 = load i32, i32* %retval, align 4
  ret i32 %10
}

; Function Attrs: noinline nounwind optnone
define hidden i32 @fivenum(double* %x, double* %result, i32 %x_len) #0 {
entry:
  %retval = alloca i32, align 4
  %x.addr = alloca double*, align 4
  %result.addr = alloca double*, align 4
  %x_len.addr = alloca i32, align 4
  %i = alloca i32, align 4
  %m = alloca i32, align 4
  %lower_end = alloca i32, align 4
  store double* %x, double** %x.addr, align 4
  store double* %result, double** %result.addr, align 4
  store i32 %x_len, i32* %x_len.addr, align 4
  store i32 0, i32* %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %0 = load i32, i32* %i, align 4
  %1 = load i32, i32* %x_len.addr, align 4
  %cmp = icmp slt i32 %0, %1
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %2 = load double*, double** %x.addr, align 4
  %3 = load i32, i32* %i, align 4
  %arrayidx = getelementptr inbounds double, double* %2, i32 %3
  %4 = load double, double* %arrayidx, align 8
  %5 = load double*, double** %x.addr, align 4
  %6 = load i32, i32* %i, align 4
  %arrayidx1 = getelementptr inbounds double, double* %5, i32 %6
  %7 = load double, double* %arrayidx1, align 8
  %cmp2 = fcmp une double %4, %7
  br i1 %cmp2, label %if.then, label %if.end

if.then:                                          ; preds = %for.body
  %call = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([44 x i8], [44 x i8]* @.str.1, i32 0, i32 0))
  store i32 1, i32* %retval, align 4
  br label %return

if.end:                                           ; preds = %for.body
  br label %for.inc

for.inc:                                          ; preds = %if.end
  %8 = load i32, i32* %i, align 4
  %inc = add nsw i32 %8, 1
  store i32 %inc, i32* %i, align 4
  br label %for.cond

for.end:                                          ; preds = %for.cond
  %9 = load double*, double** %x.addr, align 4
  %10 = bitcast double* %9 to i8*
  %11 = load i32, i32* %x_len.addr, align 4
  call void @qsort(i8* %10, i32 %11, i32 8, i32 (i8*, i8*)* @compare)
  %12 = load double*, double** %x.addr, align 4
  %arrayidx3 = getelementptr inbounds double, double* %12, i32 0
  %13 = load double, double* %arrayidx3, align 8
  %14 = load double*, double** %result.addr, align 4
  %arrayidx4 = getelementptr inbounds double, double* %14, i32 0
  store double %13, double* %arrayidx4, align 8
  %15 = load double*, double** %x.addr, align 4
  %16 = load i32, i32* %x_len.addr, align 4
  %sub = sub nsw i32 %16, 1
  %call5 = call double @median(double* %15, i32 0, i32 %sub)
  %17 = load double*, double** %result.addr, align 4
  %arrayidx6 = getelementptr inbounds double, double* %17, i32 2
  store double %call5, double* %arrayidx6, align 8
  %18 = load double*, double** %x.addr, align 4
  %19 = load i32, i32* %x_len.addr, align 4
  %sub7 = sub nsw i32 %19, 1
  %arrayidx8 = getelementptr inbounds double, double* %18, i32 %sub7
  %20 = load double, double* %arrayidx8, align 8
  %21 = load double*, double** %result.addr, align 4
  %arrayidx9 = getelementptr inbounds double, double* %21, i32 4
  store double %20, double* %arrayidx9, align 8
  %22 = load i32, i32* %x_len.addr, align 4
  %div = sdiv i32 %22, 2
  store i32 %div, i32* %m, align 4
  %23 = load i32, i32* %x_len.addr, align 4
  %rem = srem i32 %23, 2
  %tobool = icmp ne i32 %rem, 0
  br i1 %tobool, label %cond.true, label %cond.false

cond.true:                                        ; preds = %for.end
  %24 = load i32, i32* %m, align 4
  br label %cond.end

cond.false:                                       ; preds = %for.end
  %25 = load i32, i32* %m, align 4
  %sub10 = sub nsw i32 %25, 1
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi i32 [ %24, %cond.true ], [ %sub10, %cond.false ]
  store i32 %cond, i32* %lower_end, align 4
  %26 = load double*, double** %x.addr, align 4
  %27 = load i32, i32* %lower_end, align 4
  %call11 = call double @median(double* %26, i32 0, i32 %27)
  %28 = load double*, double** %result.addr, align 4
  %arrayidx12 = getelementptr inbounds double, double* %28, i32 1
  store double %call11, double* %arrayidx12, align 8
  %29 = load double*, double** %x.addr, align 4
  %30 = load i32, i32* %m, align 4
  %31 = load i32, i32* %x_len.addr, align 4
  %sub13 = sub nsw i32 %31, 1
  %call14 = call double @median(double* %29, i32 %30, i32 %sub13)
  %32 = load double*, double** %result.addr, align 4
  %arrayidx15 = getelementptr inbounds double, double* %32, i32 3
  store double %call14, double* %arrayidx15, align 8
  store i32 0, i32* %retval, align 4
  br label %return

return:                                           ; preds = %cond.end, %if.then
  %33 = load i32, i32* %retval, align 4
  ret i32 %33
}

declare void @qsort(i8* %0, i32 %1, i32 %2, i32 (i8*, i8*)* %3) #1

; Function Attrs: noinline nounwind optnone
define hidden i32 @show(double* %result, i32 %places) #0 {
entry:
  %retval = alloca i32, align 4
  %result.addr = alloca double*, align 4
  %places.addr = alloca i32, align 4
  %i = alloca i32, align 4
  %f = alloca [7 x i8], align 1
  store double* %result, double** %result.addr, align 4
  store i32 %places, i32* %places.addr, align 4
  %arraydecay = getelementptr inbounds [7 x i8], [7 x i8]* %f, i32 0, i32 0
  %0 = load i32, i32* %places.addr, align 4
  %call = call i32 (i8*, i8*, ...) @sprintf(i8* %arraydecay, i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str.2, i32 0, i32 0), i32 %0)
  %call1 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([2 x i8], [2 x i8]* @.str.3, i32 0, i32 0))
  store i32 0, i32* %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %1 = load i32, i32* %i, align 4
  %cmp = icmp slt i32 %1, 5
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %arraydecay2 = getelementptr inbounds [7 x i8], [7 x i8]* %f, i32 0, i32 0
  %2 = load double*, double** %result.addr, align 4
  %3 = load i32, i32* %i, align 4
  %arrayidx = getelementptr inbounds double, double* %2, i32 %3
  %4 = load double, double* %arrayidx, align 8
  %call3 = call i32 (i8*, ...) @printf(i8* %arraydecay2, double %4)
  %5 = load i32, i32* %i, align 4
  %cmp4 = icmp slt i32 %5, 4
  br i1 %cmp4, label %if.then, label %if.end

if.then:                                          ; preds = %for.body
  %call5 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([3 x i8], [3 x i8]* @.str.4, i32 0, i32 0))
  br label %if.end

if.end:                                           ; preds = %if.then, %for.body
  br label %for.inc

for.inc:                                          ; preds = %if.end
  %6 = load i32, i32* %i, align 4
  %inc = add nsw i32 %6, 1
  store i32 %inc, i32* %i, align 4
  br label %for.cond

for.end:                                          ; preds = %for.cond
  %call6 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([4 x i8], [4 x i8]* @.str.5, i32 0, i32 0))
  %7 = load i32, i32* %retval, align 4
  ret i32 %7
}

declare i32 @sprintf(i8* %0, i8* %1, ...) #1

; Function Attrs: noinline nounwind optnone
define hidden i32 @main() #0 {
entry:
  %retval = alloca i32, align 4
  %result = alloca [5 x double], align 16
  %x1 = alloca [11 x double], align 16
  %x2 = alloca [6 x double], align 16
  %x3 = alloca [20 x double], align 16
  store i32 0, i32* %retval, align 4
  %0 = bitcast [11 x double]* %x1 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 16 %0, i8* align 16 bitcast ([11 x double]* @__const.main.x1 to i8*), i32 88, i1 false)
  %arraydecay = getelementptr inbounds [11 x double], [11 x double]* %x1, i32 0, i32 0
  %arraydecay1 = getelementptr inbounds [5 x double], [5 x double]* %result, i32 0, i32 0
  %call = call i32 @fivenum(double* %arraydecay, double* %arraydecay1, i32 11)
  %tobool = icmp ne i32 %call, 0
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  %arraydecay2 = getelementptr inbounds [5 x double], [5 x double]* %result, i32 0, i32 0
  %call3 = call i32 @show(double* %arraydecay2, i32 1)
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  %1 = bitcast [6 x double]* %x2 to i8*
  call void @llvm.memset.p0i8.i32(i8* align 16 %1, i8 0, i32 48, i1 false)
  %2 = bitcast i8* %1 to [6 x double]*
  %3 = getelementptr inbounds [6 x double], [6 x double]* %2, i32 0, i32 0
  store double 3.600000e+01, double* %3, align 16
  %4 = getelementptr inbounds [6 x double], [6 x double]* %2, i32 0, i32 1
  store double 4.000000e+01, double* %4, align 8
  %5 = getelementptr inbounds [6 x double], [6 x double]* %2, i32 0, i32 2
  store double 7.000000e+00, double* %5, align 16
  %6 = getelementptr inbounds [6 x double], [6 x double]* %2, i32 0, i32 3
  store double 3.900000e+01, double* %6, align 8
  %7 = getelementptr inbounds [6 x double], [6 x double]* %2, i32 0, i32 4
  store double 4.100000e+01, double* %7, align 16
  %8 = getelementptr inbounds [6 x double], [6 x double]* %2, i32 0, i32 5
  store double 1.500000e+01, double* %8, align 8
  %arraydecay4 = getelementptr inbounds [6 x double], [6 x double]* %x2, i32 0, i32 0
  %arraydecay5 = getelementptr inbounds [5 x double], [5 x double]* %result, i32 0, i32 0
  %call6 = call i32 @fivenum(double* %arraydecay4, double* %arraydecay5, i32 6)
  %tobool7 = icmp ne i32 %call6, 0
  br i1 %tobool7, label %if.end11, label %if.then8

if.then8:                                         ; preds = %if.end
  %arraydecay9 = getelementptr inbounds [5 x double], [5 x double]* %result, i32 0, i32 0
  %call10 = call i32 @show(double* %arraydecay9, i32 1)
  br label %if.end11

if.end11:                                         ; preds = %if.then8, %if.end
  %9 = bitcast [20 x double]* %x3 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 16 %9, i8* align 16 bitcast ([20 x double]* @__const.main.x3 to i8*), i32 160, i1 false)
  %arraydecay12 = getelementptr inbounds [20 x double], [20 x double]* %x3, i32 0, i32 0
  %arraydecay13 = getelementptr inbounds [5 x double], [5 x double]* %result, i32 0, i32 0
  %call14 = call i32 @fivenum(double* %arraydecay12, double* %arraydecay13, i32 20)
  %tobool15 = icmp ne i32 %call14, 0
  br i1 %tobool15, label %if.end19, label %if.then16

if.then16:                                        ; preds = %if.end11
  %arraydecay17 = getelementptr inbounds [5 x double], [5 x double]* %result, i32 0, i32 0
  %call18 = call i32 @show(double* %arraydecay17, i32 9)
  br label %if.end19

if.end19:                                         ; preds = %if.then16, %if.end11
  ret i32 0
}

; Function Attrs: argmemonly nounwind willreturn
declare void @llvm.memcpy.p0i8.p0i8.i32(i8* noalias nocapture writeonly %0, i8* noalias nocapture readonly %1, i32 %2, i1 immarg %3) #3

; Function Attrs: argmemonly nounwind willreturn writeonly
declare void @llvm.memset.p0i8.i32(i8* nocapture writeonly %0, i8 %1, i32 %2, i1 immarg %3) #4

attributes #0 = { noinline nounwind optnone "correctly-rounded-divide-sqrt-fp-math"="false" "disable-tail-calls"="false" "frame-pointer"="none" "less-precise-fpmad"="false" "min-legal-vector-width"="0" "no-infs-fp-math"="false" "no-jump-tables"="false" "no-nans-fp-math"="false" "no-signed-zeros-fp-math"="false" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="generic" "unsafe-fp-math"="false" "use-soft-float"="false" }
attributes #1 = { "correctly-rounded-divide-sqrt-fp-math"="false" "disable-tail-calls"="false" "frame-pointer"="none" "less-precise-fpmad"="false" "no-infs-fp-math"="false" "no-nans-fp-math"="false" "no-signed-zeros-fp-math"="false" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="generic" "unsafe-fp-math"="false" "use-soft-float"="false" }
attributes #2 = { noreturn "correctly-rounded-divide-sqrt-fp-math"="false" "disable-tail-calls"="false" "frame-pointer"="none" "less-precise-fpmad"="false" "no-infs-fp-math"="false" "no-nans-fp-math"="false" "no-signed-zeros-fp-math"="false" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="generic" "unsafe-fp-math"="false" "use-soft-float"="false" }
attributes #3 = { argmemonly nounwind willreturn }
attributes #4 = { argmemonly nounwind willreturn writeonly }
attributes #5 = { noreturn }

!llvm.module.flags = !{!0}
!llvm.ident = !{!1}

!0 = !{i32 1, !"wchar_size", i32 4}
!1 = !{!"clang version 11.0.0 (https://github.com/Jacarte/llvm-project.git 0f6dea67136cc1e0b3d200eb2bb165628970c44b)"}

; extracted candidates

; *****
; For LLVM instruction:
;  %0 = load i32, i32* %end_inclusive.addr, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %1 = load i32, i32* %start.addr, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %sub = sub nsw i32 %0, %1
; Looking for a replacement for:
%0:i32 = var
%1:i32 = var
%2:i32 = subnsw %0, %1
infer %2

; *****
; For LLVM instruction:
;  %add = add nsw i32 %sub, 1
; Looking for a replacement for:
%0:i32 = var
%1:i32 = var
%2:i32 = subnsw %0, %1
%3:i32 = addnsw 1:i32, %2
infer %3

; *****
; For LLVM instruction:
;  %2 = load i32, i32* %size, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %cmp = icmp sle i32 %2, 0
; Looking for a replacement for:
%0:i32 = var
%1:i1 = sle %0, 0:i32
infer %1

; *****
; For LLVM instruction:
;  %3 = load i32, i32* %start.addr, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %4 = load i32, i32* %size, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %div = sdiv i32 %4, 2
; Looking for a replacement for:
%0:i32 = var
%1:i32 = sdiv %0, 2:i32
infer %1

; *****
; For LLVM instruction:
;  %add1 = add nsw i32 %3, %div
; Looking for a replacement for:
%0:i32 = var
%1:i32 = var
%2:i32 = sdiv %1, 2:i32
%3:i32 = addnsw %0, %2
infer %3

; *****
; For LLVM instruction:
;  %5 = load i32, i32* %size, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %rem = srem i32 %5, 2
; Looking for a replacement for:
%0:i32 = var
%1:i32 = srem %0, 2:i32
infer %1

; *****
; For LLVM instruction:
;  %tobool = icmp ne i32 %rem, 0
; Looking for a replacement for:
%0:i32 = var
%1:i32 = srem %0, 2:i32
%2:i1 = ne 0:i32, %1
infer %2

; *****
; For LLVM instruction:
;  %7 = load i32, i32* %m, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %10 = load i32, i32* %m, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %sub4 = sub nsw i32 %10, 1
; Looking for a replacement for:
%0:i32 = var
%1:i32 = subnsw %0, 1:i32
infer %1

; *****
; For LLVM instruction:
;  %13 = load i32, i32* %m, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0
got 1 candidates from LHS

-------------------------------------------------
%0:i32 = var
infer %0


--------------------------------
guess 0

%0:i32 = var ; reservedconst_1

Cost = 0
first query is SAT, returning the model:
reservedconst_1: 0
0 th attempt: second query is SAT-- constant doesn't work
first query is SAT, returning the model:
reservedconst_1: -1
1 th attempt: second query is SAT-- constant doesn't work
first query is UNSAT-- no more guesses
Dataflow Pruned 0/0
There are 1 Guesses
There are 0 RHSs before deduplication
There are 0 RHSs after deduplication
got 3 candidates from LHS

-------------------------------------------------
%0:i32 = var
%1:i32 = var
%2:i32 = subnsw %0, %1
infer %2


--------------------------------
guess 0

%0:i32 = var ; reservedconst_1

Cost = 0
first query is SAT, returning the model:
reservedconst_1: 0
0 th attempt: second query is SAT-- constant doesn't work
first query is SAT, returning the model:
reservedconst_1: 2147418112
1 th attempt: second query is SAT-- constant doesn't work
first query is UNSAT-- no more guesses

--------------------------------
guess 1

%0:i32 = var

Cost = 0
second query is SAT-- constant doesn't work

--------------------------------
guess 2

%0:i32 = var

Cost = 0
second query is SAT-- constant doesn't work
Dataflow Pruned 0/0
There are 3 Guesses
There are 0 RHSs before deduplication
There are 0 RHSs after deduplication
got 4 candidates from LHS

-------------------------------------------------
%0:i32 = var
%1:i32 = var
%2:i32 = subnsw %0, %1
%3:i32 = addnsw 1:i32, %2
infer %3


--------------------------------
guess 0

%0:i32 = var ; reservedconst_1

Cost = 0
first query is SAT, returning the model:
reservedconst_1: 1
0 th attempt: second query is SAT-- constant doesn't work
first query is SAT, returning the model:
reservedconst_1: -2128609279
1 th attempt: second query is SAT-- constant doesn't work
first query is UNSAT-- no more guesses

--------------------------------
guess 1

%0:i32 = var

Cost = 0
second query is SAT-- constant doesn't work

--------------------------------
guess 2

%0:i32 = var

Cost = 0
second query is SAT-- constant doesn't work

--------------------------------
guess 3

%0:i32 = var
%1:i32 = var
%2:i32 = subnsw %0, %1

Cost = 1
second query is SAT-- constant doesn't work
Dataflow Pruned 0/0
There are 4 Guesses
There are 0 RHSs before deduplication
There are 0 RHSs after deduplication
got 2 candidates from LHS

-------------------------------------------------
%0:i32 = var
%1:i1 = sle %0, 0:i32
infer %1


--------------------------------
guess 0

%0:i1 = var ; reservedconst_1

Cost = 0
first query is SAT, returning the model:
reservedconst_1: -1
0 th attempt: second query is SAT-- constant doesn't work
first query is SAT, returning the model:
reservedconst_1: 0
1 th attempt: second query is SAT-- constant doesn't work
first query is UNSAT-- no more guesses
Dataflow Pruned 0/0
There are 1 Guesses
There are 0 RHSs before deduplication
There are 0 RHSs after deduplication
got 2 candidates from LHS

-------------------------------------------------
%0:i32 = var
%1:i32 = sdiv %0, 2:i32
infer %1


--------------------------------
guess 0

%0:i32 = var ; reservedconst_1

Cost = 0
first query is SAT, returning the model:
reservedconst_1: 0
0 th attempt: second query is SAT-- constant doesn't work
first query is SAT, returning the model:
reservedconst_1: 631636206
1 th attempt: second query is SAT-- constant doesn't work
first query is UNSAT-- no more guesses

--------------------------------
guess 1

%0:i32 = var

Cost = 0
second query is SAT-- constant doesn't work
Dataflow Pruned 0/0
There are 2 Guesses
There are 0 RHSs before deduplication
There are 0 RHSs after deduplication
got 4 candidates from LHS

-------------------------------------------------
%0:i32 = var
%1:i32 = var
%2:i32 = sdiv %1, 2:i32
%3:i32 = addnsw %0, %2
infer %3


--------------------------------
guess 0

%0:i32 = var ; reservedconst_1

Cost = 0
first query is SAT, returning the model:
reservedconst_1: 0
0 th attempt: second query is SAT-- constant doesn't work
first query is SAT, returning the model:
reservedconst_1: 536870780
1 th attempt: second query is SAT-- constant doesn't work
first query is UNSAT-- no more guesses

--------------------------------
guess 1

%0:i32 = var

Cost = 0
second query is SAT-- constant doesn't work

--------------------------------
guess 2

%0:i32 = var

Cost = 0
second query is SAT-- constant doesn't work

--------------------------------
guess 3

%0:i32 = var
%1:i32 = sdiv %0, 2:i32

Cost = 5
second query is SAT-- constant doesn't work
Dataflow Pruned 0/0
There are 4 Guesses
There are 0 RHSs before deduplication
There are 0 RHSs after deduplication
got 2 candidates from LHS

-------------------------------------------------
%0:i32 = var
%1:i32 = srem %0, 2:i32
infer %1


--------------------------------
guess 0

%0:i32 = var ; reservedconst_1

Cost = 0
first query is SAT, returning the model:
reservedconst_1: 0
0 th attempt: second query is SAT-- constant doesn't work
first query is SAT, returning the model:
reservedconst_1: 1
1 th attempt: second query is SAT-- constant doesn't work
first query is UNSAT-- no more guesses

--------------------------------
guess 1

%0:i32 = var

Cost = 0
second query is SAT-- constant doesn't work
Dataflow Pruned 0/0
There are 2 Guesses
There are 0 RHSs before deduplication
There are 0 RHSs after deduplication
got 3 candidates from LHS

-------------------------------------------------
%0:i32 = var
%1:i32 = srem %0, 2:i32
%2:i1 = ne 0:i32, %1
infer %2


--------------------------------
guess 0

%0:i1 = var ; reservedconst_1

Cost = 0
first query is SAT, returning the model:
reservedconst_1: 0
0 th attempt: second query is SAT-- constant doesn't work
first query is SAT, returning the model:
reservedconst_1: -1
1 th attempt: second query is SAT-- constant doesn't work
first query is UNSAT-- no more guesses
Dataflow Pruned 0/0
There are 1 Guesses
There are 0 RHSs before deduplication
There are 0 RHSs after deduplication
got 2 candidates from LHS

-------------------------------------------------
%0:i32 = var
%1:i32 = subnsw %0, 1:i32
infer %1


--------------------------------
guess 0

%0:i32 = var ; reservedconst_1

Cost = 0
first query is SAT, returning the model:
reservedconst_1: -1
0 th attempt: second query is SAT-- constant doesn't work
first query is SAT, returning the model:
reservedconst_1: 536870911
1 th attempt: second query is SAT-- constant doesn't work
first query is UNSAT-- no more guesses

--------------------------------
guess 1

%0:i32 = var

Cost = 0
second query is SAT-- constant doesn't work
Dataflow Pruned 0/0
There are 2 Guesses
There are 0 RHSs before deduplication
There are 0 RHSs after deduplication
#########################################################
; exiting Souper's runOnFunction() for median()

; entering Souper's runOnFunction() for compare()

; ModuleID = './Fivenum.c.bc'
source_filename = "./Fivenum.c"
target datalayout = "e-m:e-p:32:32-i64:64-n32:64-S128"
target triple = "wasm32-unknown-wasi"

@.str = private unnamed_addr constant [29 x i8] c"Array slice cannot be empty\0A\00", align 1
@.str.1 = private unnamed_addr constant [44 x i8] c"Unable to deal with arrays containing NaN\0A\0A\00", align 1
@.str.2 = private unnamed_addr constant [8 x i8] c"%%.%dlf\00", align 1
@.str.3 = private unnamed_addr constant [2 x i8] c"[\00", align 1
@.str.4 = private unnamed_addr constant [3 x i8] c", \00", align 1
@.str.5 = private unnamed_addr constant [4 x i8] c"]\0A\0A\00", align 1
@__const.main.x1 = private unnamed_addr constant [11 x double] [double 1.500000e+01, double 6.000000e+00, double 4.200000e+01, double 4.100000e+01, double 7.000000e+00, double 3.600000e+01, double 4.900000e+01, double 4.000000e+01, double 3.900000e+01, double 4.700000e+01, double 4.300000e+01], align 16
@__const.main.x3 = private unnamed_addr constant [20 x double] [double 0x3FC206A9BD53322C, double 9.748790e-02, double 0x3FFBB3776E4B8D1C, double 0x3FEC0B2450C23A4D, double 0xBFFF35A416A02A82, double 0x3FE780161FFCF58A, double 0xBF9F15F93B95AD51, double 0x3FF777D904E973CD, double 0xBFE7E0FB1CEC49EB, double 0xBFE73A78E23EF9E6, double 0x3FE4731C574E9B6F, double 0x3FE3AE3480E6197A, double 0xBFEFACC0526B06DF, double 0xBFF012584C9D3C91, double 0xBFE4154175962F2C, double 0x3FE52F9BDF192A9E, double 0x3FF0B09EB1059BF6, double 0xBFBA61BCB37A1570, double 0x3FE83F8A39545F7E, double 0x3FD4D7B548A1AF68], align 16
@llvm.used = appending global [1 x i8*] [i8* bitcast (i32 ()* @__main_void to i8*)], section "llvm.metadata"

@__main_void = alias i32 (), i32 ()* @main

; Function Attrs: noinline nounwind optnone
define hidden double @median(double* %x, i32 %start, i32 %end_inclusive) #0 {
entry:
  %retval = alloca double, align 8
  %x.addr = alloca double*, align 4
  %start.addr = alloca i32, align 4
  %end_inclusive.addr = alloca i32, align 4
  %size = alloca i32, align 4
  %m = alloca i32, align 4
  store double* %x, double** %x.addr, align 4
  store i32 %start, i32* %start.addr, align 4
  store i32 %end_inclusive, i32* %end_inclusive.addr, align 4
  %0 = load i32, i32* %end_inclusive.addr, align 4
  %1 = load i32, i32* %start.addr, align 4
  %sub = sub nsw i32 %0, %1
  %add = add nsw i32 %sub, 1
  store i32 %add, i32* %size, align 4
  %2 = load i32, i32* %size, align 4
  %cmp = icmp sle i32 %2, 0
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %call = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([29 x i8], [29 x i8]* @.str, i32 0, i32 0))
  call void @exit(i32 1) #5
  unreachable

if.end:                                           ; preds = %entry
  %3 = load i32, i32* %start.addr, align 4
  %4 = load i32, i32* %size, align 4
  %div = sdiv i32 %4, 2
  %add1 = add nsw i32 %3, %div
  store i32 %add1, i32* %m, align 4
  %5 = load i32, i32* %size, align 4
  %rem = srem i32 %5, 2
  %tobool = icmp ne i32 %rem, 0
  br i1 %tobool, label %if.then2, label %if.end3

if.then2:                                         ; preds = %if.end
  %6 = load double*, double** %x.addr, align 4
  %7 = load i32, i32* %m, align 4
  %arrayidx = getelementptr inbounds double, double* %6, i32 %7
  %8 = load double, double* %arrayidx, align 8
  store double %8, double* %retval, align 8
  br label %return

if.end3:                                          ; preds = %if.end
  %9 = load double*, double** %x.addr, align 4
  %10 = load i32, i32* %m, align 4
  %sub4 = sub nsw i32 %10, 1
  %arrayidx5 = getelementptr inbounds double, double* %9, i32 %sub4
  %11 = load double, double* %arrayidx5, align 8
  %12 = load double*, double** %x.addr, align 4
  %13 = load i32, i32* %m, align 4
  %arrayidx6 = getelementptr inbounds double, double* %12, i32 %13
  %14 = load double, double* %arrayidx6, align 8
  %add7 = fadd double %11, %14
  %div8 = fdiv double %add7, 2.000000e+00
  store double %div8, double* %retval, align 8
  br label %return

return:                                           ; preds = %if.end3, %if.then2
  %15 = load double, double* %retval, align 8
  ret double %15
}

declare i32 @printf(i8* %0, ...) #1

; Function Attrs: noreturn
declare void @exit(i32 %0) #2

; Function Attrs: noinline nounwind optnone
define hidden i32 @compare(i8* %a, i8* %b) #0 {
entry:
  %retval = alloca i32, align 4
  %a.addr = alloca i8*, align 4
  %b.addr = alloca i8*, align 4
  %aa = alloca double, align 8
  %bb = alloca double, align 8
  store i8* %a, i8** %a.addr, align 4
  store i8* %b, i8** %b.addr, align 4
  %0 = load i8*, i8** %a.addr, align 4
  %1 = bitcast i8* %0 to double*
  %2 = load double, double* %1, align 8
  store double %2, double* %aa, align 8
  %3 = load i8*, i8** %b.addr, align 4
  %4 = bitcast i8* %3 to double*
  %5 = load double, double* %4, align 8
  store double %5, double* %bb, align 8
  %6 = load double, double* %aa, align 8
  %7 = load double, double* %bb, align 8
  %cmp = fcmp ogt double %6, %7
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  store i32 1, i32* %retval, align 4
  br label %return

if.end:                                           ; preds = %entry
  %8 = load double, double* %aa, align 8
  %9 = load double, double* %bb, align 8
  %cmp1 = fcmp olt double %8, %9
  br i1 %cmp1, label %if.then2, label %if.end3

if.then2:                                         ; preds = %if.end
  store i32 -1, i32* %retval, align 4
  br label %return

if.end3:                                          ; preds = %if.end
  store i32 0, i32* %retval, align 4
  br label %return

return:                                           ; preds = %if.end3, %if.then2, %if.then
  %10 = load i32, i32* %retval, align 4
  ret i32 %10
}

; Function Attrs: noinline nounwind optnone
define hidden i32 @fivenum(double* %x, double* %result, i32 %x_len) #0 {
entry:
  %retval = alloca i32, align 4
  %x.addr = alloca double*, align 4
  %result.addr = alloca double*, align 4
  %x_len.addr = alloca i32, align 4
  %i = alloca i32, align 4
  %m = alloca i32, align 4
  %lower_end = alloca i32, align 4
  store double* %x, double** %x.addr, align 4
  store double* %result, double** %result.addr, align 4
  store i32 %x_len, i32* %x_len.addr, align 4
  store i32 0, i32* %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %0 = load i32, i32* %i, align 4
  %1 = load i32, i32* %x_len.addr, align 4
  %cmp = icmp slt i32 %0, %1
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %2 = load double*, double** %x.addr, align 4
  %3 = load i32, i32* %i, align 4
  %arrayidx = getelementptr inbounds double, double* %2, i32 %3
  %4 = load double, double* %arrayidx, align 8
  %5 = load double*, double** %x.addr, align 4
  %6 = load i32, i32* %i, align 4
  %arrayidx1 = getelementptr inbounds double, double* %5, i32 %6
  %7 = load double, double* %arrayidx1, align 8
  %cmp2 = fcmp une double %4, %7
  br i1 %cmp2, label %if.then, label %if.end

if.then:                                          ; preds = %for.body
  %call = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([44 x i8], [44 x i8]* @.str.1, i32 0, i32 0))
  store i32 1, i32* %retval, align 4
  br label %return

if.end:                                           ; preds = %for.body
  br label %for.inc

for.inc:                                          ; preds = %if.end
  %8 = load i32, i32* %i, align 4
  %inc = add nsw i32 %8, 1
  store i32 %inc, i32* %i, align 4
  br label %for.cond

for.end:                                          ; preds = %for.cond
  %9 = load double*, double** %x.addr, align 4
  %10 = bitcast double* %9 to i8*
  %11 = load i32, i32* %x_len.addr, align 4
  call void @qsort(i8* %10, i32 %11, i32 8, i32 (i8*, i8*)* @compare)
  %12 = load double*, double** %x.addr, align 4
  %arrayidx3 = getelementptr inbounds double, double* %12, i32 0
  %13 = load double, double* %arrayidx3, align 8
  %14 = load double*, double** %result.addr, align 4
  %arrayidx4 = getelementptr inbounds double, double* %14, i32 0
  store double %13, double* %arrayidx4, align 8
  %15 = load double*, double** %x.addr, align 4
  %16 = load i32, i32* %x_len.addr, align 4
  %sub = sub nsw i32 %16, 1
  %call5 = call double @median(double* %15, i32 0, i32 %sub)
  %17 = load double*, double** %result.addr, align 4
  %arrayidx6 = getelementptr inbounds double, double* %17, i32 2
  store double %call5, double* %arrayidx6, align 8
  %18 = load double*, double** %x.addr, align 4
  %19 = load i32, i32* %x_len.addr, align 4
  %sub7 = sub nsw i32 %19, 1
  %arrayidx8 = getelementptr inbounds double, double* %18, i32 %sub7
  %20 = load double, double* %arrayidx8, align 8
  %21 = load double*, double** %result.addr, align 4
  %arrayidx9 = getelementptr inbounds double, double* %21, i32 4
  store double %20, double* %arrayidx9, align 8
  %22 = load i32, i32* %x_len.addr, align 4
  %div = sdiv i32 %22, 2
  store i32 %div, i32* %m, align 4
  %23 = load i32, i32* %x_len.addr, align 4
  %rem = srem i32 %23, 2
  %tobool = icmp ne i32 %rem, 0
  br i1 %tobool, label %cond.true, label %cond.false

cond.true:                                        ; preds = %for.end
  %24 = load i32, i32* %m, align 4
  br label %cond.end

cond.false:                                       ; preds = %for.end
  %25 = load i32, i32* %m, align 4
  %sub10 = sub nsw i32 %25, 1
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi i32 [ %24, %cond.true ], [ %sub10, %cond.false ]
  store i32 %cond, i32* %lower_end, align 4
  %26 = load double*, double** %x.addr, align 4
  %27 = load i32, i32* %lower_end, align 4
  %call11 = call double @median(double* %26, i32 0, i32 %27)
  %28 = load double*, double** %result.addr, align 4
  %arrayidx12 = getelementptr inbounds double, double* %28, i32 1
  store double %call11, double* %arrayidx12, align 8
  %29 = load double*, double** %x.addr, align 4
  %30 = load i32, i32* %m, align 4
  %31 = load i32, i32* %x_len.addr, align 4
  %sub13 = sub nsw i32 %31, 1
  %call14 = call double @median(double* %29, i32 %30, i32 %sub13)
  %32 = load double*, double** %result.addr, align 4
  %arrayidx15 = getelementptr inbounds double, double* %32, i32 3
  store double %call14, double* %arrayidx15, align 8
  store i32 0, i32* %retval, align 4
  br label %return

return:                                           ; preds = %cond.end, %if.then
  %33 = load i32, i32* %retval, align 4
  ret i32 %33
}

declare void @qsort(i8* %0, i32 %1, i32 %2, i32 (i8*, i8*)* %3) #1

; Function Attrs: noinline nounwind optnone
define hidden i32 @show(double* %result, i32 %places) #0 {
entry:
  %retval = alloca i32, align 4
  %result.addr = alloca double*, align 4
  %places.addr = alloca i32, align 4
  %i = alloca i32, align 4
  %f = alloca [7 x i8], align 1
  store double* %result, double** %result.addr, align 4
  store i32 %places, i32* %places.addr, align 4
  %arraydecay = getelementptr inbounds [7 x i8], [7 x i8]* %f, i32 0, i32 0
  %0 = load i32, i32* %places.addr, align 4
  %call = call i32 (i8*, i8*, ...) @sprintf(i8* %arraydecay, i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str.2, i32 0, i32 0), i32 %0)
  %call1 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([2 x i8], [2 x i8]* @.str.3, i32 0, i32 0))
  store i32 0, i32* %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %1 = load i32, i32* %i, align 4
  %cmp = icmp slt i32 %1, 5
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %arraydecay2 = getelementptr inbounds [7 x i8], [7 x i8]* %f, i32 0, i32 0
  %2 = load double*, double** %result.addr, align 4
  %3 = load i32, i32* %i, align 4
  %arrayidx = getelementptr inbounds double, double* %2, i32 %3
  %4 = load double, double* %arrayidx, align 8
  %call3 = call i32 (i8*, ...) @printf(i8* %arraydecay2, double %4)
  %5 = load i32, i32* %i, align 4
  %cmp4 = icmp slt i32 %5, 4
  br i1 %cmp4, label %if.then, label %if.end

if.then:                                          ; preds = %for.body
  %call5 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([3 x i8], [3 x i8]* @.str.4, i32 0, i32 0))
  br label %if.end

if.end:                                           ; preds = %if.then, %for.body
  br label %for.inc

for.inc:                                          ; preds = %if.end
  %6 = load i32, i32* %i, align 4
  %inc = add nsw i32 %6, 1
  store i32 %inc, i32* %i, align 4
  br label %for.cond

for.end:                                          ; preds = %for.cond
  %call6 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([4 x i8], [4 x i8]* @.str.5, i32 0, i32 0))
  %7 = load i32, i32* %retval, align 4
  ret i32 %7
}

declare i32 @sprintf(i8* %0, i8* %1, ...) #1

; Function Attrs: noinline nounwind optnone
define hidden i32 @main() #0 {
entry:
  %retval = alloca i32, align 4
  %result = alloca [5 x double], align 16
  %x1 = alloca [11 x double], align 16
  %x2 = alloca [6 x double], align 16
  %x3 = alloca [20 x double], align 16
  store i32 0, i32* %retval, align 4
  %0 = bitcast [11 x double]* %x1 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 16 %0, i8* align 16 bitcast ([11 x double]* @__const.main.x1 to i8*), i32 88, i1 false)
  %arraydecay = getelementptr inbounds [11 x double], [11 x double]* %x1, i32 0, i32 0
  %arraydecay1 = getelementptr inbounds [5 x double], [5 x double]* %result, i32 0, i32 0
  %call = call i32 @fivenum(double* %arraydecay, double* %arraydecay1, i32 11)
  %tobool = icmp ne i32 %call, 0
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  %arraydecay2 = getelementptr inbounds [5 x double], [5 x double]* %result, i32 0, i32 0
  %call3 = call i32 @show(double* %arraydecay2, i32 1)
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  %1 = bitcast [6 x double]* %x2 to i8*
  call void @llvm.memset.p0i8.i32(i8* align 16 %1, i8 0, i32 48, i1 false)
  %2 = bitcast i8* %1 to [6 x double]*
  %3 = getelementptr inbounds [6 x double], [6 x double]* %2, i32 0, i32 0
  store double 3.600000e+01, double* %3, align 16
  %4 = getelementptr inbounds [6 x double], [6 x double]* %2, i32 0, i32 1
  store double 4.000000e+01, double* %4, align 8
  %5 = getelementptr inbounds [6 x double], [6 x double]* %2, i32 0, i32 2
  store double 7.000000e+00, double* %5, align 16
  %6 = getelementptr inbounds [6 x double], [6 x double]* %2, i32 0, i32 3
  store double 3.900000e+01, double* %6, align 8
  %7 = getelementptr inbounds [6 x double], [6 x double]* %2, i32 0, i32 4
  store double 4.100000e+01, double* %7, align 16
  %8 = getelementptr inbounds [6 x double], [6 x double]* %2, i32 0, i32 5
  store double 1.500000e+01, double* %8, align 8
  %arraydecay4 = getelementptr inbounds [6 x double], [6 x double]* %x2, i32 0, i32 0
  %arraydecay5 = getelementptr inbounds [5 x double], [5 x double]* %result, i32 0, i32 0
  %call6 = call i32 @fivenum(double* %arraydecay4, double* %arraydecay5, i32 6)
  %tobool7 = icmp ne i32 %call6, 0
  br i1 %tobool7, label %if.end11, label %if.then8

if.then8:                                         ; preds = %if.end
  %arraydecay9 = getelementptr inbounds [5 x double], [5 x double]* %result, i32 0, i32 0
  %call10 = call i32 @show(double* %arraydecay9, i32 1)
  br label %if.end11

if.end11:                                         ; preds = %if.then8, %if.end
  %9 = bitcast [20 x double]* %x3 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 16 %9, i8* align 16 bitcast ([20 x double]* @__const.main.x3 to i8*), i32 160, i1 false)
  %arraydecay12 = getelementptr inbounds [20 x double], [20 x double]* %x3, i32 0, i32 0
  %arraydecay13 = getelementptr inbounds [5 x double], [5 x double]* %result, i32 0, i32 0
  %call14 = call i32 @fivenum(double* %arraydecay12, double* %arraydecay13, i32 20)
  %tobool15 = icmp ne i32 %call14, 0
  br i1 %tobool15, label %if.end19, label %if.then16

if.then16:                                        ; preds = %if.end11
  %arraydecay17 = getelementptr inbounds [5 x double], [5 x double]* %result, i32 0, i32 0
  %call18 = call i32 @show(double* %arraydecay17, i32 9)
  br label %if.end19

if.end19:                                         ; preds = %if.then16, %if.end11
  ret i32 0
}

; Function Attrs: argmemonly nounwind willreturn
declare void @llvm.memcpy.p0i8.p0i8.i32(i8* noalias nocapture writeonly %0, i8* noalias nocapture readonly %1, i32 %2, i1 immarg %3) #3

; Function Attrs: argmemonly nounwind willreturn writeonly
declare void @llvm.memset.p0i8.i32(i8* nocapture writeonly %0, i8 %1, i32 %2, i1 immarg %3) #4

attributes #0 = { noinline nounwind optnone "correctly-rounded-divide-sqrt-fp-math"="false" "disable-tail-calls"="false" "frame-pointer"="none" "less-precise-fpmad"="false" "min-legal-vector-width"="0" "no-infs-fp-math"="false" "no-jump-tables"="false" "no-nans-fp-math"="false" "no-signed-zeros-fp-math"="false" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="generic" "unsafe-fp-math"="false" "use-soft-float"="false" }
attributes #1 = { "correctly-rounded-divide-sqrt-fp-math"="false" "disable-tail-calls"="false" "frame-pointer"="none" "less-precise-fpmad"="false" "no-infs-fp-math"="false" "no-nans-fp-math"="false" "no-signed-zeros-fp-math"="false" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="generic" "unsafe-fp-math"="false" "use-soft-float"="false" }
attributes #2 = { noreturn "correctly-rounded-divide-sqrt-fp-math"="false" "disable-tail-calls"="false" "frame-pointer"="none" "less-precise-fpmad"="false" "no-infs-fp-math"="false" "no-nans-fp-math"="false" "no-signed-zeros-fp-math"="false" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="generic" "unsafe-fp-math"="false" "use-soft-float"="false" }
attributes #3 = { argmemonly nounwind willreturn }
attributes #4 = { argmemonly nounwind willreturn writeonly }
attributes #5 = { noreturn }

!llvm.module.flags = !{!0}
!llvm.ident = !{!1}

!0 = !{i32 1, !"wchar_size", i32 4}
!1 = !{!"clang version 11.0.0 (https://github.com/Jacarte/llvm-project.git 0f6dea67136cc1e0b3d200eb2bb165628970c44b)"}

; extracted candidates

; *****
; For LLVM instruction:
;  %cmp = fcmp ogt double %6, %7
; Looking for a replacement for:
%0:i1 = var
infer %0

; *****
; For LLVM instruction:
;  %cmp1 = fcmp olt double %8, %9
; Looking for a replacement for:
%0:i1 = var
infer %0

; *****
; For LLVM instruction:
;  %10 = load i32, i32* %retval, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0
got 1 candidates from LHS

-------------------------------------------------
%0:i1 = var
infer %0


--------------------------------
guess 0

%0:i1 = var ; reservedconst_1

Cost = 0
first query is SAT, returning the model:
reservedconst_1: 0
0 th attempt: second query is SAT-- constant doesn't work
first query is SAT, returning the model:
reservedconst_1: -1
1 th attempt: second query is SAT-- constant doesn't work
first query is UNSAT-- no more guesses
Dataflow Pruned 0/0
There are 1 Guesses
There are 0 RHSs before deduplication
There are 0 RHSs after deduplication
#########################################################
; exiting Souper's runOnFunction() for compare()

; entering Souper's runOnFunction() for fivenum()

; ModuleID = './Fivenum.c.bc'
source_filename = "./Fivenum.c"
target datalayout = "e-m:e-p:32:32-i64:64-n32:64-S128"
target triple = "wasm32-unknown-wasi"

@.str = private unnamed_addr constant [29 x i8] c"Array slice cannot be empty\0A\00", align 1
@.str.1 = private unnamed_addr constant [44 x i8] c"Unable to deal with arrays containing NaN\0A\0A\00", align 1
@.str.2 = private unnamed_addr constant [8 x i8] c"%%.%dlf\00", align 1
@.str.3 = private unnamed_addr constant [2 x i8] c"[\00", align 1
@.str.4 = private unnamed_addr constant [3 x i8] c", \00", align 1
@.str.5 = private unnamed_addr constant [4 x i8] c"]\0A\0A\00", align 1
@__const.main.x1 = private unnamed_addr constant [11 x double] [double 1.500000e+01, double 6.000000e+00, double 4.200000e+01, double 4.100000e+01, double 7.000000e+00, double 3.600000e+01, double 4.900000e+01, double 4.000000e+01, double 3.900000e+01, double 4.700000e+01, double 4.300000e+01], align 16
@__const.main.x3 = private unnamed_addr constant [20 x double] [double 0x3FC206A9BD53322C, double 9.748790e-02, double 0x3FFBB3776E4B8D1C, double 0x3FEC0B2450C23A4D, double 0xBFFF35A416A02A82, double 0x3FE780161FFCF58A, double 0xBF9F15F93B95AD51, double 0x3FF777D904E973CD, double 0xBFE7E0FB1CEC49EB, double 0xBFE73A78E23EF9E6, double 0x3FE4731C574E9B6F, double 0x3FE3AE3480E6197A, double 0xBFEFACC0526B06DF, double 0xBFF012584C9D3C91, double 0xBFE4154175962F2C, double 0x3FE52F9BDF192A9E, double 0x3FF0B09EB1059BF6, double 0xBFBA61BCB37A1570, double 0x3FE83F8A39545F7E, double 0x3FD4D7B548A1AF68], align 16
@llvm.used = appending global [1 x i8*] [i8* bitcast (i32 ()* @__main_void to i8*)], section "llvm.metadata"

@__main_void = alias i32 (), i32 ()* @main

; Function Attrs: noinline nounwind optnone
define hidden double @median(double* %x, i32 %start, i32 %end_inclusive) #0 {
entry:
  %retval = alloca double, align 8
  %x.addr = alloca double*, align 4
  %start.addr = alloca i32, align 4
  %end_inclusive.addr = alloca i32, align 4
  %size = alloca i32, align 4
  %m = alloca i32, align 4
  store double* %x, double** %x.addr, align 4
  store i32 %start, i32* %start.addr, align 4
  store i32 %end_inclusive, i32* %end_inclusive.addr, align 4
  %0 = load i32, i32* %end_inclusive.addr, align 4
  %1 = load i32, i32* %start.addr, align 4
  %sub = sub nsw i32 %0, %1
  %add = add nsw i32 %sub, 1
  store i32 %add, i32* %size, align 4
  %2 = load i32, i32* %size, align 4
  %cmp = icmp sle i32 %2, 0
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %call = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([29 x i8], [29 x i8]* @.str, i32 0, i32 0))
  call void @exit(i32 1) #5
  unreachable

if.end:                                           ; preds = %entry
  %3 = load i32, i32* %start.addr, align 4
  %4 = load i32, i32* %size, align 4
  %div = sdiv i32 %4, 2
  %add1 = add nsw i32 %3, %div
  store i32 %add1, i32* %m, align 4
  %5 = load i32, i32* %size, align 4
  %rem = srem i32 %5, 2
  %tobool = icmp ne i32 %rem, 0
  br i1 %tobool, label %if.then2, label %if.end3

if.then2:                                         ; preds = %if.end
  %6 = load double*, double** %x.addr, align 4
  %7 = load i32, i32* %m, align 4
  %arrayidx = getelementptr inbounds double, double* %6, i32 %7
  %8 = load double, double* %arrayidx, align 8
  store double %8, double* %retval, align 8
  br label %return

if.end3:                                          ; preds = %if.end
  %9 = load double*, double** %x.addr, align 4
  %10 = load i32, i32* %m, align 4
  %sub4 = sub nsw i32 %10, 1
  %arrayidx5 = getelementptr inbounds double, double* %9, i32 %sub4
  %11 = load double, double* %arrayidx5, align 8
  %12 = load double*, double** %x.addr, align 4
  %13 = load i32, i32* %m, align 4
  %arrayidx6 = getelementptr inbounds double, double* %12, i32 %13
  %14 = load double, double* %arrayidx6, align 8
  %add7 = fadd double %11, %14
  %div8 = fdiv double %add7, 2.000000e+00
  store double %div8, double* %retval, align 8
  br label %return

return:                                           ; preds = %if.end3, %if.then2
  %15 = load double, double* %retval, align 8
  ret double %15
}

declare i32 @printf(i8* %0, ...) #1

; Function Attrs: noreturn
declare void @exit(i32 %0) #2

; Function Attrs: noinline nounwind optnone
define hidden i32 @compare(i8* %a, i8* %b) #0 {
entry:
  %retval = alloca i32, align 4
  %a.addr = alloca i8*, align 4
  %b.addr = alloca i8*, align 4
  %aa = alloca double, align 8
  %bb = alloca double, align 8
  store i8* %a, i8** %a.addr, align 4
  store i8* %b, i8** %b.addr, align 4
  %0 = load i8*, i8** %a.addr, align 4
  %1 = bitcast i8* %0 to double*
  %2 = load double, double* %1, align 8
  store double %2, double* %aa, align 8
  %3 = load i8*, i8** %b.addr, align 4
  %4 = bitcast i8* %3 to double*
  %5 = load double, double* %4, align 8
  store double %5, double* %bb, align 8
  %6 = load double, double* %aa, align 8
  %7 = load double, double* %bb, align 8
  %cmp = fcmp ogt double %6, %7
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  store i32 1, i32* %retval, align 4
  br label %return

if.end:                                           ; preds = %entry
  %8 = load double, double* %aa, align 8
  %9 = load double, double* %bb, align 8
  %cmp1 = fcmp olt double %8, %9
  br i1 %cmp1, label %if.then2, label %if.end3

if.then2:                                         ; preds = %if.end
  store i32 -1, i32* %retval, align 4
  br label %return

if.end3:                                          ; preds = %if.end
  store i32 0, i32* %retval, align 4
  br label %return

return:                                           ; preds = %if.end3, %if.then2, %if.then
  %10 = load i32, i32* %retval, align 4
  ret i32 %10
}

; Function Attrs: noinline nounwind optnone
define hidden i32 @fivenum(double* %x, double* %result, i32 %x_len) #0 {
entry:
  %retval = alloca i32, align 4
  %x.addr = alloca double*, align 4
  %result.addr = alloca double*, align 4
  %x_len.addr = alloca i32, align 4
  %i = alloca i32, align 4
  %m = alloca i32, align 4
  %lower_end = alloca i32, align 4
  store double* %x, double** %x.addr, align 4
  store double* %result, double** %result.addr, align 4
  store i32 %x_len, i32* %x_len.addr, align 4
  store i32 0, i32* %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %0 = load i32, i32* %i, align 4
  %1 = load i32, i32* %x_len.addr, align 4
  %cmp = icmp slt i32 %0, %1
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %2 = load double*, double** %x.addr, align 4
  %3 = load i32, i32* %i, align 4
  %arrayidx = getelementptr inbounds double, double* %2, i32 %3
  %4 = load double, double* %arrayidx, align 8
  %5 = load double*, double** %x.addr, align 4
  %6 = load i32, i32* %i, align 4
  %arrayidx1 = getelementptr inbounds double, double* %5, i32 %6
  %7 = load double, double* %arrayidx1, align 8
  %cmp2 = fcmp une double %4, %7
  br i1 %cmp2, label %if.then, label %if.end

if.then:                                          ; preds = %for.body
  %call = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([44 x i8], [44 x i8]* @.str.1, i32 0, i32 0))
  store i32 1, i32* %retval, align 4
  br label %return

if.end:                                           ; preds = %for.body
  br label %for.inc

for.inc:                                          ; preds = %if.end
  %8 = load i32, i32* %i, align 4
  %inc = add nsw i32 %8, 1
  store i32 %inc, i32* %i, align 4
  br label %for.cond

for.end:                                          ; preds = %for.cond
  %9 = load double*, double** %x.addr, align 4
  %10 = bitcast double* %9 to i8*
  %11 = load i32, i32* %x_len.addr, align 4
  call void @qsort(i8* %10, i32 %11, i32 8, i32 (i8*, i8*)* @compare)
  %12 = load double*, double** %x.addr, align 4
  %arrayidx3 = getelementptr inbounds double, double* %12, i32 0
  %13 = load double, double* %arrayidx3, align 8
  %14 = load double*, double** %result.addr, align 4
  %arrayidx4 = getelementptr inbounds double, double* %14, i32 0
  store double %13, double* %arrayidx4, align 8
  %15 = load double*, double** %x.addr, align 4
  %16 = load i32, i32* %x_len.addr, align 4
  %sub = sub nsw i32 %16, 1
  %call5 = call double @median(double* %15, i32 0, i32 %sub)
  %17 = load double*, double** %result.addr, align 4
  %arrayidx6 = getelementptr inbounds double, double* %17, i32 2
  store double %call5, double* %arrayidx6, align 8
  %18 = load double*, double** %x.addr, align 4
  %19 = load i32, i32* %x_len.addr, align 4
  %sub7 = sub nsw i32 %19, 1
  %arrayidx8 = getelementptr inbounds double, double* %18, i32 %sub7
  %20 = load double, double* %arrayidx8, align 8
  %21 = load double*, double** %result.addr, align 4
  %arrayidx9 = getelementptr inbounds double, double* %21, i32 4
  store double %20, double* %arrayidx9, align 8
  %22 = load i32, i32* %x_len.addr, align 4
  %div = sdiv i32 %22, 2
  store i32 %div, i32* %m, align 4
  %23 = load i32, i32* %x_len.addr, align 4
  %rem = srem i32 %23, 2
  %tobool = icmp ne i32 %rem, 0
  br i1 %tobool, label %cond.true, label %cond.false

cond.true:                                        ; preds = %for.end
  %24 = load i32, i32* %m, align 4
  br label %cond.end

cond.false:                                       ; preds = %for.end
  %25 = load i32, i32* %m, align 4
  %sub10 = sub nsw i32 %25, 1
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi i32 [ %24, %cond.true ], [ %sub10, %cond.false ]
  store i32 %cond, i32* %lower_end, align 4
  %26 = load double*, double** %x.addr, align 4
  %27 = load i32, i32* %lower_end, align 4
  %call11 = call double @median(double* %26, i32 0, i32 %27)
  %28 = load double*, double** %result.addr, align 4
  %arrayidx12 = getelementptr inbounds double, double* %28, i32 1
  store double %call11, double* %arrayidx12, align 8
  %29 = load double*, double** %x.addr, align 4
  %30 = load i32, i32* %m, align 4
  %31 = load i32, i32* %x_len.addr, align 4
  %sub13 = sub nsw i32 %31, 1
  %call14 = call double @median(double* %29, i32 %30, i32 %sub13)
  %32 = load double*, double** %result.addr, align 4
  %arrayidx15 = getelementptr inbounds double, double* %32, i32 3
  store double %call14, double* %arrayidx15, align 8
  store i32 0, i32* %retval, align 4
  br label %return

return:                                           ; preds = %cond.end, %if.then
  %33 = load i32, i32* %retval, align 4
  ret i32 %33
}

declare void @qsort(i8* %0, i32 %1, i32 %2, i32 (i8*, i8*)* %3) #1

; Function Attrs: noinline nounwind optnone
define hidden i32 @show(double* %result, i32 %places) #0 {
entry:
  %retval = alloca i32, align 4
  %result.addr = alloca double*, align 4
  %places.addr = alloca i32, align 4
  %i = alloca i32, align 4
  %f = alloca [7 x i8], align 1
  store double* %result, double** %result.addr, align 4
  store i32 %places, i32* %places.addr, align 4
  %arraydecay = getelementptr inbounds [7 x i8], [7 x i8]* %f, i32 0, i32 0
  %0 = load i32, i32* %places.addr, align 4
  %call = call i32 (i8*, i8*, ...) @sprintf(i8* %arraydecay, i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str.2, i32 0, i32 0), i32 %0)
  %call1 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([2 x i8], [2 x i8]* @.str.3, i32 0, i32 0))
  store i32 0, i32* %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %1 = load i32, i32* %i, align 4
  %cmp = icmp slt i32 %1, 5
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %arraydecay2 = getelementptr inbounds [7 x i8], [7 x i8]* %f, i32 0, i32 0
  %2 = load double*, double** %result.addr, align 4
  %3 = load i32, i32* %i, align 4
  %arrayidx = getelementptr inbounds double, double* %2, i32 %3
  %4 = load double, double* %arrayidx, align 8
  %call3 = call i32 (i8*, ...) @printf(i8* %arraydecay2, double %4)
  %5 = load i32, i32* %i, align 4
  %cmp4 = icmp slt i32 %5, 4
  br i1 %cmp4, label %if.then, label %if.end

if.then:                                          ; preds = %for.body
  %call5 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([3 x i8], [3 x i8]* @.str.4, i32 0, i32 0))
  br label %if.end

if.end:                                           ; preds = %if.then, %for.body
  br label %for.inc

for.inc:                                          ; preds = %if.end
  %6 = load i32, i32* %i, align 4
  %inc = add nsw i32 %6, 1
  store i32 %inc, i32* %i, align 4
  br label %for.cond

for.end:                                          ; preds = %for.cond
  %call6 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([4 x i8], [4 x i8]* @.str.5, i32 0, i32 0))
  %7 = load i32, i32* %retval, align 4
  ret i32 %7
}

declare i32 @sprintf(i8* %0, i8* %1, ...) #1

; Function Attrs: noinline nounwind optnone
define hidden i32 @main() #0 {
entry:
  %retval = alloca i32, align 4
  %result = alloca [5 x double], align 16
  %x1 = alloca [11 x double], align 16
  %x2 = alloca [6 x double], align 16
  %x3 = alloca [20 x double], align 16
  store i32 0, i32* %retval, align 4
  %0 = bitcast [11 x double]* %x1 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 16 %0, i8* align 16 bitcast ([11 x double]* @__const.main.x1 to i8*), i32 88, i1 false)
  %arraydecay = getelementptr inbounds [11 x double], [11 x double]* %x1, i32 0, i32 0
  %arraydecay1 = getelementptr inbounds [5 x double], [5 x double]* %result, i32 0, i32 0
  %call = call i32 @fivenum(double* %arraydecay, double* %arraydecay1, i32 11)
  %tobool = icmp ne i32 %call, 0
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  %arraydecay2 = getelementptr inbounds [5 x double], [5 x double]* %result, i32 0, i32 0
  %call3 = call i32 @show(double* %arraydecay2, i32 1)
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  %1 = bitcast [6 x double]* %x2 to i8*
  call void @llvm.memset.p0i8.i32(i8* align 16 %1, i8 0, i32 48, i1 false)
  %2 = bitcast i8* %1 to [6 x double]*
  %3 = getelementptr inbounds [6 x double], [6 x double]* %2, i32 0, i32 0
  store double 3.600000e+01, double* %3, align 16
  %4 = getelementptr inbounds [6 x double], [6 x double]* %2, i32 0, i32 1
  store double 4.000000e+01, double* %4, align 8
  %5 = getelementptr inbounds [6 x double], [6 x double]* %2, i32 0, i32 2
  store double 7.000000e+00, double* %5, align 16
  %6 = getelementptr inbounds [6 x double], [6 x double]* %2, i32 0, i32 3
  store double 3.900000e+01, double* %6, align 8
  %7 = getelementptr inbounds [6 x double], [6 x double]* %2, i32 0, i32 4
  store double 4.100000e+01, double* %7, align 16
  %8 = getelementptr inbounds [6 x double], [6 x double]* %2, i32 0, i32 5
  store double 1.500000e+01, double* %8, align 8
  %arraydecay4 = getelementptr inbounds [6 x double], [6 x double]* %x2, i32 0, i32 0
  %arraydecay5 = getelementptr inbounds [5 x double], [5 x double]* %result, i32 0, i32 0
  %call6 = call i32 @fivenum(double* %arraydecay4, double* %arraydecay5, i32 6)
  %tobool7 = icmp ne i32 %call6, 0
  br i1 %tobool7, label %if.end11, label %if.then8

if.then8:                                         ; preds = %if.end
  %arraydecay9 = getelementptr inbounds [5 x double], [5 x double]* %result, i32 0, i32 0
  %call10 = call i32 @show(double* %arraydecay9, i32 1)
  br label %if.end11

if.end11:                                         ; preds = %if.then8, %if.end
  %9 = bitcast [20 x double]* %x3 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 16 %9, i8* align 16 bitcast ([20 x double]* @__const.main.x3 to i8*), i32 160, i1 false)
  %arraydecay12 = getelementptr inbounds [20 x double], [20 x double]* %x3, i32 0, i32 0
  %arraydecay13 = getelementptr inbounds [5 x double], [5 x double]* %result, i32 0, i32 0
  %call14 = call i32 @fivenum(double* %arraydecay12, double* %arraydecay13, i32 20)
  %tobool15 = icmp ne i32 %call14, 0
  br i1 %tobool15, label %if.end19, label %if.then16

if.then16:                                        ; preds = %if.end11
  %arraydecay17 = getelementptr inbounds [5 x double], [5 x double]* %result, i32 0, i32 0
  %call18 = call i32 @show(double* %arraydecay17, i32 9)
  br label %if.end19

if.end19:                                         ; preds = %if.then16, %if.end11
  ret i32 0
}

; Function Attrs: argmemonly nounwind willreturn
declare void @llvm.memcpy.p0i8.p0i8.i32(i8* noalias nocapture writeonly %0, i8* noalias nocapture readonly %1, i32 %2, i1 immarg %3) #3

; Function Attrs: argmemonly nounwind willreturn writeonly
declare void @llvm.memset.p0i8.i32(i8* nocapture writeonly %0, i8 %1, i32 %2, i1 immarg %3) #4

attributes #0 = { noinline nounwind optnone "correctly-rounded-divide-sqrt-fp-math"="false" "disable-tail-calls"="false" "frame-pointer"="none" "less-precise-fpmad"="false" "min-legal-vector-width"="0" "no-infs-fp-math"="false" "no-jump-tables"="false" "no-nans-fp-math"="false" "no-signed-zeros-fp-math"="false" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="generic" "unsafe-fp-math"="false" "use-soft-float"="false" }
attributes #1 = { "correctly-rounded-divide-sqrt-fp-math"="false" "disable-tail-calls"="false" "frame-pointer"="none" "less-precise-fpmad"="false" "no-infs-fp-math"="false" "no-nans-fp-math"="false" "no-signed-zeros-fp-math"="false" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="generic" "unsafe-fp-math"="false" "use-soft-float"="false" }
attributes #2 = { noreturn "correctly-rounded-divide-sqrt-fp-math"="false" "disable-tail-calls"="false" "frame-pointer"="none" "less-precise-fpmad"="false" "no-infs-fp-math"="false" "no-nans-fp-math"="false" "no-signed-zeros-fp-math"="false" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="generic" "unsafe-fp-math"="false" "use-soft-float"="false" }
attributes #3 = { argmemonly nounwind willreturn }
attributes #4 = { argmemonly nounwind willreturn writeonly }
attributes #5 = { noreturn }

!llvm.module.flags = !{!0}
!llvm.ident = !{!1}

!0 = !{i32 1, !"wchar_size", i32 4}
!1 = !{!"clang version 11.0.0 (https://github.com/Jacarte/llvm-project.git 0f6dea67136cc1e0b3d200eb2bb165628970c44b)"}

; extracted candidates

; *****
; For LLVM instruction:
;  %0 = load i32, i32* %i, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %1 = load i32, i32* %x_len.addr, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %cmp = icmp slt i32 %0, %1
; Looking for a replacement for:
%0:i32 = var
%1:i32 = var
%2:i1 = slt %0, %1
infer %2

; *****
; For LLVM instruction:
;  %3 = load i32, i32* %i, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %6 = load i32, i32* %i, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %cmp2 = fcmp une double %4, %7
; Looking for a replacement for:
%0:i1 = var
infer %0

; *****
; For LLVM instruction:
;  %8 = load i32, i32* %i, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %inc = add nsw i32 %8, 1
; Looking for a replacement for:
%0:i32 = var
%1:i32 = addnsw 1:i32, %0
infer %1

; *****
; For LLVM instruction:
;  %11 = load i32, i32* %x_len.addr, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %16 = load i32, i32* %x_len.addr, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %sub = sub nsw i32 %16, 1
; Looking for a replacement for:
%0:i32 = var
%1:i32 = subnsw %0, 1:i32
infer %1

; *****
; For LLVM instruction:
;  %19 = load i32, i32* %x_len.addr, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %sub7 = sub nsw i32 %19, 1
; Looking for a replacement for:
%0:i32 = var
%1:i32 = subnsw %0, 1:i32
infer %1

; *****
; For LLVM instruction:
;  %22 = load i32, i32* %x_len.addr, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %div = sdiv i32 %22, 2
; Looking for a replacement for:
%0:i32 = var
%1:i32 = sdiv %0, 2:i32
infer %1

; *****
; For LLVM instruction:
;  %23 = load i32, i32* %x_len.addr, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %rem = srem i32 %23, 2
; Looking for a replacement for:
%0:i32 = var
%1:i32 = srem %0, 2:i32
infer %1

; *****
; For LLVM instruction:
;  %tobool = icmp ne i32 %rem, 0
; Looking for a replacement for:
%0:i32 = var
%1:i32 = srem %0, 2:i32
%2:i1 = ne 0:i32, %1
infer %2

; *****
; For LLVM instruction:
;  %24 = load i32, i32* %m, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %25 = load i32, i32* %m, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %sub10 = sub nsw i32 %25, 1
; Looking for a replacement for:
%0:i32 = var
%1:i32 = subnsw %0, 1:i32
infer %1

; *****
; For LLVM instruction:
;  %cond = phi i32 [ %24, %cond.true ], [ %sub10, %cond.false ]
; Looking for a replacement for:
%0 = block 2
%1:i32 = var
%2:i32 = var
%3:i32 = subnsw %2, 1:i32
%4:i32 = phi %0, %1, %3
infer %4

; *****
; For LLVM instruction:
;  %27 = load i32, i32* %lower_end, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %30 = load i32, i32* %m, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %31 = load i32, i32* %x_len.addr, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %sub13 = sub nsw i32 %31, 1
; Looking for a replacement for:
%0:i32 = var
%1:i32 = subnsw %0, 1:i32
infer %1

; *****
; For LLVM instruction:
;  %33 = load i32, i32* %retval, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0
got 3 candidates from LHS

-------------------------------------------------
%0:i32 = var
%1:i32 = var
%2:i1 = slt %0, %1
infer %2


--------------------------------
guess 0

%0:i1 = var ; reservedconst_1

Cost = 0
first query is SAT, returning the model:
reservedconst_1: 0
0 th attempt: second query is SAT-- constant doesn't work
first query is SAT, returning the model:
reservedconst_1: -1
1 th attempt: second query is SAT-- constant doesn't work
first query is UNSAT-- no more guesses
Dataflow Pruned 0/0
There are 1 Guesses
There are 0 RHSs before deduplication
There are 0 RHSs after deduplication
got 2 candidates from LHS

-------------------------------------------------
%0:i32 = var
%1:i32 = addnsw 1:i32, %0
infer %1


--------------------------------
guess 0

%0:i32 = var ; reservedconst_1

Cost = 0
first query is SAT, returning the model:
reservedconst_1: 1
0 th attempt: second query is SAT-- constant doesn't work
first query is SAT, returning the model:
reservedconst_1: 268435457
1 th attempt: second query is SAT-- constant doesn't work
first query is UNSAT-- no more guesses

--------------------------------
guess 1

%0:i32 = var

Cost = 0
second query is SAT-- constant doesn't work
Dataflow Pruned 0/0
There are 2 Guesses
There are 0 RHSs before deduplication
There are 0 RHSs after deduplication
got 4 candidates from LHS

-------------------------------------------------
%0 = block 2
%1:i32 = var
%2:i32 = var
%3:i32 = subnsw %2, 1:i32
%4:i32 = phi %0, %1, %3
infer %4


--------------------------------
guess 0

%0:i32 = var ; reservedconst_1

Cost = 0
first query is SAT, returning the model:
reservedconst_1: -1
0 th attempt: second query is SAT-- constant doesn't work
first query is SAT, returning the model:
reservedconst_1: 0
1 th attempt: second query is SAT-- constant doesn't work
first query is UNSAT-- no more guesses

--------------------------------
guess 1

%0:i32 = var

Cost = 0
second query is SAT-- constant doesn't work

--------------------------------
guess 2

%0:i32 = var

Cost = 0
second query is SAT-- constant doesn't work

--------------------------------
guess 3

%0:i32 = var
%1:i32 = subnsw %0, 1:i32

Cost = 1
second query is SAT-- constant doesn't work
Dataflow Pruned 0/0
There are 4 Guesses
There are 0 RHSs before deduplication
There are 0 RHSs after deduplication
#########################################################
; exiting Souper's runOnFunction() for fivenum()

; entering Souper's runOnFunction() for show()

; ModuleID = './Fivenum.c.bc'
source_filename = "./Fivenum.c"
target datalayout = "e-m:e-p:32:32-i64:64-n32:64-S128"
target triple = "wasm32-unknown-wasi"

@.str = private unnamed_addr constant [29 x i8] c"Array slice cannot be empty\0A\00", align 1
@.str.1 = private unnamed_addr constant [44 x i8] c"Unable to deal with arrays containing NaN\0A\0A\00", align 1
@.str.2 = private unnamed_addr constant [8 x i8] c"%%.%dlf\00", align 1
@.str.3 = private unnamed_addr constant [2 x i8] c"[\00", align 1
@.str.4 = private unnamed_addr constant [3 x i8] c", \00", align 1
@.str.5 = private unnamed_addr constant [4 x i8] c"]\0A\0A\00", align 1
@__const.main.x1 = private unnamed_addr constant [11 x double] [double 1.500000e+01, double 6.000000e+00, double 4.200000e+01, double 4.100000e+01, double 7.000000e+00, double 3.600000e+01, double 4.900000e+01, double 4.000000e+01, double 3.900000e+01, double 4.700000e+01, double 4.300000e+01], align 16
@__const.main.x3 = private unnamed_addr constant [20 x double] [double 0x3FC206A9BD53322C, double 9.748790e-02, double 0x3FFBB3776E4B8D1C, double 0x3FEC0B2450C23A4D, double 0xBFFF35A416A02A82, double 0x3FE780161FFCF58A, double 0xBF9F15F93B95AD51, double 0x3FF777D904E973CD, double 0xBFE7E0FB1CEC49EB, double 0xBFE73A78E23EF9E6, double 0x3FE4731C574E9B6F, double 0x3FE3AE3480E6197A, double 0xBFEFACC0526B06DF, double 0xBFF012584C9D3C91, double 0xBFE4154175962F2C, double 0x3FE52F9BDF192A9E, double 0x3FF0B09EB1059BF6, double 0xBFBA61BCB37A1570, double 0x3FE83F8A39545F7E, double 0x3FD4D7B548A1AF68], align 16
@llvm.used = appending global [1 x i8*] [i8* bitcast (i32 ()* @__main_void to i8*)], section "llvm.metadata"

@__main_void = alias i32 (), i32 ()* @main

; Function Attrs: noinline nounwind optnone
define hidden double @median(double* %x, i32 %start, i32 %end_inclusive) #0 {
entry:
  %retval = alloca double, align 8
  %x.addr = alloca double*, align 4
  %start.addr = alloca i32, align 4
  %end_inclusive.addr = alloca i32, align 4
  %size = alloca i32, align 4
  %m = alloca i32, align 4
  store double* %x, double** %x.addr, align 4
  store i32 %start, i32* %start.addr, align 4
  store i32 %end_inclusive, i32* %end_inclusive.addr, align 4
  %0 = load i32, i32* %end_inclusive.addr, align 4
  %1 = load i32, i32* %start.addr, align 4
  %sub = sub nsw i32 %0, %1
  %add = add nsw i32 %sub, 1
  store i32 %add, i32* %size, align 4
  %2 = load i32, i32* %size, align 4
  %cmp = icmp sle i32 %2, 0
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %call = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([29 x i8], [29 x i8]* @.str, i32 0, i32 0))
  call void @exit(i32 1) #5
  unreachable

if.end:                                           ; preds = %entry
  %3 = load i32, i32* %start.addr, align 4
  %4 = load i32, i32* %size, align 4
  %div = sdiv i32 %4, 2
  %add1 = add nsw i32 %3, %div
  store i32 %add1, i32* %m, align 4
  %5 = load i32, i32* %size, align 4
  %rem = srem i32 %5, 2
  %tobool = icmp ne i32 %rem, 0
  br i1 %tobool, label %if.then2, label %if.end3

if.then2:                                         ; preds = %if.end
  %6 = load double*, double** %x.addr, align 4
  %7 = load i32, i32* %m, align 4
  %arrayidx = getelementptr inbounds double, double* %6, i32 %7
  %8 = load double, double* %arrayidx, align 8
  store double %8, double* %retval, align 8
  br label %return

if.end3:                                          ; preds = %if.end
  %9 = load double*, double** %x.addr, align 4
  %10 = load i32, i32* %m, align 4
  %sub4 = sub nsw i32 %10, 1
  %arrayidx5 = getelementptr inbounds double, double* %9, i32 %sub4
  %11 = load double, double* %arrayidx5, align 8
  %12 = load double*, double** %x.addr, align 4
  %13 = load i32, i32* %m, align 4
  %arrayidx6 = getelementptr inbounds double, double* %12, i32 %13
  %14 = load double, double* %arrayidx6, align 8
  %add7 = fadd double %11, %14
  %div8 = fdiv double %add7, 2.000000e+00
  store double %div8, double* %retval, align 8
  br label %return

return:                                           ; preds = %if.end3, %if.then2
  %15 = load double, double* %retval, align 8
  ret double %15
}

declare i32 @printf(i8* %0, ...) #1

; Function Attrs: noreturn
declare void @exit(i32 %0) #2

; Function Attrs: noinline nounwind optnone
define hidden i32 @compare(i8* %a, i8* %b) #0 {
entry:
  %retval = alloca i32, align 4
  %a.addr = alloca i8*, align 4
  %b.addr = alloca i8*, align 4
  %aa = alloca double, align 8
  %bb = alloca double, align 8
  store i8* %a, i8** %a.addr, align 4
  store i8* %b, i8** %b.addr, align 4
  %0 = load i8*, i8** %a.addr, align 4
  %1 = bitcast i8* %0 to double*
  %2 = load double, double* %1, align 8
  store double %2, double* %aa, align 8
  %3 = load i8*, i8** %b.addr, align 4
  %4 = bitcast i8* %3 to double*
  %5 = load double, double* %4, align 8
  store double %5, double* %bb, align 8
  %6 = load double, double* %aa, align 8
  %7 = load double, double* %bb, align 8
  %cmp = fcmp ogt double %6, %7
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  store i32 1, i32* %retval, align 4
  br label %return

if.end:                                           ; preds = %entry
  %8 = load double, double* %aa, align 8
  %9 = load double, double* %bb, align 8
  %cmp1 = fcmp olt double %8, %9
  br i1 %cmp1, label %if.then2, label %if.end3

if.then2:                                         ; preds = %if.end
  store i32 -1, i32* %retval, align 4
  br label %return

if.end3:                                          ; preds = %if.end
  store i32 0, i32* %retval, align 4
  br label %return

return:                                           ; preds = %if.end3, %if.then2, %if.then
  %10 = load i32, i32* %retval, align 4
  ret i32 %10
}

; Function Attrs: noinline nounwind optnone
define hidden i32 @fivenum(double* %x, double* %result, i32 %x_len) #0 {
entry:
  %retval = alloca i32, align 4
  %x.addr = alloca double*, align 4
  %result.addr = alloca double*, align 4
  %x_len.addr = alloca i32, align 4
  %i = alloca i32, align 4
  %m = alloca i32, align 4
  %lower_end = alloca i32, align 4
  store double* %x, double** %x.addr, align 4
  store double* %result, double** %result.addr, align 4
  store i32 %x_len, i32* %x_len.addr, align 4
  store i32 0, i32* %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %0 = load i32, i32* %i, align 4
  %1 = load i32, i32* %x_len.addr, align 4
  %cmp = icmp slt i32 %0, %1
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %2 = load double*, double** %x.addr, align 4
  %3 = load i32, i32* %i, align 4
  %arrayidx = getelementptr inbounds double, double* %2, i32 %3
  %4 = load double, double* %arrayidx, align 8
  %5 = load double*, double** %x.addr, align 4
  %6 = load i32, i32* %i, align 4
  %arrayidx1 = getelementptr inbounds double, double* %5, i32 %6
  %7 = load double, double* %arrayidx1, align 8
  %cmp2 = fcmp une double %4, %7
  br i1 %cmp2, label %if.then, label %if.end

if.then:                                          ; preds = %for.body
  %call = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([44 x i8], [44 x i8]* @.str.1, i32 0, i32 0))
  store i32 1, i32* %retval, align 4
  br label %return

if.end:                                           ; preds = %for.body
  br label %for.inc

for.inc:                                          ; preds = %if.end
  %8 = load i32, i32* %i, align 4
  %inc = add nsw i32 %8, 1
  store i32 %inc, i32* %i, align 4
  br label %for.cond

for.end:                                          ; preds = %for.cond
  %9 = load double*, double** %x.addr, align 4
  %10 = bitcast double* %9 to i8*
  %11 = load i32, i32* %x_len.addr, align 4
  call void @qsort(i8* %10, i32 %11, i32 8, i32 (i8*, i8*)* @compare)
  %12 = load double*, double** %x.addr, align 4
  %arrayidx3 = getelementptr inbounds double, double* %12, i32 0
  %13 = load double, double* %arrayidx3, align 8
  %14 = load double*, double** %result.addr, align 4
  %arrayidx4 = getelementptr inbounds double, double* %14, i32 0
  store double %13, double* %arrayidx4, align 8
  %15 = load double*, double** %x.addr, align 4
  %16 = load i32, i32* %x_len.addr, align 4
  %sub = sub nsw i32 %16, 1
  %call5 = call double @median(double* %15, i32 0, i32 %sub)
  %17 = load double*, double** %result.addr, align 4
  %arrayidx6 = getelementptr inbounds double, double* %17, i32 2
  store double %call5, double* %arrayidx6, align 8
  %18 = load double*, double** %x.addr, align 4
  %19 = load i32, i32* %x_len.addr, align 4
  %sub7 = sub nsw i32 %19, 1
  %arrayidx8 = getelementptr inbounds double, double* %18, i32 %sub7
  %20 = load double, double* %arrayidx8, align 8
  %21 = load double*, double** %result.addr, align 4
  %arrayidx9 = getelementptr inbounds double, double* %21, i32 4
  store double %20, double* %arrayidx9, align 8
  %22 = load i32, i32* %x_len.addr, align 4
  %div = sdiv i32 %22, 2
  store i32 %div, i32* %m, align 4
  %23 = load i32, i32* %x_len.addr, align 4
  %rem = srem i32 %23, 2
  %tobool = icmp ne i32 %rem, 0
  br i1 %tobool, label %cond.true, label %cond.false

cond.true:                                        ; preds = %for.end
  %24 = load i32, i32* %m, align 4
  br label %cond.end

cond.false:                                       ; preds = %for.end
  %25 = load i32, i32* %m, align 4
  %sub10 = sub nsw i32 %25, 1
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi i32 [ %24, %cond.true ], [ %sub10, %cond.false ]
  store i32 %cond, i32* %lower_end, align 4
  %26 = load double*, double** %x.addr, align 4
  %27 = load i32, i32* %lower_end, align 4
  %call11 = call double @median(double* %26, i32 0, i32 %27)
  %28 = load double*, double** %result.addr, align 4
  %arrayidx12 = getelementptr inbounds double, double* %28, i32 1
  store double %call11, double* %arrayidx12, align 8
  %29 = load double*, double** %x.addr, align 4
  %30 = load i32, i32* %m, align 4
  %31 = load i32, i32* %x_len.addr, align 4
  %sub13 = sub nsw i32 %31, 1
  %call14 = call double @median(double* %29, i32 %30, i32 %sub13)
  %32 = load double*, double** %result.addr, align 4
  %arrayidx15 = getelementptr inbounds double, double* %32, i32 3
  store double %call14, double* %arrayidx15, align 8
  store i32 0, i32* %retval, align 4
  br label %return

return:                                           ; preds = %cond.end, %if.then
  %33 = load i32, i32* %retval, align 4
  ret i32 %33
}

declare void @qsort(i8* %0, i32 %1, i32 %2, i32 (i8*, i8*)* %3) #1

; Function Attrs: noinline nounwind optnone
define hidden i32 @show(double* %result, i32 %places) #0 {
entry:
  %retval = alloca i32, align 4
  %result.addr = alloca double*, align 4
  %places.addr = alloca i32, align 4
  %i = alloca i32, align 4
  %f = alloca [7 x i8], align 1
  store double* %result, double** %result.addr, align 4
  store i32 %places, i32* %places.addr, align 4
  %arraydecay = getelementptr inbounds [7 x i8], [7 x i8]* %f, i32 0, i32 0
  %0 = load i32, i32* %places.addr, align 4
  %call = call i32 (i8*, i8*, ...) @sprintf(i8* %arraydecay, i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str.2, i32 0, i32 0), i32 %0)
  %call1 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([2 x i8], [2 x i8]* @.str.3, i32 0, i32 0))
  store i32 0, i32* %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %1 = load i32, i32* %i, align 4
  %cmp = icmp slt i32 %1, 5
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %arraydecay2 = getelementptr inbounds [7 x i8], [7 x i8]* %f, i32 0, i32 0
  %2 = load double*, double** %result.addr, align 4
  %3 = load i32, i32* %i, align 4
  %arrayidx = getelementptr inbounds double, double* %2, i32 %3
  %4 = load double, double* %arrayidx, align 8
  %call3 = call i32 (i8*, ...) @printf(i8* %arraydecay2, double %4)
  %5 = load i32, i32* %i, align 4
  %cmp4 = icmp slt i32 %5, 4
  br i1 %cmp4, label %if.then, label %if.end

if.then:                                          ; preds = %for.body
  %call5 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([3 x i8], [3 x i8]* @.str.4, i32 0, i32 0))
  br label %if.end

if.end:                                           ; preds = %if.then, %for.body
  br label %for.inc

for.inc:                                          ; preds = %if.end
  %6 = load i32, i32* %i, align 4
  %inc = add nsw i32 %6, 1
  store i32 %inc, i32* %i, align 4
  br label %for.cond

for.end:                                          ; preds = %for.cond
  %call6 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([4 x i8], [4 x i8]* @.str.5, i32 0, i32 0))
  %7 = load i32, i32* %retval, align 4
  ret i32 %7
}

declare i32 @sprintf(i8* %0, i8* %1, ...) #1

; Function Attrs: noinline nounwind optnone
define hidden i32 @main() #0 {
entry:
  %retval = alloca i32, align 4
  %result = alloca [5 x double], align 16
  %x1 = alloca [11 x double], align 16
  %x2 = alloca [6 x double], align 16
  %x3 = alloca [20 x double], align 16
  store i32 0, i32* %retval, align 4
  %0 = bitcast [11 x double]* %x1 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 16 %0, i8* align 16 bitcast ([11 x double]* @__const.main.x1 to i8*), i32 88, i1 false)
  %arraydecay = getelementptr inbounds [11 x double], [11 x double]* %x1, i32 0, i32 0
  %arraydecay1 = getelementptr inbounds [5 x double], [5 x double]* %result, i32 0, i32 0
  %call = call i32 @fivenum(double* %arraydecay, double* %arraydecay1, i32 11)
  %tobool = icmp ne i32 %call, 0
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  %arraydecay2 = getelementptr inbounds [5 x double], [5 x double]* %result, i32 0, i32 0
  %call3 = call i32 @show(double* %arraydecay2, i32 1)
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  %1 = bitcast [6 x double]* %x2 to i8*
  call void @llvm.memset.p0i8.i32(i8* align 16 %1, i8 0, i32 48, i1 false)
  %2 = bitcast i8* %1 to [6 x double]*
  %3 = getelementptr inbounds [6 x double], [6 x double]* %2, i32 0, i32 0
  store double 3.600000e+01, double* %3, align 16
  %4 = getelementptr inbounds [6 x double], [6 x double]* %2, i32 0, i32 1
  store double 4.000000e+01, double* %4, align 8
  %5 = getelementptr inbounds [6 x double], [6 x double]* %2, i32 0, i32 2
  store double 7.000000e+00, double* %5, align 16
  %6 = getelementptr inbounds [6 x double], [6 x double]* %2, i32 0, i32 3
  store double 3.900000e+01, double* %6, align 8
  %7 = getelementptr inbounds [6 x double], [6 x double]* %2, i32 0, i32 4
  store double 4.100000e+01, double* %7, align 16
  %8 = getelementptr inbounds [6 x double], [6 x double]* %2, i32 0, i32 5
  store double 1.500000e+01, double* %8, align 8
  %arraydecay4 = getelementptr inbounds [6 x double], [6 x double]* %x2, i32 0, i32 0
  %arraydecay5 = getelementptr inbounds [5 x double], [5 x double]* %result, i32 0, i32 0
  %call6 = call i32 @fivenum(double* %arraydecay4, double* %arraydecay5, i32 6)
  %tobool7 = icmp ne i32 %call6, 0
  br i1 %tobool7, label %if.end11, label %if.then8

if.then8:                                         ; preds = %if.end
  %arraydecay9 = getelementptr inbounds [5 x double], [5 x double]* %result, i32 0, i32 0
  %call10 = call i32 @show(double* %arraydecay9, i32 1)
  br label %if.end11

if.end11:                                         ; preds = %if.then8, %if.end
  %9 = bitcast [20 x double]* %x3 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 16 %9, i8* align 16 bitcast ([20 x double]* @__const.main.x3 to i8*), i32 160, i1 false)
  %arraydecay12 = getelementptr inbounds [20 x double], [20 x double]* %x3, i32 0, i32 0
  %arraydecay13 = getelementptr inbounds [5 x double], [5 x double]* %result, i32 0, i32 0
  %call14 = call i32 @fivenum(double* %arraydecay12, double* %arraydecay13, i32 20)
  %tobool15 = icmp ne i32 %call14, 0
  br i1 %tobool15, label %if.end19, label %if.then16

if.then16:                                        ; preds = %if.end11
  %arraydecay17 = getelementptr inbounds [5 x double], [5 x double]* %result, i32 0, i32 0
  %call18 = call i32 @show(double* %arraydecay17, i32 9)
  br label %if.end19

if.end19:                                         ; preds = %if.then16, %if.end11
  ret i32 0
}

; Function Attrs: argmemonly nounwind willreturn
declare void @llvm.memcpy.p0i8.p0i8.i32(i8* noalias nocapture writeonly %0, i8* noalias nocapture readonly %1, i32 %2, i1 immarg %3) #3

; Function Attrs: argmemonly nounwind willreturn writeonly
declare void @llvm.memset.p0i8.i32(i8* nocapture writeonly %0, i8 %1, i32 %2, i1 immarg %3) #4

attributes #0 = { noinline nounwind optnone "correctly-rounded-divide-sqrt-fp-math"="false" "disable-tail-calls"="false" "frame-pointer"="none" "less-precise-fpmad"="false" "min-legal-vector-width"="0" "no-infs-fp-math"="false" "no-jump-tables"="false" "no-nans-fp-math"="false" "no-signed-zeros-fp-math"="false" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="generic" "unsafe-fp-math"="false" "use-soft-float"="false" }
attributes #1 = { "correctly-rounded-divide-sqrt-fp-math"="false" "disable-tail-calls"="false" "frame-pointer"="none" "less-precise-fpmad"="false" "no-infs-fp-math"="false" "no-nans-fp-math"="false" "no-signed-zeros-fp-math"="false" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="generic" "unsafe-fp-math"="false" "use-soft-float"="false" }
attributes #2 = { noreturn "correctly-rounded-divide-sqrt-fp-math"="false" "disable-tail-calls"="false" "frame-pointer"="none" "less-precise-fpmad"="false" "no-infs-fp-math"="false" "no-nans-fp-math"="false" "no-signed-zeros-fp-math"="false" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="generic" "unsafe-fp-math"="false" "use-soft-float"="false" }
attributes #3 = { argmemonly nounwind willreturn }
attributes #4 = { argmemonly nounwind willreturn writeonly }
attributes #5 = { noreturn }

!llvm.module.flags = !{!0}
!llvm.ident = !{!1}

!0 = !{i32 1, !"wchar_size", i32 4}
!1 = !{!"clang version 11.0.0 (https://github.com/Jacarte/llvm-project.git 0f6dea67136cc1e0b3d200eb2bb165628970c44b)"}

; extracted candidates

; *****
; For LLVM instruction:
;  %0 = load i32, i32* %places.addr, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %1 = load i32, i32* %i, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %cmp = icmp slt i32 %1, 5
; Looking for a replacement for:
%0:i32 = var
%1:i1 = slt %0, 5:i32
infer %1

; *****
; For LLVM instruction:
;  %3 = load i32, i32* %i, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %5 = load i32, i32* %i, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %cmp4 = icmp slt i32 %5, 4
; Looking for a replacement for:
%0:i32 = var
%1:i1 = slt %0, 4:i32
infer %1

; *****
; For LLVM instruction:
;  %6 = load i32, i32* %i, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %inc = add nsw i32 %6, 1
; Looking for a replacement for:
%0:i32 = var
%1:i32 = addnsw 1:i32, %0
infer %1

; *****
; For LLVM instruction:
;  %7 = load i32, i32* %retval, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0
got 2 candidates from LHS

-------------------------------------------------
%0:i32 = var
%1:i1 = slt %0, 5:i32
infer %1


--------------------------------
guess 0

%0:i1 = var ; reservedconst_1

Cost = 0
first query is SAT, returning the model:
reservedconst_1: -1
0 th attempt: second query is SAT-- constant doesn't work
first query is SAT, returning the model:
reservedconst_1: 0
1 th attempt: second query is SAT-- constant doesn't work
first query is UNSAT-- no more guesses
Dataflow Pruned 0/0
There are 1 Guesses
There are 0 RHSs before deduplication
There are 0 RHSs after deduplication
got 2 candidates from LHS

-------------------------------------------------
%0:i32 = var
%1:i1 = slt %0, 4:i32
infer %1


--------------------------------
guess 0

%0:i1 = var ; reservedconst_1

Cost = 0
first query is SAT, returning the model:
reservedconst_1: -1
0 th attempt: second query is SAT-- constant doesn't work
first query is SAT, returning the model:
reservedconst_1: 0
1 th attempt: second query is SAT-- constant doesn't work
first query is UNSAT-- no more guesses
Dataflow Pruned 0/0
There are 1 Guesses
There are 0 RHSs before deduplication
There are 0 RHSs after deduplication
#########################################################
; exiting Souper's runOnFunction() for show()

; entering Souper's runOnFunction() for main()

; ModuleID = './Fivenum.c.bc'
source_filename = "./Fivenum.c"
target datalayout = "e-m:e-p:32:32-i64:64-n32:64-S128"
target triple = "wasm32-unknown-wasi"

@.str = private unnamed_addr constant [29 x i8] c"Array slice cannot be empty\0A\00", align 1
@.str.1 = private unnamed_addr constant [44 x i8] c"Unable to deal with arrays containing NaN\0A\0A\00", align 1
@.str.2 = private unnamed_addr constant [8 x i8] c"%%.%dlf\00", align 1
@.str.3 = private unnamed_addr constant [2 x i8] c"[\00", align 1
@.str.4 = private unnamed_addr constant [3 x i8] c", \00", align 1
@.str.5 = private unnamed_addr constant [4 x i8] c"]\0A\0A\00", align 1
@__const.main.x1 = private unnamed_addr constant [11 x double] [double 1.500000e+01, double 6.000000e+00, double 4.200000e+01, double 4.100000e+01, double 7.000000e+00, double 3.600000e+01, double 4.900000e+01, double 4.000000e+01, double 3.900000e+01, double 4.700000e+01, double 4.300000e+01], align 16
@__const.main.x3 = private unnamed_addr constant [20 x double] [double 0x3FC206A9BD53322C, double 9.748790e-02, double 0x3FFBB3776E4B8D1C, double 0x3FEC0B2450C23A4D, double 0xBFFF35A416A02A82, double 0x3FE780161FFCF58A, double 0xBF9F15F93B95AD51, double 0x3FF777D904E973CD, double 0xBFE7E0FB1CEC49EB, double 0xBFE73A78E23EF9E6, double 0x3FE4731C574E9B6F, double 0x3FE3AE3480E6197A, double 0xBFEFACC0526B06DF, double 0xBFF012584C9D3C91, double 0xBFE4154175962F2C, double 0x3FE52F9BDF192A9E, double 0x3FF0B09EB1059BF6, double 0xBFBA61BCB37A1570, double 0x3FE83F8A39545F7E, double 0x3FD4D7B548A1AF68], align 16
@llvm.used = appending global [1 x i8*] [i8* bitcast (i32 ()* @__main_void to i8*)], section "llvm.metadata"

@__main_void = alias i32 (), i32 ()* @main

; Function Attrs: noinline nounwind optnone
define hidden double @median(double* %x, i32 %start, i32 %end_inclusive) #0 {
entry:
  %retval = alloca double, align 8
  %x.addr = alloca double*, align 4
  %start.addr = alloca i32, align 4
  %end_inclusive.addr = alloca i32, align 4
  %size = alloca i32, align 4
  %m = alloca i32, align 4
  store double* %x, double** %x.addr, align 4
  store i32 %start, i32* %start.addr, align 4
  store i32 %end_inclusive, i32* %end_inclusive.addr, align 4
  %0 = load i32, i32* %end_inclusive.addr, align 4
  %1 = load i32, i32* %start.addr, align 4
  %sub = sub nsw i32 %0, %1
  %add = add nsw i32 %sub, 1
  store i32 %add, i32* %size, align 4
  %2 = load i32, i32* %size, align 4
  %cmp = icmp sle i32 %2, 0
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %call = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([29 x i8], [29 x i8]* @.str, i32 0, i32 0))
  call void @exit(i32 1) #5
  unreachable

if.end:                                           ; preds = %entry
  %3 = load i32, i32* %start.addr, align 4
  %4 = load i32, i32* %size, align 4
  %div = sdiv i32 %4, 2
  %add1 = add nsw i32 %3, %div
  store i32 %add1, i32* %m, align 4
  %5 = load i32, i32* %size, align 4
  %rem = srem i32 %5, 2
  %tobool = icmp ne i32 %rem, 0
  br i1 %tobool, label %if.then2, label %if.end3

if.then2:                                         ; preds = %if.end
  %6 = load double*, double** %x.addr, align 4
  %7 = load i32, i32* %m, align 4
  %arrayidx = getelementptr inbounds double, double* %6, i32 %7
  %8 = load double, double* %arrayidx, align 8
  store double %8, double* %retval, align 8
  br label %return

if.end3:                                          ; preds = %if.end
  %9 = load double*, double** %x.addr, align 4
  %10 = load i32, i32* %m, align 4
  %sub4 = sub nsw i32 %10, 1
  %arrayidx5 = getelementptr inbounds double, double* %9, i32 %sub4
  %11 = load double, double* %arrayidx5, align 8
  %12 = load double*, double** %x.addr, align 4
  %13 = load i32, i32* %m, align 4
  %arrayidx6 = getelementptr inbounds double, double* %12, i32 %13
  %14 = load double, double* %arrayidx6, align 8
  %add7 = fadd double %11, %14
  %div8 = fdiv double %add7, 2.000000e+00
  store double %div8, double* %retval, align 8
  br label %return

return:                                           ; preds = %if.end3, %if.then2
  %15 = load double, double* %retval, align 8
  ret double %15
}

declare i32 @printf(i8* %0, ...) #1

; Function Attrs: noreturn
declare void @exit(i32 %0) #2

; Function Attrs: noinline nounwind optnone
define hidden i32 @compare(i8* %a, i8* %b) #0 {
entry:
  %retval = alloca i32, align 4
  %a.addr = alloca i8*, align 4
  %b.addr = alloca i8*, align 4
  %aa = alloca double, align 8
  %bb = alloca double, align 8
  store i8* %a, i8** %a.addr, align 4
  store i8* %b, i8** %b.addr, align 4
  %0 = load i8*, i8** %a.addr, align 4
  %1 = bitcast i8* %0 to double*
  %2 = load double, double* %1, align 8
  store double %2, double* %aa, align 8
  %3 = load i8*, i8** %b.addr, align 4
  %4 = bitcast i8* %3 to double*
  %5 = load double, double* %4, align 8
  store double %5, double* %bb, align 8
  %6 = load double, double* %aa, align 8
  %7 = load double, double* %bb, align 8
  %cmp = fcmp ogt double %6, %7
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  store i32 1, i32* %retval, align 4
  br label %return

if.end:                                           ; preds = %entry
  %8 = load double, double* %aa, align 8
  %9 = load double, double* %bb, align 8
  %cmp1 = fcmp olt double %8, %9
  br i1 %cmp1, label %if.then2, label %if.end3

if.then2:                                         ; preds = %if.end
  store i32 -1, i32* %retval, align 4
  br label %return

if.end3:                                          ; preds = %if.end
  store i32 0, i32* %retval, align 4
  br label %return

return:                                           ; preds = %if.end3, %if.then2, %if.then
  %10 = load i32, i32* %retval, align 4
  ret i32 %10
}

; Function Attrs: noinline nounwind optnone
define hidden i32 @fivenum(double* %x, double* %result, i32 %x_len) #0 {
entry:
  %retval = alloca i32, align 4
  %x.addr = alloca double*, align 4
  %result.addr = alloca double*, align 4
  %x_len.addr = alloca i32, align 4
  %i = alloca i32, align 4
  %m = alloca i32, align 4
  %lower_end = alloca i32, align 4
  store double* %x, double** %x.addr, align 4
  store double* %result, double** %result.addr, align 4
  store i32 %x_len, i32* %x_len.addr, align 4
  store i32 0, i32* %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %0 = load i32, i32* %i, align 4
  %1 = load i32, i32* %x_len.addr, align 4
  %cmp = icmp slt i32 %0, %1
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %2 = load double*, double** %x.addr, align 4
  %3 = load i32, i32* %i, align 4
  %arrayidx = getelementptr inbounds double, double* %2, i32 %3
  %4 = load double, double* %arrayidx, align 8
  %5 = load double*, double** %x.addr, align 4
  %6 = load i32, i32* %i, align 4
  %arrayidx1 = getelementptr inbounds double, double* %5, i32 %6
  %7 = load double, double* %arrayidx1, align 8
  %cmp2 = fcmp une double %4, %7
  br i1 %cmp2, label %if.then, label %if.end

if.then:                                          ; preds = %for.body
  %call = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([44 x i8], [44 x i8]* @.str.1, i32 0, i32 0))
  store i32 1, i32* %retval, align 4
  br label %return

if.end:                                           ; preds = %for.body
  br label %for.inc

for.inc:                                          ; preds = %if.end
  %8 = load i32, i32* %i, align 4
  %inc = add nsw i32 %8, 1
  store i32 %inc, i32* %i, align 4
  br label %for.cond

for.end:                                          ; preds = %for.cond
  %9 = load double*, double** %x.addr, align 4
  %10 = bitcast double* %9 to i8*
  %11 = load i32, i32* %x_len.addr, align 4
  call void @qsort(i8* %10, i32 %11, i32 8, i32 (i8*, i8*)* @compare)
  %12 = load double*, double** %x.addr, align 4
  %arrayidx3 = getelementptr inbounds double, double* %12, i32 0
  %13 = load double, double* %arrayidx3, align 8
  %14 = load double*, double** %result.addr, align 4
  %arrayidx4 = getelementptr inbounds double, double* %14, i32 0
  store double %13, double* %arrayidx4, align 8
  %15 = load double*, double** %x.addr, align 4
  %16 = load i32, i32* %x_len.addr, align 4
  %sub = sub nsw i32 %16, 1
  %call5 = call double @median(double* %15, i32 0, i32 %sub)
  %17 = load double*, double** %result.addr, align 4
  %arrayidx6 = getelementptr inbounds double, double* %17, i32 2
  store double %call5, double* %arrayidx6, align 8
  %18 = load double*, double** %x.addr, align 4
  %19 = load i32, i32* %x_len.addr, align 4
  %sub7 = sub nsw i32 %19, 1
  %arrayidx8 = getelementptr inbounds double, double* %18, i32 %sub7
  %20 = load double, double* %arrayidx8, align 8
  %21 = load double*, double** %result.addr, align 4
  %arrayidx9 = getelementptr inbounds double, double* %21, i32 4
  store double %20, double* %arrayidx9, align 8
  %22 = load i32, i32* %x_len.addr, align 4
  %div = sdiv i32 %22, 2
  store i32 %div, i32* %m, align 4
  %23 = load i32, i32* %x_len.addr, align 4
  %rem = srem i32 %23, 2
  %tobool = icmp ne i32 %rem, 0
  br i1 %tobool, label %cond.true, label %cond.false

cond.true:                                        ; preds = %for.end
  %24 = load i32, i32* %m, align 4
  br label %cond.end

cond.false:                                       ; preds = %for.end
  %25 = load i32, i32* %m, align 4
  %sub10 = sub nsw i32 %25, 1
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi i32 [ %24, %cond.true ], [ %sub10, %cond.false ]
  store i32 %cond, i32* %lower_end, align 4
  %26 = load double*, double** %x.addr, align 4
  %27 = load i32, i32* %lower_end, align 4
  %call11 = call double @median(double* %26, i32 0, i32 %27)
  %28 = load double*, double** %result.addr, align 4
  %arrayidx12 = getelementptr inbounds double, double* %28, i32 1
  store double %call11, double* %arrayidx12, align 8
  %29 = load double*, double** %x.addr, align 4
  %30 = load i32, i32* %m, align 4
  %31 = load i32, i32* %x_len.addr, align 4
  %sub13 = sub nsw i32 %31, 1
  %call14 = call double @median(double* %29, i32 %30, i32 %sub13)
  %32 = load double*, double** %result.addr, align 4
  %arrayidx15 = getelementptr inbounds double, double* %32, i32 3
  store double %call14, double* %arrayidx15, align 8
  store i32 0, i32* %retval, align 4
  br label %return

return:                                           ; preds = %cond.end, %if.then
  %33 = load i32, i32* %retval, align 4
  ret i32 %33
}

declare void @qsort(i8* %0, i32 %1, i32 %2, i32 (i8*, i8*)* %3) #1

; Function Attrs: noinline nounwind optnone
define hidden i32 @show(double* %result, i32 %places) #0 {
entry:
  %retval = alloca i32, align 4
  %result.addr = alloca double*, align 4
  %places.addr = alloca i32, align 4
  %i = alloca i32, align 4
  %f = alloca [7 x i8], align 1
  store double* %result, double** %result.addr, align 4
  store i32 %places, i32* %places.addr, align 4
  %arraydecay = getelementptr inbounds [7 x i8], [7 x i8]* %f, i32 0, i32 0
  %0 = load i32, i32* %places.addr, align 4
  %call = call i32 (i8*, i8*, ...) @sprintf(i8* %arraydecay, i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str.2, i32 0, i32 0), i32 %0)
  %call1 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([2 x i8], [2 x i8]* @.str.3, i32 0, i32 0))
  store i32 0, i32* %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %1 = load i32, i32* %i, align 4
  %cmp = icmp slt i32 %1, 5
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %arraydecay2 = getelementptr inbounds [7 x i8], [7 x i8]* %f, i32 0, i32 0
  %2 = load double*, double** %result.addr, align 4
  %3 = load i32, i32* %i, align 4
  %arrayidx = getelementptr inbounds double, double* %2, i32 %3
  %4 = load double, double* %arrayidx, align 8
  %call3 = call i32 (i8*, ...) @printf(i8* %arraydecay2, double %4)
  %5 = load i32, i32* %i, align 4
  %cmp4 = icmp slt i32 %5, 4
  br i1 %cmp4, label %if.then, label %if.end

if.then:                                          ; preds = %for.body
  %call5 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([3 x i8], [3 x i8]* @.str.4, i32 0, i32 0))
  br label %if.end

if.end:                                           ; preds = %if.then, %for.body
  br label %for.inc

for.inc:                                          ; preds = %if.end
  %6 = load i32, i32* %i, align 4
  %inc = add nsw i32 %6, 1
  store i32 %inc, i32* %i, align 4
  br label %for.cond

for.end:                                          ; preds = %for.cond
  %call6 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([4 x i8], [4 x i8]* @.str.5, i32 0, i32 0))
  %7 = load i32, i32* %retval, align 4
  ret i32 %7
}

declare i32 @sprintf(i8* %0, i8* %1, ...) #1

; Function Attrs: noinline nounwind optnone
define hidden i32 @main() #0 {
entry:
  %retval = alloca i32, align 4
  %result = alloca [5 x double], align 16
  %x1 = alloca [11 x double], align 16
  %x2 = alloca [6 x double], align 16
  %x3 = alloca [20 x double], align 16
  store i32 0, i32* %retval, align 4
  %0 = bitcast [11 x double]* %x1 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 16 %0, i8* align 16 bitcast ([11 x double]* @__const.main.x1 to i8*), i32 88, i1 false)
  %arraydecay = getelementptr inbounds [11 x double], [11 x double]* %x1, i32 0, i32 0
  %arraydecay1 = getelementptr inbounds [5 x double], [5 x double]* %result, i32 0, i32 0
  %call = call i32 @fivenum(double* %arraydecay, double* %arraydecay1, i32 11)
  %tobool = icmp ne i32 %call, 0
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  %arraydecay2 = getelementptr inbounds [5 x double], [5 x double]* %result, i32 0, i32 0
  %call3 = call i32 @show(double* %arraydecay2, i32 1)
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  %1 = bitcast [6 x double]* %x2 to i8*
  call void @llvm.memset.p0i8.i32(i8* align 16 %1, i8 0, i32 48, i1 false)
  %2 = bitcast i8* %1 to [6 x double]*
  %3 = getelementptr inbounds [6 x double], [6 x double]* %2, i32 0, i32 0
  store double 3.600000e+01, double* %3, align 16
  %4 = getelementptr inbounds [6 x double], [6 x double]* %2, i32 0, i32 1
  store double 4.000000e+01, double* %4, align 8
  %5 = getelementptr inbounds [6 x double], [6 x double]* %2, i32 0, i32 2
  store double 7.000000e+00, double* %5, align 16
  %6 = getelementptr inbounds [6 x double], [6 x double]* %2, i32 0, i32 3
  store double 3.900000e+01, double* %6, align 8
  %7 = getelementptr inbounds [6 x double], [6 x double]* %2, i32 0, i32 4
  store double 4.100000e+01, double* %7, align 16
  %8 = getelementptr inbounds [6 x double], [6 x double]* %2, i32 0, i32 5
  store double 1.500000e+01, double* %8, align 8
  %arraydecay4 = getelementptr inbounds [6 x double], [6 x double]* %x2, i32 0, i32 0
  %arraydecay5 = getelementptr inbounds [5 x double], [5 x double]* %result, i32 0, i32 0
  %call6 = call i32 @fivenum(double* %arraydecay4, double* %arraydecay5, i32 6)
  %tobool7 = icmp ne i32 %call6, 0
  br i1 %tobool7, label %if.end11, label %if.then8

if.then8:                                         ; preds = %if.end
  %arraydecay9 = getelementptr inbounds [5 x double], [5 x double]* %result, i32 0, i32 0
  %call10 = call i32 @show(double* %arraydecay9, i32 1)
  br label %if.end11

if.end11:                                         ; preds = %if.then8, %if.end
  %9 = bitcast [20 x double]* %x3 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 16 %9, i8* align 16 bitcast ([20 x double]* @__const.main.x3 to i8*), i32 160, i1 false)
  %arraydecay12 = getelementptr inbounds [20 x double], [20 x double]* %x3, i32 0, i32 0
  %arraydecay13 = getelementptr inbounds [5 x double], [5 x double]* %result, i32 0, i32 0
  %call14 = call i32 @fivenum(double* %arraydecay12, double* %arraydecay13, i32 20)
  %tobool15 = icmp ne i32 %call14, 0
  br i1 %tobool15, label %if.end19, label %if.then16

if.then16:                                        ; preds = %if.end11
  %arraydecay17 = getelementptr inbounds [5 x double], [5 x double]* %result, i32 0, i32 0
  %call18 = call i32 @show(double* %arraydecay17, i32 9)
  br label %if.end19

if.end19:                                         ; preds = %if.then16, %if.end11
  ret i32 0
}

; Function Attrs: argmemonly nounwind willreturn
declare void @llvm.memcpy.p0i8.p0i8.i32(i8* noalias nocapture writeonly %0, i8* noalias nocapture readonly %1, i32 %2, i1 immarg %3) #3

; Function Attrs: argmemonly nounwind willreturn writeonly
declare void @llvm.memset.p0i8.i32(i8* nocapture writeonly %0, i8 %1, i32 %2, i1 immarg %3) #4

attributes #0 = { noinline nounwind optnone "correctly-rounded-divide-sqrt-fp-math"="false" "disable-tail-calls"="false" "frame-pointer"="none" "less-precise-fpmad"="false" "min-legal-vector-width"="0" "no-infs-fp-math"="false" "no-jump-tables"="false" "no-nans-fp-math"="false" "no-signed-zeros-fp-math"="false" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="generic" "unsafe-fp-math"="false" "use-soft-float"="false" }
attributes #1 = { "correctly-rounded-divide-sqrt-fp-math"="false" "disable-tail-calls"="false" "frame-pointer"="none" "less-precise-fpmad"="false" "no-infs-fp-math"="false" "no-nans-fp-math"="false" "no-signed-zeros-fp-math"="false" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="generic" "unsafe-fp-math"="false" "use-soft-float"="false" }
attributes #2 = { noreturn "correctly-rounded-divide-sqrt-fp-math"="false" "disable-tail-calls"="false" "frame-pointer"="none" "less-precise-fpmad"="false" "no-infs-fp-math"="false" "no-nans-fp-math"="false" "no-signed-zeros-fp-math"="false" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="generic" "unsafe-fp-math"="false" "use-soft-float"="false" }
attributes #3 = { argmemonly nounwind willreturn }
attributes #4 = { argmemonly nounwind willreturn writeonly }
attributes #5 = { noreturn }

!llvm.module.flags = !{!0}
!llvm.ident = !{!1}

!0 = !{i32 1, !"wchar_size", i32 4}
!1 = !{!"clang version 11.0.0 (https://github.com/Jacarte/llvm-project.git 0f6dea67136cc1e0b3d200eb2bb165628970c44b)"}

; extracted candidates

; *****
; For LLVM instruction:
;  %call = call i32 @fivenum(double* %arraydecay, double* %arraydecay1, i32 11)
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %tobool = icmp ne i32 %call, 0
; Looking for a replacement for:
%0:i32 = var
%1:i1 = ne 0:i32, %0
infer %1

; *****
; For LLVM instruction:
;  %call6 = call i32 @fivenum(double* %arraydecay4, double* %arraydecay5, i32 6)
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %tobool7 = icmp ne i32 %call6, 0
; Looking for a replacement for:
%0:i32 = var
%1:i1 = ne 0:i32, %0
infer %1

; *****
; For LLVM instruction:
;  %call14 = call i32 @fivenum(double* %arraydecay12, double* %arraydecay13, i32 20)
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %tobool15 = icmp ne i32 %call14, 0
; Looking for a replacement for:
%0:i32 = var
%1:i1 = ne 0:i32, %0
infer %1
got 2 candidates from LHS

-------------------------------------------------
%0:i32 = var
%1:i1 = ne 0:i32, %0
infer %1


--------------------------------
guess 0

%0:i1 = var ; reservedconst_1

Cost = 0
first query is SAT, returning the model:
reservedconst_1: 0
0 th attempt: second query is SAT-- constant doesn't work
first query is SAT, returning the model:
reservedconst_1: -1
1 th attempt: second query is SAT-- constant doesn't work
first query is UNSAT-- no more guesses
Dataflow Pruned 0/0
There are 1 Guesses
There are 0 RHSs before deduplication
There are 0 RHSs after deduplication
#########################################################
; exiting Souper's runOnFunction() for main()
Total of 0 replacements done on this module
Total of 0 replacements candidates on this module
