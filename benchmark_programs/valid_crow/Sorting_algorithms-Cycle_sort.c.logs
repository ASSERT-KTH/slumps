
Entering the Souper pass's runOnModule()


; entering Souper's runOnFunction() for cycleSort()

; ModuleID = './Sorting_algorithms-Cycle_sort.c.bc'
source_filename = "./Sorting_algorithms-Cycle_sort.c"
target datalayout = "e-m:e-p:32:32-i64:64-n32:64-S128"
target triple = "wasm32-unknown-wasi"

@__const.__main_argc_argv.arr = private unnamed_addr constant [16 x i32] [i32 0, i32 1, i32 2, i32 2, i32 2, i32 2, i32 1, i32 9, i32 3, i32 5, i32 5, i32 8, i32 4, i32 7, i32 0, i32 6], align 16
@.str = private unnamed_addr constant [12 x i8] c"writes: %d\0A\00", align 1
@.str.1 = private unnamed_addr constant [4 x i8] c"%d \00", align 1

; Function Attrs: noinline nounwind optnone
define hidden i32 @cycleSort(i32* %list, i32 %l_len) #0 {
entry:
  %list.addr = alloca i32*, align 4
  %l_len.addr = alloca i32, align 4
  %writes = alloca i32, align 4
  %cycleStart = alloca i32, align 4
  %item = alloca i32, align 4
  %swap_tmp = alloca i32, align 4
  %pos = alloca i32, align 4
  %i = alloca i32, align 4
  %i19 = alloca i32, align 4
  store i32* %list, i32** %list.addr, align 4
  store i32 %l_len, i32* %l_len.addr, align 4
  store i32 0, i32* %writes, align 4
  store i32 0, i32* %cycleStart, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc42, %entry
  %0 = load i32, i32* %cycleStart, align 4
  %1 = load i32, i32* %l_len.addr, align 4
  %sub = sub i32 %1, 1
  %cmp = icmp ult i32 %0, %sub
  br i1 %cmp, label %for.body, label %for.end44

for.body:                                         ; preds = %for.cond
  %2 = load i32*, i32** %list.addr, align 4
  %3 = load i32, i32* %cycleStart, align 4
  %arrayidx = getelementptr inbounds i32, i32* %2, i32 %3
  %4 = load i32, i32* %arrayidx, align 4
  store i32 %4, i32* %item, align 4
  %5 = load i32, i32* %cycleStart, align 4
  store i32 %5, i32* %pos, align 4
  %6 = load i32, i32* %cycleStart, align 4
  %add = add nsw i32 %6, 1
  store i32 %add, i32* %i, align 4
  br label %for.cond1

for.cond1:                                        ; preds = %for.inc, %for.body
  %7 = load i32, i32* %i, align 4
  %8 = load i32, i32* %l_len.addr, align 4
  %cmp2 = icmp ult i32 %7, %8
  br i1 %cmp2, label %for.body3, label %for.end

for.body3:                                        ; preds = %for.cond1
  %9 = load i32*, i32** %list.addr, align 4
  %10 = load i32, i32* %i, align 4
  %arrayidx4 = getelementptr inbounds i32, i32* %9, i32 %10
  %11 = load i32, i32* %arrayidx4, align 4
  %12 = load i32, i32* %item, align 4
  %cmp5 = icmp slt i32 %11, %12
  br i1 %cmp5, label %if.then, label %if.end

if.then:                                          ; preds = %for.body3
  %13 = load i32, i32* %pos, align 4
  %inc = add nsw i32 %13, 1
  store i32 %inc, i32* %pos, align 4
  br label %if.end

if.end:                                           ; preds = %if.then, %for.body3
  br label %for.inc

for.inc:                                          ; preds = %if.end
  %14 = load i32, i32* %i, align 4
  %inc6 = add nsw i32 %14, 1
  store i32 %inc6, i32* %i, align 4
  br label %for.cond1

for.end:                                          ; preds = %for.cond1
  %15 = load i32, i32* %pos, align 4
  %16 = load i32, i32* %cycleStart, align 4
  %cmp7 = icmp eq i32 %15, %16
  br i1 %cmp7, label %if.then8, label %if.end9

if.then8:                                         ; preds = %for.end
  br label %for.inc42

if.end9:                                          ; preds = %for.end
  br label %while.cond

while.cond:                                       ; preds = %while.body, %if.end9
  %17 = load i32, i32* %item, align 4
  %18 = load i32*, i32** %list.addr, align 4
  %19 = load i32, i32* %pos, align 4
  %arrayidx10 = getelementptr inbounds i32, i32* %18, i32 %19
  %20 = load i32, i32* %arrayidx10, align 4
  %cmp11 = icmp eq i32 %17, %20
  br i1 %cmp11, label %while.body, label %while.end

while.body:                                       ; preds = %while.cond
  %21 = load i32, i32* %pos, align 4
  %inc12 = add nsw i32 %21, 1
  store i32 %inc12, i32* %pos, align 4
  br label %while.cond

while.end:                                        ; preds = %while.cond
  %22 = load i32*, i32** %list.addr, align 4
  %23 = load i32, i32* %pos, align 4
  %arrayidx13 = getelementptr inbounds i32, i32* %22, i32 %23
  %24 = load i32, i32* %arrayidx13, align 4
  store i32 %24, i32* %swap_tmp, align 4
  %25 = load i32, i32* %item, align 4
  %26 = load i32*, i32** %list.addr, align 4
  %27 = load i32, i32* %pos, align 4
  %arrayidx14 = getelementptr inbounds i32, i32* %26, i32 %27
  store i32 %25, i32* %arrayidx14, align 4
  %28 = load i32, i32* %swap_tmp, align 4
  store i32 %28, i32* %item, align 4
  %29 = load i32, i32* %writes, align 4
  %inc15 = add nsw i32 %29, 1
  store i32 %inc15, i32* %writes, align 4
  br label %while.cond16

while.cond16:                                     ; preds = %while.end37, %while.end
  %30 = load i32, i32* %pos, align 4
  %31 = load i32, i32* %cycleStart, align 4
  %cmp17 = icmp ne i32 %30, %31
  br i1 %cmp17, label %while.body18, label %while.end41

while.body18:                                     ; preds = %while.cond16
  %32 = load i32, i32* %cycleStart, align 4
  store i32 %32, i32* %pos, align 4
  %33 = load i32, i32* %cycleStart, align 4
  %add20 = add nsw i32 %33, 1
  store i32 %add20, i32* %i19, align 4
  br label %for.cond21

for.cond21:                                       ; preds = %for.inc29, %while.body18
  %34 = load i32, i32* %i19, align 4
  %35 = load i32, i32* %l_len.addr, align 4
  %cmp22 = icmp ult i32 %34, %35
  br i1 %cmp22, label %for.body23, label %for.end31

for.body23:                                       ; preds = %for.cond21
  %36 = load i32*, i32** %list.addr, align 4
  %37 = load i32, i32* %i19, align 4
  %arrayidx24 = getelementptr inbounds i32, i32* %36, i32 %37
  %38 = load i32, i32* %arrayidx24, align 4
  %39 = load i32, i32* %item, align 4
  %cmp25 = icmp slt i32 %38, %39
  br i1 %cmp25, label %if.then26, label %if.end28

if.then26:                                        ; preds = %for.body23
  %40 = load i32, i32* %pos, align 4
  %inc27 = add nsw i32 %40, 1
  store i32 %inc27, i32* %pos, align 4
  br label %if.end28

if.end28:                                         ; preds = %if.then26, %for.body23
  br label %for.inc29

for.inc29:                                        ; preds = %if.end28
  %41 = load i32, i32* %i19, align 4
  %inc30 = add nsw i32 %41, 1
  store i32 %inc30, i32* %i19, align 4
  br label %for.cond21

for.end31:                                        ; preds = %for.cond21
  br label %while.cond32

while.cond32:                                     ; preds = %while.body35, %for.end31
  %42 = load i32, i32* %item, align 4
  %43 = load i32*, i32** %list.addr, align 4
  %44 = load i32, i32* %pos, align 4
  %arrayidx33 = getelementptr inbounds i32, i32* %43, i32 %44
  %45 = load i32, i32* %arrayidx33, align 4
  %cmp34 = icmp eq i32 %42, %45
  br i1 %cmp34, label %while.body35, label %while.end37

while.body35:                                     ; preds = %while.cond32
  %46 = load i32, i32* %pos, align 4
  %inc36 = add nsw i32 %46, 1
  store i32 %inc36, i32* %pos, align 4
  br label %while.cond32

while.end37:                                      ; preds = %while.cond32
  %47 = load i32*, i32** %list.addr, align 4
  %48 = load i32, i32* %pos, align 4
  %arrayidx38 = getelementptr inbounds i32, i32* %47, i32 %48
  %49 = load i32, i32* %arrayidx38, align 4
  store i32 %49, i32* %swap_tmp, align 4
  %50 = load i32, i32* %item, align 4
  %51 = load i32*, i32** %list.addr, align 4
  %52 = load i32, i32* %pos, align 4
  %arrayidx39 = getelementptr inbounds i32, i32* %51, i32 %52
  store i32 %50, i32* %arrayidx39, align 4
  %53 = load i32, i32* %swap_tmp, align 4
  store i32 %53, i32* %item, align 4
  %54 = load i32, i32* %writes, align 4
  %inc40 = add nsw i32 %54, 1
  store i32 %inc40, i32* %writes, align 4
  br label %while.cond16

while.end41:                                      ; preds = %while.cond16
  br label %for.inc42

for.inc42:                                        ; preds = %while.end41, %if.then8
  %55 = load i32, i32* %cycleStart, align 4
  %inc43 = add nsw i32 %55, 1
  store i32 %inc43, i32* %cycleStart, align 4
  br label %for.cond

for.end44:                                        ; preds = %for.cond
  %56 = load i32, i32* %writes, align 4
  ret i32 %56
}

; Function Attrs: noinline nounwind optnone
define hidden i32 @__main_argc_argv(i32 %argc, i8** %argv) #0 {
entry:
  %retval = alloca i32, align 4
  %argc.addr = alloca i32, align 4
  %argv.addr = alloca i8**, align 4
  %arr = alloca [16 x i32], align 16
  %arr_k = alloca i32, align 4
  %writes = alloca i32, align 4
  store i32 0, i32* %retval, align 4
  store i32 %argc, i32* %argc.addr, align 4
  store i8** %argv, i8*** %argv.addr, align 4
  %0 = bitcast [16 x i32]* %arr to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 16 %0, i8* align 16 bitcast ([16 x i32]* @__const.__main_argc_argv.arr to i8*), i32 64, i1 false)
  store i32 16, i32* %arr_k, align 4
  %arraydecay = getelementptr inbounds [16 x i32], [16 x i32]* %arr, i32 0, i32 0
  %1 = load i32, i32* %arr_k, align 4
  call void @show_array(i32* %arraydecay, i32 %1)
  %arraydecay1 = getelementptr inbounds [16 x i32], [16 x i32]* %arr, i32 0, i32 0
  %2 = load i32, i32* %arr_k, align 4
  %call = call i32 @cycleSort(i32* %arraydecay1, i32 %2)
  store i32 %call, i32* %writes, align 4
  %arraydecay2 = getelementptr inbounds [16 x i32], [16 x i32]* %arr, i32 0, i32 0
  %3 = load i32, i32* %arr_k, align 4
  call void @show_array(i32* %arraydecay2, i32 %3)
  %4 = load i32, i32* %writes, align 4
  %call3 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([12 x i8], [12 x i8]* @.str, i32 0, i32 0), i32 %4)
  ret i32 0
}

; Function Attrs: argmemonly nounwind willreturn
declare void @llvm.memcpy.p0i8.p0i8.i32(i8* noalias nocapture writeonly %0, i8* noalias nocapture readonly %1, i32 %2, i1 immarg %3) #1

; Function Attrs: noinline nounwind optnone
define hidden void @show_array(i32* %array, i32 %a_len) #0 {
entry:
  %array.addr = alloca i32*, align 4
  %a_len.addr = alloca i32, align 4
  %ix = alloca i32, align 4
  store i32* %array, i32** %array.addr, align 4
  store i32 %a_len, i32* %a_len.addr, align 4
  store i32 0, i32* %ix, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %0 = load i32, i32* %ix, align 4
  %1 = load i32, i32* %a_len.addr, align 4
  %cmp = icmp ult i32 %0, %1
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %2 = load i32*, i32** %array.addr, align 4
  %3 = load i32, i32* %ix, align 4
  %arrayidx = getelementptr inbounds i32, i32* %2, i32 %3
  %4 = load i32, i32* %arrayidx, align 4
  %call = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([4 x i8], [4 x i8]* @.str.1, i32 0, i32 0), i32 %4)
  br label %for.inc

for.inc:                                          ; preds = %for.body
  %5 = load i32, i32* %ix, align 4
  %inc = add nsw i32 %5, 1
  store i32 %inc, i32* %ix, align 4
  br label %for.cond

for.end:                                          ; preds = %for.cond
  %call1 = call i32 @putchar(i32 10)
  ret void
}

declare i32 @printf(i8* %0, ...) #2

declare i32 @putchar(i32 %0) #2

attributes #0 = { noinline nounwind optnone "correctly-rounded-divide-sqrt-fp-math"="false" "disable-tail-calls"="false" "frame-pointer"="none" "less-precise-fpmad"="false" "min-legal-vector-width"="0" "no-infs-fp-math"="false" "no-jump-tables"="false" "no-nans-fp-math"="false" "no-signed-zeros-fp-math"="false" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="generic" "unsafe-fp-math"="false" "use-soft-float"="false" }
attributes #1 = { argmemonly nounwind willreturn }
attributes #2 = { "correctly-rounded-divide-sqrt-fp-math"="false" "disable-tail-calls"="false" "frame-pointer"="none" "less-precise-fpmad"="false" "no-infs-fp-math"="false" "no-nans-fp-math"="false" "no-signed-zeros-fp-math"="false" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="generic" "unsafe-fp-math"="false" "use-soft-float"="false" }

!llvm.module.flags = !{!0}
!llvm.ident = !{!1}

!0 = !{i32 1, !"wchar_size", i32 4}
!1 = !{!"clang version 11.0.0 (https://github.com/Jacarte/llvm-project.git 0f6dea67136cc1e0b3d200eb2bb165628970c44b)"}

; extracted candidates

; *****
; For LLVM instruction:
;  %0 = load i32, i32* %cycleStart, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %1 = load i32, i32* %l_len.addr, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %sub = sub i32 %1, 1
; Looking for a replacement for:
%0:i32 = var
%1:i32 = sub %0, 1:i32
infer %1

; *****
; For LLVM instruction:
;  %cmp = icmp ult i32 %0, %sub
; Looking for a replacement for:
%0:i32 = var
%1:i32 = var
%2:i32 = sub %1, 1:i32
%3:i1 = ult %0, %2
infer %3

; *****
; For LLVM instruction:
;  %3 = load i32, i32* %cycleStart, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %4 = load i32, i32* %arrayidx, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %5 = load i32, i32* %cycleStart, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %6 = load i32, i32* %cycleStart, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %add = add nsw i32 %6, 1
; Looking for a replacement for:
%0:i32 = var
%1:i32 = addnsw 1:i32, %0
infer %1

; *****
; For LLVM instruction:
;  %7 = load i32, i32* %i, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %8 = load i32, i32* %l_len.addr, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %cmp2 = icmp ult i32 %7, %8
; Looking for a replacement for:
%0:i32 = var
%1:i32 = var
%2:i1 = ult %0, %1
infer %2

; *****
; For LLVM instruction:
;  %10 = load i32, i32* %i, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %11 = load i32, i32* %arrayidx4, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %12 = load i32, i32* %item, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %cmp5 = icmp slt i32 %11, %12
; Looking for a replacement for:
%0:i32 = var
%1:i32 = var
%2:i1 = slt %0, %1
infer %2

; *****
; For LLVM instruction:
;  %13 = load i32, i32* %pos, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %inc = add nsw i32 %13, 1
; Looking for a replacement for:
%0:i32 = var
%1:i32 = addnsw 1:i32, %0
infer %1

; *****
; For LLVM instruction:
;  %14 = load i32, i32* %i, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %inc6 = add nsw i32 %14, 1
; Looking for a replacement for:
%0:i32 = var
%1:i32 = addnsw 1:i32, %0
infer %1

; *****
; For LLVM instruction:
;  %15 = load i32, i32* %pos, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %16 = load i32, i32* %cycleStart, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %cmp7 = icmp eq i32 %15, %16
; Looking for a replacement for:
%0:i32 = var
%1:i32 = var
%2:i1 = eq %0, %1
infer %2

; *****
; For LLVM instruction:
;  %17 = load i32, i32* %item, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %19 = load i32, i32* %pos, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %20 = load i32, i32* %arrayidx10, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %cmp11 = icmp eq i32 %17, %20
; Looking for a replacement for:
%0:i32 = var
%1:i32 = var
%2:i1 = eq %0, %1
infer %2

; *****
; For LLVM instruction:
;  %21 = load i32, i32* %pos, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %inc12 = add nsw i32 %21, 1
; Looking for a replacement for:
%0:i32 = var
%1:i32 = addnsw 1:i32, %0
infer %1

; *****
; For LLVM instruction:
;  %23 = load i32, i32* %pos, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %24 = load i32, i32* %arrayidx13, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %25 = load i32, i32* %item, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %27 = load i32, i32* %pos, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %28 = load i32, i32* %swap_tmp, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %29 = load i32, i32* %writes, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %inc15 = add nsw i32 %29, 1
; Looking for a replacement for:
%0:i32 = var
%1:i32 = addnsw 1:i32, %0
infer %1

; *****
; For LLVM instruction:
;  %30 = load i32, i32* %pos, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %31 = load i32, i32* %cycleStart, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %cmp17 = icmp ne i32 %30, %31
; Looking for a replacement for:
%0:i32 = var
%1:i32 = var
%2:i1 = ne %0, %1
infer %2

; *****
; For LLVM instruction:
;  %32 = load i32, i32* %cycleStart, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %33 = load i32, i32* %cycleStart, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %add20 = add nsw i32 %33, 1
; Looking for a replacement for:
%0:i32 = var
%1:i32 = addnsw 1:i32, %0
infer %1

; *****
; For LLVM instruction:
;  %34 = load i32, i32* %i19, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %35 = load i32, i32* %l_len.addr, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %cmp22 = icmp ult i32 %34, %35
; Looking for a replacement for:
%0:i32 = var
%1:i32 = var
%2:i1 = ult %0, %1
infer %2

; *****
; For LLVM instruction:
;  %37 = load i32, i32* %i19, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %38 = load i32, i32* %arrayidx24, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %39 = load i32, i32* %item, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %cmp25 = icmp slt i32 %38, %39
; Looking for a replacement for:
%0:i32 = var
%1:i32 = var
%2:i1 = slt %0, %1
infer %2

; *****
; For LLVM instruction:
;  %40 = load i32, i32* %pos, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %inc27 = add nsw i32 %40, 1
; Looking for a replacement for:
%0:i32 = var
%1:i32 = addnsw 1:i32, %0
infer %1

; *****
; For LLVM instruction:
;  %41 = load i32, i32* %i19, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %inc30 = add nsw i32 %41, 1
; Looking for a replacement for:
%0:i32 = var
%1:i32 = addnsw 1:i32, %0
infer %1

; *****
; For LLVM instruction:
;  %42 = load i32, i32* %item, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %44 = load i32, i32* %pos, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %45 = load i32, i32* %arrayidx33, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %cmp34 = icmp eq i32 %42, %45
; Looking for a replacement for:
%0:i32 = var
%1:i32 = var
%2:i1 = eq %0, %1
infer %2

; *****
; For LLVM instruction:
;  %46 = load i32, i32* %pos, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %inc36 = add nsw i32 %46, 1
; Looking for a replacement for:
%0:i32 = var
%1:i32 = addnsw 1:i32, %0
infer %1

; *****
; For LLVM instruction:
;  %48 = load i32, i32* %pos, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %49 = load i32, i32* %arrayidx38, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %50 = load i32, i32* %item, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %52 = load i32, i32* %pos, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %53 = load i32, i32* %swap_tmp, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %54 = load i32, i32* %writes, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %inc40 = add nsw i32 %54, 1
; Looking for a replacement for:
%0:i32 = var
%1:i32 = addnsw 1:i32, %0
infer %1

; *****
; For LLVM instruction:
;  %55 = load i32, i32* %cycleStart, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %inc43 = add nsw i32 %55, 1
; Looking for a replacement for:
%0:i32 = var
%1:i32 = addnsw 1:i32, %0
infer %1

; *****
; For LLVM instruction:
;  %56 = load i32, i32* %writes, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0
got 1 candidates from LHS

-------------------------------------------------
%0:i32 = var
infer %0


--------------------------------
guess 0

%0:i32 = var ; reservedconst_1

Cost = 0
first query is SAT, returning the model:
reservedconst_1: 0
0 th attempt: second query is SAT-- constant doesn't work
first query is SAT, returning the model:
reservedconst_1: -1
1 th attempt: second query is SAT-- constant doesn't work
first query is UNSAT-- no more guesses
Dataflow Pruned 0/0
There are 1 Guesses
There are 0 RHSs before deduplication
There are 0 RHSs after deduplication
got 2 candidates from LHS

-------------------------------------------------
%0:i32 = var
%1:i32 = sub %0, 1:i32
infer %1


--------------------------------
guess 0

%0:i32 = var ; reservedconst_1

Cost = 0
first query is SAT, returning the model:
reservedconst_1: -1
0 th attempt: second query is SAT-- constant doesn't work
first query is SAT, returning the model:
reservedconst_1: -2
1 th attempt: second query is SAT-- constant doesn't work
first query is UNSAT-- no more guesses

--------------------------------
guess 1

%0:i32 = var

Cost = 0
second query is SAT-- constant doesn't work
Dataflow Pruned 0/0
There are 2 Guesses
There are 0 RHSs before deduplication
There are 0 RHSs after deduplication
got 4 candidates from LHS

-------------------------------------------------
%0:i32 = var
%1:i32 = var
%2:i32 = sub %1, 1:i32
%3:i1 = ult %0, %2
infer %3


--------------------------------
guess 0

%0:i1 = var ; reservedconst_1

Cost = 0
first query is SAT, returning the model:
reservedconst_1: -1
0 th attempt: second query is SAT-- constant doesn't work
first query is SAT, returning the model:
reservedconst_1: 0
1 th attempt: second query is SAT-- constant doesn't work
first query is UNSAT-- no more guesses
Dataflow Pruned 0/0
There are 1 Guesses
There are 0 RHSs before deduplication
There are 0 RHSs after deduplication
got 2 candidates from LHS

-------------------------------------------------
%0:i32 = var
%1:i32 = addnsw 1:i32, %0
infer %1


--------------------------------
guess 0

%0:i32 = var ; reservedconst_1

Cost = 0
first query is SAT, returning the model:
reservedconst_1: 1
0 th attempt: second query is SAT-- constant doesn't work
first query is SAT, returning the model:
reservedconst_1: 268435457
1 th attempt: second query is SAT-- constant doesn't work
first query is UNSAT-- no more guesses

--------------------------------
guess 1

%0:i32 = var

Cost = 0
second query is SAT-- constant doesn't work
Dataflow Pruned 0/0
There are 2 Guesses
There are 0 RHSs before deduplication
There are 0 RHSs after deduplication
got 3 candidates from LHS

-------------------------------------------------
%0:i32 = var
%1:i32 = var
%2:i1 = ult %0, %1
infer %2


--------------------------------
guess 0

%0:i1 = var ; reservedconst_1

Cost = 0
first query is SAT, returning the model:
reservedconst_1: 0
0 th attempt: second query is SAT-- constant doesn't work
first query is SAT, returning the model:
reservedconst_1: -1
1 th attempt: second query is SAT-- constant doesn't work
first query is UNSAT-- no more guesses
Dataflow Pruned 0/0
There are 1 Guesses
There are 0 RHSs before deduplication
There are 0 RHSs after deduplication
got 3 candidates from LHS

-------------------------------------------------
%0:i32 = var
%1:i32 = var
%2:i1 = slt %0, %1
infer %2


--------------------------------
guess 0

%0:i1 = var ; reservedconst_1

Cost = 0
first query is SAT, returning the model:
reservedconst_1: 0
0 th attempt: second query is SAT-- constant doesn't work
first query is SAT, returning the model:
reservedconst_1: -1
1 th attempt: second query is SAT-- constant doesn't work
first query is UNSAT-- no more guesses
Dataflow Pruned 0/0
There are 1 Guesses
There are 0 RHSs before deduplication
There are 0 RHSs after deduplication
got 3 candidates from LHS

-------------------------------------------------
%0:i32 = var
%1:i32 = var
%2:i1 = eq %0, %1
infer %2


--------------------------------
guess 0

%0:i1 = var ; reservedconst_1

Cost = 0
first query is SAT, returning the model:
reservedconst_1: -1
0 th attempt: second query is SAT-- constant doesn't work
first query is SAT, returning the model:
reservedconst_1: 0
1 th attempt: second query is SAT-- constant doesn't work
first query is UNSAT-- no more guesses
Dataflow Pruned 0/0
There are 1 Guesses
There are 0 RHSs before deduplication
There are 0 RHSs after deduplication
got 3 candidates from LHS

-------------------------------------------------
%0:i32 = var
%1:i32 = var
%2:i1 = ne %0, %1
infer %2


--------------------------------
guess 0

%0:i1 = var ; reservedconst_1

Cost = 0
first query is SAT, returning the model:
reservedconst_1: 0
0 th attempt: second query is SAT-- constant doesn't work
first query is SAT, returning the model:
reservedconst_1: -1
1 th attempt: second query is SAT-- constant doesn't work
first query is UNSAT-- no more guesses
Dataflow Pruned 0/0
There are 1 Guesses
There are 0 RHSs before deduplication
There are 0 RHSs after deduplication
#########################################################
; exiting Souper's runOnFunction() for cycleSort()

; entering Souper's runOnFunction() for __main_argc_argv()

; ModuleID = './Sorting_algorithms-Cycle_sort.c.bc'
source_filename = "./Sorting_algorithms-Cycle_sort.c"
target datalayout = "e-m:e-p:32:32-i64:64-n32:64-S128"
target triple = "wasm32-unknown-wasi"

@__const.__main_argc_argv.arr = private unnamed_addr constant [16 x i32] [i32 0, i32 1, i32 2, i32 2, i32 2, i32 2, i32 1, i32 9, i32 3, i32 5, i32 5, i32 8, i32 4, i32 7, i32 0, i32 6], align 16
@.str = private unnamed_addr constant [12 x i8] c"writes: %d\0A\00", align 1
@.str.1 = private unnamed_addr constant [4 x i8] c"%d \00", align 1

; Function Attrs: noinline nounwind optnone
define hidden i32 @cycleSort(i32* %list, i32 %l_len) #0 {
entry:
  %list.addr = alloca i32*, align 4
  %l_len.addr = alloca i32, align 4
  %writes = alloca i32, align 4
  %cycleStart = alloca i32, align 4
  %item = alloca i32, align 4
  %swap_tmp = alloca i32, align 4
  %pos = alloca i32, align 4
  %i = alloca i32, align 4
  %i19 = alloca i32, align 4
  store i32* %list, i32** %list.addr, align 4
  store i32 %l_len, i32* %l_len.addr, align 4
  store i32 0, i32* %writes, align 4
  store i32 0, i32* %cycleStart, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc42, %entry
  %0 = load i32, i32* %cycleStart, align 4
  %1 = load i32, i32* %l_len.addr, align 4
  %sub = sub i32 %1, 1
  %cmp = icmp ult i32 %0, %sub
  br i1 %cmp, label %for.body, label %for.end44

for.body:                                         ; preds = %for.cond
  %2 = load i32*, i32** %list.addr, align 4
  %3 = load i32, i32* %cycleStart, align 4
  %arrayidx = getelementptr inbounds i32, i32* %2, i32 %3
  %4 = load i32, i32* %arrayidx, align 4
  store i32 %4, i32* %item, align 4
  %5 = load i32, i32* %cycleStart, align 4
  store i32 %5, i32* %pos, align 4
  %6 = load i32, i32* %cycleStart, align 4
  %add = add nsw i32 %6, 1
  store i32 %add, i32* %i, align 4
  br label %for.cond1

for.cond1:                                        ; preds = %for.inc, %for.body
  %7 = load i32, i32* %i, align 4
  %8 = load i32, i32* %l_len.addr, align 4
  %cmp2 = icmp ult i32 %7, %8
  br i1 %cmp2, label %for.body3, label %for.end

for.body3:                                        ; preds = %for.cond1
  %9 = load i32*, i32** %list.addr, align 4
  %10 = load i32, i32* %i, align 4
  %arrayidx4 = getelementptr inbounds i32, i32* %9, i32 %10
  %11 = load i32, i32* %arrayidx4, align 4
  %12 = load i32, i32* %item, align 4
  %cmp5 = icmp slt i32 %11, %12
  br i1 %cmp5, label %if.then, label %if.end

if.then:                                          ; preds = %for.body3
  %13 = load i32, i32* %pos, align 4
  %inc = add nsw i32 %13, 1
  store i32 %inc, i32* %pos, align 4
  br label %if.end

if.end:                                           ; preds = %if.then, %for.body3
  br label %for.inc

for.inc:                                          ; preds = %if.end
  %14 = load i32, i32* %i, align 4
  %inc6 = add nsw i32 %14, 1
  store i32 %inc6, i32* %i, align 4
  br label %for.cond1

for.end:                                          ; preds = %for.cond1
  %15 = load i32, i32* %pos, align 4
  %16 = load i32, i32* %cycleStart, align 4
  %cmp7 = icmp eq i32 %15, %16
  br i1 %cmp7, label %if.then8, label %if.end9

if.then8:                                         ; preds = %for.end
  br label %for.inc42

if.end9:                                          ; preds = %for.end
  br label %while.cond

while.cond:                                       ; preds = %while.body, %if.end9
  %17 = load i32, i32* %item, align 4
  %18 = load i32*, i32** %list.addr, align 4
  %19 = load i32, i32* %pos, align 4
  %arrayidx10 = getelementptr inbounds i32, i32* %18, i32 %19
  %20 = load i32, i32* %arrayidx10, align 4
  %cmp11 = icmp eq i32 %17, %20
  br i1 %cmp11, label %while.body, label %while.end

while.body:                                       ; preds = %while.cond
  %21 = load i32, i32* %pos, align 4
  %inc12 = add nsw i32 %21, 1
  store i32 %inc12, i32* %pos, align 4
  br label %while.cond

while.end:                                        ; preds = %while.cond
  %22 = load i32*, i32** %list.addr, align 4
  %23 = load i32, i32* %pos, align 4
  %arrayidx13 = getelementptr inbounds i32, i32* %22, i32 %23
  %24 = load i32, i32* %arrayidx13, align 4
  store i32 %24, i32* %swap_tmp, align 4
  %25 = load i32, i32* %item, align 4
  %26 = load i32*, i32** %list.addr, align 4
  %27 = load i32, i32* %pos, align 4
  %arrayidx14 = getelementptr inbounds i32, i32* %26, i32 %27
  store i32 %25, i32* %arrayidx14, align 4
  %28 = load i32, i32* %swap_tmp, align 4
  store i32 %28, i32* %item, align 4
  %29 = load i32, i32* %writes, align 4
  %inc15 = add nsw i32 %29, 1
  store i32 %inc15, i32* %writes, align 4
  br label %while.cond16

while.cond16:                                     ; preds = %while.end37, %while.end
  %30 = load i32, i32* %pos, align 4
  %31 = load i32, i32* %cycleStart, align 4
  %cmp17 = icmp ne i32 %30, %31
  br i1 %cmp17, label %while.body18, label %while.end41

while.body18:                                     ; preds = %while.cond16
  %32 = load i32, i32* %cycleStart, align 4
  store i32 %32, i32* %pos, align 4
  %33 = load i32, i32* %cycleStart, align 4
  %add20 = add nsw i32 %33, 1
  store i32 %add20, i32* %i19, align 4
  br label %for.cond21

for.cond21:                                       ; preds = %for.inc29, %while.body18
  %34 = load i32, i32* %i19, align 4
  %35 = load i32, i32* %l_len.addr, align 4
  %cmp22 = icmp ult i32 %34, %35
  br i1 %cmp22, label %for.body23, label %for.end31

for.body23:                                       ; preds = %for.cond21
  %36 = load i32*, i32** %list.addr, align 4
  %37 = load i32, i32* %i19, align 4
  %arrayidx24 = getelementptr inbounds i32, i32* %36, i32 %37
  %38 = load i32, i32* %arrayidx24, align 4
  %39 = load i32, i32* %item, align 4
  %cmp25 = icmp slt i32 %38, %39
  br i1 %cmp25, label %if.then26, label %if.end28

if.then26:                                        ; preds = %for.body23
  %40 = load i32, i32* %pos, align 4
  %inc27 = add nsw i32 %40, 1
  store i32 %inc27, i32* %pos, align 4
  br label %if.end28

if.end28:                                         ; preds = %if.then26, %for.body23
  br label %for.inc29

for.inc29:                                        ; preds = %if.end28
  %41 = load i32, i32* %i19, align 4
  %inc30 = add nsw i32 %41, 1
  store i32 %inc30, i32* %i19, align 4
  br label %for.cond21

for.end31:                                        ; preds = %for.cond21
  br label %while.cond32

while.cond32:                                     ; preds = %while.body35, %for.end31
  %42 = load i32, i32* %item, align 4
  %43 = load i32*, i32** %list.addr, align 4
  %44 = load i32, i32* %pos, align 4
  %arrayidx33 = getelementptr inbounds i32, i32* %43, i32 %44
  %45 = load i32, i32* %arrayidx33, align 4
  %cmp34 = icmp eq i32 %42, %45
  br i1 %cmp34, label %while.body35, label %while.end37

while.body35:                                     ; preds = %while.cond32
  %46 = load i32, i32* %pos, align 4
  %inc36 = add nsw i32 %46, 1
  store i32 %inc36, i32* %pos, align 4
  br label %while.cond32

while.end37:                                      ; preds = %while.cond32
  %47 = load i32*, i32** %list.addr, align 4
  %48 = load i32, i32* %pos, align 4
  %arrayidx38 = getelementptr inbounds i32, i32* %47, i32 %48
  %49 = load i32, i32* %arrayidx38, align 4
  store i32 %49, i32* %swap_tmp, align 4
  %50 = load i32, i32* %item, align 4
  %51 = load i32*, i32** %list.addr, align 4
  %52 = load i32, i32* %pos, align 4
  %arrayidx39 = getelementptr inbounds i32, i32* %51, i32 %52
  store i32 %50, i32* %arrayidx39, align 4
  %53 = load i32, i32* %swap_tmp, align 4
  store i32 %53, i32* %item, align 4
  %54 = load i32, i32* %writes, align 4
  %inc40 = add nsw i32 %54, 1
  store i32 %inc40, i32* %writes, align 4
  br label %while.cond16

while.end41:                                      ; preds = %while.cond16
  br label %for.inc42

for.inc42:                                        ; preds = %while.end41, %if.then8
  %55 = load i32, i32* %cycleStart, align 4
  %inc43 = add nsw i32 %55, 1
  store i32 %inc43, i32* %cycleStart, align 4
  br label %for.cond

for.end44:                                        ; preds = %for.cond
  %56 = load i32, i32* %writes, align 4
  ret i32 %56
}

; Function Attrs: noinline nounwind optnone
define hidden i32 @__main_argc_argv(i32 %argc, i8** %argv) #0 {
entry:
  %retval = alloca i32, align 4
  %argc.addr = alloca i32, align 4
  %argv.addr = alloca i8**, align 4
  %arr = alloca [16 x i32], align 16
  %arr_k = alloca i32, align 4
  %writes = alloca i32, align 4
  store i32 0, i32* %retval, align 4
  store i32 %argc, i32* %argc.addr, align 4
  store i8** %argv, i8*** %argv.addr, align 4
  %0 = bitcast [16 x i32]* %arr to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 16 %0, i8* align 16 bitcast ([16 x i32]* @__const.__main_argc_argv.arr to i8*), i32 64, i1 false)
  store i32 16, i32* %arr_k, align 4
  %arraydecay = getelementptr inbounds [16 x i32], [16 x i32]* %arr, i32 0, i32 0
  %1 = load i32, i32* %arr_k, align 4
  call void @show_array(i32* %arraydecay, i32 %1)
  %arraydecay1 = getelementptr inbounds [16 x i32], [16 x i32]* %arr, i32 0, i32 0
  %2 = load i32, i32* %arr_k, align 4
  %call = call i32 @cycleSort(i32* %arraydecay1, i32 %2)
  store i32 %call, i32* %writes, align 4
  %arraydecay2 = getelementptr inbounds [16 x i32], [16 x i32]* %arr, i32 0, i32 0
  %3 = load i32, i32* %arr_k, align 4
  call void @show_array(i32* %arraydecay2, i32 %3)
  %4 = load i32, i32* %writes, align 4
  %call3 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([12 x i8], [12 x i8]* @.str, i32 0, i32 0), i32 %4)
  ret i32 0
}

; Function Attrs: argmemonly nounwind willreturn
declare void @llvm.memcpy.p0i8.p0i8.i32(i8* noalias nocapture writeonly %0, i8* noalias nocapture readonly %1, i32 %2, i1 immarg %3) #1

; Function Attrs: noinline nounwind optnone
define hidden void @show_array(i32* %array, i32 %a_len) #0 {
entry:
  %array.addr = alloca i32*, align 4
  %a_len.addr = alloca i32, align 4
  %ix = alloca i32, align 4
  store i32* %array, i32** %array.addr, align 4
  store i32 %a_len, i32* %a_len.addr, align 4
  store i32 0, i32* %ix, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %0 = load i32, i32* %ix, align 4
  %1 = load i32, i32* %a_len.addr, align 4
  %cmp = icmp ult i32 %0, %1
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %2 = load i32*, i32** %array.addr, align 4
  %3 = load i32, i32* %ix, align 4
  %arrayidx = getelementptr inbounds i32, i32* %2, i32 %3
  %4 = load i32, i32* %arrayidx, align 4
  %call = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([4 x i8], [4 x i8]* @.str.1, i32 0, i32 0), i32 %4)
  br label %for.inc

for.inc:                                          ; preds = %for.body
  %5 = load i32, i32* %ix, align 4
  %inc = add nsw i32 %5, 1
  store i32 %inc, i32* %ix, align 4
  br label %for.cond

for.end:                                          ; preds = %for.cond
  %call1 = call i32 @putchar(i32 10)
  ret void
}

declare i32 @printf(i8* %0, ...) #2

declare i32 @putchar(i32 %0) #2

attributes #0 = { noinline nounwind optnone "correctly-rounded-divide-sqrt-fp-math"="false" "disable-tail-calls"="false" "frame-pointer"="none" "less-precise-fpmad"="false" "min-legal-vector-width"="0" "no-infs-fp-math"="false" "no-jump-tables"="false" "no-nans-fp-math"="false" "no-signed-zeros-fp-math"="false" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="generic" "unsafe-fp-math"="false" "use-soft-float"="false" }
attributes #1 = { argmemonly nounwind willreturn }
attributes #2 = { "correctly-rounded-divide-sqrt-fp-math"="false" "disable-tail-calls"="false" "frame-pointer"="none" "less-precise-fpmad"="false" "no-infs-fp-math"="false" "no-nans-fp-math"="false" "no-signed-zeros-fp-math"="false" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="generic" "unsafe-fp-math"="false" "use-soft-float"="false" }

!llvm.module.flags = !{!0}
!llvm.ident = !{!1}

!0 = !{i32 1, !"wchar_size", i32 4}
!1 = !{!"clang version 11.0.0 (https://github.com/Jacarte/llvm-project.git 0f6dea67136cc1e0b3d200eb2bb165628970c44b)"}

; extracted candidates

; *****
; For LLVM instruction:
;  %1 = load i32, i32* %arr_k, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %2 = load i32, i32* %arr_k, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %call = call i32 @cycleSort(i32* %arraydecay1, i32 %2)
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %3 = load i32, i32* %arr_k, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %4 = load i32, i32* %writes, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0
#########################################################
; exiting Souper's runOnFunction() for __main_argc_argv()

; entering Souper's runOnFunction() for show_array()

; ModuleID = './Sorting_algorithms-Cycle_sort.c.bc'
source_filename = "./Sorting_algorithms-Cycle_sort.c"
target datalayout = "e-m:e-p:32:32-i64:64-n32:64-S128"
target triple = "wasm32-unknown-wasi"

@__const.__main_argc_argv.arr = private unnamed_addr constant [16 x i32] [i32 0, i32 1, i32 2, i32 2, i32 2, i32 2, i32 1, i32 9, i32 3, i32 5, i32 5, i32 8, i32 4, i32 7, i32 0, i32 6], align 16
@.str = private unnamed_addr constant [12 x i8] c"writes: %d\0A\00", align 1
@.str.1 = private unnamed_addr constant [4 x i8] c"%d \00", align 1

; Function Attrs: noinline nounwind optnone
define hidden i32 @cycleSort(i32* %list, i32 %l_len) #0 {
entry:
  %list.addr = alloca i32*, align 4
  %l_len.addr = alloca i32, align 4
  %writes = alloca i32, align 4
  %cycleStart = alloca i32, align 4
  %item = alloca i32, align 4
  %swap_tmp = alloca i32, align 4
  %pos = alloca i32, align 4
  %i = alloca i32, align 4
  %i19 = alloca i32, align 4
  store i32* %list, i32** %list.addr, align 4
  store i32 %l_len, i32* %l_len.addr, align 4
  store i32 0, i32* %writes, align 4
  store i32 0, i32* %cycleStart, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc42, %entry
  %0 = load i32, i32* %cycleStart, align 4
  %1 = load i32, i32* %l_len.addr, align 4
  %sub = sub i32 %1, 1
  %cmp = icmp ult i32 %0, %sub
  br i1 %cmp, label %for.body, label %for.end44

for.body:                                         ; preds = %for.cond
  %2 = load i32*, i32** %list.addr, align 4
  %3 = load i32, i32* %cycleStart, align 4
  %arrayidx = getelementptr inbounds i32, i32* %2, i32 %3
  %4 = load i32, i32* %arrayidx, align 4
  store i32 %4, i32* %item, align 4
  %5 = load i32, i32* %cycleStart, align 4
  store i32 %5, i32* %pos, align 4
  %6 = load i32, i32* %cycleStart, align 4
  %add = add nsw i32 %6, 1
  store i32 %add, i32* %i, align 4
  br label %for.cond1

for.cond1:                                        ; preds = %for.inc, %for.body
  %7 = load i32, i32* %i, align 4
  %8 = load i32, i32* %l_len.addr, align 4
  %cmp2 = icmp ult i32 %7, %8
  br i1 %cmp2, label %for.body3, label %for.end

for.body3:                                        ; preds = %for.cond1
  %9 = load i32*, i32** %list.addr, align 4
  %10 = load i32, i32* %i, align 4
  %arrayidx4 = getelementptr inbounds i32, i32* %9, i32 %10
  %11 = load i32, i32* %arrayidx4, align 4
  %12 = load i32, i32* %item, align 4
  %cmp5 = icmp slt i32 %11, %12
  br i1 %cmp5, label %if.then, label %if.end

if.then:                                          ; preds = %for.body3
  %13 = load i32, i32* %pos, align 4
  %inc = add nsw i32 %13, 1
  store i32 %inc, i32* %pos, align 4
  br label %if.end

if.end:                                           ; preds = %if.then, %for.body3
  br label %for.inc

for.inc:                                          ; preds = %if.end
  %14 = load i32, i32* %i, align 4
  %inc6 = add nsw i32 %14, 1
  store i32 %inc6, i32* %i, align 4
  br label %for.cond1

for.end:                                          ; preds = %for.cond1
  %15 = load i32, i32* %pos, align 4
  %16 = load i32, i32* %cycleStart, align 4
  %cmp7 = icmp eq i32 %15, %16
  br i1 %cmp7, label %if.then8, label %if.end9

if.then8:                                         ; preds = %for.end
  br label %for.inc42

if.end9:                                          ; preds = %for.end
  br label %while.cond

while.cond:                                       ; preds = %while.body, %if.end9
  %17 = load i32, i32* %item, align 4
  %18 = load i32*, i32** %list.addr, align 4
  %19 = load i32, i32* %pos, align 4
  %arrayidx10 = getelementptr inbounds i32, i32* %18, i32 %19
  %20 = load i32, i32* %arrayidx10, align 4
  %cmp11 = icmp eq i32 %17, %20
  br i1 %cmp11, label %while.body, label %while.end

while.body:                                       ; preds = %while.cond
  %21 = load i32, i32* %pos, align 4
  %inc12 = add nsw i32 %21, 1
  store i32 %inc12, i32* %pos, align 4
  br label %while.cond

while.end:                                        ; preds = %while.cond
  %22 = load i32*, i32** %list.addr, align 4
  %23 = load i32, i32* %pos, align 4
  %arrayidx13 = getelementptr inbounds i32, i32* %22, i32 %23
  %24 = load i32, i32* %arrayidx13, align 4
  store i32 %24, i32* %swap_tmp, align 4
  %25 = load i32, i32* %item, align 4
  %26 = load i32*, i32** %list.addr, align 4
  %27 = load i32, i32* %pos, align 4
  %arrayidx14 = getelementptr inbounds i32, i32* %26, i32 %27
  store i32 %25, i32* %arrayidx14, align 4
  %28 = load i32, i32* %swap_tmp, align 4
  store i32 %28, i32* %item, align 4
  %29 = load i32, i32* %writes, align 4
  %inc15 = add nsw i32 %29, 1
  store i32 %inc15, i32* %writes, align 4
  br label %while.cond16

while.cond16:                                     ; preds = %while.end37, %while.end
  %30 = load i32, i32* %pos, align 4
  %31 = load i32, i32* %cycleStart, align 4
  %cmp17 = icmp ne i32 %30, %31
  br i1 %cmp17, label %while.body18, label %while.end41

while.body18:                                     ; preds = %while.cond16
  %32 = load i32, i32* %cycleStart, align 4
  store i32 %32, i32* %pos, align 4
  %33 = load i32, i32* %cycleStart, align 4
  %add20 = add nsw i32 %33, 1
  store i32 %add20, i32* %i19, align 4
  br label %for.cond21

for.cond21:                                       ; preds = %for.inc29, %while.body18
  %34 = load i32, i32* %i19, align 4
  %35 = load i32, i32* %l_len.addr, align 4
  %cmp22 = icmp ult i32 %34, %35
  br i1 %cmp22, label %for.body23, label %for.end31

for.body23:                                       ; preds = %for.cond21
  %36 = load i32*, i32** %list.addr, align 4
  %37 = load i32, i32* %i19, align 4
  %arrayidx24 = getelementptr inbounds i32, i32* %36, i32 %37
  %38 = load i32, i32* %arrayidx24, align 4
  %39 = load i32, i32* %item, align 4
  %cmp25 = icmp slt i32 %38, %39
  br i1 %cmp25, label %if.then26, label %if.end28

if.then26:                                        ; preds = %for.body23
  %40 = load i32, i32* %pos, align 4
  %inc27 = add nsw i32 %40, 1
  store i32 %inc27, i32* %pos, align 4
  br label %if.end28

if.end28:                                         ; preds = %if.then26, %for.body23
  br label %for.inc29

for.inc29:                                        ; preds = %if.end28
  %41 = load i32, i32* %i19, align 4
  %inc30 = add nsw i32 %41, 1
  store i32 %inc30, i32* %i19, align 4
  br label %for.cond21

for.end31:                                        ; preds = %for.cond21
  br label %while.cond32

while.cond32:                                     ; preds = %while.body35, %for.end31
  %42 = load i32, i32* %item, align 4
  %43 = load i32*, i32** %list.addr, align 4
  %44 = load i32, i32* %pos, align 4
  %arrayidx33 = getelementptr inbounds i32, i32* %43, i32 %44
  %45 = load i32, i32* %arrayidx33, align 4
  %cmp34 = icmp eq i32 %42, %45
  br i1 %cmp34, label %while.body35, label %while.end37

while.body35:                                     ; preds = %while.cond32
  %46 = load i32, i32* %pos, align 4
  %inc36 = add nsw i32 %46, 1
  store i32 %inc36, i32* %pos, align 4
  br label %while.cond32

while.end37:                                      ; preds = %while.cond32
  %47 = load i32*, i32** %list.addr, align 4
  %48 = load i32, i32* %pos, align 4
  %arrayidx38 = getelementptr inbounds i32, i32* %47, i32 %48
  %49 = load i32, i32* %arrayidx38, align 4
  store i32 %49, i32* %swap_tmp, align 4
  %50 = load i32, i32* %item, align 4
  %51 = load i32*, i32** %list.addr, align 4
  %52 = load i32, i32* %pos, align 4
  %arrayidx39 = getelementptr inbounds i32, i32* %51, i32 %52
  store i32 %50, i32* %arrayidx39, align 4
  %53 = load i32, i32* %swap_tmp, align 4
  store i32 %53, i32* %item, align 4
  %54 = load i32, i32* %writes, align 4
  %inc40 = add nsw i32 %54, 1
  store i32 %inc40, i32* %writes, align 4
  br label %while.cond16

while.end41:                                      ; preds = %while.cond16
  br label %for.inc42

for.inc42:                                        ; preds = %while.end41, %if.then8
  %55 = load i32, i32* %cycleStart, align 4
  %inc43 = add nsw i32 %55, 1
  store i32 %inc43, i32* %cycleStart, align 4
  br label %for.cond

for.end44:                                        ; preds = %for.cond
  %56 = load i32, i32* %writes, align 4
  ret i32 %56
}

; Function Attrs: noinline nounwind optnone
define hidden i32 @__main_argc_argv(i32 %argc, i8** %argv) #0 {
entry:
  %retval = alloca i32, align 4
  %argc.addr = alloca i32, align 4
  %argv.addr = alloca i8**, align 4
  %arr = alloca [16 x i32], align 16
  %arr_k = alloca i32, align 4
  %writes = alloca i32, align 4
  store i32 0, i32* %retval, align 4
  store i32 %argc, i32* %argc.addr, align 4
  store i8** %argv, i8*** %argv.addr, align 4
  %0 = bitcast [16 x i32]* %arr to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 16 %0, i8* align 16 bitcast ([16 x i32]* @__const.__main_argc_argv.arr to i8*), i32 64, i1 false)
  store i32 16, i32* %arr_k, align 4
  %arraydecay = getelementptr inbounds [16 x i32], [16 x i32]* %arr, i32 0, i32 0
  %1 = load i32, i32* %arr_k, align 4
  call void @show_array(i32* %arraydecay, i32 %1)
  %arraydecay1 = getelementptr inbounds [16 x i32], [16 x i32]* %arr, i32 0, i32 0
  %2 = load i32, i32* %arr_k, align 4
  %call = call i32 @cycleSort(i32* %arraydecay1, i32 %2)
  store i32 %call, i32* %writes, align 4
  %arraydecay2 = getelementptr inbounds [16 x i32], [16 x i32]* %arr, i32 0, i32 0
  %3 = load i32, i32* %arr_k, align 4
  call void @show_array(i32* %arraydecay2, i32 %3)
  %4 = load i32, i32* %writes, align 4
  %call3 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([12 x i8], [12 x i8]* @.str, i32 0, i32 0), i32 %4)
  ret i32 0
}

; Function Attrs: argmemonly nounwind willreturn
declare void @llvm.memcpy.p0i8.p0i8.i32(i8* noalias nocapture writeonly %0, i8* noalias nocapture readonly %1, i32 %2, i1 immarg %3) #1

; Function Attrs: noinline nounwind optnone
define hidden void @show_array(i32* %array, i32 %a_len) #0 {
entry:
  %array.addr = alloca i32*, align 4
  %a_len.addr = alloca i32, align 4
  %ix = alloca i32, align 4
  store i32* %array, i32** %array.addr, align 4
  store i32 %a_len, i32* %a_len.addr, align 4
  store i32 0, i32* %ix, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %0 = load i32, i32* %ix, align 4
  %1 = load i32, i32* %a_len.addr, align 4
  %cmp = icmp ult i32 %0, %1
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %2 = load i32*, i32** %array.addr, align 4
  %3 = load i32, i32* %ix, align 4
  %arrayidx = getelementptr inbounds i32, i32* %2, i32 %3
  %4 = load i32, i32* %arrayidx, align 4
  %call = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([4 x i8], [4 x i8]* @.str.1, i32 0, i32 0), i32 %4)
  br label %for.inc

for.inc:                                          ; preds = %for.body
  %5 = load i32, i32* %ix, align 4
  %inc = add nsw i32 %5, 1
  store i32 %inc, i32* %ix, align 4
  br label %for.cond

for.end:                                          ; preds = %for.cond
  %call1 = call i32 @putchar(i32 10)
  ret void
}

declare i32 @printf(i8* %0, ...) #2

declare i32 @putchar(i32 %0) #2

attributes #0 = { noinline nounwind optnone "correctly-rounded-divide-sqrt-fp-math"="false" "disable-tail-calls"="false" "frame-pointer"="none" "less-precise-fpmad"="false" "min-legal-vector-width"="0" "no-infs-fp-math"="false" "no-jump-tables"="false" "no-nans-fp-math"="false" "no-signed-zeros-fp-math"="false" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="generic" "unsafe-fp-math"="false" "use-soft-float"="false" }
attributes #1 = { argmemonly nounwind willreturn }
attributes #2 = { "correctly-rounded-divide-sqrt-fp-math"="false" "disable-tail-calls"="false" "frame-pointer"="none" "less-precise-fpmad"="false" "no-infs-fp-math"="false" "no-nans-fp-math"="false" "no-signed-zeros-fp-math"="false" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="generic" "unsafe-fp-math"="false" "use-soft-float"="false" }

!llvm.module.flags = !{!0}
!llvm.ident = !{!1}

!0 = !{i32 1, !"wchar_size", i32 4}
!1 = !{!"clang version 11.0.0 (https://github.com/Jacarte/llvm-project.git 0f6dea67136cc1e0b3d200eb2bb165628970c44b)"}

; extracted candidates

; *****
; For LLVM instruction:
;  %0 = load i32, i32* %ix, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %1 = load i32, i32* %a_len.addr, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %cmp = icmp ult i32 %0, %1
; Looking for a replacement for:
%0:i32 = var
%1:i32 = var
%2:i1 = ult %0, %1
infer %2

; *****
; For LLVM instruction:
;  %3 = load i32, i32* %ix, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %4 = load i32, i32* %arrayidx, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %5 = load i32, i32* %ix, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %inc = add nsw i32 %5, 1
; Looking for a replacement for:
%0:i32 = var
%1:i32 = addnsw 1:i32, %0
infer %1
#########################################################
; exiting Souper's runOnFunction() for show_array()
Total of 0 replacements done on this module
Total of 0 replacements candidates on this module
