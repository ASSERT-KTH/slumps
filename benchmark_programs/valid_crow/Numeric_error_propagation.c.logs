
Entering the Souper pass's runOnModule()


; entering Souper's runOnFunction() for imprecise_add()

; ModuleID = './Numeric_error_propagation.c.bc'
source_filename = "./Numeric_error_propagation.c"
target datalayout = "e-m:e-p:32:32-i64:64-n32:64-S128"
target triple = "wasm32-unknown-wasi"

%struct.imprecise = type { double, double }

@.str = private unnamed_addr constant [3 x i8] c"%f\00", align 1
@__const.main.x1 = private unnamed_addr constant %struct.imprecise { double 1.000000e+02, double 1.100000e+00 }, align 8
@__const.main.y1 = private unnamed_addr constant %struct.imprecise { double 5.000000e+01, double 1.200000e+00 }, align 8
@__const.main.x2 = private unnamed_addr constant %struct.imprecise { double -2.000000e+02, double 2.200000e+00 }, align 8
@__const.main.y2 = private unnamed_addr constant %struct.imprecise { double -1.000000e+02, double 2.300000e+00 }, align 8
@.str.1 = private unnamed_addr constant [44 x i8] c"Distance, d, between the following points :\00", align 1
@.str.2 = private unnamed_addr constant [23 x i8] c"\0A( x1, y1) = ( %s, %s)\00", align 1
@.str.3 = private unnamed_addr constant [23 x i8] c"\0A( x2, y2) = ( %s, %s)\00", align 1
@.str.4 = private unnamed_addr constant [11 x i8] c"\0Ais d = %s\00", align 1
@llvm.used = appending global [1 x i8*] [i8* bitcast (i32 ()* @__main_void to i8*)], section "llvm.metadata"

@__main_void = alias i32 (), i32 ()* @main

; Function Attrs: noinline nounwind optnone
define hidden void @imprecise_add(%struct.imprecise* noalias sret align 8 %agg.result, %struct.imprecise* byval(%struct.imprecise) align 8 %a, %struct.imprecise* byval(%struct.imprecise) align 8 %b) #0 {
entry:
  %value = getelementptr inbounds %struct.imprecise, %struct.imprecise* %a, i32 0, i32 0
  %0 = load double, double* %value, align 8
  %value1 = getelementptr inbounds %struct.imprecise, %struct.imprecise* %b, i32 0, i32 0
  %1 = load double, double* %value1, align 8
  %add = fadd double %0, %1
  %value2 = getelementptr inbounds %struct.imprecise, %struct.imprecise* %agg.result, i32 0, i32 0
  store double %add, double* %value2, align 8
  %delta = getelementptr inbounds %struct.imprecise, %struct.imprecise* %a, i32 0, i32 1
  %2 = load double, double* %delta, align 8
  %delta3 = getelementptr inbounds %struct.imprecise, %struct.imprecise* %a, i32 0, i32 1
  %3 = load double, double* %delta3, align 8
  %mul = fmul double %2, %3
  %delta4 = getelementptr inbounds %struct.imprecise, %struct.imprecise* %b, i32 0, i32 1
  %4 = load double, double* %delta4, align 8
  %delta5 = getelementptr inbounds %struct.imprecise, %struct.imprecise* %b, i32 0, i32 1
  %5 = load double, double* %delta5, align 8
  %mul6 = fmul double %4, %5
  %add7 = fadd double %mul, %mul6
  %6 = call double @llvm.sqrt.f64(double %add7)
  %delta8 = getelementptr inbounds %struct.imprecise, %struct.imprecise* %agg.result, i32 0, i32 1
  store double %6, double* %delta8, align 8
  ret void
}

; Function Attrs: nounwind readnone speculatable willreturn
declare double @llvm.sqrt.f64(double %0) #1

; Function Attrs: noinline nounwind optnone
define hidden void @imprecise_mul(%struct.imprecise* noalias sret align 8 %agg.result, %struct.imprecise* byval(%struct.imprecise) align 8 %a, %struct.imprecise* byval(%struct.imprecise) align 8 %b) #0 {
entry:
  %value = getelementptr inbounds %struct.imprecise, %struct.imprecise* %a, i32 0, i32 0
  %0 = load double, double* %value, align 8
  %value1 = getelementptr inbounds %struct.imprecise, %struct.imprecise* %b, i32 0, i32 0
  %1 = load double, double* %value1, align 8
  %mul = fmul double %0, %1
  %value2 = getelementptr inbounds %struct.imprecise, %struct.imprecise* %agg.result, i32 0, i32 0
  store double %mul, double* %value2, align 8
  %value3 = getelementptr inbounds %struct.imprecise, %struct.imprecise* %a, i32 0, i32 0
  %2 = load double, double* %value3, align 8
  %delta = getelementptr inbounds %struct.imprecise, %struct.imprecise* %b, i32 0, i32 1
  %3 = load double, double* %delta, align 8
  %mul4 = fmul double %2, %3
  %value5 = getelementptr inbounds %struct.imprecise, %struct.imprecise* %a, i32 0, i32 0
  %4 = load double, double* %value5, align 8
  %delta6 = getelementptr inbounds %struct.imprecise, %struct.imprecise* %b, i32 0, i32 1
  %5 = load double, double* %delta6, align 8
  %mul7 = fmul double %4, %5
  %mul8 = fmul double %mul4, %mul7
  %value9 = getelementptr inbounds %struct.imprecise, %struct.imprecise* %b, i32 0, i32 0
  %6 = load double, double* %value9, align 8
  %delta10 = getelementptr inbounds %struct.imprecise, %struct.imprecise* %a, i32 0, i32 1
  %7 = load double, double* %delta10, align 8
  %mul11 = fmul double %6, %7
  %value12 = getelementptr inbounds %struct.imprecise, %struct.imprecise* %b, i32 0, i32 0
  %8 = load double, double* %value12, align 8
  %delta13 = getelementptr inbounds %struct.imprecise, %struct.imprecise* %a, i32 0, i32 1
  %9 = load double, double* %delta13, align 8
  %mul14 = fmul double %8, %9
  %mul15 = fmul double %mul11, %mul14
  %add = fadd double %mul8, %mul15
  %10 = call double @llvm.sqrt.f64(double %add)
  %delta16 = getelementptr inbounds %struct.imprecise, %struct.imprecise* %agg.result, i32 0, i32 1
  store double %10, double* %delta16, align 8
  ret void
}

; Function Attrs: noinline nounwind optnone
define hidden void @imprecise_div(%struct.imprecise* noalias sret align 8 %agg.result, %struct.imprecise* byval(%struct.imprecise) align 8 %a, %struct.imprecise* byval(%struct.imprecise) align 8 %b) #0 {
entry:
  %value = getelementptr inbounds %struct.imprecise, %struct.imprecise* %a, i32 0, i32 0
  %0 = load double, double* %value, align 8
  %value1 = getelementptr inbounds %struct.imprecise, %struct.imprecise* %b, i32 0, i32 0
  %1 = load double, double* %value1, align 8
  %div = fdiv double %0, %1
  %value2 = getelementptr inbounds %struct.imprecise, %struct.imprecise* %agg.result, i32 0, i32 0
  store double %div, double* %value2, align 8
  %value3 = getelementptr inbounds %struct.imprecise, %struct.imprecise* %a, i32 0, i32 0
  %2 = load double, double* %value3, align 8
  %delta = getelementptr inbounds %struct.imprecise, %struct.imprecise* %b, i32 0, i32 1
  %3 = load double, double* %delta, align 8
  %mul = fmul double %2, %3
  %value4 = getelementptr inbounds %struct.imprecise, %struct.imprecise* %a, i32 0, i32 0
  %4 = load double, double* %value4, align 8
  %delta5 = getelementptr inbounds %struct.imprecise, %struct.imprecise* %b, i32 0, i32 1
  %5 = load double, double* %delta5, align 8
  %mul6 = fmul double %4, %5
  %mul7 = fmul double %mul, %mul6
  %value8 = getelementptr inbounds %struct.imprecise, %struct.imprecise* %b, i32 0, i32 0
  %6 = load double, double* %value8, align 8
  %delta9 = getelementptr inbounds %struct.imprecise, %struct.imprecise* %a, i32 0, i32 1
  %7 = load double, double* %delta9, align 8
  %mul10 = fmul double %6, %7
  %value11 = getelementptr inbounds %struct.imprecise, %struct.imprecise* %b, i32 0, i32 0
  %8 = load double, double* %value11, align 8
  %delta12 = getelementptr inbounds %struct.imprecise, %struct.imprecise* %a, i32 0, i32 1
  %9 = load double, double* %delta12, align 8
  %mul13 = fmul double %8, %9
  %mul14 = fmul double %mul10, %mul13
  %add = fadd double %mul7, %mul14
  %10 = call double @llvm.sqrt.f64(double %add)
  %value15 = getelementptr inbounds %struct.imprecise, %struct.imprecise* %b, i32 0, i32 0
  %11 = load double, double* %value15, align 8
  %value16 = getelementptr inbounds %struct.imprecise, %struct.imprecise* %b, i32 0, i32 0
  %12 = load double, double* %value16, align 8
  %mul17 = fmul double %11, %12
  %div18 = fdiv double %10, %mul17
  %delta19 = getelementptr inbounds %struct.imprecise, %struct.imprecise* %agg.result, i32 0, i32 1
  store double %div18, double* %delta19, align 8
  ret void
}

; Function Attrs: noinline nounwind optnone
define hidden void @imprecise_pow(%struct.imprecise* noalias sret align 8 %agg.result, %struct.imprecise* byval(%struct.imprecise) align 8 %a, double %c) #0 {
entry:
  %c.addr = alloca double, align 8
  store double %c, double* %c.addr, align 8
  %value = getelementptr inbounds %struct.imprecise, %struct.imprecise* %a, i32 0, i32 0
  %0 = load double, double* %value, align 8
  %1 = load double, double* %c.addr, align 8
  %2 = call double @llvm.pow.f64(double %0, double %1)
  %value1 = getelementptr inbounds %struct.imprecise, %struct.imprecise* %agg.result, i32 0, i32 0
  store double %2, double* %value1, align 8
  %value2 = getelementptr inbounds %struct.imprecise, %struct.imprecise* %agg.result, i32 0, i32 0
  %3 = load double, double* %value2, align 8
  %4 = load double, double* %c.addr, align 8
  %mul = fmul double %3, %4
  %delta = getelementptr inbounds %struct.imprecise, %struct.imprecise* %a, i32 0, i32 1
  %5 = load double, double* %delta, align 8
  %mul3 = fmul double %mul, %5
  %value4 = getelementptr inbounds %struct.imprecise, %struct.imprecise* %a, i32 0, i32 0
  %6 = load double, double* %value4, align 8
  %div = fdiv double %mul3, %6
  %7 = call double @llvm.fabs.f64(double %div)
  %delta5 = getelementptr inbounds %struct.imprecise, %struct.imprecise* %agg.result, i32 0, i32 1
  store double %7, double* %delta5, align 8
  ret void
}

; Function Attrs: nounwind readnone speculatable willreturn
declare double @llvm.pow.f64(double %0, double %1) #1

; Function Attrs: nounwind readnone speculatable willreturn
declare double @llvm.fabs.f64(double %0) #1

; Function Attrs: noinline nounwind optnone
define hidden i8* @printImprecise(%struct.imprecise* byval(%struct.imprecise) align 8 %val) #0 {
entry:
  %principal = alloca [30 x i8], align 16
  %error = alloca [30 x i8], align 16
  %string = alloca i8*, align 4
  %sign = alloca [2 x i8], align 1
  %arrayidx = getelementptr inbounds [2 x i8], [2 x i8]* %sign, i32 0, i32 0
  store i8 -15, i8* %arrayidx, align 1
  %arrayidx1 = getelementptr inbounds [2 x i8], [2 x i8]* %sign, i32 0, i32 1
  store i8 0, i8* %arrayidx1, align 1
  %arraydecay = getelementptr inbounds [30 x i8], [30 x i8]* %principal, i32 0, i32 0
  %value = getelementptr inbounds %struct.imprecise, %struct.imprecise* %val, i32 0, i32 0
  %0 = load double, double* %value, align 8
  %call = call i32 (i8*, i8*, ...) @sprintf(i8* %arraydecay, i8* getelementptr inbounds ([3 x i8], [3 x i8]* @.str, i32 0, i32 0), double %0)
  %arraydecay2 = getelementptr inbounds [30 x i8], [30 x i8]* %error, i32 0, i32 0
  %delta = getelementptr inbounds %struct.imprecise, %struct.imprecise* %val, i32 0, i32 1
  %1 = load double, double* %delta, align 8
  %call3 = call i32 (i8*, i8*, ...) @sprintf(i8* %arraydecay2, i8* getelementptr inbounds ([3 x i8], [3 x i8]* @.str, i32 0, i32 0), double %1)
  %arraydecay4 = getelementptr inbounds [30 x i8], [30 x i8]* %principal, i32 0, i32 0
  %call5 = call i32 @strlen(i8* %arraydecay4) #5
  %add = add i32 %call5, 1
  %arraydecay6 = getelementptr inbounds [30 x i8], [30 x i8]* %error, i32 0, i32 0
  %call7 = call i32 @strlen(i8* %arraydecay6) #5
  %add8 = add i32 %add, %call7
  %add9 = add i32 %add8, 1
  %mul = mul i32 %add9, 1
  %call10 = call noalias i8* @malloc(i32 %mul)
  store i8* %call10, i8** %string, align 4
  %2 = load i8*, i8** %string, align 4
  %arraydecay11 = getelementptr inbounds [30 x i8], [30 x i8]* %principal, i32 0, i32 0
  %call12 = call i8* @strcpy(i8* %2, i8* %arraydecay11)
  %3 = load i8*, i8** %string, align 4
  %arraydecay13 = getelementptr inbounds [2 x i8], [2 x i8]* %sign, i32 0, i32 0
  %call14 = call i8* @strcat(i8* %3, i8* %arraydecay13)
  %4 = load i8*, i8** %string, align 4
  %arraydecay15 = getelementptr inbounds [30 x i8], [30 x i8]* %error, i32 0, i32 0
  %call16 = call i8* @strcat(i8* %4, i8* %arraydecay15)
  %5 = load i8*, i8** %string, align 4
  ret i8* %5
}

declare i32 @sprintf(i8* %0, i8* %1, ...) #2

declare noalias i8* @malloc(i32 %0) #2

; Function Attrs: nounwind readonly
declare i32 @strlen(i8* %0) #3

declare i8* @strcpy(i8* %0, i8* %1) #2

declare i8* @strcat(i8* %0, i8* %1) #2

; Function Attrs: noinline nounwind optnone
define hidden i32 @main() #0 {
entry:
  %retval = alloca i32, align 4
  %x1 = alloca %struct.imprecise, align 8
  %y1 = alloca %struct.imprecise, align 8
  %x2 = alloca %struct.imprecise, align 8
  %y2 = alloca %struct.imprecise, align 8
  %d = alloca %struct.imprecise, align 8
  %tmp = alloca %struct.imprecise, align 8
  %agg.tmp = alloca %struct.imprecise, align 8
  %agg.tmp1 = alloca %struct.imprecise, align 8
  %agg.tmp2 = alloca %struct.imprecise, align 8
  %agg.tmp3 = alloca %struct.imprecise, align 8
  %agg.tmp4 = alloca %struct.imprecise, align 8
  store i32 0, i32* %retval, align 4
  %0 = bitcast %struct.imprecise* %x1 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 8 %0, i8* align 8 bitcast (%struct.imprecise* @__const.main.x1 to i8*), i32 16, i1 false)
  %1 = bitcast %struct.imprecise* %y1 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 8 %1, i8* align 8 bitcast (%struct.imprecise* @__const.main.y1 to i8*), i32 16, i1 false)
  %2 = bitcast %struct.imprecise* %x2 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 8 %2, i8* align 8 bitcast (%struct.imprecise* @__const.main.x2 to i8*), i32 16, i1 false)
  %3 = bitcast %struct.imprecise* %y2 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 8 %3, i8* align 8 bitcast (%struct.imprecise* @__const.main.y2 to i8*), i32 16, i1 false)
  call void @imprecise_add(%struct.imprecise* sret align 8 %agg.tmp2, %struct.imprecise* byval(%struct.imprecise) align 8 %x1, %struct.imprecise* byval(%struct.imprecise) align 8 %x2)
  call void @imprecise_pow(%struct.imprecise* sret align 8 %agg.tmp1, %struct.imprecise* byval(%struct.imprecise) align 8 %agg.tmp2, double 2.000000e+00)
  call void @imprecise_add(%struct.imprecise* sret align 8 %agg.tmp4, %struct.imprecise* byval(%struct.imprecise) align 8 %y1, %struct.imprecise* byval(%struct.imprecise) align 8 %y2)
  call void @imprecise_pow(%struct.imprecise* sret align 8 %agg.tmp3, %struct.imprecise* byval(%struct.imprecise) align 8 %agg.tmp4, double 2.000000e+00)
  call void @imprecise_add(%struct.imprecise* sret align 8 %agg.tmp, %struct.imprecise* byval(%struct.imprecise) align 8 %agg.tmp1, %struct.imprecise* byval(%struct.imprecise) align 8 %agg.tmp3)
  call void @imprecise_pow(%struct.imprecise* sret align 8 %tmp, %struct.imprecise* byval(%struct.imprecise) align 8 %agg.tmp, double 5.000000e-01)
  %4 = bitcast %struct.imprecise* %d to i8*
  %5 = bitcast %struct.imprecise* %tmp to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 8 %4, i8* align 8 %5, i32 16, i1 false)
  %call = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([44 x i8], [44 x i8]* @.str.1, i32 0, i32 0))
  %call5 = call i8* @printImprecise(%struct.imprecise* byval(%struct.imprecise) align 8 %x1)
  %call6 = call i8* @printImprecise(%struct.imprecise* byval(%struct.imprecise) align 8 %y1)
  %call7 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([23 x i8], [23 x i8]* @.str.2, i32 0, i32 0), i8* %call5, i8* %call6)
  %call8 = call i8* @printImprecise(%struct.imprecise* byval(%struct.imprecise) align 8 %x2)
  %call9 = call i8* @printImprecise(%struct.imprecise* byval(%struct.imprecise) align 8 %y2)
  %call10 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([23 x i8], [23 x i8]* @.str.3, i32 0, i32 0), i8* %call8, i8* %call9)
  %call11 = call i8* @printImprecise(%struct.imprecise* byval(%struct.imprecise) align 8 %d)
  %call12 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([11 x i8], [11 x i8]* @.str.4, i32 0, i32 0), i8* %call11)
  ret i32 0
}

; Function Attrs: argmemonly nounwind willreturn
declare void @llvm.memcpy.p0i8.p0i8.i32(i8* noalias nocapture writeonly %0, i8* noalias nocapture readonly %1, i32 %2, i1 immarg %3) #4

declare i32 @printf(i8* %0, ...) #2

attributes #0 = { noinline nounwind optnone "correctly-rounded-divide-sqrt-fp-math"="false" "disable-tail-calls"="false" "frame-pointer"="none" "less-precise-fpmad"="false" "min-legal-vector-width"="0" "no-infs-fp-math"="false" "no-jump-tables"="false" "no-nans-fp-math"="false" "no-signed-zeros-fp-math"="false" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="generic" "unsafe-fp-math"="false" "use-soft-float"="false" }
attributes #1 = { nounwind readnone speculatable willreturn }
attributes #2 = { "correctly-rounded-divide-sqrt-fp-math"="false" "disable-tail-calls"="false" "frame-pointer"="none" "less-precise-fpmad"="false" "no-infs-fp-math"="false" "no-nans-fp-math"="false" "no-signed-zeros-fp-math"="false" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="generic" "unsafe-fp-math"="false" "use-soft-float"="false" }
attributes #3 = { nounwind readonly "correctly-rounded-divide-sqrt-fp-math"="false" "disable-tail-calls"="false" "frame-pointer"="none" "less-precise-fpmad"="false" "no-infs-fp-math"="false" "no-nans-fp-math"="false" "no-signed-zeros-fp-math"="false" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="generic" "unsafe-fp-math"="false" "use-soft-float"="false" }
attributes #4 = { argmemonly nounwind willreturn }
attributes #5 = { nounwind readonly }

!llvm.module.flags = !{!0}
!llvm.ident = !{!1}

!0 = !{i32 1, !"wchar_size", i32 4}
!1 = !{!"clang version 11.0.0 (https://github.com/Jacarte/llvm-project.git 0f6dea67136cc1e0b3d200eb2bb165628970c44b)"}

; extracted candidates
#########################################################
; exiting Souper's runOnFunction() for imprecise_add()

; entering Souper's runOnFunction() for imprecise_mul()

; ModuleID = './Numeric_error_propagation.c.bc'
source_filename = "./Numeric_error_propagation.c"
target datalayout = "e-m:e-p:32:32-i64:64-n32:64-S128"
target triple = "wasm32-unknown-wasi"

%struct.imprecise = type { double, double }

@.str = private unnamed_addr constant [3 x i8] c"%f\00", align 1
@__const.main.x1 = private unnamed_addr constant %struct.imprecise { double 1.000000e+02, double 1.100000e+00 }, align 8
@__const.main.y1 = private unnamed_addr constant %struct.imprecise { double 5.000000e+01, double 1.200000e+00 }, align 8
@__const.main.x2 = private unnamed_addr constant %struct.imprecise { double -2.000000e+02, double 2.200000e+00 }, align 8
@__const.main.y2 = private unnamed_addr constant %struct.imprecise { double -1.000000e+02, double 2.300000e+00 }, align 8
@.str.1 = private unnamed_addr constant [44 x i8] c"Distance, d, between the following points :\00", align 1
@.str.2 = private unnamed_addr constant [23 x i8] c"\0A( x1, y1) = ( %s, %s)\00", align 1
@.str.3 = private unnamed_addr constant [23 x i8] c"\0A( x2, y2) = ( %s, %s)\00", align 1
@.str.4 = private unnamed_addr constant [11 x i8] c"\0Ais d = %s\00", align 1
@llvm.used = appending global [1 x i8*] [i8* bitcast (i32 ()* @__main_void to i8*)], section "llvm.metadata"

@__main_void = alias i32 (), i32 ()* @main

; Function Attrs: noinline nounwind optnone
define hidden void @imprecise_add(%struct.imprecise* noalias sret align 8 %agg.result, %struct.imprecise* byval(%struct.imprecise) align 8 %a, %struct.imprecise* byval(%struct.imprecise) align 8 %b) #0 {
entry:
  %value = getelementptr inbounds %struct.imprecise, %struct.imprecise* %a, i32 0, i32 0
  %0 = load double, double* %value, align 8
  %value1 = getelementptr inbounds %struct.imprecise, %struct.imprecise* %b, i32 0, i32 0
  %1 = load double, double* %value1, align 8
  %add = fadd double %0, %1
  %value2 = getelementptr inbounds %struct.imprecise, %struct.imprecise* %agg.result, i32 0, i32 0
  store double %add, double* %value2, align 8
  %delta = getelementptr inbounds %struct.imprecise, %struct.imprecise* %a, i32 0, i32 1
  %2 = load double, double* %delta, align 8
  %delta3 = getelementptr inbounds %struct.imprecise, %struct.imprecise* %a, i32 0, i32 1
  %3 = load double, double* %delta3, align 8
  %mul = fmul double %2, %3
  %delta4 = getelementptr inbounds %struct.imprecise, %struct.imprecise* %b, i32 0, i32 1
  %4 = load double, double* %delta4, align 8
  %delta5 = getelementptr inbounds %struct.imprecise, %struct.imprecise* %b, i32 0, i32 1
  %5 = load double, double* %delta5, align 8
  %mul6 = fmul double %4, %5
  %add7 = fadd double %mul, %mul6
  %6 = call double @llvm.sqrt.f64(double %add7)
  %delta8 = getelementptr inbounds %struct.imprecise, %struct.imprecise* %agg.result, i32 0, i32 1
  store double %6, double* %delta8, align 8
  ret void
}

; Function Attrs: nounwind readnone speculatable willreturn
declare double @llvm.sqrt.f64(double %0) #1

; Function Attrs: noinline nounwind optnone
define hidden void @imprecise_mul(%struct.imprecise* noalias sret align 8 %agg.result, %struct.imprecise* byval(%struct.imprecise) align 8 %a, %struct.imprecise* byval(%struct.imprecise) align 8 %b) #0 {
entry:
  %value = getelementptr inbounds %struct.imprecise, %struct.imprecise* %a, i32 0, i32 0
  %0 = load double, double* %value, align 8
  %value1 = getelementptr inbounds %struct.imprecise, %struct.imprecise* %b, i32 0, i32 0
  %1 = load double, double* %value1, align 8
  %mul = fmul double %0, %1
  %value2 = getelementptr inbounds %struct.imprecise, %struct.imprecise* %agg.result, i32 0, i32 0
  store double %mul, double* %value2, align 8
  %value3 = getelementptr inbounds %struct.imprecise, %struct.imprecise* %a, i32 0, i32 0
  %2 = load double, double* %value3, align 8
  %delta = getelementptr inbounds %struct.imprecise, %struct.imprecise* %b, i32 0, i32 1
  %3 = load double, double* %delta, align 8
  %mul4 = fmul double %2, %3
  %value5 = getelementptr inbounds %struct.imprecise, %struct.imprecise* %a, i32 0, i32 0
  %4 = load double, double* %value5, align 8
  %delta6 = getelementptr inbounds %struct.imprecise, %struct.imprecise* %b, i32 0, i32 1
  %5 = load double, double* %delta6, align 8
  %mul7 = fmul double %4, %5
  %mul8 = fmul double %mul4, %mul7
  %value9 = getelementptr inbounds %struct.imprecise, %struct.imprecise* %b, i32 0, i32 0
  %6 = load double, double* %value9, align 8
  %delta10 = getelementptr inbounds %struct.imprecise, %struct.imprecise* %a, i32 0, i32 1
  %7 = load double, double* %delta10, align 8
  %mul11 = fmul double %6, %7
  %value12 = getelementptr inbounds %struct.imprecise, %struct.imprecise* %b, i32 0, i32 0
  %8 = load double, double* %value12, align 8
  %delta13 = getelementptr inbounds %struct.imprecise, %struct.imprecise* %a, i32 0, i32 1
  %9 = load double, double* %delta13, align 8
  %mul14 = fmul double %8, %9
  %mul15 = fmul double %mul11, %mul14
  %add = fadd double %mul8, %mul15
  %10 = call double @llvm.sqrt.f64(double %add)
  %delta16 = getelementptr inbounds %struct.imprecise, %struct.imprecise* %agg.result, i32 0, i32 1
  store double %10, double* %delta16, align 8
  ret void
}

; Function Attrs: noinline nounwind optnone
define hidden void @imprecise_div(%struct.imprecise* noalias sret align 8 %agg.result, %struct.imprecise* byval(%struct.imprecise) align 8 %a, %struct.imprecise* byval(%struct.imprecise) align 8 %b) #0 {
entry:
  %value = getelementptr inbounds %struct.imprecise, %struct.imprecise* %a, i32 0, i32 0
  %0 = load double, double* %value, align 8
  %value1 = getelementptr inbounds %struct.imprecise, %struct.imprecise* %b, i32 0, i32 0
  %1 = load double, double* %value1, align 8
  %div = fdiv double %0, %1
  %value2 = getelementptr inbounds %struct.imprecise, %struct.imprecise* %agg.result, i32 0, i32 0
  store double %div, double* %value2, align 8
  %value3 = getelementptr inbounds %struct.imprecise, %struct.imprecise* %a, i32 0, i32 0
  %2 = load double, double* %value3, align 8
  %delta = getelementptr inbounds %struct.imprecise, %struct.imprecise* %b, i32 0, i32 1
  %3 = load double, double* %delta, align 8
  %mul = fmul double %2, %3
  %value4 = getelementptr inbounds %struct.imprecise, %struct.imprecise* %a, i32 0, i32 0
  %4 = load double, double* %value4, align 8
  %delta5 = getelementptr inbounds %struct.imprecise, %struct.imprecise* %b, i32 0, i32 1
  %5 = load double, double* %delta5, align 8
  %mul6 = fmul double %4, %5
  %mul7 = fmul double %mul, %mul6
  %value8 = getelementptr inbounds %struct.imprecise, %struct.imprecise* %b, i32 0, i32 0
  %6 = load double, double* %value8, align 8
  %delta9 = getelementptr inbounds %struct.imprecise, %struct.imprecise* %a, i32 0, i32 1
  %7 = load double, double* %delta9, align 8
  %mul10 = fmul double %6, %7
  %value11 = getelementptr inbounds %struct.imprecise, %struct.imprecise* %b, i32 0, i32 0
  %8 = load double, double* %value11, align 8
  %delta12 = getelementptr inbounds %struct.imprecise, %struct.imprecise* %a, i32 0, i32 1
  %9 = load double, double* %delta12, align 8
  %mul13 = fmul double %8, %9
  %mul14 = fmul double %mul10, %mul13
  %add = fadd double %mul7, %mul14
  %10 = call double @llvm.sqrt.f64(double %add)
  %value15 = getelementptr inbounds %struct.imprecise, %struct.imprecise* %b, i32 0, i32 0
  %11 = load double, double* %value15, align 8
  %value16 = getelementptr inbounds %struct.imprecise, %struct.imprecise* %b, i32 0, i32 0
  %12 = load double, double* %value16, align 8
  %mul17 = fmul double %11, %12
  %div18 = fdiv double %10, %mul17
  %delta19 = getelementptr inbounds %struct.imprecise, %struct.imprecise* %agg.result, i32 0, i32 1
  store double %div18, double* %delta19, align 8
  ret void
}

; Function Attrs: noinline nounwind optnone
define hidden void @imprecise_pow(%struct.imprecise* noalias sret align 8 %agg.result, %struct.imprecise* byval(%struct.imprecise) align 8 %a, double %c) #0 {
entry:
  %c.addr = alloca double, align 8
  store double %c, double* %c.addr, align 8
  %value = getelementptr inbounds %struct.imprecise, %struct.imprecise* %a, i32 0, i32 0
  %0 = load double, double* %value, align 8
  %1 = load double, double* %c.addr, align 8
  %2 = call double @llvm.pow.f64(double %0, double %1)
  %value1 = getelementptr inbounds %struct.imprecise, %struct.imprecise* %agg.result, i32 0, i32 0
  store double %2, double* %value1, align 8
  %value2 = getelementptr inbounds %struct.imprecise, %struct.imprecise* %agg.result, i32 0, i32 0
  %3 = load double, double* %value2, align 8
  %4 = load double, double* %c.addr, align 8
  %mul = fmul double %3, %4
  %delta = getelementptr inbounds %struct.imprecise, %struct.imprecise* %a, i32 0, i32 1
  %5 = load double, double* %delta, align 8
  %mul3 = fmul double %mul, %5
  %value4 = getelementptr inbounds %struct.imprecise, %struct.imprecise* %a, i32 0, i32 0
  %6 = load double, double* %value4, align 8
  %div = fdiv double %mul3, %6
  %7 = call double @llvm.fabs.f64(double %div)
  %delta5 = getelementptr inbounds %struct.imprecise, %struct.imprecise* %agg.result, i32 0, i32 1
  store double %7, double* %delta5, align 8
  ret void
}

; Function Attrs: nounwind readnone speculatable willreturn
declare double @llvm.pow.f64(double %0, double %1) #1

; Function Attrs: nounwind readnone speculatable willreturn
declare double @llvm.fabs.f64(double %0) #1

; Function Attrs: noinline nounwind optnone
define hidden i8* @printImprecise(%struct.imprecise* byval(%struct.imprecise) align 8 %val) #0 {
entry:
  %principal = alloca [30 x i8], align 16
  %error = alloca [30 x i8], align 16
  %string = alloca i8*, align 4
  %sign = alloca [2 x i8], align 1
  %arrayidx = getelementptr inbounds [2 x i8], [2 x i8]* %sign, i32 0, i32 0
  store i8 -15, i8* %arrayidx, align 1
  %arrayidx1 = getelementptr inbounds [2 x i8], [2 x i8]* %sign, i32 0, i32 1
  store i8 0, i8* %arrayidx1, align 1
  %arraydecay = getelementptr inbounds [30 x i8], [30 x i8]* %principal, i32 0, i32 0
  %value = getelementptr inbounds %struct.imprecise, %struct.imprecise* %val, i32 0, i32 0
  %0 = load double, double* %value, align 8
  %call = call i32 (i8*, i8*, ...) @sprintf(i8* %arraydecay, i8* getelementptr inbounds ([3 x i8], [3 x i8]* @.str, i32 0, i32 0), double %0)
  %arraydecay2 = getelementptr inbounds [30 x i8], [30 x i8]* %error, i32 0, i32 0
  %delta = getelementptr inbounds %struct.imprecise, %struct.imprecise* %val, i32 0, i32 1
  %1 = load double, double* %delta, align 8
  %call3 = call i32 (i8*, i8*, ...) @sprintf(i8* %arraydecay2, i8* getelementptr inbounds ([3 x i8], [3 x i8]* @.str, i32 0, i32 0), double %1)
  %arraydecay4 = getelementptr inbounds [30 x i8], [30 x i8]* %principal, i32 0, i32 0
  %call5 = call i32 @strlen(i8* %arraydecay4) #5
  %add = add i32 %call5, 1
  %arraydecay6 = getelementptr inbounds [30 x i8], [30 x i8]* %error, i32 0, i32 0
  %call7 = call i32 @strlen(i8* %arraydecay6) #5
  %add8 = add i32 %add, %call7
  %add9 = add i32 %add8, 1
  %mul = mul i32 %add9, 1
  %call10 = call noalias i8* @malloc(i32 %mul)
  store i8* %call10, i8** %string, align 4
  %2 = load i8*, i8** %string, align 4
  %arraydecay11 = getelementptr inbounds [30 x i8], [30 x i8]* %principal, i32 0, i32 0
  %call12 = call i8* @strcpy(i8* %2, i8* %arraydecay11)
  %3 = load i8*, i8** %string, align 4
  %arraydecay13 = getelementptr inbounds [2 x i8], [2 x i8]* %sign, i32 0, i32 0
  %call14 = call i8* @strcat(i8* %3, i8* %arraydecay13)
  %4 = load i8*, i8** %string, align 4
  %arraydecay15 = getelementptr inbounds [30 x i8], [30 x i8]* %error, i32 0, i32 0
  %call16 = call i8* @strcat(i8* %4, i8* %arraydecay15)
  %5 = load i8*, i8** %string, align 4
  ret i8* %5
}

declare i32 @sprintf(i8* %0, i8* %1, ...) #2

declare noalias i8* @malloc(i32 %0) #2

; Function Attrs: nounwind readonly
declare i32 @strlen(i8* %0) #3

declare i8* @strcpy(i8* %0, i8* %1) #2

declare i8* @strcat(i8* %0, i8* %1) #2

; Function Attrs: noinline nounwind optnone
define hidden i32 @main() #0 {
entry:
  %retval = alloca i32, align 4
  %x1 = alloca %struct.imprecise, align 8
  %y1 = alloca %struct.imprecise, align 8
  %x2 = alloca %struct.imprecise, align 8
  %y2 = alloca %struct.imprecise, align 8
  %d = alloca %struct.imprecise, align 8
  %tmp = alloca %struct.imprecise, align 8
  %agg.tmp = alloca %struct.imprecise, align 8
  %agg.tmp1 = alloca %struct.imprecise, align 8
  %agg.tmp2 = alloca %struct.imprecise, align 8
  %agg.tmp3 = alloca %struct.imprecise, align 8
  %agg.tmp4 = alloca %struct.imprecise, align 8
  store i32 0, i32* %retval, align 4
  %0 = bitcast %struct.imprecise* %x1 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 8 %0, i8* align 8 bitcast (%struct.imprecise* @__const.main.x1 to i8*), i32 16, i1 false)
  %1 = bitcast %struct.imprecise* %y1 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 8 %1, i8* align 8 bitcast (%struct.imprecise* @__const.main.y1 to i8*), i32 16, i1 false)
  %2 = bitcast %struct.imprecise* %x2 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 8 %2, i8* align 8 bitcast (%struct.imprecise* @__const.main.x2 to i8*), i32 16, i1 false)
  %3 = bitcast %struct.imprecise* %y2 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 8 %3, i8* align 8 bitcast (%struct.imprecise* @__const.main.y2 to i8*), i32 16, i1 false)
  call void @imprecise_add(%struct.imprecise* sret align 8 %agg.tmp2, %struct.imprecise* byval(%struct.imprecise) align 8 %x1, %struct.imprecise* byval(%struct.imprecise) align 8 %x2)
  call void @imprecise_pow(%struct.imprecise* sret align 8 %agg.tmp1, %struct.imprecise* byval(%struct.imprecise) align 8 %agg.tmp2, double 2.000000e+00)
  call void @imprecise_add(%struct.imprecise* sret align 8 %agg.tmp4, %struct.imprecise* byval(%struct.imprecise) align 8 %y1, %struct.imprecise* byval(%struct.imprecise) align 8 %y2)
  call void @imprecise_pow(%struct.imprecise* sret align 8 %agg.tmp3, %struct.imprecise* byval(%struct.imprecise) align 8 %agg.tmp4, double 2.000000e+00)
  call void @imprecise_add(%struct.imprecise* sret align 8 %agg.tmp, %struct.imprecise* byval(%struct.imprecise) align 8 %agg.tmp1, %struct.imprecise* byval(%struct.imprecise) align 8 %agg.tmp3)
  call void @imprecise_pow(%struct.imprecise* sret align 8 %tmp, %struct.imprecise* byval(%struct.imprecise) align 8 %agg.tmp, double 5.000000e-01)
  %4 = bitcast %struct.imprecise* %d to i8*
  %5 = bitcast %struct.imprecise* %tmp to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 8 %4, i8* align 8 %5, i32 16, i1 false)
  %call = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([44 x i8], [44 x i8]* @.str.1, i32 0, i32 0))
  %call5 = call i8* @printImprecise(%struct.imprecise* byval(%struct.imprecise) align 8 %x1)
  %call6 = call i8* @printImprecise(%struct.imprecise* byval(%struct.imprecise) align 8 %y1)
  %call7 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([23 x i8], [23 x i8]* @.str.2, i32 0, i32 0), i8* %call5, i8* %call6)
  %call8 = call i8* @printImprecise(%struct.imprecise* byval(%struct.imprecise) align 8 %x2)
  %call9 = call i8* @printImprecise(%struct.imprecise* byval(%struct.imprecise) align 8 %y2)
  %call10 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([23 x i8], [23 x i8]* @.str.3, i32 0, i32 0), i8* %call8, i8* %call9)
  %call11 = call i8* @printImprecise(%struct.imprecise* byval(%struct.imprecise) align 8 %d)
  %call12 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([11 x i8], [11 x i8]* @.str.4, i32 0, i32 0), i8* %call11)
  ret i32 0
}

; Function Attrs: argmemonly nounwind willreturn
declare void @llvm.memcpy.p0i8.p0i8.i32(i8* noalias nocapture writeonly %0, i8* noalias nocapture readonly %1, i32 %2, i1 immarg %3) #4

declare i32 @printf(i8* %0, ...) #2

attributes #0 = { noinline nounwind optnone "correctly-rounded-divide-sqrt-fp-math"="false" "disable-tail-calls"="false" "frame-pointer"="none" "less-precise-fpmad"="false" "min-legal-vector-width"="0" "no-infs-fp-math"="false" "no-jump-tables"="false" "no-nans-fp-math"="false" "no-signed-zeros-fp-math"="false" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="generic" "unsafe-fp-math"="false" "use-soft-float"="false" }
attributes #1 = { nounwind readnone speculatable willreturn }
attributes #2 = { "correctly-rounded-divide-sqrt-fp-math"="false" "disable-tail-calls"="false" "frame-pointer"="none" "less-precise-fpmad"="false" "no-infs-fp-math"="false" "no-nans-fp-math"="false" "no-signed-zeros-fp-math"="false" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="generic" "unsafe-fp-math"="false" "use-soft-float"="false" }
attributes #3 = { nounwind readonly "correctly-rounded-divide-sqrt-fp-math"="false" "disable-tail-calls"="false" "frame-pointer"="none" "less-precise-fpmad"="false" "no-infs-fp-math"="false" "no-nans-fp-math"="false" "no-signed-zeros-fp-math"="false" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="generic" "unsafe-fp-math"="false" "use-soft-float"="false" }
attributes #4 = { argmemonly nounwind willreturn }
attributes #5 = { nounwind readonly }

!llvm.module.flags = !{!0}
!llvm.ident = !{!1}

!0 = !{i32 1, !"wchar_size", i32 4}
!1 = !{!"clang version 11.0.0 (https://github.com/Jacarte/llvm-project.git 0f6dea67136cc1e0b3d200eb2bb165628970c44b)"}

; extracted candidates
#########################################################
; exiting Souper's runOnFunction() for imprecise_mul()

; entering Souper's runOnFunction() for imprecise_div()

; ModuleID = './Numeric_error_propagation.c.bc'
source_filename = "./Numeric_error_propagation.c"
target datalayout = "e-m:e-p:32:32-i64:64-n32:64-S128"
target triple = "wasm32-unknown-wasi"

%struct.imprecise = type { double, double }

@.str = private unnamed_addr constant [3 x i8] c"%f\00", align 1
@__const.main.x1 = private unnamed_addr constant %struct.imprecise { double 1.000000e+02, double 1.100000e+00 }, align 8
@__const.main.y1 = private unnamed_addr constant %struct.imprecise { double 5.000000e+01, double 1.200000e+00 }, align 8
@__const.main.x2 = private unnamed_addr constant %struct.imprecise { double -2.000000e+02, double 2.200000e+00 }, align 8
@__const.main.y2 = private unnamed_addr constant %struct.imprecise { double -1.000000e+02, double 2.300000e+00 }, align 8
@.str.1 = private unnamed_addr constant [44 x i8] c"Distance, d, between the following points :\00", align 1
@.str.2 = private unnamed_addr constant [23 x i8] c"\0A( x1, y1) = ( %s, %s)\00", align 1
@.str.3 = private unnamed_addr constant [23 x i8] c"\0A( x2, y2) = ( %s, %s)\00", align 1
@.str.4 = private unnamed_addr constant [11 x i8] c"\0Ais d = %s\00", align 1
@llvm.used = appending global [1 x i8*] [i8* bitcast (i32 ()* @__main_void to i8*)], section "llvm.metadata"

@__main_void = alias i32 (), i32 ()* @main

; Function Attrs: noinline nounwind optnone
define hidden void @imprecise_add(%struct.imprecise* noalias sret align 8 %agg.result, %struct.imprecise* byval(%struct.imprecise) align 8 %a, %struct.imprecise* byval(%struct.imprecise) align 8 %b) #0 {
entry:
  %value = getelementptr inbounds %struct.imprecise, %struct.imprecise* %a, i32 0, i32 0
  %0 = load double, double* %value, align 8
  %value1 = getelementptr inbounds %struct.imprecise, %struct.imprecise* %b, i32 0, i32 0
  %1 = load double, double* %value1, align 8
  %add = fadd double %0, %1
  %value2 = getelementptr inbounds %struct.imprecise, %struct.imprecise* %agg.result, i32 0, i32 0
  store double %add, double* %value2, align 8
  %delta = getelementptr inbounds %struct.imprecise, %struct.imprecise* %a, i32 0, i32 1
  %2 = load double, double* %delta, align 8
  %delta3 = getelementptr inbounds %struct.imprecise, %struct.imprecise* %a, i32 0, i32 1
  %3 = load double, double* %delta3, align 8
  %mul = fmul double %2, %3
  %delta4 = getelementptr inbounds %struct.imprecise, %struct.imprecise* %b, i32 0, i32 1
  %4 = load double, double* %delta4, align 8
  %delta5 = getelementptr inbounds %struct.imprecise, %struct.imprecise* %b, i32 0, i32 1
  %5 = load double, double* %delta5, align 8
  %mul6 = fmul double %4, %5
  %add7 = fadd double %mul, %mul6
  %6 = call double @llvm.sqrt.f64(double %add7)
  %delta8 = getelementptr inbounds %struct.imprecise, %struct.imprecise* %agg.result, i32 0, i32 1
  store double %6, double* %delta8, align 8
  ret void
}

; Function Attrs: nounwind readnone speculatable willreturn
declare double @llvm.sqrt.f64(double %0) #1

; Function Attrs: noinline nounwind optnone
define hidden void @imprecise_mul(%struct.imprecise* noalias sret align 8 %agg.result, %struct.imprecise* byval(%struct.imprecise) align 8 %a, %struct.imprecise* byval(%struct.imprecise) align 8 %b) #0 {
entry:
  %value = getelementptr inbounds %struct.imprecise, %struct.imprecise* %a, i32 0, i32 0
  %0 = load double, double* %value, align 8
  %value1 = getelementptr inbounds %struct.imprecise, %struct.imprecise* %b, i32 0, i32 0
  %1 = load double, double* %value1, align 8
  %mul = fmul double %0, %1
  %value2 = getelementptr inbounds %struct.imprecise, %struct.imprecise* %agg.result, i32 0, i32 0
  store double %mul, double* %value2, align 8
  %value3 = getelementptr inbounds %struct.imprecise, %struct.imprecise* %a, i32 0, i32 0
  %2 = load double, double* %value3, align 8
  %delta = getelementptr inbounds %struct.imprecise, %struct.imprecise* %b, i32 0, i32 1
  %3 = load double, double* %delta, align 8
  %mul4 = fmul double %2, %3
  %value5 = getelementptr inbounds %struct.imprecise, %struct.imprecise* %a, i32 0, i32 0
  %4 = load double, double* %value5, align 8
  %delta6 = getelementptr inbounds %struct.imprecise, %struct.imprecise* %b, i32 0, i32 1
  %5 = load double, double* %delta6, align 8
  %mul7 = fmul double %4, %5
  %mul8 = fmul double %mul4, %mul7
  %value9 = getelementptr inbounds %struct.imprecise, %struct.imprecise* %b, i32 0, i32 0
  %6 = load double, double* %value9, align 8
  %delta10 = getelementptr inbounds %struct.imprecise, %struct.imprecise* %a, i32 0, i32 1
  %7 = load double, double* %delta10, align 8
  %mul11 = fmul double %6, %7
  %value12 = getelementptr inbounds %struct.imprecise, %struct.imprecise* %b, i32 0, i32 0
  %8 = load double, double* %value12, align 8
  %delta13 = getelementptr inbounds %struct.imprecise, %struct.imprecise* %a, i32 0, i32 1
  %9 = load double, double* %delta13, align 8
  %mul14 = fmul double %8, %9
  %mul15 = fmul double %mul11, %mul14
  %add = fadd double %mul8, %mul15
  %10 = call double @llvm.sqrt.f64(double %add)
  %delta16 = getelementptr inbounds %struct.imprecise, %struct.imprecise* %agg.result, i32 0, i32 1
  store double %10, double* %delta16, align 8
  ret void
}

; Function Attrs: noinline nounwind optnone
define hidden void @imprecise_div(%struct.imprecise* noalias sret align 8 %agg.result, %struct.imprecise* byval(%struct.imprecise) align 8 %a, %struct.imprecise* byval(%struct.imprecise) align 8 %b) #0 {
entry:
  %value = getelementptr inbounds %struct.imprecise, %struct.imprecise* %a, i32 0, i32 0
  %0 = load double, double* %value, align 8
  %value1 = getelementptr inbounds %struct.imprecise, %struct.imprecise* %b, i32 0, i32 0
  %1 = load double, double* %value1, align 8
  %div = fdiv double %0, %1
  %value2 = getelementptr inbounds %struct.imprecise, %struct.imprecise* %agg.result, i32 0, i32 0
  store double %div, double* %value2, align 8
  %value3 = getelementptr inbounds %struct.imprecise, %struct.imprecise* %a, i32 0, i32 0
  %2 = load double, double* %value3, align 8
  %delta = getelementptr inbounds %struct.imprecise, %struct.imprecise* %b, i32 0, i32 1
  %3 = load double, double* %delta, align 8
  %mul = fmul double %2, %3
  %value4 = getelementptr inbounds %struct.imprecise, %struct.imprecise* %a, i32 0, i32 0
  %4 = load double, double* %value4, align 8
  %delta5 = getelementptr inbounds %struct.imprecise, %struct.imprecise* %b, i32 0, i32 1
  %5 = load double, double* %delta5, align 8
  %mul6 = fmul double %4, %5
  %mul7 = fmul double %mul, %mul6
  %value8 = getelementptr inbounds %struct.imprecise, %struct.imprecise* %b, i32 0, i32 0
  %6 = load double, double* %value8, align 8
  %delta9 = getelementptr inbounds %struct.imprecise, %struct.imprecise* %a, i32 0, i32 1
  %7 = load double, double* %delta9, align 8
  %mul10 = fmul double %6, %7
  %value11 = getelementptr inbounds %struct.imprecise, %struct.imprecise* %b, i32 0, i32 0
  %8 = load double, double* %value11, align 8
  %delta12 = getelementptr inbounds %struct.imprecise, %struct.imprecise* %a, i32 0, i32 1
  %9 = load double, double* %delta12, align 8
  %mul13 = fmul double %8, %9
  %mul14 = fmul double %mul10, %mul13
  %add = fadd double %mul7, %mul14
  %10 = call double @llvm.sqrt.f64(double %add)
  %value15 = getelementptr inbounds %struct.imprecise, %struct.imprecise* %b, i32 0, i32 0
  %11 = load double, double* %value15, align 8
  %value16 = getelementptr inbounds %struct.imprecise, %struct.imprecise* %b, i32 0, i32 0
  %12 = load double, double* %value16, align 8
  %mul17 = fmul double %11, %12
  %div18 = fdiv double %10, %mul17
  %delta19 = getelementptr inbounds %struct.imprecise, %struct.imprecise* %agg.result, i32 0, i32 1
  store double %div18, double* %delta19, align 8
  ret void
}

; Function Attrs: noinline nounwind optnone
define hidden void @imprecise_pow(%struct.imprecise* noalias sret align 8 %agg.result, %struct.imprecise* byval(%struct.imprecise) align 8 %a, double %c) #0 {
entry:
  %c.addr = alloca double, align 8
  store double %c, double* %c.addr, align 8
  %value = getelementptr inbounds %struct.imprecise, %struct.imprecise* %a, i32 0, i32 0
  %0 = load double, double* %value, align 8
  %1 = load double, double* %c.addr, align 8
  %2 = call double @llvm.pow.f64(double %0, double %1)
  %value1 = getelementptr inbounds %struct.imprecise, %struct.imprecise* %agg.result, i32 0, i32 0
  store double %2, double* %value1, align 8
  %value2 = getelementptr inbounds %struct.imprecise, %struct.imprecise* %agg.result, i32 0, i32 0
  %3 = load double, double* %value2, align 8
  %4 = load double, double* %c.addr, align 8
  %mul = fmul double %3, %4
  %delta = getelementptr inbounds %struct.imprecise, %struct.imprecise* %a, i32 0, i32 1
  %5 = load double, double* %delta, align 8
  %mul3 = fmul double %mul, %5
  %value4 = getelementptr inbounds %struct.imprecise, %struct.imprecise* %a, i32 0, i32 0
  %6 = load double, double* %value4, align 8
  %div = fdiv double %mul3, %6
  %7 = call double @llvm.fabs.f64(double %div)
  %delta5 = getelementptr inbounds %struct.imprecise, %struct.imprecise* %agg.result, i32 0, i32 1
  store double %7, double* %delta5, align 8
  ret void
}

; Function Attrs: nounwind readnone speculatable willreturn
declare double @llvm.pow.f64(double %0, double %1) #1

; Function Attrs: nounwind readnone speculatable willreturn
declare double @llvm.fabs.f64(double %0) #1

; Function Attrs: noinline nounwind optnone
define hidden i8* @printImprecise(%struct.imprecise* byval(%struct.imprecise) align 8 %val) #0 {
entry:
  %principal = alloca [30 x i8], align 16
  %error = alloca [30 x i8], align 16
  %string = alloca i8*, align 4
  %sign = alloca [2 x i8], align 1
  %arrayidx = getelementptr inbounds [2 x i8], [2 x i8]* %sign, i32 0, i32 0
  store i8 -15, i8* %arrayidx, align 1
  %arrayidx1 = getelementptr inbounds [2 x i8], [2 x i8]* %sign, i32 0, i32 1
  store i8 0, i8* %arrayidx1, align 1
  %arraydecay = getelementptr inbounds [30 x i8], [30 x i8]* %principal, i32 0, i32 0
  %value = getelementptr inbounds %struct.imprecise, %struct.imprecise* %val, i32 0, i32 0
  %0 = load double, double* %value, align 8
  %call = call i32 (i8*, i8*, ...) @sprintf(i8* %arraydecay, i8* getelementptr inbounds ([3 x i8], [3 x i8]* @.str, i32 0, i32 0), double %0)
  %arraydecay2 = getelementptr inbounds [30 x i8], [30 x i8]* %error, i32 0, i32 0
  %delta = getelementptr inbounds %struct.imprecise, %struct.imprecise* %val, i32 0, i32 1
  %1 = load double, double* %delta, align 8
  %call3 = call i32 (i8*, i8*, ...) @sprintf(i8* %arraydecay2, i8* getelementptr inbounds ([3 x i8], [3 x i8]* @.str, i32 0, i32 0), double %1)
  %arraydecay4 = getelementptr inbounds [30 x i8], [30 x i8]* %principal, i32 0, i32 0
  %call5 = call i32 @strlen(i8* %arraydecay4) #5
  %add = add i32 %call5, 1
  %arraydecay6 = getelementptr inbounds [30 x i8], [30 x i8]* %error, i32 0, i32 0
  %call7 = call i32 @strlen(i8* %arraydecay6) #5
  %add8 = add i32 %add, %call7
  %add9 = add i32 %add8, 1
  %mul = mul i32 %add9, 1
  %call10 = call noalias i8* @malloc(i32 %mul)
  store i8* %call10, i8** %string, align 4
  %2 = load i8*, i8** %string, align 4
  %arraydecay11 = getelementptr inbounds [30 x i8], [30 x i8]* %principal, i32 0, i32 0
  %call12 = call i8* @strcpy(i8* %2, i8* %arraydecay11)
  %3 = load i8*, i8** %string, align 4
  %arraydecay13 = getelementptr inbounds [2 x i8], [2 x i8]* %sign, i32 0, i32 0
  %call14 = call i8* @strcat(i8* %3, i8* %arraydecay13)
  %4 = load i8*, i8** %string, align 4
  %arraydecay15 = getelementptr inbounds [30 x i8], [30 x i8]* %error, i32 0, i32 0
  %call16 = call i8* @strcat(i8* %4, i8* %arraydecay15)
  %5 = load i8*, i8** %string, align 4
  ret i8* %5
}

declare i32 @sprintf(i8* %0, i8* %1, ...) #2

declare noalias i8* @malloc(i32 %0) #2

; Function Attrs: nounwind readonly
declare i32 @strlen(i8* %0) #3

declare i8* @strcpy(i8* %0, i8* %1) #2

declare i8* @strcat(i8* %0, i8* %1) #2

; Function Attrs: noinline nounwind optnone
define hidden i32 @main() #0 {
entry:
  %retval = alloca i32, align 4
  %x1 = alloca %struct.imprecise, align 8
  %y1 = alloca %struct.imprecise, align 8
  %x2 = alloca %struct.imprecise, align 8
  %y2 = alloca %struct.imprecise, align 8
  %d = alloca %struct.imprecise, align 8
  %tmp = alloca %struct.imprecise, align 8
  %agg.tmp = alloca %struct.imprecise, align 8
  %agg.tmp1 = alloca %struct.imprecise, align 8
  %agg.tmp2 = alloca %struct.imprecise, align 8
  %agg.tmp3 = alloca %struct.imprecise, align 8
  %agg.tmp4 = alloca %struct.imprecise, align 8
  store i32 0, i32* %retval, align 4
  %0 = bitcast %struct.imprecise* %x1 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 8 %0, i8* align 8 bitcast (%struct.imprecise* @__const.main.x1 to i8*), i32 16, i1 false)
  %1 = bitcast %struct.imprecise* %y1 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 8 %1, i8* align 8 bitcast (%struct.imprecise* @__const.main.y1 to i8*), i32 16, i1 false)
  %2 = bitcast %struct.imprecise* %x2 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 8 %2, i8* align 8 bitcast (%struct.imprecise* @__const.main.x2 to i8*), i32 16, i1 false)
  %3 = bitcast %struct.imprecise* %y2 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 8 %3, i8* align 8 bitcast (%struct.imprecise* @__const.main.y2 to i8*), i32 16, i1 false)
  call void @imprecise_add(%struct.imprecise* sret align 8 %agg.tmp2, %struct.imprecise* byval(%struct.imprecise) align 8 %x1, %struct.imprecise* byval(%struct.imprecise) align 8 %x2)
  call void @imprecise_pow(%struct.imprecise* sret align 8 %agg.tmp1, %struct.imprecise* byval(%struct.imprecise) align 8 %agg.tmp2, double 2.000000e+00)
  call void @imprecise_add(%struct.imprecise* sret align 8 %agg.tmp4, %struct.imprecise* byval(%struct.imprecise) align 8 %y1, %struct.imprecise* byval(%struct.imprecise) align 8 %y2)
  call void @imprecise_pow(%struct.imprecise* sret align 8 %agg.tmp3, %struct.imprecise* byval(%struct.imprecise) align 8 %agg.tmp4, double 2.000000e+00)
  call void @imprecise_add(%struct.imprecise* sret align 8 %agg.tmp, %struct.imprecise* byval(%struct.imprecise) align 8 %agg.tmp1, %struct.imprecise* byval(%struct.imprecise) align 8 %agg.tmp3)
  call void @imprecise_pow(%struct.imprecise* sret align 8 %tmp, %struct.imprecise* byval(%struct.imprecise) align 8 %agg.tmp, double 5.000000e-01)
  %4 = bitcast %struct.imprecise* %d to i8*
  %5 = bitcast %struct.imprecise* %tmp to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 8 %4, i8* align 8 %5, i32 16, i1 false)
  %call = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([44 x i8], [44 x i8]* @.str.1, i32 0, i32 0))
  %call5 = call i8* @printImprecise(%struct.imprecise* byval(%struct.imprecise) align 8 %x1)
  %call6 = call i8* @printImprecise(%struct.imprecise* byval(%struct.imprecise) align 8 %y1)
  %call7 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([23 x i8], [23 x i8]* @.str.2, i32 0, i32 0), i8* %call5, i8* %call6)
  %call8 = call i8* @printImprecise(%struct.imprecise* byval(%struct.imprecise) align 8 %x2)
  %call9 = call i8* @printImprecise(%struct.imprecise* byval(%struct.imprecise) align 8 %y2)
  %call10 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([23 x i8], [23 x i8]* @.str.3, i32 0, i32 0), i8* %call8, i8* %call9)
  %call11 = call i8* @printImprecise(%struct.imprecise* byval(%struct.imprecise) align 8 %d)
  %call12 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([11 x i8], [11 x i8]* @.str.4, i32 0, i32 0), i8* %call11)
  ret i32 0
}

; Function Attrs: argmemonly nounwind willreturn
declare void @llvm.memcpy.p0i8.p0i8.i32(i8* noalias nocapture writeonly %0, i8* noalias nocapture readonly %1, i32 %2, i1 immarg %3) #4

declare i32 @printf(i8* %0, ...) #2

attributes #0 = { noinline nounwind optnone "correctly-rounded-divide-sqrt-fp-math"="false" "disable-tail-calls"="false" "frame-pointer"="none" "less-precise-fpmad"="false" "min-legal-vector-width"="0" "no-infs-fp-math"="false" "no-jump-tables"="false" "no-nans-fp-math"="false" "no-signed-zeros-fp-math"="false" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="generic" "unsafe-fp-math"="false" "use-soft-float"="false" }
attributes #1 = { nounwind readnone speculatable willreturn }
attributes #2 = { "correctly-rounded-divide-sqrt-fp-math"="false" "disable-tail-calls"="false" "frame-pointer"="none" "less-precise-fpmad"="false" "no-infs-fp-math"="false" "no-nans-fp-math"="false" "no-signed-zeros-fp-math"="false" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="generic" "unsafe-fp-math"="false" "use-soft-float"="false" }
attributes #3 = { nounwind readonly "correctly-rounded-divide-sqrt-fp-math"="false" "disable-tail-calls"="false" "frame-pointer"="none" "less-precise-fpmad"="false" "no-infs-fp-math"="false" "no-nans-fp-math"="false" "no-signed-zeros-fp-math"="false" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="generic" "unsafe-fp-math"="false" "use-soft-float"="false" }
attributes #4 = { argmemonly nounwind willreturn }
attributes #5 = { nounwind readonly }

!llvm.module.flags = !{!0}
!llvm.ident = !{!1}

!0 = !{i32 1, !"wchar_size", i32 4}
!1 = !{!"clang version 11.0.0 (https://github.com/Jacarte/llvm-project.git 0f6dea67136cc1e0b3d200eb2bb165628970c44b)"}

; extracted candidates
#########################################################
; exiting Souper's runOnFunction() for imprecise_div()

; entering Souper's runOnFunction() for imprecise_pow()

; ModuleID = './Numeric_error_propagation.c.bc'
source_filename = "./Numeric_error_propagation.c"
target datalayout = "e-m:e-p:32:32-i64:64-n32:64-S128"
target triple = "wasm32-unknown-wasi"

%struct.imprecise = type { double, double }

@.str = private unnamed_addr constant [3 x i8] c"%f\00", align 1
@__const.main.x1 = private unnamed_addr constant %struct.imprecise { double 1.000000e+02, double 1.100000e+00 }, align 8
@__const.main.y1 = private unnamed_addr constant %struct.imprecise { double 5.000000e+01, double 1.200000e+00 }, align 8
@__const.main.x2 = private unnamed_addr constant %struct.imprecise { double -2.000000e+02, double 2.200000e+00 }, align 8
@__const.main.y2 = private unnamed_addr constant %struct.imprecise { double -1.000000e+02, double 2.300000e+00 }, align 8
@.str.1 = private unnamed_addr constant [44 x i8] c"Distance, d, between the following points :\00", align 1
@.str.2 = private unnamed_addr constant [23 x i8] c"\0A( x1, y1) = ( %s, %s)\00", align 1
@.str.3 = private unnamed_addr constant [23 x i8] c"\0A( x2, y2) = ( %s, %s)\00", align 1
@.str.4 = private unnamed_addr constant [11 x i8] c"\0Ais d = %s\00", align 1
@llvm.used = appending global [1 x i8*] [i8* bitcast (i32 ()* @__main_void to i8*)], section "llvm.metadata"

@__main_void = alias i32 (), i32 ()* @main

; Function Attrs: noinline nounwind optnone
define hidden void @imprecise_add(%struct.imprecise* noalias sret align 8 %agg.result, %struct.imprecise* byval(%struct.imprecise) align 8 %a, %struct.imprecise* byval(%struct.imprecise) align 8 %b) #0 {
entry:
  %value = getelementptr inbounds %struct.imprecise, %struct.imprecise* %a, i32 0, i32 0
  %0 = load double, double* %value, align 8
  %value1 = getelementptr inbounds %struct.imprecise, %struct.imprecise* %b, i32 0, i32 0
  %1 = load double, double* %value1, align 8
  %add = fadd double %0, %1
  %value2 = getelementptr inbounds %struct.imprecise, %struct.imprecise* %agg.result, i32 0, i32 0
  store double %add, double* %value2, align 8
  %delta = getelementptr inbounds %struct.imprecise, %struct.imprecise* %a, i32 0, i32 1
  %2 = load double, double* %delta, align 8
  %delta3 = getelementptr inbounds %struct.imprecise, %struct.imprecise* %a, i32 0, i32 1
  %3 = load double, double* %delta3, align 8
  %mul = fmul double %2, %3
  %delta4 = getelementptr inbounds %struct.imprecise, %struct.imprecise* %b, i32 0, i32 1
  %4 = load double, double* %delta4, align 8
  %delta5 = getelementptr inbounds %struct.imprecise, %struct.imprecise* %b, i32 0, i32 1
  %5 = load double, double* %delta5, align 8
  %mul6 = fmul double %4, %5
  %add7 = fadd double %mul, %mul6
  %6 = call double @llvm.sqrt.f64(double %add7)
  %delta8 = getelementptr inbounds %struct.imprecise, %struct.imprecise* %agg.result, i32 0, i32 1
  store double %6, double* %delta8, align 8
  ret void
}

; Function Attrs: nounwind readnone speculatable willreturn
declare double @llvm.sqrt.f64(double %0) #1

; Function Attrs: noinline nounwind optnone
define hidden void @imprecise_mul(%struct.imprecise* noalias sret align 8 %agg.result, %struct.imprecise* byval(%struct.imprecise) align 8 %a, %struct.imprecise* byval(%struct.imprecise) align 8 %b) #0 {
entry:
  %value = getelementptr inbounds %struct.imprecise, %struct.imprecise* %a, i32 0, i32 0
  %0 = load double, double* %value, align 8
  %value1 = getelementptr inbounds %struct.imprecise, %struct.imprecise* %b, i32 0, i32 0
  %1 = load double, double* %value1, align 8
  %mul = fmul double %0, %1
  %value2 = getelementptr inbounds %struct.imprecise, %struct.imprecise* %agg.result, i32 0, i32 0
  store double %mul, double* %value2, align 8
  %value3 = getelementptr inbounds %struct.imprecise, %struct.imprecise* %a, i32 0, i32 0
  %2 = load double, double* %value3, align 8
  %delta = getelementptr inbounds %struct.imprecise, %struct.imprecise* %b, i32 0, i32 1
  %3 = load double, double* %delta, align 8
  %mul4 = fmul double %2, %3
  %value5 = getelementptr inbounds %struct.imprecise, %struct.imprecise* %a, i32 0, i32 0
  %4 = load double, double* %value5, align 8
  %delta6 = getelementptr inbounds %struct.imprecise, %struct.imprecise* %b, i32 0, i32 1
  %5 = load double, double* %delta6, align 8
  %mul7 = fmul double %4, %5
  %mul8 = fmul double %mul4, %mul7
  %value9 = getelementptr inbounds %struct.imprecise, %struct.imprecise* %b, i32 0, i32 0
  %6 = load double, double* %value9, align 8
  %delta10 = getelementptr inbounds %struct.imprecise, %struct.imprecise* %a, i32 0, i32 1
  %7 = load double, double* %delta10, align 8
  %mul11 = fmul double %6, %7
  %value12 = getelementptr inbounds %struct.imprecise, %struct.imprecise* %b, i32 0, i32 0
  %8 = load double, double* %value12, align 8
  %delta13 = getelementptr inbounds %struct.imprecise, %struct.imprecise* %a, i32 0, i32 1
  %9 = load double, double* %delta13, align 8
  %mul14 = fmul double %8, %9
  %mul15 = fmul double %mul11, %mul14
  %add = fadd double %mul8, %mul15
  %10 = call double @llvm.sqrt.f64(double %add)
  %delta16 = getelementptr inbounds %struct.imprecise, %struct.imprecise* %agg.result, i32 0, i32 1
  store double %10, double* %delta16, align 8
  ret void
}

; Function Attrs: noinline nounwind optnone
define hidden void @imprecise_div(%struct.imprecise* noalias sret align 8 %agg.result, %struct.imprecise* byval(%struct.imprecise) align 8 %a, %struct.imprecise* byval(%struct.imprecise) align 8 %b) #0 {
entry:
  %value = getelementptr inbounds %struct.imprecise, %struct.imprecise* %a, i32 0, i32 0
  %0 = load double, double* %value, align 8
  %value1 = getelementptr inbounds %struct.imprecise, %struct.imprecise* %b, i32 0, i32 0
  %1 = load double, double* %value1, align 8
  %div = fdiv double %0, %1
  %value2 = getelementptr inbounds %struct.imprecise, %struct.imprecise* %agg.result, i32 0, i32 0
  store double %div, double* %value2, align 8
  %value3 = getelementptr inbounds %struct.imprecise, %struct.imprecise* %a, i32 0, i32 0
  %2 = load double, double* %value3, align 8
  %delta = getelementptr inbounds %struct.imprecise, %struct.imprecise* %b, i32 0, i32 1
  %3 = load double, double* %delta, align 8
  %mul = fmul double %2, %3
  %value4 = getelementptr inbounds %struct.imprecise, %struct.imprecise* %a, i32 0, i32 0
  %4 = load double, double* %value4, align 8
  %delta5 = getelementptr inbounds %struct.imprecise, %struct.imprecise* %b, i32 0, i32 1
  %5 = load double, double* %delta5, align 8
  %mul6 = fmul double %4, %5
  %mul7 = fmul double %mul, %mul6
  %value8 = getelementptr inbounds %struct.imprecise, %struct.imprecise* %b, i32 0, i32 0
  %6 = load double, double* %value8, align 8
  %delta9 = getelementptr inbounds %struct.imprecise, %struct.imprecise* %a, i32 0, i32 1
  %7 = load double, double* %delta9, align 8
  %mul10 = fmul double %6, %7
  %value11 = getelementptr inbounds %struct.imprecise, %struct.imprecise* %b, i32 0, i32 0
  %8 = load double, double* %value11, align 8
  %delta12 = getelementptr inbounds %struct.imprecise, %struct.imprecise* %a, i32 0, i32 1
  %9 = load double, double* %delta12, align 8
  %mul13 = fmul double %8, %9
  %mul14 = fmul double %mul10, %mul13
  %add = fadd double %mul7, %mul14
  %10 = call double @llvm.sqrt.f64(double %add)
  %value15 = getelementptr inbounds %struct.imprecise, %struct.imprecise* %b, i32 0, i32 0
  %11 = load double, double* %value15, align 8
  %value16 = getelementptr inbounds %struct.imprecise, %struct.imprecise* %b, i32 0, i32 0
  %12 = load double, double* %value16, align 8
  %mul17 = fmul double %11, %12
  %div18 = fdiv double %10, %mul17
  %delta19 = getelementptr inbounds %struct.imprecise, %struct.imprecise* %agg.result, i32 0, i32 1
  store double %div18, double* %delta19, align 8
  ret void
}

; Function Attrs: noinline nounwind optnone
define hidden void @imprecise_pow(%struct.imprecise* noalias sret align 8 %agg.result, %struct.imprecise* byval(%struct.imprecise) align 8 %a, double %c) #0 {
entry:
  %c.addr = alloca double, align 8
  store double %c, double* %c.addr, align 8
  %value = getelementptr inbounds %struct.imprecise, %struct.imprecise* %a, i32 0, i32 0
  %0 = load double, double* %value, align 8
  %1 = load double, double* %c.addr, align 8
  %2 = call double @llvm.pow.f64(double %0, double %1)
  %value1 = getelementptr inbounds %struct.imprecise, %struct.imprecise* %agg.result, i32 0, i32 0
  store double %2, double* %value1, align 8
  %value2 = getelementptr inbounds %struct.imprecise, %struct.imprecise* %agg.result, i32 0, i32 0
  %3 = load double, double* %value2, align 8
  %4 = load double, double* %c.addr, align 8
  %mul = fmul double %3, %4
  %delta = getelementptr inbounds %struct.imprecise, %struct.imprecise* %a, i32 0, i32 1
  %5 = load double, double* %delta, align 8
  %mul3 = fmul double %mul, %5
  %value4 = getelementptr inbounds %struct.imprecise, %struct.imprecise* %a, i32 0, i32 0
  %6 = load double, double* %value4, align 8
  %div = fdiv double %mul3, %6
  %7 = call double @llvm.fabs.f64(double %div)
  %delta5 = getelementptr inbounds %struct.imprecise, %struct.imprecise* %agg.result, i32 0, i32 1
  store double %7, double* %delta5, align 8
  ret void
}

; Function Attrs: nounwind readnone speculatable willreturn
declare double @llvm.pow.f64(double %0, double %1) #1

; Function Attrs: nounwind readnone speculatable willreturn
declare double @llvm.fabs.f64(double %0) #1

; Function Attrs: noinline nounwind optnone
define hidden i8* @printImprecise(%struct.imprecise* byval(%struct.imprecise) align 8 %val) #0 {
entry:
  %principal = alloca [30 x i8], align 16
  %error = alloca [30 x i8], align 16
  %string = alloca i8*, align 4
  %sign = alloca [2 x i8], align 1
  %arrayidx = getelementptr inbounds [2 x i8], [2 x i8]* %sign, i32 0, i32 0
  store i8 -15, i8* %arrayidx, align 1
  %arrayidx1 = getelementptr inbounds [2 x i8], [2 x i8]* %sign, i32 0, i32 1
  store i8 0, i8* %arrayidx1, align 1
  %arraydecay = getelementptr inbounds [30 x i8], [30 x i8]* %principal, i32 0, i32 0
  %value = getelementptr inbounds %struct.imprecise, %struct.imprecise* %val, i32 0, i32 0
  %0 = load double, double* %value, align 8
  %call = call i32 (i8*, i8*, ...) @sprintf(i8* %arraydecay, i8* getelementptr inbounds ([3 x i8], [3 x i8]* @.str, i32 0, i32 0), double %0)
  %arraydecay2 = getelementptr inbounds [30 x i8], [30 x i8]* %error, i32 0, i32 0
  %delta = getelementptr inbounds %struct.imprecise, %struct.imprecise* %val, i32 0, i32 1
  %1 = load double, double* %delta, align 8
  %call3 = call i32 (i8*, i8*, ...) @sprintf(i8* %arraydecay2, i8* getelementptr inbounds ([3 x i8], [3 x i8]* @.str, i32 0, i32 0), double %1)
  %arraydecay4 = getelementptr inbounds [30 x i8], [30 x i8]* %principal, i32 0, i32 0
  %call5 = call i32 @strlen(i8* %arraydecay4) #5
  %add = add i32 %call5, 1
  %arraydecay6 = getelementptr inbounds [30 x i8], [30 x i8]* %error, i32 0, i32 0
  %call7 = call i32 @strlen(i8* %arraydecay6) #5
  %add8 = add i32 %add, %call7
  %add9 = add i32 %add8, 1
  %mul = mul i32 %add9, 1
  %call10 = call noalias i8* @malloc(i32 %mul)
  store i8* %call10, i8** %string, align 4
  %2 = load i8*, i8** %string, align 4
  %arraydecay11 = getelementptr inbounds [30 x i8], [30 x i8]* %principal, i32 0, i32 0
  %call12 = call i8* @strcpy(i8* %2, i8* %arraydecay11)
  %3 = load i8*, i8** %string, align 4
  %arraydecay13 = getelementptr inbounds [2 x i8], [2 x i8]* %sign, i32 0, i32 0
  %call14 = call i8* @strcat(i8* %3, i8* %arraydecay13)
  %4 = load i8*, i8** %string, align 4
  %arraydecay15 = getelementptr inbounds [30 x i8], [30 x i8]* %error, i32 0, i32 0
  %call16 = call i8* @strcat(i8* %4, i8* %arraydecay15)
  %5 = load i8*, i8** %string, align 4
  ret i8* %5
}

declare i32 @sprintf(i8* %0, i8* %1, ...) #2

declare noalias i8* @malloc(i32 %0) #2

; Function Attrs: nounwind readonly
declare i32 @strlen(i8* %0) #3

declare i8* @strcpy(i8* %0, i8* %1) #2

declare i8* @strcat(i8* %0, i8* %1) #2

; Function Attrs: noinline nounwind optnone
define hidden i32 @main() #0 {
entry:
  %retval = alloca i32, align 4
  %x1 = alloca %struct.imprecise, align 8
  %y1 = alloca %struct.imprecise, align 8
  %x2 = alloca %struct.imprecise, align 8
  %y2 = alloca %struct.imprecise, align 8
  %d = alloca %struct.imprecise, align 8
  %tmp = alloca %struct.imprecise, align 8
  %agg.tmp = alloca %struct.imprecise, align 8
  %agg.tmp1 = alloca %struct.imprecise, align 8
  %agg.tmp2 = alloca %struct.imprecise, align 8
  %agg.tmp3 = alloca %struct.imprecise, align 8
  %agg.tmp4 = alloca %struct.imprecise, align 8
  store i32 0, i32* %retval, align 4
  %0 = bitcast %struct.imprecise* %x1 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 8 %0, i8* align 8 bitcast (%struct.imprecise* @__const.main.x1 to i8*), i32 16, i1 false)
  %1 = bitcast %struct.imprecise* %y1 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 8 %1, i8* align 8 bitcast (%struct.imprecise* @__const.main.y1 to i8*), i32 16, i1 false)
  %2 = bitcast %struct.imprecise* %x2 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 8 %2, i8* align 8 bitcast (%struct.imprecise* @__const.main.x2 to i8*), i32 16, i1 false)
  %3 = bitcast %struct.imprecise* %y2 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 8 %3, i8* align 8 bitcast (%struct.imprecise* @__const.main.y2 to i8*), i32 16, i1 false)
  call void @imprecise_add(%struct.imprecise* sret align 8 %agg.tmp2, %struct.imprecise* byval(%struct.imprecise) align 8 %x1, %struct.imprecise* byval(%struct.imprecise) align 8 %x2)
  call void @imprecise_pow(%struct.imprecise* sret align 8 %agg.tmp1, %struct.imprecise* byval(%struct.imprecise) align 8 %agg.tmp2, double 2.000000e+00)
  call void @imprecise_add(%struct.imprecise* sret align 8 %agg.tmp4, %struct.imprecise* byval(%struct.imprecise) align 8 %y1, %struct.imprecise* byval(%struct.imprecise) align 8 %y2)
  call void @imprecise_pow(%struct.imprecise* sret align 8 %agg.tmp3, %struct.imprecise* byval(%struct.imprecise) align 8 %agg.tmp4, double 2.000000e+00)
  call void @imprecise_add(%struct.imprecise* sret align 8 %agg.tmp, %struct.imprecise* byval(%struct.imprecise) align 8 %agg.tmp1, %struct.imprecise* byval(%struct.imprecise) align 8 %agg.tmp3)
  call void @imprecise_pow(%struct.imprecise* sret align 8 %tmp, %struct.imprecise* byval(%struct.imprecise) align 8 %agg.tmp, double 5.000000e-01)
  %4 = bitcast %struct.imprecise* %d to i8*
  %5 = bitcast %struct.imprecise* %tmp to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 8 %4, i8* align 8 %5, i32 16, i1 false)
  %call = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([44 x i8], [44 x i8]* @.str.1, i32 0, i32 0))
  %call5 = call i8* @printImprecise(%struct.imprecise* byval(%struct.imprecise) align 8 %x1)
  %call6 = call i8* @printImprecise(%struct.imprecise* byval(%struct.imprecise) align 8 %y1)
  %call7 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([23 x i8], [23 x i8]* @.str.2, i32 0, i32 0), i8* %call5, i8* %call6)
  %call8 = call i8* @printImprecise(%struct.imprecise* byval(%struct.imprecise) align 8 %x2)
  %call9 = call i8* @printImprecise(%struct.imprecise* byval(%struct.imprecise) align 8 %y2)
  %call10 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([23 x i8], [23 x i8]* @.str.3, i32 0, i32 0), i8* %call8, i8* %call9)
  %call11 = call i8* @printImprecise(%struct.imprecise* byval(%struct.imprecise) align 8 %d)
  %call12 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([11 x i8], [11 x i8]* @.str.4, i32 0, i32 0), i8* %call11)
  ret i32 0
}

; Function Attrs: argmemonly nounwind willreturn
declare void @llvm.memcpy.p0i8.p0i8.i32(i8* noalias nocapture writeonly %0, i8* noalias nocapture readonly %1, i32 %2, i1 immarg %3) #4

declare i32 @printf(i8* %0, ...) #2

attributes #0 = { noinline nounwind optnone "correctly-rounded-divide-sqrt-fp-math"="false" "disable-tail-calls"="false" "frame-pointer"="none" "less-precise-fpmad"="false" "min-legal-vector-width"="0" "no-infs-fp-math"="false" "no-jump-tables"="false" "no-nans-fp-math"="false" "no-signed-zeros-fp-math"="false" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="generic" "unsafe-fp-math"="false" "use-soft-float"="false" }
attributes #1 = { nounwind readnone speculatable willreturn }
attributes #2 = { "correctly-rounded-divide-sqrt-fp-math"="false" "disable-tail-calls"="false" "frame-pointer"="none" "less-precise-fpmad"="false" "no-infs-fp-math"="false" "no-nans-fp-math"="false" "no-signed-zeros-fp-math"="false" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="generic" "unsafe-fp-math"="false" "use-soft-float"="false" }
attributes #3 = { nounwind readonly "correctly-rounded-divide-sqrt-fp-math"="false" "disable-tail-calls"="false" "frame-pointer"="none" "less-precise-fpmad"="false" "no-infs-fp-math"="false" "no-nans-fp-math"="false" "no-signed-zeros-fp-math"="false" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="generic" "unsafe-fp-math"="false" "use-soft-float"="false" }
attributes #4 = { argmemonly nounwind willreturn }
attributes #5 = { nounwind readonly }

!llvm.module.flags = !{!0}
!llvm.ident = !{!1}

!0 = !{i32 1, !"wchar_size", i32 4}
!1 = !{!"clang version 11.0.0 (https://github.com/Jacarte/llvm-project.git 0f6dea67136cc1e0b3d200eb2bb165628970c44b)"}

; extracted candidates
#########################################################
; exiting Souper's runOnFunction() for imprecise_pow()

; entering Souper's runOnFunction() for printImprecise()

; ModuleID = './Numeric_error_propagation.c.bc'
source_filename = "./Numeric_error_propagation.c"
target datalayout = "e-m:e-p:32:32-i64:64-n32:64-S128"
target triple = "wasm32-unknown-wasi"

%struct.imprecise = type { double, double }

@.str = private unnamed_addr constant [3 x i8] c"%f\00", align 1
@__const.main.x1 = private unnamed_addr constant %struct.imprecise { double 1.000000e+02, double 1.100000e+00 }, align 8
@__const.main.y1 = private unnamed_addr constant %struct.imprecise { double 5.000000e+01, double 1.200000e+00 }, align 8
@__const.main.x2 = private unnamed_addr constant %struct.imprecise { double -2.000000e+02, double 2.200000e+00 }, align 8
@__const.main.y2 = private unnamed_addr constant %struct.imprecise { double -1.000000e+02, double 2.300000e+00 }, align 8
@.str.1 = private unnamed_addr constant [44 x i8] c"Distance, d, between the following points :\00", align 1
@.str.2 = private unnamed_addr constant [23 x i8] c"\0A( x1, y1) = ( %s, %s)\00", align 1
@.str.3 = private unnamed_addr constant [23 x i8] c"\0A( x2, y2) = ( %s, %s)\00", align 1
@.str.4 = private unnamed_addr constant [11 x i8] c"\0Ais d = %s\00", align 1
@llvm.used = appending global [1 x i8*] [i8* bitcast (i32 ()* @__main_void to i8*)], section "llvm.metadata"

@__main_void = alias i32 (), i32 ()* @main

; Function Attrs: noinline nounwind optnone
define hidden void @imprecise_add(%struct.imprecise* noalias sret align 8 %agg.result, %struct.imprecise* byval(%struct.imprecise) align 8 %a, %struct.imprecise* byval(%struct.imprecise) align 8 %b) #0 {
entry:
  %value = getelementptr inbounds %struct.imprecise, %struct.imprecise* %a, i32 0, i32 0
  %0 = load double, double* %value, align 8
  %value1 = getelementptr inbounds %struct.imprecise, %struct.imprecise* %b, i32 0, i32 0
  %1 = load double, double* %value1, align 8
  %add = fadd double %0, %1
  %value2 = getelementptr inbounds %struct.imprecise, %struct.imprecise* %agg.result, i32 0, i32 0
  store double %add, double* %value2, align 8
  %delta = getelementptr inbounds %struct.imprecise, %struct.imprecise* %a, i32 0, i32 1
  %2 = load double, double* %delta, align 8
  %delta3 = getelementptr inbounds %struct.imprecise, %struct.imprecise* %a, i32 0, i32 1
  %3 = load double, double* %delta3, align 8
  %mul = fmul double %2, %3
  %delta4 = getelementptr inbounds %struct.imprecise, %struct.imprecise* %b, i32 0, i32 1
  %4 = load double, double* %delta4, align 8
  %delta5 = getelementptr inbounds %struct.imprecise, %struct.imprecise* %b, i32 0, i32 1
  %5 = load double, double* %delta5, align 8
  %mul6 = fmul double %4, %5
  %add7 = fadd double %mul, %mul6
  %6 = call double @llvm.sqrt.f64(double %add7)
  %delta8 = getelementptr inbounds %struct.imprecise, %struct.imprecise* %agg.result, i32 0, i32 1
  store double %6, double* %delta8, align 8
  ret void
}

; Function Attrs: nounwind readnone speculatable willreturn
declare double @llvm.sqrt.f64(double %0) #1

; Function Attrs: noinline nounwind optnone
define hidden void @imprecise_mul(%struct.imprecise* noalias sret align 8 %agg.result, %struct.imprecise* byval(%struct.imprecise) align 8 %a, %struct.imprecise* byval(%struct.imprecise) align 8 %b) #0 {
entry:
  %value = getelementptr inbounds %struct.imprecise, %struct.imprecise* %a, i32 0, i32 0
  %0 = load double, double* %value, align 8
  %value1 = getelementptr inbounds %struct.imprecise, %struct.imprecise* %b, i32 0, i32 0
  %1 = load double, double* %value1, align 8
  %mul = fmul double %0, %1
  %value2 = getelementptr inbounds %struct.imprecise, %struct.imprecise* %agg.result, i32 0, i32 0
  store double %mul, double* %value2, align 8
  %value3 = getelementptr inbounds %struct.imprecise, %struct.imprecise* %a, i32 0, i32 0
  %2 = load double, double* %value3, align 8
  %delta = getelementptr inbounds %struct.imprecise, %struct.imprecise* %b, i32 0, i32 1
  %3 = load double, double* %delta, align 8
  %mul4 = fmul double %2, %3
  %value5 = getelementptr inbounds %struct.imprecise, %struct.imprecise* %a, i32 0, i32 0
  %4 = load double, double* %value5, align 8
  %delta6 = getelementptr inbounds %struct.imprecise, %struct.imprecise* %b, i32 0, i32 1
  %5 = load double, double* %delta6, align 8
  %mul7 = fmul double %4, %5
  %mul8 = fmul double %mul4, %mul7
  %value9 = getelementptr inbounds %struct.imprecise, %struct.imprecise* %b, i32 0, i32 0
  %6 = load double, double* %value9, align 8
  %delta10 = getelementptr inbounds %struct.imprecise, %struct.imprecise* %a, i32 0, i32 1
  %7 = load double, double* %delta10, align 8
  %mul11 = fmul double %6, %7
  %value12 = getelementptr inbounds %struct.imprecise, %struct.imprecise* %b, i32 0, i32 0
  %8 = load double, double* %value12, align 8
  %delta13 = getelementptr inbounds %struct.imprecise, %struct.imprecise* %a, i32 0, i32 1
  %9 = load double, double* %delta13, align 8
  %mul14 = fmul double %8, %9
  %mul15 = fmul double %mul11, %mul14
  %add = fadd double %mul8, %mul15
  %10 = call double @llvm.sqrt.f64(double %add)
  %delta16 = getelementptr inbounds %struct.imprecise, %struct.imprecise* %agg.result, i32 0, i32 1
  store double %10, double* %delta16, align 8
  ret void
}

; Function Attrs: noinline nounwind optnone
define hidden void @imprecise_div(%struct.imprecise* noalias sret align 8 %agg.result, %struct.imprecise* byval(%struct.imprecise) align 8 %a, %struct.imprecise* byval(%struct.imprecise) align 8 %b) #0 {
entry:
  %value = getelementptr inbounds %struct.imprecise, %struct.imprecise* %a, i32 0, i32 0
  %0 = load double, double* %value, align 8
  %value1 = getelementptr inbounds %struct.imprecise, %struct.imprecise* %b, i32 0, i32 0
  %1 = load double, double* %value1, align 8
  %div = fdiv double %0, %1
  %value2 = getelementptr inbounds %struct.imprecise, %struct.imprecise* %agg.result, i32 0, i32 0
  store double %div, double* %value2, align 8
  %value3 = getelementptr inbounds %struct.imprecise, %struct.imprecise* %a, i32 0, i32 0
  %2 = load double, double* %value3, align 8
  %delta = getelementptr inbounds %struct.imprecise, %struct.imprecise* %b, i32 0, i32 1
  %3 = load double, double* %delta, align 8
  %mul = fmul double %2, %3
  %value4 = getelementptr inbounds %struct.imprecise, %struct.imprecise* %a, i32 0, i32 0
  %4 = load double, double* %value4, align 8
  %delta5 = getelementptr inbounds %struct.imprecise, %struct.imprecise* %b, i32 0, i32 1
  %5 = load double, double* %delta5, align 8
  %mul6 = fmul double %4, %5
  %mul7 = fmul double %mul, %mul6
  %value8 = getelementptr inbounds %struct.imprecise, %struct.imprecise* %b, i32 0, i32 0
  %6 = load double, double* %value8, align 8
  %delta9 = getelementptr inbounds %struct.imprecise, %struct.imprecise* %a, i32 0, i32 1
  %7 = load double, double* %delta9, align 8
  %mul10 = fmul double %6, %7
  %value11 = getelementptr inbounds %struct.imprecise, %struct.imprecise* %b, i32 0, i32 0
  %8 = load double, double* %value11, align 8
  %delta12 = getelementptr inbounds %struct.imprecise, %struct.imprecise* %a, i32 0, i32 1
  %9 = load double, double* %delta12, align 8
  %mul13 = fmul double %8, %9
  %mul14 = fmul double %mul10, %mul13
  %add = fadd double %mul7, %mul14
  %10 = call double @llvm.sqrt.f64(double %add)
  %value15 = getelementptr inbounds %struct.imprecise, %struct.imprecise* %b, i32 0, i32 0
  %11 = load double, double* %value15, align 8
  %value16 = getelementptr inbounds %struct.imprecise, %struct.imprecise* %b, i32 0, i32 0
  %12 = load double, double* %value16, align 8
  %mul17 = fmul double %11, %12
  %div18 = fdiv double %10, %mul17
  %delta19 = getelementptr inbounds %struct.imprecise, %struct.imprecise* %agg.result, i32 0, i32 1
  store double %div18, double* %delta19, align 8
  ret void
}

; Function Attrs: noinline nounwind optnone
define hidden void @imprecise_pow(%struct.imprecise* noalias sret align 8 %agg.result, %struct.imprecise* byval(%struct.imprecise) align 8 %a, double %c) #0 {
entry:
  %c.addr = alloca double, align 8
  store double %c, double* %c.addr, align 8
  %value = getelementptr inbounds %struct.imprecise, %struct.imprecise* %a, i32 0, i32 0
  %0 = load double, double* %value, align 8
  %1 = load double, double* %c.addr, align 8
  %2 = call double @llvm.pow.f64(double %0, double %1)
  %value1 = getelementptr inbounds %struct.imprecise, %struct.imprecise* %agg.result, i32 0, i32 0
  store double %2, double* %value1, align 8
  %value2 = getelementptr inbounds %struct.imprecise, %struct.imprecise* %agg.result, i32 0, i32 0
  %3 = load double, double* %value2, align 8
  %4 = load double, double* %c.addr, align 8
  %mul = fmul double %3, %4
  %delta = getelementptr inbounds %struct.imprecise, %struct.imprecise* %a, i32 0, i32 1
  %5 = load double, double* %delta, align 8
  %mul3 = fmul double %mul, %5
  %value4 = getelementptr inbounds %struct.imprecise, %struct.imprecise* %a, i32 0, i32 0
  %6 = load double, double* %value4, align 8
  %div = fdiv double %mul3, %6
  %7 = call double @llvm.fabs.f64(double %div)
  %delta5 = getelementptr inbounds %struct.imprecise, %struct.imprecise* %agg.result, i32 0, i32 1
  store double %7, double* %delta5, align 8
  ret void
}

; Function Attrs: nounwind readnone speculatable willreturn
declare double @llvm.pow.f64(double %0, double %1) #1

; Function Attrs: nounwind readnone speculatable willreturn
declare double @llvm.fabs.f64(double %0) #1

; Function Attrs: noinline nounwind optnone
define hidden i8* @printImprecise(%struct.imprecise* byval(%struct.imprecise) align 8 %val) #0 {
entry:
  %principal = alloca [30 x i8], align 16
  %error = alloca [30 x i8], align 16
  %string = alloca i8*, align 4
  %sign = alloca [2 x i8], align 1
  %arrayidx = getelementptr inbounds [2 x i8], [2 x i8]* %sign, i32 0, i32 0
  store i8 -15, i8* %arrayidx, align 1
  %arrayidx1 = getelementptr inbounds [2 x i8], [2 x i8]* %sign, i32 0, i32 1
  store i8 0, i8* %arrayidx1, align 1
  %arraydecay = getelementptr inbounds [30 x i8], [30 x i8]* %principal, i32 0, i32 0
  %value = getelementptr inbounds %struct.imprecise, %struct.imprecise* %val, i32 0, i32 0
  %0 = load double, double* %value, align 8
  %call = call i32 (i8*, i8*, ...) @sprintf(i8* %arraydecay, i8* getelementptr inbounds ([3 x i8], [3 x i8]* @.str, i32 0, i32 0), double %0)
  %arraydecay2 = getelementptr inbounds [30 x i8], [30 x i8]* %error, i32 0, i32 0
  %delta = getelementptr inbounds %struct.imprecise, %struct.imprecise* %val, i32 0, i32 1
  %1 = load double, double* %delta, align 8
  %call3 = call i32 (i8*, i8*, ...) @sprintf(i8* %arraydecay2, i8* getelementptr inbounds ([3 x i8], [3 x i8]* @.str, i32 0, i32 0), double %1)
  %arraydecay4 = getelementptr inbounds [30 x i8], [30 x i8]* %principal, i32 0, i32 0
  %call5 = call i32 @strlen(i8* %arraydecay4) #5
  %add = add i32 %call5, 1
  %arraydecay6 = getelementptr inbounds [30 x i8], [30 x i8]* %error, i32 0, i32 0
  %call7 = call i32 @strlen(i8* %arraydecay6) #5
  %add8 = add i32 %add, %call7
  %add9 = add i32 %add8, 1
  %mul = mul i32 %add9, 1
  %call10 = call noalias i8* @malloc(i32 %mul)
  store i8* %call10, i8** %string, align 4
  %2 = load i8*, i8** %string, align 4
  %arraydecay11 = getelementptr inbounds [30 x i8], [30 x i8]* %principal, i32 0, i32 0
  %call12 = call i8* @strcpy(i8* %2, i8* %arraydecay11)
  %3 = load i8*, i8** %string, align 4
  %arraydecay13 = getelementptr inbounds [2 x i8], [2 x i8]* %sign, i32 0, i32 0
  %call14 = call i8* @strcat(i8* %3, i8* %arraydecay13)
  %4 = load i8*, i8** %string, align 4
  %arraydecay15 = getelementptr inbounds [30 x i8], [30 x i8]* %error, i32 0, i32 0
  %call16 = call i8* @strcat(i8* %4, i8* %arraydecay15)
  %5 = load i8*, i8** %string, align 4
  ret i8* %5
}

declare i32 @sprintf(i8* %0, i8* %1, ...) #2

declare noalias i8* @malloc(i32 %0) #2

; Function Attrs: nounwind readonly
declare i32 @strlen(i8* %0) #3

declare i8* @strcpy(i8* %0, i8* %1) #2

declare i8* @strcat(i8* %0, i8* %1) #2

; Function Attrs: noinline nounwind optnone
define hidden i32 @main() #0 {
entry:
  %retval = alloca i32, align 4
  %x1 = alloca %struct.imprecise, align 8
  %y1 = alloca %struct.imprecise, align 8
  %x2 = alloca %struct.imprecise, align 8
  %y2 = alloca %struct.imprecise, align 8
  %d = alloca %struct.imprecise, align 8
  %tmp = alloca %struct.imprecise, align 8
  %agg.tmp = alloca %struct.imprecise, align 8
  %agg.tmp1 = alloca %struct.imprecise, align 8
  %agg.tmp2 = alloca %struct.imprecise, align 8
  %agg.tmp3 = alloca %struct.imprecise, align 8
  %agg.tmp4 = alloca %struct.imprecise, align 8
  store i32 0, i32* %retval, align 4
  %0 = bitcast %struct.imprecise* %x1 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 8 %0, i8* align 8 bitcast (%struct.imprecise* @__const.main.x1 to i8*), i32 16, i1 false)
  %1 = bitcast %struct.imprecise* %y1 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 8 %1, i8* align 8 bitcast (%struct.imprecise* @__const.main.y1 to i8*), i32 16, i1 false)
  %2 = bitcast %struct.imprecise* %x2 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 8 %2, i8* align 8 bitcast (%struct.imprecise* @__const.main.x2 to i8*), i32 16, i1 false)
  %3 = bitcast %struct.imprecise* %y2 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 8 %3, i8* align 8 bitcast (%struct.imprecise* @__const.main.y2 to i8*), i32 16, i1 false)
  call void @imprecise_add(%struct.imprecise* sret align 8 %agg.tmp2, %struct.imprecise* byval(%struct.imprecise) align 8 %x1, %struct.imprecise* byval(%struct.imprecise) align 8 %x2)
  call void @imprecise_pow(%struct.imprecise* sret align 8 %agg.tmp1, %struct.imprecise* byval(%struct.imprecise) align 8 %agg.tmp2, double 2.000000e+00)
  call void @imprecise_add(%struct.imprecise* sret align 8 %agg.tmp4, %struct.imprecise* byval(%struct.imprecise) align 8 %y1, %struct.imprecise* byval(%struct.imprecise) align 8 %y2)
  call void @imprecise_pow(%struct.imprecise* sret align 8 %agg.tmp3, %struct.imprecise* byval(%struct.imprecise) align 8 %agg.tmp4, double 2.000000e+00)
  call void @imprecise_add(%struct.imprecise* sret align 8 %agg.tmp, %struct.imprecise* byval(%struct.imprecise) align 8 %agg.tmp1, %struct.imprecise* byval(%struct.imprecise) align 8 %agg.tmp3)
  call void @imprecise_pow(%struct.imprecise* sret align 8 %tmp, %struct.imprecise* byval(%struct.imprecise) align 8 %agg.tmp, double 5.000000e-01)
  %4 = bitcast %struct.imprecise* %d to i8*
  %5 = bitcast %struct.imprecise* %tmp to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 8 %4, i8* align 8 %5, i32 16, i1 false)
  %call = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([44 x i8], [44 x i8]* @.str.1, i32 0, i32 0))
  %call5 = call i8* @printImprecise(%struct.imprecise* byval(%struct.imprecise) align 8 %x1)
  %call6 = call i8* @printImprecise(%struct.imprecise* byval(%struct.imprecise) align 8 %y1)
  %call7 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([23 x i8], [23 x i8]* @.str.2, i32 0, i32 0), i8* %call5, i8* %call6)
  %call8 = call i8* @printImprecise(%struct.imprecise* byval(%struct.imprecise) align 8 %x2)
  %call9 = call i8* @printImprecise(%struct.imprecise* byval(%struct.imprecise) align 8 %y2)
  %call10 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([23 x i8], [23 x i8]* @.str.3, i32 0, i32 0), i8* %call8, i8* %call9)
  %call11 = call i8* @printImprecise(%struct.imprecise* byval(%struct.imprecise) align 8 %d)
  %call12 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([11 x i8], [11 x i8]* @.str.4, i32 0, i32 0), i8* %call11)
  ret i32 0
}

; Function Attrs: argmemonly nounwind willreturn
declare void @llvm.memcpy.p0i8.p0i8.i32(i8* noalias nocapture writeonly %0, i8* noalias nocapture readonly %1, i32 %2, i1 immarg %3) #4

declare i32 @printf(i8* %0, ...) #2

attributes #0 = { noinline nounwind optnone "correctly-rounded-divide-sqrt-fp-math"="false" "disable-tail-calls"="false" "frame-pointer"="none" "less-precise-fpmad"="false" "min-legal-vector-width"="0" "no-infs-fp-math"="false" "no-jump-tables"="false" "no-nans-fp-math"="false" "no-signed-zeros-fp-math"="false" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="generic" "unsafe-fp-math"="false" "use-soft-float"="false" }
attributes #1 = { nounwind readnone speculatable willreturn }
attributes #2 = { "correctly-rounded-divide-sqrt-fp-math"="false" "disable-tail-calls"="false" "frame-pointer"="none" "less-precise-fpmad"="false" "no-infs-fp-math"="false" "no-nans-fp-math"="false" "no-signed-zeros-fp-math"="false" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="generic" "unsafe-fp-math"="false" "use-soft-float"="false" }
attributes #3 = { nounwind readonly "correctly-rounded-divide-sqrt-fp-math"="false" "disable-tail-calls"="false" "frame-pointer"="none" "less-precise-fpmad"="false" "no-infs-fp-math"="false" "no-nans-fp-math"="false" "no-signed-zeros-fp-math"="false" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="generic" "unsafe-fp-math"="false" "use-soft-float"="false" }
attributes #4 = { argmemonly nounwind willreturn }
attributes #5 = { nounwind readonly }

!llvm.module.flags = !{!0}
!llvm.ident = !{!1}

!0 = !{i32 1, !"wchar_size", i32 4}
!1 = !{!"clang version 11.0.0 (https://github.com/Jacarte/llvm-project.git 0f6dea67136cc1e0b3d200eb2bb165628970c44b)"}

; extracted candidates

; *****
; For LLVM instruction:
;  %call5 = call i32 @strlen(i8* %arraydecay4) #5
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %add = add i32 %call5, 1
; Looking for a replacement for:
%0:i32 = var
%1:i32 = add 1:i32, %0
infer %1

; *****
; For LLVM instruction:
;  %call7 = call i32 @strlen(i8* %arraydecay6) #5
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %add8 = add i32 %add, %call7
; Looking for a replacement for:
%0:i32 = var
%1:i32 = var
%2:i32 = add 1:i32, %1
%3:i32 = add %0, %2
infer %3

; *****
; For LLVM instruction:
;  %add9 = add i32 %add8, 1
; Looking for a replacement for:
%0:i32 = var
%1:i32 = var
%2:i32 = add 1:i32, %1
%3:i32 = add %0, %2
%4:i32 = add 1:i32, %3
infer %4

; *****
; For LLVM instruction:
;  %mul = mul i32 %add9, 1
; Looking for a replacement for:
%0:i32 = var
%1:i32 = var
%2:i32 = add 1:i32, %1
%3:i32 = add %0, %2
%4:i32 = add 1:i32, %3
%5:i32 = mul 1:i32, %4
infer %5
got 1 candidates from LHS

-------------------------------------------------
%0:i32 = var
infer %0


--------------------------------
guess 0

%0:i32 = var ; reservedconst_1

Cost = 0
first query is SAT, returning the model:
reservedconst_1: 0
ConstantSynthesis: solver returns error on second query
Dataflow Pruned 0/0
There are 1 Guesses
There are 0 RHSs before deduplication
There are 0 RHSs after deduplication
got 2 candidates from LHS

-------------------------------------------------
%0:i32 = var
%1:i32 = add 1:i32, %0
infer %1


--------------------------------
guess 0

%0:i32 = var ; reservedconst_1

Cost = 0
first query is SAT, returning the model:
reservedconst_1: 1
0 th attempt: second query is SAT-- constant doesn't work
first query is SAT, returning the model:
reservedconst_1: 0
1 th attempt: second query is SAT-- constant doesn't work
first query is UNSAT-- no more guesses

--------------------------------
guess 1

%0:i32 = var

Cost = 0
second query is SAT-- constant doesn't work
Dataflow Pruned 0/0
There are 2 Guesses
There are 0 RHSs before deduplication
There are 0 RHSs after deduplication
got 4 candidates from LHS

-------------------------------------------------
%0:i32 = var
%1:i32 = var
%2:i32 = add 1:i32, %1
%3:i32 = add %0, %2
infer %3


--------------------------------
guess 0

%0:i32 = var ; reservedconst_1

Cost = 0
first query is SAT, returning the model:
reservedconst_1: 1
0 th attempt: second query is SAT-- constant doesn't work
first query is SAT, returning the model:
reservedconst_1: 0
1 th attempt: second query is SAT-- constant doesn't work
first query is UNSAT-- no more guesses

--------------------------------
guess 1

%0:i32 = var

Cost = 0
second query is SAT-- constant doesn't work

--------------------------------
guess 2

%0:i32 = var

Cost = 0
second query is SAT-- constant doesn't work

--------------------------------
guess 3

%0:i32 = var
%1:i32 = add 1:i32, %0

Cost = 1
second query is SAT-- constant doesn't work
Dataflow Pruned 0/0
There are 4 Guesses
There are 0 RHSs before deduplication
There are 0 RHSs after deduplication
got 5 candidates from LHS

-------------------------------------------------
%0:i32 = var
%1:i32 = var
%2:i32 = add 1:i32, %1
%3:i32 = add %0, %2
%4:i32 = add 1:i32, %3
infer %4


--------------------------------
guess 0

%0:i32 = var ; reservedconst_1

Cost = 0
first query is SAT, returning the model:
reservedconst_1: 2
0 th attempt: second query is SAT-- constant doesn't work
first query is SAT, returning the model:
reservedconst_1: 1
1 th attempt: second query is SAT-- constant doesn't work
first query is UNSAT-- no more guesses

--------------------------------
guess 1

%0:i32 = var

Cost = 0
second query is SAT-- constant doesn't work

--------------------------------
guess 2

%0:i32 = var

Cost = 0
second query is SAT-- constant doesn't work

--------------------------------
guess 3

%0:i32 = var
%1:i32 = add 1:i32, %0

Cost = 1
second query is SAT-- constant doesn't work

--------------------------------
guess 4

%0:i32 = var
%1:i32 = var
%2:i32 = add 1:i32, %1
%3:i32 = add %0, %2

Cost = 2
second query is SAT-- constant doesn't work
Dataflow Pruned 0/0
There are 5 Guesses
There are 0 RHSs before deduplication
There are 0 RHSs after deduplication
got 6 candidates from LHS

-------------------------------------------------
%0:i32 = var
%1:i32 = var
%2:i32 = add 1:i32, %1
%3:i32 = add %0, %2
%4:i32 = add 1:i32, %3
%5:i32 = mul 1:i32, %4
infer %5


--------------------------------
guess 0

%0:i32 = var ; reservedconst_1

Cost = 0
first query is SAT, returning the model:
reservedconst_1: 2
0 th attempt: second query is SAT-- constant doesn't work
first query is SAT, returning the model:
reservedconst_1: 1
1 th attempt: second query is SAT-- constant doesn't work
first query is UNSAT-- no more guesses

--------------------------------
guess 1

%0:i32 = var

Cost = 0
second query is SAT-- constant doesn't work

--------------------------------
guess 2

%0:i32 = var

Cost = 0
second query is SAT-- constant doesn't work

--------------------------------
guess 3

%0:i32 = var
%1:i32 = add 1:i32, %0

Cost = 1
second query is SAT-- constant doesn't work

--------------------------------
guess 4

%0:i32 = var
%1:i32 = var
%2:i32 = add 1:i32, %1
%3:i32 = add %0, %2

Cost = 2
second query is SAT-- constant doesn't work

--------------------------------
guess 5

%0:i32 = var
%1:i32 = var
%2:i32 = add 1:i32, %1
%3:i32 = add %0, %2
%4:i32 = add 1:i32, %3

Cost = 3
second query is UNSAT
Dataflow Pruned 0/0
There are 6 Guesses
There are 1 RHSs before deduplication
There are 1 RHSs after deduplication
"
; No valid RHS in the list
#########################################################

Module before replacement:
; ModuleID = './Numeric_error_propagation.c.bc'
source_filename = "./Numeric_error_propagation.c"
target datalayout = "e-m:e-p:32:32-i64:64-n32:64-S128"
target triple = "wasm32-unknown-wasi"

%struct.imprecise = type { double, double }

@.str = private unnamed_addr constant [3 x i8] c"%f\00", align 1
@__const.main.x1 = private unnamed_addr constant %struct.imprecise { double 1.000000e+02, double 1.100000e+00 }, align 8
@__const.main.y1 = private unnamed_addr constant %struct.imprecise { double 5.000000e+01, double 1.200000e+00 }, align 8
@__const.main.x2 = private unnamed_addr constant %struct.imprecise { double -2.000000e+02, double 2.200000e+00 }, align 8
@__const.main.y2 = private unnamed_addr constant %struct.imprecise { double -1.000000e+02, double 2.300000e+00 }, align 8
@.str.1 = private unnamed_addr constant [44 x i8] c"Distance, d, between the following points :\00", align 1
@.str.2 = private unnamed_addr constant [23 x i8] c"\0A( x1, y1) = ( %s, %s)\00", align 1
@.str.3 = private unnamed_addr constant [23 x i8] c"\0A( x2, y2) = ( %s, %s)\00", align 1
@.str.4 = private unnamed_addr constant [11 x i8] c"\0Ais d = %s\00", align 1
@llvm.used = appending global [1 x i8*] [i8* bitcast (i32 ()* @__main_void to i8*)], section "llvm.metadata"

@__main_void = alias i32 (), i32 ()* @main

; Function Attrs: noinline nounwind optnone
define hidden void @imprecise_add(%struct.imprecise* noalias sret align 8 %agg.result, %struct.imprecise* byval(%struct.imprecise) align 8 %a, %struct.imprecise* byval(%struct.imprecise) align 8 %b) #0 {
entry:
  %value = getelementptr inbounds %struct.imprecise, %struct.imprecise* %a, i32 0, i32 0
  %0 = load double, double* %value, align 8
  %value1 = getelementptr inbounds %struct.imprecise, %struct.imprecise* %b, i32 0, i32 0
  %1 = load double, double* %value1, align 8
  %add = fadd double %0, %1
  %value2 = getelementptr inbounds %struct.imprecise, %struct.imprecise* %agg.result, i32 0, i32 0
  store double %add, double* %value2, align 8
  %delta = getelementptr inbounds %struct.imprecise, %struct.imprecise* %a, i32 0, i32 1
  %2 = load double, double* %delta, align 8
  %delta3 = getelementptr inbounds %struct.imprecise, %struct.imprecise* %a, i32 0, i32 1
  %3 = load double, double* %delta3, align 8
  %mul = fmul double %2, %3
  %delta4 = getelementptr inbounds %struct.imprecise, %struct.imprecise* %b, i32 0, i32 1
  %4 = load double, double* %delta4, align 8
  %delta5 = getelementptr inbounds %struct.imprecise, %struct.imprecise* %b, i32 0, i32 1
  %5 = load double, double* %delta5, align 8
  %mul6 = fmul double %4, %5
  %add7 = fadd double %mul, %mul6
  %6 = call double @llvm.sqrt.f64(double %add7)
  %delta8 = getelementptr inbounds %struct.imprecise, %struct.imprecise* %agg.result, i32 0, i32 1
  store double %6, double* %delta8, align 8
  ret void
}

; Function Attrs: nounwind readnone speculatable willreturn
declare double @llvm.sqrt.f64(double %0) #1

; Function Attrs: noinline nounwind optnone
define hidden void @imprecise_mul(%struct.imprecise* noalias sret align 8 %agg.result, %struct.imprecise* byval(%struct.imprecise) align 8 %a, %struct.imprecise* byval(%struct.imprecise) align 8 %b) #0 {
entry:
  %value = getelementptr inbounds %struct.imprecise, %struct.imprecise* %a, i32 0, i32 0
  %0 = load double, double* %value, align 8
  %value1 = getelementptr inbounds %struct.imprecise, %struct.imprecise* %b, i32 0, i32 0
  %1 = load double, double* %value1, align 8
  %mul = fmul double %0, %1
  %value2 = getelementptr inbounds %struct.imprecise, %struct.imprecise* %agg.result, i32 0, i32 0
  store double %mul, double* %value2, align 8
  %value3 = getelementptr inbounds %struct.imprecise, %struct.imprecise* %a, i32 0, i32 0
  %2 = load double, double* %value3, align 8
  %delta = getelementptr inbounds %struct.imprecise, %struct.imprecise* %b, i32 0, i32 1
  %3 = load double, double* %delta, align 8
  %mul4 = fmul double %2, %3
  %value5 = getelementptr inbounds %struct.imprecise, %struct.imprecise* %a, i32 0, i32 0
  %4 = load double, double* %value5, align 8
  %delta6 = getelementptr inbounds %struct.imprecise, %struct.imprecise* %b, i32 0, i32 1
  %5 = load double, double* %delta6, align 8
  %mul7 = fmul double %4, %5
  %mul8 = fmul double %mul4, %mul7
  %value9 = getelementptr inbounds %struct.imprecise, %struct.imprecise* %b, i32 0, i32 0
  %6 = load double, double* %value9, align 8
  %delta10 = getelementptr inbounds %struct.imprecise, %struct.imprecise* %a, i32 0, i32 1
  %7 = load double, double* %delta10, align 8
  %mul11 = fmul double %6, %7
  %value12 = getelementptr inbounds %struct.imprecise, %struct.imprecise* %b, i32 0, i32 0
  %8 = load double, double* %value12, align 8
  %delta13 = getelementptr inbounds %struct.imprecise, %struct.imprecise* %a, i32 0, i32 1
  %9 = load double, double* %delta13, align 8
  %mul14 = fmul double %8, %9
  %mul15 = fmul double %mul11, %mul14
  %add = fadd double %mul8, %mul15
  %10 = call double @llvm.sqrt.f64(double %add)
  %delta16 = getelementptr inbounds %struct.imprecise, %struct.imprecise* %agg.result, i32 0, i32 1
  store double %10, double* %delta16, align 8
  ret void
}

; Function Attrs: noinline nounwind optnone
define hidden void @imprecise_div(%struct.imprecise* noalias sret align 8 %agg.result, %struct.imprecise* byval(%struct.imprecise) align 8 %a, %struct.imprecise* byval(%struct.imprecise) align 8 %b) #0 {
entry:
  %value = getelementptr inbounds %struct.imprecise, %struct.imprecise* %a, i32 0, i32 0
  %0 = load double, double* %value, align 8
  %value1 = getelementptr inbounds %struct.imprecise, %struct.imprecise* %b, i32 0, i32 0
  %1 = load double, double* %value1, align 8
  %div = fdiv double %0, %1
  %value2 = getelementptr inbounds %struct.imprecise, %struct.imprecise* %agg.result, i32 0, i32 0
  store double %div, double* %value2, align 8
  %value3 = getelementptr inbounds %struct.imprecise, %struct.imprecise* %a, i32 0, i32 0
  %2 = load double, double* %value3, align 8
  %delta = getelementptr inbounds %struct.imprecise, %struct.imprecise* %b, i32 0, i32 1
  %3 = load double, double* %delta, align 8
  %mul = fmul double %2, %3
  %value4 = getelementptr inbounds %struct.imprecise, %struct.imprecise* %a, i32 0, i32 0
  %4 = load double, double* %value4, align 8
  %delta5 = getelementptr inbounds %struct.imprecise, %struct.imprecise* %b, i32 0, i32 1
  %5 = load double, double* %delta5, align 8
  %mul6 = fmul double %4, %5
  %mul7 = fmul double %mul, %mul6
  %value8 = getelementptr inbounds %struct.imprecise, %struct.imprecise* %b, i32 0, i32 0
  %6 = load double, double* %value8, align 8
  %delta9 = getelementptr inbounds %struct.imprecise, %struct.imprecise* %a, i32 0, i32 1
  %7 = load double, double* %delta9, align 8
  %mul10 = fmul double %6, %7
  %value11 = getelementptr inbounds %struct.imprecise, %struct.imprecise* %b, i32 0, i32 0
  %8 = load double, double* %value11, align 8
  %delta12 = getelementptr inbounds %struct.imprecise, %struct.imprecise* %a, i32 0, i32 1
  %9 = load double, double* %delta12, align 8
  %mul13 = fmul double %8, %9
  %mul14 = fmul double %mul10, %mul13
  %add = fadd double %mul7, %mul14
  %10 = call double @llvm.sqrt.f64(double %add)
  %value15 = getelementptr inbounds %struct.imprecise, %struct.imprecise* %b, i32 0, i32 0
  %11 = load double, double* %value15, align 8
  %value16 = getelementptr inbounds %struct.imprecise, %struct.imprecise* %b, i32 0, i32 0
  %12 = load double, double* %value16, align 8
  %mul17 = fmul double %11, %12
  %div18 = fdiv double %10, %mul17
  %delta19 = getelementptr inbounds %struct.imprecise, %struct.imprecise* %agg.result, i32 0, i32 1
  store double %div18, double* %delta19, align 8
  ret void
}

; Function Attrs: noinline nounwind optnone
define hidden void @imprecise_pow(%struct.imprecise* noalias sret align 8 %agg.result, %struct.imprecise* byval(%struct.imprecise) align 8 %a, double %c) #0 {
entry:
  %c.addr = alloca double, align 8
  store double %c, double* %c.addr, align 8
  %value = getelementptr inbounds %struct.imprecise, %struct.imprecise* %a, i32 0, i32 0
  %0 = load double, double* %value, align 8
  %1 = load double, double* %c.addr, align 8
  %2 = call double @llvm.pow.f64(double %0, double %1)
  %value1 = getelementptr inbounds %struct.imprecise, %struct.imprecise* %agg.result, i32 0, i32 0
  store double %2, double* %value1, align 8
  %value2 = getelementptr inbounds %struct.imprecise, %struct.imprecise* %agg.result, i32 0, i32 0
  %3 = load double, double* %value2, align 8
  %4 = load double, double* %c.addr, align 8
  %mul = fmul double %3, %4
  %delta = getelementptr inbounds %struct.imprecise, %struct.imprecise* %a, i32 0, i32 1
  %5 = load double, double* %delta, align 8
  %mul3 = fmul double %mul, %5
  %value4 = getelementptr inbounds %struct.imprecise, %struct.imprecise* %a, i32 0, i32 0
  %6 = load double, double* %value4, align 8
  %div = fdiv double %mul3, %6
  %7 = call double @llvm.fabs.f64(double %div)
  %delta5 = getelementptr inbounds %struct.imprecise, %struct.imprecise* %agg.result, i32 0, i32 1
  store double %7, double* %delta5, align 8
  ret void
}

; Function Attrs: nounwind readnone speculatable willreturn
declare double @llvm.pow.f64(double %0, double %1) #1

; Function Attrs: nounwind readnone speculatable willreturn
declare double @llvm.fabs.f64(double %0) #1

; Function Attrs: noinline nounwind optnone
define hidden i8* @printImprecise(%struct.imprecise* byval(%struct.imprecise) align 8 %val) #0 {
entry:
  %principal = alloca [30 x i8], align 16
  %error = alloca [30 x i8], align 16
  %string = alloca i8*, align 4
  %sign = alloca [2 x i8], align 1
  %arrayidx = getelementptr inbounds [2 x i8], [2 x i8]* %sign, i32 0, i32 0
  store i8 -15, i8* %arrayidx, align 1
  %arrayidx1 = getelementptr inbounds [2 x i8], [2 x i8]* %sign, i32 0, i32 1
  store i8 0, i8* %arrayidx1, align 1
  %arraydecay = getelementptr inbounds [30 x i8], [30 x i8]* %principal, i32 0, i32 0
  %value = getelementptr inbounds %struct.imprecise, %struct.imprecise* %val, i32 0, i32 0
  %0 = load double, double* %value, align 8
  %call = call i32 (i8*, i8*, ...) @sprintf(i8* %arraydecay, i8* getelementptr inbounds ([3 x i8], [3 x i8]* @.str, i32 0, i32 0), double %0)
  %arraydecay2 = getelementptr inbounds [30 x i8], [30 x i8]* %error, i32 0, i32 0
  %delta = getelementptr inbounds %struct.imprecise, %struct.imprecise* %val, i32 0, i32 1
  %1 = load double, double* %delta, align 8
  %call3 = call i32 (i8*, i8*, ...) @sprintf(i8* %arraydecay2, i8* getelementptr inbounds ([3 x i8], [3 x i8]* @.str, i32 0, i32 0), double %1)
  %arraydecay4 = getelementptr inbounds [30 x i8], [30 x i8]* %principal, i32 0, i32 0
  %call5 = call i32 @strlen(i8* %arraydecay4) #5
  %add = add i32 %call5, 1
  %arraydecay6 = getelementptr inbounds [30 x i8], [30 x i8]* %error, i32 0, i32 0
  %call7 = call i32 @strlen(i8* %arraydecay6) #5
  %add8 = add i32 %add, %call7
  %add9 = add i32 %add8, 1
  %mul = mul i32 %add9, 1
  %call10 = call noalias i8* @malloc(i32 %mul)
  store i8* %call10, i8** %string, align 4
  %2 = load i8*, i8** %string, align 4
  %arraydecay11 = getelementptr inbounds [30 x i8], [30 x i8]* %principal, i32 0, i32 0
  %call12 = call i8* @strcpy(i8* %2, i8* %arraydecay11)
  %3 = load i8*, i8** %string, align 4
  %arraydecay13 = getelementptr inbounds [2 x i8], [2 x i8]* %sign, i32 0, i32 0
  %call14 = call i8* @strcat(i8* %3, i8* %arraydecay13)
  %4 = load i8*, i8** %string, align 4
  %arraydecay15 = getelementptr inbounds [30 x i8], [30 x i8]* %error, i32 0, i32 0
  %call16 = call i8* @strcat(i8* %4, i8* %arraydecay15)
  %5 = load i8*, i8** %string, align 4
  ret i8* %5
}

declare i32 @sprintf(i8* %0, i8* %1, ...) #2

declare noalias i8* @malloc(i32 %0) #2

; Function Attrs: nounwind readonly
declare i32 @strlen(i8* %0) #3

declare i8* @strcpy(i8* %0, i8* %1) #2

declare i8* @strcat(i8* %0, i8* %1) #2

; Function Attrs: noinline nounwind optnone
define hidden i32 @main() #0 {
entry:
  %retval = alloca i32, align 4
  %x1 = alloca %struct.imprecise, align 8
  %y1 = alloca %struct.imprecise, align 8
  %x2 = alloca %struct.imprecise, align 8
  %y2 = alloca %struct.imprecise, align 8
  %d = alloca %struct.imprecise, align 8
  %tmp = alloca %struct.imprecise, align 8
  %agg.tmp = alloca %struct.imprecise, align 8
  %agg.tmp1 = alloca %struct.imprecise, align 8
  %agg.tmp2 = alloca %struct.imprecise, align 8
  %agg.tmp3 = alloca %struct.imprecise, align 8
  %agg.tmp4 = alloca %struct.imprecise, align 8
  store i32 0, i32* %retval, align 4
  %0 = bitcast %struct.imprecise* %x1 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 8 %0, i8* align 8 bitcast (%struct.imprecise* @__const.main.x1 to i8*), i32 16, i1 false)
  %1 = bitcast %struct.imprecise* %y1 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 8 %1, i8* align 8 bitcast (%struct.imprecise* @__const.main.y1 to i8*), i32 16, i1 false)
  %2 = bitcast %struct.imprecise* %x2 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 8 %2, i8* align 8 bitcast (%struct.imprecise* @__const.main.x2 to i8*), i32 16, i1 false)
  %3 = bitcast %struct.imprecise* %y2 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 8 %3, i8* align 8 bitcast (%struct.imprecise* @__const.main.y2 to i8*), i32 16, i1 false)
  call void @imprecise_add(%struct.imprecise* sret align 8 %agg.tmp2, %struct.imprecise* byval(%struct.imprecise) align 8 %x1, %struct.imprecise* byval(%struct.imprecise) align 8 %x2)
  call void @imprecise_pow(%struct.imprecise* sret align 8 %agg.tmp1, %struct.imprecise* byval(%struct.imprecise) align 8 %agg.tmp2, double 2.000000e+00)
  call void @imprecise_add(%struct.imprecise* sret align 8 %agg.tmp4, %struct.imprecise* byval(%struct.imprecise) align 8 %y1, %struct.imprecise* byval(%struct.imprecise) align 8 %y2)
  call void @imprecise_pow(%struct.imprecise* sret align 8 %agg.tmp3, %struct.imprecise* byval(%struct.imprecise) align 8 %agg.tmp4, double 2.000000e+00)
  call void @imprecise_add(%struct.imprecise* sret align 8 %agg.tmp, %struct.imprecise* byval(%struct.imprecise) align 8 %agg.tmp1, %struct.imprecise* byval(%struct.imprecise) align 8 %agg.tmp3)
  call void @imprecise_pow(%struct.imprecise* sret align 8 %tmp, %struct.imprecise* byval(%struct.imprecise) align 8 %agg.tmp, double 5.000000e-01)
  %4 = bitcast %struct.imprecise* %d to i8*
  %5 = bitcast %struct.imprecise* %tmp to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 8 %4, i8* align 8 %5, i32 16, i1 false)
  %call = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([44 x i8], [44 x i8]* @.str.1, i32 0, i32 0))
  %call5 = call i8* @printImprecise(%struct.imprecise* byval(%struct.imprecise) align 8 %x1)
  %call6 = call i8* @printImprecise(%struct.imprecise* byval(%struct.imprecise) align 8 %y1)
  %call7 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([23 x i8], [23 x i8]* @.str.2, i32 0, i32 0), i8* %call5, i8* %call6)
  %call8 = call i8* @printImprecise(%struct.imprecise* byval(%struct.imprecise) align 8 %x2)
  %call9 = call i8* @printImprecise(%struct.imprecise* byval(%struct.imprecise) align 8 %y2)
  %call10 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([23 x i8], [23 x i8]* @.str.3, i32 0, i32 0), i8* %call8, i8* %call9)
  %call11 = call i8* @printImprecise(%struct.imprecise* byval(%struct.imprecise) align 8 %d)
  %call12 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([11 x i8], [11 x i8]* @.str.4, i32 0, i32 0), i8* %call11)
  ret i32 0
}

; Function Attrs: argmemonly nounwind willreturn
declare void @llvm.memcpy.p0i8.p0i8.i32(i8* noalias nocapture writeonly %0, i8* noalias nocapture readonly %1, i32 %2, i1 immarg %3) #4

declare i32 @printf(i8* %0, ...) #2

attributes #0 = { noinline nounwind optnone "correctly-rounded-divide-sqrt-fp-math"="false" "disable-tail-calls"="false" "frame-pointer"="none" "less-precise-fpmad"="false" "min-legal-vector-width"="0" "no-infs-fp-math"="false" "no-jump-tables"="false" "no-nans-fp-math"="false" "no-signed-zeros-fp-math"="false" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="generic" "unsafe-fp-math"="false" "use-soft-float"="false" }
attributes #1 = { nounwind readnone speculatable willreturn }
attributes #2 = { "correctly-rounded-divide-sqrt-fp-math"="false" "disable-tail-calls"="false" "frame-pointer"="none" "less-precise-fpmad"="false" "no-infs-fp-math"="false" "no-nans-fp-math"="false" "no-signed-zeros-fp-math"="false" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="generic" "unsafe-fp-math"="false" "use-soft-float"="false" }
attributes #3 = { nounwind readonly "correctly-rounded-divide-sqrt-fp-math"="false" "disable-tail-calls"="false" "frame-pointer"="none" "less-precise-fpmad"="false" "no-infs-fp-math"="false" "no-nans-fp-math"="false" "no-signed-zeros-fp-math"="false" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="generic" "unsafe-fp-math"="false" "use-soft-float"="false" }
attributes #4 = { argmemonly nounwind willreturn }
attributes #5 = { nounwind readonly }

!llvm.module.flags = !{!0}
!llvm.ident = !{!1}

!0 = !{i32 1, !"wchar_size", i32 4}
!1 = !{!"clang version 11.0.0 (https://github.com/Jacarte/llvm-project.git 0f6dea67136cc1e0b3d200eb2bb165628970c44b)"}

; Replacing "  %mul = mul i32 %add9, 1"
; from ""
; with "  %add9 = add i32 %add8, 1" in:
"%0:i32 = var
%1:i32 = var
%2:i32 = add 1:i32, %1
%3:i32 = add %0, %2
%4:i32 = add 1:i32, %3
%5:i32 = mul 1:i32, %4
cand %5 %4
"
; with "  %add9 = add i32 %add8, 1"

Module after replacement:
; ModuleID = './Numeric_error_propagation.c.bc'
source_filename = "./Numeric_error_propagation.c"
target datalayout = "e-m:e-p:32:32-i64:64-n32:64-S128"
target triple = "wasm32-unknown-wasi"

%struct.imprecise = type { double, double }

@.str = private unnamed_addr constant [3 x i8] c"%f\00", align 1
@__const.main.x1 = private unnamed_addr constant %struct.imprecise { double 1.000000e+02, double 1.100000e+00 }, align 8
@__const.main.y1 = private unnamed_addr constant %struct.imprecise { double 5.000000e+01, double 1.200000e+00 }, align 8
@__const.main.x2 = private unnamed_addr constant %struct.imprecise { double -2.000000e+02, double 2.200000e+00 }, align 8
@__const.main.y2 = private unnamed_addr constant %struct.imprecise { double -1.000000e+02, double 2.300000e+00 }, align 8
@.str.1 = private unnamed_addr constant [44 x i8] c"Distance, d, between the following points :\00", align 1
@.str.2 = private unnamed_addr constant [23 x i8] c"\0A( x1, y1) = ( %s, %s)\00", align 1
@.str.3 = private unnamed_addr constant [23 x i8] c"\0A( x2, y2) = ( %s, %s)\00", align 1
@.str.4 = private unnamed_addr constant [11 x i8] c"\0Ais d = %s\00", align 1
@llvm.used = appending global [1 x i8*] [i8* bitcast (i32 ()* @__main_void to i8*)], section "llvm.metadata"

@__main_void = alias i32 (), i32 ()* @main

; Function Attrs: noinline nounwind optnone
define hidden void @imprecise_add(%struct.imprecise* noalias sret align 8 %agg.result, %struct.imprecise* byval(%struct.imprecise) align 8 %a, %struct.imprecise* byval(%struct.imprecise) align 8 %b) #0 {
entry:
  %value = getelementptr inbounds %struct.imprecise, %struct.imprecise* %a, i32 0, i32 0
  %0 = load double, double* %value, align 8
  %value1 = getelementptr inbounds %struct.imprecise, %struct.imprecise* %b, i32 0, i32 0
  %1 = load double, double* %value1, align 8
  %add = fadd double %0, %1
  %value2 = getelementptr inbounds %struct.imprecise, %struct.imprecise* %agg.result, i32 0, i32 0
  store double %add, double* %value2, align 8
  %delta = getelementptr inbounds %struct.imprecise, %struct.imprecise* %a, i32 0, i32 1
  %2 = load double, double* %delta, align 8
  %delta3 = getelementptr inbounds %struct.imprecise, %struct.imprecise* %a, i32 0, i32 1
  %3 = load double, double* %delta3, align 8
  %mul = fmul double %2, %3
  %delta4 = getelementptr inbounds %struct.imprecise, %struct.imprecise* %b, i32 0, i32 1
  %4 = load double, double* %delta4, align 8
  %delta5 = getelementptr inbounds %struct.imprecise, %struct.imprecise* %b, i32 0, i32 1
  %5 = load double, double* %delta5, align 8
  %mul6 = fmul double %4, %5
  %add7 = fadd double %mul, %mul6
  %6 = call double @llvm.sqrt.f64(double %add7)
  %delta8 = getelementptr inbounds %struct.imprecise, %struct.imprecise* %agg.result, i32 0, i32 1
  store double %6, double* %delta8, align 8
  ret void
}

; Function Attrs: nounwind readnone speculatable willreturn
declare double @llvm.sqrt.f64(double %0) #1

; Function Attrs: noinline nounwind optnone
define hidden void @imprecise_mul(%struct.imprecise* noalias sret align 8 %agg.result, %struct.imprecise* byval(%struct.imprecise) align 8 %a, %struct.imprecise* byval(%struct.imprecise) align 8 %b) #0 {
entry:
  %value = getelementptr inbounds %struct.imprecise, %struct.imprecise* %a, i32 0, i32 0
  %0 = load double, double* %value, align 8
  %value1 = getelementptr inbounds %struct.imprecise, %struct.imprecise* %b, i32 0, i32 0
  %1 = load double, double* %value1, align 8
  %mul = fmul double %0, %1
  %value2 = getelementptr inbounds %struct.imprecise, %struct.imprecise* %agg.result, i32 0, i32 0
  store double %mul, double* %value2, align 8
  %value3 = getelementptr inbounds %struct.imprecise, %struct.imprecise* %a, i32 0, i32 0
  %2 = load double, double* %value3, align 8
  %delta = getelementptr inbounds %struct.imprecise, %struct.imprecise* %b, i32 0, i32 1
  %3 = load double, double* %delta, align 8
  %mul4 = fmul double %2, %3
  %value5 = getelementptr inbounds %struct.imprecise, %struct.imprecise* %a, i32 0, i32 0
  %4 = load double, double* %value5, align 8
  %delta6 = getelementptr inbounds %struct.imprecise, %struct.imprecise* %b, i32 0, i32 1
  %5 = load double, double* %delta6, align 8
  %mul7 = fmul double %4, %5
  %mul8 = fmul double %mul4, %mul7
  %value9 = getelementptr inbounds %struct.imprecise, %struct.imprecise* %b, i32 0, i32 0
  %6 = load double, double* %value9, align 8
  %delta10 = getelementptr inbounds %struct.imprecise, %struct.imprecise* %a, i32 0, i32 1
  %7 = load double, double* %delta10, align 8
  %mul11 = fmul double %6, %7
  %value12 = getelementptr inbounds %struct.imprecise, %struct.imprecise* %b, i32 0, i32 0
  %8 = load double, double* %value12, align 8
  %delta13 = getelementptr inbounds %struct.imprecise, %struct.imprecise* %a, i32 0, i32 1
  %9 = load double, double* %delta13, align 8
  %mul14 = fmul double %8, %9
  %mul15 = fmul double %mul11, %mul14
  %add = fadd double %mul8, %mul15
  %10 = call double @llvm.sqrt.f64(double %add)
  %delta16 = getelementptr inbounds %struct.imprecise, %struct.imprecise* %agg.result, i32 0, i32 1
  store double %10, double* %delta16, align 8
  ret void
}

; Function Attrs: noinline nounwind optnone
define hidden void @imprecise_div(%struct.imprecise* noalias sret align 8 %agg.result, %struct.imprecise* byval(%struct.imprecise) align 8 %a, %struct.imprecise* byval(%struct.imprecise) align 8 %b) #0 {
entry:
  %value = getelementptr inbounds %struct.imprecise, %struct.imprecise* %a, i32 0, i32 0
  %0 = load double, double* %value, align 8
  %value1 = getelementptr inbounds %struct.imprecise, %struct.imprecise* %b, i32 0, i32 0
  %1 = load double, double* %value1, align 8
  %div = fdiv double %0, %1
  %value2 = getelementptr inbounds %struct.imprecise, %struct.imprecise* %agg.result, i32 0, i32 0
  store double %div, double* %value2, align 8
  %value3 = getelementptr inbounds %struct.imprecise, %struct.imprecise* %a, i32 0, i32 0
  %2 = load double, double* %value3, align 8
  %delta = getelementptr inbounds %struct.imprecise, %struct.imprecise* %b, i32 0, i32 1
  %3 = load double, double* %delta, align 8
  %mul = fmul double %2, %3
  %value4 = getelementptr inbounds %struct.imprecise, %struct.imprecise* %a, i32 0, i32 0
  %4 = load double, double* %value4, align 8
  %delta5 = getelementptr inbounds %struct.imprecise, %struct.imprecise* %b, i32 0, i32 1
  %5 = load double, double* %delta5, align 8
  %mul6 = fmul double %4, %5
  %mul7 = fmul double %mul, %mul6
  %value8 = getelementptr inbounds %struct.imprecise, %struct.imprecise* %b, i32 0, i32 0
  %6 = load double, double* %value8, align 8
  %delta9 = getelementptr inbounds %struct.imprecise, %struct.imprecise* %a, i32 0, i32 1
  %7 = load double, double* %delta9, align 8
  %mul10 = fmul double %6, %7
  %value11 = getelementptr inbounds %struct.imprecise, %struct.imprecise* %b, i32 0, i32 0
  %8 = load double, double* %value11, align 8
  %delta12 = getelementptr inbounds %struct.imprecise, %struct.imprecise* %a, i32 0, i32 1
  %9 = load double, double* %delta12, align 8
  %mul13 = fmul double %8, %9
  %mul14 = fmul double %mul10, %mul13
  %add = fadd double %mul7, %mul14
  %10 = call double @llvm.sqrt.f64(double %add)
  %value15 = getelementptr inbounds %struct.imprecise, %struct.imprecise* %b, i32 0, i32 0
  %11 = load double, double* %value15, align 8
  %value16 = getelementptr inbounds %struct.imprecise, %struct.imprecise* %b, i32 0, i32 0
  %12 = load double, double* %value16, align 8
  %mul17 = fmul double %11, %12
  %div18 = fdiv double %10, %mul17
  %delta19 = getelementptr inbounds %struct.imprecise, %struct.imprecise* %agg.result, i32 0, i32 1
  store double %div18, double* %delta19, align 8
  ret void
}

; Function Attrs: noinline nounwind optnone
define hidden void @imprecise_pow(%struct.imprecise* noalias sret align 8 %agg.result, %struct.imprecise* byval(%struct.imprecise) align 8 %a, double %c) #0 {
entry:
  %c.addr = alloca double, align 8
  store double %c, double* %c.addr, align 8
  %value = getelementptr inbounds %struct.imprecise, %struct.imprecise* %a, i32 0, i32 0
  %0 = load double, double* %value, align 8
  %1 = load double, double* %c.addr, align 8
  %2 = call double @llvm.pow.f64(double %0, double %1)
  %value1 = getelementptr inbounds %struct.imprecise, %struct.imprecise* %agg.result, i32 0, i32 0
  store double %2, double* %value1, align 8
  %value2 = getelementptr inbounds %struct.imprecise, %struct.imprecise* %agg.result, i32 0, i32 0
  %3 = load double, double* %value2, align 8
  %4 = load double, double* %c.addr, align 8
  %mul = fmul double %3, %4
  %delta = getelementptr inbounds %struct.imprecise, %struct.imprecise* %a, i32 0, i32 1
  %5 = load double, double* %delta, align 8
  %mul3 = fmul double %mul, %5
  %value4 = getelementptr inbounds %struct.imprecise, %struct.imprecise* %a, i32 0, i32 0
  %6 = load double, double* %value4, align 8
  %div = fdiv double %mul3, %6
  %7 = call double @llvm.fabs.f64(double %div)
  %delta5 = getelementptr inbounds %struct.imprecise, %struct.imprecise* %agg.result, i32 0, i32 1
  store double %7, double* %delta5, align 8
  ret void
}

; Function Attrs: nounwind readnone speculatable willreturn
declare double @llvm.pow.f64(double %0, double %1) #1

; Function Attrs: nounwind readnone speculatable willreturn
declare double @llvm.fabs.f64(double %0) #1

; Function Attrs: noinline nounwind optnone
define hidden i8* @printImprecise(%struct.imprecise* byval(%struct.imprecise) align 8 %val) #0 {
entry:
  %principal = alloca [30 x i8], align 16
  %error = alloca [30 x i8], align 16
  %string = alloca i8*, align 4
  %sign = alloca [2 x i8], align 1
  %arrayidx = getelementptr inbounds [2 x i8], [2 x i8]* %sign, i32 0, i32 0
  store i8 -15, i8* %arrayidx, align 1
  %arrayidx1 = getelementptr inbounds [2 x i8], [2 x i8]* %sign, i32 0, i32 1
  store i8 0, i8* %arrayidx1, align 1
  %arraydecay = getelementptr inbounds [30 x i8], [30 x i8]* %principal, i32 0, i32 0
  %value = getelementptr inbounds %struct.imprecise, %struct.imprecise* %val, i32 0, i32 0
  %0 = load double, double* %value, align 8
  %call = call i32 (i8*, i8*, ...) @sprintf(i8* %arraydecay, i8* getelementptr inbounds ([3 x i8], [3 x i8]* @.str, i32 0, i32 0), double %0)
  %arraydecay2 = getelementptr inbounds [30 x i8], [30 x i8]* %error, i32 0, i32 0
  %delta = getelementptr inbounds %struct.imprecise, %struct.imprecise* %val, i32 0, i32 1
  %1 = load double, double* %delta, align 8
  %call3 = call i32 (i8*, i8*, ...) @sprintf(i8* %arraydecay2, i8* getelementptr inbounds ([3 x i8], [3 x i8]* @.str, i32 0, i32 0), double %1)
  %arraydecay4 = getelementptr inbounds [30 x i8], [30 x i8]* %principal, i32 0, i32 0
  %call5 = call i32 @strlen(i8* %arraydecay4) #5
  %add = add i32 %call5, 1
  %arraydecay6 = getelementptr inbounds [30 x i8], [30 x i8]* %error, i32 0, i32 0
  %call7 = call i32 @strlen(i8* %arraydecay6) #5
  %add8 = add i32 %add, %call7
  %add9 = add i32 %add8, 1
  %call10 = call noalias i8* @malloc(i32 %add9)
  store i8* %call10, i8** %string, align 4
  %2 = load i8*, i8** %string, align 4
  %arraydecay11 = getelementptr inbounds [30 x i8], [30 x i8]* %principal, i32 0, i32 0
  %call12 = call i8* @strcpy(i8* %2, i8* %arraydecay11)
  %3 = load i8*, i8** %string, align 4
  %arraydecay13 = getelementptr inbounds [2 x i8], [2 x i8]* %sign, i32 0, i32 0
  %call14 = call i8* @strcat(i8* %3, i8* %arraydecay13)
  %4 = load i8*, i8** %string, align 4
  %arraydecay15 = getelementptr inbounds [30 x i8], [30 x i8]* %error, i32 0, i32 0
  %call16 = call i8* @strcat(i8* %4, i8* %arraydecay15)
  %5 = load i8*, i8** %string, align 4
  ret i8* %5
}

declare i32 @sprintf(i8* %0, i8* %1, ...) #2

declare noalias i8* @malloc(i32 %0) #2

; Function Attrs: nounwind readonly
declare i32 @strlen(i8* %0) #3

declare i8* @strcpy(i8* %0, i8* %1) #2

declare i8* @strcat(i8* %0, i8* %1) #2

; Function Attrs: noinline nounwind optnone
define hidden i32 @main() #0 {
entry:
  %retval = alloca i32, align 4
  %x1 = alloca %struct.imprecise, align 8
  %y1 = alloca %struct.imprecise, align 8
  %x2 = alloca %struct.imprecise, align 8
  %y2 = alloca %struct.imprecise, align 8
  %d = alloca %struct.imprecise, align 8
  %tmp = alloca %struct.imprecise, align 8
  %agg.tmp = alloca %struct.imprecise, align 8
  %agg.tmp1 = alloca %struct.imprecise, align 8
  %agg.tmp2 = alloca %struct.imprecise, align 8
  %agg.tmp3 = alloca %struct.imprecise, align 8
  %agg.tmp4 = alloca %struct.imprecise, align 8
  store i32 0, i32* %retval, align 4
  %0 = bitcast %struct.imprecise* %x1 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 8 %0, i8* align 8 bitcast (%struct.imprecise* @__const.main.x1 to i8*), i32 16, i1 false)
  %1 = bitcast %struct.imprecise* %y1 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 8 %1, i8* align 8 bitcast (%struct.imprecise* @__const.main.y1 to i8*), i32 16, i1 false)
  %2 = bitcast %struct.imprecise* %x2 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 8 %2, i8* align 8 bitcast (%struct.imprecise* @__const.main.x2 to i8*), i32 16, i1 false)
  %3 = bitcast %struct.imprecise* %y2 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 8 %3, i8* align 8 bitcast (%struct.imprecise* @__const.main.y2 to i8*), i32 16, i1 false)
  call void @imprecise_add(%struct.imprecise* sret align 8 %agg.tmp2, %struct.imprecise* byval(%struct.imprecise) align 8 %x1, %struct.imprecise* byval(%struct.imprecise) align 8 %x2)
  call void @imprecise_pow(%struct.imprecise* sret align 8 %agg.tmp1, %struct.imprecise* byval(%struct.imprecise) align 8 %agg.tmp2, double 2.000000e+00)
  call void @imprecise_add(%struct.imprecise* sret align 8 %agg.tmp4, %struct.imprecise* byval(%struct.imprecise) align 8 %y1, %struct.imprecise* byval(%struct.imprecise) align 8 %y2)
  call void @imprecise_pow(%struct.imprecise* sret align 8 %agg.tmp3, %struct.imprecise* byval(%struct.imprecise) align 8 %agg.tmp4, double 2.000000e+00)
  call void @imprecise_add(%struct.imprecise* sret align 8 %agg.tmp, %struct.imprecise* byval(%struct.imprecise) align 8 %agg.tmp1, %struct.imprecise* byval(%struct.imprecise) align 8 %agg.tmp3)
  call void @imprecise_pow(%struct.imprecise* sret align 8 %tmp, %struct.imprecise* byval(%struct.imprecise) align 8 %agg.tmp, double 5.000000e-01)
  %4 = bitcast %struct.imprecise* %d to i8*
  %5 = bitcast %struct.imprecise* %tmp to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 8 %4, i8* align 8 %5, i32 16, i1 false)
  %call = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([44 x i8], [44 x i8]* @.str.1, i32 0, i32 0))
  %call5 = call i8* @printImprecise(%struct.imprecise* byval(%struct.imprecise) align 8 %x1)
  %call6 = call i8* @printImprecise(%struct.imprecise* byval(%struct.imprecise) align 8 %y1)
  %call7 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([23 x i8], [23 x i8]* @.str.2, i32 0, i32 0), i8* %call5, i8* %call6)
  %call8 = call i8* @printImprecise(%struct.imprecise* byval(%struct.imprecise) align 8 %x2)
  %call9 = call i8* @printImprecise(%struct.imprecise* byval(%struct.imprecise) align 8 %y2)
  %call10 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([23 x i8], [23 x i8]* @.str.3, i32 0, i32 0), i8* %call8, i8* %call9)
  %call11 = call i8* @printImprecise(%struct.imprecise* byval(%struct.imprecise) align 8 %d)
  %call12 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([11 x i8], [11 x i8]* @.str.4, i32 0, i32 0), i8* %call11)
  ret i32 0
}

; Function Attrs: argmemonly nounwind willreturn
declare void @llvm.memcpy.p0i8.p0i8.i32(i8* noalias nocapture writeonly %0, i8* noalias nocapture readonly %1, i32 %2, i1 immarg %3) #4

declare i32 @printf(i8* %0, ...) #2

attributes #0 = { noinline nounwind optnone "correctly-rounded-divide-sqrt-fp-math"="false" "disable-tail-calls"="false" "frame-pointer"="none" "less-precise-fpmad"="false" "min-legal-vector-width"="0" "no-infs-fp-math"="false" "no-jump-tables"="false" "no-nans-fp-math"="false" "no-signed-zeros-fp-math"="false" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="generic" "unsafe-fp-math"="false" "use-soft-float"="false" }
attributes #1 = { nounwind readnone speculatable willreturn }
attributes #2 = { "correctly-rounded-divide-sqrt-fp-math"="false" "disable-tail-calls"="false" "frame-pointer"="none" "less-precise-fpmad"="false" "no-infs-fp-math"="false" "no-nans-fp-math"="false" "no-signed-zeros-fp-math"="false" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="generic" "unsafe-fp-math"="false" "use-soft-float"="false" }
attributes #3 = { nounwind readonly "correctly-rounded-divide-sqrt-fp-math"="false" "disable-tail-calls"="false" "frame-pointer"="none" "less-precise-fpmad"="false" "no-infs-fp-math"="false" "no-nans-fp-math"="false" "no-signed-zeros-fp-math"="false" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="generic" "unsafe-fp-math"="false" "use-soft-float"="false" }
attributes #4 = { argmemonly nounwind willreturn }
attributes #5 = { nounwind readonly }

!llvm.module.flags = !{!0}
!llvm.ident = !{!1}

!0 = !{i32 1, !"wchar_size", i32 4}
!1 = !{!"clang version 11.0.0 (https://github.com/Jacarte/llvm-project.git 0f6dea67136cc1e0b3d200eb2bb165628970c44b)"}

#########################################################
; exiting Souper's runOnFunction() for printImprecise()
rescanning function after transformation was applied

; entering Souper's runOnFunction() for printImprecise()

; ModuleID = './Numeric_error_propagation.c.bc'
source_filename = "./Numeric_error_propagation.c"
target datalayout = "e-m:e-p:32:32-i64:64-n32:64-S128"
target triple = "wasm32-unknown-wasi"

%struct.imprecise = type { double, double }

@.str = private unnamed_addr constant [3 x i8] c"%f\00", align 1
@__const.main.x1 = private unnamed_addr constant %struct.imprecise { double 1.000000e+02, double 1.100000e+00 }, align 8
@__const.main.y1 = private unnamed_addr constant %struct.imprecise { double 5.000000e+01, double 1.200000e+00 }, align 8
@__const.main.x2 = private unnamed_addr constant %struct.imprecise { double -2.000000e+02, double 2.200000e+00 }, align 8
@__const.main.y2 = private unnamed_addr constant %struct.imprecise { double -1.000000e+02, double 2.300000e+00 }, align 8
@.str.1 = private unnamed_addr constant [44 x i8] c"Distance, d, between the following points :\00", align 1
@.str.2 = private unnamed_addr constant [23 x i8] c"\0A( x1, y1) = ( %s, %s)\00", align 1
@.str.3 = private unnamed_addr constant [23 x i8] c"\0A( x2, y2) = ( %s, %s)\00", align 1
@.str.4 = private unnamed_addr constant [11 x i8] c"\0Ais d = %s\00", align 1
@llvm.used = appending global [1 x i8*] [i8* bitcast (i32 ()* @__main_void to i8*)], section "llvm.metadata"

@__main_void = alias i32 (), i32 ()* @main

; Function Attrs: noinline nounwind optnone
define hidden void @imprecise_add(%struct.imprecise* noalias sret align 8 %agg.result, %struct.imprecise* byval(%struct.imprecise) align 8 %a, %struct.imprecise* byval(%struct.imprecise) align 8 %b) #0 {
entry:
  %value = getelementptr inbounds %struct.imprecise, %struct.imprecise* %a, i32 0, i32 0
  %0 = load double, double* %value, align 8
  %value1 = getelementptr inbounds %struct.imprecise, %struct.imprecise* %b, i32 0, i32 0
  %1 = load double, double* %value1, align 8
  %add = fadd double %0, %1
  %value2 = getelementptr inbounds %struct.imprecise, %struct.imprecise* %agg.result, i32 0, i32 0
  store double %add, double* %value2, align 8
  %delta = getelementptr inbounds %struct.imprecise, %struct.imprecise* %a, i32 0, i32 1
  %2 = load double, double* %delta, align 8
  %delta3 = getelementptr inbounds %struct.imprecise, %struct.imprecise* %a, i32 0, i32 1
  %3 = load double, double* %delta3, align 8
  %mul = fmul double %2, %3
  %delta4 = getelementptr inbounds %struct.imprecise, %struct.imprecise* %b, i32 0, i32 1
  %4 = load double, double* %delta4, align 8
  %delta5 = getelementptr inbounds %struct.imprecise, %struct.imprecise* %b, i32 0, i32 1
  %5 = load double, double* %delta5, align 8
  %mul6 = fmul double %4, %5
  %add7 = fadd double %mul, %mul6
  %6 = call double @llvm.sqrt.f64(double %add7)
  %delta8 = getelementptr inbounds %struct.imprecise, %struct.imprecise* %agg.result, i32 0, i32 1
  store double %6, double* %delta8, align 8
  ret void
}

; Function Attrs: nounwind readnone speculatable willreturn
declare double @llvm.sqrt.f64(double %0) #1

; Function Attrs: noinline nounwind optnone
define hidden void @imprecise_mul(%struct.imprecise* noalias sret align 8 %agg.result, %struct.imprecise* byval(%struct.imprecise) align 8 %a, %struct.imprecise* byval(%struct.imprecise) align 8 %b) #0 {
entry:
  %value = getelementptr inbounds %struct.imprecise, %struct.imprecise* %a, i32 0, i32 0
  %0 = load double, double* %value, align 8
  %value1 = getelementptr inbounds %struct.imprecise, %struct.imprecise* %b, i32 0, i32 0
  %1 = load double, double* %value1, align 8
  %mul = fmul double %0, %1
  %value2 = getelementptr inbounds %struct.imprecise, %struct.imprecise* %agg.result, i32 0, i32 0
  store double %mul, double* %value2, align 8
  %value3 = getelementptr inbounds %struct.imprecise, %struct.imprecise* %a, i32 0, i32 0
  %2 = load double, double* %value3, align 8
  %delta = getelementptr inbounds %struct.imprecise, %struct.imprecise* %b, i32 0, i32 1
  %3 = load double, double* %delta, align 8
  %mul4 = fmul double %2, %3
  %value5 = getelementptr inbounds %struct.imprecise, %struct.imprecise* %a, i32 0, i32 0
  %4 = load double, double* %value5, align 8
  %delta6 = getelementptr inbounds %struct.imprecise, %struct.imprecise* %b, i32 0, i32 1
  %5 = load double, double* %delta6, align 8
  %mul7 = fmul double %4, %5
  %mul8 = fmul double %mul4, %mul7
  %value9 = getelementptr inbounds %struct.imprecise, %struct.imprecise* %b, i32 0, i32 0
  %6 = load double, double* %value9, align 8
  %delta10 = getelementptr inbounds %struct.imprecise, %struct.imprecise* %a, i32 0, i32 1
  %7 = load double, double* %delta10, align 8
  %mul11 = fmul double %6, %7
  %value12 = getelementptr inbounds %struct.imprecise, %struct.imprecise* %b, i32 0, i32 0
  %8 = load double, double* %value12, align 8
  %delta13 = getelementptr inbounds %struct.imprecise, %struct.imprecise* %a, i32 0, i32 1
  %9 = load double, double* %delta13, align 8
  %mul14 = fmul double %8, %9
  %mul15 = fmul double %mul11, %mul14
  %add = fadd double %mul8, %mul15
  %10 = call double @llvm.sqrt.f64(double %add)
  %delta16 = getelementptr inbounds %struct.imprecise, %struct.imprecise* %agg.result, i32 0, i32 1
  store double %10, double* %delta16, align 8
  ret void
}

; Function Attrs: noinline nounwind optnone
define hidden void @imprecise_div(%struct.imprecise* noalias sret align 8 %agg.result, %struct.imprecise* byval(%struct.imprecise) align 8 %a, %struct.imprecise* byval(%struct.imprecise) align 8 %b) #0 {
entry:
  %value = getelementptr inbounds %struct.imprecise, %struct.imprecise* %a, i32 0, i32 0
  %0 = load double, double* %value, align 8
  %value1 = getelementptr inbounds %struct.imprecise, %struct.imprecise* %b, i32 0, i32 0
  %1 = load double, double* %value1, align 8
  %div = fdiv double %0, %1
  %value2 = getelementptr inbounds %struct.imprecise, %struct.imprecise* %agg.result, i32 0, i32 0
  store double %div, double* %value2, align 8
  %value3 = getelementptr inbounds %struct.imprecise, %struct.imprecise* %a, i32 0, i32 0
  %2 = load double, double* %value3, align 8
  %delta = getelementptr inbounds %struct.imprecise, %struct.imprecise* %b, i32 0, i32 1
  %3 = load double, double* %delta, align 8
  %mul = fmul double %2, %3
  %value4 = getelementptr inbounds %struct.imprecise, %struct.imprecise* %a, i32 0, i32 0
  %4 = load double, double* %value4, align 8
  %delta5 = getelementptr inbounds %struct.imprecise, %struct.imprecise* %b, i32 0, i32 1
  %5 = load double, double* %delta5, align 8
  %mul6 = fmul double %4, %5
  %mul7 = fmul double %mul, %mul6
  %value8 = getelementptr inbounds %struct.imprecise, %struct.imprecise* %b, i32 0, i32 0
  %6 = load double, double* %value8, align 8
  %delta9 = getelementptr inbounds %struct.imprecise, %struct.imprecise* %a, i32 0, i32 1
  %7 = load double, double* %delta9, align 8
  %mul10 = fmul double %6, %7
  %value11 = getelementptr inbounds %struct.imprecise, %struct.imprecise* %b, i32 0, i32 0
  %8 = load double, double* %value11, align 8
  %delta12 = getelementptr inbounds %struct.imprecise, %struct.imprecise* %a, i32 0, i32 1
  %9 = load double, double* %delta12, align 8
  %mul13 = fmul double %8, %9
  %mul14 = fmul double %mul10, %mul13
  %add = fadd double %mul7, %mul14
  %10 = call double @llvm.sqrt.f64(double %add)
  %value15 = getelementptr inbounds %struct.imprecise, %struct.imprecise* %b, i32 0, i32 0
  %11 = load double, double* %value15, align 8
  %value16 = getelementptr inbounds %struct.imprecise, %struct.imprecise* %b, i32 0, i32 0
  %12 = load double, double* %value16, align 8
  %mul17 = fmul double %11, %12
  %div18 = fdiv double %10, %mul17
  %delta19 = getelementptr inbounds %struct.imprecise, %struct.imprecise* %agg.result, i32 0, i32 1
  store double %div18, double* %delta19, align 8
  ret void
}

; Function Attrs: noinline nounwind optnone
define hidden void @imprecise_pow(%struct.imprecise* noalias sret align 8 %agg.result, %struct.imprecise* byval(%struct.imprecise) align 8 %a, double %c) #0 {
entry:
  %c.addr = alloca double, align 8
  store double %c, double* %c.addr, align 8
  %value = getelementptr inbounds %struct.imprecise, %struct.imprecise* %a, i32 0, i32 0
  %0 = load double, double* %value, align 8
  %1 = load double, double* %c.addr, align 8
  %2 = call double @llvm.pow.f64(double %0, double %1)
  %value1 = getelementptr inbounds %struct.imprecise, %struct.imprecise* %agg.result, i32 0, i32 0
  store double %2, double* %value1, align 8
  %value2 = getelementptr inbounds %struct.imprecise, %struct.imprecise* %agg.result, i32 0, i32 0
  %3 = load double, double* %value2, align 8
  %4 = load double, double* %c.addr, align 8
  %mul = fmul double %3, %4
  %delta = getelementptr inbounds %struct.imprecise, %struct.imprecise* %a, i32 0, i32 1
  %5 = load double, double* %delta, align 8
  %mul3 = fmul double %mul, %5
  %value4 = getelementptr inbounds %struct.imprecise, %struct.imprecise* %a, i32 0, i32 0
  %6 = load double, double* %value4, align 8
  %div = fdiv double %mul3, %6
  %7 = call double @llvm.fabs.f64(double %div)
  %delta5 = getelementptr inbounds %struct.imprecise, %struct.imprecise* %agg.result, i32 0, i32 1
  store double %7, double* %delta5, align 8
  ret void
}

; Function Attrs: nounwind readnone speculatable willreturn
declare double @llvm.pow.f64(double %0, double %1) #1

; Function Attrs: nounwind readnone speculatable willreturn
declare double @llvm.fabs.f64(double %0) #1

; Function Attrs: noinline nounwind optnone
define hidden i8* @printImprecise(%struct.imprecise* byval(%struct.imprecise) align 8 %val) #0 {
entry:
  %principal = alloca [30 x i8], align 16
  %error = alloca [30 x i8], align 16
  %string = alloca i8*, align 4
  %sign = alloca [2 x i8], align 1
  %arrayidx = getelementptr inbounds [2 x i8], [2 x i8]* %sign, i32 0, i32 0
  store i8 -15, i8* %arrayidx, align 1
  %arrayidx1 = getelementptr inbounds [2 x i8], [2 x i8]* %sign, i32 0, i32 1
  store i8 0, i8* %arrayidx1, align 1
  %arraydecay = getelementptr inbounds [30 x i8], [30 x i8]* %principal, i32 0, i32 0
  %value = getelementptr inbounds %struct.imprecise, %struct.imprecise* %val, i32 0, i32 0
  %0 = load double, double* %value, align 8
  %call = call i32 (i8*, i8*, ...) @sprintf(i8* %arraydecay, i8* getelementptr inbounds ([3 x i8], [3 x i8]* @.str, i32 0, i32 0), double %0)
  %arraydecay2 = getelementptr inbounds [30 x i8], [30 x i8]* %error, i32 0, i32 0
  %delta = getelementptr inbounds %struct.imprecise, %struct.imprecise* %val, i32 0, i32 1
  %1 = load double, double* %delta, align 8
  %call3 = call i32 (i8*, i8*, ...) @sprintf(i8* %arraydecay2, i8* getelementptr inbounds ([3 x i8], [3 x i8]* @.str, i32 0, i32 0), double %1)
  %arraydecay4 = getelementptr inbounds [30 x i8], [30 x i8]* %principal, i32 0, i32 0
  %call5 = call i32 @strlen(i8* %arraydecay4) #5
  %add = add i32 %call5, 1
  %arraydecay6 = getelementptr inbounds [30 x i8], [30 x i8]* %error, i32 0, i32 0
  %call7 = call i32 @strlen(i8* %arraydecay6) #5
  %add8 = add i32 %add, %call7
  %add9 = add i32 %add8, 1
  %call10 = call noalias i8* @malloc(i32 %add9)
  store i8* %call10, i8** %string, align 4
  %2 = load i8*, i8** %string, align 4
  %arraydecay11 = getelementptr inbounds [30 x i8], [30 x i8]* %principal, i32 0, i32 0
  %call12 = call i8* @strcpy(i8* %2, i8* %arraydecay11)
  %3 = load i8*, i8** %string, align 4
  %arraydecay13 = getelementptr inbounds [2 x i8], [2 x i8]* %sign, i32 0, i32 0
  %call14 = call i8* @strcat(i8* %3, i8* %arraydecay13)
  %4 = load i8*, i8** %string, align 4
  %arraydecay15 = getelementptr inbounds [30 x i8], [30 x i8]* %error, i32 0, i32 0
  %call16 = call i8* @strcat(i8* %4, i8* %arraydecay15)
  %5 = load i8*, i8** %string, align 4
  ret i8* %5
}

declare i32 @sprintf(i8* %0, i8* %1, ...) #2

declare noalias i8* @malloc(i32 %0) #2

; Function Attrs: nounwind readonly
declare i32 @strlen(i8* %0) #3

declare i8* @strcpy(i8* %0, i8* %1) #2

declare i8* @strcat(i8* %0, i8* %1) #2

; Function Attrs: noinline nounwind optnone
define hidden i32 @main() #0 {
entry:
  %retval = alloca i32, align 4
  %x1 = alloca %struct.imprecise, align 8
  %y1 = alloca %struct.imprecise, align 8
  %x2 = alloca %struct.imprecise, align 8
  %y2 = alloca %struct.imprecise, align 8
  %d = alloca %struct.imprecise, align 8
  %tmp = alloca %struct.imprecise, align 8
  %agg.tmp = alloca %struct.imprecise, align 8
  %agg.tmp1 = alloca %struct.imprecise, align 8
  %agg.tmp2 = alloca %struct.imprecise, align 8
  %agg.tmp3 = alloca %struct.imprecise, align 8
  %agg.tmp4 = alloca %struct.imprecise, align 8
  store i32 0, i32* %retval, align 4
  %0 = bitcast %struct.imprecise* %x1 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 8 %0, i8* align 8 bitcast (%struct.imprecise* @__const.main.x1 to i8*), i32 16, i1 false)
  %1 = bitcast %struct.imprecise* %y1 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 8 %1, i8* align 8 bitcast (%struct.imprecise* @__const.main.y1 to i8*), i32 16, i1 false)
  %2 = bitcast %struct.imprecise* %x2 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 8 %2, i8* align 8 bitcast (%struct.imprecise* @__const.main.x2 to i8*), i32 16, i1 false)
  %3 = bitcast %struct.imprecise* %y2 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 8 %3, i8* align 8 bitcast (%struct.imprecise* @__const.main.y2 to i8*), i32 16, i1 false)
  call void @imprecise_add(%struct.imprecise* sret align 8 %agg.tmp2, %struct.imprecise* byval(%struct.imprecise) align 8 %x1, %struct.imprecise* byval(%struct.imprecise) align 8 %x2)
  call void @imprecise_pow(%struct.imprecise* sret align 8 %agg.tmp1, %struct.imprecise* byval(%struct.imprecise) align 8 %agg.tmp2, double 2.000000e+00)
  call void @imprecise_add(%struct.imprecise* sret align 8 %agg.tmp4, %struct.imprecise* byval(%struct.imprecise) align 8 %y1, %struct.imprecise* byval(%struct.imprecise) align 8 %y2)
  call void @imprecise_pow(%struct.imprecise* sret align 8 %agg.tmp3, %struct.imprecise* byval(%struct.imprecise) align 8 %agg.tmp4, double 2.000000e+00)
  call void @imprecise_add(%struct.imprecise* sret align 8 %agg.tmp, %struct.imprecise* byval(%struct.imprecise) align 8 %agg.tmp1, %struct.imprecise* byval(%struct.imprecise) align 8 %agg.tmp3)
  call void @imprecise_pow(%struct.imprecise* sret align 8 %tmp, %struct.imprecise* byval(%struct.imprecise) align 8 %agg.tmp, double 5.000000e-01)
  %4 = bitcast %struct.imprecise* %d to i8*
  %5 = bitcast %struct.imprecise* %tmp to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 8 %4, i8* align 8 %5, i32 16, i1 false)
  %call = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([44 x i8], [44 x i8]* @.str.1, i32 0, i32 0))
  %call5 = call i8* @printImprecise(%struct.imprecise* byval(%struct.imprecise) align 8 %x1)
  %call6 = call i8* @printImprecise(%struct.imprecise* byval(%struct.imprecise) align 8 %y1)
  %call7 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([23 x i8], [23 x i8]* @.str.2, i32 0, i32 0), i8* %call5, i8* %call6)
  %call8 = call i8* @printImprecise(%struct.imprecise* byval(%struct.imprecise) align 8 %x2)
  %call9 = call i8* @printImprecise(%struct.imprecise* byval(%struct.imprecise) align 8 %y2)
  %call10 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([23 x i8], [23 x i8]* @.str.3, i32 0, i32 0), i8* %call8, i8* %call9)
  %call11 = call i8* @printImprecise(%struct.imprecise* byval(%struct.imprecise) align 8 %d)
  %call12 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([11 x i8], [11 x i8]* @.str.4, i32 0, i32 0), i8* %call11)
  ret i32 0
}

; Function Attrs: argmemonly nounwind willreturn
declare void @llvm.memcpy.p0i8.p0i8.i32(i8* noalias nocapture writeonly %0, i8* noalias nocapture readonly %1, i32 %2, i1 immarg %3) #4

declare i32 @printf(i8* %0, ...) #2

attributes #0 = { noinline nounwind optnone "correctly-rounded-divide-sqrt-fp-math"="false" "disable-tail-calls"="false" "frame-pointer"="none" "less-precise-fpmad"="false" "min-legal-vector-width"="0" "no-infs-fp-math"="false" "no-jump-tables"="false" "no-nans-fp-math"="false" "no-signed-zeros-fp-math"="false" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="generic" "unsafe-fp-math"="false" "use-soft-float"="false" }
attributes #1 = { nounwind readnone speculatable willreturn }
attributes #2 = { "correctly-rounded-divide-sqrt-fp-math"="false" "disable-tail-calls"="false" "frame-pointer"="none" "less-precise-fpmad"="false" "no-infs-fp-math"="false" "no-nans-fp-math"="false" "no-signed-zeros-fp-math"="false" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="generic" "unsafe-fp-math"="false" "use-soft-float"="false" }
attributes #3 = { nounwind readonly "correctly-rounded-divide-sqrt-fp-math"="false" "disable-tail-calls"="false" "frame-pointer"="none" "less-precise-fpmad"="false" "no-infs-fp-math"="false" "no-nans-fp-math"="false" "no-signed-zeros-fp-math"="false" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="generic" "unsafe-fp-math"="false" "use-soft-float"="false" }
attributes #4 = { argmemonly nounwind willreturn }
attributes #5 = { nounwind readonly }

!llvm.module.flags = !{!0}
!llvm.ident = !{!1}

!0 = !{i32 1, !"wchar_size", i32 4}
!1 = !{!"clang version 11.0.0 (https://github.com/Jacarte/llvm-project.git 0f6dea67136cc1e0b3d200eb2bb165628970c44b)"}

; extracted candidates

; *****
; For LLVM instruction:
;  %call5 = call i32 @strlen(i8* %arraydecay4) #5
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %add = add i32 %call5, 1
; Looking for a replacement for:
%0:i32 = var
%1:i32 = add 1:i32, %0
infer %1

; *****
; For LLVM instruction:
;  %call7 = call i32 @strlen(i8* %arraydecay6) #5
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %add8 = add i32 %add, %call7
; Looking for a replacement for:
%0:i32 = var
%1:i32 = var
%2:i32 = add 1:i32, %1
%3:i32 = add %0, %2
infer %3

; *****
; For LLVM instruction:
;  %add9 = add i32 %add8, 1
; Looking for a replacement for:
%0:i32 = var
%1:i32 = var
%2:i32 = add 1:i32, %1
%3:i32 = add %0, %2
%4:i32 = add 1:i32, %3
infer %4
#########################################################
; exiting Souper's runOnFunction() for printImprecise()

; entering Souper's runOnFunction() for main()

; ModuleID = './Numeric_error_propagation.c.bc'
source_filename = "./Numeric_error_propagation.c"
target datalayout = "e-m:e-p:32:32-i64:64-n32:64-S128"
target triple = "wasm32-unknown-wasi"

%struct.imprecise = type { double, double }

@.str = private unnamed_addr constant [3 x i8] c"%f\00", align 1
@__const.main.x1 = private unnamed_addr constant %struct.imprecise { double 1.000000e+02, double 1.100000e+00 }, align 8
@__const.main.y1 = private unnamed_addr constant %struct.imprecise { double 5.000000e+01, double 1.200000e+00 }, align 8
@__const.main.x2 = private unnamed_addr constant %struct.imprecise { double -2.000000e+02, double 2.200000e+00 }, align 8
@__const.main.y2 = private unnamed_addr constant %struct.imprecise { double -1.000000e+02, double 2.300000e+00 }, align 8
@.str.1 = private unnamed_addr constant [44 x i8] c"Distance, d, between the following points :\00", align 1
@.str.2 = private unnamed_addr constant [23 x i8] c"\0A( x1, y1) = ( %s, %s)\00", align 1
@.str.3 = private unnamed_addr constant [23 x i8] c"\0A( x2, y2) = ( %s, %s)\00", align 1
@.str.4 = private unnamed_addr constant [11 x i8] c"\0Ais d = %s\00", align 1
@llvm.used = appending global [1 x i8*] [i8* bitcast (i32 ()* @__main_void to i8*)], section "llvm.metadata"

@__main_void = alias i32 (), i32 ()* @main

; Function Attrs: noinline nounwind optnone
define hidden void @imprecise_add(%struct.imprecise* noalias sret align 8 %agg.result, %struct.imprecise* byval(%struct.imprecise) align 8 %a, %struct.imprecise* byval(%struct.imprecise) align 8 %b) #0 {
entry:
  %value = getelementptr inbounds %struct.imprecise, %struct.imprecise* %a, i32 0, i32 0
  %0 = load double, double* %value, align 8
  %value1 = getelementptr inbounds %struct.imprecise, %struct.imprecise* %b, i32 0, i32 0
  %1 = load double, double* %value1, align 8
  %add = fadd double %0, %1
  %value2 = getelementptr inbounds %struct.imprecise, %struct.imprecise* %agg.result, i32 0, i32 0
  store double %add, double* %value2, align 8
  %delta = getelementptr inbounds %struct.imprecise, %struct.imprecise* %a, i32 0, i32 1
  %2 = load double, double* %delta, align 8
  %delta3 = getelementptr inbounds %struct.imprecise, %struct.imprecise* %a, i32 0, i32 1
  %3 = load double, double* %delta3, align 8
  %mul = fmul double %2, %3
  %delta4 = getelementptr inbounds %struct.imprecise, %struct.imprecise* %b, i32 0, i32 1
  %4 = load double, double* %delta4, align 8
  %delta5 = getelementptr inbounds %struct.imprecise, %struct.imprecise* %b, i32 0, i32 1
  %5 = load double, double* %delta5, align 8
  %mul6 = fmul double %4, %5
  %add7 = fadd double %mul, %mul6
  %6 = call double @llvm.sqrt.f64(double %add7)
  %delta8 = getelementptr inbounds %struct.imprecise, %struct.imprecise* %agg.result, i32 0, i32 1
  store double %6, double* %delta8, align 8
  ret void
}

; Function Attrs: nounwind readnone speculatable willreturn
declare double @llvm.sqrt.f64(double %0) #1

; Function Attrs: noinline nounwind optnone
define hidden void @imprecise_mul(%struct.imprecise* noalias sret align 8 %agg.result, %struct.imprecise* byval(%struct.imprecise) align 8 %a, %struct.imprecise* byval(%struct.imprecise) align 8 %b) #0 {
entry:
  %value = getelementptr inbounds %struct.imprecise, %struct.imprecise* %a, i32 0, i32 0
  %0 = load double, double* %value, align 8
  %value1 = getelementptr inbounds %struct.imprecise, %struct.imprecise* %b, i32 0, i32 0
  %1 = load double, double* %value1, align 8
  %mul = fmul double %0, %1
  %value2 = getelementptr inbounds %struct.imprecise, %struct.imprecise* %agg.result, i32 0, i32 0
  store double %mul, double* %value2, align 8
  %value3 = getelementptr inbounds %struct.imprecise, %struct.imprecise* %a, i32 0, i32 0
  %2 = load double, double* %value3, align 8
  %delta = getelementptr inbounds %struct.imprecise, %struct.imprecise* %b, i32 0, i32 1
  %3 = load double, double* %delta, align 8
  %mul4 = fmul double %2, %3
  %value5 = getelementptr inbounds %struct.imprecise, %struct.imprecise* %a, i32 0, i32 0
  %4 = load double, double* %value5, align 8
  %delta6 = getelementptr inbounds %struct.imprecise, %struct.imprecise* %b, i32 0, i32 1
  %5 = load double, double* %delta6, align 8
  %mul7 = fmul double %4, %5
  %mul8 = fmul double %mul4, %mul7
  %value9 = getelementptr inbounds %struct.imprecise, %struct.imprecise* %b, i32 0, i32 0
  %6 = load double, double* %value9, align 8
  %delta10 = getelementptr inbounds %struct.imprecise, %struct.imprecise* %a, i32 0, i32 1
  %7 = load double, double* %delta10, align 8
  %mul11 = fmul double %6, %7
  %value12 = getelementptr inbounds %struct.imprecise, %struct.imprecise* %b, i32 0, i32 0
  %8 = load double, double* %value12, align 8
  %delta13 = getelementptr inbounds %struct.imprecise, %struct.imprecise* %a, i32 0, i32 1
  %9 = load double, double* %delta13, align 8
  %mul14 = fmul double %8, %9
  %mul15 = fmul double %mul11, %mul14
  %add = fadd double %mul8, %mul15
  %10 = call double @llvm.sqrt.f64(double %add)
  %delta16 = getelementptr inbounds %struct.imprecise, %struct.imprecise* %agg.result, i32 0, i32 1
  store double %10, double* %delta16, align 8
  ret void
}

; Function Attrs: noinline nounwind optnone
define hidden void @imprecise_div(%struct.imprecise* noalias sret align 8 %agg.result, %struct.imprecise* byval(%struct.imprecise) align 8 %a, %struct.imprecise* byval(%struct.imprecise) align 8 %b) #0 {
entry:
  %value = getelementptr inbounds %struct.imprecise, %struct.imprecise* %a, i32 0, i32 0
  %0 = load double, double* %value, align 8
  %value1 = getelementptr inbounds %struct.imprecise, %struct.imprecise* %b, i32 0, i32 0
  %1 = load double, double* %value1, align 8
  %div = fdiv double %0, %1
  %value2 = getelementptr inbounds %struct.imprecise, %struct.imprecise* %agg.result, i32 0, i32 0
  store double %div, double* %value2, align 8
  %value3 = getelementptr inbounds %struct.imprecise, %struct.imprecise* %a, i32 0, i32 0
  %2 = load double, double* %value3, align 8
  %delta = getelementptr inbounds %struct.imprecise, %struct.imprecise* %b, i32 0, i32 1
  %3 = load double, double* %delta, align 8
  %mul = fmul double %2, %3
  %value4 = getelementptr inbounds %struct.imprecise, %struct.imprecise* %a, i32 0, i32 0
  %4 = load double, double* %value4, align 8
  %delta5 = getelementptr inbounds %struct.imprecise, %struct.imprecise* %b, i32 0, i32 1
  %5 = load double, double* %delta5, align 8
  %mul6 = fmul double %4, %5
  %mul7 = fmul double %mul, %mul6
  %value8 = getelementptr inbounds %struct.imprecise, %struct.imprecise* %b, i32 0, i32 0
  %6 = load double, double* %value8, align 8
  %delta9 = getelementptr inbounds %struct.imprecise, %struct.imprecise* %a, i32 0, i32 1
  %7 = load double, double* %delta9, align 8
  %mul10 = fmul double %6, %7
  %value11 = getelementptr inbounds %struct.imprecise, %struct.imprecise* %b, i32 0, i32 0
  %8 = load double, double* %value11, align 8
  %delta12 = getelementptr inbounds %struct.imprecise, %struct.imprecise* %a, i32 0, i32 1
  %9 = load double, double* %delta12, align 8
  %mul13 = fmul double %8, %9
  %mul14 = fmul double %mul10, %mul13
  %add = fadd double %mul7, %mul14
  %10 = call double @llvm.sqrt.f64(double %add)
  %value15 = getelementptr inbounds %struct.imprecise, %struct.imprecise* %b, i32 0, i32 0
  %11 = load double, double* %value15, align 8
  %value16 = getelementptr inbounds %struct.imprecise, %struct.imprecise* %b, i32 0, i32 0
  %12 = load double, double* %value16, align 8
  %mul17 = fmul double %11, %12
  %div18 = fdiv double %10, %mul17
  %delta19 = getelementptr inbounds %struct.imprecise, %struct.imprecise* %agg.result, i32 0, i32 1
  store double %div18, double* %delta19, align 8
  ret void
}

; Function Attrs: noinline nounwind optnone
define hidden void @imprecise_pow(%struct.imprecise* noalias sret align 8 %agg.result, %struct.imprecise* byval(%struct.imprecise) align 8 %a, double %c) #0 {
entry:
  %c.addr = alloca double, align 8
  store double %c, double* %c.addr, align 8
  %value = getelementptr inbounds %struct.imprecise, %struct.imprecise* %a, i32 0, i32 0
  %0 = load double, double* %value, align 8
  %1 = load double, double* %c.addr, align 8
  %2 = call double @llvm.pow.f64(double %0, double %1)
  %value1 = getelementptr inbounds %struct.imprecise, %struct.imprecise* %agg.result, i32 0, i32 0
  store double %2, double* %value1, align 8
  %value2 = getelementptr inbounds %struct.imprecise, %struct.imprecise* %agg.result, i32 0, i32 0
  %3 = load double, double* %value2, align 8
  %4 = load double, double* %c.addr, align 8
  %mul = fmul double %3, %4
  %delta = getelementptr inbounds %struct.imprecise, %struct.imprecise* %a, i32 0, i32 1
  %5 = load double, double* %delta, align 8
  %mul3 = fmul double %mul, %5
  %value4 = getelementptr inbounds %struct.imprecise, %struct.imprecise* %a, i32 0, i32 0
  %6 = load double, double* %value4, align 8
  %div = fdiv double %mul3, %6
  %7 = call double @llvm.fabs.f64(double %div)
  %delta5 = getelementptr inbounds %struct.imprecise, %struct.imprecise* %agg.result, i32 0, i32 1
  store double %7, double* %delta5, align 8
  ret void
}

; Function Attrs: nounwind readnone speculatable willreturn
declare double @llvm.pow.f64(double %0, double %1) #1

; Function Attrs: nounwind readnone speculatable willreturn
declare double @llvm.fabs.f64(double %0) #1

; Function Attrs: noinline nounwind optnone
define hidden i8* @printImprecise(%struct.imprecise* byval(%struct.imprecise) align 8 %val) #0 {
entry:
  %principal = alloca [30 x i8], align 16
  %error = alloca [30 x i8], align 16
  %string = alloca i8*, align 4
  %sign = alloca [2 x i8], align 1
  %arrayidx = getelementptr inbounds [2 x i8], [2 x i8]* %sign, i32 0, i32 0
  store i8 -15, i8* %arrayidx, align 1
  %arrayidx1 = getelementptr inbounds [2 x i8], [2 x i8]* %sign, i32 0, i32 1
  store i8 0, i8* %arrayidx1, align 1
  %arraydecay = getelementptr inbounds [30 x i8], [30 x i8]* %principal, i32 0, i32 0
  %value = getelementptr inbounds %struct.imprecise, %struct.imprecise* %val, i32 0, i32 0
  %0 = load double, double* %value, align 8
  %call = call i32 (i8*, i8*, ...) @sprintf(i8* %arraydecay, i8* getelementptr inbounds ([3 x i8], [3 x i8]* @.str, i32 0, i32 0), double %0)
  %arraydecay2 = getelementptr inbounds [30 x i8], [30 x i8]* %error, i32 0, i32 0
  %delta = getelementptr inbounds %struct.imprecise, %struct.imprecise* %val, i32 0, i32 1
  %1 = load double, double* %delta, align 8
  %call3 = call i32 (i8*, i8*, ...) @sprintf(i8* %arraydecay2, i8* getelementptr inbounds ([3 x i8], [3 x i8]* @.str, i32 0, i32 0), double %1)
  %arraydecay4 = getelementptr inbounds [30 x i8], [30 x i8]* %principal, i32 0, i32 0
  %call5 = call i32 @strlen(i8* %arraydecay4) #5
  %add = add i32 %call5, 1
  %arraydecay6 = getelementptr inbounds [30 x i8], [30 x i8]* %error, i32 0, i32 0
  %call7 = call i32 @strlen(i8* %arraydecay6) #5
  %add8 = add i32 %add, %call7
  %add9 = add i32 %add8, 1
  %call10 = call noalias i8* @malloc(i32 %add9)
  store i8* %call10, i8** %string, align 4
  %2 = load i8*, i8** %string, align 4
  %arraydecay11 = getelementptr inbounds [30 x i8], [30 x i8]* %principal, i32 0, i32 0
  %call12 = call i8* @strcpy(i8* %2, i8* %arraydecay11)
  %3 = load i8*, i8** %string, align 4
  %arraydecay13 = getelementptr inbounds [2 x i8], [2 x i8]* %sign, i32 0, i32 0
  %call14 = call i8* @strcat(i8* %3, i8* %arraydecay13)
  %4 = load i8*, i8** %string, align 4
  %arraydecay15 = getelementptr inbounds [30 x i8], [30 x i8]* %error, i32 0, i32 0
  %call16 = call i8* @strcat(i8* %4, i8* %arraydecay15)
  %5 = load i8*, i8** %string, align 4
  ret i8* %5
}

declare i32 @sprintf(i8* %0, i8* %1, ...) #2

declare noalias i8* @malloc(i32 %0) #2

; Function Attrs: nounwind readonly
declare i32 @strlen(i8* %0) #3

declare i8* @strcpy(i8* %0, i8* %1) #2

declare i8* @strcat(i8* %0, i8* %1) #2

; Function Attrs: noinline nounwind optnone
define hidden i32 @main() #0 {
entry:
  %retval = alloca i32, align 4
  %x1 = alloca %struct.imprecise, align 8
  %y1 = alloca %struct.imprecise, align 8
  %x2 = alloca %struct.imprecise, align 8
  %y2 = alloca %struct.imprecise, align 8
  %d = alloca %struct.imprecise, align 8
  %tmp = alloca %struct.imprecise, align 8
  %agg.tmp = alloca %struct.imprecise, align 8
  %agg.tmp1 = alloca %struct.imprecise, align 8
  %agg.tmp2 = alloca %struct.imprecise, align 8
  %agg.tmp3 = alloca %struct.imprecise, align 8
  %agg.tmp4 = alloca %struct.imprecise, align 8
  store i32 0, i32* %retval, align 4
  %0 = bitcast %struct.imprecise* %x1 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 8 %0, i8* align 8 bitcast (%struct.imprecise* @__const.main.x1 to i8*), i32 16, i1 false)
  %1 = bitcast %struct.imprecise* %y1 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 8 %1, i8* align 8 bitcast (%struct.imprecise* @__const.main.y1 to i8*), i32 16, i1 false)
  %2 = bitcast %struct.imprecise* %x2 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 8 %2, i8* align 8 bitcast (%struct.imprecise* @__const.main.x2 to i8*), i32 16, i1 false)
  %3 = bitcast %struct.imprecise* %y2 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 8 %3, i8* align 8 bitcast (%struct.imprecise* @__const.main.y2 to i8*), i32 16, i1 false)
  call void @imprecise_add(%struct.imprecise* sret align 8 %agg.tmp2, %struct.imprecise* byval(%struct.imprecise) align 8 %x1, %struct.imprecise* byval(%struct.imprecise) align 8 %x2)
  call void @imprecise_pow(%struct.imprecise* sret align 8 %agg.tmp1, %struct.imprecise* byval(%struct.imprecise) align 8 %agg.tmp2, double 2.000000e+00)
  call void @imprecise_add(%struct.imprecise* sret align 8 %agg.tmp4, %struct.imprecise* byval(%struct.imprecise) align 8 %y1, %struct.imprecise* byval(%struct.imprecise) align 8 %y2)
  call void @imprecise_pow(%struct.imprecise* sret align 8 %agg.tmp3, %struct.imprecise* byval(%struct.imprecise) align 8 %agg.tmp4, double 2.000000e+00)
  call void @imprecise_add(%struct.imprecise* sret align 8 %agg.tmp, %struct.imprecise* byval(%struct.imprecise) align 8 %agg.tmp1, %struct.imprecise* byval(%struct.imprecise) align 8 %agg.tmp3)
  call void @imprecise_pow(%struct.imprecise* sret align 8 %tmp, %struct.imprecise* byval(%struct.imprecise) align 8 %agg.tmp, double 5.000000e-01)
  %4 = bitcast %struct.imprecise* %d to i8*
  %5 = bitcast %struct.imprecise* %tmp to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 8 %4, i8* align 8 %5, i32 16, i1 false)
  %call = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([44 x i8], [44 x i8]* @.str.1, i32 0, i32 0))
  %call5 = call i8* @printImprecise(%struct.imprecise* byval(%struct.imprecise) align 8 %x1)
  %call6 = call i8* @printImprecise(%struct.imprecise* byval(%struct.imprecise) align 8 %y1)
  %call7 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([23 x i8], [23 x i8]* @.str.2, i32 0, i32 0), i8* %call5, i8* %call6)
  %call8 = call i8* @printImprecise(%struct.imprecise* byval(%struct.imprecise) align 8 %x2)
  %call9 = call i8* @printImprecise(%struct.imprecise* byval(%struct.imprecise) align 8 %y2)
  %call10 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([23 x i8], [23 x i8]* @.str.3, i32 0, i32 0), i8* %call8, i8* %call9)
  %call11 = call i8* @printImprecise(%struct.imprecise* byval(%struct.imprecise) align 8 %d)
  %call12 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([11 x i8], [11 x i8]* @.str.4, i32 0, i32 0), i8* %call11)
  ret i32 0
}

; Function Attrs: argmemonly nounwind willreturn
declare void @llvm.memcpy.p0i8.p0i8.i32(i8* noalias nocapture writeonly %0, i8* noalias nocapture readonly %1, i32 %2, i1 immarg %3) #4

declare i32 @printf(i8* %0, ...) #2

attributes #0 = { noinline nounwind optnone "correctly-rounded-divide-sqrt-fp-math"="false" "disable-tail-calls"="false" "frame-pointer"="none" "less-precise-fpmad"="false" "min-legal-vector-width"="0" "no-infs-fp-math"="false" "no-jump-tables"="false" "no-nans-fp-math"="false" "no-signed-zeros-fp-math"="false" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="generic" "unsafe-fp-math"="false" "use-soft-float"="false" }
attributes #1 = { nounwind readnone speculatable willreturn }
attributes #2 = { "correctly-rounded-divide-sqrt-fp-math"="false" "disable-tail-calls"="false" "frame-pointer"="none" "less-precise-fpmad"="false" "no-infs-fp-math"="false" "no-nans-fp-math"="false" "no-signed-zeros-fp-math"="false" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="generic" "unsafe-fp-math"="false" "use-soft-float"="false" }
attributes #3 = { nounwind readonly "correctly-rounded-divide-sqrt-fp-math"="false" "disable-tail-calls"="false" "frame-pointer"="none" "less-precise-fpmad"="false" "no-infs-fp-math"="false" "no-nans-fp-math"="false" "no-signed-zeros-fp-math"="false" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="generic" "unsafe-fp-math"="false" "use-soft-float"="false" }
attributes #4 = { argmemonly nounwind willreturn }
attributes #5 = { nounwind readonly }

!llvm.module.flags = !{!0}
!llvm.ident = !{!1}

!0 = !{i32 1, !"wchar_size", i32 4}
!1 = !{!"clang version 11.0.0 (https://github.com/Jacarte/llvm-project.git 0f6dea67136cc1e0b3d200eb2bb165628970c44b)"}

; extracted candidates
#########################################################
; exiting Souper's runOnFunction() for main()
Total of 1 replacements done on this module
Total of 1 replacements candidates on this module
