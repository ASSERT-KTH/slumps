
Entering the Souper pass's runOnModule()


; entering Souper's runOnFunction() for seq_len()

; ModuleID = './P-value_correction.c.bc'
source_filename = "./P-value_correction.c"
target datalayout = "e-m:e-p:32:32-i64:64-n32:64-S128"
target triple = "wasm32-unknown-wasi"

@.str = private unnamed_addr constant [29 x i8] c"malloc failed at %s line %u\0A\00", align 1
@.str.1 = private unnamed_addr constant [23 x i8] c"./P-value_correction.c\00", align 1
@.str.2 = private unnamed_addr constant [1 x i8] zeroinitializer, align 1
@base_arr = hidden global double* null, align 4
@.str.3 = private unnamed_addr constant [33 x i8] c"failed to malloc at %s line %u.\0A\00", align 1
@.str.4 = private unnamed_addr constant [48 x i8] c"cummin function requires at least one element.\0A\00", align 1
@.str.5 = private unnamed_addr constant [22 x i8] c"Failed at %s line %u\0A\00", align 1
@.str.6 = private unnamed_addr constant [41 x i8] c"function requires at least one element.\0A\00", align 1
@.str.7 = private unnamed_addr constant [37 x i8] c"pmin requires at least one element.\0A\00", align 1
@.str.8 = private unnamed_addr constant [7 x i8] c"[1] %e\00", align 1
@.str.9 = private unnamed_addr constant [7 x i8] c" %.10f\00", align 1
@.str.10 = private unnamed_addr constant [6 x i8] c"\0A[%u]\00", align 1
@.str.11 = private unnamed_addr constant [2 x i8] c"\0A\00", align 1
@.str.12 = private unnamed_addr constant [34 x i8] c"Failure to malloc at %s line %u.\0A\00", align 1
@.str.13 = private unnamed_addr constant [41 x i8] c"p_adjust requires at least one element.\0A\00", align 1
@.str.14 = private unnamed_addr constant [3 x i8] c"BH\00", align 1
@.str.15 = private unnamed_addr constant [4 x i8] c"fdr\00", align 1
@.str.16 = private unnamed_addr constant [3 x i8] c"by\00", align 1
@.str.17 = private unnamed_addr constant [11 x i8] c"Bonferroni\00", align 1
@.str.18 = private unnamed_addr constant [9 x i8] c"hochberg\00", align 1
@.str.19 = private unnamed_addr constant [5 x i8] c"holm\00", align 1
@.str.20 = private unnamed_addr constant [7 x i8] c"hommel\00", align 1
@.str.21 = private unnamed_addr constant [44 x i8] c"%s doesn't match any accepted FDR methods.\0A\00", align 1
@.str.22 = private unnamed_addr constant [42 x i8] c"%g is outside of the interval I planned.\0A\00", align 1
@.str.23 = private unnamed_addr constant [23 x i8] c"Failure at %s line %u\0A\00", align 1
@.str.24 = private unnamed_addr constant [54 x i8] c"array[%u] = %lf, which is outside the interval [0,1]\0A\00", align 1
@.str.25 = private unnamed_addr constant [20 x i8] c"died at %s line %u\0A\00", align 1
@__const.main.PVALUES = private unnamed_addr constant [50 x double] [double 0x3FDD04160F35FDE9, double 0x3FE758E721E2A8D7, double 0x3FB96FAC8B38D8BA, double 0x3FB73E71D5B04B37, double 0x3FC710AB48EE865B, double 0x3FEC01D953C3CC73, double 0x3FD2B3C4BE0A922A, double 0x3FED2B5A568DAB4F, double 0x3FDBE08D73F16964, double 0x3FE10A218C41C242, double 0x3FDF8810DB1996AA, double 0x3FE291CCB11E1A9D, double 0x3FD64E8C550D788F, double 7.883130e-01, double 0x3FD177B2BF048D2D, double 0x3FEB3543434BAF2B, double 0x3FDB50EAD41ED0A6, double 0x3FE49D4AFF01D33F, double 0x3FD364C9AE345B51, double 0x3FA99BA35F15394D, double 3.194810e-01, double 0x3FE941E405CE761A, double 0x3FEFF94F77369843, double 0x3FC65847BFB23217, double 0x3FECEB8879B6A543, double 0x3FBEAF00332BA677, double 0x3FD96207C7749E38, double 0x3F8CC02620502C93, double 0x3FE773A5B45A0F40, double 0x3FB1642C24762C01, double 4.040730e-03, double 0x3F33E11D79A90777, double 0x3F870B02BD749528, double 0x3F98521BD6A0353F, double 0x3F4310F26148FFAA, double 0x3F3427CD76006778, double 0x3F80E60AFB1F8A4E, double 0x3F5639B74A9E4DA2, double 0x3F8BDDF74195769F, double 0x3F38ABEE3BFA8581, double 0x3EF2E2E96B5466FE, double 0x3E90CE9F65B58A88, double 0x3FA0F2D097879B95, double 0x3F834EE7216A6684, double 0x3F4CCE8DBB40BD9D, double 0x3F2C8B969590F2ED, double 0x3F4FC31F7F1541AD, double 6.610250e-05, double 0x3F9DB44EA6AC26BA, double 5.735490e-03], align 16
@__const.main.CORRECT_ANSWERS = private unnamed_addr constant [6 x [50 x double]] [[50 x double] [double 0x3FE39AFA2199ADBC, double 8.521710e-01, double 0x3FC96FAC6045BAF5, double 0x3FC83660E51D25AB, double 0x3FD498068702BE20, double 0x3FEDC3BF727136A4, double 4.870370e-01, double 0x3FEDC3BF727136A4, double 0x3FE35BF08BEEB62C, double 0x3FE5D879DEE92F03, double 0x3FE4BE91D656B94A, double 0x3FE7363FC28DAEAA, double 0x3FE0E62C4F13638A, double 0x3FEC1052C8FAB035, double 0x3FDE1DD2E43E029A, double 0x3FED92EFFC7CBDC1, double 0x3FE35BF08BEEB62C, double 0x3FE923B90CFC67C5, double 0x3FDF47B8FC357024, double 0x3FBD1996A9FB10AD, double 0x3FDFF2B6D6C14255, double 0x3FEC1052C8FAB035, double 0x3FEFF94F77369843, double 0x3FD498068702BE20, double 0x3FEDC3BF727136A4, double 0x3FCD80E2E96EC403, double 0x3FE2A9F6A93F290B, double 0x3FA3F736D8AF2E2B, double 8.521710e-01, double 0x3FC2E751B350FAC4, double 0x3F913D8E55EE9F05, double 0x3F64FECB88BB3633, double 0x3FA2009A03CCBE34, double 0x3FB0001FB57CF9FC, double 0x3F6DCA7ADA5E274A, double 0x3F64FECB88BB3633, double 0x3F9E2D13B467D120, double 0x3F7941963399C6A1, double 0x3FA3F736D8AF2E2B, double 0x3F6607390CEF853C, double 0x3F3D828C80BA213A, double 0x3EEA42D90EEBA875, double 0x3FB42D4181AA8F8B, double 0x3FA01715F12E0018, double 0x3F73D9F3AF6D490C, double 0x3F64FECB88BB3633, double 0x3F73D9F3AF6D490C, double 0x3F520CE5F51A7C61, double 0x3FB290B112B20952, double 0x3F9696C95AA76B69], [50 x double] [double 1.000000e+00, double 1.000000e+00, double 0x3FEC9C56E33BA41B, double 0x3FEB3BF21E95ED3D, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 0x3FE05DA74553C727, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 0x3FC675198790829A, double 1.000000e+00, double 0x3FE54345648E1F12, double 0x3FB3645F501CA2F9, double 0x3F879D934E50F0DE, double 0x3FC43FC3646E3EA2, double 0x3FD1FF539D36064C, double 0x3F90C123206B855F, double 0x3F879D934E50F0DE, double 0x3FC0F8967F32E606, double 0x3F9C6880470D2FBE, double 0x3FC675198790829A, double 0x3F88C70105E47082, double 2.025930e-03, double 0x3F0D89DE4FA8F818, double 0x3FD6B1E2D11B1027, double 0x3FC219271872BD8D, double 0x3F96542FAD16CEF9, double 0x3F879D934E50F0DE, double 0x3F96542FAD16CEF9, double 0x3F744D9816EB319A, double 0x3FD4E1D5728DBC16, double 0x3FB9687C40426555], [50 x double] [double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 0x3FE6761DC93EA2D3, double 1.000000e+00, double 1.000000e+00, double 0x3FC9DC55000C953A, double 0x3F8F0FBD624BA499, double 0x3FE2009A24031487, double 1.000000e+00, double 0x3F9DCA7AB8020F7A, double 0x3F8F7E310860A1AB, double 0x3FDA677128614819, double 6.782670e-02, double 6.803480e-01, double 0x3F9346521EDBB84D, double 0x3F4D828CB7B3E0EE, double 0x3EEA42D90EEBA875, double 1.000000e+00, double 4.713920e-01, double 0x3FA6815EE53DB1E7, double 0x3F864D0CF90CC6B8, double 0x3FA8D0709B489B4F, double 0x3F6B1359791819D2, double 1.000000e+00, double 0x3FD25A836EB4E981], [50 x double] [double 0x3FEFF94F77369843, double 0x3FEFF94F77369843, double 0x3FEFF94F77369843, double 0x3FEFF94F77369843, double 0x3FEFF94F77369843, double 0x3FEFF94F77369843, double 0x3FEFF94F77369843, double 0x3FEFF94F77369843, double 0x3FEFF94F77369843, double 0x3FEFF94F77369843, double 0x3FEFF94F77369843, double 0x3FEFF94F77369843, double 0x3FEFF94F77369843, double 0x3FEFF94F77369843, double 0x3FEFF94F77369843, double 0x3FEFF94F77369843, double 0x3FEFF94F77369843, double 0x3FEFF94F77369843, double 0x3FEFF94F77369843, double 0x3FEFF94F77369843, double 0x3FEFF94F77369843, double 0x3FEFF94F77369843, double 0x3FEFF94F77369843, double 0x3FEFF94F77369843, double 0x3FEFF94F77369843, double 0x3FEFF94F77369843, double 0x3FEFF94F77369843, double 0x3FDDA6274695E687, double 0x3FEFF94F77369843, double 0x3FEFF94F77369843, double 0x3FC42BDC26DCE39B, double 0x3F8C57F9104CA951, double 0x3FD9340AC9879DEF, double 7.600230e-01, double 0x3F999EC5A86B439B, double 0x3F8C57F9104CA951, double 0x3FD389FCD90412B4, double 0x3FABC8251D45E10B, double 0x3FDD9BD68ABBB045, double 0x3F90F633F956C386, double 8.825610e-04, double 0x3EEA42D90EEBA875, double 0x3FEFC7471C1E43B8, double 0x3FD5B8C4014C305A, double 0x3FA2E78CEC8D068E, double 0x3F84F6832995A599, double 0x3FA459002162FC24, double 3.172920e-03, double 8.992520e-01, double 0x3FCBE5BD5E9AC00A], [50 x double] [double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 0x3FDDA6274695E687, double 1.000000e+00, double 1.000000e+00, double 0x3FC42BDC26DCE39B, double 0x3F8C939AFCF101E0, double 0x3FD9340AC9879DEF, double 7.600230e-01, double 0x3F999EC5A86B439B, double 0x3F8C939AFCF101E0, double 0x3FD389FCD90412B4, double 0x3FABC8251D45E10B, double 0x3FDD9BD68ABBB045, double 0x3F90F633F956C386, double 8.825610e-04, double 0x3EEA42D90EEBA875, double 0x3FEFC7471C1E43B8, double 0x3FD5B8C4014C305A, double 0x3FA2E78CEC8D068E, double 0x3F84F6832995A599, double 0x3FA459002162FC24, double 3.172920e-03, double 8.992520e-01, double 0x3FCBE5BD5E9AC00A], [50 x double] [double 0x3FEFF94F77369843, double 0x3FEFF94F77369843, double 0x3FEFF94F77369843, double 0x3FEFF5DC908F2EDD, double 0x3FEFF94F77369843, double 0x3FEFF94F77369843, double 0x3FEFF94F77369843, double 0x3FEFF94F77369843, double 0x3FEFF94F77369843, double 0x3FEFF94F77369843, double 0x3FEFF94F77369843, double 0x3FEFF94F77369843, double 0x3FEFF94F77369843, double 0x3FEFF94F77369843, double 0x3FEFF94F77369843, double 0x3FEFF94F77369843, double 0x3FEFF94F77369843, double 0x3FEFF94F77369843, double 0x3FEFF94F77369843, double 0x3FEEB45F17BD8BE7, double 0x3FEFF94F77369843, double 0x3FEFF94F77369843, double 0x3FEFF94F77369843, double 0x3FEFF94F77369843, double 0x3FEFF94F77369843, double 0x3FEFF94F77369843, double 0x3FEFF94F77369843, double 0x3FDBDA250F840182, double 0x3FEFF94F77369843, double 0x3FEF40BC1D52205E, double 0x3FC21A3BEB689947, double 1.304340e-02, double 0x3FD69916517B1CD7, double 0x3FE60A69453DF7B2, double 0x3F986DB666D9D3C6, double 0x3F8B157BBD3AB385, double 2.722920e-01, double 0x3FABC8251D45E10B, double 0x3FDAFF07B27BE8AF, double 0x3F9030D45E3B9F93, double 8.825610e-04, double 0x3EEA42D90EEBA875, double 0x3FEBFACC1948A662, double 0x3FD34EE6EDE042CB, double 0x3FA2011883DA6A9A, double 0x3F839FF779153716, double 0x3FA3D9F3D1C960DD, double 3.172920e-03, double 0x3FE9FDC4BC5D1301, double 0x3FC8F5FAC3801CF1]], align 16
@.str.26 = private unnamed_addr constant [3 x i8] c"bh\00", align 1
@.str.27 = private unnamed_addr constant [11 x i8] c"bonferroni\00", align 1
@__const.main.TYPES = private unnamed_addr constant [6 x i8*] [i8* getelementptr inbounds ([3 x i8], [3 x i8]* @.str.26, i32 0, i32 0), i8* getelementptr inbounds ([3 x i8], [3 x i8]* @.str.16, i32 0, i32 0), i8* getelementptr inbounds ([11 x i8], [11 x i8]* @.str.27, i32 0, i32 0), i8* getelementptr inbounds ([9 x i8], [9 x i8]* @.str.18, i32 0, i32 0), i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.19, i32 0, i32 0), i8* getelementptr inbounds ([7 x i8], [7 x i8]* @.str.20, i32 0, i32 0)], align 16
@.str.28 = private unnamed_addr constant [44 x i8] c"\0Atype %u = '%s' has cumulative error of %g\0A\00", align 1
@llvm.used = appending global [1 x i8*] [i8* bitcast (i32 ()* @__main_void to i8*)], section "llvm.metadata"

@__main_void = alias i32 (), i32 ()* @main

; Function Attrs: noinline nounwind optnone
define hidden i32* @seq_len(i32 %START, i32 %END) #0 {
entry:
  %retval = alloca i32*, align 4
  %START.addr = alloca i32, align 4
  %END.addr = alloca i32, align 4
  %start = alloca i32, align 4
  %end = alloca i32, align 4
  %sequence = alloca i32*, align 4
  %i = alloca i32, align 4
  %LENGTH = alloca i32, align 4
  %sequence10 = alloca i32*, align 4
  %index = alloca i32, align 4
  %index28 = alloca i32, align 4
  store i32 %START, i32* %START.addr, align 4
  store i32 %END, i32* %END.addr, align 4
  %0 = load i32, i32* %START.addr, align 4
  store i32 %0, i32* %start, align 4
  %1 = load i32, i32* %END.addr, align 4
  store i32 %1, i32* %end, align 4
  %2 = load i32, i32* %START.addr, align 4
  %3 = load i32, i32* %END.addr, align 4
  %cmp = icmp eq i32 %2, %3
  br i1 %cmp, label %if.then, label %if.end6

if.then:                                          ; preds = %entry
  %4 = load i32, i32* %end, align 4
  %add = add i32 %4, 1
  %mul = mul i32 %add, 4
  %call = call noalias i8* @malloc(i32 %mul)
  %5 = bitcast i8* %call to i32*
  store i32* %5, i32** %sequence, align 4
  %6 = load i32*, i32** %sequence, align 4
  %cmp1 = icmp eq i32* %6, null
  br i1 %cmp1, label %if.then2, label %if.end

if.then2:                                         ; preds = %if.then
  %call3 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([29 x i8], [29 x i8]* @.str, i32 0, i32 0), i8* getelementptr inbounds ([23 x i8], [23 x i8]* @.str.1, i32 0, i32 0), i32 15)
  call void @perror(i8* getelementptr inbounds ([1 x i8], [1 x i8]* @.str.2, i32 0, i32 0))
  call void @exit(i32 1) #5
  unreachable

if.end:                                           ; preds = %if.then
  store i32 0, i32* %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.end
  %7 = load i32, i32* %i, align 4
  %8 = load i32, i32* %end, align 4
  %cmp4 = icmp ult i32 %7, %8
  br i1 %cmp4, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %9 = load i32, i32* %i, align 4
  %add5 = add i32 %9, 1
  %10 = load i32*, i32** %sequence, align 4
  %11 = load i32, i32* %i, align 4
  %arrayidx = getelementptr inbounds i32, i32* %10, i32 %11
  store i32 %add5, i32* %arrayidx, align 4
  br label %for.inc

for.inc:                                          ; preds = %for.body
  %12 = load i32, i32* %i, align 4
  %inc = add i32 %12, 1
  store i32 %inc, i32* %i, align 4
  br label %for.cond

for.end:                                          ; preds = %for.cond
  %13 = load i32*, i32** %sequence, align 4
  store i32* %13, i32** %retval, align 4
  br label %return

if.end6:                                          ; preds = %entry
  %14 = load i32, i32* %START.addr, align 4
  %15 = load i32, i32* %END.addr, align 4
  %cmp7 = icmp ugt i32 %14, %15
  br i1 %cmp7, label %if.then8, label %if.end9

if.then8:                                         ; preds = %if.end6
  %16 = load i32, i32* %START.addr, align 4
  store i32 %16, i32* %end, align 4
  %17 = load i32, i32* %END.addr, align 4
  store i32 %17, i32* %start, align 4
  br label %if.end9

if.end9:                                          ; preds = %if.then8, %if.end6
  %18 = load i32, i32* %end, align 4
  %19 = load i32, i32* %start, align 4
  %sub = sub i32 %18, %19
  store i32 %sub, i32* %LENGTH, align 4
  %20 = load i32, i32* %LENGTH, align 4
  %add11 = add i32 1, %20
  %mul12 = mul i32 %add11, 4
  %call13 = call noalias i8* @malloc(i32 %mul12)
  %21 = bitcast i8* %call13 to i32*
  store i32* %21, i32** %sequence10, align 4
  %22 = load i32*, i32** %sequence10, align 4
  %cmp14 = icmp eq i32* %22, null
  br i1 %cmp14, label %if.then15, label %if.end17

if.then15:                                        ; preds = %if.end9
  %call16 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([29 x i8], [29 x i8]* @.str, i32 0, i32 0), i8* getelementptr inbounds ([23 x i8], [23 x i8]* @.str.1, i32 0, i32 0), i32 31)
  call void @perror(i8* getelementptr inbounds ([1 x i8], [1 x i8]* @.str.2, i32 0, i32 0))
  call void @exit(i32 1) #5
  unreachable

if.end17:                                         ; preds = %if.end9
  %23 = load i32, i32* %START.addr, align 4
  %24 = load i32, i32* %END.addr, align 4
  %cmp18 = icmp ult i32 %23, %24
  br i1 %cmp18, label %if.then19, label %if.else

if.then19:                                        ; preds = %if.end17
  store i32 0, i32* %index, align 4
  br label %for.cond20

for.cond20:                                       ; preds = %for.inc25, %if.then19
  %25 = load i32, i32* %index, align 4
  %26 = load i32, i32* %LENGTH, align 4
  %cmp21 = icmp ule i32 %25, %26
  br i1 %cmp21, label %for.body22, label %for.end27

for.body22:                                       ; preds = %for.cond20
  %27 = load i32, i32* %start, align 4
  %28 = load i32, i32* %index, align 4
  %add23 = add i32 %27, %28
  %29 = load i32*, i32** %sequence10, align 4
  %30 = load i32, i32* %index, align 4
  %arrayidx24 = getelementptr inbounds i32, i32* %29, i32 %30
  store i32 %add23, i32* %arrayidx24, align 4
  br label %for.inc25

for.inc25:                                        ; preds = %for.body22
  %31 = load i32, i32* %index, align 4
  %inc26 = add i32 %31, 1
  store i32 %inc26, i32* %index, align 4
  br label %for.cond20

for.end27:                                        ; preds = %for.cond20
  br label %if.end37

if.else:                                          ; preds = %if.end17
  store i32 0, i32* %index28, align 4
  br label %for.cond29

for.cond29:                                       ; preds = %for.inc34, %if.else
  %32 = load i32, i32* %index28, align 4
  %33 = load i32, i32* %LENGTH, align 4
  %cmp30 = icmp ule i32 %32, %33
  br i1 %cmp30, label %for.body31, label %for.end36

for.body31:                                       ; preds = %for.cond29
  %34 = load i32, i32* %end, align 4
  %35 = load i32, i32* %index28, align 4
  %sub32 = sub i32 %34, %35
  %36 = load i32*, i32** %sequence10, align 4
  %37 = load i32, i32* %index28, align 4
  %arrayidx33 = getelementptr inbounds i32, i32* %36, i32 %37
  store i32 %sub32, i32* %arrayidx33, align 4
  br label %for.inc34

for.inc34:                                        ; preds = %for.body31
  %38 = load i32, i32* %index28, align 4
  %inc35 = add i32 %38, 1
  store i32 %inc35, i32* %index28, align 4
  br label %for.cond29

for.end36:                                        ; preds = %for.cond29
  br label %if.end37

if.end37:                                         ; preds = %for.end36, %for.end27
  %39 = load i32*, i32** %sequence10, align 4
  store i32* %39, i32** %retval, align 4
  br label %return

return:                                           ; preds = %if.end37, %for.end
  %40 = load i32*, i32** %retval, align 4
  ret i32* %40
}

declare noalias i8* @malloc(i32 %0) #1

declare i32 @printf(i8* %0, ...) #1

declare void @perror(i8* %0) #1

; Function Attrs: noreturn
declare void @exit(i32 %0) #2

; Function Attrs: noinline nounwind optnone
define hidden i32* @order(double* noalias %ARRAY, i32 %SIZE, i1 zeroext %DECREASING) #0 {
entry:
  %ARRAY.addr = alloca double*, align 4
  %SIZE.addr = alloca i32, align 4
  %DECREASING.addr = alloca i8, align 1
  %idx = alloca i32*, align 4
  %i = alloca i32, align 4
  store double* %ARRAY, double** %ARRAY.addr, align 4
  store i32 %SIZE, i32* %SIZE.addr, align 4
  %frombool = zext i1 %DECREASING to i8
  store i8 %frombool, i8* %DECREASING.addr, align 1
  %0 = load i32, i32* %SIZE.addr, align 4
  %mul = mul i32 %0, 4
  %call = call noalias i8* @malloc(i32 %mul)
  %1 = bitcast i8* %call to i32*
  store i32* %1, i32** %idx, align 4
  %2 = load i32*, i32** %idx, align 4
  %cmp = icmp eq i32* %2, null
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %call1 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([33 x i8], [33 x i8]* @.str.3, i32 0, i32 0), i8* getelementptr inbounds ([23 x i8], [23 x i8]* @.str.1, i32 0, i32 0), i32 77)
  call void @perror(i8* getelementptr inbounds ([1 x i8], [1 x i8]* @.str.2, i32 0, i32 0))
  call void @exit(i32 1) #5
  unreachable

if.end:                                           ; preds = %entry
  %3 = load i32, i32* %SIZE.addr, align 4
  %mul2 = mul i32 8, %3
  %call3 = call noalias i8* @malloc(i32 %mul2)
  %4 = bitcast i8* %call3 to double*
  store double* %4, double** @base_arr, align 4
  %5 = load double*, double** @base_arr, align 4
  %cmp4 = icmp eq double* %5, null
  br i1 %cmp4, label %if.then5, label %if.end7

if.then5:                                         ; preds = %if.end
  %call6 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([33 x i8], [33 x i8]* @.str.3, i32 0, i32 0), i8* getelementptr inbounds ([23 x i8], [23 x i8]* @.str.1, i32 0, i32 0), i32 83)
  call void @perror(i8* getelementptr inbounds ([1 x i8], [1 x i8]* @.str.2, i32 0, i32 0))
  call void @exit(i32 1) #5
  unreachable

if.end7:                                          ; preds = %if.end
  store i32 0, i32* %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.end7
  %6 = load i32, i32* %i, align 4
  %7 = load i32, i32* %SIZE.addr, align 4
  %cmp8 = icmp ult i32 %6, %7
  br i1 %cmp8, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %8 = load double*, double** %ARRAY.addr, align 4
  %9 = load i32, i32* %i, align 4
  %arrayidx = getelementptr inbounds double, double* %8, i32 %9
  %10 = load double, double* %arrayidx, align 8
  %11 = load double*, double** @base_arr, align 4
  %12 = load i32, i32* %i, align 4
  %arrayidx9 = getelementptr inbounds double, double* %11, i32 %12
  store double %10, double* %arrayidx9, align 8
  %13 = load i32, i32* %i, align 4
  %14 = load i32*, i32** %idx, align 4
  %15 = load i32, i32* %i, align 4
  %arrayidx10 = getelementptr inbounds i32, i32* %14, i32 %15
  store i32 %13, i32* %arrayidx10, align 4
  br label %for.inc

for.inc:                                          ; preds = %for.body
  %16 = load i32, i32* %i, align 4
  %inc = add i32 %16, 1
  store i32 %inc, i32* %i, align 4
  br label %for.cond

for.end:                                          ; preds = %for.cond
  %17 = load i8, i8* %DECREASING.addr, align 1
  %tobool = trunc i8 %17 to i1
  %conv = zext i1 %tobool to i32
  %cmp11 = icmp eq i32 %conv, 0
  br i1 %cmp11, label %if.then13, label %if.else

if.then13:                                        ; preds = %for.end
  %18 = load i32*, i32** %idx, align 4
  %19 = bitcast i32* %18 to i8*
  %20 = load i32, i32* %SIZE.addr, align 4
  call void @qsort(i8* %19, i32 %20, i32 4, i32 (i8*, i8*)* @compar_decrease)
  br label %if.end20

if.else:                                          ; preds = %for.end
  %21 = load i8, i8* %DECREASING.addr, align 1
  %tobool14 = trunc i8 %21 to i1
  %conv15 = zext i1 %tobool14 to i32
  %cmp16 = icmp eq i32 %conv15, 1
  br i1 %cmp16, label %if.then18, label %if.end19

if.then18:                                        ; preds = %if.else
  %22 = load i32*, i32** %idx, align 4
  %23 = bitcast i32* %22 to i8*
  %24 = load i32, i32* %SIZE.addr, align 4
  call void @qsort(i8* %23, i32 %24, i32 4, i32 (i8*, i8*)* @compar_increase)
  br label %if.end19

if.end19:                                         ; preds = %if.then18, %if.else
  br label %if.end20

if.end20:                                         ; preds = %if.end19, %if.then13
  %25 = load double*, double** @base_arr, align 4
  %26 = bitcast double* %25 to i8*
  call void @free(i8* %26)
  store double* null, double** @base_arr, align 4
  %27 = load i32*, i32** %idx, align 4
  ret i32* %27
}

declare void @qsort(i8* %0, i32 %1, i32 %2, i32 (i8*, i8*)* %3) #1

; Function Attrs: noinline nounwind optnone
define internal i32 @compar_decrease(i8* noalias %a, i8* noalias %b) #0 {
entry:
  %retval = alloca i32, align 4
  %a.addr = alloca i8*, align 4
  %b.addr = alloca i8*, align 4
  %aa = alloca i32, align 4
  %bb = alloca i32, align 4
  store i8* %a, i8** %a.addr, align 4
  store i8* %b, i8** %b.addr, align 4
  %0 = load i8*, i8** %a.addr, align 4
  %1 = bitcast i8* %0 to i32*
  %2 = load i32, i32* %1, align 4
  store i32 %2, i32* %aa, align 4
  %3 = load i8*, i8** %b.addr, align 4
  %4 = bitcast i8* %3 to i32*
  %5 = load i32, i32* %4, align 4
  store i32 %5, i32* %bb, align 4
  %6 = load double*, double** @base_arr, align 4
  %7 = load i32, i32* %aa, align 4
  %arrayidx = getelementptr inbounds double, double* %6, i32 %7
  %8 = load double, double* %arrayidx, align 8
  %9 = load double*, double** @base_arr, align 4
  %10 = load i32, i32* %bb, align 4
  %arrayidx1 = getelementptr inbounds double, double* %9, i32 %10
  %11 = load double, double* %arrayidx1, align 8
  %cmp = fcmp olt double %8, %11
  br i1 %cmp, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  store i32 -1, i32* %retval, align 4
  br label %return

if.else:                                          ; preds = %entry
  %12 = load double*, double** @base_arr, align 4
  %13 = load i32, i32* %aa, align 4
  %arrayidx2 = getelementptr inbounds double, double* %12, i32 %13
  %14 = load double, double* %arrayidx2, align 8
  %15 = load double*, double** @base_arr, align 4
  %16 = load i32, i32* %bb, align 4
  %arrayidx3 = getelementptr inbounds double, double* %15, i32 %16
  %17 = load double, double* %arrayidx3, align 8
  %cmp4 = fcmp oeq double %14, %17
  br i1 %cmp4, label %if.then5, label %if.else6

if.then5:                                         ; preds = %if.else
  store i32 0, i32* %retval, align 4
  br label %return

if.else6:                                         ; preds = %if.else
  store i32 1, i32* %retval, align 4
  br label %return

return:                                           ; preds = %if.else6, %if.then5, %if.then
  %18 = load i32, i32* %retval, align 4
  ret i32 %18
}

; Function Attrs: noinline nounwind optnone
define internal i32 @compar_increase(i8* noalias %a, i8* noalias %b) #0 {
entry:
  %retval = alloca i32, align 4
  %a.addr = alloca i8*, align 4
  %b.addr = alloca i8*, align 4
  %aa = alloca i32, align 4
  %bb = alloca i32, align 4
  store i8* %a, i8** %a.addr, align 4
  store i8* %b, i8** %b.addr, align 4
  %0 = load i8*, i8** %a.addr, align 4
  %1 = bitcast i8* %0 to i32*
  %2 = load i32, i32* %1, align 4
  store i32 %2, i32* %aa, align 4
  %3 = load i8*, i8** %b.addr, align 4
  %4 = bitcast i8* %3 to i32*
  %5 = load i32, i32* %4, align 4
  store i32 %5, i32* %bb, align 4
  %6 = load double*, double** @base_arr, align 4
  %7 = load i32, i32* %aa, align 4
  %arrayidx = getelementptr inbounds double, double* %6, i32 %7
  %8 = load double, double* %arrayidx, align 8
  %9 = load double*, double** @base_arr, align 4
  %10 = load i32, i32* %bb, align 4
  %arrayidx1 = getelementptr inbounds double, double* %9, i32 %10
  %11 = load double, double* %arrayidx1, align 8
  %cmp = fcmp olt double %8, %11
  br i1 %cmp, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  store i32 1, i32* %retval, align 4
  br label %return

if.else:                                          ; preds = %entry
  %12 = load double*, double** @base_arr, align 4
  %13 = load i32, i32* %aa, align 4
  %arrayidx2 = getelementptr inbounds double, double* %12, i32 %13
  %14 = load double, double* %arrayidx2, align 8
  %15 = load double*, double** @base_arr, align 4
  %16 = load i32, i32* %bb, align 4
  %arrayidx3 = getelementptr inbounds double, double* %15, i32 %16
  %17 = load double, double* %arrayidx3, align 8
  %cmp4 = fcmp oeq double %14, %17
  br i1 %cmp4, label %if.then5, label %if.else6

if.then5:                                         ; preds = %if.else
  store i32 0, i32* %retval, align 4
  br label %return

if.else6:                                         ; preds = %if.else
  store i32 -1, i32* %retval, align 4
  br label %return

return:                                           ; preds = %if.else6, %if.then5, %if.then
  %18 = load i32, i32* %retval, align 4
  ret i32 %18
}

declare void @free(i8* %0) #1

; Function Attrs: noinline nounwind optnone
define hidden double* @cummin(double* noalias %ARRAY, i32 %NO_OF_ARRAY_ELEMENTS) #0 {
entry:
  %ARRAY.addr = alloca double*, align 4
  %NO_OF_ARRAY_ELEMENTS.addr = alloca i32, align 4
  %output = alloca double*, align 4
  %cumulative_min = alloca double, align 8
  %i = alloca i32, align 4
  store double* %ARRAY, double** %ARRAY.addr, align 4
  store i32 %NO_OF_ARRAY_ELEMENTS, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
  %0 = load i32, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
  %cmp = icmp ult i32 %0, 1
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %call = call i32 @puts(i8* getelementptr inbounds ([48 x i8], [48 x i8]* @.str.4, i32 0, i32 0))
  %call1 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([22 x i8], [22 x i8]* @.str.5, i32 0, i32 0), i8* getelementptr inbounds ([23 x i8], [23 x i8]* @.str.1, i32 0, i32 0), i32 105)
  call void @exit(i32 1) #5
  unreachable

if.end:                                           ; preds = %entry
  %1 = load i32, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
  %mul = mul i32 8, %1
  %call2 = call noalias i8* @malloc(i32 %mul)
  %2 = bitcast i8* %call2 to double*
  store double* %2, double** %output, align 4
  %3 = load double*, double** %output, align 4
  %cmp3 = icmp eq double* %3, null
  br i1 %cmp3, label %if.then4, label %if.end6

if.then4:                                         ; preds = %if.end
  %call5 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([33 x i8], [33 x i8]* @.str.3, i32 0, i32 0), i8* getelementptr inbounds ([23 x i8], [23 x i8]* @.str.1, i32 0, i32 0), i32 110)
  call void @perror(i8* getelementptr inbounds ([1 x i8], [1 x i8]* @.str.2, i32 0, i32 0))
  call void @exit(i32 1) #5
  unreachable

if.end6:                                          ; preds = %if.end
  %4 = load double*, double** %ARRAY.addr, align 4
  %arrayidx = getelementptr inbounds double, double* %4, i32 0
  %5 = load double, double* %arrayidx, align 8
  store double %5, double* %cumulative_min, align 8
  store i32 0, i32* %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.end6
  %6 = load i32, i32* %i, align 4
  %7 = load i32, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
  %cmp7 = icmp ult i32 %6, %7
  br i1 %cmp7, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %8 = load double*, double** %ARRAY.addr, align 4
  %9 = load i32, i32* %i, align 4
  %arrayidx8 = getelementptr inbounds double, double* %8, i32 %9
  %10 = load double, double* %arrayidx8, align 8
  %11 = load double, double* %cumulative_min, align 8
  %cmp9 = fcmp olt double %10, %11
  br i1 %cmp9, label %if.then10, label %if.end12

if.then10:                                        ; preds = %for.body
  %12 = load double*, double** %ARRAY.addr, align 4
  %13 = load i32, i32* %i, align 4
  %arrayidx11 = getelementptr inbounds double, double* %12, i32 %13
  %14 = load double, double* %arrayidx11, align 8
  store double %14, double* %cumulative_min, align 8
  br label %if.end12

if.end12:                                         ; preds = %if.then10, %for.body
  %15 = load double, double* %cumulative_min, align 8
  %16 = load double*, double** %output, align 4
  %17 = load i32, i32* %i, align 4
  %arrayidx13 = getelementptr inbounds double, double* %16, i32 %17
  store double %15, double* %arrayidx13, align 8
  br label %for.inc

for.inc:                                          ; preds = %if.end12
  %18 = load i32, i32* %i, align 4
  %inc = add i32 %18, 1
  store i32 %inc, i32* %i, align 4
  br label %for.cond

for.end:                                          ; preds = %for.cond
  %19 = load double*, double** %output, align 4
  ret double* %19
}

declare i32 @puts(i8* %0) #1

; Function Attrs: noinline nounwind optnone
define hidden double* @cummax(double* noalias %ARRAY, i32 %NO_OF_ARRAY_ELEMENTS) #0 {
entry:
  %ARRAY.addr = alloca double*, align 4
  %NO_OF_ARRAY_ELEMENTS.addr = alloca i32, align 4
  %output = alloca double*, align 4
  %cumulative_max = alloca double, align 8
  %i = alloca i32, align 4
  store double* %ARRAY, double** %ARRAY.addr, align 4
  store i32 %NO_OF_ARRAY_ELEMENTS, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
  %0 = load i32, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
  %cmp = icmp ult i32 %0, 1
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %call = call i32 @puts(i8* getelementptr inbounds ([41 x i8], [41 x i8]* @.str.6, i32 0, i32 0))
  %call1 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([22 x i8], [22 x i8]* @.str.5, i32 0, i32 0), i8* getelementptr inbounds ([23 x i8], [23 x i8]* @.str.1, i32 0, i32 0), i32 129)
  call void @exit(i32 1) #5
  unreachable

if.end:                                           ; preds = %entry
  %1 = load i32, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
  %mul = mul i32 8, %1
  %call2 = call noalias i8* @malloc(i32 %mul)
  %2 = bitcast i8* %call2 to double*
  store double* %2, double** %output, align 4
  %3 = load double*, double** %output, align 4
  %cmp3 = icmp eq double* %3, null
  br i1 %cmp3, label %if.then4, label %if.end6

if.then4:                                         ; preds = %if.end
  %call5 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([33 x i8], [33 x i8]* @.str.3, i32 0, i32 0), i8* getelementptr inbounds ([23 x i8], [23 x i8]* @.str.1, i32 0, i32 0), i32 134)
  call void @perror(i8* getelementptr inbounds ([1 x i8], [1 x i8]* @.str.2, i32 0, i32 0))
  call void @exit(i32 1) #5
  unreachable

if.end6:                                          ; preds = %if.end
  %4 = load double*, double** %ARRAY.addr, align 4
  %arrayidx = getelementptr inbounds double, double* %4, i32 0
  %5 = load double, double* %arrayidx, align 8
  store double %5, double* %cumulative_max, align 8
  store i32 0, i32* %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.end6
  %6 = load i32, i32* %i, align 4
  %7 = load i32, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
  %cmp7 = icmp ult i32 %6, %7
  br i1 %cmp7, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %8 = load double*, double** %ARRAY.addr, align 4
  %9 = load i32, i32* %i, align 4
  %arrayidx8 = getelementptr inbounds double, double* %8, i32 %9
  %10 = load double, double* %arrayidx8, align 8
  %11 = load double, double* %cumulative_max, align 8
  %cmp9 = fcmp ogt double %10, %11
  br i1 %cmp9, label %if.then10, label %if.end12

if.then10:                                        ; preds = %for.body
  %12 = load double*, double** %ARRAY.addr, align 4
  %13 = load i32, i32* %i, align 4
  %arrayidx11 = getelementptr inbounds double, double* %12, i32 %13
  %14 = load double, double* %arrayidx11, align 8
  store double %14, double* %cumulative_max, align 8
  br label %if.end12

if.end12:                                         ; preds = %if.then10, %for.body
  %15 = load double, double* %cumulative_max, align 8
  %16 = load double*, double** %output, align 4
  %17 = load i32, i32* %i, align 4
  %arrayidx13 = getelementptr inbounds double, double* %16, i32 %17
  store double %15, double* %arrayidx13, align 8
  br label %for.inc

for.inc:                                          ; preds = %if.end12
  %18 = load i32, i32* %i, align 4
  %inc = add i32 %18, 1
  store i32 %inc, i32* %i, align 4
  br label %for.cond

for.end:                                          ; preds = %for.cond
  %19 = load double*, double** %output, align 4
  ret double* %19
}

; Function Attrs: noinline nounwind optnone
define hidden double* @pminx(double* noalias %ARRAY, i32 %NO_OF_ARRAY_ELEMENTS, double %X) #0 {
entry:
  %ARRAY.addr = alloca double*, align 4
  %NO_OF_ARRAY_ELEMENTS.addr = alloca i32, align 4
  %X.addr = alloca double, align 8
  %pmin_array = alloca double*, align 4
  %index = alloca i32, align 4
  store double* %ARRAY, double** %ARRAY.addr, align 4
  store i32 %NO_OF_ARRAY_ELEMENTS, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
  store double %X, double* %X.addr, align 8
  %0 = load i32, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
  %cmp = icmp ult i32 %0, 1
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %call = call i32 @puts(i8* getelementptr inbounds ([37 x i8], [37 x i8]* @.str.7, i32 0, i32 0))
  %call1 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([22 x i8], [22 x i8]* @.str.5, i32 0, i32 0), i8* getelementptr inbounds ([23 x i8], [23 x i8]* @.str.1, i32 0, i32 0), i32 152)
  call void @exit(i32 1) #5
  unreachable

if.end:                                           ; preds = %entry
  %1 = load i32, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
  %mul = mul i32 8, %1
  %call2 = call noalias i8* @malloc(i32 %mul)
  %2 = bitcast i8* %call2 to double*
  store double* %2, double** %pmin_array, align 4
  %3 = load double*, double** %pmin_array, align 4
  %cmp3 = icmp eq double* %3, null
  br i1 %cmp3, label %if.then4, label %if.end6

if.then4:                                         ; preds = %if.end
  %call5 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([33 x i8], [33 x i8]* @.str.3, i32 0, i32 0), i8* getelementptr inbounds ([23 x i8], [23 x i8]* @.str.1, i32 0, i32 0), i32 157)
  call void @perror(i8* getelementptr inbounds ([1 x i8], [1 x i8]* @.str.2, i32 0, i32 0))
  call void @exit(i32 1) #5
  unreachable

if.end6:                                          ; preds = %if.end
  store i32 0, i32* %index, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.end6
  %4 = load i32, i32* %index, align 4
  %5 = load i32, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
  %cmp7 = icmp ult i32 %4, %5
  br i1 %cmp7, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %6 = load double*, double** %ARRAY.addr, align 4
  %7 = load i32, i32* %index, align 4
  %arrayidx = getelementptr inbounds double, double* %6, i32 %7
  %8 = load double, double* %arrayidx, align 8
  %9 = load double, double* %X.addr, align 8
  %cmp8 = fcmp olt double %8, %9
  br i1 %cmp8, label %if.then9, label %if.else

if.then9:                                         ; preds = %for.body
  %10 = load double*, double** %ARRAY.addr, align 4
  %11 = load i32, i32* %index, align 4
  %arrayidx10 = getelementptr inbounds double, double* %10, i32 %11
  %12 = load double, double* %arrayidx10, align 8
  %13 = load double*, double** %pmin_array, align 4
  %14 = load i32, i32* %index, align 4
  %arrayidx11 = getelementptr inbounds double, double* %13, i32 %14
  store double %12, double* %arrayidx11, align 8
  br label %if.end13

if.else:                                          ; preds = %for.body
  %15 = load double, double* %X.addr, align 8
  %16 = load double*, double** %pmin_array, align 4
  %17 = load i32, i32* %index, align 4
  %arrayidx12 = getelementptr inbounds double, double* %16, i32 %17
  store double %15, double* %arrayidx12, align 8
  br label %if.end13

if.end13:                                         ; preds = %if.else, %if.then9
  br label %for.inc

for.inc:                                          ; preds = %if.end13
  %18 = load i32, i32* %index, align 4
  %inc = add i32 %18, 1
  store i32 %inc, i32* %index, align 4
  br label %for.cond

for.end:                                          ; preds = %for.cond
  %19 = load double*, double** %pmin_array, align 4
  ret double* %19
}

; Function Attrs: noinline nounwind optnone
define hidden void @double_say(double* noalias %ARRAY, i32 %NO_OF_ARRAY_ELEMENTS) #0 {
entry:
  %ARRAY.addr = alloca double*, align 4
  %NO_OF_ARRAY_ELEMENTS.addr = alloca i32, align 4
  %i = alloca i32, align 4
  store double* %ARRAY, double** %ARRAY.addr, align 4
  store i32 %NO_OF_ARRAY_ELEMENTS, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
  %0 = load double*, double** %ARRAY.addr, align 4
  %arrayidx = getelementptr inbounds double, double* %0, i32 0
  %1 = load double, double* %arrayidx, align 8
  %call = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([7 x i8], [7 x i8]* @.str.8, i32 0, i32 0), double %1)
  store i32 1, i32* %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %2 = load i32, i32* %i, align 4
  %3 = load i32, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
  %cmp = icmp ult i32 %2, %3
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %4 = load double*, double** %ARRAY.addr, align 4
  %5 = load i32, i32* %i, align 4
  %arrayidx1 = getelementptr inbounds double, double* %4, i32 %5
  %6 = load double, double* %arrayidx1, align 8
  %call2 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([7 x i8], [7 x i8]* @.str.9, i32 0, i32 0), double %6)
  %7 = load i32, i32* %i, align 4
  %add = add i32 %7, 1
  %rem = urem i32 %add, 5
  %cmp3 = icmp eq i32 %rem, 0
  br i1 %cmp3, label %if.then, label %if.end

if.then:                                          ; preds = %for.body
  %8 = load i32, i32* %i, align 4
  %add4 = add i32 %8, 1
  %call5 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([6 x i8], [6 x i8]* @.str.10, i32 0, i32 0), i32 %add4)
  br label %if.end

if.end:                                           ; preds = %if.then, %for.body
  br label %for.inc

for.inc:                                          ; preds = %if.end
  %9 = load i32, i32* %i, align 4
  %inc = add i32 %9, 1
  store i32 %inc, i32* %i, align 4
  br label %for.cond

for.end:                                          ; preds = %for.cond
  %call6 = call i32 @puts(i8* getelementptr inbounds ([2 x i8], [2 x i8]* @.str.11, i32 0, i32 0))
  ret void
}

; Function Attrs: noinline nounwind optnone
define hidden double* @uint2double(i32* noalias %ARRAY, i32 %NO_OF_ARRAY_ELEMENTS) #0 {
entry:
  %ARRAY.addr = alloca i32*, align 4
  %NO_OF_ARRAY_ELEMENTS.addr = alloca i32, align 4
  %doubleArray = alloca double*, align 4
  %index = alloca i32, align 4
  store i32* %ARRAY, i32** %ARRAY.addr, align 4
  store i32 %NO_OF_ARRAY_ELEMENTS, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
  %0 = load i32, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
  %mul = mul i32 8, %0
  %call = call noalias i8* @malloc(i32 %mul)
  %1 = bitcast i8* %call to double*
  store double* %1, double** %doubleArray, align 4
  %2 = load double*, double** %doubleArray, align 4
  %cmp = icmp eq double* %2, null
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %call1 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([34 x i8], [34 x i8]* @.str.12, i32 0, i32 0), i8* getelementptr inbounds ([23 x i8], [23 x i8]* @.str.1, i32 0, i32 0), i32 194)
  call void @perror(i8* getelementptr inbounds ([1 x i8], [1 x i8]* @.str.2, i32 0, i32 0))
  call void @exit(i32 1) #5
  unreachable

if.end:                                           ; preds = %entry
  store i32 0, i32* %index, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.end
  %3 = load i32, i32* %index, align 4
  %4 = load i32, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
  %cmp2 = icmp ult i32 %3, %4
  br i1 %cmp2, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %5 = load i32*, i32** %ARRAY.addr, align 4
  %6 = load i32, i32* %index, align 4
  %arrayidx = getelementptr inbounds i32, i32* %5, i32 %6
  %7 = load i32, i32* %arrayidx, align 4
  %conv = uitofp i32 %7 to double
  %8 = load double*, double** %doubleArray, align 4
  %9 = load i32, i32* %index, align 4
  %arrayidx3 = getelementptr inbounds double, double* %8, i32 %9
  store double %conv, double* %arrayidx3, align 8
  br label %for.inc

for.inc:                                          ; preds = %for.body
  %10 = load i32, i32* %index, align 4
  %inc = add i32 %10, 1
  store i32 %inc, i32* %index, align 4
  br label %for.cond

for.end:                                          ; preds = %for.cond
  %11 = load double*, double** %doubleArray, align 4
  ret double* %11
}

; Function Attrs: noinline nounwind optnone
define hidden double @min2(double %N1, double %N2) #0 {
entry:
  %retval = alloca double, align 8
  %N1.addr = alloca double, align 8
  %N2.addr = alloca double, align 8
  store double %N1, double* %N1.addr, align 8
  store double %N2, double* %N2.addr, align 8
  %0 = load double, double* %N1.addr, align 8
  %1 = load double, double* %N2.addr, align 8
  %cmp = fcmp olt double %0, %1
  br i1 %cmp, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  %2 = load double, double* %N1.addr, align 8
  store double %2, double* %retval, align 8
  br label %return

if.else:                                          ; preds = %entry
  %3 = load double, double* %N2.addr, align 8
  store double %3, double* %retval, align 8
  br label %return

return:                                           ; preds = %if.else, %if.then
  %4 = load double, double* %retval, align 8
  ret double %4
}

; Function Attrs: noinline nounwind optnone
define hidden double* @p_adjust(double* noalias %PVALUES, i32 %NO_OF_ARRAY_ELEMENTS, i8* noalias %STRING) #0 {
entry:
  %retval = alloca double*, align 4
  %PVALUES.addr = alloca double*, align 4
  %NO_OF_ARRAY_ELEMENTS.addr = alloca i32, align 4
  %STRING.addr = alloca i8*, align 4
  %TYPE = alloca i16, align 2
  %bonferroni = alloca double*, align 4
  %index = alloca i32, align 4
  %BONFERRONI = alloca double, align 8
  %o = alloca i32*, align 4
  %o2double = alloca double*, align 4
  %cummax_input = alloca double*, align 4
  %index80 = alloca i32, align 4
  %ro = alloca i32*, align 4
  %cummax_output = alloca double*, align 4
  %pmin = alloca double*, align 4
  %qvalues = alloca double*, align 4
  %index98 = alloca i32, align 4
  %o114 = alloca i32*, align 4
  %p = alloca double*, align 4
  %index123 = alloca i32, align 4
  %o2double134 = alloca double*, align 4
  %ro136 = alloca i32*, align 4
  %q = alloca double*, align 4
  %pa = alloca double*, align 4
  %min = alloca double, align 8
  %index155 = alloca i32, align 4
  %TEMP = alloca double, align 8
  %index171 = alloca i32, align 4
  %j = alloca i32, align 4
  %ij = alloca i32*, align 4
  %I2_LENGTH = alloca i32, align 4
  %i2 = alloca i32*, align 4
  %i = alloca i32, align 4
  %q1 = alloca double, align 8
  %i208 = alloca i32, align 4
  %TEMP_Q1 = alloca double, align 8
  %i227 = alloca i32, align 4
  %i244 = alloca i32, align 4
  %i256 = alloca i32, align 4
  %index274 = alloca i32, align 4
  %o288 = alloca i32*, align 4
  %o_double = alloca double*, align 4
  %index296 = alloca i32, align 4
  %ro315 = alloca i32*, align 4
  %cummin_input = alloca double*, align 4
  %index328 = alloca i32, align 4
  %NI = alloca double, align 8
  %q349 = alloca double, align 8
  %index350 = alloca i32, align 4
  %index362 = alloca i32, align 4
  %NI367 = alloca double, align 8
  %index385 = alloca i32, align 4
  %cummin_array = alloca double*, align 4
  %pmin403 = alloca double*, align 4
  %q_array = alloca double*, align 4
  %index407 = alloca i32, align 4
  store double* %PVALUES, double** %PVALUES.addr, align 4
  store i32 %NO_OF_ARRAY_ELEMENTS, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
  store i8* %STRING, i8** %STRING.addr, align 4
  %0 = load i32, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
  %cmp = icmp ult i32 %0, 1
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %call = call i32 @puts(i8* getelementptr inbounds ([41 x i8], [41 x i8]* @.str.13, i32 0, i32 0))
  %call1 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([22 x i8], [22 x i8]* @.str.5, i32 0, i32 0), i8* getelementptr inbounds ([23 x i8], [23 x i8]* @.str.1, i32 0, i32 0), i32 217)
  call void @exit(i32 1) #5
  unreachable

if.end:                                           ; preds = %entry
  store i16 -1, i16* %TYPE, align 2
  %1 = load i8*, i8** %STRING.addr, align 4
  %cmp2 = icmp eq i8* %1, null
  br i1 %cmp2, label %if.then3, label %if.else

if.then3:                                         ; preds = %if.end
  store i16 0, i16* %TYPE, align 2
  br label %if.end41

if.else:                                          ; preds = %if.end
  %2 = load i8*, i8** %STRING.addr, align 4
  %call4 = call i32 @strcasecmp(i8* %2, i8* getelementptr inbounds ([3 x i8], [3 x i8]* @.str.14, i32 0, i32 0))
  %cmp5 = icmp eq i32 %call4, 0
  br i1 %cmp5, label %if.then6, label %if.else7

if.then6:                                         ; preds = %if.else
  store i16 0, i16* %TYPE, align 2
  br label %if.end40

if.else7:                                         ; preds = %if.else
  %3 = load i8*, i8** %STRING.addr, align 4
  %call8 = call i32 @strcasecmp(i8* %3, i8* getelementptr inbounds ([4 x i8], [4 x i8]* @.str.15, i32 0, i32 0))
  %cmp9 = icmp eq i32 %call8, 0
  br i1 %cmp9, label %if.then10, label %if.else11

if.then10:                                        ; preds = %if.else7
  store i16 0, i16* %TYPE, align 2
  br label %if.end39

if.else11:                                        ; preds = %if.else7
  %4 = load i8*, i8** %STRING.addr, align 4
  %call12 = call i32 @strcasecmp(i8* %4, i8* getelementptr inbounds ([3 x i8], [3 x i8]* @.str.16, i32 0, i32 0))
  %cmp13 = icmp eq i32 %call12, 0
  br i1 %cmp13, label %if.then14, label %if.else15

if.then14:                                        ; preds = %if.else11
  store i16 1, i16* %TYPE, align 2
  br label %if.end38

if.else15:                                        ; preds = %if.else11
  %5 = load i8*, i8** %STRING.addr, align 4
  %call16 = call i32 @strcasecmp(i8* %5, i8* getelementptr inbounds ([11 x i8], [11 x i8]* @.str.17, i32 0, i32 0))
  %cmp17 = icmp eq i32 %call16, 0
  br i1 %cmp17, label %if.then18, label %if.else19

if.then18:                                        ; preds = %if.else15
  store i16 2, i16* %TYPE, align 2
  br label %if.end37

if.else19:                                        ; preds = %if.else15
  %6 = load i8*, i8** %STRING.addr, align 4
  %call20 = call i32 @strcasecmp(i8* %6, i8* getelementptr inbounds ([9 x i8], [9 x i8]* @.str.18, i32 0, i32 0))
  %cmp21 = icmp eq i32 %call20, 0
  br i1 %cmp21, label %if.then22, label %if.else23

if.then22:                                        ; preds = %if.else19
  store i16 3, i16* %TYPE, align 2
  br label %if.end36

if.else23:                                        ; preds = %if.else19
  %7 = load i8*, i8** %STRING.addr, align 4
  %call24 = call i32 @strcasecmp(i8* %7, i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.19, i32 0, i32 0))
  %cmp25 = icmp eq i32 %call24, 0
  br i1 %cmp25, label %if.then26, label %if.else27

if.then26:                                        ; preds = %if.else23
  store i16 4, i16* %TYPE, align 2
  br label %if.end35

if.else27:                                        ; preds = %if.else23
  %8 = load i8*, i8** %STRING.addr, align 4
  %call28 = call i32 @strcasecmp(i8* %8, i8* getelementptr inbounds ([7 x i8], [7 x i8]* @.str.20, i32 0, i32 0))
  %cmp29 = icmp eq i32 %call28, 0
  br i1 %cmp29, label %if.then30, label %if.else31

if.then30:                                        ; preds = %if.else27
  store i16 5, i16* %TYPE, align 2
  br label %if.end34

if.else31:                                        ; preds = %if.else27
  %9 = load i8*, i8** %STRING.addr, align 4
  %call32 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([44 x i8], [44 x i8]* @.str.21, i32 0, i32 0), i8* %9)
  %call33 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([22 x i8], [22 x i8]* @.str.5, i32 0, i32 0), i8* getelementptr inbounds ([23 x i8], [23 x i8]* @.str.1, i32 0, i32 0), i32 239)
  call void @exit(i32 1) #5
  unreachable

if.end34:                                         ; preds = %if.then30
  br label %if.end35

if.end35:                                         ; preds = %if.end34, %if.then26
  br label %if.end36

if.end36:                                         ; preds = %if.end35, %if.then22
  br label %if.end37

if.end37:                                         ; preds = %if.end36, %if.then18
  br label %if.end38

if.end38:                                         ; preds = %if.end37, %if.then14
  br label %if.end39

if.end39:                                         ; preds = %if.end38, %if.then10
  br label %if.end40

if.end40:                                         ; preds = %if.end39, %if.then6
  br label %if.end41

if.end41:                                         ; preds = %if.end40, %if.then3
  %10 = load i16, i16* %TYPE, align 2
  %conv = sext i16 %10 to i32
  %cmp42 = icmp eq i32 %conv, 2
  br i1 %cmp42, label %if.then44, label %if.else71

if.then44:                                        ; preds = %if.end41
  %11 = load i32, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
  %mul = mul i32 8, %11
  %call45 = call noalias i8* @malloc(i32 %mul)
  %12 = bitcast i8* %call45 to double*
  store double* %12, double** %bonferroni, align 4
  %13 = load double*, double** %bonferroni, align 4
  %cmp46 = icmp eq double* %13, null
  br i1 %cmp46, label %if.then48, label %if.end50

if.then48:                                        ; preds = %if.then44
  %call49 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([33 x i8], [33 x i8]* @.str.3, i32 0, i32 0), i8* getelementptr inbounds ([23 x i8], [23 x i8]* @.str.1, i32 0, i32 0), i32 247)
  call void @perror(i8* getelementptr inbounds ([1 x i8], [1 x i8]* @.str.2, i32 0, i32 0))
  call void @exit(i32 1) #5
  unreachable

if.end50:                                         ; preds = %if.then44
  store i32 0, i32* %index, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.end50
  %14 = load i32, i32* %index, align 4
  %15 = load i32, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
  %cmp51 = icmp ult i32 %14, %15
  br i1 %cmp51, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %16 = load double*, double** %PVALUES.addr, align 4
  %17 = load i32, i32* %index, align 4
  %arrayidx = getelementptr inbounds double, double* %16, i32 %17
  %18 = load double, double* %arrayidx, align 8
  %19 = load i32, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
  %conv53 = uitofp i32 %19 to double
  %mul54 = fmul double %18, %conv53
  store double %mul54, double* %BONFERRONI, align 8
  %20 = load double, double* %BONFERRONI, align 8
  %cmp55 = fcmp oge double %20, 1.000000e+00
  br i1 %cmp55, label %if.then57, label %if.else59

if.then57:                                        ; preds = %for.body
  %21 = load double*, double** %bonferroni, align 4
  %22 = load i32, i32* %index, align 4
  %arrayidx58 = getelementptr inbounds double, double* %21, i32 %22
  store double 1.000000e+00, double* %arrayidx58, align 8
  br label %if.end70

if.else59:                                        ; preds = %for.body
  %23 = load double, double* %BONFERRONI, align 8
  %cmp60 = fcmp ole double 0.000000e+00, %23
  br i1 %cmp60, label %land.lhs.true, label %if.else66

land.lhs.true:                                    ; preds = %if.else59
  %24 = load double, double* %BONFERRONI, align 8
  %cmp62 = fcmp olt double %24, 1.000000e+00
  br i1 %cmp62, label %if.then64, label %if.else66

if.then64:                                        ; preds = %land.lhs.true
  %25 = load double, double* %BONFERRONI, align 8
  %26 = load double*, double** %bonferroni, align 4
  %27 = load i32, i32* %index, align 4
  %arrayidx65 = getelementptr inbounds double, double* %26, i32 %27
  store double %25, double* %arrayidx65, align 8
  br label %if.end69

if.else66:                                        ; preds = %land.lhs.true, %if.else59
  %28 = load double, double* %BONFERRONI, align 8
  %call67 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([42 x i8], [42 x i8]* @.str.22, i32 0, i32 0), double %28)
  %call68 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([23 x i8], [23 x i8]* @.str.23, i32 0, i32 0), i8* getelementptr inbounds ([23 x i8], [23 x i8]* @.str.1, i32 0, i32 0), i32 259)
  call void @exit(i32 1) #5
  unreachable

if.end69:                                         ; preds = %if.then64
  br label %if.end70

if.end70:                                         ; preds = %if.end69, %if.then57
  br label %for.inc

for.inc:                                          ; preds = %if.end70
  %29 = load i32, i32* %index, align 4
  %inc = add i32 %29, 1
  store i32 %inc, i32* %index, align 4
  br label %for.cond

for.end:                                          ; preds = %for.cond
  %30 = load double*, double** %bonferroni, align 4
  store double* %30, double** %retval, align 4
  br label %return

if.else71:                                        ; preds = %if.end41
  %31 = load i16, i16* %TYPE, align 2
  %conv72 = sext i16 %31 to i32
  %cmp73 = icmp eq i32 %conv72, 4
  br i1 %cmp73, label %if.then75, label %if.else109

if.then75:                                        ; preds = %if.else71
  %32 = load double*, double** %PVALUES.addr, align 4
  %33 = load i32, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
  %call76 = call i32* @order(double* %32, i32 %33, i1 zeroext false)
  store i32* %call76, i32** %o, align 4
  %34 = load i32*, i32** %o, align 4
  %35 = load i32, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
  %call77 = call double* @uint2double(i32* %34, i32 %35)
  store double* %call77, double** %o2double, align 4
  %36 = load i32, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
  %mul78 = mul i32 8, %36
  %call79 = call noalias i8* @malloc(i32 %mul78)
  %37 = bitcast i8* %call79 to double*
  store double* %37, double** %cummax_input, align 4
  store i32 0, i32* %index80, align 4
  br label %for.cond81

for.cond81:                                       ; preds = %for.inc90, %if.then75
  %38 = load i32, i32* %index80, align 4
  %39 = load i32, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
  %cmp82 = icmp ult i32 %38, %39
  br i1 %cmp82, label %for.body84, label %for.end92

for.body84:                                       ; preds = %for.cond81
  %40 = load i32, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
  %41 = load i32, i32* %index80, align 4
  %sub = sub i32 %40, %41
  %conv85 = uitofp i32 %sub to double
  %42 = load double*, double** %PVALUES.addr, align 4
  %43 = load i32*, i32** %o, align 4
  %44 = load i32, i32* %index80, align 4
  %arrayidx86 = getelementptr inbounds i32, i32* %43, i32 %44
  %45 = load i32, i32* %arrayidx86, align 4
  %arrayidx87 = getelementptr inbounds double, double* %42, i32 %45
  %46 = load double, double* %arrayidx87, align 8
  %mul88 = fmul double %conv85, %46
  %47 = load double*, double** %cummax_input, align 4
  %48 = load i32, i32* %index80, align 4
  %arrayidx89 = getelementptr inbounds double, double* %47, i32 %48
  store double %mul88, double* %arrayidx89, align 8
  br label %for.inc90

for.inc90:                                        ; preds = %for.body84
  %49 = load i32, i32* %index80, align 4
  %inc91 = add i32 %49, 1
  store i32 %inc91, i32* %index80, align 4
  br label %for.cond81

for.end92:                                        ; preds = %for.cond81
  %50 = load i32*, i32** %o, align 4
  %51 = bitcast i32* %50 to i8*
  call void @free(i8* %51)
  store i32* null, i32** %o, align 4
  %52 = load double*, double** %o2double, align 4
  %53 = load i32, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
  %call93 = call i32* @order(double* %52, i32 %53, i1 zeroext false)
  store i32* %call93, i32** %ro, align 4
  %54 = load double*, double** %o2double, align 4
  %55 = bitcast double* %54 to i8*
  call void @free(i8* %55)
  store double* null, double** %o2double, align 4
  %56 = load double*, double** %cummax_input, align 4
  %57 = load i32, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
  %call94 = call double* @cummax(double* %56, i32 %57)
  store double* %call94, double** %cummax_output, align 4
  %58 = load double*, double** %cummax_input, align 4
  %59 = bitcast double* %58 to i8*
  call void @free(i8* %59)
  store double* null, double** %cummax_input, align 4
  %60 = load double*, double** %cummax_output, align 4
  %61 = load i32, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
  %call95 = call double* @pminx(double* %60, i32 %61, double 1.000000e+00)
  store double* %call95, double** %pmin, align 4
  %62 = load double*, double** %cummax_output, align 4
  %63 = bitcast double* %62 to i8*
  call void @free(i8* %63)
  store double* null, double** %cummax_output, align 4
  %64 = load i32, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
  %mul96 = mul i32 8, %64
  %call97 = call noalias i8* @malloc(i32 %mul96)
  %65 = bitcast i8* %call97 to double*
  store double* %65, double** %qvalues, align 4
  store i32 0, i32* %index98, align 4
  br label %for.cond99

for.cond99:                                       ; preds = %for.inc106, %for.end92
  %66 = load i32, i32* %index98, align 4
  %67 = load i32, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
  %cmp100 = icmp ult i32 %66, %67
  br i1 %cmp100, label %for.body102, label %for.end108

for.body102:                                      ; preds = %for.cond99
  %68 = load double*, double** %pmin, align 4
  %69 = load i32*, i32** %ro, align 4
  %70 = load i32, i32* %index98, align 4
  %arrayidx103 = getelementptr inbounds i32, i32* %69, i32 %70
  %71 = load i32, i32* %arrayidx103, align 4
  %arrayidx104 = getelementptr inbounds double, double* %68, i32 %71
  %72 = load double, double* %arrayidx104, align 8
  %73 = load double*, double** %qvalues, align 4
  %74 = load i32, i32* %index98, align 4
  %arrayidx105 = getelementptr inbounds double, double* %73, i32 %74
  store double %72, double* %arrayidx105, align 8
  br label %for.inc106

for.inc106:                                       ; preds = %for.body102
  %75 = load i32, i32* %index98, align 4
  %inc107 = add i32 %75, 1
  store i32 %inc107, i32* %index98, align 4
  br label %for.cond99

for.end108:                                       ; preds = %for.cond99
  %76 = load double*, double** %pmin, align 4
  %77 = bitcast double* %76 to i8*
  call void @free(i8* %77)
  store double* null, double** %pmin, align 4
  %78 = load i32*, i32** %ro, align 4
  %79 = bitcast i32* %78 to i8*
  call void @free(i8* %79)
  store i32* null, i32** %ro, align 4
  %80 = load double*, double** %qvalues, align 4
  store double* %80, double** %retval, align 4
  br label %return

if.else109:                                       ; preds = %if.else71
  %81 = load i16, i16* %TYPE, align 2
  %conv110 = sext i16 %81 to i32
  %cmp111 = icmp eq i32 %conv110, 5
  br i1 %cmp111, label %if.then113, label %if.end285

if.then113:                                       ; preds = %if.else109
  %82 = load double*, double** %PVALUES.addr, align 4
  %83 = load i32, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
  %call115 = call i32* @order(double* %82, i32 %83, i1 zeroext false)
  store i32* %call115, i32** %o114, align 4
  %84 = load i32, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
  %mul116 = mul i32 8, %84
  %call117 = call noalias i8* @malloc(i32 %mul116)
  %85 = bitcast i8* %call117 to double*
  store double* %85, double** %p, align 4
  %86 = load double*, double** %p, align 4
  %cmp118 = icmp eq double* %86, null
  br i1 %cmp118, label %if.then120, label %if.end122

if.then120:                                       ; preds = %if.then113
  %call121 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([33 x i8], [33 x i8]* @.str.3, i32 0, i32 0), i8* getelementptr inbounds ([23 x i8], [23 x i8]* @.str.1, i32 0, i32 0), i32 302)
  call void @perror(i8* getelementptr inbounds ([1 x i8], [1 x i8]* @.str.2, i32 0, i32 0))
  call void @exit(i32 1) #5
  unreachable

if.end122:                                        ; preds = %if.then113
  store i32 0, i32* %index123, align 4
  br label %for.cond124

for.cond124:                                      ; preds = %for.inc131, %if.end122
  %87 = load i32, i32* %index123, align 4
  %88 = load i32, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
  %cmp125 = icmp ult i32 %87, %88
  br i1 %cmp125, label %for.body127, label %for.end133

for.body127:                                      ; preds = %for.cond124
  %89 = load double*, double** %PVALUES.addr, align 4
  %90 = load i32*, i32** %o114, align 4
  %91 = load i32, i32* %index123, align 4
  %arrayidx128 = getelementptr inbounds i32, i32* %90, i32 %91
  %92 = load i32, i32* %arrayidx128, align 4
  %arrayidx129 = getelementptr inbounds double, double* %89, i32 %92
  %93 = load double, double* %arrayidx129, align 8
  %94 = load double*, double** %p, align 4
  %95 = load i32, i32* %index123, align 4
  %arrayidx130 = getelementptr inbounds double, double* %94, i32 %95
  store double %93, double* %arrayidx130, align 8
  br label %for.inc131

for.inc131:                                       ; preds = %for.body127
  %96 = load i32, i32* %index123, align 4
  %inc132 = add i32 %96, 1
  store i32 %inc132, i32* %index123, align 4
  br label %for.cond124

for.end133:                                       ; preds = %for.cond124
  %97 = load i32*, i32** %o114, align 4
  %98 = load i32, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
  %call135 = call double* @uint2double(i32* %97, i32 %98)
  store double* %call135, double** %o2double134, align 4
  %99 = load i32*, i32** %o114, align 4
  %100 = bitcast i32* %99 to i8*
  call void @free(i8* %100)
  store i32* null, i32** %o114, align 4
  %101 = load double*, double** %o2double134, align 4
  %102 = load i32, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
  %call137 = call i32* @order(double* %101, i32 %102, i1 zeroext false)
  store i32* %call137, i32** %ro136, align 4
  %103 = load double*, double** %o2double134, align 4
  %104 = bitcast double* %103 to i8*
  call void @free(i8* %104)
  store double* null, double** %o2double134, align 4
  %105 = load i32, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
  %mul138 = mul i32 8, %105
  %call139 = call noalias i8* @malloc(i32 %mul138)
  %106 = bitcast i8* %call139 to double*
  store double* %106, double** %q, align 4
  %107 = load double*, double** %q, align 4
  %cmp140 = icmp eq double* %107, null
  br i1 %cmp140, label %if.then142, label %if.end144

if.then142:                                       ; preds = %for.end133
  %call143 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([33 x i8], [33 x i8]* @.str.3, i32 0, i32 0), i8* getelementptr inbounds ([23 x i8], [23 x i8]* @.str.1, i32 0, i32 0), i32 318)
  call void @perror(i8* getelementptr inbounds ([1 x i8], [1 x i8]* @.str.2, i32 0, i32 0))
  call void @exit(i32 1) #5
  unreachable

if.end144:                                        ; preds = %for.end133
  %108 = load i32, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
  %mul145 = mul i32 8, %108
  %call146 = call noalias i8* @malloc(i32 %mul145)
  %109 = bitcast i8* %call146 to double*
  store double* %109, double** %pa, align 4
  %110 = load double*, double** %pa, align 4
  %cmp147 = icmp eq double* %110, null
  br i1 %cmp147, label %if.then149, label %if.end151

if.then149:                                       ; preds = %if.end144
  %call150 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([33 x i8], [33 x i8]* @.str.3, i32 0, i32 0), i8* getelementptr inbounds ([23 x i8], [23 x i8]* @.str.1, i32 0, i32 0), i32 324)
  call void @perror(i8* getelementptr inbounds ([1 x i8], [1 x i8]* @.str.2, i32 0, i32 0))
  call void @exit(i32 1) #5
  unreachable

if.end151:                                        ; preds = %if.end144
  %111 = load i32, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
  %conv152 = uitofp i32 %111 to double
  %112 = load double*, double** %p, align 4
  %arrayidx153 = getelementptr inbounds double, double* %112, i32 0
  %113 = load double, double* %arrayidx153, align 8
  %mul154 = fmul double %conv152, %113
  store double %mul154, double* %min, align 8
  store i32 1, i32* %index155, align 4
  br label %for.cond156

for.cond156:                                      ; preds = %for.inc168, %if.end151
  %114 = load i32, i32* %index155, align 4
  %115 = load i32, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
  %cmp157 = icmp ult i32 %114, %115
  br i1 %cmp157, label %for.body159, label %for.end170

for.body159:                                      ; preds = %for.cond156
  %116 = load i32, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
  %conv160 = uitofp i32 %116 to double
  %117 = load double*, double** %p, align 4
  %118 = load i32, i32* %index155, align 4
  %arrayidx161 = getelementptr inbounds double, double* %117, i32 %118
  %119 = load double, double* %arrayidx161, align 8
  %mul162 = fmul double %conv160, %119
  %120 = load i32, i32* %index155, align 4
  %add = add i32 1, %120
  %conv163 = uitofp i32 %add to double
  %div = fdiv double %mul162, %conv163
  store double %div, double* %TEMP, align 8
  %121 = load double, double* %TEMP, align 8
  %122 = load double, double* %min, align 8
  %cmp164 = fcmp olt double %121, %122
  br i1 %cmp164, label %if.then166, label %if.end167

if.then166:                                       ; preds = %for.body159
  %123 = load double, double* %TEMP, align 8
  store double %123, double* %min, align 8
  br label %if.end167

if.end167:                                        ; preds = %if.then166, %for.body159
  br label %for.inc168

for.inc168:                                       ; preds = %if.end167
  %124 = load i32, i32* %index155, align 4
  %inc169 = add i32 %124, 1
  store i32 %inc169, i32* %index155, align 4
  br label %for.cond156

for.end170:                                       ; preds = %for.cond156
  store i32 0, i32* %index171, align 4
  br label %for.cond172

for.cond172:                                      ; preds = %for.inc178, %for.end170
  %125 = load i32, i32* %index171, align 4
  %126 = load i32, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
  %cmp173 = icmp ult i32 %125, %126
  br i1 %cmp173, label %for.body175, label %for.end180

for.body175:                                      ; preds = %for.cond172
  %127 = load double, double* %min, align 8
  %128 = load double*, double** %pa, align 4
  %129 = load i32, i32* %index171, align 4
  %arrayidx176 = getelementptr inbounds double, double* %128, i32 %129
  store double %127, double* %arrayidx176, align 8
  %130 = load double, double* %min, align 8
  %131 = load double*, double** %q, align 4
  %132 = load i32, i32* %index171, align 4
  %arrayidx177 = getelementptr inbounds double, double* %131, i32 %132
  store double %130, double* %arrayidx177, align 8
  br label %for.inc178

for.inc178:                                       ; preds = %for.body175
  %133 = load i32, i32* %index171, align 4
  %inc179 = add i32 %133, 1
  store i32 %inc179, i32* %index171, align 4
  br label %for.cond172

for.end180:                                       ; preds = %for.cond172
  %134 = load i32, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
  %sub181 = sub i32 %134, 1
  store i32 %sub181, i32* %j, align 4
  br label %for.cond182

for.cond182:                                      ; preds = %for.inc272, %for.end180
  %135 = load i32, i32* %j, align 4
  %cmp183 = icmp uge i32 %135, 2
  br i1 %cmp183, label %for.body185, label %for.end273

for.body185:                                      ; preds = %for.cond182
  %136 = load i32, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
  %137 = load i32, i32* %j, align 4
  %sub186 = sub i32 %136, %137
  %call187 = call i32* @seq_len(i32 0, i32 %sub186)
  store i32* %call187, i32** %ij, align 4
  %138 = load i32, i32* %j, align 4
  %sub188 = sub i32 %138, 1
  store i32 %sub188, i32* %I2_LENGTH, align 4
  %139 = load i32, i32* %I2_LENGTH, align 4
  %mul189 = mul i32 %139, 4
  %call190 = call noalias i8* @malloc(i32 %mul189)
  %140 = bitcast i8* %call190 to i32*
  store i32* %140, i32** %i2, align 4
  store i32 0, i32* %i, align 4
  br label %for.cond191

for.cond191:                                      ; preds = %for.inc200, %for.body185
  %141 = load i32, i32* %i, align 4
  %142 = load i32, i32* %I2_LENGTH, align 4
  %cmp192 = icmp ult i32 %141, %142
  br i1 %cmp192, label %for.body194, label %for.end202

for.body194:                                      ; preds = %for.cond191
  %143 = load i32, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
  %144 = load i32, i32* %j, align 4
  %sub195 = sub i32 %143, %144
  %add196 = add i32 %sub195, 2
  %145 = load i32, i32* %i, align 4
  %add197 = add i32 %add196, %145
  %sub198 = sub i32 %add197, 1
  %146 = load i32*, i32** %i2, align 4
  %147 = load i32, i32* %i, align 4
  %arrayidx199 = getelementptr inbounds i32, i32* %146, i32 %147
  store i32 %sub198, i32* %arrayidx199, align 4
  br label %for.inc200

for.inc200:                                       ; preds = %for.body194
  %148 = load i32, i32* %i, align 4
  %inc201 = add i32 %148, 1
  store i32 %inc201, i32* %i, align 4
  br label %for.cond191

for.end202:                                       ; preds = %for.cond191
  %149 = load i32, i32* %j, align 4
  %conv203 = uitofp i32 %149 to double
  %150 = load double*, double** %p, align 4
  %151 = load i32*, i32** %i2, align 4
  %arrayidx204 = getelementptr inbounds i32, i32* %151, i32 0
  %152 = load i32, i32* %arrayidx204, align 4
  %arrayidx205 = getelementptr inbounds double, double* %150, i32 %152
  %153 = load double, double* %arrayidx205, align 8
  %mul206 = fmul double %conv203, %153
  %div207 = fdiv double %mul206, 2.000000e+00
  store double %div207, double* %q1, align 8
  store i32 1, i32* %i208, align 4
  br label %for.cond209

for.cond209:                                      ; preds = %for.inc224, %for.end202
  %154 = load i32, i32* %i208, align 4
  %155 = load i32, i32* %I2_LENGTH, align 4
  %cmp210 = icmp ult i32 %154, %155
  br i1 %cmp210, label %for.body212, label %for.end226

for.body212:                                      ; preds = %for.cond209
  %156 = load i32, i32* %j, align 4
  %conv213 = uitofp i32 %156 to double
  %157 = load double*, double** %p, align 4
  %158 = load i32*, i32** %i2, align 4
  %159 = load i32, i32* %i208, align 4
  %arrayidx214 = getelementptr inbounds i32, i32* %158, i32 %159
  %160 = load i32, i32* %arrayidx214, align 4
  %arrayidx215 = getelementptr inbounds double, double* %157, i32 %160
  %161 = load double, double* %arrayidx215, align 8
  %mul216 = fmul double %conv213, %161
  %162 = load i32, i32* %i208, align 4
  %add217 = add i32 2, %162
  %conv218 = uitofp i32 %add217 to double
  %div219 = fdiv double %mul216, %conv218
  store double %div219, double* %TEMP_Q1, align 8
  %163 = load double, double* %TEMP_Q1, align 8
  %164 = load double, double* %q1, align 8
  %cmp220 = fcmp olt double %163, %164
  br i1 %cmp220, label %if.then222, label %if.end223

if.then222:                                       ; preds = %for.body212
  %165 = load double, double* %TEMP_Q1, align 8
  store double %165, double* %q1, align 8
  br label %if.end223

if.end223:                                        ; preds = %if.then222, %for.body212
  br label %for.inc224

for.inc224:                                       ; preds = %if.end223
  %166 = load i32, i32* %i208, align 4
  %inc225 = add i32 %166, 1
  store i32 %inc225, i32* %i208, align 4
  br label %for.cond209

for.end226:                                       ; preds = %for.cond209
  store i32 0, i32* %i227, align 4
  br label %for.cond228

for.cond228:                                      ; preds = %for.inc241, %for.end226
  %167 = load i32, i32* %i227, align 4
  %168 = load i32, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
  %169 = load i32, i32* %j, align 4
  %sub229 = sub i32 %168, %169
  %add230 = add i32 %sub229, 1
  %cmp231 = icmp ult i32 %167, %add230
  br i1 %cmp231, label %for.body233, label %for.end243

for.body233:                                      ; preds = %for.cond228
  %170 = load i32, i32* %j, align 4
  %conv234 = uitofp i32 %170 to double
  %171 = load double*, double** %p, align 4
  %172 = load i32*, i32** %ij, align 4
  %173 = load i32, i32* %i227, align 4
  %arrayidx235 = getelementptr inbounds i32, i32* %172, i32 %173
  %174 = load i32, i32* %arrayidx235, align 4
  %arrayidx236 = getelementptr inbounds double, double* %171, i32 %174
  %175 = load double, double* %arrayidx236, align 8
  %mul237 = fmul double %conv234, %175
  %176 = load double, double* %q1, align 8
  %call238 = call double @min2(double %mul237, double %176)
  %177 = load double*, double** %q, align 4
  %178 = load i32*, i32** %ij, align 4
  %179 = load i32, i32* %i227, align 4
  %arrayidx239 = getelementptr inbounds i32, i32* %178, i32 %179
  %180 = load i32, i32* %arrayidx239, align 4
  %arrayidx240 = getelementptr inbounds double, double* %177, i32 %180
  store double %call238, double* %arrayidx240, align 8
  br label %for.inc241

for.inc241:                                       ; preds = %for.body233
  %181 = load i32, i32* %i227, align 4
  %inc242 = add i32 %181, 1
  store i32 %inc242, i32* %i227, align 4
  br label %for.cond228

for.end243:                                       ; preds = %for.cond228
  %182 = load i32*, i32** %ij, align 4
  %183 = bitcast i32* %182 to i8*
  call void @free(i8* %183)
  store i32* null, i32** %ij, align 4
  store i32 0, i32* %i244, align 4
  br label %for.cond245

for.cond245:                                      ; preds = %for.inc253, %for.end243
  %184 = load i32, i32* %i244, align 4
  %185 = load i32, i32* %I2_LENGTH, align 4
  %cmp246 = icmp ult i32 %184, %185
  br i1 %cmp246, label %for.body248, label %for.end255

for.body248:                                      ; preds = %for.cond245
  %186 = load double*, double** %q, align 4
  %187 = load i32, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
  %188 = load i32, i32* %j, align 4
  %sub249 = sub i32 %187, %188
  %arrayidx250 = getelementptr inbounds double, double* %186, i32 %sub249
  %189 = load double, double* %arrayidx250, align 8
  %190 = load double*, double** %q, align 4
  %191 = load i32*, i32** %i2, align 4
  %192 = load i32, i32* %i244, align 4
  %arrayidx251 = getelementptr inbounds i32, i32* %191, i32 %192
  %193 = load i32, i32* %arrayidx251, align 4
  %arrayidx252 = getelementptr inbounds double, double* %190, i32 %193
  store double %189, double* %arrayidx252, align 8
  br label %for.inc253

for.inc253:                                       ; preds = %for.body248
  %194 = load i32, i32* %i244, align 4
  %inc254 = add i32 %194, 1
  store i32 %inc254, i32* %i244, align 4
  br label %for.cond245

for.end255:                                       ; preds = %for.cond245
  %195 = load i32*, i32** %i2, align 4
  %196 = bitcast i32* %195 to i8*
  call void @free(i8* %196)
  store i32* null, i32** %i2, align 4
  store i32 0, i32* %i256, align 4
  br label %for.cond257

for.cond257:                                      ; preds = %for.inc269, %for.end255
  %197 = load i32, i32* %i256, align 4
  %198 = load i32, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
  %cmp258 = icmp ult i32 %197, %198
  br i1 %cmp258, label %for.body260, label %for.end271

for.body260:                                      ; preds = %for.cond257
  %199 = load double*, double** %pa, align 4
  %200 = load i32, i32* %i256, align 4
  %arrayidx261 = getelementptr inbounds double, double* %199, i32 %200
  %201 = load double, double* %arrayidx261, align 8
  %202 = load double*, double** %q, align 4
  %203 = load i32, i32* %i256, align 4
  %arrayidx262 = getelementptr inbounds double, double* %202, i32 %203
  %204 = load double, double* %arrayidx262, align 8
  %cmp263 = fcmp olt double %201, %204
  br i1 %cmp263, label %if.then265, label %if.end268

if.then265:                                       ; preds = %for.body260
  %205 = load double*, double** %q, align 4
  %206 = load i32, i32* %i256, align 4
  %arrayidx266 = getelementptr inbounds double, double* %205, i32 %206
  %207 = load double, double* %arrayidx266, align 8
  %208 = load double*, double** %pa, align 4
  %209 = load i32, i32* %i256, align 4
  %arrayidx267 = getelementptr inbounds double, double* %208, i32 %209
  store double %207, double* %arrayidx267, align 8
  br label %if.end268

if.end268:                                        ; preds = %if.then265, %for.body260
  br label %for.inc269

for.inc269:                                       ; preds = %if.end268
  %210 = load i32, i32* %i256, align 4
  %inc270 = add i32 %210, 1
  store i32 %inc270, i32* %i256, align 4
  br label %for.cond257

for.end271:                                       ; preds = %for.cond257
  br label %for.inc272

for.inc272:                                       ; preds = %for.end271
  %211 = load i32, i32* %j, align 4
  %dec = add i32 %211, -1
  store i32 %dec, i32* %j, align 4
  br label %for.cond182

for.end273:                                       ; preds = %for.cond182
  %212 = load double*, double** %p, align 4
  %213 = bitcast double* %212 to i8*
  call void @free(i8* %213)
  store double* null, double** %p, align 4
  store i32 0, i32* %index274, align 4
  br label %for.cond275

for.cond275:                                      ; preds = %for.inc282, %for.end273
  %214 = load i32, i32* %index274, align 4
  %215 = load i32, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
  %cmp276 = icmp ult i32 %214, %215
  br i1 %cmp276, label %for.body278, label %for.end284

for.body278:                                      ; preds = %for.cond275
  %216 = load double*, double** %pa, align 4
  %217 = load i32*, i32** %ro136, align 4
  %218 = load i32, i32* %index274, align 4
  %arrayidx279 = getelementptr inbounds i32, i32* %217, i32 %218
  %219 = load i32, i32* %arrayidx279, align 4
  %arrayidx280 = getelementptr inbounds double, double* %216, i32 %219
  %220 = load double, double* %arrayidx280, align 8
  %221 = load double*, double** %q, align 4
  %222 = load i32, i32* %index274, align 4
  %arrayidx281 = getelementptr inbounds double, double* %221, i32 %222
  store double %220, double* %arrayidx281, align 8
  br label %for.inc282

for.inc282:                                       ; preds = %for.body278
  %223 = load i32, i32* %index274, align 4
  %inc283 = add i32 %223, 1
  store i32 %inc283, i32* %index274, align 4
  br label %for.cond275

for.end284:                                       ; preds = %for.cond275
  %224 = load i32*, i32** %ro136, align 4
  %225 = bitcast i32* %224 to i8*
  call void @free(i8* %225)
  store i32* null, i32** %ro136, align 4
  %226 = load double*, double** %pa, align 4
  %227 = bitcast double* %226 to i8*
  call void @free(i8* %227)
  store double* null, double** %pa, align 4
  %228 = load double*, double** %q, align 4
  store double* %228, double** %retval, align 4
  br label %return

if.end285:                                        ; preds = %if.else109
  br label %if.end286

if.end286:                                        ; preds = %if.end285
  br label %if.end287

if.end287:                                        ; preds = %if.end286
  %229 = load double*, double** %PVALUES.addr, align 4
  %230 = load i32, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
  %call289 = call i32* @order(double* %229, i32 %230, i1 zeroext true)
  store i32* %call289, i32** %o288, align 4
  %231 = load i32*, i32** %o288, align 4
  %cmp290 = icmp eq i32* %231, null
  br i1 %cmp290, label %if.then292, label %if.end294

if.then292:                                       ; preds = %if.end287
  %call293 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([33 x i8], [33 x i8]* @.str.3, i32 0, i32 0), i8* getelementptr inbounds ([23 x i8], [23 x i8]* @.str.1, i32 0, i32 0), i32 398)
  call void @perror(i8* getelementptr inbounds ([1 x i8], [1 x i8]* @.str.2, i32 0, i32 0))
  call void @exit(i32 1) #5
  unreachable

if.end294:                                        ; preds = %if.end287
  %232 = load i32*, i32** %o288, align 4
  %233 = load i32, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
  %call295 = call double* @uint2double(i32* %232, i32 %233)
  store double* %call295, double** %o_double, align 4
  store i32 0, i32* %index296, align 4
  br label %for.cond297

for.cond297:                                      ; preds = %for.inc312, %if.end294
  %234 = load i32, i32* %index296, align 4
  %235 = load i32, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
  %cmp298 = icmp ult i32 %234, %235
  br i1 %cmp298, label %for.body300, label %for.end314

for.body300:                                      ; preds = %for.cond297
  %236 = load double*, double** %PVALUES.addr, align 4
  %237 = load i32, i32* %index296, align 4
  %arrayidx301 = getelementptr inbounds double, double* %236, i32 %237
  %238 = load double, double* %arrayidx301, align 8
  %cmp302 = fcmp olt double %238, 0.000000e+00
  br i1 %cmp302, label %if.then307, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %for.body300
  %239 = load double*, double** %PVALUES.addr, align 4
  %240 = load i32, i32* %index296, align 4
  %arrayidx304 = getelementptr inbounds double, double* %239, i32 %240
  %241 = load double, double* %arrayidx304, align 8
  %cmp305 = fcmp ogt double %241, 1.000000e+00
  br i1 %cmp305, label %if.then307, label %if.end311

if.then307:                                       ; preds = %lor.lhs.false, %for.body300
  %242 = load i32, i32* %index296, align 4
  %243 = load double*, double** %PVALUES.addr, align 4
  %244 = load i32, i32* %index296, align 4
  %arrayidx308 = getelementptr inbounds double, double* %243, i32 %244
  %245 = load double, double* %arrayidx308, align 8
  %call309 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([54 x i8], [54 x i8]* @.str.24, i32 0, i32 0), i32 %242, double %245)
  %call310 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([20 x i8], [20 x i8]* @.str.25, i32 0, i32 0), i8* getelementptr inbounds ([23 x i8], [23 x i8]* @.str.1, i32 0, i32 0), i32 406)
  call void @exit(i32 1) #5
  unreachable

if.end311:                                        ; preds = %lor.lhs.false
  br label %for.inc312

for.inc312:                                       ; preds = %if.end311
  %246 = load i32, i32* %index296, align 4
  %inc313 = add i32 %246, 1
  store i32 %inc313, i32* %index296, align 4
  br label %for.cond297

for.end314:                                       ; preds = %for.cond297
  %247 = load double*, double** %o_double, align 4
  %248 = load i32, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
  %call316 = call i32* @order(double* %247, i32 %248, i1 zeroext false)
  store i32* %call316, i32** %ro315, align 4
  %249 = load i32*, i32** %ro315, align 4
  %cmp317 = icmp eq i32* %249, null
  br i1 %cmp317, label %if.then319, label %if.end321

if.then319:                                       ; preds = %for.end314
  %call320 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([33 x i8], [33 x i8]* @.str.3, i32 0, i32 0), i8* getelementptr inbounds ([23 x i8], [23 x i8]* @.str.1, i32 0, i32 0), i32 413)
  call void @perror(i8* getelementptr inbounds ([1 x i8], [1 x i8]* @.str.2, i32 0, i32 0))
  call void @exit(i32 1) #5
  unreachable

if.end321:                                        ; preds = %for.end314
  %250 = load double*, double** %o_double, align 4
  %251 = bitcast double* %250 to i8*
  call void @free(i8* %251)
  store double* null, double** %o_double, align 4
  %252 = load i32, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
  %mul322 = mul i32 8, %252
  %call323 = call noalias i8* @malloc(i32 %mul322)
  %253 = bitcast i8* %call323 to double*
  store double* %253, double** %cummin_input, align 4
  %254 = load i16, i16* %TYPE, align 2
  %conv324 = sext i16 %254 to i32
  %cmp325 = icmp eq i32 %conv324, 0
  br i1 %cmp325, label %if.then327, label %if.else344

if.then327:                                       ; preds = %if.end321
  store i32 0, i32* %index328, align 4
  br label %for.cond329

for.cond329:                                      ; preds = %for.inc341, %if.then327
  %255 = load i32, i32* %index328, align 4
  %256 = load i32, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
  %cmp330 = icmp ult i32 %255, %256
  br i1 %cmp330, label %for.body332, label %for.end343

for.body332:                                      ; preds = %for.cond329
  %257 = load i32, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
  %conv333 = uitofp i32 %257 to double
  %258 = load i32, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
  %259 = load i32, i32* %index328, align 4
  %sub334 = sub i32 %258, %259
  %conv335 = uitofp i32 %sub334 to double
  %div336 = fdiv double %conv333, %conv335
  store double %div336, double* %NI, align 8
  %260 = load double, double* %NI, align 8
  %261 = load double*, double** %PVALUES.addr, align 4
  %262 = load i32*, i32** %o288, align 4
  %263 = load i32, i32* %index328, align 4
  %arrayidx337 = getelementptr inbounds i32, i32* %262, i32 %263
  %264 = load i32, i32* %arrayidx337, align 4
  %arrayidx338 = getelementptr inbounds double, double* %261, i32 %264
  %265 = load double, double* %arrayidx338, align 8
  %mul339 = fmul double %260, %265
  %266 = load double*, double** %cummin_input, align 4
  %267 = load i32, i32* %index328, align 4
  %arrayidx340 = getelementptr inbounds double, double* %266, i32 %267
  store double %mul339, double* %arrayidx340, align 8
  br label %for.inc341

for.inc341:                                       ; preds = %for.body332
  %268 = load i32, i32* %index328, align 4
  %inc342 = add i32 %268, 1
  store i32 %inc342, i32* %index328, align 4
  br label %for.cond329

for.end343:                                       ; preds = %for.cond329
  br label %if.end401

if.else344:                                       ; preds = %if.end321
  %269 = load i16, i16* %TYPE, align 2
  %conv345 = sext i16 %269 to i32
  %cmp346 = icmp eq i32 %conv345, 1
  br i1 %cmp346, label %if.then348, label %if.else380

if.then348:                                       ; preds = %if.else344
  store double 1.000000e+00, double* %q349, align 8
  store i32 2, i32* %index350, align 4
  br label %for.cond351

for.cond351:                                      ; preds = %for.inc359, %if.then348
  %270 = load i32, i32* %index350, align 4
  %271 = load i32, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
  %add352 = add i32 1, %271
  %cmp353 = icmp ult i32 %270, %add352
  br i1 %cmp353, label %for.body355, label %for.end361

for.body355:                                      ; preds = %for.cond351
  %272 = load i32, i32* %index350, align 4
  %conv356 = uitofp i32 %272 to double
  %div357 = fdiv double 1.000000e+00, %conv356
  %273 = load double, double* %q349, align 8
  %add358 = fadd double %273, %div357
  store double %add358, double* %q349, align 8
  br label %for.inc359

for.inc359:                                       ; preds = %for.body355
  %274 = load i32, i32* %index350, align 4
  %inc360 = add i32 %274, 1
  store i32 %inc360, i32* %index350, align 4
  br label %for.cond351

for.end361:                                       ; preds = %for.cond351
  store i32 0, i32* %index362, align 4
  br label %for.cond363

for.cond363:                                      ; preds = %for.inc377, %for.end361
  %275 = load i32, i32* %index362, align 4
  %276 = load i32, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
  %cmp364 = icmp ult i32 %275, %276
  br i1 %cmp364, label %for.body366, label %for.end379

for.body366:                                      ; preds = %for.cond363
  %277 = load i32, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
  %conv368 = uitofp i32 %277 to double
  %278 = load i32, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
  %279 = load i32, i32* %index362, align 4
  %sub369 = sub i32 %278, %279
  %conv370 = uitofp i32 %sub369 to double
  %div371 = fdiv double %conv368, %conv370
  store double %div371, double* %NI367, align 8
  %280 = load double, double* %q349, align 8
  %281 = load double, double* %NI367, align 8
  %mul372 = fmul double %280, %281
  %282 = load double*, double** %PVALUES.addr, align 4
  %283 = load i32*, i32** %o288, align 4
  %284 = load i32, i32* %index362, align 4
  %arrayidx373 = getelementptr inbounds i32, i32* %283, i32 %284
  %285 = load i32, i32* %arrayidx373, align 4
  %arrayidx374 = getelementptr inbounds double, double* %282, i32 %285
  %286 = load double, double* %arrayidx374, align 8
  %mul375 = fmul double %mul372, %286
  %287 = load double*, double** %cummin_input, align 4
  %288 = load i32, i32* %index362, align 4
  %arrayidx376 = getelementptr inbounds double, double* %287, i32 %288
  store double %mul375, double* %arrayidx376, align 8
  br label %for.inc377

for.inc377:                                       ; preds = %for.body366
  %289 = load i32, i32* %index362, align 4
  %inc378 = add i32 %289, 1
  store i32 %inc378, i32* %index362, align 4
  br label %for.cond363

for.end379:                                       ; preds = %for.cond363
  br label %if.end400

if.else380:                                       ; preds = %if.else344
  %290 = load i16, i16* %TYPE, align 2
  %conv381 = sext i16 %290 to i32
  %cmp382 = icmp eq i32 %conv381, 3
  br i1 %cmp382, label %if.then384, label %if.end399

if.then384:                                       ; preds = %if.else380
  store i32 0, i32* %index385, align 4
  br label %for.cond386

for.cond386:                                      ; preds = %for.inc396, %if.then384
  %291 = load i32, i32* %index385, align 4
  %292 = load i32, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
  %cmp387 = icmp ult i32 %291, %292
  br i1 %cmp387, label %for.body389, label %for.end398

for.body389:                                      ; preds = %for.cond386
  %293 = load i32, i32* %index385, align 4
  %add390 = add i32 %293, 1
  %conv391 = uitofp i32 %add390 to double
  %294 = load double*, double** %PVALUES.addr, align 4
  %295 = load i32*, i32** %o288, align 4
  %296 = load i32, i32* %index385, align 4
  %arrayidx392 = getelementptr inbounds i32, i32* %295, i32 %296
  %297 = load i32, i32* %arrayidx392, align 4
  %arrayidx393 = getelementptr inbounds double, double* %294, i32 %297
  %298 = load double, double* %arrayidx393, align 8
  %mul394 = fmul double %conv391, %298
  %299 = load double*, double** %cummin_input, align 4
  %300 = load i32, i32* %index385, align 4
  %arrayidx395 = getelementptr inbounds double, double* %299, i32 %300
  store double %mul394, double* %arrayidx395, align 8
  br label %for.inc396

for.inc396:                                       ; preds = %for.body389
  %301 = load i32, i32* %index385, align 4
  %inc397 = add i32 %301, 1
  store i32 %inc397, i32* %index385, align 4
  br label %for.cond386

for.end398:                                       ; preds = %for.cond386
  br label %if.end399

if.end399:                                        ; preds = %for.end398, %if.else380
  br label %if.end400

if.end400:                                        ; preds = %if.end399, %for.end379
  br label %if.end401

if.end401:                                        ; preds = %if.end400, %for.end343
  %302 = load i32*, i32** %o288, align 4
  %303 = bitcast i32* %302 to i8*
  call void @free(i8* %303)
  store i32* null, i32** %o288, align 4
  store double* null, double** %cummin_array, align 4
  %304 = load double*, double** %cummin_input, align 4
  %305 = load i32, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
  %call402 = call double* @cummin(double* %304, i32 %305)
  store double* %call402, double** %cummin_array, align 4
  %306 = load double*, double** %cummin_input, align 4
  %307 = bitcast double* %306 to i8*
  call void @free(i8* %307)
  store double* null, double** %cummin_input, align 4
  %308 = load double*, double** %cummin_array, align 4
  %309 = load i32, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
  %call404 = call double* @pminx(double* %308, i32 %309, double 1.000000e+00)
  store double* %call404, double** %pmin403, align 4
  %310 = load double*, double** %cummin_array, align 4
  %311 = bitcast double* %310 to i8*
  call void @free(i8* %311)
  store double* null, double** %cummin_array, align 4
  %312 = load i32, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
  %mul405 = mul i32 %312, 8
  %call406 = call noalias i8* @malloc(i32 %mul405)
  %313 = bitcast i8* %call406 to double*
  store double* %313, double** %q_array, align 4
  store i32 0, i32* %index407, align 4
  br label %for.cond408

for.cond408:                                      ; preds = %for.inc415, %if.end401
  %314 = load i32, i32* %index407, align 4
  %315 = load i32, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
  %cmp409 = icmp ult i32 %314, %315
  br i1 %cmp409, label %for.body411, label %for.end417

for.body411:                                      ; preds = %for.cond408
  %316 = load double*, double** %pmin403, align 4
  %317 = load i32*, i32** %ro315, align 4
  %318 = load i32, i32* %index407, align 4
  %arrayidx412 = getelementptr inbounds i32, i32* %317, i32 %318
  %319 = load i32, i32* %arrayidx412, align 4
  %arrayidx413 = getelementptr inbounds double, double* %316, i32 %319
  %320 = load double, double* %arrayidx413, align 8
  %321 = load double*, double** %q_array, align 4
  %322 = load i32, i32* %index407, align 4
  %arrayidx414 = getelementptr inbounds double, double* %321, i32 %322
  store double %320, double* %arrayidx414, align 8
  br label %for.inc415

for.inc415:                                       ; preds = %for.body411
  %323 = load i32, i32* %index407, align 4
  %inc416 = add i32 %323, 1
  store i32 %inc416, i32* %index407, align 4
  br label %for.cond408

for.end417:                                       ; preds = %for.cond408
  %324 = load i32*, i32** %ro315, align 4
  %325 = bitcast i32* %324 to i8*
  call void @free(i8* %325)
  store i32* null, i32** %ro315, align 4
  %326 = load double*, double** %pmin403, align 4
  %327 = bitcast double* %326 to i8*
  call void @free(i8* %327)
  store double* null, double** %pmin403, align 4
  %328 = load double*, double** %q_array, align 4
  store double* %328, double** %retval, align 4
  br label %return

return:                                           ; preds = %for.end417, %for.end284, %for.end108, %for.end
  %329 = load double*, double** %retval, align 4
  ret double* %329
}

declare i32 @strcasecmp(i8* %0, i8* %1) #1

; Function Attrs: noinline nounwind optnone
define hidden i32 @main() #0 {
entry:
  %retval = alloca i32, align 4
  %PVALUES = alloca [50 x double], align 16
  %CORRECT_ANSWERS = alloca [6 x [50 x double]], align 16
  %TYPES = alloca [6 x i8*], align 16
  %type = alloca i16, align 2
  %q = alloca double*, align 4
  %error = alloca double, align 8
  %i = alloca i32, align 4
  %this_error = alloca double, align 8
  store i32 0, i32* %retval, align 4
  %0 = bitcast [50 x double]* %PVALUES to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 16 %0, i8* align 16 bitcast ([50 x double]* @__const.main.PVALUES to i8*), i32 400, i1 false)
  %1 = bitcast [6 x [50 x double]]* %CORRECT_ANSWERS to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 16 %1, i8* align 16 bitcast ([6 x [50 x double]]* @__const.main.CORRECT_ANSWERS to i8*), i32 2400, i1 false)
  %2 = bitcast [6 x i8*]* %TYPES to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 16 %2, i8* align 16 bitcast ([6 x i8*]* @__const.main.TYPES to i8*), i32 24, i1 false)
  store i16 0, i16* %type, align 2
  br label %for.cond

for.cond:                                         ; preds = %for.inc19, %entry
  %3 = load i16, i16* %type, align 2
  %conv = zext i16 %3 to i32
  %cmp = icmp sle i32 %conv, 5
  br i1 %cmp, label %for.body, label %for.end21

for.body:                                         ; preds = %for.cond
  %arraydecay = getelementptr inbounds [50 x double], [50 x double]* %PVALUES, i32 0, i32 0
  %4 = load i16, i16* %type, align 2
  %idxprom = zext i16 %4 to i32
  %arrayidx = getelementptr inbounds [6 x i8*], [6 x i8*]* %TYPES, i32 0, i32 %idxprom
  %5 = load i8*, i8** %arrayidx, align 4
  %call = call double* @p_adjust(double* %arraydecay, i32 50, i8* %5)
  store double* %call, double** %q, align 4
  %6 = load double*, double** %q, align 4
  %arrayidx2 = getelementptr inbounds double, double* %6, i32 0
  %7 = load double, double* %arrayidx2, align 8
  %8 = load i16, i16* %type, align 2
  %idxprom3 = zext i16 %8 to i32
  %arrayidx4 = getelementptr inbounds [6 x [50 x double]], [6 x [50 x double]]* %CORRECT_ANSWERS, i32 0, i32 %idxprom3
  %arrayidx5 = getelementptr inbounds [50 x double], [50 x double]* %arrayidx4, i32 0, i32 0
  %9 = load double, double* %arrayidx5, align 16
  %sub = fsub double %7, %9
  %10 = call double @llvm.fabs.f64(double %sub)
  store double %10, double* %error, align 8
  store i32 1, i32* %i, align 4
  br label %for.cond6

for.cond6:                                        ; preds = %for.inc, %for.body
  %11 = load i32, i32* %i, align 4
  %cmp7 = icmp ult i32 %11, 50
  br i1 %cmp7, label %for.body9, label %for.end

for.body9:                                        ; preds = %for.cond6
  %12 = load double*, double** %q, align 4
  %13 = load i32, i32* %i, align 4
  %arrayidx10 = getelementptr inbounds double, double* %12, i32 %13
  %14 = load double, double* %arrayidx10, align 8
  %15 = load i16, i16* %type, align 2
  %idxprom11 = zext i16 %15 to i32
  %arrayidx12 = getelementptr inbounds [6 x [50 x double]], [6 x [50 x double]]* %CORRECT_ANSWERS, i32 0, i32 %idxprom11
  %16 = load i32, i32* %i, align 4
  %arrayidx13 = getelementptr inbounds [50 x double], [50 x double]* %arrayidx12, i32 0, i32 %16
  %17 = load double, double* %arrayidx13, align 8
  %sub14 = fsub double %14, %17
  %18 = call double @llvm.fabs.f64(double %sub14)
  store double %18, double* %this_error, align 8
  %19 = load double, double* %this_error, align 8
  %20 = load double, double* %error, align 8
  %add = fadd double %20, %19
  store double %add, double* %error, align 8
  br label %for.inc

for.inc:                                          ; preds = %for.body9
  %21 = load i32, i32* %i, align 4
  %inc = add i32 %21, 1
  store i32 %inc, i32* %i, align 4
  br label %for.cond6

for.end:                                          ; preds = %for.cond6
  %22 = load double*, double** %q, align 4
  call void @double_say(double* %22, i32 50)
  %23 = load double*, double** %q, align 4
  %24 = bitcast double* %23 to i8*
  call void @free(i8* %24)
  store double* null, double** %q, align 4
  %25 = load i16, i16* %type, align 2
  %conv15 = zext i16 %25 to i32
  %26 = load i16, i16* %type, align 2
  %idxprom16 = zext i16 %26 to i32
  %arrayidx17 = getelementptr inbounds [6 x i8*], [6 x i8*]* %TYPES, i32 0, i32 %idxprom16
  %27 = load i8*, i8** %arrayidx17, align 4
  %28 = load double, double* %error, align 8
  %call18 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([44 x i8], [44 x i8]* @.str.28, i32 0, i32 0), i32 %conv15, i8* %27, double %28)
  br label %for.inc19

for.inc19:                                        ; preds = %for.end
  %29 = load i16, i16* %type, align 2
  %inc20 = add i16 %29, 1
  store i16 %inc20, i16* %type, align 2
  br label %for.cond

for.end21:                                        ; preds = %for.cond
  ret i32 0
}

; Function Attrs: argmemonly nounwind willreturn
declare void @llvm.memcpy.p0i8.p0i8.i32(i8* noalias nocapture writeonly %0, i8* noalias nocapture readonly %1, i32 %2, i1 immarg %3) #3

; Function Attrs: nounwind readnone speculatable willreturn
declare double @llvm.fabs.f64(double %0) #4

attributes #0 = { noinline nounwind optnone "correctly-rounded-divide-sqrt-fp-math"="false" "disable-tail-calls"="false" "frame-pointer"="none" "less-precise-fpmad"="false" "min-legal-vector-width"="0" "no-infs-fp-math"="false" "no-jump-tables"="false" "no-nans-fp-math"="false" "no-signed-zeros-fp-math"="false" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="generic" "unsafe-fp-math"="false" "use-soft-float"="false" }
attributes #1 = { "correctly-rounded-divide-sqrt-fp-math"="false" "disable-tail-calls"="false" "frame-pointer"="none" "less-precise-fpmad"="false" "no-infs-fp-math"="false" "no-nans-fp-math"="false" "no-signed-zeros-fp-math"="false" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="generic" "unsafe-fp-math"="false" "use-soft-float"="false" }
attributes #2 = { noreturn "correctly-rounded-divide-sqrt-fp-math"="false" "disable-tail-calls"="false" "frame-pointer"="none" "less-precise-fpmad"="false" "no-infs-fp-math"="false" "no-nans-fp-math"="false" "no-signed-zeros-fp-math"="false" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="generic" "unsafe-fp-math"="false" "use-soft-float"="false" }
attributes #3 = { argmemonly nounwind willreturn }
attributes #4 = { nounwind readnone speculatable willreturn }
attributes #5 = { noreturn }

!llvm.module.flags = !{!0}
!llvm.ident = !{!1}

!0 = !{i32 1, !"wchar_size", i32 4}
!1 = !{!"clang version 11.0.0 (https://github.com/Jacarte/llvm-project.git 0f6dea67136cc1e0b3d200eb2bb165628970c44b)"}

; extracted candidates

; *****
; For LLVM instruction:
;  %0 = load i32, i32* %START.addr, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %1 = load i32, i32* %END.addr, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %2 = load i32, i32* %START.addr, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %3 = load i32, i32* %END.addr, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %cmp = icmp eq i32 %2, %3
; Looking for a replacement for:
%0:i32 = var
%1:i32 = var
%2:i1 = eq %0, %1
infer %2

; *****
; For LLVM instruction:
;  %4 = load i32, i32* %end, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %add = add i32 %4, 1
; Looking for a replacement for:
%0:i32 = var
%1:i32 = add 1:i32, %0
infer %1

; *****
; For LLVM instruction:
;  %mul = mul i32 %add, 4
; Looking for a replacement for:
%0:i32 = var
%1:i32 = add 1:i32, %0
%2:i32 = mul 4:i32, %1
infer %2

; *****
; For LLVM instruction:
;  %cmp1 = icmp eq i32* %6, null
; Looking for a replacement for:
%0:i32 = var
%1:i1 = eq 0:i32, %0
infer %1

; *****
; For LLVM instruction:
;  %7 = load i32, i32* %i, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %8 = load i32, i32* %end, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %cmp4 = icmp ult i32 %7, %8
; Looking for a replacement for:
%0:i32 = var
%1:i32 = var
%2:i1 = ult %0, %1
infer %2

; *****
; For LLVM instruction:
;  %9 = load i32, i32* %i, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %add5 = add i32 %9, 1
; Looking for a replacement for:
%0:i32 = var
%1:i32 = add 1:i32, %0
infer %1

; *****
; For LLVM instruction:
;  %11 = load i32, i32* %i, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %12 = load i32, i32* %i, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %inc = add i32 %12, 1
; Looking for a replacement for:
%0:i32 = var
%1:i32 = add 1:i32, %0
infer %1

; *****
; For LLVM instruction:
;  %14 = load i32, i32* %START.addr, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %15 = load i32, i32* %END.addr, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %cmp7 = icmp ugt i32 %14, %15
; Looking for a replacement for:
%0:i32 = var
%1:i32 = var
%2:i1 = ult %0, %1
infer %2

; *****
; For LLVM instruction:
;  %16 = load i32, i32* %START.addr, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %17 = load i32, i32* %END.addr, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %18 = load i32, i32* %end, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %19 = load i32, i32* %start, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %sub = sub i32 %18, %19
; Looking for a replacement for:
%0:i32 = var
%1:i32 = var
%2:i32 = sub %0, %1
infer %2

; *****
; For LLVM instruction:
;  %20 = load i32, i32* %LENGTH, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %add11 = add i32 1, %20
; Looking for a replacement for:
%0:i32 = var
%1:i32 = add 1:i32, %0
infer %1

; *****
; For LLVM instruction:
;  %mul12 = mul i32 %add11, 4
; Looking for a replacement for:
%0:i32 = var
%1:i32 = add 1:i32, %0
%2:i32 = mul 4:i32, %1
infer %2

; *****
; For LLVM instruction:
;  %cmp14 = icmp eq i32* %22, null
; Looking for a replacement for:
%0:i32 = var
%1:i1 = eq 0:i32, %0
infer %1

; *****
; For LLVM instruction:
;  %23 = load i32, i32* %START.addr, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %24 = load i32, i32* %END.addr, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %cmp18 = icmp ult i32 %23, %24
; Looking for a replacement for:
%0:i32 = var
%1:i32 = var
%2:i1 = ult %0, %1
infer %2

; *****
; For LLVM instruction:
;  %25 = load i32, i32* %index, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %26 = load i32, i32* %LENGTH, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %cmp21 = icmp ule i32 %25, %26
; Looking for a replacement for:
%0:i32 = var
%1:i32 = var
%2:i1 = ule %0, %1
infer %2

; *****
; For LLVM instruction:
;  %27 = load i32, i32* %start, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %28 = load i32, i32* %index, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %add23 = add i32 %27, %28
; Looking for a replacement for:
%0:i32 = var
%1:i32 = var
%2:i32 = add %0, %1
infer %2

; *****
; For LLVM instruction:
;  %30 = load i32, i32* %index, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %31 = load i32, i32* %index, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %inc26 = add i32 %31, 1
; Looking for a replacement for:
%0:i32 = var
%1:i32 = add 1:i32, %0
infer %1

; *****
; For LLVM instruction:
;  %32 = load i32, i32* %index28, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %33 = load i32, i32* %LENGTH, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %cmp30 = icmp ule i32 %32, %33
; Looking for a replacement for:
%0:i32 = var
%1:i32 = var
%2:i1 = ule %0, %1
infer %2

; *****
; For LLVM instruction:
;  %34 = load i32, i32* %end, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %35 = load i32, i32* %index28, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %sub32 = sub i32 %34, %35
; Looking for a replacement for:
%0:i32 = var
%1:i32 = var
%2:i32 = sub %0, %1
infer %2

; *****
; For LLVM instruction:
;  %37 = load i32, i32* %index28, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %38 = load i32, i32* %index28, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %inc35 = add i32 %38, 1
; Looking for a replacement for:
%0:i32 = var
%1:i32 = add 1:i32, %0
infer %1
got 1 candidates from LHS

-------------------------------------------------
%0:i32 = var
infer %0


--------------------------------
guess 0

%0:i32 = var ; reservedconst_1

Cost = 0
first query is SAT, returning the model:
reservedconst_1: 0
0 th attempt: second query is SAT-- constant doesn't work
first query is SAT, returning the model:
reservedconst_1: -1
1 th attempt: second query is SAT-- constant doesn't work
first query is UNSAT-- no more guesses
Dataflow Pruned 0/0
There are 1 Guesses
There are 0 RHSs before deduplication
There are 0 RHSs after deduplication
got 3 candidates from LHS

-------------------------------------------------
%0:i32 = var
%1:i32 = var
%2:i1 = eq %0, %1
infer %2


--------------------------------
guess 0

%0:i1 = var ; reservedconst_1

Cost = 0
first query is SAT, returning the model:
reservedconst_1: -1
0 th attempt: second query is SAT-- constant doesn't work
first query is SAT, returning the model:
reservedconst_1: 0
1 th attempt: second query is SAT-- constant doesn't work
first query is UNSAT-- no more guesses
Dataflow Pruned 0/0
There are 1 Guesses
There are 0 RHSs before deduplication
There are 0 RHSs after deduplication
got 2 candidates from LHS

-------------------------------------------------
%0:i32 = var
%1:i32 = add 1:i32, %0
infer %1


--------------------------------
guess 0

%0:i32 = var ; reservedconst_1

Cost = 0
first query is SAT, returning the model:
reservedconst_1: 1
0 th attempt: second query is SAT-- constant doesn't work
first query is SAT, returning the model:
reservedconst_1: 0
1 th attempt: second query is SAT-- constant doesn't work
first query is UNSAT-- no more guesses

--------------------------------
guess 1

%0:i32 = var

Cost = 0
second query is SAT-- constant doesn't work
Dataflow Pruned 0/0
There are 2 Guesses
There are 0 RHSs before deduplication
There are 0 RHSs after deduplication
got 3 candidates from LHS

-------------------------------------------------
%0:i32 = var
%1:i32 = add 1:i32, %0
%2:i32 = mul 4:i32, %1
infer %2


--------------------------------
guess 0

%0:i32 = var ; reservedconst_1

Cost = 0
first query is SAT, returning the model:
reservedconst_1: 4
0 th attempt: second query is SAT-- constant doesn't work
first query is SAT, returning the model:
reservedconst_1: 1073741828
1 th attempt: second query is SAT-- constant doesn't work
first query is UNSAT-- no more guesses

--------------------------------
guess 1

%0:i32 = var

Cost = 0
second query is SAT-- constant doesn't work

--------------------------------
guess 2

%0:i32 = var
%1:i32 = add 1:i32, %0

Cost = 1
second query is SAT-- constant doesn't work
Dataflow Pruned 0/0
There are 3 Guesses
There are 0 RHSs before deduplication
There are 0 RHSs after deduplication
got 2 candidates from LHS

-------------------------------------------------
%0:i32 = var
%1:i1 = eq 0:i32, %0
infer %1


--------------------------------
guess 0

%0:i1 = var ; reservedconst_1

Cost = 0
first query is SAT, returning the model:
reservedconst_1: -1
0 th attempt: second query is SAT-- constant doesn't work
first query is SAT, returning the model:
reservedconst_1: 0
1 th attempt: second query is SAT-- constant doesn't work
first query is UNSAT-- no more guesses
Dataflow Pruned 0/0
There are 1 Guesses
There are 0 RHSs before deduplication
There are 0 RHSs after deduplication
got 3 candidates from LHS

-------------------------------------------------
%0:i32 = var
%1:i32 = var
%2:i1 = ult %0, %1
infer %2


--------------------------------
guess 0

%0:i1 = var ; reservedconst_1

Cost = 0
first query is SAT, returning the model:
reservedconst_1: 0
0 th attempt: second query is SAT-- constant doesn't work
first query is SAT, returning the model:
reservedconst_1: -1
1 th attempt: second query is SAT-- constant doesn't work
first query is UNSAT-- no more guesses
Dataflow Pruned 0/0
There are 1 Guesses
There are 0 RHSs before deduplication
There are 0 RHSs after deduplication
got 3 candidates from LHS

-------------------------------------------------
%0:i32 = var
%1:i32 = var
%2:i32 = sub %0, %1
infer %2


--------------------------------
guess 0

%0:i32 = var ; reservedconst_1

Cost = 0
first query is SAT, returning the model:
reservedconst_1: 0
0 th attempt: second query is SAT-- constant doesn't work
first query is SAT, returning the model:
reservedconst_1: -1
1 th attempt: second query is SAT-- constant doesn't work
first query is UNSAT-- no more guesses

--------------------------------
guess 1

%0:i32 = var

Cost = 0
second query is SAT-- constant doesn't work

--------------------------------
guess 2

%0:i32 = var

Cost = 0
second query is SAT-- constant doesn't work
Dataflow Pruned 0/0
There are 3 Guesses
There are 0 RHSs before deduplication
There are 0 RHSs after deduplication
got 3 candidates from LHS

-------------------------------------------------
%0:i32 = var
%1:i32 = var
%2:i1 = ule %0, %1
infer %2


--------------------------------
guess 0

%0:i1 = var ; reservedconst_1

Cost = 0
first query is SAT, returning the model:
reservedconst_1: -1
0 th attempt: second query is SAT-- constant doesn't work
first query is SAT, returning the model:
reservedconst_1: 0
1 th attempt: second query is SAT-- constant doesn't work
first query is UNSAT-- no more guesses
Dataflow Pruned 0/0
There are 1 Guesses
There are 0 RHSs before deduplication
There are 0 RHSs after deduplication
got 3 candidates from LHS

-------------------------------------------------
%0:i32 = var
%1:i32 = var
%2:i32 = add %0, %1
infer %2


--------------------------------
guess 0

%0:i32 = var ; reservedconst_1

Cost = 0
first query is SAT, returning the model:
reservedconst_1: 0
0 th attempt: second query is SAT-- constant doesn't work
first query is SAT, returning the model:
reservedconst_1: -1
1 th attempt: second query is SAT-- constant doesn't work
first query is UNSAT-- no more guesses

--------------------------------
guess 1

%0:i32 = var

Cost = 0
second query is SAT-- constant doesn't work

--------------------------------
guess 2

%0:i32 = var

Cost = 0
second query is SAT-- constant doesn't work
Dataflow Pruned 0/0
There are 3 Guesses
There are 0 RHSs before deduplication
There are 0 RHSs after deduplication
#########################################################
; exiting Souper's runOnFunction() for seq_len()

; entering Souper's runOnFunction() for order()

; ModuleID = './P-value_correction.c.bc'
source_filename = "./P-value_correction.c"
target datalayout = "e-m:e-p:32:32-i64:64-n32:64-S128"
target triple = "wasm32-unknown-wasi"

@.str = private unnamed_addr constant [29 x i8] c"malloc failed at %s line %u\0A\00", align 1
@.str.1 = private unnamed_addr constant [23 x i8] c"./P-value_correction.c\00", align 1
@.str.2 = private unnamed_addr constant [1 x i8] zeroinitializer, align 1
@base_arr = hidden global double* null, align 4
@.str.3 = private unnamed_addr constant [33 x i8] c"failed to malloc at %s line %u.\0A\00", align 1
@.str.4 = private unnamed_addr constant [48 x i8] c"cummin function requires at least one element.\0A\00", align 1
@.str.5 = private unnamed_addr constant [22 x i8] c"Failed at %s line %u\0A\00", align 1
@.str.6 = private unnamed_addr constant [41 x i8] c"function requires at least one element.\0A\00", align 1
@.str.7 = private unnamed_addr constant [37 x i8] c"pmin requires at least one element.\0A\00", align 1
@.str.8 = private unnamed_addr constant [7 x i8] c"[1] %e\00", align 1
@.str.9 = private unnamed_addr constant [7 x i8] c" %.10f\00", align 1
@.str.10 = private unnamed_addr constant [6 x i8] c"\0A[%u]\00", align 1
@.str.11 = private unnamed_addr constant [2 x i8] c"\0A\00", align 1
@.str.12 = private unnamed_addr constant [34 x i8] c"Failure to malloc at %s line %u.\0A\00", align 1
@.str.13 = private unnamed_addr constant [41 x i8] c"p_adjust requires at least one element.\0A\00", align 1
@.str.14 = private unnamed_addr constant [3 x i8] c"BH\00", align 1
@.str.15 = private unnamed_addr constant [4 x i8] c"fdr\00", align 1
@.str.16 = private unnamed_addr constant [3 x i8] c"by\00", align 1
@.str.17 = private unnamed_addr constant [11 x i8] c"Bonferroni\00", align 1
@.str.18 = private unnamed_addr constant [9 x i8] c"hochberg\00", align 1
@.str.19 = private unnamed_addr constant [5 x i8] c"holm\00", align 1
@.str.20 = private unnamed_addr constant [7 x i8] c"hommel\00", align 1
@.str.21 = private unnamed_addr constant [44 x i8] c"%s doesn't match any accepted FDR methods.\0A\00", align 1
@.str.22 = private unnamed_addr constant [42 x i8] c"%g is outside of the interval I planned.\0A\00", align 1
@.str.23 = private unnamed_addr constant [23 x i8] c"Failure at %s line %u\0A\00", align 1
@.str.24 = private unnamed_addr constant [54 x i8] c"array[%u] = %lf, which is outside the interval [0,1]\0A\00", align 1
@.str.25 = private unnamed_addr constant [20 x i8] c"died at %s line %u\0A\00", align 1
@__const.main.PVALUES = private unnamed_addr constant [50 x double] [double 0x3FDD04160F35FDE9, double 0x3FE758E721E2A8D7, double 0x3FB96FAC8B38D8BA, double 0x3FB73E71D5B04B37, double 0x3FC710AB48EE865B, double 0x3FEC01D953C3CC73, double 0x3FD2B3C4BE0A922A, double 0x3FED2B5A568DAB4F, double 0x3FDBE08D73F16964, double 0x3FE10A218C41C242, double 0x3FDF8810DB1996AA, double 0x3FE291CCB11E1A9D, double 0x3FD64E8C550D788F, double 7.883130e-01, double 0x3FD177B2BF048D2D, double 0x3FEB3543434BAF2B, double 0x3FDB50EAD41ED0A6, double 0x3FE49D4AFF01D33F, double 0x3FD364C9AE345B51, double 0x3FA99BA35F15394D, double 3.194810e-01, double 0x3FE941E405CE761A, double 0x3FEFF94F77369843, double 0x3FC65847BFB23217, double 0x3FECEB8879B6A543, double 0x3FBEAF00332BA677, double 0x3FD96207C7749E38, double 0x3F8CC02620502C93, double 0x3FE773A5B45A0F40, double 0x3FB1642C24762C01, double 4.040730e-03, double 0x3F33E11D79A90777, double 0x3F870B02BD749528, double 0x3F98521BD6A0353F, double 0x3F4310F26148FFAA, double 0x3F3427CD76006778, double 0x3F80E60AFB1F8A4E, double 0x3F5639B74A9E4DA2, double 0x3F8BDDF74195769F, double 0x3F38ABEE3BFA8581, double 0x3EF2E2E96B5466FE, double 0x3E90CE9F65B58A88, double 0x3FA0F2D097879B95, double 0x3F834EE7216A6684, double 0x3F4CCE8DBB40BD9D, double 0x3F2C8B969590F2ED, double 0x3F4FC31F7F1541AD, double 6.610250e-05, double 0x3F9DB44EA6AC26BA, double 5.735490e-03], align 16
@__const.main.CORRECT_ANSWERS = private unnamed_addr constant [6 x [50 x double]] [[50 x double] [double 0x3FE39AFA2199ADBC, double 8.521710e-01, double 0x3FC96FAC6045BAF5, double 0x3FC83660E51D25AB, double 0x3FD498068702BE20, double 0x3FEDC3BF727136A4, double 4.870370e-01, double 0x3FEDC3BF727136A4, double 0x3FE35BF08BEEB62C, double 0x3FE5D879DEE92F03, double 0x3FE4BE91D656B94A, double 0x3FE7363FC28DAEAA, double 0x3FE0E62C4F13638A, double 0x3FEC1052C8FAB035, double 0x3FDE1DD2E43E029A, double 0x3FED92EFFC7CBDC1, double 0x3FE35BF08BEEB62C, double 0x3FE923B90CFC67C5, double 0x3FDF47B8FC357024, double 0x3FBD1996A9FB10AD, double 0x3FDFF2B6D6C14255, double 0x3FEC1052C8FAB035, double 0x3FEFF94F77369843, double 0x3FD498068702BE20, double 0x3FEDC3BF727136A4, double 0x3FCD80E2E96EC403, double 0x3FE2A9F6A93F290B, double 0x3FA3F736D8AF2E2B, double 8.521710e-01, double 0x3FC2E751B350FAC4, double 0x3F913D8E55EE9F05, double 0x3F64FECB88BB3633, double 0x3FA2009A03CCBE34, double 0x3FB0001FB57CF9FC, double 0x3F6DCA7ADA5E274A, double 0x3F64FECB88BB3633, double 0x3F9E2D13B467D120, double 0x3F7941963399C6A1, double 0x3FA3F736D8AF2E2B, double 0x3F6607390CEF853C, double 0x3F3D828C80BA213A, double 0x3EEA42D90EEBA875, double 0x3FB42D4181AA8F8B, double 0x3FA01715F12E0018, double 0x3F73D9F3AF6D490C, double 0x3F64FECB88BB3633, double 0x3F73D9F3AF6D490C, double 0x3F520CE5F51A7C61, double 0x3FB290B112B20952, double 0x3F9696C95AA76B69], [50 x double] [double 1.000000e+00, double 1.000000e+00, double 0x3FEC9C56E33BA41B, double 0x3FEB3BF21E95ED3D, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 0x3FE05DA74553C727, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 0x3FC675198790829A, double 1.000000e+00, double 0x3FE54345648E1F12, double 0x3FB3645F501CA2F9, double 0x3F879D934E50F0DE, double 0x3FC43FC3646E3EA2, double 0x3FD1FF539D36064C, double 0x3F90C123206B855F, double 0x3F879D934E50F0DE, double 0x3FC0F8967F32E606, double 0x3F9C6880470D2FBE, double 0x3FC675198790829A, double 0x3F88C70105E47082, double 2.025930e-03, double 0x3F0D89DE4FA8F818, double 0x3FD6B1E2D11B1027, double 0x3FC219271872BD8D, double 0x3F96542FAD16CEF9, double 0x3F879D934E50F0DE, double 0x3F96542FAD16CEF9, double 0x3F744D9816EB319A, double 0x3FD4E1D5728DBC16, double 0x3FB9687C40426555], [50 x double] [double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 0x3FE6761DC93EA2D3, double 1.000000e+00, double 1.000000e+00, double 0x3FC9DC55000C953A, double 0x3F8F0FBD624BA499, double 0x3FE2009A24031487, double 1.000000e+00, double 0x3F9DCA7AB8020F7A, double 0x3F8F7E310860A1AB, double 0x3FDA677128614819, double 6.782670e-02, double 6.803480e-01, double 0x3F9346521EDBB84D, double 0x3F4D828CB7B3E0EE, double 0x3EEA42D90EEBA875, double 1.000000e+00, double 4.713920e-01, double 0x3FA6815EE53DB1E7, double 0x3F864D0CF90CC6B8, double 0x3FA8D0709B489B4F, double 0x3F6B1359791819D2, double 1.000000e+00, double 0x3FD25A836EB4E981], [50 x double] [double 0x3FEFF94F77369843, double 0x3FEFF94F77369843, double 0x3FEFF94F77369843, double 0x3FEFF94F77369843, double 0x3FEFF94F77369843, double 0x3FEFF94F77369843, double 0x3FEFF94F77369843, double 0x3FEFF94F77369843, double 0x3FEFF94F77369843, double 0x3FEFF94F77369843, double 0x3FEFF94F77369843, double 0x3FEFF94F77369843, double 0x3FEFF94F77369843, double 0x3FEFF94F77369843, double 0x3FEFF94F77369843, double 0x3FEFF94F77369843, double 0x3FEFF94F77369843, double 0x3FEFF94F77369843, double 0x3FEFF94F77369843, double 0x3FEFF94F77369843, double 0x3FEFF94F77369843, double 0x3FEFF94F77369843, double 0x3FEFF94F77369843, double 0x3FEFF94F77369843, double 0x3FEFF94F77369843, double 0x3FEFF94F77369843, double 0x3FEFF94F77369843, double 0x3FDDA6274695E687, double 0x3FEFF94F77369843, double 0x3FEFF94F77369843, double 0x3FC42BDC26DCE39B, double 0x3F8C57F9104CA951, double 0x3FD9340AC9879DEF, double 7.600230e-01, double 0x3F999EC5A86B439B, double 0x3F8C57F9104CA951, double 0x3FD389FCD90412B4, double 0x3FABC8251D45E10B, double 0x3FDD9BD68ABBB045, double 0x3F90F633F956C386, double 8.825610e-04, double 0x3EEA42D90EEBA875, double 0x3FEFC7471C1E43B8, double 0x3FD5B8C4014C305A, double 0x3FA2E78CEC8D068E, double 0x3F84F6832995A599, double 0x3FA459002162FC24, double 3.172920e-03, double 8.992520e-01, double 0x3FCBE5BD5E9AC00A], [50 x double] [double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 0x3FDDA6274695E687, double 1.000000e+00, double 1.000000e+00, double 0x3FC42BDC26DCE39B, double 0x3F8C939AFCF101E0, double 0x3FD9340AC9879DEF, double 7.600230e-01, double 0x3F999EC5A86B439B, double 0x3F8C939AFCF101E0, double 0x3FD389FCD90412B4, double 0x3FABC8251D45E10B, double 0x3FDD9BD68ABBB045, double 0x3F90F633F956C386, double 8.825610e-04, double 0x3EEA42D90EEBA875, double 0x3FEFC7471C1E43B8, double 0x3FD5B8C4014C305A, double 0x3FA2E78CEC8D068E, double 0x3F84F6832995A599, double 0x3FA459002162FC24, double 3.172920e-03, double 8.992520e-01, double 0x3FCBE5BD5E9AC00A], [50 x double] [double 0x3FEFF94F77369843, double 0x3FEFF94F77369843, double 0x3FEFF94F77369843, double 0x3FEFF5DC908F2EDD, double 0x3FEFF94F77369843, double 0x3FEFF94F77369843, double 0x3FEFF94F77369843, double 0x3FEFF94F77369843, double 0x3FEFF94F77369843, double 0x3FEFF94F77369843, double 0x3FEFF94F77369843, double 0x3FEFF94F77369843, double 0x3FEFF94F77369843, double 0x3FEFF94F77369843, double 0x3FEFF94F77369843, double 0x3FEFF94F77369843, double 0x3FEFF94F77369843, double 0x3FEFF94F77369843, double 0x3FEFF94F77369843, double 0x3FEEB45F17BD8BE7, double 0x3FEFF94F77369843, double 0x3FEFF94F77369843, double 0x3FEFF94F77369843, double 0x3FEFF94F77369843, double 0x3FEFF94F77369843, double 0x3FEFF94F77369843, double 0x3FEFF94F77369843, double 0x3FDBDA250F840182, double 0x3FEFF94F77369843, double 0x3FEF40BC1D52205E, double 0x3FC21A3BEB689947, double 1.304340e-02, double 0x3FD69916517B1CD7, double 0x3FE60A69453DF7B2, double 0x3F986DB666D9D3C6, double 0x3F8B157BBD3AB385, double 2.722920e-01, double 0x3FABC8251D45E10B, double 0x3FDAFF07B27BE8AF, double 0x3F9030D45E3B9F93, double 8.825610e-04, double 0x3EEA42D90EEBA875, double 0x3FEBFACC1948A662, double 0x3FD34EE6EDE042CB, double 0x3FA2011883DA6A9A, double 0x3F839FF779153716, double 0x3FA3D9F3D1C960DD, double 3.172920e-03, double 0x3FE9FDC4BC5D1301, double 0x3FC8F5FAC3801CF1]], align 16
@.str.26 = private unnamed_addr constant [3 x i8] c"bh\00", align 1
@.str.27 = private unnamed_addr constant [11 x i8] c"bonferroni\00", align 1
@__const.main.TYPES = private unnamed_addr constant [6 x i8*] [i8* getelementptr inbounds ([3 x i8], [3 x i8]* @.str.26, i32 0, i32 0), i8* getelementptr inbounds ([3 x i8], [3 x i8]* @.str.16, i32 0, i32 0), i8* getelementptr inbounds ([11 x i8], [11 x i8]* @.str.27, i32 0, i32 0), i8* getelementptr inbounds ([9 x i8], [9 x i8]* @.str.18, i32 0, i32 0), i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.19, i32 0, i32 0), i8* getelementptr inbounds ([7 x i8], [7 x i8]* @.str.20, i32 0, i32 0)], align 16
@.str.28 = private unnamed_addr constant [44 x i8] c"\0Atype %u = '%s' has cumulative error of %g\0A\00", align 1
@llvm.used = appending global [1 x i8*] [i8* bitcast (i32 ()* @__main_void to i8*)], section "llvm.metadata"

@__main_void = alias i32 (), i32 ()* @main

; Function Attrs: noinline nounwind optnone
define hidden i32* @seq_len(i32 %START, i32 %END) #0 {
entry:
  %retval = alloca i32*, align 4
  %START.addr = alloca i32, align 4
  %END.addr = alloca i32, align 4
  %start = alloca i32, align 4
  %end = alloca i32, align 4
  %sequence = alloca i32*, align 4
  %i = alloca i32, align 4
  %LENGTH = alloca i32, align 4
  %sequence10 = alloca i32*, align 4
  %index = alloca i32, align 4
  %index28 = alloca i32, align 4
  store i32 %START, i32* %START.addr, align 4
  store i32 %END, i32* %END.addr, align 4
  %0 = load i32, i32* %START.addr, align 4
  store i32 %0, i32* %start, align 4
  %1 = load i32, i32* %END.addr, align 4
  store i32 %1, i32* %end, align 4
  %2 = load i32, i32* %START.addr, align 4
  %3 = load i32, i32* %END.addr, align 4
  %cmp = icmp eq i32 %2, %3
  br i1 %cmp, label %if.then, label %if.end6

if.then:                                          ; preds = %entry
  %4 = load i32, i32* %end, align 4
  %add = add i32 %4, 1
  %mul = mul i32 %add, 4
  %call = call noalias i8* @malloc(i32 %mul)
  %5 = bitcast i8* %call to i32*
  store i32* %5, i32** %sequence, align 4
  %6 = load i32*, i32** %sequence, align 4
  %cmp1 = icmp eq i32* %6, null
  br i1 %cmp1, label %if.then2, label %if.end

if.then2:                                         ; preds = %if.then
  %call3 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([29 x i8], [29 x i8]* @.str, i32 0, i32 0), i8* getelementptr inbounds ([23 x i8], [23 x i8]* @.str.1, i32 0, i32 0), i32 15)
  call void @perror(i8* getelementptr inbounds ([1 x i8], [1 x i8]* @.str.2, i32 0, i32 0))
  call void @exit(i32 1) #5
  unreachable

if.end:                                           ; preds = %if.then
  store i32 0, i32* %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.end
  %7 = load i32, i32* %i, align 4
  %8 = load i32, i32* %end, align 4
  %cmp4 = icmp ult i32 %7, %8
  br i1 %cmp4, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %9 = load i32, i32* %i, align 4
  %add5 = add i32 %9, 1
  %10 = load i32*, i32** %sequence, align 4
  %11 = load i32, i32* %i, align 4
  %arrayidx = getelementptr inbounds i32, i32* %10, i32 %11
  store i32 %add5, i32* %arrayidx, align 4
  br label %for.inc

for.inc:                                          ; preds = %for.body
  %12 = load i32, i32* %i, align 4
  %inc = add i32 %12, 1
  store i32 %inc, i32* %i, align 4
  br label %for.cond

for.end:                                          ; preds = %for.cond
  %13 = load i32*, i32** %sequence, align 4
  store i32* %13, i32** %retval, align 4
  br label %return

if.end6:                                          ; preds = %entry
  %14 = load i32, i32* %START.addr, align 4
  %15 = load i32, i32* %END.addr, align 4
  %cmp7 = icmp ugt i32 %14, %15
  br i1 %cmp7, label %if.then8, label %if.end9

if.then8:                                         ; preds = %if.end6
  %16 = load i32, i32* %START.addr, align 4
  store i32 %16, i32* %end, align 4
  %17 = load i32, i32* %END.addr, align 4
  store i32 %17, i32* %start, align 4
  br label %if.end9

if.end9:                                          ; preds = %if.then8, %if.end6
  %18 = load i32, i32* %end, align 4
  %19 = load i32, i32* %start, align 4
  %sub = sub i32 %18, %19
  store i32 %sub, i32* %LENGTH, align 4
  %20 = load i32, i32* %LENGTH, align 4
  %add11 = add i32 1, %20
  %mul12 = mul i32 %add11, 4
  %call13 = call noalias i8* @malloc(i32 %mul12)
  %21 = bitcast i8* %call13 to i32*
  store i32* %21, i32** %sequence10, align 4
  %22 = load i32*, i32** %sequence10, align 4
  %cmp14 = icmp eq i32* %22, null
  br i1 %cmp14, label %if.then15, label %if.end17

if.then15:                                        ; preds = %if.end9
  %call16 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([29 x i8], [29 x i8]* @.str, i32 0, i32 0), i8* getelementptr inbounds ([23 x i8], [23 x i8]* @.str.1, i32 0, i32 0), i32 31)
  call void @perror(i8* getelementptr inbounds ([1 x i8], [1 x i8]* @.str.2, i32 0, i32 0))
  call void @exit(i32 1) #5
  unreachable

if.end17:                                         ; preds = %if.end9
  %23 = load i32, i32* %START.addr, align 4
  %24 = load i32, i32* %END.addr, align 4
  %cmp18 = icmp ult i32 %23, %24
  br i1 %cmp18, label %if.then19, label %if.else

if.then19:                                        ; preds = %if.end17
  store i32 0, i32* %index, align 4
  br label %for.cond20

for.cond20:                                       ; preds = %for.inc25, %if.then19
  %25 = load i32, i32* %index, align 4
  %26 = load i32, i32* %LENGTH, align 4
  %cmp21 = icmp ule i32 %25, %26
  br i1 %cmp21, label %for.body22, label %for.end27

for.body22:                                       ; preds = %for.cond20
  %27 = load i32, i32* %start, align 4
  %28 = load i32, i32* %index, align 4
  %add23 = add i32 %27, %28
  %29 = load i32*, i32** %sequence10, align 4
  %30 = load i32, i32* %index, align 4
  %arrayidx24 = getelementptr inbounds i32, i32* %29, i32 %30
  store i32 %add23, i32* %arrayidx24, align 4
  br label %for.inc25

for.inc25:                                        ; preds = %for.body22
  %31 = load i32, i32* %index, align 4
  %inc26 = add i32 %31, 1
  store i32 %inc26, i32* %index, align 4
  br label %for.cond20

for.end27:                                        ; preds = %for.cond20
  br label %if.end37

if.else:                                          ; preds = %if.end17
  store i32 0, i32* %index28, align 4
  br label %for.cond29

for.cond29:                                       ; preds = %for.inc34, %if.else
  %32 = load i32, i32* %index28, align 4
  %33 = load i32, i32* %LENGTH, align 4
  %cmp30 = icmp ule i32 %32, %33
  br i1 %cmp30, label %for.body31, label %for.end36

for.body31:                                       ; preds = %for.cond29
  %34 = load i32, i32* %end, align 4
  %35 = load i32, i32* %index28, align 4
  %sub32 = sub i32 %34, %35
  %36 = load i32*, i32** %sequence10, align 4
  %37 = load i32, i32* %index28, align 4
  %arrayidx33 = getelementptr inbounds i32, i32* %36, i32 %37
  store i32 %sub32, i32* %arrayidx33, align 4
  br label %for.inc34

for.inc34:                                        ; preds = %for.body31
  %38 = load i32, i32* %index28, align 4
  %inc35 = add i32 %38, 1
  store i32 %inc35, i32* %index28, align 4
  br label %for.cond29

for.end36:                                        ; preds = %for.cond29
  br label %if.end37

if.end37:                                         ; preds = %for.end36, %for.end27
  %39 = load i32*, i32** %sequence10, align 4
  store i32* %39, i32** %retval, align 4
  br label %return

return:                                           ; preds = %if.end37, %for.end
  %40 = load i32*, i32** %retval, align 4
  ret i32* %40
}

declare noalias i8* @malloc(i32 %0) #1

declare i32 @printf(i8* %0, ...) #1

declare void @perror(i8* %0) #1

; Function Attrs: noreturn
declare void @exit(i32 %0) #2

; Function Attrs: noinline nounwind optnone
define hidden i32* @order(double* noalias %ARRAY, i32 %SIZE, i1 zeroext %DECREASING) #0 {
entry:
  %ARRAY.addr = alloca double*, align 4
  %SIZE.addr = alloca i32, align 4
  %DECREASING.addr = alloca i8, align 1
  %idx = alloca i32*, align 4
  %i = alloca i32, align 4
  store double* %ARRAY, double** %ARRAY.addr, align 4
  store i32 %SIZE, i32* %SIZE.addr, align 4
  %frombool = zext i1 %DECREASING to i8
  store i8 %frombool, i8* %DECREASING.addr, align 1
  %0 = load i32, i32* %SIZE.addr, align 4
  %mul = mul i32 %0, 4
  %call = call noalias i8* @malloc(i32 %mul)
  %1 = bitcast i8* %call to i32*
  store i32* %1, i32** %idx, align 4
  %2 = load i32*, i32** %idx, align 4
  %cmp = icmp eq i32* %2, null
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %call1 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([33 x i8], [33 x i8]* @.str.3, i32 0, i32 0), i8* getelementptr inbounds ([23 x i8], [23 x i8]* @.str.1, i32 0, i32 0), i32 77)
  call void @perror(i8* getelementptr inbounds ([1 x i8], [1 x i8]* @.str.2, i32 0, i32 0))
  call void @exit(i32 1) #5
  unreachable

if.end:                                           ; preds = %entry
  %3 = load i32, i32* %SIZE.addr, align 4
  %mul2 = mul i32 8, %3
  %call3 = call noalias i8* @malloc(i32 %mul2)
  %4 = bitcast i8* %call3 to double*
  store double* %4, double** @base_arr, align 4
  %5 = load double*, double** @base_arr, align 4
  %cmp4 = icmp eq double* %5, null
  br i1 %cmp4, label %if.then5, label %if.end7

if.then5:                                         ; preds = %if.end
  %call6 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([33 x i8], [33 x i8]* @.str.3, i32 0, i32 0), i8* getelementptr inbounds ([23 x i8], [23 x i8]* @.str.1, i32 0, i32 0), i32 83)
  call void @perror(i8* getelementptr inbounds ([1 x i8], [1 x i8]* @.str.2, i32 0, i32 0))
  call void @exit(i32 1) #5
  unreachable

if.end7:                                          ; preds = %if.end
  store i32 0, i32* %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.end7
  %6 = load i32, i32* %i, align 4
  %7 = load i32, i32* %SIZE.addr, align 4
  %cmp8 = icmp ult i32 %6, %7
  br i1 %cmp8, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %8 = load double*, double** %ARRAY.addr, align 4
  %9 = load i32, i32* %i, align 4
  %arrayidx = getelementptr inbounds double, double* %8, i32 %9
  %10 = load double, double* %arrayidx, align 8
  %11 = load double*, double** @base_arr, align 4
  %12 = load i32, i32* %i, align 4
  %arrayidx9 = getelementptr inbounds double, double* %11, i32 %12
  store double %10, double* %arrayidx9, align 8
  %13 = load i32, i32* %i, align 4
  %14 = load i32*, i32** %idx, align 4
  %15 = load i32, i32* %i, align 4
  %arrayidx10 = getelementptr inbounds i32, i32* %14, i32 %15
  store i32 %13, i32* %arrayidx10, align 4
  br label %for.inc

for.inc:                                          ; preds = %for.body
  %16 = load i32, i32* %i, align 4
  %inc = add i32 %16, 1
  store i32 %inc, i32* %i, align 4
  br label %for.cond

for.end:                                          ; preds = %for.cond
  %17 = load i8, i8* %DECREASING.addr, align 1
  %tobool = trunc i8 %17 to i1
  %conv = zext i1 %tobool to i32
  %cmp11 = icmp eq i32 %conv, 0
  br i1 %cmp11, label %if.then13, label %if.else

if.then13:                                        ; preds = %for.end
  %18 = load i32*, i32** %idx, align 4
  %19 = bitcast i32* %18 to i8*
  %20 = load i32, i32* %SIZE.addr, align 4
  call void @qsort(i8* %19, i32 %20, i32 4, i32 (i8*, i8*)* @compar_decrease)
  br label %if.end20

if.else:                                          ; preds = %for.end
  %21 = load i8, i8* %DECREASING.addr, align 1
  %tobool14 = trunc i8 %21 to i1
  %conv15 = zext i1 %tobool14 to i32
  %cmp16 = icmp eq i32 %conv15, 1
  br i1 %cmp16, label %if.then18, label %if.end19

if.then18:                                        ; preds = %if.else
  %22 = load i32*, i32** %idx, align 4
  %23 = bitcast i32* %22 to i8*
  %24 = load i32, i32* %SIZE.addr, align 4
  call void @qsort(i8* %23, i32 %24, i32 4, i32 (i8*, i8*)* @compar_increase)
  br label %if.end19

if.end19:                                         ; preds = %if.then18, %if.else
  br label %if.end20

if.end20:                                         ; preds = %if.end19, %if.then13
  %25 = load double*, double** @base_arr, align 4
  %26 = bitcast double* %25 to i8*
  call void @free(i8* %26)
  store double* null, double** @base_arr, align 4
  %27 = load i32*, i32** %idx, align 4
  ret i32* %27
}

declare void @qsort(i8* %0, i32 %1, i32 %2, i32 (i8*, i8*)* %3) #1

; Function Attrs: noinline nounwind optnone
define internal i32 @compar_decrease(i8* noalias %a, i8* noalias %b) #0 {
entry:
  %retval = alloca i32, align 4
  %a.addr = alloca i8*, align 4
  %b.addr = alloca i8*, align 4
  %aa = alloca i32, align 4
  %bb = alloca i32, align 4
  store i8* %a, i8** %a.addr, align 4
  store i8* %b, i8** %b.addr, align 4
  %0 = load i8*, i8** %a.addr, align 4
  %1 = bitcast i8* %0 to i32*
  %2 = load i32, i32* %1, align 4
  store i32 %2, i32* %aa, align 4
  %3 = load i8*, i8** %b.addr, align 4
  %4 = bitcast i8* %3 to i32*
  %5 = load i32, i32* %4, align 4
  store i32 %5, i32* %bb, align 4
  %6 = load double*, double** @base_arr, align 4
  %7 = load i32, i32* %aa, align 4
  %arrayidx = getelementptr inbounds double, double* %6, i32 %7
  %8 = load double, double* %arrayidx, align 8
  %9 = load double*, double** @base_arr, align 4
  %10 = load i32, i32* %bb, align 4
  %arrayidx1 = getelementptr inbounds double, double* %9, i32 %10
  %11 = load double, double* %arrayidx1, align 8
  %cmp = fcmp olt double %8, %11
  br i1 %cmp, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  store i32 -1, i32* %retval, align 4
  br label %return

if.else:                                          ; preds = %entry
  %12 = load double*, double** @base_arr, align 4
  %13 = load i32, i32* %aa, align 4
  %arrayidx2 = getelementptr inbounds double, double* %12, i32 %13
  %14 = load double, double* %arrayidx2, align 8
  %15 = load double*, double** @base_arr, align 4
  %16 = load i32, i32* %bb, align 4
  %arrayidx3 = getelementptr inbounds double, double* %15, i32 %16
  %17 = load double, double* %arrayidx3, align 8
  %cmp4 = fcmp oeq double %14, %17
  br i1 %cmp4, label %if.then5, label %if.else6

if.then5:                                         ; preds = %if.else
  store i32 0, i32* %retval, align 4
  br label %return

if.else6:                                         ; preds = %if.else
  store i32 1, i32* %retval, align 4
  br label %return

return:                                           ; preds = %if.else6, %if.then5, %if.then
  %18 = load i32, i32* %retval, align 4
  ret i32 %18
}

; Function Attrs: noinline nounwind optnone
define internal i32 @compar_increase(i8* noalias %a, i8* noalias %b) #0 {
entry:
  %retval = alloca i32, align 4
  %a.addr = alloca i8*, align 4
  %b.addr = alloca i8*, align 4
  %aa = alloca i32, align 4
  %bb = alloca i32, align 4
  store i8* %a, i8** %a.addr, align 4
  store i8* %b, i8** %b.addr, align 4
  %0 = load i8*, i8** %a.addr, align 4
  %1 = bitcast i8* %0 to i32*
  %2 = load i32, i32* %1, align 4
  store i32 %2, i32* %aa, align 4
  %3 = load i8*, i8** %b.addr, align 4
  %4 = bitcast i8* %3 to i32*
  %5 = load i32, i32* %4, align 4
  store i32 %5, i32* %bb, align 4
  %6 = load double*, double** @base_arr, align 4
  %7 = load i32, i32* %aa, align 4
  %arrayidx = getelementptr inbounds double, double* %6, i32 %7
  %8 = load double, double* %arrayidx, align 8
  %9 = load double*, double** @base_arr, align 4
  %10 = load i32, i32* %bb, align 4
  %arrayidx1 = getelementptr inbounds double, double* %9, i32 %10
  %11 = load double, double* %arrayidx1, align 8
  %cmp = fcmp olt double %8, %11
  br i1 %cmp, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  store i32 1, i32* %retval, align 4
  br label %return

if.else:                                          ; preds = %entry
  %12 = load double*, double** @base_arr, align 4
  %13 = load i32, i32* %aa, align 4
  %arrayidx2 = getelementptr inbounds double, double* %12, i32 %13
  %14 = load double, double* %arrayidx2, align 8
  %15 = load double*, double** @base_arr, align 4
  %16 = load i32, i32* %bb, align 4
  %arrayidx3 = getelementptr inbounds double, double* %15, i32 %16
  %17 = load double, double* %arrayidx3, align 8
  %cmp4 = fcmp oeq double %14, %17
  br i1 %cmp4, label %if.then5, label %if.else6

if.then5:                                         ; preds = %if.else
  store i32 0, i32* %retval, align 4
  br label %return

if.else6:                                         ; preds = %if.else
  store i32 -1, i32* %retval, align 4
  br label %return

return:                                           ; preds = %if.else6, %if.then5, %if.then
  %18 = load i32, i32* %retval, align 4
  ret i32 %18
}

declare void @free(i8* %0) #1

; Function Attrs: noinline nounwind optnone
define hidden double* @cummin(double* noalias %ARRAY, i32 %NO_OF_ARRAY_ELEMENTS) #0 {
entry:
  %ARRAY.addr = alloca double*, align 4
  %NO_OF_ARRAY_ELEMENTS.addr = alloca i32, align 4
  %output = alloca double*, align 4
  %cumulative_min = alloca double, align 8
  %i = alloca i32, align 4
  store double* %ARRAY, double** %ARRAY.addr, align 4
  store i32 %NO_OF_ARRAY_ELEMENTS, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
  %0 = load i32, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
  %cmp = icmp ult i32 %0, 1
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %call = call i32 @puts(i8* getelementptr inbounds ([48 x i8], [48 x i8]* @.str.4, i32 0, i32 0))
  %call1 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([22 x i8], [22 x i8]* @.str.5, i32 0, i32 0), i8* getelementptr inbounds ([23 x i8], [23 x i8]* @.str.1, i32 0, i32 0), i32 105)
  call void @exit(i32 1) #5
  unreachable

if.end:                                           ; preds = %entry
  %1 = load i32, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
  %mul = mul i32 8, %1
  %call2 = call noalias i8* @malloc(i32 %mul)
  %2 = bitcast i8* %call2 to double*
  store double* %2, double** %output, align 4
  %3 = load double*, double** %output, align 4
  %cmp3 = icmp eq double* %3, null
  br i1 %cmp3, label %if.then4, label %if.end6

if.then4:                                         ; preds = %if.end
  %call5 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([33 x i8], [33 x i8]* @.str.3, i32 0, i32 0), i8* getelementptr inbounds ([23 x i8], [23 x i8]* @.str.1, i32 0, i32 0), i32 110)
  call void @perror(i8* getelementptr inbounds ([1 x i8], [1 x i8]* @.str.2, i32 0, i32 0))
  call void @exit(i32 1) #5
  unreachable

if.end6:                                          ; preds = %if.end
  %4 = load double*, double** %ARRAY.addr, align 4
  %arrayidx = getelementptr inbounds double, double* %4, i32 0
  %5 = load double, double* %arrayidx, align 8
  store double %5, double* %cumulative_min, align 8
  store i32 0, i32* %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.end6
  %6 = load i32, i32* %i, align 4
  %7 = load i32, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
  %cmp7 = icmp ult i32 %6, %7
  br i1 %cmp7, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %8 = load double*, double** %ARRAY.addr, align 4
  %9 = load i32, i32* %i, align 4
  %arrayidx8 = getelementptr inbounds double, double* %8, i32 %9
  %10 = load double, double* %arrayidx8, align 8
  %11 = load double, double* %cumulative_min, align 8
  %cmp9 = fcmp olt double %10, %11
  br i1 %cmp9, label %if.then10, label %if.end12

if.then10:                                        ; preds = %for.body
  %12 = load double*, double** %ARRAY.addr, align 4
  %13 = load i32, i32* %i, align 4
  %arrayidx11 = getelementptr inbounds double, double* %12, i32 %13
  %14 = load double, double* %arrayidx11, align 8
  store double %14, double* %cumulative_min, align 8
  br label %if.end12

if.end12:                                         ; preds = %if.then10, %for.body
  %15 = load double, double* %cumulative_min, align 8
  %16 = load double*, double** %output, align 4
  %17 = load i32, i32* %i, align 4
  %arrayidx13 = getelementptr inbounds double, double* %16, i32 %17
  store double %15, double* %arrayidx13, align 8
  br label %for.inc

for.inc:                                          ; preds = %if.end12
  %18 = load i32, i32* %i, align 4
  %inc = add i32 %18, 1
  store i32 %inc, i32* %i, align 4
  br label %for.cond

for.end:                                          ; preds = %for.cond
  %19 = load double*, double** %output, align 4
  ret double* %19
}

declare i32 @puts(i8* %0) #1

; Function Attrs: noinline nounwind optnone
define hidden double* @cummax(double* noalias %ARRAY, i32 %NO_OF_ARRAY_ELEMENTS) #0 {
entry:
  %ARRAY.addr = alloca double*, align 4
  %NO_OF_ARRAY_ELEMENTS.addr = alloca i32, align 4
  %output = alloca double*, align 4
  %cumulative_max = alloca double, align 8
  %i = alloca i32, align 4
  store double* %ARRAY, double** %ARRAY.addr, align 4
  store i32 %NO_OF_ARRAY_ELEMENTS, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
  %0 = load i32, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
  %cmp = icmp ult i32 %0, 1
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %call = call i32 @puts(i8* getelementptr inbounds ([41 x i8], [41 x i8]* @.str.6, i32 0, i32 0))
  %call1 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([22 x i8], [22 x i8]* @.str.5, i32 0, i32 0), i8* getelementptr inbounds ([23 x i8], [23 x i8]* @.str.1, i32 0, i32 0), i32 129)
  call void @exit(i32 1) #5
  unreachable

if.end:                                           ; preds = %entry
  %1 = load i32, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
  %mul = mul i32 8, %1
  %call2 = call noalias i8* @malloc(i32 %mul)
  %2 = bitcast i8* %call2 to double*
  store double* %2, double** %output, align 4
  %3 = load double*, double** %output, align 4
  %cmp3 = icmp eq double* %3, null
  br i1 %cmp3, label %if.then4, label %if.end6

if.then4:                                         ; preds = %if.end
  %call5 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([33 x i8], [33 x i8]* @.str.3, i32 0, i32 0), i8* getelementptr inbounds ([23 x i8], [23 x i8]* @.str.1, i32 0, i32 0), i32 134)
  call void @perror(i8* getelementptr inbounds ([1 x i8], [1 x i8]* @.str.2, i32 0, i32 0))
  call void @exit(i32 1) #5
  unreachable

if.end6:                                          ; preds = %if.end
  %4 = load double*, double** %ARRAY.addr, align 4
  %arrayidx = getelementptr inbounds double, double* %4, i32 0
  %5 = load double, double* %arrayidx, align 8
  store double %5, double* %cumulative_max, align 8
  store i32 0, i32* %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.end6
  %6 = load i32, i32* %i, align 4
  %7 = load i32, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
  %cmp7 = icmp ult i32 %6, %7
  br i1 %cmp7, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %8 = load double*, double** %ARRAY.addr, align 4
  %9 = load i32, i32* %i, align 4
  %arrayidx8 = getelementptr inbounds double, double* %8, i32 %9
  %10 = load double, double* %arrayidx8, align 8
  %11 = load double, double* %cumulative_max, align 8
  %cmp9 = fcmp ogt double %10, %11
  br i1 %cmp9, label %if.then10, label %if.end12

if.then10:                                        ; preds = %for.body
  %12 = load double*, double** %ARRAY.addr, align 4
  %13 = load i32, i32* %i, align 4
  %arrayidx11 = getelementptr inbounds double, double* %12, i32 %13
  %14 = load double, double* %arrayidx11, align 8
  store double %14, double* %cumulative_max, align 8
  br label %if.end12

if.end12:                                         ; preds = %if.then10, %for.body
  %15 = load double, double* %cumulative_max, align 8
  %16 = load double*, double** %output, align 4
  %17 = load i32, i32* %i, align 4
  %arrayidx13 = getelementptr inbounds double, double* %16, i32 %17
  store double %15, double* %arrayidx13, align 8
  br label %for.inc

for.inc:                                          ; preds = %if.end12
  %18 = load i32, i32* %i, align 4
  %inc = add i32 %18, 1
  store i32 %inc, i32* %i, align 4
  br label %for.cond

for.end:                                          ; preds = %for.cond
  %19 = load double*, double** %output, align 4
  ret double* %19
}

; Function Attrs: noinline nounwind optnone
define hidden double* @pminx(double* noalias %ARRAY, i32 %NO_OF_ARRAY_ELEMENTS, double %X) #0 {
entry:
  %ARRAY.addr = alloca double*, align 4
  %NO_OF_ARRAY_ELEMENTS.addr = alloca i32, align 4
  %X.addr = alloca double, align 8
  %pmin_array = alloca double*, align 4
  %index = alloca i32, align 4
  store double* %ARRAY, double** %ARRAY.addr, align 4
  store i32 %NO_OF_ARRAY_ELEMENTS, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
  store double %X, double* %X.addr, align 8
  %0 = load i32, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
  %cmp = icmp ult i32 %0, 1
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %call = call i32 @puts(i8* getelementptr inbounds ([37 x i8], [37 x i8]* @.str.7, i32 0, i32 0))
  %call1 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([22 x i8], [22 x i8]* @.str.5, i32 0, i32 0), i8* getelementptr inbounds ([23 x i8], [23 x i8]* @.str.1, i32 0, i32 0), i32 152)
  call void @exit(i32 1) #5
  unreachable

if.end:                                           ; preds = %entry
  %1 = load i32, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
  %mul = mul i32 8, %1
  %call2 = call noalias i8* @malloc(i32 %mul)
  %2 = bitcast i8* %call2 to double*
  store double* %2, double** %pmin_array, align 4
  %3 = load double*, double** %pmin_array, align 4
  %cmp3 = icmp eq double* %3, null
  br i1 %cmp3, label %if.then4, label %if.end6

if.then4:                                         ; preds = %if.end
  %call5 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([33 x i8], [33 x i8]* @.str.3, i32 0, i32 0), i8* getelementptr inbounds ([23 x i8], [23 x i8]* @.str.1, i32 0, i32 0), i32 157)
  call void @perror(i8* getelementptr inbounds ([1 x i8], [1 x i8]* @.str.2, i32 0, i32 0))
  call void @exit(i32 1) #5
  unreachable

if.end6:                                          ; preds = %if.end
  store i32 0, i32* %index, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.end6
  %4 = load i32, i32* %index, align 4
  %5 = load i32, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
  %cmp7 = icmp ult i32 %4, %5
  br i1 %cmp7, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %6 = load double*, double** %ARRAY.addr, align 4
  %7 = load i32, i32* %index, align 4
  %arrayidx = getelementptr inbounds double, double* %6, i32 %7
  %8 = load double, double* %arrayidx, align 8
  %9 = load double, double* %X.addr, align 8
  %cmp8 = fcmp olt double %8, %9
  br i1 %cmp8, label %if.then9, label %if.else

if.then9:                                         ; preds = %for.body
  %10 = load double*, double** %ARRAY.addr, align 4
  %11 = load i32, i32* %index, align 4
  %arrayidx10 = getelementptr inbounds double, double* %10, i32 %11
  %12 = load double, double* %arrayidx10, align 8
  %13 = load double*, double** %pmin_array, align 4
  %14 = load i32, i32* %index, align 4
  %arrayidx11 = getelementptr inbounds double, double* %13, i32 %14
  store double %12, double* %arrayidx11, align 8
  br label %if.end13

if.else:                                          ; preds = %for.body
  %15 = load double, double* %X.addr, align 8
  %16 = load double*, double** %pmin_array, align 4
  %17 = load i32, i32* %index, align 4
  %arrayidx12 = getelementptr inbounds double, double* %16, i32 %17
  store double %15, double* %arrayidx12, align 8
  br label %if.end13

if.end13:                                         ; preds = %if.else, %if.then9
  br label %for.inc

for.inc:                                          ; preds = %if.end13
  %18 = load i32, i32* %index, align 4
  %inc = add i32 %18, 1
  store i32 %inc, i32* %index, align 4
  br label %for.cond

for.end:                                          ; preds = %for.cond
  %19 = load double*, double** %pmin_array, align 4
  ret double* %19
}

; Function Attrs: noinline nounwind optnone
define hidden void @double_say(double* noalias %ARRAY, i32 %NO_OF_ARRAY_ELEMENTS) #0 {
entry:
  %ARRAY.addr = alloca double*, align 4
  %NO_OF_ARRAY_ELEMENTS.addr = alloca i32, align 4
  %i = alloca i32, align 4
  store double* %ARRAY, double** %ARRAY.addr, align 4
  store i32 %NO_OF_ARRAY_ELEMENTS, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
  %0 = load double*, double** %ARRAY.addr, align 4
  %arrayidx = getelementptr inbounds double, double* %0, i32 0
  %1 = load double, double* %arrayidx, align 8
  %call = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([7 x i8], [7 x i8]* @.str.8, i32 0, i32 0), double %1)
  store i32 1, i32* %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %2 = load i32, i32* %i, align 4
  %3 = load i32, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
  %cmp = icmp ult i32 %2, %3
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %4 = load double*, double** %ARRAY.addr, align 4
  %5 = load i32, i32* %i, align 4
  %arrayidx1 = getelementptr inbounds double, double* %4, i32 %5
  %6 = load double, double* %arrayidx1, align 8
  %call2 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([7 x i8], [7 x i8]* @.str.9, i32 0, i32 0), double %6)
  %7 = load i32, i32* %i, align 4
  %add = add i32 %7, 1
  %rem = urem i32 %add, 5
  %cmp3 = icmp eq i32 %rem, 0
  br i1 %cmp3, label %if.then, label %if.end

if.then:                                          ; preds = %for.body
  %8 = load i32, i32* %i, align 4
  %add4 = add i32 %8, 1
  %call5 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([6 x i8], [6 x i8]* @.str.10, i32 0, i32 0), i32 %add4)
  br label %if.end

if.end:                                           ; preds = %if.then, %for.body
  br label %for.inc

for.inc:                                          ; preds = %if.end
  %9 = load i32, i32* %i, align 4
  %inc = add i32 %9, 1
  store i32 %inc, i32* %i, align 4
  br label %for.cond

for.end:                                          ; preds = %for.cond
  %call6 = call i32 @puts(i8* getelementptr inbounds ([2 x i8], [2 x i8]* @.str.11, i32 0, i32 0))
  ret void
}

; Function Attrs: noinline nounwind optnone
define hidden double* @uint2double(i32* noalias %ARRAY, i32 %NO_OF_ARRAY_ELEMENTS) #0 {
entry:
  %ARRAY.addr = alloca i32*, align 4
  %NO_OF_ARRAY_ELEMENTS.addr = alloca i32, align 4
  %doubleArray = alloca double*, align 4
  %index = alloca i32, align 4
  store i32* %ARRAY, i32** %ARRAY.addr, align 4
  store i32 %NO_OF_ARRAY_ELEMENTS, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
  %0 = load i32, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
  %mul = mul i32 8, %0
  %call = call noalias i8* @malloc(i32 %mul)
  %1 = bitcast i8* %call to double*
  store double* %1, double** %doubleArray, align 4
  %2 = load double*, double** %doubleArray, align 4
  %cmp = icmp eq double* %2, null
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %call1 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([34 x i8], [34 x i8]* @.str.12, i32 0, i32 0), i8* getelementptr inbounds ([23 x i8], [23 x i8]* @.str.1, i32 0, i32 0), i32 194)
  call void @perror(i8* getelementptr inbounds ([1 x i8], [1 x i8]* @.str.2, i32 0, i32 0))
  call void @exit(i32 1) #5
  unreachable

if.end:                                           ; preds = %entry
  store i32 0, i32* %index, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.end
  %3 = load i32, i32* %index, align 4
  %4 = load i32, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
  %cmp2 = icmp ult i32 %3, %4
  br i1 %cmp2, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %5 = load i32*, i32** %ARRAY.addr, align 4
  %6 = load i32, i32* %index, align 4
  %arrayidx = getelementptr inbounds i32, i32* %5, i32 %6
  %7 = load i32, i32* %arrayidx, align 4
  %conv = uitofp i32 %7 to double
  %8 = load double*, double** %doubleArray, align 4
  %9 = load i32, i32* %index, align 4
  %arrayidx3 = getelementptr inbounds double, double* %8, i32 %9
  store double %conv, double* %arrayidx3, align 8
  br label %for.inc

for.inc:                                          ; preds = %for.body
  %10 = load i32, i32* %index, align 4
  %inc = add i32 %10, 1
  store i32 %inc, i32* %index, align 4
  br label %for.cond

for.end:                                          ; preds = %for.cond
  %11 = load double*, double** %doubleArray, align 4
  ret double* %11
}

; Function Attrs: noinline nounwind optnone
define hidden double @min2(double %N1, double %N2) #0 {
entry:
  %retval = alloca double, align 8
  %N1.addr = alloca double, align 8
  %N2.addr = alloca double, align 8
  store double %N1, double* %N1.addr, align 8
  store double %N2, double* %N2.addr, align 8
  %0 = load double, double* %N1.addr, align 8
  %1 = load double, double* %N2.addr, align 8
  %cmp = fcmp olt double %0, %1
  br i1 %cmp, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  %2 = load double, double* %N1.addr, align 8
  store double %2, double* %retval, align 8
  br label %return

if.else:                                          ; preds = %entry
  %3 = load double, double* %N2.addr, align 8
  store double %3, double* %retval, align 8
  br label %return

return:                                           ; preds = %if.else, %if.then
  %4 = load double, double* %retval, align 8
  ret double %4
}

; Function Attrs: noinline nounwind optnone
define hidden double* @p_adjust(double* noalias %PVALUES, i32 %NO_OF_ARRAY_ELEMENTS, i8* noalias %STRING) #0 {
entry:
  %retval = alloca double*, align 4
  %PVALUES.addr = alloca double*, align 4
  %NO_OF_ARRAY_ELEMENTS.addr = alloca i32, align 4
  %STRING.addr = alloca i8*, align 4
  %TYPE = alloca i16, align 2
  %bonferroni = alloca double*, align 4
  %index = alloca i32, align 4
  %BONFERRONI = alloca double, align 8
  %o = alloca i32*, align 4
  %o2double = alloca double*, align 4
  %cummax_input = alloca double*, align 4
  %index80 = alloca i32, align 4
  %ro = alloca i32*, align 4
  %cummax_output = alloca double*, align 4
  %pmin = alloca double*, align 4
  %qvalues = alloca double*, align 4
  %index98 = alloca i32, align 4
  %o114 = alloca i32*, align 4
  %p = alloca double*, align 4
  %index123 = alloca i32, align 4
  %o2double134 = alloca double*, align 4
  %ro136 = alloca i32*, align 4
  %q = alloca double*, align 4
  %pa = alloca double*, align 4
  %min = alloca double, align 8
  %index155 = alloca i32, align 4
  %TEMP = alloca double, align 8
  %index171 = alloca i32, align 4
  %j = alloca i32, align 4
  %ij = alloca i32*, align 4
  %I2_LENGTH = alloca i32, align 4
  %i2 = alloca i32*, align 4
  %i = alloca i32, align 4
  %q1 = alloca double, align 8
  %i208 = alloca i32, align 4
  %TEMP_Q1 = alloca double, align 8
  %i227 = alloca i32, align 4
  %i244 = alloca i32, align 4
  %i256 = alloca i32, align 4
  %index274 = alloca i32, align 4
  %o288 = alloca i32*, align 4
  %o_double = alloca double*, align 4
  %index296 = alloca i32, align 4
  %ro315 = alloca i32*, align 4
  %cummin_input = alloca double*, align 4
  %index328 = alloca i32, align 4
  %NI = alloca double, align 8
  %q349 = alloca double, align 8
  %index350 = alloca i32, align 4
  %index362 = alloca i32, align 4
  %NI367 = alloca double, align 8
  %index385 = alloca i32, align 4
  %cummin_array = alloca double*, align 4
  %pmin403 = alloca double*, align 4
  %q_array = alloca double*, align 4
  %index407 = alloca i32, align 4
  store double* %PVALUES, double** %PVALUES.addr, align 4
  store i32 %NO_OF_ARRAY_ELEMENTS, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
  store i8* %STRING, i8** %STRING.addr, align 4
  %0 = load i32, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
  %cmp = icmp ult i32 %0, 1
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %call = call i32 @puts(i8* getelementptr inbounds ([41 x i8], [41 x i8]* @.str.13, i32 0, i32 0))
  %call1 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([22 x i8], [22 x i8]* @.str.5, i32 0, i32 0), i8* getelementptr inbounds ([23 x i8], [23 x i8]* @.str.1, i32 0, i32 0), i32 217)
  call void @exit(i32 1) #5
  unreachable

if.end:                                           ; preds = %entry
  store i16 -1, i16* %TYPE, align 2
  %1 = load i8*, i8** %STRING.addr, align 4
  %cmp2 = icmp eq i8* %1, null
  br i1 %cmp2, label %if.then3, label %if.else

if.then3:                                         ; preds = %if.end
  store i16 0, i16* %TYPE, align 2
  br label %if.end41

if.else:                                          ; preds = %if.end
  %2 = load i8*, i8** %STRING.addr, align 4
  %call4 = call i32 @strcasecmp(i8* %2, i8* getelementptr inbounds ([3 x i8], [3 x i8]* @.str.14, i32 0, i32 0))
  %cmp5 = icmp eq i32 %call4, 0
  br i1 %cmp5, label %if.then6, label %if.else7

if.then6:                                         ; preds = %if.else
  store i16 0, i16* %TYPE, align 2
  br label %if.end40

if.else7:                                         ; preds = %if.else
  %3 = load i8*, i8** %STRING.addr, align 4
  %call8 = call i32 @strcasecmp(i8* %3, i8* getelementptr inbounds ([4 x i8], [4 x i8]* @.str.15, i32 0, i32 0))
  %cmp9 = icmp eq i32 %call8, 0
  br i1 %cmp9, label %if.then10, label %if.else11

if.then10:                                        ; preds = %if.else7
  store i16 0, i16* %TYPE, align 2
  br label %if.end39

if.else11:                                        ; preds = %if.else7
  %4 = load i8*, i8** %STRING.addr, align 4
  %call12 = call i32 @strcasecmp(i8* %4, i8* getelementptr inbounds ([3 x i8], [3 x i8]* @.str.16, i32 0, i32 0))
  %cmp13 = icmp eq i32 %call12, 0
  br i1 %cmp13, label %if.then14, label %if.else15

if.then14:                                        ; preds = %if.else11
  store i16 1, i16* %TYPE, align 2
  br label %if.end38

if.else15:                                        ; preds = %if.else11
  %5 = load i8*, i8** %STRING.addr, align 4
  %call16 = call i32 @strcasecmp(i8* %5, i8* getelementptr inbounds ([11 x i8], [11 x i8]* @.str.17, i32 0, i32 0))
  %cmp17 = icmp eq i32 %call16, 0
  br i1 %cmp17, label %if.then18, label %if.else19

if.then18:                                        ; preds = %if.else15
  store i16 2, i16* %TYPE, align 2
  br label %if.end37

if.else19:                                        ; preds = %if.else15
  %6 = load i8*, i8** %STRING.addr, align 4
  %call20 = call i32 @strcasecmp(i8* %6, i8* getelementptr inbounds ([9 x i8], [9 x i8]* @.str.18, i32 0, i32 0))
  %cmp21 = icmp eq i32 %call20, 0
  br i1 %cmp21, label %if.then22, label %if.else23

if.then22:                                        ; preds = %if.else19
  store i16 3, i16* %TYPE, align 2
  br label %if.end36

if.else23:                                        ; preds = %if.else19
  %7 = load i8*, i8** %STRING.addr, align 4
  %call24 = call i32 @strcasecmp(i8* %7, i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.19, i32 0, i32 0))
  %cmp25 = icmp eq i32 %call24, 0
  br i1 %cmp25, label %if.then26, label %if.else27

if.then26:                                        ; preds = %if.else23
  store i16 4, i16* %TYPE, align 2
  br label %if.end35

if.else27:                                        ; preds = %if.else23
  %8 = load i8*, i8** %STRING.addr, align 4
  %call28 = call i32 @strcasecmp(i8* %8, i8* getelementptr inbounds ([7 x i8], [7 x i8]* @.str.20, i32 0, i32 0))
  %cmp29 = icmp eq i32 %call28, 0
  br i1 %cmp29, label %if.then30, label %if.else31

if.then30:                                        ; preds = %if.else27
  store i16 5, i16* %TYPE, align 2
  br label %if.end34

if.else31:                                        ; preds = %if.else27
  %9 = load i8*, i8** %STRING.addr, align 4
  %call32 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([44 x i8], [44 x i8]* @.str.21, i32 0, i32 0), i8* %9)
  %call33 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([22 x i8], [22 x i8]* @.str.5, i32 0, i32 0), i8* getelementptr inbounds ([23 x i8], [23 x i8]* @.str.1, i32 0, i32 0), i32 239)
  call void @exit(i32 1) #5
  unreachable

if.end34:                                         ; preds = %if.then30
  br label %if.end35

if.end35:                                         ; preds = %if.end34, %if.then26
  br label %if.end36

if.end36:                                         ; preds = %if.end35, %if.then22
  br label %if.end37

if.end37:                                         ; preds = %if.end36, %if.then18
  br label %if.end38

if.end38:                                         ; preds = %if.end37, %if.then14
  br label %if.end39

if.end39:                                         ; preds = %if.end38, %if.then10
  br label %if.end40

if.end40:                                         ; preds = %if.end39, %if.then6
  br label %if.end41

if.end41:                                         ; preds = %if.end40, %if.then3
  %10 = load i16, i16* %TYPE, align 2
  %conv = sext i16 %10 to i32
  %cmp42 = icmp eq i32 %conv, 2
  br i1 %cmp42, label %if.then44, label %if.else71

if.then44:                                        ; preds = %if.end41
  %11 = load i32, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
  %mul = mul i32 8, %11
  %call45 = call noalias i8* @malloc(i32 %mul)
  %12 = bitcast i8* %call45 to double*
  store double* %12, double** %bonferroni, align 4
  %13 = load double*, double** %bonferroni, align 4
  %cmp46 = icmp eq double* %13, null
  br i1 %cmp46, label %if.then48, label %if.end50

if.then48:                                        ; preds = %if.then44
  %call49 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([33 x i8], [33 x i8]* @.str.3, i32 0, i32 0), i8* getelementptr inbounds ([23 x i8], [23 x i8]* @.str.1, i32 0, i32 0), i32 247)
  call void @perror(i8* getelementptr inbounds ([1 x i8], [1 x i8]* @.str.2, i32 0, i32 0))
  call void @exit(i32 1) #5
  unreachable

if.end50:                                         ; preds = %if.then44
  store i32 0, i32* %index, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.end50
  %14 = load i32, i32* %index, align 4
  %15 = load i32, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
  %cmp51 = icmp ult i32 %14, %15
  br i1 %cmp51, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %16 = load double*, double** %PVALUES.addr, align 4
  %17 = load i32, i32* %index, align 4
  %arrayidx = getelementptr inbounds double, double* %16, i32 %17
  %18 = load double, double* %arrayidx, align 8
  %19 = load i32, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
  %conv53 = uitofp i32 %19 to double
  %mul54 = fmul double %18, %conv53
  store double %mul54, double* %BONFERRONI, align 8
  %20 = load double, double* %BONFERRONI, align 8
  %cmp55 = fcmp oge double %20, 1.000000e+00
  br i1 %cmp55, label %if.then57, label %if.else59

if.then57:                                        ; preds = %for.body
  %21 = load double*, double** %bonferroni, align 4
  %22 = load i32, i32* %index, align 4
  %arrayidx58 = getelementptr inbounds double, double* %21, i32 %22
  store double 1.000000e+00, double* %arrayidx58, align 8
  br label %if.end70

if.else59:                                        ; preds = %for.body
  %23 = load double, double* %BONFERRONI, align 8
  %cmp60 = fcmp ole double 0.000000e+00, %23
  br i1 %cmp60, label %land.lhs.true, label %if.else66

land.lhs.true:                                    ; preds = %if.else59
  %24 = load double, double* %BONFERRONI, align 8
  %cmp62 = fcmp olt double %24, 1.000000e+00
  br i1 %cmp62, label %if.then64, label %if.else66

if.then64:                                        ; preds = %land.lhs.true
  %25 = load double, double* %BONFERRONI, align 8
  %26 = load double*, double** %bonferroni, align 4
  %27 = load i32, i32* %index, align 4
  %arrayidx65 = getelementptr inbounds double, double* %26, i32 %27
  store double %25, double* %arrayidx65, align 8
  br label %if.end69

if.else66:                                        ; preds = %land.lhs.true, %if.else59
  %28 = load double, double* %BONFERRONI, align 8
  %call67 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([42 x i8], [42 x i8]* @.str.22, i32 0, i32 0), double %28)
  %call68 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([23 x i8], [23 x i8]* @.str.23, i32 0, i32 0), i8* getelementptr inbounds ([23 x i8], [23 x i8]* @.str.1, i32 0, i32 0), i32 259)
  call void @exit(i32 1) #5
  unreachable

if.end69:                                         ; preds = %if.then64
  br label %if.end70

if.end70:                                         ; preds = %if.end69, %if.then57
  br label %for.inc

for.inc:                                          ; preds = %if.end70
  %29 = load i32, i32* %index, align 4
  %inc = add i32 %29, 1
  store i32 %inc, i32* %index, align 4
  br label %for.cond

for.end:                                          ; preds = %for.cond
  %30 = load double*, double** %bonferroni, align 4
  store double* %30, double** %retval, align 4
  br label %return

if.else71:                                        ; preds = %if.end41
  %31 = load i16, i16* %TYPE, align 2
  %conv72 = sext i16 %31 to i32
  %cmp73 = icmp eq i32 %conv72, 4
  br i1 %cmp73, label %if.then75, label %if.else109

if.then75:                                        ; preds = %if.else71
  %32 = load double*, double** %PVALUES.addr, align 4
  %33 = load i32, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
  %call76 = call i32* @order(double* %32, i32 %33, i1 zeroext false)
  store i32* %call76, i32** %o, align 4
  %34 = load i32*, i32** %o, align 4
  %35 = load i32, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
  %call77 = call double* @uint2double(i32* %34, i32 %35)
  store double* %call77, double** %o2double, align 4
  %36 = load i32, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
  %mul78 = mul i32 8, %36
  %call79 = call noalias i8* @malloc(i32 %mul78)
  %37 = bitcast i8* %call79 to double*
  store double* %37, double** %cummax_input, align 4
  store i32 0, i32* %index80, align 4
  br label %for.cond81

for.cond81:                                       ; preds = %for.inc90, %if.then75
  %38 = load i32, i32* %index80, align 4
  %39 = load i32, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
  %cmp82 = icmp ult i32 %38, %39
  br i1 %cmp82, label %for.body84, label %for.end92

for.body84:                                       ; preds = %for.cond81
  %40 = load i32, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
  %41 = load i32, i32* %index80, align 4
  %sub = sub i32 %40, %41
  %conv85 = uitofp i32 %sub to double
  %42 = load double*, double** %PVALUES.addr, align 4
  %43 = load i32*, i32** %o, align 4
  %44 = load i32, i32* %index80, align 4
  %arrayidx86 = getelementptr inbounds i32, i32* %43, i32 %44
  %45 = load i32, i32* %arrayidx86, align 4
  %arrayidx87 = getelementptr inbounds double, double* %42, i32 %45
  %46 = load double, double* %arrayidx87, align 8
  %mul88 = fmul double %conv85, %46
  %47 = load double*, double** %cummax_input, align 4
  %48 = load i32, i32* %index80, align 4
  %arrayidx89 = getelementptr inbounds double, double* %47, i32 %48
  store double %mul88, double* %arrayidx89, align 8
  br label %for.inc90

for.inc90:                                        ; preds = %for.body84
  %49 = load i32, i32* %index80, align 4
  %inc91 = add i32 %49, 1
  store i32 %inc91, i32* %index80, align 4
  br label %for.cond81

for.end92:                                        ; preds = %for.cond81
  %50 = load i32*, i32** %o, align 4
  %51 = bitcast i32* %50 to i8*
  call void @free(i8* %51)
  store i32* null, i32** %o, align 4
  %52 = load double*, double** %o2double, align 4
  %53 = load i32, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
  %call93 = call i32* @order(double* %52, i32 %53, i1 zeroext false)
  store i32* %call93, i32** %ro, align 4
  %54 = load double*, double** %o2double, align 4
  %55 = bitcast double* %54 to i8*
  call void @free(i8* %55)
  store double* null, double** %o2double, align 4
  %56 = load double*, double** %cummax_input, align 4
  %57 = load i32, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
  %call94 = call double* @cummax(double* %56, i32 %57)
  store double* %call94, double** %cummax_output, align 4
  %58 = load double*, double** %cummax_input, align 4
  %59 = bitcast double* %58 to i8*
  call void @free(i8* %59)
  store double* null, double** %cummax_input, align 4
  %60 = load double*, double** %cummax_output, align 4
  %61 = load i32, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
  %call95 = call double* @pminx(double* %60, i32 %61, double 1.000000e+00)
  store double* %call95, double** %pmin, align 4
  %62 = load double*, double** %cummax_output, align 4
  %63 = bitcast double* %62 to i8*
  call void @free(i8* %63)
  store double* null, double** %cummax_output, align 4
  %64 = load i32, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
  %mul96 = mul i32 8, %64
  %call97 = call noalias i8* @malloc(i32 %mul96)
  %65 = bitcast i8* %call97 to double*
  store double* %65, double** %qvalues, align 4
  store i32 0, i32* %index98, align 4
  br label %for.cond99

for.cond99:                                       ; preds = %for.inc106, %for.end92
  %66 = load i32, i32* %index98, align 4
  %67 = load i32, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
  %cmp100 = icmp ult i32 %66, %67
  br i1 %cmp100, label %for.body102, label %for.end108

for.body102:                                      ; preds = %for.cond99
  %68 = load double*, double** %pmin, align 4
  %69 = load i32*, i32** %ro, align 4
  %70 = load i32, i32* %index98, align 4
  %arrayidx103 = getelementptr inbounds i32, i32* %69, i32 %70
  %71 = load i32, i32* %arrayidx103, align 4
  %arrayidx104 = getelementptr inbounds double, double* %68, i32 %71
  %72 = load double, double* %arrayidx104, align 8
  %73 = load double*, double** %qvalues, align 4
  %74 = load i32, i32* %index98, align 4
  %arrayidx105 = getelementptr inbounds double, double* %73, i32 %74
  store double %72, double* %arrayidx105, align 8
  br label %for.inc106

for.inc106:                                       ; preds = %for.body102
  %75 = load i32, i32* %index98, align 4
  %inc107 = add i32 %75, 1
  store i32 %inc107, i32* %index98, align 4
  br label %for.cond99

for.end108:                                       ; preds = %for.cond99
  %76 = load double*, double** %pmin, align 4
  %77 = bitcast double* %76 to i8*
  call void @free(i8* %77)
  store double* null, double** %pmin, align 4
  %78 = load i32*, i32** %ro, align 4
  %79 = bitcast i32* %78 to i8*
  call void @free(i8* %79)
  store i32* null, i32** %ro, align 4
  %80 = load double*, double** %qvalues, align 4
  store double* %80, double** %retval, align 4
  br label %return

if.else109:                                       ; preds = %if.else71
  %81 = load i16, i16* %TYPE, align 2
  %conv110 = sext i16 %81 to i32
  %cmp111 = icmp eq i32 %conv110, 5
  br i1 %cmp111, label %if.then113, label %if.end285

if.then113:                                       ; preds = %if.else109
  %82 = load double*, double** %PVALUES.addr, align 4
  %83 = load i32, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
  %call115 = call i32* @order(double* %82, i32 %83, i1 zeroext false)
  store i32* %call115, i32** %o114, align 4
  %84 = load i32, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
  %mul116 = mul i32 8, %84
  %call117 = call noalias i8* @malloc(i32 %mul116)
  %85 = bitcast i8* %call117 to double*
  store double* %85, double** %p, align 4
  %86 = load double*, double** %p, align 4
  %cmp118 = icmp eq double* %86, null
  br i1 %cmp118, label %if.then120, label %if.end122

if.then120:                                       ; preds = %if.then113
  %call121 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([33 x i8], [33 x i8]* @.str.3, i32 0, i32 0), i8* getelementptr inbounds ([23 x i8], [23 x i8]* @.str.1, i32 0, i32 0), i32 302)
  call void @perror(i8* getelementptr inbounds ([1 x i8], [1 x i8]* @.str.2, i32 0, i32 0))
  call void @exit(i32 1) #5
  unreachable

if.end122:                                        ; preds = %if.then113
  store i32 0, i32* %index123, align 4
  br label %for.cond124

for.cond124:                                      ; preds = %for.inc131, %if.end122
  %87 = load i32, i32* %index123, align 4
  %88 = load i32, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
  %cmp125 = icmp ult i32 %87, %88
  br i1 %cmp125, label %for.body127, label %for.end133

for.body127:                                      ; preds = %for.cond124
  %89 = load double*, double** %PVALUES.addr, align 4
  %90 = load i32*, i32** %o114, align 4
  %91 = load i32, i32* %index123, align 4
  %arrayidx128 = getelementptr inbounds i32, i32* %90, i32 %91
  %92 = load i32, i32* %arrayidx128, align 4
  %arrayidx129 = getelementptr inbounds double, double* %89, i32 %92
  %93 = load double, double* %arrayidx129, align 8
  %94 = load double*, double** %p, align 4
  %95 = load i32, i32* %index123, align 4
  %arrayidx130 = getelementptr inbounds double, double* %94, i32 %95
  store double %93, double* %arrayidx130, align 8
  br label %for.inc131

for.inc131:                                       ; preds = %for.body127
  %96 = load i32, i32* %index123, align 4
  %inc132 = add i32 %96, 1
  store i32 %inc132, i32* %index123, align 4
  br label %for.cond124

for.end133:                                       ; preds = %for.cond124
  %97 = load i32*, i32** %o114, align 4
  %98 = load i32, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
  %call135 = call double* @uint2double(i32* %97, i32 %98)
  store double* %call135, double** %o2double134, align 4
  %99 = load i32*, i32** %o114, align 4
  %100 = bitcast i32* %99 to i8*
  call void @free(i8* %100)
  store i32* null, i32** %o114, align 4
  %101 = load double*, double** %o2double134, align 4
  %102 = load i32, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
  %call137 = call i32* @order(double* %101, i32 %102, i1 zeroext false)
  store i32* %call137, i32** %ro136, align 4
  %103 = load double*, double** %o2double134, align 4
  %104 = bitcast double* %103 to i8*
  call void @free(i8* %104)
  store double* null, double** %o2double134, align 4
  %105 = load i32, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
  %mul138 = mul i32 8, %105
  %call139 = call noalias i8* @malloc(i32 %mul138)
  %106 = bitcast i8* %call139 to double*
  store double* %106, double** %q, align 4
  %107 = load double*, double** %q, align 4
  %cmp140 = icmp eq double* %107, null
  br i1 %cmp140, label %if.then142, label %if.end144

if.then142:                                       ; preds = %for.end133
  %call143 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([33 x i8], [33 x i8]* @.str.3, i32 0, i32 0), i8* getelementptr inbounds ([23 x i8], [23 x i8]* @.str.1, i32 0, i32 0), i32 318)
  call void @perror(i8* getelementptr inbounds ([1 x i8], [1 x i8]* @.str.2, i32 0, i32 0))
  call void @exit(i32 1) #5
  unreachable

if.end144:                                        ; preds = %for.end133
  %108 = load i32, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
  %mul145 = mul i32 8, %108
  %call146 = call noalias i8* @malloc(i32 %mul145)
  %109 = bitcast i8* %call146 to double*
  store double* %109, double** %pa, align 4
  %110 = load double*, double** %pa, align 4
  %cmp147 = icmp eq double* %110, null
  br i1 %cmp147, label %if.then149, label %if.end151

if.then149:                                       ; preds = %if.end144
  %call150 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([33 x i8], [33 x i8]* @.str.3, i32 0, i32 0), i8* getelementptr inbounds ([23 x i8], [23 x i8]* @.str.1, i32 0, i32 0), i32 324)
  call void @perror(i8* getelementptr inbounds ([1 x i8], [1 x i8]* @.str.2, i32 0, i32 0))
  call void @exit(i32 1) #5
  unreachable

if.end151:                                        ; preds = %if.end144
  %111 = load i32, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
  %conv152 = uitofp i32 %111 to double
  %112 = load double*, double** %p, align 4
  %arrayidx153 = getelementptr inbounds double, double* %112, i32 0
  %113 = load double, double* %arrayidx153, align 8
  %mul154 = fmul double %conv152, %113
  store double %mul154, double* %min, align 8
  store i32 1, i32* %index155, align 4
  br label %for.cond156

for.cond156:                                      ; preds = %for.inc168, %if.end151
  %114 = load i32, i32* %index155, align 4
  %115 = load i32, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
  %cmp157 = icmp ult i32 %114, %115
  br i1 %cmp157, label %for.body159, label %for.end170

for.body159:                                      ; preds = %for.cond156
  %116 = load i32, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
  %conv160 = uitofp i32 %116 to double
  %117 = load double*, double** %p, align 4
  %118 = load i32, i32* %index155, align 4
  %arrayidx161 = getelementptr inbounds double, double* %117, i32 %118
  %119 = load double, double* %arrayidx161, align 8
  %mul162 = fmul double %conv160, %119
  %120 = load i32, i32* %index155, align 4
  %add = add i32 1, %120
  %conv163 = uitofp i32 %add to double
  %div = fdiv double %mul162, %conv163
  store double %div, double* %TEMP, align 8
  %121 = load double, double* %TEMP, align 8
  %122 = load double, double* %min, align 8
  %cmp164 = fcmp olt double %121, %122
  br i1 %cmp164, label %if.then166, label %if.end167

if.then166:                                       ; preds = %for.body159
  %123 = load double, double* %TEMP, align 8
  store double %123, double* %min, align 8
  br label %if.end167

if.end167:                                        ; preds = %if.then166, %for.body159
  br label %for.inc168

for.inc168:                                       ; preds = %if.end167
  %124 = load i32, i32* %index155, align 4
  %inc169 = add i32 %124, 1
  store i32 %inc169, i32* %index155, align 4
  br label %for.cond156

for.end170:                                       ; preds = %for.cond156
  store i32 0, i32* %index171, align 4
  br label %for.cond172

for.cond172:                                      ; preds = %for.inc178, %for.end170
  %125 = load i32, i32* %index171, align 4
  %126 = load i32, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
  %cmp173 = icmp ult i32 %125, %126
  br i1 %cmp173, label %for.body175, label %for.end180

for.body175:                                      ; preds = %for.cond172
  %127 = load double, double* %min, align 8
  %128 = load double*, double** %pa, align 4
  %129 = load i32, i32* %index171, align 4
  %arrayidx176 = getelementptr inbounds double, double* %128, i32 %129
  store double %127, double* %arrayidx176, align 8
  %130 = load double, double* %min, align 8
  %131 = load double*, double** %q, align 4
  %132 = load i32, i32* %index171, align 4
  %arrayidx177 = getelementptr inbounds double, double* %131, i32 %132
  store double %130, double* %arrayidx177, align 8
  br label %for.inc178

for.inc178:                                       ; preds = %for.body175
  %133 = load i32, i32* %index171, align 4
  %inc179 = add i32 %133, 1
  store i32 %inc179, i32* %index171, align 4
  br label %for.cond172

for.end180:                                       ; preds = %for.cond172
  %134 = load i32, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
  %sub181 = sub i32 %134, 1
  store i32 %sub181, i32* %j, align 4
  br label %for.cond182

for.cond182:                                      ; preds = %for.inc272, %for.end180
  %135 = load i32, i32* %j, align 4
  %cmp183 = icmp uge i32 %135, 2
  br i1 %cmp183, label %for.body185, label %for.end273

for.body185:                                      ; preds = %for.cond182
  %136 = load i32, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
  %137 = load i32, i32* %j, align 4
  %sub186 = sub i32 %136, %137
  %call187 = call i32* @seq_len(i32 0, i32 %sub186)
  store i32* %call187, i32** %ij, align 4
  %138 = load i32, i32* %j, align 4
  %sub188 = sub i32 %138, 1
  store i32 %sub188, i32* %I2_LENGTH, align 4
  %139 = load i32, i32* %I2_LENGTH, align 4
  %mul189 = mul i32 %139, 4
  %call190 = call noalias i8* @malloc(i32 %mul189)
  %140 = bitcast i8* %call190 to i32*
  store i32* %140, i32** %i2, align 4
  store i32 0, i32* %i, align 4
  br label %for.cond191

for.cond191:                                      ; preds = %for.inc200, %for.body185
  %141 = load i32, i32* %i, align 4
  %142 = load i32, i32* %I2_LENGTH, align 4
  %cmp192 = icmp ult i32 %141, %142
  br i1 %cmp192, label %for.body194, label %for.end202

for.body194:                                      ; preds = %for.cond191
  %143 = load i32, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
  %144 = load i32, i32* %j, align 4
  %sub195 = sub i32 %143, %144
  %add196 = add i32 %sub195, 2
  %145 = load i32, i32* %i, align 4
  %add197 = add i32 %add196, %145
  %sub198 = sub i32 %add197, 1
  %146 = load i32*, i32** %i2, align 4
  %147 = load i32, i32* %i, align 4
  %arrayidx199 = getelementptr inbounds i32, i32* %146, i32 %147
  store i32 %sub198, i32* %arrayidx199, align 4
  br label %for.inc200

for.inc200:                                       ; preds = %for.body194
  %148 = load i32, i32* %i, align 4
  %inc201 = add i32 %148, 1
  store i32 %inc201, i32* %i, align 4
  br label %for.cond191

for.end202:                                       ; preds = %for.cond191
  %149 = load i32, i32* %j, align 4
  %conv203 = uitofp i32 %149 to double
  %150 = load double*, double** %p, align 4
  %151 = load i32*, i32** %i2, align 4
  %arrayidx204 = getelementptr inbounds i32, i32* %151, i32 0
  %152 = load i32, i32* %arrayidx204, align 4
  %arrayidx205 = getelementptr inbounds double, double* %150, i32 %152
  %153 = load double, double* %arrayidx205, align 8
  %mul206 = fmul double %conv203, %153
  %div207 = fdiv double %mul206, 2.000000e+00
  store double %div207, double* %q1, align 8
  store i32 1, i32* %i208, align 4
  br label %for.cond209

for.cond209:                                      ; preds = %for.inc224, %for.end202
  %154 = load i32, i32* %i208, align 4
  %155 = load i32, i32* %I2_LENGTH, align 4
  %cmp210 = icmp ult i32 %154, %155
  br i1 %cmp210, label %for.body212, label %for.end226

for.body212:                                      ; preds = %for.cond209
  %156 = load i32, i32* %j, align 4
  %conv213 = uitofp i32 %156 to double
  %157 = load double*, double** %p, align 4
  %158 = load i32*, i32** %i2, align 4
  %159 = load i32, i32* %i208, align 4
  %arrayidx214 = getelementptr inbounds i32, i32* %158, i32 %159
  %160 = load i32, i32* %arrayidx214, align 4
  %arrayidx215 = getelementptr inbounds double, double* %157, i32 %160
  %161 = load double, double* %arrayidx215, align 8
  %mul216 = fmul double %conv213, %161
  %162 = load i32, i32* %i208, align 4
  %add217 = add i32 2, %162
  %conv218 = uitofp i32 %add217 to double
  %div219 = fdiv double %mul216, %conv218
  store double %div219, double* %TEMP_Q1, align 8
  %163 = load double, double* %TEMP_Q1, align 8
  %164 = load double, double* %q1, align 8
  %cmp220 = fcmp olt double %163, %164
  br i1 %cmp220, label %if.then222, label %if.end223

if.then222:                                       ; preds = %for.body212
  %165 = load double, double* %TEMP_Q1, align 8
  store double %165, double* %q1, align 8
  br label %if.end223

if.end223:                                        ; preds = %if.then222, %for.body212
  br label %for.inc224

for.inc224:                                       ; preds = %if.end223
  %166 = load i32, i32* %i208, align 4
  %inc225 = add i32 %166, 1
  store i32 %inc225, i32* %i208, align 4
  br label %for.cond209

for.end226:                                       ; preds = %for.cond209
  store i32 0, i32* %i227, align 4
  br label %for.cond228

for.cond228:                                      ; preds = %for.inc241, %for.end226
  %167 = load i32, i32* %i227, align 4
  %168 = load i32, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
  %169 = load i32, i32* %j, align 4
  %sub229 = sub i32 %168, %169
  %add230 = add i32 %sub229, 1
  %cmp231 = icmp ult i32 %167, %add230
  br i1 %cmp231, label %for.body233, label %for.end243

for.body233:                                      ; preds = %for.cond228
  %170 = load i32, i32* %j, align 4
  %conv234 = uitofp i32 %170 to double
  %171 = load double*, double** %p, align 4
  %172 = load i32*, i32** %ij, align 4
  %173 = load i32, i32* %i227, align 4
  %arrayidx235 = getelementptr inbounds i32, i32* %172, i32 %173
  %174 = load i32, i32* %arrayidx235, align 4
  %arrayidx236 = getelementptr inbounds double, double* %171, i32 %174
  %175 = load double, double* %arrayidx236, align 8
  %mul237 = fmul double %conv234, %175
  %176 = load double, double* %q1, align 8
  %call238 = call double @min2(double %mul237, double %176)
  %177 = load double*, double** %q, align 4
  %178 = load i32*, i32** %ij, align 4
  %179 = load i32, i32* %i227, align 4
  %arrayidx239 = getelementptr inbounds i32, i32* %178, i32 %179
  %180 = load i32, i32* %arrayidx239, align 4
  %arrayidx240 = getelementptr inbounds double, double* %177, i32 %180
  store double %call238, double* %arrayidx240, align 8
  br label %for.inc241

for.inc241:                                       ; preds = %for.body233
  %181 = load i32, i32* %i227, align 4
  %inc242 = add i32 %181, 1
  store i32 %inc242, i32* %i227, align 4
  br label %for.cond228

for.end243:                                       ; preds = %for.cond228
  %182 = load i32*, i32** %ij, align 4
  %183 = bitcast i32* %182 to i8*
  call void @free(i8* %183)
  store i32* null, i32** %ij, align 4
  store i32 0, i32* %i244, align 4
  br label %for.cond245

for.cond245:                                      ; preds = %for.inc253, %for.end243
  %184 = load i32, i32* %i244, align 4
  %185 = load i32, i32* %I2_LENGTH, align 4
  %cmp246 = icmp ult i32 %184, %185
  br i1 %cmp246, label %for.body248, label %for.end255

for.body248:                                      ; preds = %for.cond245
  %186 = load double*, double** %q, align 4
  %187 = load i32, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
  %188 = load i32, i32* %j, align 4
  %sub249 = sub i32 %187, %188
  %arrayidx250 = getelementptr inbounds double, double* %186, i32 %sub249
  %189 = load double, double* %arrayidx250, align 8
  %190 = load double*, double** %q, align 4
  %191 = load i32*, i32** %i2, align 4
  %192 = load i32, i32* %i244, align 4
  %arrayidx251 = getelementptr inbounds i32, i32* %191, i32 %192
  %193 = load i32, i32* %arrayidx251, align 4
  %arrayidx252 = getelementptr inbounds double, double* %190, i32 %193
  store double %189, double* %arrayidx252, align 8
  br label %for.inc253

for.inc253:                                       ; preds = %for.body248
  %194 = load i32, i32* %i244, align 4
  %inc254 = add i32 %194, 1
  store i32 %inc254, i32* %i244, align 4
  br label %for.cond245

for.end255:                                       ; preds = %for.cond245
  %195 = load i32*, i32** %i2, align 4
  %196 = bitcast i32* %195 to i8*
  call void @free(i8* %196)
  store i32* null, i32** %i2, align 4
  store i32 0, i32* %i256, align 4
  br label %for.cond257

for.cond257:                                      ; preds = %for.inc269, %for.end255
  %197 = load i32, i32* %i256, align 4
  %198 = load i32, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
  %cmp258 = icmp ult i32 %197, %198
  br i1 %cmp258, label %for.body260, label %for.end271

for.body260:                                      ; preds = %for.cond257
  %199 = load double*, double** %pa, align 4
  %200 = load i32, i32* %i256, align 4
  %arrayidx261 = getelementptr inbounds double, double* %199, i32 %200
  %201 = load double, double* %arrayidx261, align 8
  %202 = load double*, double** %q, align 4
  %203 = load i32, i32* %i256, align 4
  %arrayidx262 = getelementptr inbounds double, double* %202, i32 %203
  %204 = load double, double* %arrayidx262, align 8
  %cmp263 = fcmp olt double %201, %204
  br i1 %cmp263, label %if.then265, label %if.end268

if.then265:                                       ; preds = %for.body260
  %205 = load double*, double** %q, align 4
  %206 = load i32, i32* %i256, align 4
  %arrayidx266 = getelementptr inbounds double, double* %205, i32 %206
  %207 = load double, double* %arrayidx266, align 8
  %208 = load double*, double** %pa, align 4
  %209 = load i32, i32* %i256, align 4
  %arrayidx267 = getelementptr inbounds double, double* %208, i32 %209
  store double %207, double* %arrayidx267, align 8
  br label %if.end268

if.end268:                                        ; preds = %if.then265, %for.body260
  br label %for.inc269

for.inc269:                                       ; preds = %if.end268
  %210 = load i32, i32* %i256, align 4
  %inc270 = add i32 %210, 1
  store i32 %inc270, i32* %i256, align 4
  br label %for.cond257

for.end271:                                       ; preds = %for.cond257
  br label %for.inc272

for.inc272:                                       ; preds = %for.end271
  %211 = load i32, i32* %j, align 4
  %dec = add i32 %211, -1
  store i32 %dec, i32* %j, align 4
  br label %for.cond182

for.end273:                                       ; preds = %for.cond182
  %212 = load double*, double** %p, align 4
  %213 = bitcast double* %212 to i8*
  call void @free(i8* %213)
  store double* null, double** %p, align 4
  store i32 0, i32* %index274, align 4
  br label %for.cond275

for.cond275:                                      ; preds = %for.inc282, %for.end273
  %214 = load i32, i32* %index274, align 4
  %215 = load i32, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
  %cmp276 = icmp ult i32 %214, %215
  br i1 %cmp276, label %for.body278, label %for.end284

for.body278:                                      ; preds = %for.cond275
  %216 = load double*, double** %pa, align 4
  %217 = load i32*, i32** %ro136, align 4
  %218 = load i32, i32* %index274, align 4
  %arrayidx279 = getelementptr inbounds i32, i32* %217, i32 %218
  %219 = load i32, i32* %arrayidx279, align 4
  %arrayidx280 = getelementptr inbounds double, double* %216, i32 %219
  %220 = load double, double* %arrayidx280, align 8
  %221 = load double*, double** %q, align 4
  %222 = load i32, i32* %index274, align 4
  %arrayidx281 = getelementptr inbounds double, double* %221, i32 %222
  store double %220, double* %arrayidx281, align 8
  br label %for.inc282

for.inc282:                                       ; preds = %for.body278
  %223 = load i32, i32* %index274, align 4
  %inc283 = add i32 %223, 1
  store i32 %inc283, i32* %index274, align 4
  br label %for.cond275

for.end284:                                       ; preds = %for.cond275
  %224 = load i32*, i32** %ro136, align 4
  %225 = bitcast i32* %224 to i8*
  call void @free(i8* %225)
  store i32* null, i32** %ro136, align 4
  %226 = load double*, double** %pa, align 4
  %227 = bitcast double* %226 to i8*
  call void @free(i8* %227)
  store double* null, double** %pa, align 4
  %228 = load double*, double** %q, align 4
  store double* %228, double** %retval, align 4
  br label %return

if.end285:                                        ; preds = %if.else109
  br label %if.end286

if.end286:                                        ; preds = %if.end285
  br label %if.end287

if.end287:                                        ; preds = %if.end286
  %229 = load double*, double** %PVALUES.addr, align 4
  %230 = load i32, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
  %call289 = call i32* @order(double* %229, i32 %230, i1 zeroext true)
  store i32* %call289, i32** %o288, align 4
  %231 = load i32*, i32** %o288, align 4
  %cmp290 = icmp eq i32* %231, null
  br i1 %cmp290, label %if.then292, label %if.end294

if.then292:                                       ; preds = %if.end287
  %call293 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([33 x i8], [33 x i8]* @.str.3, i32 0, i32 0), i8* getelementptr inbounds ([23 x i8], [23 x i8]* @.str.1, i32 0, i32 0), i32 398)
  call void @perror(i8* getelementptr inbounds ([1 x i8], [1 x i8]* @.str.2, i32 0, i32 0))
  call void @exit(i32 1) #5
  unreachable

if.end294:                                        ; preds = %if.end287
  %232 = load i32*, i32** %o288, align 4
  %233 = load i32, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
  %call295 = call double* @uint2double(i32* %232, i32 %233)
  store double* %call295, double** %o_double, align 4
  store i32 0, i32* %index296, align 4
  br label %for.cond297

for.cond297:                                      ; preds = %for.inc312, %if.end294
  %234 = load i32, i32* %index296, align 4
  %235 = load i32, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
  %cmp298 = icmp ult i32 %234, %235
  br i1 %cmp298, label %for.body300, label %for.end314

for.body300:                                      ; preds = %for.cond297
  %236 = load double*, double** %PVALUES.addr, align 4
  %237 = load i32, i32* %index296, align 4
  %arrayidx301 = getelementptr inbounds double, double* %236, i32 %237
  %238 = load double, double* %arrayidx301, align 8
  %cmp302 = fcmp olt double %238, 0.000000e+00
  br i1 %cmp302, label %if.then307, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %for.body300
  %239 = load double*, double** %PVALUES.addr, align 4
  %240 = load i32, i32* %index296, align 4
  %arrayidx304 = getelementptr inbounds double, double* %239, i32 %240
  %241 = load double, double* %arrayidx304, align 8
  %cmp305 = fcmp ogt double %241, 1.000000e+00
  br i1 %cmp305, label %if.then307, label %if.end311

if.then307:                                       ; preds = %lor.lhs.false, %for.body300
  %242 = load i32, i32* %index296, align 4
  %243 = load double*, double** %PVALUES.addr, align 4
  %244 = load i32, i32* %index296, align 4
  %arrayidx308 = getelementptr inbounds double, double* %243, i32 %244
  %245 = load double, double* %arrayidx308, align 8
  %call309 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([54 x i8], [54 x i8]* @.str.24, i32 0, i32 0), i32 %242, double %245)
  %call310 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([20 x i8], [20 x i8]* @.str.25, i32 0, i32 0), i8* getelementptr inbounds ([23 x i8], [23 x i8]* @.str.1, i32 0, i32 0), i32 406)
  call void @exit(i32 1) #5
  unreachable

if.end311:                                        ; preds = %lor.lhs.false
  br label %for.inc312

for.inc312:                                       ; preds = %if.end311
  %246 = load i32, i32* %index296, align 4
  %inc313 = add i32 %246, 1
  store i32 %inc313, i32* %index296, align 4
  br label %for.cond297

for.end314:                                       ; preds = %for.cond297
  %247 = load double*, double** %o_double, align 4
  %248 = load i32, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
  %call316 = call i32* @order(double* %247, i32 %248, i1 zeroext false)
  store i32* %call316, i32** %ro315, align 4
  %249 = load i32*, i32** %ro315, align 4
  %cmp317 = icmp eq i32* %249, null
  br i1 %cmp317, label %if.then319, label %if.end321

if.then319:                                       ; preds = %for.end314
  %call320 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([33 x i8], [33 x i8]* @.str.3, i32 0, i32 0), i8* getelementptr inbounds ([23 x i8], [23 x i8]* @.str.1, i32 0, i32 0), i32 413)
  call void @perror(i8* getelementptr inbounds ([1 x i8], [1 x i8]* @.str.2, i32 0, i32 0))
  call void @exit(i32 1) #5
  unreachable

if.end321:                                        ; preds = %for.end314
  %250 = load double*, double** %o_double, align 4
  %251 = bitcast double* %250 to i8*
  call void @free(i8* %251)
  store double* null, double** %o_double, align 4
  %252 = load i32, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
  %mul322 = mul i32 8, %252
  %call323 = call noalias i8* @malloc(i32 %mul322)
  %253 = bitcast i8* %call323 to double*
  store double* %253, double** %cummin_input, align 4
  %254 = load i16, i16* %TYPE, align 2
  %conv324 = sext i16 %254 to i32
  %cmp325 = icmp eq i32 %conv324, 0
  br i1 %cmp325, label %if.then327, label %if.else344

if.then327:                                       ; preds = %if.end321
  store i32 0, i32* %index328, align 4
  br label %for.cond329

for.cond329:                                      ; preds = %for.inc341, %if.then327
  %255 = load i32, i32* %index328, align 4
  %256 = load i32, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
  %cmp330 = icmp ult i32 %255, %256
  br i1 %cmp330, label %for.body332, label %for.end343

for.body332:                                      ; preds = %for.cond329
  %257 = load i32, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
  %conv333 = uitofp i32 %257 to double
  %258 = load i32, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
  %259 = load i32, i32* %index328, align 4
  %sub334 = sub i32 %258, %259
  %conv335 = uitofp i32 %sub334 to double
  %div336 = fdiv double %conv333, %conv335
  store double %div336, double* %NI, align 8
  %260 = load double, double* %NI, align 8
  %261 = load double*, double** %PVALUES.addr, align 4
  %262 = load i32*, i32** %o288, align 4
  %263 = load i32, i32* %index328, align 4
  %arrayidx337 = getelementptr inbounds i32, i32* %262, i32 %263
  %264 = load i32, i32* %arrayidx337, align 4
  %arrayidx338 = getelementptr inbounds double, double* %261, i32 %264
  %265 = load double, double* %arrayidx338, align 8
  %mul339 = fmul double %260, %265
  %266 = load double*, double** %cummin_input, align 4
  %267 = load i32, i32* %index328, align 4
  %arrayidx340 = getelementptr inbounds double, double* %266, i32 %267
  store double %mul339, double* %arrayidx340, align 8
  br label %for.inc341

for.inc341:                                       ; preds = %for.body332
  %268 = load i32, i32* %index328, align 4
  %inc342 = add i32 %268, 1
  store i32 %inc342, i32* %index328, align 4
  br label %for.cond329

for.end343:                                       ; preds = %for.cond329
  br label %if.end401

if.else344:                                       ; preds = %if.end321
  %269 = load i16, i16* %TYPE, align 2
  %conv345 = sext i16 %269 to i32
  %cmp346 = icmp eq i32 %conv345, 1
  br i1 %cmp346, label %if.then348, label %if.else380

if.then348:                                       ; preds = %if.else344
  store double 1.000000e+00, double* %q349, align 8
  store i32 2, i32* %index350, align 4
  br label %for.cond351

for.cond351:                                      ; preds = %for.inc359, %if.then348
  %270 = load i32, i32* %index350, align 4
  %271 = load i32, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
  %add352 = add i32 1, %271
  %cmp353 = icmp ult i32 %270, %add352
  br i1 %cmp353, label %for.body355, label %for.end361

for.body355:                                      ; preds = %for.cond351
  %272 = load i32, i32* %index350, align 4
  %conv356 = uitofp i32 %272 to double
  %div357 = fdiv double 1.000000e+00, %conv356
  %273 = load double, double* %q349, align 8
  %add358 = fadd double %273, %div357
  store double %add358, double* %q349, align 8
  br label %for.inc359

for.inc359:                                       ; preds = %for.body355
  %274 = load i32, i32* %index350, align 4
  %inc360 = add i32 %274, 1
  store i32 %inc360, i32* %index350, align 4
  br label %for.cond351

for.end361:                                       ; preds = %for.cond351
  store i32 0, i32* %index362, align 4
  br label %for.cond363

for.cond363:                                      ; preds = %for.inc377, %for.end361
  %275 = load i32, i32* %index362, align 4
  %276 = load i32, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
  %cmp364 = icmp ult i32 %275, %276
  br i1 %cmp364, label %for.body366, label %for.end379

for.body366:                                      ; preds = %for.cond363
  %277 = load i32, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
  %conv368 = uitofp i32 %277 to double
  %278 = load i32, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
  %279 = load i32, i32* %index362, align 4
  %sub369 = sub i32 %278, %279
  %conv370 = uitofp i32 %sub369 to double
  %div371 = fdiv double %conv368, %conv370
  store double %div371, double* %NI367, align 8
  %280 = load double, double* %q349, align 8
  %281 = load double, double* %NI367, align 8
  %mul372 = fmul double %280, %281
  %282 = load double*, double** %PVALUES.addr, align 4
  %283 = load i32*, i32** %o288, align 4
  %284 = load i32, i32* %index362, align 4
  %arrayidx373 = getelementptr inbounds i32, i32* %283, i32 %284
  %285 = load i32, i32* %arrayidx373, align 4
  %arrayidx374 = getelementptr inbounds double, double* %282, i32 %285
  %286 = load double, double* %arrayidx374, align 8
  %mul375 = fmul double %mul372, %286
  %287 = load double*, double** %cummin_input, align 4
  %288 = load i32, i32* %index362, align 4
  %arrayidx376 = getelementptr inbounds double, double* %287, i32 %288
  store double %mul375, double* %arrayidx376, align 8
  br label %for.inc377

for.inc377:                                       ; preds = %for.body366
  %289 = load i32, i32* %index362, align 4
  %inc378 = add i32 %289, 1
  store i32 %inc378, i32* %index362, align 4
  br label %for.cond363

for.end379:                                       ; preds = %for.cond363
  br label %if.end400

if.else380:                                       ; preds = %if.else344
  %290 = load i16, i16* %TYPE, align 2
  %conv381 = sext i16 %290 to i32
  %cmp382 = icmp eq i32 %conv381, 3
  br i1 %cmp382, label %if.then384, label %if.end399

if.then384:                                       ; preds = %if.else380
  store i32 0, i32* %index385, align 4
  br label %for.cond386

for.cond386:                                      ; preds = %for.inc396, %if.then384
  %291 = load i32, i32* %index385, align 4
  %292 = load i32, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
  %cmp387 = icmp ult i32 %291, %292
  br i1 %cmp387, label %for.body389, label %for.end398

for.body389:                                      ; preds = %for.cond386
  %293 = load i32, i32* %index385, align 4
  %add390 = add i32 %293, 1
  %conv391 = uitofp i32 %add390 to double
  %294 = load double*, double** %PVALUES.addr, align 4
  %295 = load i32*, i32** %o288, align 4
  %296 = load i32, i32* %index385, align 4
  %arrayidx392 = getelementptr inbounds i32, i32* %295, i32 %296
  %297 = load i32, i32* %arrayidx392, align 4
  %arrayidx393 = getelementptr inbounds double, double* %294, i32 %297
  %298 = load double, double* %arrayidx393, align 8
  %mul394 = fmul double %conv391, %298
  %299 = load double*, double** %cummin_input, align 4
  %300 = load i32, i32* %index385, align 4
  %arrayidx395 = getelementptr inbounds double, double* %299, i32 %300
  store double %mul394, double* %arrayidx395, align 8
  br label %for.inc396

for.inc396:                                       ; preds = %for.body389
  %301 = load i32, i32* %index385, align 4
  %inc397 = add i32 %301, 1
  store i32 %inc397, i32* %index385, align 4
  br label %for.cond386

for.end398:                                       ; preds = %for.cond386
  br label %if.end399

if.end399:                                        ; preds = %for.end398, %if.else380
  br label %if.end400

if.end400:                                        ; preds = %if.end399, %for.end379
  br label %if.end401

if.end401:                                        ; preds = %if.end400, %for.end343
  %302 = load i32*, i32** %o288, align 4
  %303 = bitcast i32* %302 to i8*
  call void @free(i8* %303)
  store i32* null, i32** %o288, align 4
  store double* null, double** %cummin_array, align 4
  %304 = load double*, double** %cummin_input, align 4
  %305 = load i32, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
  %call402 = call double* @cummin(double* %304, i32 %305)
  store double* %call402, double** %cummin_array, align 4
  %306 = load double*, double** %cummin_input, align 4
  %307 = bitcast double* %306 to i8*
  call void @free(i8* %307)
  store double* null, double** %cummin_input, align 4
  %308 = load double*, double** %cummin_array, align 4
  %309 = load i32, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
  %call404 = call double* @pminx(double* %308, i32 %309, double 1.000000e+00)
  store double* %call404, double** %pmin403, align 4
  %310 = load double*, double** %cummin_array, align 4
  %311 = bitcast double* %310 to i8*
  call void @free(i8* %311)
  store double* null, double** %cummin_array, align 4
  %312 = load i32, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
  %mul405 = mul i32 %312, 8
  %call406 = call noalias i8* @malloc(i32 %mul405)
  %313 = bitcast i8* %call406 to double*
  store double* %313, double** %q_array, align 4
  store i32 0, i32* %index407, align 4
  br label %for.cond408

for.cond408:                                      ; preds = %for.inc415, %if.end401
  %314 = load i32, i32* %index407, align 4
  %315 = load i32, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
  %cmp409 = icmp ult i32 %314, %315
  br i1 %cmp409, label %for.body411, label %for.end417

for.body411:                                      ; preds = %for.cond408
  %316 = load double*, double** %pmin403, align 4
  %317 = load i32*, i32** %ro315, align 4
  %318 = load i32, i32* %index407, align 4
  %arrayidx412 = getelementptr inbounds i32, i32* %317, i32 %318
  %319 = load i32, i32* %arrayidx412, align 4
  %arrayidx413 = getelementptr inbounds double, double* %316, i32 %319
  %320 = load double, double* %arrayidx413, align 8
  %321 = load double*, double** %q_array, align 4
  %322 = load i32, i32* %index407, align 4
  %arrayidx414 = getelementptr inbounds double, double* %321, i32 %322
  store double %320, double* %arrayidx414, align 8
  br label %for.inc415

for.inc415:                                       ; preds = %for.body411
  %323 = load i32, i32* %index407, align 4
  %inc416 = add i32 %323, 1
  store i32 %inc416, i32* %index407, align 4
  br label %for.cond408

for.end417:                                       ; preds = %for.cond408
  %324 = load i32*, i32** %ro315, align 4
  %325 = bitcast i32* %324 to i8*
  call void @free(i8* %325)
  store i32* null, i32** %ro315, align 4
  %326 = load double*, double** %pmin403, align 4
  %327 = bitcast double* %326 to i8*
  call void @free(i8* %327)
  store double* null, double** %pmin403, align 4
  %328 = load double*, double** %q_array, align 4
  store double* %328, double** %retval, align 4
  br label %return

return:                                           ; preds = %for.end417, %for.end284, %for.end108, %for.end
  %329 = load double*, double** %retval, align 4
  ret double* %329
}

declare i32 @strcasecmp(i8* %0, i8* %1) #1

; Function Attrs: noinline nounwind optnone
define hidden i32 @main() #0 {
entry:
  %retval = alloca i32, align 4
  %PVALUES = alloca [50 x double], align 16
  %CORRECT_ANSWERS = alloca [6 x [50 x double]], align 16
  %TYPES = alloca [6 x i8*], align 16
  %type = alloca i16, align 2
  %q = alloca double*, align 4
  %error = alloca double, align 8
  %i = alloca i32, align 4
  %this_error = alloca double, align 8
  store i32 0, i32* %retval, align 4
  %0 = bitcast [50 x double]* %PVALUES to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 16 %0, i8* align 16 bitcast ([50 x double]* @__const.main.PVALUES to i8*), i32 400, i1 false)
  %1 = bitcast [6 x [50 x double]]* %CORRECT_ANSWERS to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 16 %1, i8* align 16 bitcast ([6 x [50 x double]]* @__const.main.CORRECT_ANSWERS to i8*), i32 2400, i1 false)
  %2 = bitcast [6 x i8*]* %TYPES to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 16 %2, i8* align 16 bitcast ([6 x i8*]* @__const.main.TYPES to i8*), i32 24, i1 false)
  store i16 0, i16* %type, align 2
  br label %for.cond

for.cond:                                         ; preds = %for.inc19, %entry
  %3 = load i16, i16* %type, align 2
  %conv = zext i16 %3 to i32
  %cmp = icmp sle i32 %conv, 5
  br i1 %cmp, label %for.body, label %for.end21

for.body:                                         ; preds = %for.cond
  %arraydecay = getelementptr inbounds [50 x double], [50 x double]* %PVALUES, i32 0, i32 0
  %4 = load i16, i16* %type, align 2
  %idxprom = zext i16 %4 to i32
  %arrayidx = getelementptr inbounds [6 x i8*], [6 x i8*]* %TYPES, i32 0, i32 %idxprom
  %5 = load i8*, i8** %arrayidx, align 4
  %call = call double* @p_adjust(double* %arraydecay, i32 50, i8* %5)
  store double* %call, double** %q, align 4
  %6 = load double*, double** %q, align 4
  %arrayidx2 = getelementptr inbounds double, double* %6, i32 0
  %7 = load double, double* %arrayidx2, align 8
  %8 = load i16, i16* %type, align 2
  %idxprom3 = zext i16 %8 to i32
  %arrayidx4 = getelementptr inbounds [6 x [50 x double]], [6 x [50 x double]]* %CORRECT_ANSWERS, i32 0, i32 %idxprom3
  %arrayidx5 = getelementptr inbounds [50 x double], [50 x double]* %arrayidx4, i32 0, i32 0
  %9 = load double, double* %arrayidx5, align 16
  %sub = fsub double %7, %9
  %10 = call double @llvm.fabs.f64(double %sub)
  store double %10, double* %error, align 8
  store i32 1, i32* %i, align 4
  br label %for.cond6

for.cond6:                                        ; preds = %for.inc, %for.body
  %11 = load i32, i32* %i, align 4
  %cmp7 = icmp ult i32 %11, 50
  br i1 %cmp7, label %for.body9, label %for.end

for.body9:                                        ; preds = %for.cond6
  %12 = load double*, double** %q, align 4
  %13 = load i32, i32* %i, align 4
  %arrayidx10 = getelementptr inbounds double, double* %12, i32 %13
  %14 = load double, double* %arrayidx10, align 8
  %15 = load i16, i16* %type, align 2
  %idxprom11 = zext i16 %15 to i32
  %arrayidx12 = getelementptr inbounds [6 x [50 x double]], [6 x [50 x double]]* %CORRECT_ANSWERS, i32 0, i32 %idxprom11
  %16 = load i32, i32* %i, align 4
  %arrayidx13 = getelementptr inbounds [50 x double], [50 x double]* %arrayidx12, i32 0, i32 %16
  %17 = load double, double* %arrayidx13, align 8
  %sub14 = fsub double %14, %17
  %18 = call double @llvm.fabs.f64(double %sub14)
  store double %18, double* %this_error, align 8
  %19 = load double, double* %this_error, align 8
  %20 = load double, double* %error, align 8
  %add = fadd double %20, %19
  store double %add, double* %error, align 8
  br label %for.inc

for.inc:                                          ; preds = %for.body9
  %21 = load i32, i32* %i, align 4
  %inc = add i32 %21, 1
  store i32 %inc, i32* %i, align 4
  br label %for.cond6

for.end:                                          ; preds = %for.cond6
  %22 = load double*, double** %q, align 4
  call void @double_say(double* %22, i32 50)
  %23 = load double*, double** %q, align 4
  %24 = bitcast double* %23 to i8*
  call void @free(i8* %24)
  store double* null, double** %q, align 4
  %25 = load i16, i16* %type, align 2
  %conv15 = zext i16 %25 to i32
  %26 = load i16, i16* %type, align 2
  %idxprom16 = zext i16 %26 to i32
  %arrayidx17 = getelementptr inbounds [6 x i8*], [6 x i8*]* %TYPES, i32 0, i32 %idxprom16
  %27 = load i8*, i8** %arrayidx17, align 4
  %28 = load double, double* %error, align 8
  %call18 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([44 x i8], [44 x i8]* @.str.28, i32 0, i32 0), i32 %conv15, i8* %27, double %28)
  br label %for.inc19

for.inc19:                                        ; preds = %for.end
  %29 = load i16, i16* %type, align 2
  %inc20 = add i16 %29, 1
  store i16 %inc20, i16* %type, align 2
  br label %for.cond

for.end21:                                        ; preds = %for.cond
  ret i32 0
}

; Function Attrs: argmemonly nounwind willreturn
declare void @llvm.memcpy.p0i8.p0i8.i32(i8* noalias nocapture writeonly %0, i8* noalias nocapture readonly %1, i32 %2, i1 immarg %3) #3

; Function Attrs: nounwind readnone speculatable willreturn
declare double @llvm.fabs.f64(double %0) #4

attributes #0 = { noinline nounwind optnone "correctly-rounded-divide-sqrt-fp-math"="false" "disable-tail-calls"="false" "frame-pointer"="none" "less-precise-fpmad"="false" "min-legal-vector-width"="0" "no-infs-fp-math"="false" "no-jump-tables"="false" "no-nans-fp-math"="false" "no-signed-zeros-fp-math"="false" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="generic" "unsafe-fp-math"="false" "use-soft-float"="false" }
attributes #1 = { "correctly-rounded-divide-sqrt-fp-math"="false" "disable-tail-calls"="false" "frame-pointer"="none" "less-precise-fpmad"="false" "no-infs-fp-math"="false" "no-nans-fp-math"="false" "no-signed-zeros-fp-math"="false" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="generic" "unsafe-fp-math"="false" "use-soft-float"="false" }
attributes #2 = { noreturn "correctly-rounded-divide-sqrt-fp-math"="false" "disable-tail-calls"="false" "frame-pointer"="none" "less-precise-fpmad"="false" "no-infs-fp-math"="false" "no-nans-fp-math"="false" "no-signed-zeros-fp-math"="false" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="generic" "unsafe-fp-math"="false" "use-soft-float"="false" }
attributes #3 = { argmemonly nounwind willreturn }
attributes #4 = { nounwind readnone speculatable willreturn }
attributes #5 = { noreturn }

!llvm.module.flags = !{!0}
!llvm.ident = !{!1}

!0 = !{i32 1, !"wchar_size", i32 4}
!1 = !{!"clang version 11.0.0 (https://github.com/Jacarte/llvm-project.git 0f6dea67136cc1e0b3d200eb2bb165628970c44b)"}

; extracted candidates

; *****
; For LLVM instruction:
;  %frombool = zext i1 %DECREASING to i8
; Looking for a replacement for:
%0:i1 = var
%1:i8 = zext %0
infer %1

; *****
; For LLVM instruction:
;  %0 = load i32, i32* %SIZE.addr, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %mul = mul i32 %0, 4
; Looking for a replacement for:
%0:i32 = var
%1:i32 = mul 4:i32, %0
infer %1

; *****
; For LLVM instruction:
;  %cmp = icmp eq i32* %2, null
; Looking for a replacement for:
%0:i32 = var
%1:i1 = eq 0:i32, %0
infer %1

; *****
; For LLVM instruction:
;  %3 = load i32, i32* %SIZE.addr, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %mul2 = mul i32 8, %3
; Looking for a replacement for:
%0:i32 = var
%1:i32 = mul 8:i32, %0
infer %1

; *****
; For LLVM instruction:
;  %cmp4 = icmp eq double* %5, null
; Looking for a replacement for:
%0:i32 = var
%1:i1 = eq 0:i32, %0
infer %1

; *****
; For LLVM instruction:
;  %6 = load i32, i32* %i, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %7 = load i32, i32* %SIZE.addr, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %cmp8 = icmp ult i32 %6, %7
; Looking for a replacement for:
%0:i32 = var
%1:i32 = var
%2:i1 = ult %0, %1
infer %2

; *****
; For LLVM instruction:
;  %9 = load i32, i32* %i, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %12 = load i32, i32* %i, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %13 = load i32, i32* %i, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %15 = load i32, i32* %i, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %16 = load i32, i32* %i, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %inc = add i32 %16, 1
; Looking for a replacement for:
%0:i32 = var
%1:i32 = add 1:i32, %0
infer %1

; *****
; For LLVM instruction:
;  %17 = load i8, i8* %DECREASING.addr, align 1
; Looking for a replacement for:
%0:i8 = var
infer %0 (demandedBits=00000001)

; *****
; For LLVM instruction:
;  %tobool = trunc i8 %17 to i1
; Looking for a replacement for:
%0:i8 = var
%1:i1 = trunc %0
infer %1

; *****
; For LLVM instruction:
;  %conv = zext i1 %tobool to i32
; Looking for a replacement for:
%0:i8 = var
%1:i1 = trunc %0
%2:i32 = zext %1
infer %2

; *****
; For LLVM instruction:
;  %cmp11 = icmp eq i32 %conv, 0
; Looking for a replacement for:
%0:i8 = var
%1:i1 = trunc %0
%2:i32 = zext %1
%3:i1 = eq 0:i32, %2
infer %3

; *****
; For LLVM instruction:
;  %20 = load i32, i32* %SIZE.addr, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %21 = load i8, i8* %DECREASING.addr, align 1
; Looking for a replacement for:
%0:i8 = var
infer %0 (demandedBits=00000001)

; *****
; For LLVM instruction:
;  %tobool14 = trunc i8 %21 to i1
; Looking for a replacement for:
%0:i8 = var
%1:i1 = trunc %0
infer %1

; *****
; For LLVM instruction:
;  %conv15 = zext i1 %tobool14 to i32
; Looking for a replacement for:
%0:i8 = var
%1:i1 = trunc %0
%2:i32 = zext %1
infer %2

; *****
; For LLVM instruction:
;  %cmp16 = icmp eq i32 %conv15, 1
; Looking for a replacement for:
%0:i8 = var
%1:i1 = trunc %0
%2:i32 = zext %1
%3:i1 = eq 1:i32, %2
infer %3

; *****
; For LLVM instruction:
;  %24 = load i32, i32* %SIZE.addr, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0
got 2 candidates from LHS

-------------------------------------------------
%0:i1 = var
%1:i8 = zext %0
infer %1


--------------------------------
guess 0

%0:i8 = var ; reservedconst_1

Cost = 0
first query is SAT, returning the model:
reservedconst_1: 0
0 th attempt: second query is SAT-- constant doesn't work
first query is SAT, returning the model:
reservedconst_1: 1
1 th attempt: second query is SAT-- constant doesn't work
first query is UNSAT-- no more guesses
Dataflow Pruned 0/0
There are 1 Guesses
There are 0 RHSs before deduplication
There are 0 RHSs after deduplication
got 2 candidates from LHS

-------------------------------------------------
%0:i32 = var
%1:i32 = mul 4:i32, %0
infer %1


--------------------------------
guess 0

%0:i32 = var ; reservedconst_1

Cost = 0
first query is SAT, returning the model:
reservedconst_1: 0
0 th attempt: second query is SAT-- constant doesn't work
first query is SAT, returning the model:
reservedconst_1: 1073741824
1 th attempt: second query is SAT-- constant doesn't work
first query is UNSAT-- no more guesses

--------------------------------
guess 1

%0:i32 = var

Cost = 0
second query is SAT-- constant doesn't work
Dataflow Pruned 0/0
There are 2 Guesses
There are 0 RHSs before deduplication
There are 0 RHSs after deduplication
got 2 candidates from LHS

-------------------------------------------------
%0:i32 = var
%1:i32 = mul 8:i32, %0
infer %1


--------------------------------
guess 0

%0:i32 = var ; reservedconst_1

Cost = 0
first query is SAT, returning the model:
reservedconst_1: 0
0 th attempt: second query is SAT-- constant doesn't work
first query is SAT, returning the model:
reservedconst_1: 1073741824
1 th attempt: second query is SAT-- constant doesn't work
first query is UNSAT-- no more guesses

--------------------------------
guess 1

%0:i32 = var

Cost = 0
second query is SAT-- constant doesn't work
Dataflow Pruned 0/0
There are 2 Guesses
There are 0 RHSs before deduplication
There are 0 RHSs after deduplication
got 1 candidates from LHS

-------------------------------------------------
%0:i8 = var
infer %0 (demandedBits=00000001)


--------------------------------
guess 0

%0:i8 = var ; reservedconst_1

Cost = 0
first query is SAT, returning the model:
reservedconst_1: 0
0 th attempt: second query is SAT-- constant doesn't work
first query is SAT, returning the model:
reservedconst_1: 1
1 th attempt: second query is SAT-- constant doesn't work
first query is UNSAT-- no more guesses
Dataflow Pruned 0/0
There are 1 Guesses
There are 0 RHSs before deduplication
There are 0 RHSs after deduplication
got 2 candidates from LHS

-------------------------------------------------
%0:i8 = var
%1:i1 = trunc %0
infer %1


--------------------------------
guess 0

%0:i1 = var ; reservedconst_1

Cost = 0
first query is SAT, returning the model:
reservedconst_1: 0
0 th attempt: second query is SAT-- constant doesn't work
first query is SAT, returning the model:
reservedconst_1: -1
1 th attempt: second query is SAT-- constant doesn't work
first query is UNSAT-- no more guesses
Dataflow Pruned 0/0
There are 1 Guesses
There are 0 RHSs before deduplication
There are 0 RHSs after deduplication
got 3 candidates from LHS

-------------------------------------------------
%0:i8 = var
%1:i1 = trunc %0
%2:i32 = zext %1
infer %2


--------------------------------
guess 0

%0:i32 = var ; reservedconst_1

Cost = 0
first query is SAT, returning the model:
reservedconst_1: 0
0 th attempt: second query is SAT-- constant doesn't work
first query is SAT, returning the model:
reservedconst_1: 1
1 th attempt: second query is SAT-- constant doesn't work
first query is UNSAT-- no more guesses
Dataflow Pruned 0/0
There are 1 Guesses
There are 0 RHSs before deduplication
There are 0 RHSs after deduplication
got 4 candidates from LHS

-------------------------------------------------
%0:i8 = var
%1:i1 = trunc %0
%2:i32 = zext %1
%3:i1 = eq 0:i32, %2
infer %3


--------------------------------
guess 0

%0:i1 = var ; reservedconst_1

Cost = 0
first query is SAT, returning the model:
reservedconst_1: -1
0 th attempt: second query is SAT-- constant doesn't work
first query is SAT, returning the model:
reservedconst_1: 0
1 th attempt: second query is SAT-- constant doesn't work
first query is UNSAT-- no more guesses

--------------------------------
guess 1

%0:i8 = var
%1:i1 = trunc %0

Cost = 1
second query is SAT-- constant doesn't work
Dataflow Pruned 0/0
There are 2 Guesses
There are 0 RHSs before deduplication
There are 0 RHSs after deduplication
got 4 candidates from LHS

-------------------------------------------------
%0:i8 = var
%1:i1 = trunc %0
%2:i32 = zext %1
%3:i1 = eq 1:i32, %2
infer %3


--------------------------------
guess 0

%0:i1 = var ; reservedconst_1

Cost = 0
first query is SAT, returning the model:
reservedconst_1: 0
0 th attempt: second query is SAT-- constant doesn't work
first query is SAT, returning the model:
reservedconst_1: -1
1 th attempt: second query is SAT-- constant doesn't work
first query is UNSAT-- no more guesses

--------------------------------
guess 1

%0:i8 = var
%1:i1 = trunc %0

Cost = 1
second query is UNSAT
Dataflow Pruned 0/0
There are 2 Guesses
There are 1 RHSs before deduplication
There are 1 RHSs after deduplication
"
; No valid RHS in the list
#########################################################

Module before replacement:
; ModuleID = './P-value_correction.c.bc'
source_filename = "./P-value_correction.c"
target datalayout = "e-m:e-p:32:32-i64:64-n32:64-S128"
target triple = "wasm32-unknown-wasi"

@.str = private unnamed_addr constant [29 x i8] c"malloc failed at %s line %u\0A\00", align 1
@.str.1 = private unnamed_addr constant [23 x i8] c"./P-value_correction.c\00", align 1
@.str.2 = private unnamed_addr constant [1 x i8] zeroinitializer, align 1
@base_arr = hidden global double* null, align 4
@.str.3 = private unnamed_addr constant [33 x i8] c"failed to malloc at %s line %u.\0A\00", align 1
@.str.4 = private unnamed_addr constant [48 x i8] c"cummin function requires at least one element.\0A\00", align 1
@.str.5 = private unnamed_addr constant [22 x i8] c"Failed at %s line %u\0A\00", align 1
@.str.6 = private unnamed_addr constant [41 x i8] c"function requires at least one element.\0A\00", align 1
@.str.7 = private unnamed_addr constant [37 x i8] c"pmin requires at least one element.\0A\00", align 1
@.str.8 = private unnamed_addr constant [7 x i8] c"[1] %e\00", align 1
@.str.9 = private unnamed_addr constant [7 x i8] c" %.10f\00", align 1
@.str.10 = private unnamed_addr constant [6 x i8] c"\0A[%u]\00", align 1
@.str.11 = private unnamed_addr constant [2 x i8] c"\0A\00", align 1
@.str.12 = private unnamed_addr constant [34 x i8] c"Failure to malloc at %s line %u.\0A\00", align 1
@.str.13 = private unnamed_addr constant [41 x i8] c"p_adjust requires at least one element.\0A\00", align 1
@.str.14 = private unnamed_addr constant [3 x i8] c"BH\00", align 1
@.str.15 = private unnamed_addr constant [4 x i8] c"fdr\00", align 1
@.str.16 = private unnamed_addr constant [3 x i8] c"by\00", align 1
@.str.17 = private unnamed_addr constant [11 x i8] c"Bonferroni\00", align 1
@.str.18 = private unnamed_addr constant [9 x i8] c"hochberg\00", align 1
@.str.19 = private unnamed_addr constant [5 x i8] c"holm\00", align 1
@.str.20 = private unnamed_addr constant [7 x i8] c"hommel\00", align 1
@.str.21 = private unnamed_addr constant [44 x i8] c"%s doesn't match any accepted FDR methods.\0A\00", align 1
@.str.22 = private unnamed_addr constant [42 x i8] c"%g is outside of the interval I planned.\0A\00", align 1
@.str.23 = private unnamed_addr constant [23 x i8] c"Failure at %s line %u\0A\00", align 1
@.str.24 = private unnamed_addr constant [54 x i8] c"array[%u] = %lf, which is outside the interval [0,1]\0A\00", align 1
@.str.25 = private unnamed_addr constant [20 x i8] c"died at %s line %u\0A\00", align 1
@__const.main.PVALUES = private unnamed_addr constant [50 x double] [double 0x3FDD04160F35FDE9, double 0x3FE758E721E2A8D7, double 0x3FB96FAC8B38D8BA, double 0x3FB73E71D5B04B37, double 0x3FC710AB48EE865B, double 0x3FEC01D953C3CC73, double 0x3FD2B3C4BE0A922A, double 0x3FED2B5A568DAB4F, double 0x3FDBE08D73F16964, double 0x3FE10A218C41C242, double 0x3FDF8810DB1996AA, double 0x3FE291CCB11E1A9D, double 0x3FD64E8C550D788F, double 7.883130e-01, double 0x3FD177B2BF048D2D, double 0x3FEB3543434BAF2B, double 0x3FDB50EAD41ED0A6, double 0x3FE49D4AFF01D33F, double 0x3FD364C9AE345B51, double 0x3FA99BA35F15394D, double 3.194810e-01, double 0x3FE941E405CE761A, double 0x3FEFF94F77369843, double 0x3FC65847BFB23217, double 0x3FECEB8879B6A543, double 0x3FBEAF00332BA677, double 0x3FD96207C7749E38, double 0x3F8CC02620502C93, double 0x3FE773A5B45A0F40, double 0x3FB1642C24762C01, double 4.040730e-03, double 0x3F33E11D79A90777, double 0x3F870B02BD749528, double 0x3F98521BD6A0353F, double 0x3F4310F26148FFAA, double 0x3F3427CD76006778, double 0x3F80E60AFB1F8A4E, double 0x3F5639B74A9E4DA2, double 0x3F8BDDF74195769F, double 0x3F38ABEE3BFA8581, double 0x3EF2E2E96B5466FE, double 0x3E90CE9F65B58A88, double 0x3FA0F2D097879B95, double 0x3F834EE7216A6684, double 0x3F4CCE8DBB40BD9D, double 0x3F2C8B969590F2ED, double 0x3F4FC31F7F1541AD, double 6.610250e-05, double 0x3F9DB44EA6AC26BA, double 5.735490e-03], align 16
@__const.main.CORRECT_ANSWERS = private unnamed_addr constant [6 x [50 x double]] [[50 x double] [double 0x3FE39AFA2199ADBC, double 8.521710e-01, double 0x3FC96FAC6045BAF5, double 0x3FC83660E51D25AB, double 0x3FD498068702BE20, double 0x3FEDC3BF727136A4, double 4.870370e-01, double 0x3FEDC3BF727136A4, double 0x3FE35BF08BEEB62C, double 0x3FE5D879DEE92F03, double 0x3FE4BE91D656B94A, double 0x3FE7363FC28DAEAA, double 0x3FE0E62C4F13638A, double 0x3FEC1052C8FAB035, double 0x3FDE1DD2E43E029A, double 0x3FED92EFFC7CBDC1, double 0x3FE35BF08BEEB62C, double 0x3FE923B90CFC67C5, double 0x3FDF47B8FC357024, double 0x3FBD1996A9FB10AD, double 0x3FDFF2B6D6C14255, double 0x3FEC1052C8FAB035, double 0x3FEFF94F77369843, double 0x3FD498068702BE20, double 0x3FEDC3BF727136A4, double 0x3FCD80E2E96EC403, double 0x3FE2A9F6A93F290B, double 0x3FA3F736D8AF2E2B, double 8.521710e-01, double 0x3FC2E751B350FAC4, double 0x3F913D8E55EE9F05, double 0x3F64FECB88BB3633, double 0x3FA2009A03CCBE34, double 0x3FB0001FB57CF9FC, double 0x3F6DCA7ADA5E274A, double 0x3F64FECB88BB3633, double 0x3F9E2D13B467D120, double 0x3F7941963399C6A1, double 0x3FA3F736D8AF2E2B, double 0x3F6607390CEF853C, double 0x3F3D828C80BA213A, double 0x3EEA42D90EEBA875, double 0x3FB42D4181AA8F8B, double 0x3FA01715F12E0018, double 0x3F73D9F3AF6D490C, double 0x3F64FECB88BB3633, double 0x3F73D9F3AF6D490C, double 0x3F520CE5F51A7C61, double 0x3FB290B112B20952, double 0x3F9696C95AA76B69], [50 x double] [double 1.000000e+00, double 1.000000e+00, double 0x3FEC9C56E33BA41B, double 0x3FEB3BF21E95ED3D, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 0x3FE05DA74553C727, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 0x3FC675198790829A, double 1.000000e+00, double 0x3FE54345648E1F12, double 0x3FB3645F501CA2F9, double 0x3F879D934E50F0DE, double 0x3FC43FC3646E3EA2, double 0x3FD1FF539D36064C, double 0x3F90C123206B855F, double 0x3F879D934E50F0DE, double 0x3FC0F8967F32E606, double 0x3F9C6880470D2FBE, double 0x3FC675198790829A, double 0x3F88C70105E47082, double 2.025930e-03, double 0x3F0D89DE4FA8F818, double 0x3FD6B1E2D11B1027, double 0x3FC219271872BD8D, double 0x3F96542FAD16CEF9, double 0x3F879D934E50F0DE, double 0x3F96542FAD16CEF9, double 0x3F744D9816EB319A, double 0x3FD4E1D5728DBC16, double 0x3FB9687C40426555], [50 x double] [double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 0x3FE6761DC93EA2D3, double 1.000000e+00, double 1.000000e+00, double 0x3FC9DC55000C953A, double 0x3F8F0FBD624BA499, double 0x3FE2009A24031487, double 1.000000e+00, double 0x3F9DCA7AB8020F7A, double 0x3F8F7E310860A1AB, double 0x3FDA677128614819, double 6.782670e-02, double 6.803480e-01, double 0x3F9346521EDBB84D, double 0x3F4D828CB7B3E0EE, double 0x3EEA42D90EEBA875, double 1.000000e+00, double 4.713920e-01, double 0x3FA6815EE53DB1E7, double 0x3F864D0CF90CC6B8, double 0x3FA8D0709B489B4F, double 0x3F6B1359791819D2, double 1.000000e+00, double 0x3FD25A836EB4E981], [50 x double] [double 0x3FEFF94F77369843, double 0x3FEFF94F77369843, double 0x3FEFF94F77369843, double 0x3FEFF94F77369843, double 0x3FEFF94F77369843, double 0x3FEFF94F77369843, double 0x3FEFF94F77369843, double 0x3FEFF94F77369843, double 0x3FEFF94F77369843, double 0x3FEFF94F77369843, double 0x3FEFF94F77369843, double 0x3FEFF94F77369843, double 0x3FEFF94F77369843, double 0x3FEFF94F77369843, double 0x3FEFF94F77369843, double 0x3FEFF94F77369843, double 0x3FEFF94F77369843, double 0x3FEFF94F77369843, double 0x3FEFF94F77369843, double 0x3FEFF94F77369843, double 0x3FEFF94F77369843, double 0x3FEFF94F77369843, double 0x3FEFF94F77369843, double 0x3FEFF94F77369843, double 0x3FEFF94F77369843, double 0x3FEFF94F77369843, double 0x3FEFF94F77369843, double 0x3FDDA6274695E687, double 0x3FEFF94F77369843, double 0x3FEFF94F77369843, double 0x3FC42BDC26DCE39B, double 0x3F8C57F9104CA951, double 0x3FD9340AC9879DEF, double 7.600230e-01, double 0x3F999EC5A86B439B, double 0x3F8C57F9104CA951, double 0x3FD389FCD90412B4, double 0x3FABC8251D45E10B, double 0x3FDD9BD68ABBB045, double 0x3F90F633F956C386, double 8.825610e-04, double 0x3EEA42D90EEBA875, double 0x3FEFC7471C1E43B8, double 0x3FD5B8C4014C305A, double 0x3FA2E78CEC8D068E, double 0x3F84F6832995A599, double 0x3FA459002162FC24, double 3.172920e-03, double 8.992520e-01, double 0x3FCBE5BD5E9AC00A], [50 x double] [double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 0x3FDDA6274695E687, double 1.000000e+00, double 1.000000e+00, double 0x3FC42BDC26DCE39B, double 0x3F8C939AFCF101E0, double 0x3FD9340AC9879DEF, double 7.600230e-01, double 0x3F999EC5A86B439B, double 0x3F8C939AFCF101E0, double 0x3FD389FCD90412B4, double 0x3FABC8251D45E10B, double 0x3FDD9BD68ABBB045, double 0x3F90F633F956C386, double 8.825610e-04, double 0x3EEA42D90EEBA875, double 0x3FEFC7471C1E43B8, double 0x3FD5B8C4014C305A, double 0x3FA2E78CEC8D068E, double 0x3F84F6832995A599, double 0x3FA459002162FC24, double 3.172920e-03, double 8.992520e-01, double 0x3FCBE5BD5E9AC00A], [50 x double] [double 0x3FEFF94F77369843, double 0x3FEFF94F77369843, double 0x3FEFF94F77369843, double 0x3FEFF5DC908F2EDD, double 0x3FEFF94F77369843, double 0x3FEFF94F77369843, double 0x3FEFF94F77369843, double 0x3FEFF94F77369843, double 0x3FEFF94F77369843, double 0x3FEFF94F77369843, double 0x3FEFF94F77369843, double 0x3FEFF94F77369843, double 0x3FEFF94F77369843, double 0x3FEFF94F77369843, double 0x3FEFF94F77369843, double 0x3FEFF94F77369843, double 0x3FEFF94F77369843, double 0x3FEFF94F77369843, double 0x3FEFF94F77369843, double 0x3FEEB45F17BD8BE7, double 0x3FEFF94F77369843, double 0x3FEFF94F77369843, double 0x3FEFF94F77369843, double 0x3FEFF94F77369843, double 0x3FEFF94F77369843, double 0x3FEFF94F77369843, double 0x3FEFF94F77369843, double 0x3FDBDA250F840182, double 0x3FEFF94F77369843, double 0x3FEF40BC1D52205E, double 0x3FC21A3BEB689947, double 1.304340e-02, double 0x3FD69916517B1CD7, double 0x3FE60A69453DF7B2, double 0x3F986DB666D9D3C6, double 0x3F8B157BBD3AB385, double 2.722920e-01, double 0x3FABC8251D45E10B, double 0x3FDAFF07B27BE8AF, double 0x3F9030D45E3B9F93, double 8.825610e-04, double 0x3EEA42D90EEBA875, double 0x3FEBFACC1948A662, double 0x3FD34EE6EDE042CB, double 0x3FA2011883DA6A9A, double 0x3F839FF779153716, double 0x3FA3D9F3D1C960DD, double 3.172920e-03, double 0x3FE9FDC4BC5D1301, double 0x3FC8F5FAC3801CF1]], align 16
@.str.26 = private unnamed_addr constant [3 x i8] c"bh\00", align 1
@.str.27 = private unnamed_addr constant [11 x i8] c"bonferroni\00", align 1
@__const.main.TYPES = private unnamed_addr constant [6 x i8*] [i8* getelementptr inbounds ([3 x i8], [3 x i8]* @.str.26, i32 0, i32 0), i8* getelementptr inbounds ([3 x i8], [3 x i8]* @.str.16, i32 0, i32 0), i8* getelementptr inbounds ([11 x i8], [11 x i8]* @.str.27, i32 0, i32 0), i8* getelementptr inbounds ([9 x i8], [9 x i8]* @.str.18, i32 0, i32 0), i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.19, i32 0, i32 0), i8* getelementptr inbounds ([7 x i8], [7 x i8]* @.str.20, i32 0, i32 0)], align 16
@.str.28 = private unnamed_addr constant [44 x i8] c"\0Atype %u = '%s' has cumulative error of %g\0A\00", align 1
@llvm.used = appending global [1 x i8*] [i8* bitcast (i32 ()* @__main_void to i8*)], section "llvm.metadata"

@__main_void = alias i32 (), i32 ()* @main

; Function Attrs: noinline nounwind optnone
define hidden i32* @seq_len(i32 %START, i32 %END) #0 {
entry:
  %retval = alloca i32*, align 4
  %START.addr = alloca i32, align 4
  %END.addr = alloca i32, align 4
  %start = alloca i32, align 4
  %end = alloca i32, align 4
  %sequence = alloca i32*, align 4
  %i = alloca i32, align 4
  %LENGTH = alloca i32, align 4
  %sequence10 = alloca i32*, align 4
  %index = alloca i32, align 4
  %index28 = alloca i32, align 4
  store i32 %START, i32* %START.addr, align 4
  store i32 %END, i32* %END.addr, align 4
  %0 = load i32, i32* %START.addr, align 4
  store i32 %0, i32* %start, align 4
  %1 = load i32, i32* %END.addr, align 4
  store i32 %1, i32* %end, align 4
  %2 = load i32, i32* %START.addr, align 4
  %3 = load i32, i32* %END.addr, align 4
  %cmp = icmp eq i32 %2, %3
  br i1 %cmp, label %if.then, label %if.end6

if.then:                                          ; preds = %entry
  %4 = load i32, i32* %end, align 4
  %add = add i32 %4, 1
  %mul = mul i32 %add, 4
  %call = call noalias i8* @malloc(i32 %mul)
  %5 = bitcast i8* %call to i32*
  store i32* %5, i32** %sequence, align 4
  %6 = load i32*, i32** %sequence, align 4
  %cmp1 = icmp eq i32* %6, null
  br i1 %cmp1, label %if.then2, label %if.end

if.then2:                                         ; preds = %if.then
  %call3 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([29 x i8], [29 x i8]* @.str, i32 0, i32 0), i8* getelementptr inbounds ([23 x i8], [23 x i8]* @.str.1, i32 0, i32 0), i32 15)
  call void @perror(i8* getelementptr inbounds ([1 x i8], [1 x i8]* @.str.2, i32 0, i32 0))
  call void @exit(i32 1) #5
  unreachable

if.end:                                           ; preds = %if.then
  store i32 0, i32* %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.end
  %7 = load i32, i32* %i, align 4
  %8 = load i32, i32* %end, align 4
  %cmp4 = icmp ult i32 %7, %8
  br i1 %cmp4, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %9 = load i32, i32* %i, align 4
  %add5 = add i32 %9, 1
  %10 = load i32*, i32** %sequence, align 4
  %11 = load i32, i32* %i, align 4
  %arrayidx = getelementptr inbounds i32, i32* %10, i32 %11
  store i32 %add5, i32* %arrayidx, align 4
  br label %for.inc

for.inc:                                          ; preds = %for.body
  %12 = load i32, i32* %i, align 4
  %inc = add i32 %12, 1
  store i32 %inc, i32* %i, align 4
  br label %for.cond

for.end:                                          ; preds = %for.cond
  %13 = load i32*, i32** %sequence, align 4
  store i32* %13, i32** %retval, align 4
  br label %return

if.end6:                                          ; preds = %entry
  %14 = load i32, i32* %START.addr, align 4
  %15 = load i32, i32* %END.addr, align 4
  %cmp7 = icmp ugt i32 %14, %15
  br i1 %cmp7, label %if.then8, label %if.end9

if.then8:                                         ; preds = %if.end6
  %16 = load i32, i32* %START.addr, align 4
  store i32 %16, i32* %end, align 4
  %17 = load i32, i32* %END.addr, align 4
  store i32 %17, i32* %start, align 4
  br label %if.end9

if.end9:                                          ; preds = %if.then8, %if.end6
  %18 = load i32, i32* %end, align 4
  %19 = load i32, i32* %start, align 4
  %sub = sub i32 %18, %19
  store i32 %sub, i32* %LENGTH, align 4
  %20 = load i32, i32* %LENGTH, align 4
  %add11 = add i32 1, %20
  %mul12 = mul i32 %add11, 4
  %call13 = call noalias i8* @malloc(i32 %mul12)
  %21 = bitcast i8* %call13 to i32*
  store i32* %21, i32** %sequence10, align 4
  %22 = load i32*, i32** %sequence10, align 4
  %cmp14 = icmp eq i32* %22, null
  br i1 %cmp14, label %if.then15, label %if.end17

if.then15:                                        ; preds = %if.end9
  %call16 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([29 x i8], [29 x i8]* @.str, i32 0, i32 0), i8* getelementptr inbounds ([23 x i8], [23 x i8]* @.str.1, i32 0, i32 0), i32 31)
  call void @perror(i8* getelementptr inbounds ([1 x i8], [1 x i8]* @.str.2, i32 0, i32 0))
  call void @exit(i32 1) #5
  unreachable

if.end17:                                         ; preds = %if.end9
  %23 = load i32, i32* %START.addr, align 4
  %24 = load i32, i32* %END.addr, align 4
  %cmp18 = icmp ult i32 %23, %24
  br i1 %cmp18, label %if.then19, label %if.else

if.then19:                                        ; preds = %if.end17
  store i32 0, i32* %index, align 4
  br label %for.cond20

for.cond20:                                       ; preds = %for.inc25, %if.then19
  %25 = load i32, i32* %index, align 4
  %26 = load i32, i32* %LENGTH, align 4
  %cmp21 = icmp ule i32 %25, %26
  br i1 %cmp21, label %for.body22, label %for.end27

for.body22:                                       ; preds = %for.cond20
  %27 = load i32, i32* %start, align 4
  %28 = load i32, i32* %index, align 4
  %add23 = add i32 %27, %28
  %29 = load i32*, i32** %sequence10, align 4
  %30 = load i32, i32* %index, align 4
  %arrayidx24 = getelementptr inbounds i32, i32* %29, i32 %30
  store i32 %add23, i32* %arrayidx24, align 4
  br label %for.inc25

for.inc25:                                        ; preds = %for.body22
  %31 = load i32, i32* %index, align 4
  %inc26 = add i32 %31, 1
  store i32 %inc26, i32* %index, align 4
  br label %for.cond20

for.end27:                                        ; preds = %for.cond20
  br label %if.end37

if.else:                                          ; preds = %if.end17
  store i32 0, i32* %index28, align 4
  br label %for.cond29

for.cond29:                                       ; preds = %for.inc34, %if.else
  %32 = load i32, i32* %index28, align 4
  %33 = load i32, i32* %LENGTH, align 4
  %cmp30 = icmp ule i32 %32, %33
  br i1 %cmp30, label %for.body31, label %for.end36

for.body31:                                       ; preds = %for.cond29
  %34 = load i32, i32* %end, align 4
  %35 = load i32, i32* %index28, align 4
  %sub32 = sub i32 %34, %35
  %36 = load i32*, i32** %sequence10, align 4
  %37 = load i32, i32* %index28, align 4
  %arrayidx33 = getelementptr inbounds i32, i32* %36, i32 %37
  store i32 %sub32, i32* %arrayidx33, align 4
  br label %for.inc34

for.inc34:                                        ; preds = %for.body31
  %38 = load i32, i32* %index28, align 4
  %inc35 = add i32 %38, 1
  store i32 %inc35, i32* %index28, align 4
  br label %for.cond29

for.end36:                                        ; preds = %for.cond29
  br label %if.end37

if.end37:                                         ; preds = %for.end36, %for.end27
  %39 = load i32*, i32** %sequence10, align 4
  store i32* %39, i32** %retval, align 4
  br label %return

return:                                           ; preds = %if.end37, %for.end
  %40 = load i32*, i32** %retval, align 4
  ret i32* %40
}

declare noalias i8* @malloc(i32 %0) #1

declare i32 @printf(i8* %0, ...) #1

declare void @perror(i8* %0) #1

; Function Attrs: noreturn
declare void @exit(i32 %0) #2

; Function Attrs: noinline nounwind optnone
define hidden i32* @order(double* noalias %ARRAY, i32 %SIZE, i1 zeroext %DECREASING) #0 {
entry:
  %ARRAY.addr = alloca double*, align 4
  %SIZE.addr = alloca i32, align 4
  %DECREASING.addr = alloca i8, align 1
  %idx = alloca i32*, align 4
  %i = alloca i32, align 4
  store double* %ARRAY, double** %ARRAY.addr, align 4
  store i32 %SIZE, i32* %SIZE.addr, align 4
  %frombool = zext i1 %DECREASING to i8
  store i8 %frombool, i8* %DECREASING.addr, align 1
  %0 = load i32, i32* %SIZE.addr, align 4
  %mul = mul i32 %0, 4
  %call = call noalias i8* @malloc(i32 %mul)
  %1 = bitcast i8* %call to i32*
  store i32* %1, i32** %idx, align 4
  %2 = load i32*, i32** %idx, align 4
  %cmp = icmp eq i32* %2, null
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %call1 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([33 x i8], [33 x i8]* @.str.3, i32 0, i32 0), i8* getelementptr inbounds ([23 x i8], [23 x i8]* @.str.1, i32 0, i32 0), i32 77)
  call void @perror(i8* getelementptr inbounds ([1 x i8], [1 x i8]* @.str.2, i32 0, i32 0))
  call void @exit(i32 1) #5
  unreachable

if.end:                                           ; preds = %entry
  %3 = load i32, i32* %SIZE.addr, align 4
  %mul2 = mul i32 8, %3
  %call3 = call noalias i8* @malloc(i32 %mul2)
  %4 = bitcast i8* %call3 to double*
  store double* %4, double** @base_arr, align 4
  %5 = load double*, double** @base_arr, align 4
  %cmp4 = icmp eq double* %5, null
  br i1 %cmp4, label %if.then5, label %if.end7

if.then5:                                         ; preds = %if.end
  %call6 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([33 x i8], [33 x i8]* @.str.3, i32 0, i32 0), i8* getelementptr inbounds ([23 x i8], [23 x i8]* @.str.1, i32 0, i32 0), i32 83)
  call void @perror(i8* getelementptr inbounds ([1 x i8], [1 x i8]* @.str.2, i32 0, i32 0))
  call void @exit(i32 1) #5
  unreachable

if.end7:                                          ; preds = %if.end
  store i32 0, i32* %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.end7
  %6 = load i32, i32* %i, align 4
  %7 = load i32, i32* %SIZE.addr, align 4
  %cmp8 = icmp ult i32 %6, %7
  br i1 %cmp8, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %8 = load double*, double** %ARRAY.addr, align 4
  %9 = load i32, i32* %i, align 4
  %arrayidx = getelementptr inbounds double, double* %8, i32 %9
  %10 = load double, double* %arrayidx, align 8
  %11 = load double*, double** @base_arr, align 4
  %12 = load i32, i32* %i, align 4
  %arrayidx9 = getelementptr inbounds double, double* %11, i32 %12
  store double %10, double* %arrayidx9, align 8
  %13 = load i32, i32* %i, align 4
  %14 = load i32*, i32** %idx, align 4
  %15 = load i32, i32* %i, align 4
  %arrayidx10 = getelementptr inbounds i32, i32* %14, i32 %15
  store i32 %13, i32* %arrayidx10, align 4
  br label %for.inc

for.inc:                                          ; preds = %for.body
  %16 = load i32, i32* %i, align 4
  %inc = add i32 %16, 1
  store i32 %inc, i32* %i, align 4
  br label %for.cond

for.end:                                          ; preds = %for.cond
  %17 = load i8, i8* %DECREASING.addr, align 1
  %tobool = trunc i8 %17 to i1
  %conv = zext i1 %tobool to i32
  %cmp11 = icmp eq i32 %conv, 0
  br i1 %cmp11, label %if.then13, label %if.else

if.then13:                                        ; preds = %for.end
  %18 = load i32*, i32** %idx, align 4
  %19 = bitcast i32* %18 to i8*
  %20 = load i32, i32* %SIZE.addr, align 4
  call void @qsort(i8* %19, i32 %20, i32 4, i32 (i8*, i8*)* @compar_decrease)
  br label %if.end20

if.else:                                          ; preds = %for.end
  %21 = load i8, i8* %DECREASING.addr, align 1
  %tobool14 = trunc i8 %21 to i1
  %conv15 = zext i1 %tobool14 to i32
  %cmp16 = icmp eq i32 %conv15, 1
  br i1 %cmp16, label %if.then18, label %if.end19

if.then18:                                        ; preds = %if.else
  %22 = load i32*, i32** %idx, align 4
  %23 = bitcast i32* %22 to i8*
  %24 = load i32, i32* %SIZE.addr, align 4
  call void @qsort(i8* %23, i32 %24, i32 4, i32 (i8*, i8*)* @compar_increase)
  br label %if.end19

if.end19:                                         ; preds = %if.then18, %if.else
  br label %if.end20

if.end20:                                         ; preds = %if.end19, %if.then13
  %25 = load double*, double** @base_arr, align 4
  %26 = bitcast double* %25 to i8*
  call void @free(i8* %26)
  store double* null, double** @base_arr, align 4
  %27 = load i32*, i32** %idx, align 4
  ret i32* %27
}

declare void @qsort(i8* %0, i32 %1, i32 %2, i32 (i8*, i8*)* %3) #1

; Function Attrs: noinline nounwind optnone
define internal i32 @compar_decrease(i8* noalias %a, i8* noalias %b) #0 {
entry:
  %retval = alloca i32, align 4
  %a.addr = alloca i8*, align 4
  %b.addr = alloca i8*, align 4
  %aa = alloca i32, align 4
  %bb = alloca i32, align 4
  store i8* %a, i8** %a.addr, align 4
  store i8* %b, i8** %b.addr, align 4
  %0 = load i8*, i8** %a.addr, align 4
  %1 = bitcast i8* %0 to i32*
  %2 = load i32, i32* %1, align 4
  store i32 %2, i32* %aa, align 4
  %3 = load i8*, i8** %b.addr, align 4
  %4 = bitcast i8* %3 to i32*
  %5 = load i32, i32* %4, align 4
  store i32 %5, i32* %bb, align 4
  %6 = load double*, double** @base_arr, align 4
  %7 = load i32, i32* %aa, align 4
  %arrayidx = getelementptr inbounds double, double* %6, i32 %7
  %8 = load double, double* %arrayidx, align 8
  %9 = load double*, double** @base_arr, align 4
  %10 = load i32, i32* %bb, align 4
  %arrayidx1 = getelementptr inbounds double, double* %9, i32 %10
  %11 = load double, double* %arrayidx1, align 8
  %cmp = fcmp olt double %8, %11
  br i1 %cmp, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  store i32 -1, i32* %retval, align 4
  br label %return

if.else:                                          ; preds = %entry
  %12 = load double*, double** @base_arr, align 4
  %13 = load i32, i32* %aa, align 4
  %arrayidx2 = getelementptr inbounds double, double* %12, i32 %13
  %14 = load double, double* %arrayidx2, align 8
  %15 = load double*, double** @base_arr, align 4
  %16 = load i32, i32* %bb, align 4
  %arrayidx3 = getelementptr inbounds double, double* %15, i32 %16
  %17 = load double, double* %arrayidx3, align 8
  %cmp4 = fcmp oeq double %14, %17
  br i1 %cmp4, label %if.then5, label %if.else6

if.then5:                                         ; preds = %if.else
  store i32 0, i32* %retval, align 4
  br label %return

if.else6:                                         ; preds = %if.else
  store i32 1, i32* %retval, align 4
  br label %return

return:                                           ; preds = %if.else6, %if.then5, %if.then
  %18 = load i32, i32* %retval, align 4
  ret i32 %18
}

; Function Attrs: noinline nounwind optnone
define internal i32 @compar_increase(i8* noalias %a, i8* noalias %b) #0 {
entry:
  %retval = alloca i32, align 4
  %a.addr = alloca i8*, align 4
  %b.addr = alloca i8*, align 4
  %aa = alloca i32, align 4
  %bb = alloca i32, align 4
  store i8* %a, i8** %a.addr, align 4
  store i8* %b, i8** %b.addr, align 4
  %0 = load i8*, i8** %a.addr, align 4
  %1 = bitcast i8* %0 to i32*
  %2 = load i32, i32* %1, align 4
  store i32 %2, i32* %aa, align 4
  %3 = load i8*, i8** %b.addr, align 4
  %4 = bitcast i8* %3 to i32*
  %5 = load i32, i32* %4, align 4
  store i32 %5, i32* %bb, align 4
  %6 = load double*, double** @base_arr, align 4
  %7 = load i32, i32* %aa, align 4
  %arrayidx = getelementptr inbounds double, double* %6, i32 %7
  %8 = load double, double* %arrayidx, align 8
  %9 = load double*, double** @base_arr, align 4
  %10 = load i32, i32* %bb, align 4
  %arrayidx1 = getelementptr inbounds double, double* %9, i32 %10
  %11 = load double, double* %arrayidx1, align 8
  %cmp = fcmp olt double %8, %11
  br i1 %cmp, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  store i32 1, i32* %retval, align 4
  br label %return

if.else:                                          ; preds = %entry
  %12 = load double*, double** @base_arr, align 4
  %13 = load i32, i32* %aa, align 4
  %arrayidx2 = getelementptr inbounds double, double* %12, i32 %13
  %14 = load double, double* %arrayidx2, align 8
  %15 = load double*, double** @base_arr, align 4
  %16 = load i32, i32* %bb, align 4
  %arrayidx3 = getelementptr inbounds double, double* %15, i32 %16
  %17 = load double, double* %arrayidx3, align 8
  %cmp4 = fcmp oeq double %14, %17
  br i1 %cmp4, label %if.then5, label %if.else6

if.then5:                                         ; preds = %if.else
  store i32 0, i32* %retval, align 4
  br label %return

if.else6:                                         ; preds = %if.else
  store i32 -1, i32* %retval, align 4
  br label %return

return:                                           ; preds = %if.else6, %if.then5, %if.then
  %18 = load i32, i32* %retval, align 4
  ret i32 %18
}

declare void @free(i8* %0) #1

; Function Attrs: noinline nounwind optnone
define hidden double* @cummin(double* noalias %ARRAY, i32 %NO_OF_ARRAY_ELEMENTS) #0 {
entry:
  %ARRAY.addr = alloca double*, align 4
  %NO_OF_ARRAY_ELEMENTS.addr = alloca i32, align 4
  %output = alloca double*, align 4
  %cumulative_min = alloca double, align 8
  %i = alloca i32, align 4
  store double* %ARRAY, double** %ARRAY.addr, align 4
  store i32 %NO_OF_ARRAY_ELEMENTS, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
  %0 = load i32, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
  %cmp = icmp ult i32 %0, 1
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %call = call i32 @puts(i8* getelementptr inbounds ([48 x i8], [48 x i8]* @.str.4, i32 0, i32 0))
  %call1 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([22 x i8], [22 x i8]* @.str.5, i32 0, i32 0), i8* getelementptr inbounds ([23 x i8], [23 x i8]* @.str.1, i32 0, i32 0), i32 105)
  call void @exit(i32 1) #5
  unreachable

if.end:                                           ; preds = %entry
  %1 = load i32, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
  %mul = mul i32 8, %1
  %call2 = call noalias i8* @malloc(i32 %mul)
  %2 = bitcast i8* %call2 to double*
  store double* %2, double** %output, align 4
  %3 = load double*, double** %output, align 4
  %cmp3 = icmp eq double* %3, null
  br i1 %cmp3, label %if.then4, label %if.end6

if.then4:                                         ; preds = %if.end
  %call5 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([33 x i8], [33 x i8]* @.str.3, i32 0, i32 0), i8* getelementptr inbounds ([23 x i8], [23 x i8]* @.str.1, i32 0, i32 0), i32 110)
  call void @perror(i8* getelementptr inbounds ([1 x i8], [1 x i8]* @.str.2, i32 0, i32 0))
  call void @exit(i32 1) #5
  unreachable

if.end6:                                          ; preds = %if.end
  %4 = load double*, double** %ARRAY.addr, align 4
  %arrayidx = getelementptr inbounds double, double* %4, i32 0
  %5 = load double, double* %arrayidx, align 8
  store double %5, double* %cumulative_min, align 8
  store i32 0, i32* %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.end6
  %6 = load i32, i32* %i, align 4
  %7 = load i32, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
  %cmp7 = icmp ult i32 %6, %7
  br i1 %cmp7, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %8 = load double*, double** %ARRAY.addr, align 4
  %9 = load i32, i32* %i, align 4
  %arrayidx8 = getelementptr inbounds double, double* %8, i32 %9
  %10 = load double, double* %arrayidx8, align 8
  %11 = load double, double* %cumulative_min, align 8
  %cmp9 = fcmp olt double %10, %11
  br i1 %cmp9, label %if.then10, label %if.end12

if.then10:                                        ; preds = %for.body
  %12 = load double*, double** %ARRAY.addr, align 4
  %13 = load i32, i32* %i, align 4
  %arrayidx11 = getelementptr inbounds double, double* %12, i32 %13
  %14 = load double, double* %arrayidx11, align 8
  store double %14, double* %cumulative_min, align 8
  br label %if.end12

if.end12:                                         ; preds = %if.then10, %for.body
  %15 = load double, double* %cumulative_min, align 8
  %16 = load double*, double** %output, align 4
  %17 = load i32, i32* %i, align 4
  %arrayidx13 = getelementptr inbounds double, double* %16, i32 %17
  store double %15, double* %arrayidx13, align 8
  br label %for.inc

for.inc:                                          ; preds = %if.end12
  %18 = load i32, i32* %i, align 4
  %inc = add i32 %18, 1
  store i32 %inc, i32* %i, align 4
  br label %for.cond

for.end:                                          ; preds = %for.cond
  %19 = load double*, double** %output, align 4
  ret double* %19
}

declare i32 @puts(i8* %0) #1

; Function Attrs: noinline nounwind optnone
define hidden double* @cummax(double* noalias %ARRAY, i32 %NO_OF_ARRAY_ELEMENTS) #0 {
entry:
  %ARRAY.addr = alloca double*, align 4
  %NO_OF_ARRAY_ELEMENTS.addr = alloca i32, align 4
  %output = alloca double*, align 4
  %cumulative_max = alloca double, align 8
  %i = alloca i32, align 4
  store double* %ARRAY, double** %ARRAY.addr, align 4
  store i32 %NO_OF_ARRAY_ELEMENTS, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
  %0 = load i32, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
  %cmp = icmp ult i32 %0, 1
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %call = call i32 @puts(i8* getelementptr inbounds ([41 x i8], [41 x i8]* @.str.6, i32 0, i32 0))
  %call1 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([22 x i8], [22 x i8]* @.str.5, i32 0, i32 0), i8* getelementptr inbounds ([23 x i8], [23 x i8]* @.str.1, i32 0, i32 0), i32 129)
  call void @exit(i32 1) #5
  unreachable

if.end:                                           ; preds = %entry
  %1 = load i32, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
  %mul = mul i32 8, %1
  %call2 = call noalias i8* @malloc(i32 %mul)
  %2 = bitcast i8* %call2 to double*
  store double* %2, double** %output, align 4
  %3 = load double*, double** %output, align 4
  %cmp3 = icmp eq double* %3, null
  br i1 %cmp3, label %if.then4, label %if.end6

if.then4:                                         ; preds = %if.end
  %call5 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([33 x i8], [33 x i8]* @.str.3, i32 0, i32 0), i8* getelementptr inbounds ([23 x i8], [23 x i8]* @.str.1, i32 0, i32 0), i32 134)
  call void @perror(i8* getelementptr inbounds ([1 x i8], [1 x i8]* @.str.2, i32 0, i32 0))
  call void @exit(i32 1) #5
  unreachable

if.end6:                                          ; preds = %if.end
  %4 = load double*, double** %ARRAY.addr, align 4
  %arrayidx = getelementptr inbounds double, double* %4, i32 0
  %5 = load double, double* %arrayidx, align 8
  store double %5, double* %cumulative_max, align 8
  store i32 0, i32* %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.end6
  %6 = load i32, i32* %i, align 4
  %7 = load i32, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
  %cmp7 = icmp ult i32 %6, %7
  br i1 %cmp7, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %8 = load double*, double** %ARRAY.addr, align 4
  %9 = load i32, i32* %i, align 4
  %arrayidx8 = getelementptr inbounds double, double* %8, i32 %9
  %10 = load double, double* %arrayidx8, align 8
  %11 = load double, double* %cumulative_max, align 8
  %cmp9 = fcmp ogt double %10, %11
  br i1 %cmp9, label %if.then10, label %if.end12

if.then10:                                        ; preds = %for.body
  %12 = load double*, double** %ARRAY.addr, align 4
  %13 = load i32, i32* %i, align 4
  %arrayidx11 = getelementptr inbounds double, double* %12, i32 %13
  %14 = load double, double* %arrayidx11, align 8
  store double %14, double* %cumulative_max, align 8
  br label %if.end12

if.end12:                                         ; preds = %if.then10, %for.body
  %15 = load double, double* %cumulative_max, align 8
  %16 = load double*, double** %output, align 4
  %17 = load i32, i32* %i, align 4
  %arrayidx13 = getelementptr inbounds double, double* %16, i32 %17
  store double %15, double* %arrayidx13, align 8
  br label %for.inc

for.inc:                                          ; preds = %if.end12
  %18 = load i32, i32* %i, align 4
  %inc = add i32 %18, 1
  store i32 %inc, i32* %i, align 4
  br label %for.cond

for.end:                                          ; preds = %for.cond
  %19 = load double*, double** %output, align 4
  ret double* %19
}

; Function Attrs: noinline nounwind optnone
define hidden double* @pminx(double* noalias %ARRAY, i32 %NO_OF_ARRAY_ELEMENTS, double %X) #0 {
entry:
  %ARRAY.addr = alloca double*, align 4
  %NO_OF_ARRAY_ELEMENTS.addr = alloca i32, align 4
  %X.addr = alloca double, align 8
  %pmin_array = alloca double*, align 4
  %index = alloca i32, align 4
  store double* %ARRAY, double** %ARRAY.addr, align 4
  store i32 %NO_OF_ARRAY_ELEMENTS, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
  store double %X, double* %X.addr, align 8
  %0 = load i32, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
  %cmp = icmp ult i32 %0, 1
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %call = call i32 @puts(i8* getelementptr inbounds ([37 x i8], [37 x i8]* @.str.7, i32 0, i32 0))
  %call1 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([22 x i8], [22 x i8]* @.str.5, i32 0, i32 0), i8* getelementptr inbounds ([23 x i8], [23 x i8]* @.str.1, i32 0, i32 0), i32 152)
  call void @exit(i32 1) #5
  unreachable

if.end:                                           ; preds = %entry
  %1 = load i32, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
  %mul = mul i32 8, %1
  %call2 = call noalias i8* @malloc(i32 %mul)
  %2 = bitcast i8* %call2 to double*
  store double* %2, double** %pmin_array, align 4
  %3 = load double*, double** %pmin_array, align 4
  %cmp3 = icmp eq double* %3, null
  br i1 %cmp3, label %if.then4, label %if.end6

if.then4:                                         ; preds = %if.end
  %call5 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([33 x i8], [33 x i8]* @.str.3, i32 0, i32 0), i8* getelementptr inbounds ([23 x i8], [23 x i8]* @.str.1, i32 0, i32 0), i32 157)
  call void @perror(i8* getelementptr inbounds ([1 x i8], [1 x i8]* @.str.2, i32 0, i32 0))
  call void @exit(i32 1) #5
  unreachable

if.end6:                                          ; preds = %if.end
  store i32 0, i32* %index, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.end6
  %4 = load i32, i32* %index, align 4
  %5 = load i32, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
  %cmp7 = icmp ult i32 %4, %5
  br i1 %cmp7, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %6 = load double*, double** %ARRAY.addr, align 4
  %7 = load i32, i32* %index, align 4
  %arrayidx = getelementptr inbounds double, double* %6, i32 %7
  %8 = load double, double* %arrayidx, align 8
  %9 = load double, double* %X.addr, align 8
  %cmp8 = fcmp olt double %8, %9
  br i1 %cmp8, label %if.then9, label %if.else

if.then9:                                         ; preds = %for.body
  %10 = load double*, double** %ARRAY.addr, align 4
  %11 = load i32, i32* %index, align 4
  %arrayidx10 = getelementptr inbounds double, double* %10, i32 %11
  %12 = load double, double* %arrayidx10, align 8
  %13 = load double*, double** %pmin_array, align 4
  %14 = load i32, i32* %index, align 4
  %arrayidx11 = getelementptr inbounds double, double* %13, i32 %14
  store double %12, double* %arrayidx11, align 8
  br label %if.end13

if.else:                                          ; preds = %for.body
  %15 = load double, double* %X.addr, align 8
  %16 = load double*, double** %pmin_array, align 4
  %17 = load i32, i32* %index, align 4
  %arrayidx12 = getelementptr inbounds double, double* %16, i32 %17
  store double %15, double* %arrayidx12, align 8
  br label %if.end13

if.end13:                                         ; preds = %if.else, %if.then9
  br label %for.inc

for.inc:                                          ; preds = %if.end13
  %18 = load i32, i32* %index, align 4
  %inc = add i32 %18, 1
  store i32 %inc, i32* %index, align 4
  br label %for.cond

for.end:                                          ; preds = %for.cond
  %19 = load double*, double** %pmin_array, align 4
  ret double* %19
}

; Function Attrs: noinline nounwind optnone
define hidden void @double_say(double* noalias %ARRAY, i32 %NO_OF_ARRAY_ELEMENTS) #0 {
entry:
  %ARRAY.addr = alloca double*, align 4
  %NO_OF_ARRAY_ELEMENTS.addr = alloca i32, align 4
  %i = alloca i32, align 4
  store double* %ARRAY, double** %ARRAY.addr, align 4
  store i32 %NO_OF_ARRAY_ELEMENTS, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
  %0 = load double*, double** %ARRAY.addr, align 4
  %arrayidx = getelementptr inbounds double, double* %0, i32 0
  %1 = load double, double* %arrayidx, align 8
  %call = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([7 x i8], [7 x i8]* @.str.8, i32 0, i32 0), double %1)
  store i32 1, i32* %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %2 = load i32, i32* %i, align 4
  %3 = load i32, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
  %cmp = icmp ult i32 %2, %3
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %4 = load double*, double** %ARRAY.addr, align 4
  %5 = load i32, i32* %i, align 4
  %arrayidx1 = getelementptr inbounds double, double* %4, i32 %5
  %6 = load double, double* %arrayidx1, align 8
  %call2 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([7 x i8], [7 x i8]* @.str.9, i32 0, i32 0), double %6)
  %7 = load i32, i32* %i, align 4
  %add = add i32 %7, 1
  %rem = urem i32 %add, 5
  %cmp3 = icmp eq i32 %rem, 0
  br i1 %cmp3, label %if.then, label %if.end

if.then:                                          ; preds = %for.body
  %8 = load i32, i32* %i, align 4
  %add4 = add i32 %8, 1
  %call5 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([6 x i8], [6 x i8]* @.str.10, i32 0, i32 0), i32 %add4)
  br label %if.end

if.end:                                           ; preds = %if.then, %for.body
  br label %for.inc

for.inc:                                          ; preds = %if.end
  %9 = load i32, i32* %i, align 4
  %inc = add i32 %9, 1
  store i32 %inc, i32* %i, align 4
  br label %for.cond

for.end:                                          ; preds = %for.cond
  %call6 = call i32 @puts(i8* getelementptr inbounds ([2 x i8], [2 x i8]* @.str.11, i32 0, i32 0))
  ret void
}

; Function Attrs: noinline nounwind optnone
define hidden double* @uint2double(i32* noalias %ARRAY, i32 %NO_OF_ARRAY_ELEMENTS) #0 {
entry:
  %ARRAY.addr = alloca i32*, align 4
  %NO_OF_ARRAY_ELEMENTS.addr = alloca i32, align 4
  %doubleArray = alloca double*, align 4
  %index = alloca i32, align 4
  store i32* %ARRAY, i32** %ARRAY.addr, align 4
  store i32 %NO_OF_ARRAY_ELEMENTS, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
  %0 = load i32, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
  %mul = mul i32 8, %0
  %call = call noalias i8* @malloc(i32 %mul)
  %1 = bitcast i8* %call to double*
  store double* %1, double** %doubleArray, align 4
  %2 = load double*, double** %doubleArray, align 4
  %cmp = icmp eq double* %2, null
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %call1 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([34 x i8], [34 x i8]* @.str.12, i32 0, i32 0), i8* getelementptr inbounds ([23 x i8], [23 x i8]* @.str.1, i32 0, i32 0), i32 194)
  call void @perror(i8* getelementptr inbounds ([1 x i8], [1 x i8]* @.str.2, i32 0, i32 0))
  call void @exit(i32 1) #5
  unreachable

if.end:                                           ; preds = %entry
  store i32 0, i32* %index, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.end
  %3 = load i32, i32* %index, align 4
  %4 = load i32, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
  %cmp2 = icmp ult i32 %3, %4
  br i1 %cmp2, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %5 = load i32*, i32** %ARRAY.addr, align 4
  %6 = load i32, i32* %index, align 4
  %arrayidx = getelementptr inbounds i32, i32* %5, i32 %6
  %7 = load i32, i32* %arrayidx, align 4
  %conv = uitofp i32 %7 to double
  %8 = load double*, double** %doubleArray, align 4
  %9 = load i32, i32* %index, align 4
  %arrayidx3 = getelementptr inbounds double, double* %8, i32 %9
  store double %conv, double* %arrayidx3, align 8
  br label %for.inc

for.inc:                                          ; preds = %for.body
  %10 = load i32, i32* %index, align 4
  %inc = add i32 %10, 1
  store i32 %inc, i32* %index, align 4
  br label %for.cond

for.end:                                          ; preds = %for.cond
  %11 = load double*, double** %doubleArray, align 4
  ret double* %11
}

; Function Attrs: noinline nounwind optnone
define hidden double @min2(double %N1, double %N2) #0 {
entry:
  %retval = alloca double, align 8
  %N1.addr = alloca double, align 8
  %N2.addr = alloca double, align 8
  store double %N1, double* %N1.addr, align 8
  store double %N2, double* %N2.addr, align 8
  %0 = load double, double* %N1.addr, align 8
  %1 = load double, double* %N2.addr, align 8
  %cmp = fcmp olt double %0, %1
  br i1 %cmp, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  %2 = load double, double* %N1.addr, align 8
  store double %2, double* %retval, align 8
  br label %return

if.else:                                          ; preds = %entry
  %3 = load double, double* %N2.addr, align 8
  store double %3, double* %retval, align 8
  br label %return

return:                                           ; preds = %if.else, %if.then
  %4 = load double, double* %retval, align 8
  ret double %4
}

; Function Attrs: noinline nounwind optnone
define hidden double* @p_adjust(double* noalias %PVALUES, i32 %NO_OF_ARRAY_ELEMENTS, i8* noalias %STRING) #0 {
entry:
  %retval = alloca double*, align 4
  %PVALUES.addr = alloca double*, align 4
  %NO_OF_ARRAY_ELEMENTS.addr = alloca i32, align 4
  %STRING.addr = alloca i8*, align 4
  %TYPE = alloca i16, align 2
  %bonferroni = alloca double*, align 4
  %index = alloca i32, align 4
  %BONFERRONI = alloca double, align 8
  %o = alloca i32*, align 4
  %o2double = alloca double*, align 4
  %cummax_input = alloca double*, align 4
  %index80 = alloca i32, align 4
  %ro = alloca i32*, align 4
  %cummax_output = alloca double*, align 4
  %pmin = alloca double*, align 4
  %qvalues = alloca double*, align 4
  %index98 = alloca i32, align 4
  %o114 = alloca i32*, align 4
  %p = alloca double*, align 4
  %index123 = alloca i32, align 4
  %o2double134 = alloca double*, align 4
  %ro136 = alloca i32*, align 4
  %q = alloca double*, align 4
  %pa = alloca double*, align 4
  %min = alloca double, align 8
  %index155 = alloca i32, align 4
  %TEMP = alloca double, align 8
  %index171 = alloca i32, align 4
  %j = alloca i32, align 4
  %ij = alloca i32*, align 4
  %I2_LENGTH = alloca i32, align 4
  %i2 = alloca i32*, align 4
  %i = alloca i32, align 4
  %q1 = alloca double, align 8
  %i208 = alloca i32, align 4
  %TEMP_Q1 = alloca double, align 8
  %i227 = alloca i32, align 4
  %i244 = alloca i32, align 4
  %i256 = alloca i32, align 4
  %index274 = alloca i32, align 4
  %o288 = alloca i32*, align 4
  %o_double = alloca double*, align 4
  %index296 = alloca i32, align 4
  %ro315 = alloca i32*, align 4
  %cummin_input = alloca double*, align 4
  %index328 = alloca i32, align 4
  %NI = alloca double, align 8
  %q349 = alloca double, align 8
  %index350 = alloca i32, align 4
  %index362 = alloca i32, align 4
  %NI367 = alloca double, align 8
  %index385 = alloca i32, align 4
  %cummin_array = alloca double*, align 4
  %pmin403 = alloca double*, align 4
  %q_array = alloca double*, align 4
  %index407 = alloca i32, align 4
  store double* %PVALUES, double** %PVALUES.addr, align 4
  store i32 %NO_OF_ARRAY_ELEMENTS, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
  store i8* %STRING, i8** %STRING.addr, align 4
  %0 = load i32, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
  %cmp = icmp ult i32 %0, 1
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %call = call i32 @puts(i8* getelementptr inbounds ([41 x i8], [41 x i8]* @.str.13, i32 0, i32 0))
  %call1 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([22 x i8], [22 x i8]* @.str.5, i32 0, i32 0), i8* getelementptr inbounds ([23 x i8], [23 x i8]* @.str.1, i32 0, i32 0), i32 217)
  call void @exit(i32 1) #5
  unreachable

if.end:                                           ; preds = %entry
  store i16 -1, i16* %TYPE, align 2
  %1 = load i8*, i8** %STRING.addr, align 4
  %cmp2 = icmp eq i8* %1, null
  br i1 %cmp2, label %if.then3, label %if.else

if.then3:                                         ; preds = %if.end
  store i16 0, i16* %TYPE, align 2
  br label %if.end41

if.else:                                          ; preds = %if.end
  %2 = load i8*, i8** %STRING.addr, align 4
  %call4 = call i32 @strcasecmp(i8* %2, i8* getelementptr inbounds ([3 x i8], [3 x i8]* @.str.14, i32 0, i32 0))
  %cmp5 = icmp eq i32 %call4, 0
  br i1 %cmp5, label %if.then6, label %if.else7

if.then6:                                         ; preds = %if.else
  store i16 0, i16* %TYPE, align 2
  br label %if.end40

if.else7:                                         ; preds = %if.else
  %3 = load i8*, i8** %STRING.addr, align 4
  %call8 = call i32 @strcasecmp(i8* %3, i8* getelementptr inbounds ([4 x i8], [4 x i8]* @.str.15, i32 0, i32 0))
  %cmp9 = icmp eq i32 %call8, 0
  br i1 %cmp9, label %if.then10, label %if.else11

if.then10:                                        ; preds = %if.else7
  store i16 0, i16* %TYPE, align 2
  br label %if.end39

if.else11:                                        ; preds = %if.else7
  %4 = load i8*, i8** %STRING.addr, align 4
  %call12 = call i32 @strcasecmp(i8* %4, i8* getelementptr inbounds ([3 x i8], [3 x i8]* @.str.16, i32 0, i32 0))
  %cmp13 = icmp eq i32 %call12, 0
  br i1 %cmp13, label %if.then14, label %if.else15

if.then14:                                        ; preds = %if.else11
  store i16 1, i16* %TYPE, align 2
  br label %if.end38

if.else15:                                        ; preds = %if.else11
  %5 = load i8*, i8** %STRING.addr, align 4
  %call16 = call i32 @strcasecmp(i8* %5, i8* getelementptr inbounds ([11 x i8], [11 x i8]* @.str.17, i32 0, i32 0))
  %cmp17 = icmp eq i32 %call16, 0
  br i1 %cmp17, label %if.then18, label %if.else19

if.then18:                                        ; preds = %if.else15
  store i16 2, i16* %TYPE, align 2
  br label %if.end37

if.else19:                                        ; preds = %if.else15
  %6 = load i8*, i8** %STRING.addr, align 4
  %call20 = call i32 @strcasecmp(i8* %6, i8* getelementptr inbounds ([9 x i8], [9 x i8]* @.str.18, i32 0, i32 0))
  %cmp21 = icmp eq i32 %call20, 0
  br i1 %cmp21, label %if.then22, label %if.else23

if.then22:                                        ; preds = %if.else19
  store i16 3, i16* %TYPE, align 2
  br label %if.end36

if.else23:                                        ; preds = %if.else19
  %7 = load i8*, i8** %STRING.addr, align 4
  %call24 = call i32 @strcasecmp(i8* %7, i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.19, i32 0, i32 0))
  %cmp25 = icmp eq i32 %call24, 0
  br i1 %cmp25, label %if.then26, label %if.else27

if.then26:                                        ; preds = %if.else23
  store i16 4, i16* %TYPE, align 2
  br label %if.end35

if.else27:                                        ; preds = %if.else23
  %8 = load i8*, i8** %STRING.addr, align 4
  %call28 = call i32 @strcasecmp(i8* %8, i8* getelementptr inbounds ([7 x i8], [7 x i8]* @.str.20, i32 0, i32 0))
  %cmp29 = icmp eq i32 %call28, 0
  br i1 %cmp29, label %if.then30, label %if.else31

if.then30:                                        ; preds = %if.else27
  store i16 5, i16* %TYPE, align 2
  br label %if.end34

if.else31:                                        ; preds = %if.else27
  %9 = load i8*, i8** %STRING.addr, align 4
  %call32 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([44 x i8], [44 x i8]* @.str.21, i32 0, i32 0), i8* %9)
  %call33 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([22 x i8], [22 x i8]* @.str.5, i32 0, i32 0), i8* getelementptr inbounds ([23 x i8], [23 x i8]* @.str.1, i32 0, i32 0), i32 239)
  call void @exit(i32 1) #5
  unreachable

if.end34:                                         ; preds = %if.then30
  br label %if.end35

if.end35:                                         ; preds = %if.end34, %if.then26
  br label %if.end36

if.end36:                                         ; preds = %if.end35, %if.then22
  br label %if.end37

if.end37:                                         ; preds = %if.end36, %if.then18
  br label %if.end38

if.end38:                                         ; preds = %if.end37, %if.then14
  br label %if.end39

if.end39:                                         ; preds = %if.end38, %if.then10
  br label %if.end40

if.end40:                                         ; preds = %if.end39, %if.then6
  br label %if.end41

if.end41:                                         ; preds = %if.end40, %if.then3
  %10 = load i16, i16* %TYPE, align 2
  %conv = sext i16 %10 to i32
  %cmp42 = icmp eq i32 %conv, 2
  br i1 %cmp42, label %if.then44, label %if.else71

if.then44:                                        ; preds = %if.end41
  %11 = load i32, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
  %mul = mul i32 8, %11
  %call45 = call noalias i8* @malloc(i32 %mul)
  %12 = bitcast i8* %call45 to double*
  store double* %12, double** %bonferroni, align 4
  %13 = load double*, double** %bonferroni, align 4
  %cmp46 = icmp eq double* %13, null
  br i1 %cmp46, label %if.then48, label %if.end50

if.then48:                                        ; preds = %if.then44
  %call49 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([33 x i8], [33 x i8]* @.str.3, i32 0, i32 0), i8* getelementptr inbounds ([23 x i8], [23 x i8]* @.str.1, i32 0, i32 0), i32 247)
  call void @perror(i8* getelementptr inbounds ([1 x i8], [1 x i8]* @.str.2, i32 0, i32 0))
  call void @exit(i32 1) #5
  unreachable

if.end50:                                         ; preds = %if.then44
  store i32 0, i32* %index, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.end50
  %14 = load i32, i32* %index, align 4
  %15 = load i32, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
  %cmp51 = icmp ult i32 %14, %15
  br i1 %cmp51, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %16 = load double*, double** %PVALUES.addr, align 4
  %17 = load i32, i32* %index, align 4
  %arrayidx = getelementptr inbounds double, double* %16, i32 %17
  %18 = load double, double* %arrayidx, align 8
  %19 = load i32, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
  %conv53 = uitofp i32 %19 to double
  %mul54 = fmul double %18, %conv53
  store double %mul54, double* %BONFERRONI, align 8
  %20 = load double, double* %BONFERRONI, align 8
  %cmp55 = fcmp oge double %20, 1.000000e+00
  br i1 %cmp55, label %if.then57, label %if.else59

if.then57:                                        ; preds = %for.body
  %21 = load double*, double** %bonferroni, align 4
  %22 = load i32, i32* %index, align 4
  %arrayidx58 = getelementptr inbounds double, double* %21, i32 %22
  store double 1.000000e+00, double* %arrayidx58, align 8
  br label %if.end70

if.else59:                                        ; preds = %for.body
  %23 = load double, double* %BONFERRONI, align 8
  %cmp60 = fcmp ole double 0.000000e+00, %23
  br i1 %cmp60, label %land.lhs.true, label %if.else66

land.lhs.true:                                    ; preds = %if.else59
  %24 = load double, double* %BONFERRONI, align 8
  %cmp62 = fcmp olt double %24, 1.000000e+00
  br i1 %cmp62, label %if.then64, label %if.else66

if.then64:                                        ; preds = %land.lhs.true
  %25 = load double, double* %BONFERRONI, align 8
  %26 = load double*, double** %bonferroni, align 4
  %27 = load i32, i32* %index, align 4
  %arrayidx65 = getelementptr inbounds double, double* %26, i32 %27
  store double %25, double* %arrayidx65, align 8
  br label %if.end69

if.else66:                                        ; preds = %land.lhs.true, %if.else59
  %28 = load double, double* %BONFERRONI, align 8
  %call67 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([42 x i8], [42 x i8]* @.str.22, i32 0, i32 0), double %28)
  %call68 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([23 x i8], [23 x i8]* @.str.23, i32 0, i32 0), i8* getelementptr inbounds ([23 x i8], [23 x i8]* @.str.1, i32 0, i32 0), i32 259)
  call void @exit(i32 1) #5
  unreachable

if.end69:                                         ; preds = %if.then64
  br label %if.end70

if.end70:                                         ; preds = %if.end69, %if.then57
  br label %for.inc

for.inc:                                          ; preds = %if.end70
  %29 = load i32, i32* %index, align 4
  %inc = add i32 %29, 1
  store i32 %inc, i32* %index, align 4
  br label %for.cond

for.end:                                          ; preds = %for.cond
  %30 = load double*, double** %bonferroni, align 4
  store double* %30, double** %retval, align 4
  br label %return

if.else71:                                        ; preds = %if.end41
  %31 = load i16, i16* %TYPE, align 2
  %conv72 = sext i16 %31 to i32
  %cmp73 = icmp eq i32 %conv72, 4
  br i1 %cmp73, label %if.then75, label %if.else109

if.then75:                                        ; preds = %if.else71
  %32 = load double*, double** %PVALUES.addr, align 4
  %33 = load i32, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
  %call76 = call i32* @order(double* %32, i32 %33, i1 zeroext false)
  store i32* %call76, i32** %o, align 4
  %34 = load i32*, i32** %o, align 4
  %35 = load i32, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
  %call77 = call double* @uint2double(i32* %34, i32 %35)
  store double* %call77, double** %o2double, align 4
  %36 = load i32, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
  %mul78 = mul i32 8, %36
  %call79 = call noalias i8* @malloc(i32 %mul78)
  %37 = bitcast i8* %call79 to double*
  store double* %37, double** %cummax_input, align 4
  store i32 0, i32* %index80, align 4
  br label %for.cond81

for.cond81:                                       ; preds = %for.inc90, %if.then75
  %38 = load i32, i32* %index80, align 4
  %39 = load i32, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
  %cmp82 = icmp ult i32 %38, %39
  br i1 %cmp82, label %for.body84, label %for.end92

for.body84:                                       ; preds = %for.cond81
  %40 = load i32, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
  %41 = load i32, i32* %index80, align 4
  %sub = sub i32 %40, %41
  %conv85 = uitofp i32 %sub to double
  %42 = load double*, double** %PVALUES.addr, align 4
  %43 = load i32*, i32** %o, align 4
  %44 = load i32, i32* %index80, align 4
  %arrayidx86 = getelementptr inbounds i32, i32* %43, i32 %44
  %45 = load i32, i32* %arrayidx86, align 4
  %arrayidx87 = getelementptr inbounds double, double* %42, i32 %45
  %46 = load double, double* %arrayidx87, align 8
  %mul88 = fmul double %conv85, %46
  %47 = load double*, double** %cummax_input, align 4
  %48 = load i32, i32* %index80, align 4
  %arrayidx89 = getelementptr inbounds double, double* %47, i32 %48
  store double %mul88, double* %arrayidx89, align 8
  br label %for.inc90

for.inc90:                                        ; preds = %for.body84
  %49 = load i32, i32* %index80, align 4
  %inc91 = add i32 %49, 1
  store i32 %inc91, i32* %index80, align 4
  br label %for.cond81

for.end92:                                        ; preds = %for.cond81
  %50 = load i32*, i32** %o, align 4
  %51 = bitcast i32* %50 to i8*
  call void @free(i8* %51)
  store i32* null, i32** %o, align 4
  %52 = load double*, double** %o2double, align 4
  %53 = load i32, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
  %call93 = call i32* @order(double* %52, i32 %53, i1 zeroext false)
  store i32* %call93, i32** %ro, align 4
  %54 = load double*, double** %o2double, align 4
  %55 = bitcast double* %54 to i8*
  call void @free(i8* %55)
  store double* null, double** %o2double, align 4
  %56 = load double*, double** %cummax_input, align 4
  %57 = load i32, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
  %call94 = call double* @cummax(double* %56, i32 %57)
  store double* %call94, double** %cummax_output, align 4
  %58 = load double*, double** %cummax_input, align 4
  %59 = bitcast double* %58 to i8*
  call void @free(i8* %59)
  store double* null, double** %cummax_input, align 4
  %60 = load double*, double** %cummax_output, align 4
  %61 = load i32, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
  %call95 = call double* @pminx(double* %60, i32 %61, double 1.000000e+00)
  store double* %call95, double** %pmin, align 4
  %62 = load double*, double** %cummax_output, align 4
  %63 = bitcast double* %62 to i8*
  call void @free(i8* %63)
  store double* null, double** %cummax_output, align 4
  %64 = load i32, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
  %mul96 = mul i32 8, %64
  %call97 = call noalias i8* @malloc(i32 %mul96)
  %65 = bitcast i8* %call97 to double*
  store double* %65, double** %qvalues, align 4
  store i32 0, i32* %index98, align 4
  br label %for.cond99

for.cond99:                                       ; preds = %for.inc106, %for.end92
  %66 = load i32, i32* %index98, align 4
  %67 = load i32, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
  %cmp100 = icmp ult i32 %66, %67
  br i1 %cmp100, label %for.body102, label %for.end108

for.body102:                                      ; preds = %for.cond99
  %68 = load double*, double** %pmin, align 4
  %69 = load i32*, i32** %ro, align 4
  %70 = load i32, i32* %index98, align 4
  %arrayidx103 = getelementptr inbounds i32, i32* %69, i32 %70
  %71 = load i32, i32* %arrayidx103, align 4
  %arrayidx104 = getelementptr inbounds double, double* %68, i32 %71
  %72 = load double, double* %arrayidx104, align 8
  %73 = load double*, double** %qvalues, align 4
  %74 = load i32, i32* %index98, align 4
  %arrayidx105 = getelementptr inbounds double, double* %73, i32 %74
  store double %72, double* %arrayidx105, align 8
  br label %for.inc106

for.inc106:                                       ; preds = %for.body102
  %75 = load i32, i32* %index98, align 4
  %inc107 = add i32 %75, 1
  store i32 %inc107, i32* %index98, align 4
  br label %for.cond99

for.end108:                                       ; preds = %for.cond99
  %76 = load double*, double** %pmin, align 4
  %77 = bitcast double* %76 to i8*
  call void @free(i8* %77)
  store double* null, double** %pmin, align 4
  %78 = load i32*, i32** %ro, align 4
  %79 = bitcast i32* %78 to i8*
  call void @free(i8* %79)
  store i32* null, i32** %ro, align 4
  %80 = load double*, double** %qvalues, align 4
  store double* %80, double** %retval, align 4
  br label %return

if.else109:                                       ; preds = %if.else71
  %81 = load i16, i16* %TYPE, align 2
  %conv110 = sext i16 %81 to i32
  %cmp111 = icmp eq i32 %conv110, 5
  br i1 %cmp111, label %if.then113, label %if.end285

if.then113:                                       ; preds = %if.else109
  %82 = load double*, double** %PVALUES.addr, align 4
  %83 = load i32, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
  %call115 = call i32* @order(double* %82, i32 %83, i1 zeroext false)
  store i32* %call115, i32** %o114, align 4
  %84 = load i32, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
  %mul116 = mul i32 8, %84
  %call117 = call noalias i8* @malloc(i32 %mul116)
  %85 = bitcast i8* %call117 to double*
  store double* %85, double** %p, align 4
  %86 = load double*, double** %p, align 4
  %cmp118 = icmp eq double* %86, null
  br i1 %cmp118, label %if.then120, label %if.end122

if.then120:                                       ; preds = %if.then113
  %call121 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([33 x i8], [33 x i8]* @.str.3, i32 0, i32 0), i8* getelementptr inbounds ([23 x i8], [23 x i8]* @.str.1, i32 0, i32 0), i32 302)
  call void @perror(i8* getelementptr inbounds ([1 x i8], [1 x i8]* @.str.2, i32 0, i32 0))
  call void @exit(i32 1) #5
  unreachable

if.end122:                                        ; preds = %if.then113
  store i32 0, i32* %index123, align 4
  br label %for.cond124

for.cond124:                                      ; preds = %for.inc131, %if.end122
  %87 = load i32, i32* %index123, align 4
  %88 = load i32, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
  %cmp125 = icmp ult i32 %87, %88
  br i1 %cmp125, label %for.body127, label %for.end133

for.body127:                                      ; preds = %for.cond124
  %89 = load double*, double** %PVALUES.addr, align 4
  %90 = load i32*, i32** %o114, align 4
  %91 = load i32, i32* %index123, align 4
  %arrayidx128 = getelementptr inbounds i32, i32* %90, i32 %91
  %92 = load i32, i32* %arrayidx128, align 4
  %arrayidx129 = getelementptr inbounds double, double* %89, i32 %92
  %93 = load double, double* %arrayidx129, align 8
  %94 = load double*, double** %p, align 4
  %95 = load i32, i32* %index123, align 4
  %arrayidx130 = getelementptr inbounds double, double* %94, i32 %95
  store double %93, double* %arrayidx130, align 8
  br label %for.inc131

for.inc131:                                       ; preds = %for.body127
  %96 = load i32, i32* %index123, align 4
  %inc132 = add i32 %96, 1
  store i32 %inc132, i32* %index123, align 4
  br label %for.cond124

for.end133:                                       ; preds = %for.cond124
  %97 = load i32*, i32** %o114, align 4
  %98 = load i32, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
  %call135 = call double* @uint2double(i32* %97, i32 %98)
  store double* %call135, double** %o2double134, align 4
  %99 = load i32*, i32** %o114, align 4
  %100 = bitcast i32* %99 to i8*
  call void @free(i8* %100)
  store i32* null, i32** %o114, align 4
  %101 = load double*, double** %o2double134, align 4
  %102 = load i32, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
  %call137 = call i32* @order(double* %101, i32 %102, i1 zeroext false)
  store i32* %call137, i32** %ro136, align 4
  %103 = load double*, double** %o2double134, align 4
  %104 = bitcast double* %103 to i8*
  call void @free(i8* %104)
  store double* null, double** %o2double134, align 4
  %105 = load i32, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
  %mul138 = mul i32 8, %105
  %call139 = call noalias i8* @malloc(i32 %mul138)
  %106 = bitcast i8* %call139 to double*
  store double* %106, double** %q, align 4
  %107 = load double*, double** %q, align 4
  %cmp140 = icmp eq double* %107, null
  br i1 %cmp140, label %if.then142, label %if.end144

if.then142:                                       ; preds = %for.end133
  %call143 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([33 x i8], [33 x i8]* @.str.3, i32 0, i32 0), i8* getelementptr inbounds ([23 x i8], [23 x i8]* @.str.1, i32 0, i32 0), i32 318)
  call void @perror(i8* getelementptr inbounds ([1 x i8], [1 x i8]* @.str.2, i32 0, i32 0))
  call void @exit(i32 1) #5
  unreachable

if.end144:                                        ; preds = %for.end133
  %108 = load i32, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
  %mul145 = mul i32 8, %108
  %call146 = call noalias i8* @malloc(i32 %mul145)
  %109 = bitcast i8* %call146 to double*
  store double* %109, double** %pa, align 4
  %110 = load double*, double** %pa, align 4
  %cmp147 = icmp eq double* %110, null
  br i1 %cmp147, label %if.then149, label %if.end151

if.then149:                                       ; preds = %if.end144
  %call150 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([33 x i8], [33 x i8]* @.str.3, i32 0, i32 0), i8* getelementptr inbounds ([23 x i8], [23 x i8]* @.str.1, i32 0, i32 0), i32 324)
  call void @perror(i8* getelementptr inbounds ([1 x i8], [1 x i8]* @.str.2, i32 0, i32 0))
  call void @exit(i32 1) #5
  unreachable

if.end151:                                        ; preds = %if.end144
  %111 = load i32, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
  %conv152 = uitofp i32 %111 to double
  %112 = load double*, double** %p, align 4
  %arrayidx153 = getelementptr inbounds double, double* %112, i32 0
  %113 = load double, double* %arrayidx153, align 8
  %mul154 = fmul double %conv152, %113
  store double %mul154, double* %min, align 8
  store i32 1, i32* %index155, align 4
  br label %for.cond156

for.cond156:                                      ; preds = %for.inc168, %if.end151
  %114 = load i32, i32* %index155, align 4
  %115 = load i32, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
  %cmp157 = icmp ult i32 %114, %115
  br i1 %cmp157, label %for.body159, label %for.end170

for.body159:                                      ; preds = %for.cond156
  %116 = load i32, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
  %conv160 = uitofp i32 %116 to double
  %117 = load double*, double** %p, align 4
  %118 = load i32, i32* %index155, align 4
  %arrayidx161 = getelementptr inbounds double, double* %117, i32 %118
  %119 = load double, double* %arrayidx161, align 8
  %mul162 = fmul double %conv160, %119
  %120 = load i32, i32* %index155, align 4
  %add = add i32 1, %120
  %conv163 = uitofp i32 %add to double
  %div = fdiv double %mul162, %conv163
  store double %div, double* %TEMP, align 8
  %121 = load double, double* %TEMP, align 8
  %122 = load double, double* %min, align 8
  %cmp164 = fcmp olt double %121, %122
  br i1 %cmp164, label %if.then166, label %if.end167

if.then166:                                       ; preds = %for.body159
  %123 = load double, double* %TEMP, align 8
  store double %123, double* %min, align 8
  br label %if.end167

if.end167:                                        ; preds = %if.then166, %for.body159
  br label %for.inc168

for.inc168:                                       ; preds = %if.end167
  %124 = load i32, i32* %index155, align 4
  %inc169 = add i32 %124, 1
  store i32 %inc169, i32* %index155, align 4
  br label %for.cond156

for.end170:                                       ; preds = %for.cond156
  store i32 0, i32* %index171, align 4
  br label %for.cond172

for.cond172:                                      ; preds = %for.inc178, %for.end170
  %125 = load i32, i32* %index171, align 4
  %126 = load i32, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
  %cmp173 = icmp ult i32 %125, %126
  br i1 %cmp173, label %for.body175, label %for.end180

for.body175:                                      ; preds = %for.cond172
  %127 = load double, double* %min, align 8
  %128 = load double*, double** %pa, align 4
  %129 = load i32, i32* %index171, align 4
  %arrayidx176 = getelementptr inbounds double, double* %128, i32 %129
  store double %127, double* %arrayidx176, align 8
  %130 = load double, double* %min, align 8
  %131 = load double*, double** %q, align 4
  %132 = load i32, i32* %index171, align 4
  %arrayidx177 = getelementptr inbounds double, double* %131, i32 %132
  store double %130, double* %arrayidx177, align 8
  br label %for.inc178

for.inc178:                                       ; preds = %for.body175
  %133 = load i32, i32* %index171, align 4
  %inc179 = add i32 %133, 1
  store i32 %inc179, i32* %index171, align 4
  br label %for.cond172

for.end180:                                       ; preds = %for.cond172
  %134 = load i32, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
  %sub181 = sub i32 %134, 1
  store i32 %sub181, i32* %j, align 4
  br label %for.cond182

for.cond182:                                      ; preds = %for.inc272, %for.end180
  %135 = load i32, i32* %j, align 4
  %cmp183 = icmp uge i32 %135, 2
  br i1 %cmp183, label %for.body185, label %for.end273

for.body185:                                      ; preds = %for.cond182
  %136 = load i32, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
  %137 = load i32, i32* %j, align 4
  %sub186 = sub i32 %136, %137
  %call187 = call i32* @seq_len(i32 0, i32 %sub186)
  store i32* %call187, i32** %ij, align 4
  %138 = load i32, i32* %j, align 4
  %sub188 = sub i32 %138, 1
  store i32 %sub188, i32* %I2_LENGTH, align 4
  %139 = load i32, i32* %I2_LENGTH, align 4
  %mul189 = mul i32 %139, 4
  %call190 = call noalias i8* @malloc(i32 %mul189)
  %140 = bitcast i8* %call190 to i32*
  store i32* %140, i32** %i2, align 4
  store i32 0, i32* %i, align 4
  br label %for.cond191

for.cond191:                                      ; preds = %for.inc200, %for.body185
  %141 = load i32, i32* %i, align 4
  %142 = load i32, i32* %I2_LENGTH, align 4
  %cmp192 = icmp ult i32 %141, %142
  br i1 %cmp192, label %for.body194, label %for.end202

for.body194:                                      ; preds = %for.cond191
  %143 = load i32, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
  %144 = load i32, i32* %j, align 4
  %sub195 = sub i32 %143, %144
  %add196 = add i32 %sub195, 2
  %145 = load i32, i32* %i, align 4
  %add197 = add i32 %add196, %145
  %sub198 = sub i32 %add197, 1
  %146 = load i32*, i32** %i2, align 4
  %147 = load i32, i32* %i, align 4
  %arrayidx199 = getelementptr inbounds i32, i32* %146, i32 %147
  store i32 %sub198, i32* %arrayidx199, align 4
  br label %for.inc200

for.inc200:                                       ; preds = %for.body194
  %148 = load i32, i32* %i, align 4
  %inc201 = add i32 %148, 1
  store i32 %inc201, i32* %i, align 4
  br label %for.cond191

for.end202:                                       ; preds = %for.cond191
  %149 = load i32, i32* %j, align 4
  %conv203 = uitofp i32 %149 to double
  %150 = load double*, double** %p, align 4
  %151 = load i32*, i32** %i2, align 4
  %arrayidx204 = getelementptr inbounds i32, i32* %151, i32 0
  %152 = load i32, i32* %arrayidx204, align 4
  %arrayidx205 = getelementptr inbounds double, double* %150, i32 %152
  %153 = load double, double* %arrayidx205, align 8
  %mul206 = fmul double %conv203, %153
  %div207 = fdiv double %mul206, 2.000000e+00
  store double %div207, double* %q1, align 8
  store i32 1, i32* %i208, align 4
  br label %for.cond209

for.cond209:                                      ; preds = %for.inc224, %for.end202
  %154 = load i32, i32* %i208, align 4
  %155 = load i32, i32* %I2_LENGTH, align 4
  %cmp210 = icmp ult i32 %154, %155
  br i1 %cmp210, label %for.body212, label %for.end226

for.body212:                                      ; preds = %for.cond209
  %156 = load i32, i32* %j, align 4
  %conv213 = uitofp i32 %156 to double
  %157 = load double*, double** %p, align 4
  %158 = load i32*, i32** %i2, align 4
  %159 = load i32, i32* %i208, align 4
  %arrayidx214 = getelementptr inbounds i32, i32* %158, i32 %159
  %160 = load i32, i32* %arrayidx214, align 4
  %arrayidx215 = getelementptr inbounds double, double* %157, i32 %160
  %161 = load double, double* %arrayidx215, align 8
  %mul216 = fmul double %conv213, %161
  %162 = load i32, i32* %i208, align 4
  %add217 = add i32 2, %162
  %conv218 = uitofp i32 %add217 to double
  %div219 = fdiv double %mul216, %conv218
  store double %div219, double* %TEMP_Q1, align 8
  %163 = load double, double* %TEMP_Q1, align 8
  %164 = load double, double* %q1, align 8
  %cmp220 = fcmp olt double %163, %164
  br i1 %cmp220, label %if.then222, label %if.end223

if.then222:                                       ; preds = %for.body212
  %165 = load double, double* %TEMP_Q1, align 8
  store double %165, double* %q1, align 8
  br label %if.end223

if.end223:                                        ; preds = %if.then222, %for.body212
  br label %for.inc224

for.inc224:                                       ; preds = %if.end223
  %166 = load i32, i32* %i208, align 4
  %inc225 = add i32 %166, 1
  store i32 %inc225, i32* %i208, align 4
  br label %for.cond209

for.end226:                                       ; preds = %for.cond209
  store i32 0, i32* %i227, align 4
  br label %for.cond228

for.cond228:                                      ; preds = %for.inc241, %for.end226
  %167 = load i32, i32* %i227, align 4
  %168 = load i32, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
  %169 = load i32, i32* %j, align 4
  %sub229 = sub i32 %168, %169
  %add230 = add i32 %sub229, 1
  %cmp231 = icmp ult i32 %167, %add230
  br i1 %cmp231, label %for.body233, label %for.end243

for.body233:                                      ; preds = %for.cond228
  %170 = load i32, i32* %j, align 4
  %conv234 = uitofp i32 %170 to double
  %171 = load double*, double** %p, align 4
  %172 = load i32*, i32** %ij, align 4
  %173 = load i32, i32* %i227, align 4
  %arrayidx235 = getelementptr inbounds i32, i32* %172, i32 %173
  %174 = load i32, i32* %arrayidx235, align 4
  %arrayidx236 = getelementptr inbounds double, double* %171, i32 %174
  %175 = load double, double* %arrayidx236, align 8
  %mul237 = fmul double %conv234, %175
  %176 = load double, double* %q1, align 8
  %call238 = call double @min2(double %mul237, double %176)
  %177 = load double*, double** %q, align 4
  %178 = load i32*, i32** %ij, align 4
  %179 = load i32, i32* %i227, align 4
  %arrayidx239 = getelementptr inbounds i32, i32* %178, i32 %179
  %180 = load i32, i32* %arrayidx239, align 4
  %arrayidx240 = getelementptr inbounds double, double* %177, i32 %180
  store double %call238, double* %arrayidx240, align 8
  br label %for.inc241

for.inc241:                                       ; preds = %for.body233
  %181 = load i32, i32* %i227, align 4
  %inc242 = add i32 %181, 1
  store i32 %inc242, i32* %i227, align 4
  br label %for.cond228

for.end243:                                       ; preds = %for.cond228
  %182 = load i32*, i32** %ij, align 4
  %183 = bitcast i32* %182 to i8*
  call void @free(i8* %183)
  store i32* null, i32** %ij, align 4
  store i32 0, i32* %i244, align 4
  br label %for.cond245

for.cond245:                                      ; preds = %for.inc253, %for.end243
  %184 = load i32, i32* %i244, align 4
  %185 = load i32, i32* %I2_LENGTH, align 4
  %cmp246 = icmp ult i32 %184, %185
  br i1 %cmp246, label %for.body248, label %for.end255

for.body248:                                      ; preds = %for.cond245
  %186 = load double*, double** %q, align 4
  %187 = load i32, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
  %188 = load i32, i32* %j, align 4
  %sub249 = sub i32 %187, %188
  %arrayidx250 = getelementptr inbounds double, double* %186, i32 %sub249
  %189 = load double, double* %arrayidx250, align 8
  %190 = load double*, double** %q, align 4
  %191 = load i32*, i32** %i2, align 4
  %192 = load i32, i32* %i244, align 4
  %arrayidx251 = getelementptr inbounds i32, i32* %191, i32 %192
  %193 = load i32, i32* %arrayidx251, align 4
  %arrayidx252 = getelementptr inbounds double, double* %190, i32 %193
  store double %189, double* %arrayidx252, align 8
  br label %for.inc253

for.inc253:                                       ; preds = %for.body248
  %194 = load i32, i32* %i244, align 4
  %inc254 = add i32 %194, 1
  store i32 %inc254, i32* %i244, align 4
  br label %for.cond245

for.end255:                                       ; preds = %for.cond245
  %195 = load i32*, i32** %i2, align 4
  %196 = bitcast i32* %195 to i8*
  call void @free(i8* %196)
  store i32* null, i32** %i2, align 4
  store i32 0, i32* %i256, align 4
  br label %for.cond257

for.cond257:                                      ; preds = %for.inc269, %for.end255
  %197 = load i32, i32* %i256, align 4
  %198 = load i32, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
  %cmp258 = icmp ult i32 %197, %198
  br i1 %cmp258, label %for.body260, label %for.end271

for.body260:                                      ; preds = %for.cond257
  %199 = load double*, double** %pa, align 4
  %200 = load i32, i32* %i256, align 4
  %arrayidx261 = getelementptr inbounds double, double* %199, i32 %200
  %201 = load double, double* %arrayidx261, align 8
  %202 = load double*, double** %q, align 4
  %203 = load i32, i32* %i256, align 4
  %arrayidx262 = getelementptr inbounds double, double* %202, i32 %203
  %204 = load double, double* %arrayidx262, align 8
  %cmp263 = fcmp olt double %201, %204
  br i1 %cmp263, label %if.then265, label %if.end268

if.then265:                                       ; preds = %for.body260
  %205 = load double*, double** %q, align 4
  %206 = load i32, i32* %i256, align 4
  %arrayidx266 = getelementptr inbounds double, double* %205, i32 %206
  %207 = load double, double* %arrayidx266, align 8
  %208 = load double*, double** %pa, align 4
  %209 = load i32, i32* %i256, align 4
  %arrayidx267 = getelementptr inbounds double, double* %208, i32 %209
  store double %207, double* %arrayidx267, align 8
  br label %if.end268

if.end268:                                        ; preds = %if.then265, %for.body260
  br label %for.inc269

for.inc269:                                       ; preds = %if.end268
  %210 = load i32, i32* %i256, align 4
  %inc270 = add i32 %210, 1
  store i32 %inc270, i32* %i256, align 4
  br label %for.cond257

for.end271:                                       ; preds = %for.cond257
  br label %for.inc272

for.inc272:                                       ; preds = %for.end271
  %211 = load i32, i32* %j, align 4
  %dec = add i32 %211, -1
  store i32 %dec, i32* %j, align 4
  br label %for.cond182

for.end273:                                       ; preds = %for.cond182
  %212 = load double*, double** %p, align 4
  %213 = bitcast double* %212 to i8*
  call void @free(i8* %213)
  store double* null, double** %p, align 4
  store i32 0, i32* %index274, align 4
  br label %for.cond275

for.cond275:                                      ; preds = %for.inc282, %for.end273
  %214 = load i32, i32* %index274, align 4
  %215 = load i32, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
  %cmp276 = icmp ult i32 %214, %215
  br i1 %cmp276, label %for.body278, label %for.end284

for.body278:                                      ; preds = %for.cond275
  %216 = load double*, double** %pa, align 4
  %217 = load i32*, i32** %ro136, align 4
  %218 = load i32, i32* %index274, align 4
  %arrayidx279 = getelementptr inbounds i32, i32* %217, i32 %218
  %219 = load i32, i32* %arrayidx279, align 4
  %arrayidx280 = getelementptr inbounds double, double* %216, i32 %219
  %220 = load double, double* %arrayidx280, align 8
  %221 = load double*, double** %q, align 4
  %222 = load i32, i32* %index274, align 4
  %arrayidx281 = getelementptr inbounds double, double* %221, i32 %222
  store double %220, double* %arrayidx281, align 8
  br label %for.inc282

for.inc282:                                       ; preds = %for.body278
  %223 = load i32, i32* %index274, align 4
  %inc283 = add i32 %223, 1
  store i32 %inc283, i32* %index274, align 4
  br label %for.cond275

for.end284:                                       ; preds = %for.cond275
  %224 = load i32*, i32** %ro136, align 4
  %225 = bitcast i32* %224 to i8*
  call void @free(i8* %225)
  store i32* null, i32** %ro136, align 4
  %226 = load double*, double** %pa, align 4
  %227 = bitcast double* %226 to i8*
  call void @free(i8* %227)
  store double* null, double** %pa, align 4
  %228 = load double*, double** %q, align 4
  store double* %228, double** %retval, align 4
  br label %return

if.end285:                                        ; preds = %if.else109
  br label %if.end286

if.end286:                                        ; preds = %if.end285
  br label %if.end287

if.end287:                                        ; preds = %if.end286
  %229 = load double*, double** %PVALUES.addr, align 4
  %230 = load i32, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
  %call289 = call i32* @order(double* %229, i32 %230, i1 zeroext true)
  store i32* %call289, i32** %o288, align 4
  %231 = load i32*, i32** %o288, align 4
  %cmp290 = icmp eq i32* %231, null
  br i1 %cmp290, label %if.then292, label %if.end294

if.then292:                                       ; preds = %if.end287
  %call293 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([33 x i8], [33 x i8]* @.str.3, i32 0, i32 0), i8* getelementptr inbounds ([23 x i8], [23 x i8]* @.str.1, i32 0, i32 0), i32 398)
  call void @perror(i8* getelementptr inbounds ([1 x i8], [1 x i8]* @.str.2, i32 0, i32 0))
  call void @exit(i32 1) #5
  unreachable

if.end294:                                        ; preds = %if.end287
  %232 = load i32*, i32** %o288, align 4
  %233 = load i32, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
  %call295 = call double* @uint2double(i32* %232, i32 %233)
  store double* %call295, double** %o_double, align 4
  store i32 0, i32* %index296, align 4
  br label %for.cond297

for.cond297:                                      ; preds = %for.inc312, %if.end294
  %234 = load i32, i32* %index296, align 4
  %235 = load i32, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
  %cmp298 = icmp ult i32 %234, %235
  br i1 %cmp298, label %for.body300, label %for.end314

for.body300:                                      ; preds = %for.cond297
  %236 = load double*, double** %PVALUES.addr, align 4
  %237 = load i32, i32* %index296, align 4
  %arrayidx301 = getelementptr inbounds double, double* %236, i32 %237
  %238 = load double, double* %arrayidx301, align 8
  %cmp302 = fcmp olt double %238, 0.000000e+00
  br i1 %cmp302, label %if.then307, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %for.body300
  %239 = load double*, double** %PVALUES.addr, align 4
  %240 = load i32, i32* %index296, align 4
  %arrayidx304 = getelementptr inbounds double, double* %239, i32 %240
  %241 = load double, double* %arrayidx304, align 8
  %cmp305 = fcmp ogt double %241, 1.000000e+00
  br i1 %cmp305, label %if.then307, label %if.end311

if.then307:                                       ; preds = %lor.lhs.false, %for.body300
  %242 = load i32, i32* %index296, align 4
  %243 = load double*, double** %PVALUES.addr, align 4
  %244 = load i32, i32* %index296, align 4
  %arrayidx308 = getelementptr inbounds double, double* %243, i32 %244
  %245 = load double, double* %arrayidx308, align 8
  %call309 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([54 x i8], [54 x i8]* @.str.24, i32 0, i32 0), i32 %242, double %245)
  %call310 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([20 x i8], [20 x i8]* @.str.25, i32 0, i32 0), i8* getelementptr inbounds ([23 x i8], [23 x i8]* @.str.1, i32 0, i32 0), i32 406)
  call void @exit(i32 1) #5
  unreachable

if.end311:                                        ; preds = %lor.lhs.false
  br label %for.inc312

for.inc312:                                       ; preds = %if.end311
  %246 = load i32, i32* %index296, align 4
  %inc313 = add i32 %246, 1
  store i32 %inc313, i32* %index296, align 4
  br label %for.cond297

for.end314:                                       ; preds = %for.cond297
  %247 = load double*, double** %o_double, align 4
  %248 = load i32, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
  %call316 = call i32* @order(double* %247, i32 %248, i1 zeroext false)
  store i32* %call316, i32** %ro315, align 4
  %249 = load i32*, i32** %ro315, align 4
  %cmp317 = icmp eq i32* %249, null
  br i1 %cmp317, label %if.then319, label %if.end321

if.then319:                                       ; preds = %for.end314
  %call320 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([33 x i8], [33 x i8]* @.str.3, i32 0, i32 0), i8* getelementptr inbounds ([23 x i8], [23 x i8]* @.str.1, i32 0, i32 0), i32 413)
  call void @perror(i8* getelementptr inbounds ([1 x i8], [1 x i8]* @.str.2, i32 0, i32 0))
  call void @exit(i32 1) #5
  unreachable

if.end321:                                        ; preds = %for.end314
  %250 = load double*, double** %o_double, align 4
  %251 = bitcast double* %250 to i8*
  call void @free(i8* %251)
  store double* null, double** %o_double, align 4
  %252 = load i32, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
  %mul322 = mul i32 8, %252
  %call323 = call noalias i8* @malloc(i32 %mul322)
  %253 = bitcast i8* %call323 to double*
  store double* %253, double** %cummin_input, align 4
  %254 = load i16, i16* %TYPE, align 2
  %conv324 = sext i16 %254 to i32
  %cmp325 = icmp eq i32 %conv324, 0
  br i1 %cmp325, label %if.then327, label %if.else344

if.then327:                                       ; preds = %if.end321
  store i32 0, i32* %index328, align 4
  br label %for.cond329

for.cond329:                                      ; preds = %for.inc341, %if.then327
  %255 = load i32, i32* %index328, align 4
  %256 = load i32, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
  %cmp330 = icmp ult i32 %255, %256
  br i1 %cmp330, label %for.body332, label %for.end343

for.body332:                                      ; preds = %for.cond329
  %257 = load i32, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
  %conv333 = uitofp i32 %257 to double
  %258 = load i32, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
  %259 = load i32, i32* %index328, align 4
  %sub334 = sub i32 %258, %259
  %conv335 = uitofp i32 %sub334 to double
  %div336 = fdiv double %conv333, %conv335
  store double %div336, double* %NI, align 8
  %260 = load double, double* %NI, align 8
  %261 = load double*, double** %PVALUES.addr, align 4
  %262 = load i32*, i32** %o288, align 4
  %263 = load i32, i32* %index328, align 4
  %arrayidx337 = getelementptr inbounds i32, i32* %262, i32 %263
  %264 = load i32, i32* %arrayidx337, align 4
  %arrayidx338 = getelementptr inbounds double, double* %261, i32 %264
  %265 = load double, double* %arrayidx338, align 8
  %mul339 = fmul double %260, %265
  %266 = load double*, double** %cummin_input, align 4
  %267 = load i32, i32* %index328, align 4
  %arrayidx340 = getelementptr inbounds double, double* %266, i32 %267
  store double %mul339, double* %arrayidx340, align 8
  br label %for.inc341

for.inc341:                                       ; preds = %for.body332
  %268 = load i32, i32* %index328, align 4
  %inc342 = add i32 %268, 1
  store i32 %inc342, i32* %index328, align 4
  br label %for.cond329

for.end343:                                       ; preds = %for.cond329
  br label %if.end401

if.else344:                                       ; preds = %if.end321
  %269 = load i16, i16* %TYPE, align 2
  %conv345 = sext i16 %269 to i32
  %cmp346 = icmp eq i32 %conv345, 1
  br i1 %cmp346, label %if.then348, label %if.else380

if.then348:                                       ; preds = %if.else344
  store double 1.000000e+00, double* %q349, align 8
  store i32 2, i32* %index350, align 4
  br label %for.cond351

for.cond351:                                      ; preds = %for.inc359, %if.then348
  %270 = load i32, i32* %index350, align 4
  %271 = load i32, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
  %add352 = add i32 1, %271
  %cmp353 = icmp ult i32 %270, %add352
  br i1 %cmp353, label %for.body355, label %for.end361

for.body355:                                      ; preds = %for.cond351
  %272 = load i32, i32* %index350, align 4
  %conv356 = uitofp i32 %272 to double
  %div357 = fdiv double 1.000000e+00, %conv356
  %273 = load double, double* %q349, align 8
  %add358 = fadd double %273, %div357
  store double %add358, double* %q349, align 8
  br label %for.inc359

for.inc359:                                       ; preds = %for.body355
  %274 = load i32, i32* %index350, align 4
  %inc360 = add i32 %274, 1
  store i32 %inc360, i32* %index350, align 4
  br label %for.cond351

for.end361:                                       ; preds = %for.cond351
  store i32 0, i32* %index362, align 4
  br label %for.cond363

for.cond363:                                      ; preds = %for.inc377, %for.end361
  %275 = load i32, i32* %index362, align 4
  %276 = load i32, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
  %cmp364 = icmp ult i32 %275, %276
  br i1 %cmp364, label %for.body366, label %for.end379

for.body366:                                      ; preds = %for.cond363
  %277 = load i32, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
  %conv368 = uitofp i32 %277 to double
  %278 = load i32, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
  %279 = load i32, i32* %index362, align 4
  %sub369 = sub i32 %278, %279
  %conv370 = uitofp i32 %sub369 to double
  %div371 = fdiv double %conv368, %conv370
  store double %div371, double* %NI367, align 8
  %280 = load double, double* %q349, align 8
  %281 = load double, double* %NI367, align 8
  %mul372 = fmul double %280, %281
  %282 = load double*, double** %PVALUES.addr, align 4
  %283 = load i32*, i32** %o288, align 4
  %284 = load i32, i32* %index362, align 4
  %arrayidx373 = getelementptr inbounds i32, i32* %283, i32 %284
  %285 = load i32, i32* %arrayidx373, align 4
  %arrayidx374 = getelementptr inbounds double, double* %282, i32 %285
  %286 = load double, double* %arrayidx374, align 8
  %mul375 = fmul double %mul372, %286
  %287 = load double*, double** %cummin_input, align 4
  %288 = load i32, i32* %index362, align 4
  %arrayidx376 = getelementptr inbounds double, double* %287, i32 %288
  store double %mul375, double* %arrayidx376, align 8
  br label %for.inc377

for.inc377:                                       ; preds = %for.body366
  %289 = load i32, i32* %index362, align 4
  %inc378 = add i32 %289, 1
  store i32 %inc378, i32* %index362, align 4
  br label %for.cond363

for.end379:                                       ; preds = %for.cond363
  br label %if.end400

if.else380:                                       ; preds = %if.else344
  %290 = load i16, i16* %TYPE, align 2
  %conv381 = sext i16 %290 to i32
  %cmp382 = icmp eq i32 %conv381, 3
  br i1 %cmp382, label %if.then384, label %if.end399

if.then384:                                       ; preds = %if.else380
  store i32 0, i32* %index385, align 4
  br label %for.cond386

for.cond386:                                      ; preds = %for.inc396, %if.then384
  %291 = load i32, i32* %index385, align 4
  %292 = load i32, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
  %cmp387 = icmp ult i32 %291, %292
  br i1 %cmp387, label %for.body389, label %for.end398

for.body389:                                      ; preds = %for.cond386
  %293 = load i32, i32* %index385, align 4
  %add390 = add i32 %293, 1
  %conv391 = uitofp i32 %add390 to double
  %294 = load double*, double** %PVALUES.addr, align 4
  %295 = load i32*, i32** %o288, align 4
  %296 = load i32, i32* %index385, align 4
  %arrayidx392 = getelementptr inbounds i32, i32* %295, i32 %296
  %297 = load i32, i32* %arrayidx392, align 4
  %arrayidx393 = getelementptr inbounds double, double* %294, i32 %297
  %298 = load double, double* %arrayidx393, align 8
  %mul394 = fmul double %conv391, %298
  %299 = load double*, double** %cummin_input, align 4
  %300 = load i32, i32* %index385, align 4
  %arrayidx395 = getelementptr inbounds double, double* %299, i32 %300
  store double %mul394, double* %arrayidx395, align 8
  br label %for.inc396

for.inc396:                                       ; preds = %for.body389
  %301 = load i32, i32* %index385, align 4
  %inc397 = add i32 %301, 1
  store i32 %inc397, i32* %index385, align 4
  br label %for.cond386

for.end398:                                       ; preds = %for.cond386
  br label %if.end399

if.end399:                                        ; preds = %for.end398, %if.else380
  br label %if.end400

if.end400:                                        ; preds = %if.end399, %for.end379
  br label %if.end401

if.end401:                                        ; preds = %if.end400, %for.end343
  %302 = load i32*, i32** %o288, align 4
  %303 = bitcast i32* %302 to i8*
  call void @free(i8* %303)
  store i32* null, i32** %o288, align 4
  store double* null, double** %cummin_array, align 4
  %304 = load double*, double** %cummin_input, align 4
  %305 = load i32, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
  %call402 = call double* @cummin(double* %304, i32 %305)
  store double* %call402, double** %cummin_array, align 4
  %306 = load double*, double** %cummin_input, align 4
  %307 = bitcast double* %306 to i8*
  call void @free(i8* %307)
  store double* null, double** %cummin_input, align 4
  %308 = load double*, double** %cummin_array, align 4
  %309 = load i32, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
  %call404 = call double* @pminx(double* %308, i32 %309, double 1.000000e+00)
  store double* %call404, double** %pmin403, align 4
  %310 = load double*, double** %cummin_array, align 4
  %311 = bitcast double* %310 to i8*
  call void @free(i8* %311)
  store double* null, double** %cummin_array, align 4
  %312 = load i32, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
  %mul405 = mul i32 %312, 8
  %call406 = call noalias i8* @malloc(i32 %mul405)
  %313 = bitcast i8* %call406 to double*
  store double* %313, double** %q_array, align 4
  store i32 0, i32* %index407, align 4
  br label %for.cond408

for.cond408:                                      ; preds = %for.inc415, %if.end401
  %314 = load i32, i32* %index407, align 4
  %315 = load i32, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
  %cmp409 = icmp ult i32 %314, %315
  br i1 %cmp409, label %for.body411, label %for.end417

for.body411:                                      ; preds = %for.cond408
  %316 = load double*, double** %pmin403, align 4
  %317 = load i32*, i32** %ro315, align 4
  %318 = load i32, i32* %index407, align 4
  %arrayidx412 = getelementptr inbounds i32, i32* %317, i32 %318
  %319 = load i32, i32* %arrayidx412, align 4
  %arrayidx413 = getelementptr inbounds double, double* %316, i32 %319
  %320 = load double, double* %arrayidx413, align 8
  %321 = load double*, double** %q_array, align 4
  %322 = load i32, i32* %index407, align 4
  %arrayidx414 = getelementptr inbounds double, double* %321, i32 %322
  store double %320, double* %arrayidx414, align 8
  br label %for.inc415

for.inc415:                                       ; preds = %for.body411
  %323 = load i32, i32* %index407, align 4
  %inc416 = add i32 %323, 1
  store i32 %inc416, i32* %index407, align 4
  br label %for.cond408

for.end417:                                       ; preds = %for.cond408
  %324 = load i32*, i32** %ro315, align 4
  %325 = bitcast i32* %324 to i8*
  call void @free(i8* %325)
  store i32* null, i32** %ro315, align 4
  %326 = load double*, double** %pmin403, align 4
  %327 = bitcast double* %326 to i8*
  call void @free(i8* %327)
  store double* null, double** %pmin403, align 4
  %328 = load double*, double** %q_array, align 4
  store double* %328, double** %retval, align 4
  br label %return

return:                                           ; preds = %for.end417, %for.end284, %for.end108, %for.end
  %329 = load double*, double** %retval, align 4
  ret double* %329
}

declare i32 @strcasecmp(i8* %0, i8* %1) #1

; Function Attrs: noinline nounwind optnone
define hidden i32 @main() #0 {
entry:
  %retval = alloca i32, align 4
  %PVALUES = alloca [50 x double], align 16
  %CORRECT_ANSWERS = alloca [6 x [50 x double]], align 16
  %TYPES = alloca [6 x i8*], align 16
  %type = alloca i16, align 2
  %q = alloca double*, align 4
  %error = alloca double, align 8
  %i = alloca i32, align 4
  %this_error = alloca double, align 8
  store i32 0, i32* %retval, align 4
  %0 = bitcast [50 x double]* %PVALUES to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 16 %0, i8* align 16 bitcast ([50 x double]* @__const.main.PVALUES to i8*), i32 400, i1 false)
  %1 = bitcast [6 x [50 x double]]* %CORRECT_ANSWERS to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 16 %1, i8* align 16 bitcast ([6 x [50 x double]]* @__const.main.CORRECT_ANSWERS to i8*), i32 2400, i1 false)
  %2 = bitcast [6 x i8*]* %TYPES to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 16 %2, i8* align 16 bitcast ([6 x i8*]* @__const.main.TYPES to i8*), i32 24, i1 false)
  store i16 0, i16* %type, align 2
  br label %for.cond

for.cond:                                         ; preds = %for.inc19, %entry
  %3 = load i16, i16* %type, align 2
  %conv = zext i16 %3 to i32
  %cmp = icmp sle i32 %conv, 5
  br i1 %cmp, label %for.body, label %for.end21

for.body:                                         ; preds = %for.cond
  %arraydecay = getelementptr inbounds [50 x double], [50 x double]* %PVALUES, i32 0, i32 0
  %4 = load i16, i16* %type, align 2
  %idxprom = zext i16 %4 to i32
  %arrayidx = getelementptr inbounds [6 x i8*], [6 x i8*]* %TYPES, i32 0, i32 %idxprom
  %5 = load i8*, i8** %arrayidx, align 4
  %call = call double* @p_adjust(double* %arraydecay, i32 50, i8* %5)
  store double* %call, double** %q, align 4
  %6 = load double*, double** %q, align 4
  %arrayidx2 = getelementptr inbounds double, double* %6, i32 0
  %7 = load double, double* %arrayidx2, align 8
  %8 = load i16, i16* %type, align 2
  %idxprom3 = zext i16 %8 to i32
  %arrayidx4 = getelementptr inbounds [6 x [50 x double]], [6 x [50 x double]]* %CORRECT_ANSWERS, i32 0, i32 %idxprom3
  %arrayidx5 = getelementptr inbounds [50 x double], [50 x double]* %arrayidx4, i32 0, i32 0
  %9 = load double, double* %arrayidx5, align 16
  %sub = fsub double %7, %9
  %10 = call double @llvm.fabs.f64(double %sub)
  store double %10, double* %error, align 8
  store i32 1, i32* %i, align 4
  br label %for.cond6

for.cond6:                                        ; preds = %for.inc, %for.body
  %11 = load i32, i32* %i, align 4
  %cmp7 = icmp ult i32 %11, 50
  br i1 %cmp7, label %for.body9, label %for.end

for.body9:                                        ; preds = %for.cond6
  %12 = load double*, double** %q, align 4
  %13 = load i32, i32* %i, align 4
  %arrayidx10 = getelementptr inbounds double, double* %12, i32 %13
  %14 = load double, double* %arrayidx10, align 8
  %15 = load i16, i16* %type, align 2
  %idxprom11 = zext i16 %15 to i32
  %arrayidx12 = getelementptr inbounds [6 x [50 x double]], [6 x [50 x double]]* %CORRECT_ANSWERS, i32 0, i32 %idxprom11
  %16 = load i32, i32* %i, align 4
  %arrayidx13 = getelementptr inbounds [50 x double], [50 x double]* %arrayidx12, i32 0, i32 %16
  %17 = load double, double* %arrayidx13, align 8
  %sub14 = fsub double %14, %17
  %18 = call double @llvm.fabs.f64(double %sub14)
  store double %18, double* %this_error, align 8
  %19 = load double, double* %this_error, align 8
  %20 = load double, double* %error, align 8
  %add = fadd double %20, %19
  store double %add, double* %error, align 8
  br label %for.inc

for.inc:                                          ; preds = %for.body9
  %21 = load i32, i32* %i, align 4
  %inc = add i32 %21, 1
  store i32 %inc, i32* %i, align 4
  br label %for.cond6

for.end:                                          ; preds = %for.cond6
  %22 = load double*, double** %q, align 4
  call void @double_say(double* %22, i32 50)
  %23 = load double*, double** %q, align 4
  %24 = bitcast double* %23 to i8*
  call void @free(i8* %24)
  store double* null, double** %q, align 4
  %25 = load i16, i16* %type, align 2
  %conv15 = zext i16 %25 to i32
  %26 = load i16, i16* %type, align 2
  %idxprom16 = zext i16 %26 to i32
  %arrayidx17 = getelementptr inbounds [6 x i8*], [6 x i8*]* %TYPES, i32 0, i32 %idxprom16
  %27 = load i8*, i8** %arrayidx17, align 4
  %28 = load double, double* %error, align 8
  %call18 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([44 x i8], [44 x i8]* @.str.28, i32 0, i32 0), i32 %conv15, i8* %27, double %28)
  br label %for.inc19

for.inc19:                                        ; preds = %for.end
  %29 = load i16, i16* %type, align 2
  %inc20 = add i16 %29, 1
  store i16 %inc20, i16* %type, align 2
  br label %for.cond

for.end21:                                        ; preds = %for.cond
  ret i32 0
}

; Function Attrs: argmemonly nounwind willreturn
declare void @llvm.memcpy.p0i8.p0i8.i32(i8* noalias nocapture writeonly %0, i8* noalias nocapture readonly %1, i32 %2, i1 immarg %3) #3

; Function Attrs: nounwind readnone speculatable willreturn
declare double @llvm.fabs.f64(double %0) #4

attributes #0 = { noinline nounwind optnone "correctly-rounded-divide-sqrt-fp-math"="false" "disable-tail-calls"="false" "frame-pointer"="none" "less-precise-fpmad"="false" "min-legal-vector-width"="0" "no-infs-fp-math"="false" "no-jump-tables"="false" "no-nans-fp-math"="false" "no-signed-zeros-fp-math"="false" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="generic" "unsafe-fp-math"="false" "use-soft-float"="false" }
attributes #1 = { "correctly-rounded-divide-sqrt-fp-math"="false" "disable-tail-calls"="false" "frame-pointer"="none" "less-precise-fpmad"="false" "no-infs-fp-math"="false" "no-nans-fp-math"="false" "no-signed-zeros-fp-math"="false" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="generic" "unsafe-fp-math"="false" "use-soft-float"="false" }
attributes #2 = { noreturn "correctly-rounded-divide-sqrt-fp-math"="false" "disable-tail-calls"="false" "frame-pointer"="none" "less-precise-fpmad"="false" "no-infs-fp-math"="false" "no-nans-fp-math"="false" "no-signed-zeros-fp-math"="false" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="generic" "unsafe-fp-math"="false" "use-soft-float"="false" }
attributes #3 = { argmemonly nounwind willreturn }
attributes #4 = { nounwind readnone speculatable willreturn }
attributes #5 = { noreturn }

!llvm.module.flags = !{!0}
!llvm.ident = !{!1}

!0 = !{i32 1, !"wchar_size", i32 4}
!1 = !{!"clang version 11.0.0 (https://github.com/Jacarte/llvm-project.git 0f6dea67136cc1e0b3d200eb2bb165628970c44b)"}

; Replacing "  %cmp16 = icmp eq i32 %conv15, 1"
; from ""
; with "  %tobool14 = trunc i8 %21 to i1" in:
"%0:i8 = var
%1:i1 = trunc %0
%2:i32 = zext %1
%3:i1 = eq 1:i32, %2
cand %3 %1
"
; with "  %tobool14 = trunc i8 %21 to i1"

Module after replacement:
; ModuleID = './P-value_correction.c.bc'
source_filename = "./P-value_correction.c"
target datalayout = "e-m:e-p:32:32-i64:64-n32:64-S128"
target triple = "wasm32-unknown-wasi"

@.str = private unnamed_addr constant [29 x i8] c"malloc failed at %s line %u\0A\00", align 1
@.str.1 = private unnamed_addr constant [23 x i8] c"./P-value_correction.c\00", align 1
@.str.2 = private unnamed_addr constant [1 x i8] zeroinitializer, align 1
@base_arr = hidden global double* null, align 4
@.str.3 = private unnamed_addr constant [33 x i8] c"failed to malloc at %s line %u.\0A\00", align 1
@.str.4 = private unnamed_addr constant [48 x i8] c"cummin function requires at least one element.\0A\00", align 1
@.str.5 = private unnamed_addr constant [22 x i8] c"Failed at %s line %u\0A\00", align 1
@.str.6 = private unnamed_addr constant [41 x i8] c"function requires at least one element.\0A\00", align 1
@.str.7 = private unnamed_addr constant [37 x i8] c"pmin requires at least one element.\0A\00", align 1
@.str.8 = private unnamed_addr constant [7 x i8] c"[1] %e\00", align 1
@.str.9 = private unnamed_addr constant [7 x i8] c" %.10f\00", align 1
@.str.10 = private unnamed_addr constant [6 x i8] c"\0A[%u]\00", align 1
@.str.11 = private unnamed_addr constant [2 x i8] c"\0A\00", align 1
@.str.12 = private unnamed_addr constant [34 x i8] c"Failure to malloc at %s line %u.\0A\00", align 1
@.str.13 = private unnamed_addr constant [41 x i8] c"p_adjust requires at least one element.\0A\00", align 1
@.str.14 = private unnamed_addr constant [3 x i8] c"BH\00", align 1
@.str.15 = private unnamed_addr constant [4 x i8] c"fdr\00", align 1
@.str.16 = private unnamed_addr constant [3 x i8] c"by\00", align 1
@.str.17 = private unnamed_addr constant [11 x i8] c"Bonferroni\00", align 1
@.str.18 = private unnamed_addr constant [9 x i8] c"hochberg\00", align 1
@.str.19 = private unnamed_addr constant [5 x i8] c"holm\00", align 1
@.str.20 = private unnamed_addr constant [7 x i8] c"hommel\00", align 1
@.str.21 = private unnamed_addr constant [44 x i8] c"%s doesn't match any accepted FDR methods.\0A\00", align 1
@.str.22 = private unnamed_addr constant [42 x i8] c"%g is outside of the interval I planned.\0A\00", align 1
@.str.23 = private unnamed_addr constant [23 x i8] c"Failure at %s line %u\0A\00", align 1
@.str.24 = private unnamed_addr constant [54 x i8] c"array[%u] = %lf, which is outside the interval [0,1]\0A\00", align 1
@.str.25 = private unnamed_addr constant [20 x i8] c"died at %s line %u\0A\00", align 1
@__const.main.PVALUES = private unnamed_addr constant [50 x double] [double 0x3FDD04160F35FDE9, double 0x3FE758E721E2A8D7, double 0x3FB96FAC8B38D8BA, double 0x3FB73E71D5B04B37, double 0x3FC710AB48EE865B, double 0x3FEC01D953C3CC73, double 0x3FD2B3C4BE0A922A, double 0x3FED2B5A568DAB4F, double 0x3FDBE08D73F16964, double 0x3FE10A218C41C242, double 0x3FDF8810DB1996AA, double 0x3FE291CCB11E1A9D, double 0x3FD64E8C550D788F, double 7.883130e-01, double 0x3FD177B2BF048D2D, double 0x3FEB3543434BAF2B, double 0x3FDB50EAD41ED0A6, double 0x3FE49D4AFF01D33F, double 0x3FD364C9AE345B51, double 0x3FA99BA35F15394D, double 3.194810e-01, double 0x3FE941E405CE761A, double 0x3FEFF94F77369843, double 0x3FC65847BFB23217, double 0x3FECEB8879B6A543, double 0x3FBEAF00332BA677, double 0x3FD96207C7749E38, double 0x3F8CC02620502C93, double 0x3FE773A5B45A0F40, double 0x3FB1642C24762C01, double 4.040730e-03, double 0x3F33E11D79A90777, double 0x3F870B02BD749528, double 0x3F98521BD6A0353F, double 0x3F4310F26148FFAA, double 0x3F3427CD76006778, double 0x3F80E60AFB1F8A4E, double 0x3F5639B74A9E4DA2, double 0x3F8BDDF74195769F, double 0x3F38ABEE3BFA8581, double 0x3EF2E2E96B5466FE, double 0x3E90CE9F65B58A88, double 0x3FA0F2D097879B95, double 0x3F834EE7216A6684, double 0x3F4CCE8DBB40BD9D, double 0x3F2C8B969590F2ED, double 0x3F4FC31F7F1541AD, double 6.610250e-05, double 0x3F9DB44EA6AC26BA, double 5.735490e-03], align 16
@__const.main.CORRECT_ANSWERS = private unnamed_addr constant [6 x [50 x double]] [[50 x double] [double 0x3FE39AFA2199ADBC, double 8.521710e-01, double 0x3FC96FAC6045BAF5, double 0x3FC83660E51D25AB, double 0x3FD498068702BE20, double 0x3FEDC3BF727136A4, double 4.870370e-01, double 0x3FEDC3BF727136A4, double 0x3FE35BF08BEEB62C, double 0x3FE5D879DEE92F03, double 0x3FE4BE91D656B94A, double 0x3FE7363FC28DAEAA, double 0x3FE0E62C4F13638A, double 0x3FEC1052C8FAB035, double 0x3FDE1DD2E43E029A, double 0x3FED92EFFC7CBDC1, double 0x3FE35BF08BEEB62C, double 0x3FE923B90CFC67C5, double 0x3FDF47B8FC357024, double 0x3FBD1996A9FB10AD, double 0x3FDFF2B6D6C14255, double 0x3FEC1052C8FAB035, double 0x3FEFF94F77369843, double 0x3FD498068702BE20, double 0x3FEDC3BF727136A4, double 0x3FCD80E2E96EC403, double 0x3FE2A9F6A93F290B, double 0x3FA3F736D8AF2E2B, double 8.521710e-01, double 0x3FC2E751B350FAC4, double 0x3F913D8E55EE9F05, double 0x3F64FECB88BB3633, double 0x3FA2009A03CCBE34, double 0x3FB0001FB57CF9FC, double 0x3F6DCA7ADA5E274A, double 0x3F64FECB88BB3633, double 0x3F9E2D13B467D120, double 0x3F7941963399C6A1, double 0x3FA3F736D8AF2E2B, double 0x3F6607390CEF853C, double 0x3F3D828C80BA213A, double 0x3EEA42D90EEBA875, double 0x3FB42D4181AA8F8B, double 0x3FA01715F12E0018, double 0x3F73D9F3AF6D490C, double 0x3F64FECB88BB3633, double 0x3F73D9F3AF6D490C, double 0x3F520CE5F51A7C61, double 0x3FB290B112B20952, double 0x3F9696C95AA76B69], [50 x double] [double 1.000000e+00, double 1.000000e+00, double 0x3FEC9C56E33BA41B, double 0x3FEB3BF21E95ED3D, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 0x3FE05DA74553C727, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 0x3FC675198790829A, double 1.000000e+00, double 0x3FE54345648E1F12, double 0x3FB3645F501CA2F9, double 0x3F879D934E50F0DE, double 0x3FC43FC3646E3EA2, double 0x3FD1FF539D36064C, double 0x3F90C123206B855F, double 0x3F879D934E50F0DE, double 0x3FC0F8967F32E606, double 0x3F9C6880470D2FBE, double 0x3FC675198790829A, double 0x3F88C70105E47082, double 2.025930e-03, double 0x3F0D89DE4FA8F818, double 0x3FD6B1E2D11B1027, double 0x3FC219271872BD8D, double 0x3F96542FAD16CEF9, double 0x3F879D934E50F0DE, double 0x3F96542FAD16CEF9, double 0x3F744D9816EB319A, double 0x3FD4E1D5728DBC16, double 0x3FB9687C40426555], [50 x double] [double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 0x3FE6761DC93EA2D3, double 1.000000e+00, double 1.000000e+00, double 0x3FC9DC55000C953A, double 0x3F8F0FBD624BA499, double 0x3FE2009A24031487, double 1.000000e+00, double 0x3F9DCA7AB8020F7A, double 0x3F8F7E310860A1AB, double 0x3FDA677128614819, double 6.782670e-02, double 6.803480e-01, double 0x3F9346521EDBB84D, double 0x3F4D828CB7B3E0EE, double 0x3EEA42D90EEBA875, double 1.000000e+00, double 4.713920e-01, double 0x3FA6815EE53DB1E7, double 0x3F864D0CF90CC6B8, double 0x3FA8D0709B489B4F, double 0x3F6B1359791819D2, double 1.000000e+00, double 0x3FD25A836EB4E981], [50 x double] [double 0x3FEFF94F77369843, double 0x3FEFF94F77369843, double 0x3FEFF94F77369843, double 0x3FEFF94F77369843, double 0x3FEFF94F77369843, double 0x3FEFF94F77369843, double 0x3FEFF94F77369843, double 0x3FEFF94F77369843, double 0x3FEFF94F77369843, double 0x3FEFF94F77369843, double 0x3FEFF94F77369843, double 0x3FEFF94F77369843, double 0x3FEFF94F77369843, double 0x3FEFF94F77369843, double 0x3FEFF94F77369843, double 0x3FEFF94F77369843, double 0x3FEFF94F77369843, double 0x3FEFF94F77369843, double 0x3FEFF94F77369843, double 0x3FEFF94F77369843, double 0x3FEFF94F77369843, double 0x3FEFF94F77369843, double 0x3FEFF94F77369843, double 0x3FEFF94F77369843, double 0x3FEFF94F77369843, double 0x3FEFF94F77369843, double 0x3FEFF94F77369843, double 0x3FDDA6274695E687, double 0x3FEFF94F77369843, double 0x3FEFF94F77369843, double 0x3FC42BDC26DCE39B, double 0x3F8C57F9104CA951, double 0x3FD9340AC9879DEF, double 7.600230e-01, double 0x3F999EC5A86B439B, double 0x3F8C57F9104CA951, double 0x3FD389FCD90412B4, double 0x3FABC8251D45E10B, double 0x3FDD9BD68ABBB045, double 0x3F90F633F956C386, double 8.825610e-04, double 0x3EEA42D90EEBA875, double 0x3FEFC7471C1E43B8, double 0x3FD5B8C4014C305A, double 0x3FA2E78CEC8D068E, double 0x3F84F6832995A599, double 0x3FA459002162FC24, double 3.172920e-03, double 8.992520e-01, double 0x3FCBE5BD5E9AC00A], [50 x double] [double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 0x3FDDA6274695E687, double 1.000000e+00, double 1.000000e+00, double 0x3FC42BDC26DCE39B, double 0x3F8C939AFCF101E0, double 0x3FD9340AC9879DEF, double 7.600230e-01, double 0x3F999EC5A86B439B, double 0x3F8C939AFCF101E0, double 0x3FD389FCD90412B4, double 0x3FABC8251D45E10B, double 0x3FDD9BD68ABBB045, double 0x3F90F633F956C386, double 8.825610e-04, double 0x3EEA42D90EEBA875, double 0x3FEFC7471C1E43B8, double 0x3FD5B8C4014C305A, double 0x3FA2E78CEC8D068E, double 0x3F84F6832995A599, double 0x3FA459002162FC24, double 3.172920e-03, double 8.992520e-01, double 0x3FCBE5BD5E9AC00A], [50 x double] [double 0x3FEFF94F77369843, double 0x3FEFF94F77369843, double 0x3FEFF94F77369843, double 0x3FEFF5DC908F2EDD, double 0x3FEFF94F77369843, double 0x3FEFF94F77369843, double 0x3FEFF94F77369843, double 0x3FEFF94F77369843, double 0x3FEFF94F77369843, double 0x3FEFF94F77369843, double 0x3FEFF94F77369843, double 0x3FEFF94F77369843, double 0x3FEFF94F77369843, double 0x3FEFF94F77369843, double 0x3FEFF94F77369843, double 0x3FEFF94F77369843, double 0x3FEFF94F77369843, double 0x3FEFF94F77369843, double 0x3FEFF94F77369843, double 0x3FEEB45F17BD8BE7, double 0x3FEFF94F77369843, double 0x3FEFF94F77369843, double 0x3FEFF94F77369843, double 0x3FEFF94F77369843, double 0x3FEFF94F77369843, double 0x3FEFF94F77369843, double 0x3FEFF94F77369843, double 0x3FDBDA250F840182, double 0x3FEFF94F77369843, double 0x3FEF40BC1D52205E, double 0x3FC21A3BEB689947, double 1.304340e-02, double 0x3FD69916517B1CD7, double 0x3FE60A69453DF7B2, double 0x3F986DB666D9D3C6, double 0x3F8B157BBD3AB385, double 2.722920e-01, double 0x3FABC8251D45E10B, double 0x3FDAFF07B27BE8AF, double 0x3F9030D45E3B9F93, double 8.825610e-04, double 0x3EEA42D90EEBA875, double 0x3FEBFACC1948A662, double 0x3FD34EE6EDE042CB, double 0x3FA2011883DA6A9A, double 0x3F839FF779153716, double 0x3FA3D9F3D1C960DD, double 3.172920e-03, double 0x3FE9FDC4BC5D1301, double 0x3FC8F5FAC3801CF1]], align 16
@.str.26 = private unnamed_addr constant [3 x i8] c"bh\00", align 1
@.str.27 = private unnamed_addr constant [11 x i8] c"bonferroni\00", align 1
@__const.main.TYPES = private unnamed_addr constant [6 x i8*] [i8* getelementptr inbounds ([3 x i8], [3 x i8]* @.str.26, i32 0, i32 0), i8* getelementptr inbounds ([3 x i8], [3 x i8]* @.str.16, i32 0, i32 0), i8* getelementptr inbounds ([11 x i8], [11 x i8]* @.str.27, i32 0, i32 0), i8* getelementptr inbounds ([9 x i8], [9 x i8]* @.str.18, i32 0, i32 0), i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.19, i32 0, i32 0), i8* getelementptr inbounds ([7 x i8], [7 x i8]* @.str.20, i32 0, i32 0)], align 16
@.str.28 = private unnamed_addr constant [44 x i8] c"\0Atype %u = '%s' has cumulative error of %g\0A\00", align 1
@llvm.used = appending global [1 x i8*] [i8* bitcast (i32 ()* @__main_void to i8*)], section "llvm.metadata"

@__main_void = alias i32 (), i32 ()* @main

; Function Attrs: noinline nounwind optnone
define hidden i32* @seq_len(i32 %START, i32 %END) #0 {
entry:
  %retval = alloca i32*, align 4
  %START.addr = alloca i32, align 4
  %END.addr = alloca i32, align 4
  %start = alloca i32, align 4
  %end = alloca i32, align 4
  %sequence = alloca i32*, align 4
  %i = alloca i32, align 4
  %LENGTH = alloca i32, align 4
  %sequence10 = alloca i32*, align 4
  %index = alloca i32, align 4
  %index28 = alloca i32, align 4
  store i32 %START, i32* %START.addr, align 4
  store i32 %END, i32* %END.addr, align 4
  %0 = load i32, i32* %START.addr, align 4
  store i32 %0, i32* %start, align 4
  %1 = load i32, i32* %END.addr, align 4
  store i32 %1, i32* %end, align 4
  %2 = load i32, i32* %START.addr, align 4
  %3 = load i32, i32* %END.addr, align 4
  %cmp = icmp eq i32 %2, %3
  br i1 %cmp, label %if.then, label %if.end6

if.then:                                          ; preds = %entry
  %4 = load i32, i32* %end, align 4
  %add = add i32 %4, 1
  %mul = mul i32 %add, 4
  %call = call noalias i8* @malloc(i32 %mul)
  %5 = bitcast i8* %call to i32*
  store i32* %5, i32** %sequence, align 4
  %6 = load i32*, i32** %sequence, align 4
  %cmp1 = icmp eq i32* %6, null
  br i1 %cmp1, label %if.then2, label %if.end

if.then2:                                         ; preds = %if.then
  %call3 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([29 x i8], [29 x i8]* @.str, i32 0, i32 0), i8* getelementptr inbounds ([23 x i8], [23 x i8]* @.str.1, i32 0, i32 0), i32 15)
  call void @perror(i8* getelementptr inbounds ([1 x i8], [1 x i8]* @.str.2, i32 0, i32 0))
  call void @exit(i32 1) #5
  unreachable

if.end:                                           ; preds = %if.then
  store i32 0, i32* %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.end
  %7 = load i32, i32* %i, align 4
  %8 = load i32, i32* %end, align 4
  %cmp4 = icmp ult i32 %7, %8
  br i1 %cmp4, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %9 = load i32, i32* %i, align 4
  %add5 = add i32 %9, 1
  %10 = load i32*, i32** %sequence, align 4
  %11 = load i32, i32* %i, align 4
  %arrayidx = getelementptr inbounds i32, i32* %10, i32 %11
  store i32 %add5, i32* %arrayidx, align 4
  br label %for.inc

for.inc:                                          ; preds = %for.body
  %12 = load i32, i32* %i, align 4
  %inc = add i32 %12, 1
  store i32 %inc, i32* %i, align 4
  br label %for.cond

for.end:                                          ; preds = %for.cond
  %13 = load i32*, i32** %sequence, align 4
  store i32* %13, i32** %retval, align 4
  br label %return

if.end6:                                          ; preds = %entry
  %14 = load i32, i32* %START.addr, align 4
  %15 = load i32, i32* %END.addr, align 4
  %cmp7 = icmp ugt i32 %14, %15
  br i1 %cmp7, label %if.then8, label %if.end9

if.then8:                                         ; preds = %if.end6
  %16 = load i32, i32* %START.addr, align 4
  store i32 %16, i32* %end, align 4
  %17 = load i32, i32* %END.addr, align 4
  store i32 %17, i32* %start, align 4
  br label %if.end9

if.end9:                                          ; preds = %if.then8, %if.end6
  %18 = load i32, i32* %end, align 4
  %19 = load i32, i32* %start, align 4
  %sub = sub i32 %18, %19
  store i32 %sub, i32* %LENGTH, align 4
  %20 = load i32, i32* %LENGTH, align 4
  %add11 = add i32 1, %20
  %mul12 = mul i32 %add11, 4
  %call13 = call noalias i8* @malloc(i32 %mul12)
  %21 = bitcast i8* %call13 to i32*
  store i32* %21, i32** %sequence10, align 4
  %22 = load i32*, i32** %sequence10, align 4
  %cmp14 = icmp eq i32* %22, null
  br i1 %cmp14, label %if.then15, label %if.end17

if.then15:                                        ; preds = %if.end9
  %call16 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([29 x i8], [29 x i8]* @.str, i32 0, i32 0), i8* getelementptr inbounds ([23 x i8], [23 x i8]* @.str.1, i32 0, i32 0), i32 31)
  call void @perror(i8* getelementptr inbounds ([1 x i8], [1 x i8]* @.str.2, i32 0, i32 0))
  call void @exit(i32 1) #5
  unreachable

if.end17:                                         ; preds = %if.end9
  %23 = load i32, i32* %START.addr, align 4
  %24 = load i32, i32* %END.addr, align 4
  %cmp18 = icmp ult i32 %23, %24
  br i1 %cmp18, label %if.then19, label %if.else

if.then19:                                        ; preds = %if.end17
  store i32 0, i32* %index, align 4
  br label %for.cond20

for.cond20:                                       ; preds = %for.inc25, %if.then19
  %25 = load i32, i32* %index, align 4
  %26 = load i32, i32* %LENGTH, align 4
  %cmp21 = icmp ule i32 %25, %26
  br i1 %cmp21, label %for.body22, label %for.end27

for.body22:                                       ; preds = %for.cond20
  %27 = load i32, i32* %start, align 4
  %28 = load i32, i32* %index, align 4
  %add23 = add i32 %27, %28
  %29 = load i32*, i32** %sequence10, align 4
  %30 = load i32, i32* %index, align 4
  %arrayidx24 = getelementptr inbounds i32, i32* %29, i32 %30
  store i32 %add23, i32* %arrayidx24, align 4
  br label %for.inc25

for.inc25:                                        ; preds = %for.body22
  %31 = load i32, i32* %index, align 4
  %inc26 = add i32 %31, 1
  store i32 %inc26, i32* %index, align 4
  br label %for.cond20

for.end27:                                        ; preds = %for.cond20
  br label %if.end37

if.else:                                          ; preds = %if.end17
  store i32 0, i32* %index28, align 4
  br label %for.cond29

for.cond29:                                       ; preds = %for.inc34, %if.else
  %32 = load i32, i32* %index28, align 4
  %33 = load i32, i32* %LENGTH, align 4
  %cmp30 = icmp ule i32 %32, %33
  br i1 %cmp30, label %for.body31, label %for.end36

for.body31:                                       ; preds = %for.cond29
  %34 = load i32, i32* %end, align 4
  %35 = load i32, i32* %index28, align 4
  %sub32 = sub i32 %34, %35
  %36 = load i32*, i32** %sequence10, align 4
  %37 = load i32, i32* %index28, align 4
  %arrayidx33 = getelementptr inbounds i32, i32* %36, i32 %37
  store i32 %sub32, i32* %arrayidx33, align 4
  br label %for.inc34

for.inc34:                                        ; preds = %for.body31
  %38 = load i32, i32* %index28, align 4
  %inc35 = add i32 %38, 1
  store i32 %inc35, i32* %index28, align 4
  br label %for.cond29

for.end36:                                        ; preds = %for.cond29
  br label %if.end37

if.end37:                                         ; preds = %for.end36, %for.end27
  %39 = load i32*, i32** %sequence10, align 4
  store i32* %39, i32** %retval, align 4
  br label %return

return:                                           ; preds = %if.end37, %for.end
  %40 = load i32*, i32** %retval, align 4
  ret i32* %40
}

declare noalias i8* @malloc(i32 %0) #1

declare i32 @printf(i8* %0, ...) #1

declare void @perror(i8* %0) #1

; Function Attrs: noreturn
declare void @exit(i32 %0) #2

; Function Attrs: noinline nounwind optnone
define hidden i32* @order(double* noalias %ARRAY, i32 %SIZE, i1 zeroext %DECREASING) #0 {
entry:
  %ARRAY.addr = alloca double*, align 4
  %SIZE.addr = alloca i32, align 4
  %DECREASING.addr = alloca i8, align 1
  %idx = alloca i32*, align 4
  %i = alloca i32, align 4
  store double* %ARRAY, double** %ARRAY.addr, align 4
  store i32 %SIZE, i32* %SIZE.addr, align 4
  %frombool = zext i1 %DECREASING to i8
  store i8 %frombool, i8* %DECREASING.addr, align 1
  %0 = load i32, i32* %SIZE.addr, align 4
  %mul = mul i32 %0, 4
  %call = call noalias i8* @malloc(i32 %mul)
  %1 = bitcast i8* %call to i32*
  store i32* %1, i32** %idx, align 4
  %2 = load i32*, i32** %idx, align 4
  %cmp = icmp eq i32* %2, null
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %call1 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([33 x i8], [33 x i8]* @.str.3, i32 0, i32 0), i8* getelementptr inbounds ([23 x i8], [23 x i8]* @.str.1, i32 0, i32 0), i32 77)
  call void @perror(i8* getelementptr inbounds ([1 x i8], [1 x i8]* @.str.2, i32 0, i32 0))
  call void @exit(i32 1) #5
  unreachable

if.end:                                           ; preds = %entry
  %3 = load i32, i32* %SIZE.addr, align 4
  %mul2 = mul i32 8, %3
  %call3 = call noalias i8* @malloc(i32 %mul2)
  %4 = bitcast i8* %call3 to double*
  store double* %4, double** @base_arr, align 4
  %5 = load double*, double** @base_arr, align 4
  %cmp4 = icmp eq double* %5, null
  br i1 %cmp4, label %if.then5, label %if.end7

if.then5:                                         ; preds = %if.end
  %call6 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([33 x i8], [33 x i8]* @.str.3, i32 0, i32 0), i8* getelementptr inbounds ([23 x i8], [23 x i8]* @.str.1, i32 0, i32 0), i32 83)
  call void @perror(i8* getelementptr inbounds ([1 x i8], [1 x i8]* @.str.2, i32 0, i32 0))
  call void @exit(i32 1) #5
  unreachable

if.end7:                                          ; preds = %if.end
  store i32 0, i32* %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.end7
  %6 = load i32, i32* %i, align 4
  %7 = load i32, i32* %SIZE.addr, align 4
  %cmp8 = icmp ult i32 %6, %7
  br i1 %cmp8, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %8 = load double*, double** %ARRAY.addr, align 4
  %9 = load i32, i32* %i, align 4
  %arrayidx = getelementptr inbounds double, double* %8, i32 %9
  %10 = load double, double* %arrayidx, align 8
  %11 = load double*, double** @base_arr, align 4
  %12 = load i32, i32* %i, align 4
  %arrayidx9 = getelementptr inbounds double, double* %11, i32 %12
  store double %10, double* %arrayidx9, align 8
  %13 = load i32, i32* %i, align 4
  %14 = load i32*, i32** %idx, align 4
  %15 = load i32, i32* %i, align 4
  %arrayidx10 = getelementptr inbounds i32, i32* %14, i32 %15
  store i32 %13, i32* %arrayidx10, align 4
  br label %for.inc

for.inc:                                          ; preds = %for.body
  %16 = load i32, i32* %i, align 4
  %inc = add i32 %16, 1
  store i32 %inc, i32* %i, align 4
  br label %for.cond

for.end:                                          ; preds = %for.cond
  %17 = load i8, i8* %DECREASING.addr, align 1
  %tobool = trunc i8 %17 to i1
  %conv = zext i1 %tobool to i32
  %cmp11 = icmp eq i32 %conv, 0
  br i1 %cmp11, label %if.then13, label %if.else

if.then13:                                        ; preds = %for.end
  %18 = load i32*, i32** %idx, align 4
  %19 = bitcast i32* %18 to i8*
  %20 = load i32, i32* %SIZE.addr, align 4
  call void @qsort(i8* %19, i32 %20, i32 4, i32 (i8*, i8*)* @compar_decrease)
  br label %if.end20

if.else:                                          ; preds = %for.end
  %21 = load i8, i8* %DECREASING.addr, align 1
  %tobool14 = trunc i8 %21 to i1
  br i1 %tobool14, label %if.then18, label %if.end19

if.then18:                                        ; preds = %if.else
  %22 = load i32*, i32** %idx, align 4
  %23 = bitcast i32* %22 to i8*
  %24 = load i32, i32* %SIZE.addr, align 4
  call void @qsort(i8* %23, i32 %24, i32 4, i32 (i8*, i8*)* @compar_increase)
  br label %if.end19

if.end19:                                         ; preds = %if.then18, %if.else
  br label %if.end20

if.end20:                                         ; preds = %if.end19, %if.then13
  %25 = load double*, double** @base_arr, align 4
  %26 = bitcast double* %25 to i8*
  call void @free(i8* %26)
  store double* null, double** @base_arr, align 4
  %27 = load i32*, i32** %idx, align 4
  ret i32* %27
}

declare void @qsort(i8* %0, i32 %1, i32 %2, i32 (i8*, i8*)* %3) #1

; Function Attrs: noinline nounwind optnone
define internal i32 @compar_decrease(i8* noalias %a, i8* noalias %b) #0 {
entry:
  %retval = alloca i32, align 4
  %a.addr = alloca i8*, align 4
  %b.addr = alloca i8*, align 4
  %aa = alloca i32, align 4
  %bb = alloca i32, align 4
  store i8* %a, i8** %a.addr, align 4
  store i8* %b, i8** %b.addr, align 4
  %0 = load i8*, i8** %a.addr, align 4
  %1 = bitcast i8* %0 to i32*
  %2 = load i32, i32* %1, align 4
  store i32 %2, i32* %aa, align 4
  %3 = load i8*, i8** %b.addr, align 4
  %4 = bitcast i8* %3 to i32*
  %5 = load i32, i32* %4, align 4
  store i32 %5, i32* %bb, align 4
  %6 = load double*, double** @base_arr, align 4
  %7 = load i32, i32* %aa, align 4
  %arrayidx = getelementptr inbounds double, double* %6, i32 %7
  %8 = load double, double* %arrayidx, align 8
  %9 = load double*, double** @base_arr, align 4
  %10 = load i32, i32* %bb, align 4
  %arrayidx1 = getelementptr inbounds double, double* %9, i32 %10
  %11 = load double, double* %arrayidx1, align 8
  %cmp = fcmp olt double %8, %11
  br i1 %cmp, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  store i32 -1, i32* %retval, align 4
  br label %return

if.else:                                          ; preds = %entry
  %12 = load double*, double** @base_arr, align 4
  %13 = load i32, i32* %aa, align 4
  %arrayidx2 = getelementptr inbounds double, double* %12, i32 %13
  %14 = load double, double* %arrayidx2, align 8
  %15 = load double*, double** @base_arr, align 4
  %16 = load i32, i32* %bb, align 4
  %arrayidx3 = getelementptr inbounds double, double* %15, i32 %16
  %17 = load double, double* %arrayidx3, align 8
  %cmp4 = fcmp oeq double %14, %17
  br i1 %cmp4, label %if.then5, label %if.else6

if.then5:                                         ; preds = %if.else
  store i32 0, i32* %retval, align 4
  br label %return

if.else6:                                         ; preds = %if.else
  store i32 1, i32* %retval, align 4
  br label %return

return:                                           ; preds = %if.else6, %if.then5, %if.then
  %18 = load i32, i32* %retval, align 4
  ret i32 %18
}

; Function Attrs: noinline nounwind optnone
define internal i32 @compar_increase(i8* noalias %a, i8* noalias %b) #0 {
entry:
  %retval = alloca i32, align 4
  %a.addr = alloca i8*, align 4
  %b.addr = alloca i8*, align 4
  %aa = alloca i32, align 4
  %bb = alloca i32, align 4
  store i8* %a, i8** %a.addr, align 4
  store i8* %b, i8** %b.addr, align 4
  %0 = load i8*, i8** %a.addr, align 4
  %1 = bitcast i8* %0 to i32*
  %2 = load i32, i32* %1, align 4
  store i32 %2, i32* %aa, align 4
  %3 = load i8*, i8** %b.addr, align 4
  %4 = bitcast i8* %3 to i32*
  %5 = load i32, i32* %4, align 4
  store i32 %5, i32* %bb, align 4
  %6 = load double*, double** @base_arr, align 4
  %7 = load i32, i32* %aa, align 4
  %arrayidx = getelementptr inbounds double, double* %6, i32 %7
  %8 = load double, double* %arrayidx, align 8
  %9 = load double*, double** @base_arr, align 4
  %10 = load i32, i32* %bb, align 4
  %arrayidx1 = getelementptr inbounds double, double* %9, i32 %10
  %11 = load double, double* %arrayidx1, align 8
  %cmp = fcmp olt double %8, %11
  br i1 %cmp, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  store i32 1, i32* %retval, align 4
  br label %return

if.else:                                          ; preds = %entry
  %12 = load double*, double** @base_arr, align 4
  %13 = load i32, i32* %aa, align 4
  %arrayidx2 = getelementptr inbounds double, double* %12, i32 %13
  %14 = load double, double* %arrayidx2, align 8
  %15 = load double*, double** @base_arr, align 4
  %16 = load i32, i32* %bb, align 4
  %arrayidx3 = getelementptr inbounds double, double* %15, i32 %16
  %17 = load double, double* %arrayidx3, align 8
  %cmp4 = fcmp oeq double %14, %17
  br i1 %cmp4, label %if.then5, label %if.else6

if.then5:                                         ; preds = %if.else
  store i32 0, i32* %retval, align 4
  br label %return

if.else6:                                         ; preds = %if.else
  store i32 -1, i32* %retval, align 4
  br label %return

return:                                           ; preds = %if.else6, %if.then5, %if.then
  %18 = load i32, i32* %retval, align 4
  ret i32 %18
}

declare void @free(i8* %0) #1

; Function Attrs: noinline nounwind optnone
define hidden double* @cummin(double* noalias %ARRAY, i32 %NO_OF_ARRAY_ELEMENTS) #0 {
entry:
  %ARRAY.addr = alloca double*, align 4
  %NO_OF_ARRAY_ELEMENTS.addr = alloca i32, align 4
  %output = alloca double*, align 4
  %cumulative_min = alloca double, align 8
  %i = alloca i32, align 4
  store double* %ARRAY, double** %ARRAY.addr, align 4
  store i32 %NO_OF_ARRAY_ELEMENTS, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
  %0 = load i32, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
  %cmp = icmp ult i32 %0, 1
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %call = call i32 @puts(i8* getelementptr inbounds ([48 x i8], [48 x i8]* @.str.4, i32 0, i32 0))
  %call1 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([22 x i8], [22 x i8]* @.str.5, i32 0, i32 0), i8* getelementptr inbounds ([23 x i8], [23 x i8]* @.str.1, i32 0, i32 0), i32 105)
  call void @exit(i32 1) #5
  unreachable

if.end:                                           ; preds = %entry
  %1 = load i32, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
  %mul = mul i32 8, %1
  %call2 = call noalias i8* @malloc(i32 %mul)
  %2 = bitcast i8* %call2 to double*
  store double* %2, double** %output, align 4
  %3 = load double*, double** %output, align 4
  %cmp3 = icmp eq double* %3, null
  br i1 %cmp3, label %if.then4, label %if.end6

if.then4:                                         ; preds = %if.end
  %call5 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([33 x i8], [33 x i8]* @.str.3, i32 0, i32 0), i8* getelementptr inbounds ([23 x i8], [23 x i8]* @.str.1, i32 0, i32 0), i32 110)
  call void @perror(i8* getelementptr inbounds ([1 x i8], [1 x i8]* @.str.2, i32 0, i32 0))
  call void @exit(i32 1) #5
  unreachable

if.end6:                                          ; preds = %if.end
  %4 = load double*, double** %ARRAY.addr, align 4
  %arrayidx = getelementptr inbounds double, double* %4, i32 0
  %5 = load double, double* %arrayidx, align 8
  store double %5, double* %cumulative_min, align 8
  store i32 0, i32* %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.end6
  %6 = load i32, i32* %i, align 4
  %7 = load i32, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
  %cmp7 = icmp ult i32 %6, %7
  br i1 %cmp7, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %8 = load double*, double** %ARRAY.addr, align 4
  %9 = load i32, i32* %i, align 4
  %arrayidx8 = getelementptr inbounds double, double* %8, i32 %9
  %10 = load double, double* %arrayidx8, align 8
  %11 = load double, double* %cumulative_min, align 8
  %cmp9 = fcmp olt double %10, %11
  br i1 %cmp9, label %if.then10, label %if.end12

if.then10:                                        ; preds = %for.body
  %12 = load double*, double** %ARRAY.addr, align 4
  %13 = load i32, i32* %i, align 4
  %arrayidx11 = getelementptr inbounds double, double* %12, i32 %13
  %14 = load double, double* %arrayidx11, align 8
  store double %14, double* %cumulative_min, align 8
  br label %if.end12

if.end12:                                         ; preds = %if.then10, %for.body
  %15 = load double, double* %cumulative_min, align 8
  %16 = load double*, double** %output, align 4
  %17 = load i32, i32* %i, align 4
  %arrayidx13 = getelementptr inbounds double, double* %16, i32 %17
  store double %15, double* %arrayidx13, align 8
  br label %for.inc

for.inc:                                          ; preds = %if.end12
  %18 = load i32, i32* %i, align 4
  %inc = add i32 %18, 1
  store i32 %inc, i32* %i, align 4
  br label %for.cond

for.end:                                          ; preds = %for.cond
  %19 = load double*, double** %output, align 4
  ret double* %19
}

declare i32 @puts(i8* %0) #1

; Function Attrs: noinline nounwind optnone
define hidden double* @cummax(double* noalias %ARRAY, i32 %NO_OF_ARRAY_ELEMENTS) #0 {
entry:
  %ARRAY.addr = alloca double*, align 4
  %NO_OF_ARRAY_ELEMENTS.addr = alloca i32, align 4
  %output = alloca double*, align 4
  %cumulative_max = alloca double, align 8
  %i = alloca i32, align 4
  store double* %ARRAY, double** %ARRAY.addr, align 4
  store i32 %NO_OF_ARRAY_ELEMENTS, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
  %0 = load i32, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
  %cmp = icmp ult i32 %0, 1
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %call = call i32 @puts(i8* getelementptr inbounds ([41 x i8], [41 x i8]* @.str.6, i32 0, i32 0))
  %call1 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([22 x i8], [22 x i8]* @.str.5, i32 0, i32 0), i8* getelementptr inbounds ([23 x i8], [23 x i8]* @.str.1, i32 0, i32 0), i32 129)
  call void @exit(i32 1) #5
  unreachable

if.end:                                           ; preds = %entry
  %1 = load i32, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
  %mul = mul i32 8, %1
  %call2 = call noalias i8* @malloc(i32 %mul)
  %2 = bitcast i8* %call2 to double*
  store double* %2, double** %output, align 4
  %3 = load double*, double** %output, align 4
  %cmp3 = icmp eq double* %3, null
  br i1 %cmp3, label %if.then4, label %if.end6

if.then4:                                         ; preds = %if.end
  %call5 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([33 x i8], [33 x i8]* @.str.3, i32 0, i32 0), i8* getelementptr inbounds ([23 x i8], [23 x i8]* @.str.1, i32 0, i32 0), i32 134)
  call void @perror(i8* getelementptr inbounds ([1 x i8], [1 x i8]* @.str.2, i32 0, i32 0))
  call void @exit(i32 1) #5
  unreachable

if.end6:                                          ; preds = %if.end
  %4 = load double*, double** %ARRAY.addr, align 4
  %arrayidx = getelementptr inbounds double, double* %4, i32 0
  %5 = load double, double* %arrayidx, align 8
  store double %5, double* %cumulative_max, align 8
  store i32 0, i32* %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.end6
  %6 = load i32, i32* %i, align 4
  %7 = load i32, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
  %cmp7 = icmp ult i32 %6, %7
  br i1 %cmp7, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %8 = load double*, double** %ARRAY.addr, align 4
  %9 = load i32, i32* %i, align 4
  %arrayidx8 = getelementptr inbounds double, double* %8, i32 %9
  %10 = load double, double* %arrayidx8, align 8
  %11 = load double, double* %cumulative_max, align 8
  %cmp9 = fcmp ogt double %10, %11
  br i1 %cmp9, label %if.then10, label %if.end12

if.then10:                                        ; preds = %for.body
  %12 = load double*, double** %ARRAY.addr, align 4
  %13 = load i32, i32* %i, align 4
  %arrayidx11 = getelementptr inbounds double, double* %12, i32 %13
  %14 = load double, double* %arrayidx11, align 8
  store double %14, double* %cumulative_max, align 8
  br label %if.end12

if.end12:                                         ; preds = %if.then10, %for.body
  %15 = load double, double* %cumulative_max, align 8
  %16 = load double*, double** %output, align 4
  %17 = load i32, i32* %i, align 4
  %arrayidx13 = getelementptr inbounds double, double* %16, i32 %17
  store double %15, double* %arrayidx13, align 8
  br label %for.inc

for.inc:                                          ; preds = %if.end12
  %18 = load i32, i32* %i, align 4
  %inc = add i32 %18, 1
  store i32 %inc, i32* %i, align 4
  br label %for.cond

for.end:                                          ; preds = %for.cond
  %19 = load double*, double** %output, align 4
  ret double* %19
}

; Function Attrs: noinline nounwind optnone
define hidden double* @pminx(double* noalias %ARRAY, i32 %NO_OF_ARRAY_ELEMENTS, double %X) #0 {
entry:
  %ARRAY.addr = alloca double*, align 4
  %NO_OF_ARRAY_ELEMENTS.addr = alloca i32, align 4
  %X.addr = alloca double, align 8
  %pmin_array = alloca double*, align 4
  %index = alloca i32, align 4
  store double* %ARRAY, double** %ARRAY.addr, align 4
  store i32 %NO_OF_ARRAY_ELEMENTS, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
  store double %X, double* %X.addr, align 8
  %0 = load i32, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
  %cmp = icmp ult i32 %0, 1
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %call = call i32 @puts(i8* getelementptr inbounds ([37 x i8], [37 x i8]* @.str.7, i32 0, i32 0))
  %call1 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([22 x i8], [22 x i8]* @.str.5, i32 0, i32 0), i8* getelementptr inbounds ([23 x i8], [23 x i8]* @.str.1, i32 0, i32 0), i32 152)
  call void @exit(i32 1) #5
  unreachable

if.end:                                           ; preds = %entry
  %1 = load i32, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
  %mul = mul i32 8, %1
  %call2 = call noalias i8* @malloc(i32 %mul)
  %2 = bitcast i8* %call2 to double*
  store double* %2, double** %pmin_array, align 4
  %3 = load double*, double** %pmin_array, align 4
  %cmp3 = icmp eq double* %3, null
  br i1 %cmp3, label %if.then4, label %if.end6

if.then4:                                         ; preds = %if.end
  %call5 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([33 x i8], [33 x i8]* @.str.3, i32 0, i32 0), i8* getelementptr inbounds ([23 x i8], [23 x i8]* @.str.1, i32 0, i32 0), i32 157)
  call void @perror(i8* getelementptr inbounds ([1 x i8], [1 x i8]* @.str.2, i32 0, i32 0))
  call void @exit(i32 1) #5
  unreachable

if.end6:                                          ; preds = %if.end
  store i32 0, i32* %index, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.end6
  %4 = load i32, i32* %index, align 4
  %5 = load i32, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
  %cmp7 = icmp ult i32 %4, %5
  br i1 %cmp7, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %6 = load double*, double** %ARRAY.addr, align 4
  %7 = load i32, i32* %index, align 4
  %arrayidx = getelementptr inbounds double, double* %6, i32 %7
  %8 = load double, double* %arrayidx, align 8
  %9 = load double, double* %X.addr, align 8
  %cmp8 = fcmp olt double %8, %9
  br i1 %cmp8, label %if.then9, label %if.else

if.then9:                                         ; preds = %for.body
  %10 = load double*, double** %ARRAY.addr, align 4
  %11 = load i32, i32* %index, align 4
  %arrayidx10 = getelementptr inbounds double, double* %10, i32 %11
  %12 = load double, double* %arrayidx10, align 8
  %13 = load double*, double** %pmin_array, align 4
  %14 = load i32, i32* %index, align 4
  %arrayidx11 = getelementptr inbounds double, double* %13, i32 %14
  store double %12, double* %arrayidx11, align 8
  br label %if.end13

if.else:                                          ; preds = %for.body
  %15 = load double, double* %X.addr, align 8
  %16 = load double*, double** %pmin_array, align 4
  %17 = load i32, i32* %index, align 4
  %arrayidx12 = getelementptr inbounds double, double* %16, i32 %17
  store double %15, double* %arrayidx12, align 8
  br label %if.end13

if.end13:                                         ; preds = %if.else, %if.then9
  br label %for.inc

for.inc:                                          ; preds = %if.end13
  %18 = load i32, i32* %index, align 4
  %inc = add i32 %18, 1
  store i32 %inc, i32* %index, align 4
  br label %for.cond

for.end:                                          ; preds = %for.cond
  %19 = load double*, double** %pmin_array, align 4
  ret double* %19
}

; Function Attrs: noinline nounwind optnone
define hidden void @double_say(double* noalias %ARRAY, i32 %NO_OF_ARRAY_ELEMENTS) #0 {
entry:
  %ARRAY.addr = alloca double*, align 4
  %NO_OF_ARRAY_ELEMENTS.addr = alloca i32, align 4
  %i = alloca i32, align 4
  store double* %ARRAY, double** %ARRAY.addr, align 4
  store i32 %NO_OF_ARRAY_ELEMENTS, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
  %0 = load double*, double** %ARRAY.addr, align 4
  %arrayidx = getelementptr inbounds double, double* %0, i32 0
  %1 = load double, double* %arrayidx, align 8
  %call = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([7 x i8], [7 x i8]* @.str.8, i32 0, i32 0), double %1)
  store i32 1, i32* %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %2 = load i32, i32* %i, align 4
  %3 = load i32, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
  %cmp = icmp ult i32 %2, %3
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %4 = load double*, double** %ARRAY.addr, align 4
  %5 = load i32, i32* %i, align 4
  %arrayidx1 = getelementptr inbounds double, double* %4, i32 %5
  %6 = load double, double* %arrayidx1, align 8
  %call2 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([7 x i8], [7 x i8]* @.str.9, i32 0, i32 0), double %6)
  %7 = load i32, i32* %i, align 4
  %add = add i32 %7, 1
  %rem = urem i32 %add, 5
  %cmp3 = icmp eq i32 %rem, 0
  br i1 %cmp3, label %if.then, label %if.end

if.then:                                          ; preds = %for.body
  %8 = load i32, i32* %i, align 4
  %add4 = add i32 %8, 1
  %call5 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([6 x i8], [6 x i8]* @.str.10, i32 0, i32 0), i32 %add4)
  br label %if.end

if.end:                                           ; preds = %if.then, %for.body
  br label %for.inc

for.inc:                                          ; preds = %if.end
  %9 = load i32, i32* %i, align 4
  %inc = add i32 %9, 1
  store i32 %inc, i32* %i, align 4
  br label %for.cond

for.end:                                          ; preds = %for.cond
  %call6 = call i32 @puts(i8* getelementptr inbounds ([2 x i8], [2 x i8]* @.str.11, i32 0, i32 0))
  ret void
}

; Function Attrs: noinline nounwind optnone
define hidden double* @uint2double(i32* noalias %ARRAY, i32 %NO_OF_ARRAY_ELEMENTS) #0 {
entry:
  %ARRAY.addr = alloca i32*, align 4
  %NO_OF_ARRAY_ELEMENTS.addr = alloca i32, align 4
  %doubleArray = alloca double*, align 4
  %index = alloca i32, align 4
  store i32* %ARRAY, i32** %ARRAY.addr, align 4
  store i32 %NO_OF_ARRAY_ELEMENTS, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
  %0 = load i32, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
  %mul = mul i32 8, %0
  %call = call noalias i8* @malloc(i32 %mul)
  %1 = bitcast i8* %call to double*
  store double* %1, double** %doubleArray, align 4
  %2 = load double*, double** %doubleArray, align 4
  %cmp = icmp eq double* %2, null
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %call1 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([34 x i8], [34 x i8]* @.str.12, i32 0, i32 0), i8* getelementptr inbounds ([23 x i8], [23 x i8]* @.str.1, i32 0, i32 0), i32 194)
  call void @perror(i8* getelementptr inbounds ([1 x i8], [1 x i8]* @.str.2, i32 0, i32 0))
  call void @exit(i32 1) #5
  unreachable

if.end:                                           ; preds = %entry
  store i32 0, i32* %index, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.end
  %3 = load i32, i32* %index, align 4
  %4 = load i32, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
  %cmp2 = icmp ult i32 %3, %4
  br i1 %cmp2, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %5 = load i32*, i32** %ARRAY.addr, align 4
  %6 = load i32, i32* %index, align 4
  %arrayidx = getelementptr inbounds i32, i32* %5, i32 %6
  %7 = load i32, i32* %arrayidx, align 4
  %conv = uitofp i32 %7 to double
  %8 = load double*, double** %doubleArray, align 4
  %9 = load i32, i32* %index, align 4
  %arrayidx3 = getelementptr inbounds double, double* %8, i32 %9
  store double %conv, double* %arrayidx3, align 8
  br label %for.inc

for.inc:                                          ; preds = %for.body
  %10 = load i32, i32* %index, align 4
  %inc = add i32 %10, 1
  store i32 %inc, i32* %index, align 4
  br label %for.cond

for.end:                                          ; preds = %for.cond
  %11 = load double*, double** %doubleArray, align 4
  ret double* %11
}

; Function Attrs: noinline nounwind optnone
define hidden double @min2(double %N1, double %N2) #0 {
entry:
  %retval = alloca double, align 8
  %N1.addr = alloca double, align 8
  %N2.addr = alloca double, align 8
  store double %N1, double* %N1.addr, align 8
  store double %N2, double* %N2.addr, align 8
  %0 = load double, double* %N1.addr, align 8
  %1 = load double, double* %N2.addr, align 8
  %cmp = fcmp olt double %0, %1
  br i1 %cmp, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  %2 = load double, double* %N1.addr, align 8
  store double %2, double* %retval, align 8
  br label %return

if.else:                                          ; preds = %entry
  %3 = load double, double* %N2.addr, align 8
  store double %3, double* %retval, align 8
  br label %return

return:                                           ; preds = %if.else, %if.then
  %4 = load double, double* %retval, align 8
  ret double %4
}

; Function Attrs: noinline nounwind optnone
define hidden double* @p_adjust(double* noalias %PVALUES, i32 %NO_OF_ARRAY_ELEMENTS, i8* noalias %STRING) #0 {
entry:
  %retval = alloca double*, align 4
  %PVALUES.addr = alloca double*, align 4
  %NO_OF_ARRAY_ELEMENTS.addr = alloca i32, align 4
  %STRING.addr = alloca i8*, align 4
  %TYPE = alloca i16, align 2
  %bonferroni = alloca double*, align 4
  %index = alloca i32, align 4
  %BONFERRONI = alloca double, align 8
  %o = alloca i32*, align 4
  %o2double = alloca double*, align 4
  %cummax_input = alloca double*, align 4
  %index80 = alloca i32, align 4
  %ro = alloca i32*, align 4
  %cummax_output = alloca double*, align 4
  %pmin = alloca double*, align 4
  %qvalues = alloca double*, align 4
  %index98 = alloca i32, align 4
  %o114 = alloca i32*, align 4
  %p = alloca double*, align 4
  %index123 = alloca i32, align 4
  %o2double134 = alloca double*, align 4
  %ro136 = alloca i32*, align 4
  %q = alloca double*, align 4
  %pa = alloca double*, align 4
  %min = alloca double, align 8
  %index155 = alloca i32, align 4
  %TEMP = alloca double, align 8
  %index171 = alloca i32, align 4
  %j = alloca i32, align 4
  %ij = alloca i32*, align 4
  %I2_LENGTH = alloca i32, align 4
  %i2 = alloca i32*, align 4
  %i = alloca i32, align 4
  %q1 = alloca double, align 8
  %i208 = alloca i32, align 4
  %TEMP_Q1 = alloca double, align 8
  %i227 = alloca i32, align 4
  %i244 = alloca i32, align 4
  %i256 = alloca i32, align 4
  %index274 = alloca i32, align 4
  %o288 = alloca i32*, align 4
  %o_double = alloca double*, align 4
  %index296 = alloca i32, align 4
  %ro315 = alloca i32*, align 4
  %cummin_input = alloca double*, align 4
  %index328 = alloca i32, align 4
  %NI = alloca double, align 8
  %q349 = alloca double, align 8
  %index350 = alloca i32, align 4
  %index362 = alloca i32, align 4
  %NI367 = alloca double, align 8
  %index385 = alloca i32, align 4
  %cummin_array = alloca double*, align 4
  %pmin403 = alloca double*, align 4
  %q_array = alloca double*, align 4
  %index407 = alloca i32, align 4
  store double* %PVALUES, double** %PVALUES.addr, align 4
  store i32 %NO_OF_ARRAY_ELEMENTS, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
  store i8* %STRING, i8** %STRING.addr, align 4
  %0 = load i32, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
  %cmp = icmp ult i32 %0, 1
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %call = call i32 @puts(i8* getelementptr inbounds ([41 x i8], [41 x i8]* @.str.13, i32 0, i32 0))
  %call1 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([22 x i8], [22 x i8]* @.str.5, i32 0, i32 0), i8* getelementptr inbounds ([23 x i8], [23 x i8]* @.str.1, i32 0, i32 0), i32 217)
  call void @exit(i32 1) #5
  unreachable

if.end:                                           ; preds = %entry
  store i16 -1, i16* %TYPE, align 2
  %1 = load i8*, i8** %STRING.addr, align 4
  %cmp2 = icmp eq i8* %1, null
  br i1 %cmp2, label %if.then3, label %if.else

if.then3:                                         ; preds = %if.end
  store i16 0, i16* %TYPE, align 2
  br label %if.end41

if.else:                                          ; preds = %if.end
  %2 = load i8*, i8** %STRING.addr, align 4
  %call4 = call i32 @strcasecmp(i8* %2, i8* getelementptr inbounds ([3 x i8], [3 x i8]* @.str.14, i32 0, i32 0))
  %cmp5 = icmp eq i32 %call4, 0
  br i1 %cmp5, label %if.then6, label %if.else7

if.then6:                                         ; preds = %if.else
  store i16 0, i16* %TYPE, align 2
  br label %if.end40

if.else7:                                         ; preds = %if.else
  %3 = load i8*, i8** %STRING.addr, align 4
  %call8 = call i32 @strcasecmp(i8* %3, i8* getelementptr inbounds ([4 x i8], [4 x i8]* @.str.15, i32 0, i32 0))
  %cmp9 = icmp eq i32 %call8, 0
  br i1 %cmp9, label %if.then10, label %if.else11

if.then10:                                        ; preds = %if.else7
  store i16 0, i16* %TYPE, align 2
  br label %if.end39

if.else11:                                        ; preds = %if.else7
  %4 = load i8*, i8** %STRING.addr, align 4
  %call12 = call i32 @strcasecmp(i8* %4, i8* getelementptr inbounds ([3 x i8], [3 x i8]* @.str.16, i32 0, i32 0))
  %cmp13 = icmp eq i32 %call12, 0
  br i1 %cmp13, label %if.then14, label %if.else15

if.then14:                                        ; preds = %if.else11
  store i16 1, i16* %TYPE, align 2
  br label %if.end38

if.else15:                                        ; preds = %if.else11
  %5 = load i8*, i8** %STRING.addr, align 4
  %call16 = call i32 @strcasecmp(i8* %5, i8* getelementptr inbounds ([11 x i8], [11 x i8]* @.str.17, i32 0, i32 0))
  %cmp17 = icmp eq i32 %call16, 0
  br i1 %cmp17, label %if.then18, label %if.else19

if.then18:                                        ; preds = %if.else15
  store i16 2, i16* %TYPE, align 2
  br label %if.end37

if.else19:                                        ; preds = %if.else15
  %6 = load i8*, i8** %STRING.addr, align 4
  %call20 = call i32 @strcasecmp(i8* %6, i8* getelementptr inbounds ([9 x i8], [9 x i8]* @.str.18, i32 0, i32 0))
  %cmp21 = icmp eq i32 %call20, 0
  br i1 %cmp21, label %if.then22, label %if.else23

if.then22:                                        ; preds = %if.else19
  store i16 3, i16* %TYPE, align 2
  br label %if.end36

if.else23:                                        ; preds = %if.else19
  %7 = load i8*, i8** %STRING.addr, align 4
  %call24 = call i32 @strcasecmp(i8* %7, i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.19, i32 0, i32 0))
  %cmp25 = icmp eq i32 %call24, 0
  br i1 %cmp25, label %if.then26, label %if.else27

if.then26:                                        ; preds = %if.else23
  store i16 4, i16* %TYPE, align 2
  br label %if.end35

if.else27:                                        ; preds = %if.else23
  %8 = load i8*, i8** %STRING.addr, align 4
  %call28 = call i32 @strcasecmp(i8* %8, i8* getelementptr inbounds ([7 x i8], [7 x i8]* @.str.20, i32 0, i32 0))
  %cmp29 = icmp eq i32 %call28, 0
  br i1 %cmp29, label %if.then30, label %if.else31

if.then30:                                        ; preds = %if.else27
  store i16 5, i16* %TYPE, align 2
  br label %if.end34

if.else31:                                        ; preds = %if.else27
  %9 = load i8*, i8** %STRING.addr, align 4
  %call32 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([44 x i8], [44 x i8]* @.str.21, i32 0, i32 0), i8* %9)
  %call33 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([22 x i8], [22 x i8]* @.str.5, i32 0, i32 0), i8* getelementptr inbounds ([23 x i8], [23 x i8]* @.str.1, i32 0, i32 0), i32 239)
  call void @exit(i32 1) #5
  unreachable

if.end34:                                         ; preds = %if.then30
  br label %if.end35

if.end35:                                         ; preds = %if.end34, %if.then26
  br label %if.end36

if.end36:                                         ; preds = %if.end35, %if.then22
  br label %if.end37

if.end37:                                         ; preds = %if.end36, %if.then18
  br label %if.end38

if.end38:                                         ; preds = %if.end37, %if.then14
  br label %if.end39

if.end39:                                         ; preds = %if.end38, %if.then10
  br label %if.end40

if.end40:                                         ; preds = %if.end39, %if.then6
  br label %if.end41

if.end41:                                         ; preds = %if.end40, %if.then3
  %10 = load i16, i16* %TYPE, align 2
  %conv = sext i16 %10 to i32
  %cmp42 = icmp eq i32 %conv, 2
  br i1 %cmp42, label %if.then44, label %if.else71

if.then44:                                        ; preds = %if.end41
  %11 = load i32, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
  %mul = mul i32 8, %11
  %call45 = call noalias i8* @malloc(i32 %mul)
  %12 = bitcast i8* %call45 to double*
  store double* %12, double** %bonferroni, align 4
  %13 = load double*, double** %bonferroni, align 4
  %cmp46 = icmp eq double* %13, null
  br i1 %cmp46, label %if.then48, label %if.end50

if.then48:                                        ; preds = %if.then44
  %call49 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([33 x i8], [33 x i8]* @.str.3, i32 0, i32 0), i8* getelementptr inbounds ([23 x i8], [23 x i8]* @.str.1, i32 0, i32 0), i32 247)
  call void @perror(i8* getelementptr inbounds ([1 x i8], [1 x i8]* @.str.2, i32 0, i32 0))
  call void @exit(i32 1) #5
  unreachable

if.end50:                                         ; preds = %if.then44
  store i32 0, i32* %index, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.end50
  %14 = load i32, i32* %index, align 4
  %15 = load i32, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
  %cmp51 = icmp ult i32 %14, %15
  br i1 %cmp51, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %16 = load double*, double** %PVALUES.addr, align 4
  %17 = load i32, i32* %index, align 4
  %arrayidx = getelementptr inbounds double, double* %16, i32 %17
  %18 = load double, double* %arrayidx, align 8
  %19 = load i32, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
  %conv53 = uitofp i32 %19 to double
  %mul54 = fmul double %18, %conv53
  store double %mul54, double* %BONFERRONI, align 8
  %20 = load double, double* %BONFERRONI, align 8
  %cmp55 = fcmp oge double %20, 1.000000e+00
  br i1 %cmp55, label %if.then57, label %if.else59

if.then57:                                        ; preds = %for.body
  %21 = load double*, double** %bonferroni, align 4
  %22 = load i32, i32* %index, align 4
  %arrayidx58 = getelementptr inbounds double, double* %21, i32 %22
  store double 1.000000e+00, double* %arrayidx58, align 8
  br label %if.end70

if.else59:                                        ; preds = %for.body
  %23 = load double, double* %BONFERRONI, align 8
  %cmp60 = fcmp ole double 0.000000e+00, %23
  br i1 %cmp60, label %land.lhs.true, label %if.else66

land.lhs.true:                                    ; preds = %if.else59
  %24 = load double, double* %BONFERRONI, align 8
  %cmp62 = fcmp olt double %24, 1.000000e+00
  br i1 %cmp62, label %if.then64, label %if.else66

if.then64:                                        ; preds = %land.lhs.true
  %25 = load double, double* %BONFERRONI, align 8
  %26 = load double*, double** %bonferroni, align 4
  %27 = load i32, i32* %index, align 4
  %arrayidx65 = getelementptr inbounds double, double* %26, i32 %27
  store double %25, double* %arrayidx65, align 8
  br label %if.end69

if.else66:                                        ; preds = %land.lhs.true, %if.else59
  %28 = load double, double* %BONFERRONI, align 8
  %call67 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([42 x i8], [42 x i8]* @.str.22, i32 0, i32 0), double %28)
  %call68 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([23 x i8], [23 x i8]* @.str.23, i32 0, i32 0), i8* getelementptr inbounds ([23 x i8], [23 x i8]* @.str.1, i32 0, i32 0), i32 259)
  call void @exit(i32 1) #5
  unreachable

if.end69:                                         ; preds = %if.then64
  br label %if.end70

if.end70:                                         ; preds = %if.end69, %if.then57
  br label %for.inc

for.inc:                                          ; preds = %if.end70
  %29 = load i32, i32* %index, align 4
  %inc = add i32 %29, 1
  store i32 %inc, i32* %index, align 4
  br label %for.cond

for.end:                                          ; preds = %for.cond
  %30 = load double*, double** %bonferroni, align 4
  store double* %30, double** %retval, align 4
  br label %return

if.else71:                                        ; preds = %if.end41
  %31 = load i16, i16* %TYPE, align 2
  %conv72 = sext i16 %31 to i32
  %cmp73 = icmp eq i32 %conv72, 4
  br i1 %cmp73, label %if.then75, label %if.else109

if.then75:                                        ; preds = %if.else71
  %32 = load double*, double** %PVALUES.addr, align 4
  %33 = load i32, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
  %call76 = call i32* @order(double* %32, i32 %33, i1 zeroext false)
  store i32* %call76, i32** %o, align 4
  %34 = load i32*, i32** %o, align 4
  %35 = load i32, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
  %call77 = call double* @uint2double(i32* %34, i32 %35)
  store double* %call77, double** %o2double, align 4
  %36 = load i32, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
  %mul78 = mul i32 8, %36
  %call79 = call noalias i8* @malloc(i32 %mul78)
  %37 = bitcast i8* %call79 to double*
  store double* %37, double** %cummax_input, align 4
  store i32 0, i32* %index80, align 4
  br label %for.cond81

for.cond81:                                       ; preds = %for.inc90, %if.then75
  %38 = load i32, i32* %index80, align 4
  %39 = load i32, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
  %cmp82 = icmp ult i32 %38, %39
  br i1 %cmp82, label %for.body84, label %for.end92

for.body84:                                       ; preds = %for.cond81
  %40 = load i32, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
  %41 = load i32, i32* %index80, align 4
  %sub = sub i32 %40, %41
  %conv85 = uitofp i32 %sub to double
  %42 = load double*, double** %PVALUES.addr, align 4
  %43 = load i32*, i32** %o, align 4
  %44 = load i32, i32* %index80, align 4
  %arrayidx86 = getelementptr inbounds i32, i32* %43, i32 %44
  %45 = load i32, i32* %arrayidx86, align 4
  %arrayidx87 = getelementptr inbounds double, double* %42, i32 %45
  %46 = load double, double* %arrayidx87, align 8
  %mul88 = fmul double %conv85, %46
  %47 = load double*, double** %cummax_input, align 4
  %48 = load i32, i32* %index80, align 4
  %arrayidx89 = getelementptr inbounds double, double* %47, i32 %48
  store double %mul88, double* %arrayidx89, align 8
  br label %for.inc90

for.inc90:                                        ; preds = %for.body84
  %49 = load i32, i32* %index80, align 4
  %inc91 = add i32 %49, 1
  store i32 %inc91, i32* %index80, align 4
  br label %for.cond81

for.end92:                                        ; preds = %for.cond81
  %50 = load i32*, i32** %o, align 4
  %51 = bitcast i32* %50 to i8*
  call void @free(i8* %51)
  store i32* null, i32** %o, align 4
  %52 = load double*, double** %o2double, align 4
  %53 = load i32, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
  %call93 = call i32* @order(double* %52, i32 %53, i1 zeroext false)
  store i32* %call93, i32** %ro, align 4
  %54 = load double*, double** %o2double, align 4
  %55 = bitcast double* %54 to i8*
  call void @free(i8* %55)
  store double* null, double** %o2double, align 4
  %56 = load double*, double** %cummax_input, align 4
  %57 = load i32, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
  %call94 = call double* @cummax(double* %56, i32 %57)
  store double* %call94, double** %cummax_output, align 4
  %58 = load double*, double** %cummax_input, align 4
  %59 = bitcast double* %58 to i8*
  call void @free(i8* %59)
  store double* null, double** %cummax_input, align 4
  %60 = load double*, double** %cummax_output, align 4
  %61 = load i32, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
  %call95 = call double* @pminx(double* %60, i32 %61, double 1.000000e+00)
  store double* %call95, double** %pmin, align 4
  %62 = load double*, double** %cummax_output, align 4
  %63 = bitcast double* %62 to i8*
  call void @free(i8* %63)
  store double* null, double** %cummax_output, align 4
  %64 = load i32, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
  %mul96 = mul i32 8, %64
  %call97 = call noalias i8* @malloc(i32 %mul96)
  %65 = bitcast i8* %call97 to double*
  store double* %65, double** %qvalues, align 4
  store i32 0, i32* %index98, align 4
  br label %for.cond99

for.cond99:                                       ; preds = %for.inc106, %for.end92
  %66 = load i32, i32* %index98, align 4
  %67 = load i32, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
  %cmp100 = icmp ult i32 %66, %67
  br i1 %cmp100, label %for.body102, label %for.end108

for.body102:                                      ; preds = %for.cond99
  %68 = load double*, double** %pmin, align 4
  %69 = load i32*, i32** %ro, align 4
  %70 = load i32, i32* %index98, align 4
  %arrayidx103 = getelementptr inbounds i32, i32* %69, i32 %70
  %71 = load i32, i32* %arrayidx103, align 4
  %arrayidx104 = getelementptr inbounds double, double* %68, i32 %71
  %72 = load double, double* %arrayidx104, align 8
  %73 = load double*, double** %qvalues, align 4
  %74 = load i32, i32* %index98, align 4
  %arrayidx105 = getelementptr inbounds double, double* %73, i32 %74
  store double %72, double* %arrayidx105, align 8
  br label %for.inc106

for.inc106:                                       ; preds = %for.body102
  %75 = load i32, i32* %index98, align 4
  %inc107 = add i32 %75, 1
  store i32 %inc107, i32* %index98, align 4
  br label %for.cond99

for.end108:                                       ; preds = %for.cond99
  %76 = load double*, double** %pmin, align 4
  %77 = bitcast double* %76 to i8*
  call void @free(i8* %77)
  store double* null, double** %pmin, align 4
  %78 = load i32*, i32** %ro, align 4
  %79 = bitcast i32* %78 to i8*
  call void @free(i8* %79)
  store i32* null, i32** %ro, align 4
  %80 = load double*, double** %qvalues, align 4
  store double* %80, double** %retval, align 4
  br label %return

if.else109:                                       ; preds = %if.else71
  %81 = load i16, i16* %TYPE, align 2
  %conv110 = sext i16 %81 to i32
  %cmp111 = icmp eq i32 %conv110, 5
  br i1 %cmp111, label %if.then113, label %if.end285

if.then113:                                       ; preds = %if.else109
  %82 = load double*, double** %PVALUES.addr, align 4
  %83 = load i32, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
  %call115 = call i32* @order(double* %82, i32 %83, i1 zeroext false)
  store i32* %call115, i32** %o114, align 4
  %84 = load i32, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
  %mul116 = mul i32 8, %84
  %call117 = call noalias i8* @malloc(i32 %mul116)
  %85 = bitcast i8* %call117 to double*
  store double* %85, double** %p, align 4
  %86 = load double*, double** %p, align 4
  %cmp118 = icmp eq double* %86, null
  br i1 %cmp118, label %if.then120, label %if.end122

if.then120:                                       ; preds = %if.then113
  %call121 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([33 x i8], [33 x i8]* @.str.3, i32 0, i32 0), i8* getelementptr inbounds ([23 x i8], [23 x i8]* @.str.1, i32 0, i32 0), i32 302)
  call void @perror(i8* getelementptr inbounds ([1 x i8], [1 x i8]* @.str.2, i32 0, i32 0))
  call void @exit(i32 1) #5
  unreachable

if.end122:                                        ; preds = %if.then113
  store i32 0, i32* %index123, align 4
  br label %for.cond124

for.cond124:                                      ; preds = %for.inc131, %if.end122
  %87 = load i32, i32* %index123, align 4
  %88 = load i32, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
  %cmp125 = icmp ult i32 %87, %88
  br i1 %cmp125, label %for.body127, label %for.end133

for.body127:                                      ; preds = %for.cond124
  %89 = load double*, double** %PVALUES.addr, align 4
  %90 = load i32*, i32** %o114, align 4
  %91 = load i32, i32* %index123, align 4
  %arrayidx128 = getelementptr inbounds i32, i32* %90, i32 %91
  %92 = load i32, i32* %arrayidx128, align 4
  %arrayidx129 = getelementptr inbounds double, double* %89, i32 %92
  %93 = load double, double* %arrayidx129, align 8
  %94 = load double*, double** %p, align 4
  %95 = load i32, i32* %index123, align 4
  %arrayidx130 = getelementptr inbounds double, double* %94, i32 %95
  store double %93, double* %arrayidx130, align 8
  br label %for.inc131

for.inc131:                                       ; preds = %for.body127
  %96 = load i32, i32* %index123, align 4
  %inc132 = add i32 %96, 1
  store i32 %inc132, i32* %index123, align 4
  br label %for.cond124

for.end133:                                       ; preds = %for.cond124
  %97 = load i32*, i32** %o114, align 4
  %98 = load i32, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
  %call135 = call double* @uint2double(i32* %97, i32 %98)
  store double* %call135, double** %o2double134, align 4
  %99 = load i32*, i32** %o114, align 4
  %100 = bitcast i32* %99 to i8*
  call void @free(i8* %100)
  store i32* null, i32** %o114, align 4
  %101 = load double*, double** %o2double134, align 4
  %102 = load i32, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
  %call137 = call i32* @order(double* %101, i32 %102, i1 zeroext false)
  store i32* %call137, i32** %ro136, align 4
  %103 = load double*, double** %o2double134, align 4
  %104 = bitcast double* %103 to i8*
  call void @free(i8* %104)
  store double* null, double** %o2double134, align 4
  %105 = load i32, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
  %mul138 = mul i32 8, %105
  %call139 = call noalias i8* @malloc(i32 %mul138)
  %106 = bitcast i8* %call139 to double*
  store double* %106, double** %q, align 4
  %107 = load double*, double** %q, align 4
  %cmp140 = icmp eq double* %107, null
  br i1 %cmp140, label %if.then142, label %if.end144

if.then142:                                       ; preds = %for.end133
  %call143 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([33 x i8], [33 x i8]* @.str.3, i32 0, i32 0), i8* getelementptr inbounds ([23 x i8], [23 x i8]* @.str.1, i32 0, i32 0), i32 318)
  call void @perror(i8* getelementptr inbounds ([1 x i8], [1 x i8]* @.str.2, i32 0, i32 0))
  call void @exit(i32 1) #5
  unreachable

if.end144:                                        ; preds = %for.end133
  %108 = load i32, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
  %mul145 = mul i32 8, %108
  %call146 = call noalias i8* @malloc(i32 %mul145)
  %109 = bitcast i8* %call146 to double*
  store double* %109, double** %pa, align 4
  %110 = load double*, double** %pa, align 4
  %cmp147 = icmp eq double* %110, null
  br i1 %cmp147, label %if.then149, label %if.end151

if.then149:                                       ; preds = %if.end144
  %call150 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([33 x i8], [33 x i8]* @.str.3, i32 0, i32 0), i8* getelementptr inbounds ([23 x i8], [23 x i8]* @.str.1, i32 0, i32 0), i32 324)
  call void @perror(i8* getelementptr inbounds ([1 x i8], [1 x i8]* @.str.2, i32 0, i32 0))
  call void @exit(i32 1) #5
  unreachable

if.end151:                                        ; preds = %if.end144
  %111 = load i32, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
  %conv152 = uitofp i32 %111 to double
  %112 = load double*, double** %p, align 4
  %arrayidx153 = getelementptr inbounds double, double* %112, i32 0
  %113 = load double, double* %arrayidx153, align 8
  %mul154 = fmul double %conv152, %113
  store double %mul154, double* %min, align 8
  store i32 1, i32* %index155, align 4
  br label %for.cond156

for.cond156:                                      ; preds = %for.inc168, %if.end151
  %114 = load i32, i32* %index155, align 4
  %115 = load i32, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
  %cmp157 = icmp ult i32 %114, %115
  br i1 %cmp157, label %for.body159, label %for.end170

for.body159:                                      ; preds = %for.cond156
  %116 = load i32, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
  %conv160 = uitofp i32 %116 to double
  %117 = load double*, double** %p, align 4
  %118 = load i32, i32* %index155, align 4
  %arrayidx161 = getelementptr inbounds double, double* %117, i32 %118
  %119 = load double, double* %arrayidx161, align 8
  %mul162 = fmul double %conv160, %119
  %120 = load i32, i32* %index155, align 4
  %add = add i32 1, %120
  %conv163 = uitofp i32 %add to double
  %div = fdiv double %mul162, %conv163
  store double %div, double* %TEMP, align 8
  %121 = load double, double* %TEMP, align 8
  %122 = load double, double* %min, align 8
  %cmp164 = fcmp olt double %121, %122
  br i1 %cmp164, label %if.then166, label %if.end167

if.then166:                                       ; preds = %for.body159
  %123 = load double, double* %TEMP, align 8
  store double %123, double* %min, align 8
  br label %if.end167

if.end167:                                        ; preds = %if.then166, %for.body159
  br label %for.inc168

for.inc168:                                       ; preds = %if.end167
  %124 = load i32, i32* %index155, align 4
  %inc169 = add i32 %124, 1
  store i32 %inc169, i32* %index155, align 4
  br label %for.cond156

for.end170:                                       ; preds = %for.cond156
  store i32 0, i32* %index171, align 4
  br label %for.cond172

for.cond172:                                      ; preds = %for.inc178, %for.end170
  %125 = load i32, i32* %index171, align 4
  %126 = load i32, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
  %cmp173 = icmp ult i32 %125, %126
  br i1 %cmp173, label %for.body175, label %for.end180

for.body175:                                      ; preds = %for.cond172
  %127 = load double, double* %min, align 8
  %128 = load double*, double** %pa, align 4
  %129 = load i32, i32* %index171, align 4
  %arrayidx176 = getelementptr inbounds double, double* %128, i32 %129
  store double %127, double* %arrayidx176, align 8
  %130 = load double, double* %min, align 8
  %131 = load double*, double** %q, align 4
  %132 = load i32, i32* %index171, align 4
  %arrayidx177 = getelementptr inbounds double, double* %131, i32 %132
  store double %130, double* %arrayidx177, align 8
  br label %for.inc178

for.inc178:                                       ; preds = %for.body175
  %133 = load i32, i32* %index171, align 4
  %inc179 = add i32 %133, 1
  store i32 %inc179, i32* %index171, align 4
  br label %for.cond172

for.end180:                                       ; preds = %for.cond172
  %134 = load i32, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
  %sub181 = sub i32 %134, 1
  store i32 %sub181, i32* %j, align 4
  br label %for.cond182

for.cond182:                                      ; preds = %for.inc272, %for.end180
  %135 = load i32, i32* %j, align 4
  %cmp183 = icmp uge i32 %135, 2
  br i1 %cmp183, label %for.body185, label %for.end273

for.body185:                                      ; preds = %for.cond182
  %136 = load i32, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
  %137 = load i32, i32* %j, align 4
  %sub186 = sub i32 %136, %137
  %call187 = call i32* @seq_len(i32 0, i32 %sub186)
  store i32* %call187, i32** %ij, align 4
  %138 = load i32, i32* %j, align 4
  %sub188 = sub i32 %138, 1
  store i32 %sub188, i32* %I2_LENGTH, align 4
  %139 = load i32, i32* %I2_LENGTH, align 4
  %mul189 = mul i32 %139, 4
  %call190 = call noalias i8* @malloc(i32 %mul189)
  %140 = bitcast i8* %call190 to i32*
  store i32* %140, i32** %i2, align 4
  store i32 0, i32* %i, align 4
  br label %for.cond191

for.cond191:                                      ; preds = %for.inc200, %for.body185
  %141 = load i32, i32* %i, align 4
  %142 = load i32, i32* %I2_LENGTH, align 4
  %cmp192 = icmp ult i32 %141, %142
  br i1 %cmp192, label %for.body194, label %for.end202

for.body194:                                      ; preds = %for.cond191
  %143 = load i32, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
  %144 = load i32, i32* %j, align 4
  %sub195 = sub i32 %143, %144
  %add196 = add i32 %sub195, 2
  %145 = load i32, i32* %i, align 4
  %add197 = add i32 %add196, %145
  %sub198 = sub i32 %add197, 1
  %146 = load i32*, i32** %i2, align 4
  %147 = load i32, i32* %i, align 4
  %arrayidx199 = getelementptr inbounds i32, i32* %146, i32 %147
  store i32 %sub198, i32* %arrayidx199, align 4
  br label %for.inc200

for.inc200:                                       ; preds = %for.body194
  %148 = load i32, i32* %i, align 4
  %inc201 = add i32 %148, 1
  store i32 %inc201, i32* %i, align 4
  br label %for.cond191

for.end202:                                       ; preds = %for.cond191
  %149 = load i32, i32* %j, align 4
  %conv203 = uitofp i32 %149 to double
  %150 = load double*, double** %p, align 4
  %151 = load i32*, i32** %i2, align 4
  %arrayidx204 = getelementptr inbounds i32, i32* %151, i32 0
  %152 = load i32, i32* %arrayidx204, align 4
  %arrayidx205 = getelementptr inbounds double, double* %150, i32 %152
  %153 = load double, double* %arrayidx205, align 8
  %mul206 = fmul double %conv203, %153
  %div207 = fdiv double %mul206, 2.000000e+00
  store double %div207, double* %q1, align 8
  store i32 1, i32* %i208, align 4
  br label %for.cond209

for.cond209:                                      ; preds = %for.inc224, %for.end202
  %154 = load i32, i32* %i208, align 4
  %155 = load i32, i32* %I2_LENGTH, align 4
  %cmp210 = icmp ult i32 %154, %155
  br i1 %cmp210, label %for.body212, label %for.end226

for.body212:                                      ; preds = %for.cond209
  %156 = load i32, i32* %j, align 4
  %conv213 = uitofp i32 %156 to double
  %157 = load double*, double** %p, align 4
  %158 = load i32*, i32** %i2, align 4
  %159 = load i32, i32* %i208, align 4
  %arrayidx214 = getelementptr inbounds i32, i32* %158, i32 %159
  %160 = load i32, i32* %arrayidx214, align 4
  %arrayidx215 = getelementptr inbounds double, double* %157, i32 %160
  %161 = load double, double* %arrayidx215, align 8
  %mul216 = fmul double %conv213, %161
  %162 = load i32, i32* %i208, align 4
  %add217 = add i32 2, %162
  %conv218 = uitofp i32 %add217 to double
  %div219 = fdiv double %mul216, %conv218
  store double %div219, double* %TEMP_Q1, align 8
  %163 = load double, double* %TEMP_Q1, align 8
  %164 = load double, double* %q1, align 8
  %cmp220 = fcmp olt double %163, %164
  br i1 %cmp220, label %if.then222, label %if.end223

if.then222:                                       ; preds = %for.body212
  %165 = load double, double* %TEMP_Q1, align 8
  store double %165, double* %q1, align 8
  br label %if.end223

if.end223:                                        ; preds = %if.then222, %for.body212
  br label %for.inc224

for.inc224:                                       ; preds = %if.end223
  %166 = load i32, i32* %i208, align 4
  %inc225 = add i32 %166, 1
  store i32 %inc225, i32* %i208, align 4
  br label %for.cond209

for.end226:                                       ; preds = %for.cond209
  store i32 0, i32* %i227, align 4
  br label %for.cond228

for.cond228:                                      ; preds = %for.inc241, %for.end226
  %167 = load i32, i32* %i227, align 4
  %168 = load i32, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
  %169 = load i32, i32* %j, align 4
  %sub229 = sub i32 %168, %169
  %add230 = add i32 %sub229, 1
  %cmp231 = icmp ult i32 %167, %add230
  br i1 %cmp231, label %for.body233, label %for.end243

for.body233:                                      ; preds = %for.cond228
  %170 = load i32, i32* %j, align 4
  %conv234 = uitofp i32 %170 to double
  %171 = load double*, double** %p, align 4
  %172 = load i32*, i32** %ij, align 4
  %173 = load i32, i32* %i227, align 4
  %arrayidx235 = getelementptr inbounds i32, i32* %172, i32 %173
  %174 = load i32, i32* %arrayidx235, align 4
  %arrayidx236 = getelementptr inbounds double, double* %171, i32 %174
  %175 = load double, double* %arrayidx236, align 8
  %mul237 = fmul double %conv234, %175
  %176 = load double, double* %q1, align 8
  %call238 = call double @min2(double %mul237, double %176)
  %177 = load double*, double** %q, align 4
  %178 = load i32*, i32** %ij, align 4
  %179 = load i32, i32* %i227, align 4
  %arrayidx239 = getelementptr inbounds i32, i32* %178, i32 %179
  %180 = load i32, i32* %arrayidx239, align 4
  %arrayidx240 = getelementptr inbounds double, double* %177, i32 %180
  store double %call238, double* %arrayidx240, align 8
  br label %for.inc241

for.inc241:                                       ; preds = %for.body233
  %181 = load i32, i32* %i227, align 4
  %inc242 = add i32 %181, 1
  store i32 %inc242, i32* %i227, align 4
  br label %for.cond228

for.end243:                                       ; preds = %for.cond228
  %182 = load i32*, i32** %ij, align 4
  %183 = bitcast i32* %182 to i8*
  call void @free(i8* %183)
  store i32* null, i32** %ij, align 4
  store i32 0, i32* %i244, align 4
  br label %for.cond245

for.cond245:                                      ; preds = %for.inc253, %for.end243
  %184 = load i32, i32* %i244, align 4
  %185 = load i32, i32* %I2_LENGTH, align 4
  %cmp246 = icmp ult i32 %184, %185
  br i1 %cmp246, label %for.body248, label %for.end255

for.body248:                                      ; preds = %for.cond245
  %186 = load double*, double** %q, align 4
  %187 = load i32, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
  %188 = load i32, i32* %j, align 4
  %sub249 = sub i32 %187, %188
  %arrayidx250 = getelementptr inbounds double, double* %186, i32 %sub249
  %189 = load double, double* %arrayidx250, align 8
  %190 = load double*, double** %q, align 4
  %191 = load i32*, i32** %i2, align 4
  %192 = load i32, i32* %i244, align 4
  %arrayidx251 = getelementptr inbounds i32, i32* %191, i32 %192
  %193 = load i32, i32* %arrayidx251, align 4
  %arrayidx252 = getelementptr inbounds double, double* %190, i32 %193
  store double %189, double* %arrayidx252, align 8
  br label %for.inc253

for.inc253:                                       ; preds = %for.body248
  %194 = load i32, i32* %i244, align 4
  %inc254 = add i32 %194, 1
  store i32 %inc254, i32* %i244, align 4
  br label %for.cond245

for.end255:                                       ; preds = %for.cond245
  %195 = load i32*, i32** %i2, align 4
  %196 = bitcast i32* %195 to i8*
  call void @free(i8* %196)
  store i32* null, i32** %i2, align 4
  store i32 0, i32* %i256, align 4
  br label %for.cond257

for.cond257:                                      ; preds = %for.inc269, %for.end255
  %197 = load i32, i32* %i256, align 4
  %198 = load i32, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
  %cmp258 = icmp ult i32 %197, %198
  br i1 %cmp258, label %for.body260, label %for.end271

for.body260:                                      ; preds = %for.cond257
  %199 = load double*, double** %pa, align 4
  %200 = load i32, i32* %i256, align 4
  %arrayidx261 = getelementptr inbounds double, double* %199, i32 %200
  %201 = load double, double* %arrayidx261, align 8
  %202 = load double*, double** %q, align 4
  %203 = load i32, i32* %i256, align 4
  %arrayidx262 = getelementptr inbounds double, double* %202, i32 %203
  %204 = load double, double* %arrayidx262, align 8
  %cmp263 = fcmp olt double %201, %204
  br i1 %cmp263, label %if.then265, label %if.end268

if.then265:                                       ; preds = %for.body260
  %205 = load double*, double** %q, align 4
  %206 = load i32, i32* %i256, align 4
  %arrayidx266 = getelementptr inbounds double, double* %205, i32 %206
  %207 = load double, double* %arrayidx266, align 8
  %208 = load double*, double** %pa, align 4
  %209 = load i32, i32* %i256, align 4
  %arrayidx267 = getelementptr inbounds double, double* %208, i32 %209
  store double %207, double* %arrayidx267, align 8
  br label %if.end268

if.end268:                                        ; preds = %if.then265, %for.body260
  br label %for.inc269

for.inc269:                                       ; preds = %if.end268
  %210 = load i32, i32* %i256, align 4
  %inc270 = add i32 %210, 1
  store i32 %inc270, i32* %i256, align 4
  br label %for.cond257

for.end271:                                       ; preds = %for.cond257
  br label %for.inc272

for.inc272:                                       ; preds = %for.end271
  %211 = load i32, i32* %j, align 4
  %dec = add i32 %211, -1
  store i32 %dec, i32* %j, align 4
  br label %for.cond182

for.end273:                                       ; preds = %for.cond182
  %212 = load double*, double** %p, align 4
  %213 = bitcast double* %212 to i8*
  call void @free(i8* %213)
  store double* null, double** %p, align 4
  store i32 0, i32* %index274, align 4
  br label %for.cond275

for.cond275:                                      ; preds = %for.inc282, %for.end273
  %214 = load i32, i32* %index274, align 4
  %215 = load i32, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
  %cmp276 = icmp ult i32 %214, %215
  br i1 %cmp276, label %for.body278, label %for.end284

for.body278:                                      ; preds = %for.cond275
  %216 = load double*, double** %pa, align 4
  %217 = load i32*, i32** %ro136, align 4
  %218 = load i32, i32* %index274, align 4
  %arrayidx279 = getelementptr inbounds i32, i32* %217, i32 %218
  %219 = load i32, i32* %arrayidx279, align 4
  %arrayidx280 = getelementptr inbounds double, double* %216, i32 %219
  %220 = load double, double* %arrayidx280, align 8
  %221 = load double*, double** %q, align 4
  %222 = load i32, i32* %index274, align 4
  %arrayidx281 = getelementptr inbounds double, double* %221, i32 %222
  store double %220, double* %arrayidx281, align 8
  br label %for.inc282

for.inc282:                                       ; preds = %for.body278
  %223 = load i32, i32* %index274, align 4
  %inc283 = add i32 %223, 1
  store i32 %inc283, i32* %index274, align 4
  br label %for.cond275

for.end284:                                       ; preds = %for.cond275
  %224 = load i32*, i32** %ro136, align 4
  %225 = bitcast i32* %224 to i8*
  call void @free(i8* %225)
  store i32* null, i32** %ro136, align 4
  %226 = load double*, double** %pa, align 4
  %227 = bitcast double* %226 to i8*
  call void @free(i8* %227)
  store double* null, double** %pa, align 4
  %228 = load double*, double** %q, align 4
  store double* %228, double** %retval, align 4
  br label %return

if.end285:                                        ; preds = %if.else109
  br label %if.end286

if.end286:                                        ; preds = %if.end285
  br label %if.end287

if.end287:                                        ; preds = %if.end286
  %229 = load double*, double** %PVALUES.addr, align 4
  %230 = load i32, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
  %call289 = call i32* @order(double* %229, i32 %230, i1 zeroext true)
  store i32* %call289, i32** %o288, align 4
  %231 = load i32*, i32** %o288, align 4
  %cmp290 = icmp eq i32* %231, null
  br i1 %cmp290, label %if.then292, label %if.end294

if.then292:                                       ; preds = %if.end287
  %call293 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([33 x i8], [33 x i8]* @.str.3, i32 0, i32 0), i8* getelementptr inbounds ([23 x i8], [23 x i8]* @.str.1, i32 0, i32 0), i32 398)
  call void @perror(i8* getelementptr inbounds ([1 x i8], [1 x i8]* @.str.2, i32 0, i32 0))
  call void @exit(i32 1) #5
  unreachable

if.end294:                                        ; preds = %if.end287
  %232 = load i32*, i32** %o288, align 4
  %233 = load i32, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
  %call295 = call double* @uint2double(i32* %232, i32 %233)
  store double* %call295, double** %o_double, align 4
  store i32 0, i32* %index296, align 4
  br label %for.cond297

for.cond297:                                      ; preds = %for.inc312, %if.end294
  %234 = load i32, i32* %index296, align 4
  %235 = load i32, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
  %cmp298 = icmp ult i32 %234, %235
  br i1 %cmp298, label %for.body300, label %for.end314

for.body300:                                      ; preds = %for.cond297
  %236 = load double*, double** %PVALUES.addr, align 4
  %237 = load i32, i32* %index296, align 4
  %arrayidx301 = getelementptr inbounds double, double* %236, i32 %237
  %238 = load double, double* %arrayidx301, align 8
  %cmp302 = fcmp olt double %238, 0.000000e+00
  br i1 %cmp302, label %if.then307, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %for.body300
  %239 = load double*, double** %PVALUES.addr, align 4
  %240 = load i32, i32* %index296, align 4
  %arrayidx304 = getelementptr inbounds double, double* %239, i32 %240
  %241 = load double, double* %arrayidx304, align 8
  %cmp305 = fcmp ogt double %241, 1.000000e+00
  br i1 %cmp305, label %if.then307, label %if.end311

if.then307:                                       ; preds = %lor.lhs.false, %for.body300
  %242 = load i32, i32* %index296, align 4
  %243 = load double*, double** %PVALUES.addr, align 4
  %244 = load i32, i32* %index296, align 4
  %arrayidx308 = getelementptr inbounds double, double* %243, i32 %244
  %245 = load double, double* %arrayidx308, align 8
  %call309 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([54 x i8], [54 x i8]* @.str.24, i32 0, i32 0), i32 %242, double %245)
  %call310 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([20 x i8], [20 x i8]* @.str.25, i32 0, i32 0), i8* getelementptr inbounds ([23 x i8], [23 x i8]* @.str.1, i32 0, i32 0), i32 406)
  call void @exit(i32 1) #5
  unreachable

if.end311:                                        ; preds = %lor.lhs.false
  br label %for.inc312

for.inc312:                                       ; preds = %if.end311
  %246 = load i32, i32* %index296, align 4
  %inc313 = add i32 %246, 1
  store i32 %inc313, i32* %index296, align 4
  br label %for.cond297

for.end314:                                       ; preds = %for.cond297
  %247 = load double*, double** %o_double, align 4
  %248 = load i32, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
  %call316 = call i32* @order(double* %247, i32 %248, i1 zeroext false)
  store i32* %call316, i32** %ro315, align 4
  %249 = load i32*, i32** %ro315, align 4
  %cmp317 = icmp eq i32* %249, null
  br i1 %cmp317, label %if.then319, label %if.end321

if.then319:                                       ; preds = %for.end314
  %call320 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([33 x i8], [33 x i8]* @.str.3, i32 0, i32 0), i8* getelementptr inbounds ([23 x i8], [23 x i8]* @.str.1, i32 0, i32 0), i32 413)
  call void @perror(i8* getelementptr inbounds ([1 x i8], [1 x i8]* @.str.2, i32 0, i32 0))
  call void @exit(i32 1) #5
  unreachable

if.end321:                                        ; preds = %for.end314
  %250 = load double*, double** %o_double, align 4
  %251 = bitcast double* %250 to i8*
  call void @free(i8* %251)
  store double* null, double** %o_double, align 4
  %252 = load i32, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
  %mul322 = mul i32 8, %252
  %call323 = call noalias i8* @malloc(i32 %mul322)
  %253 = bitcast i8* %call323 to double*
  store double* %253, double** %cummin_input, align 4
  %254 = load i16, i16* %TYPE, align 2
  %conv324 = sext i16 %254 to i32
  %cmp325 = icmp eq i32 %conv324, 0
  br i1 %cmp325, label %if.then327, label %if.else344

if.then327:                                       ; preds = %if.end321
  store i32 0, i32* %index328, align 4
  br label %for.cond329

for.cond329:                                      ; preds = %for.inc341, %if.then327
  %255 = load i32, i32* %index328, align 4
  %256 = load i32, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
  %cmp330 = icmp ult i32 %255, %256
  br i1 %cmp330, label %for.body332, label %for.end343

for.body332:                                      ; preds = %for.cond329
  %257 = load i32, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
  %conv333 = uitofp i32 %257 to double
  %258 = load i32, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
  %259 = load i32, i32* %index328, align 4
  %sub334 = sub i32 %258, %259
  %conv335 = uitofp i32 %sub334 to double
  %div336 = fdiv double %conv333, %conv335
  store double %div336, double* %NI, align 8
  %260 = load double, double* %NI, align 8
  %261 = load double*, double** %PVALUES.addr, align 4
  %262 = load i32*, i32** %o288, align 4
  %263 = load i32, i32* %index328, align 4
  %arrayidx337 = getelementptr inbounds i32, i32* %262, i32 %263
  %264 = load i32, i32* %arrayidx337, align 4
  %arrayidx338 = getelementptr inbounds double, double* %261, i32 %264
  %265 = load double, double* %arrayidx338, align 8
  %mul339 = fmul double %260, %265
  %266 = load double*, double** %cummin_input, align 4
  %267 = load i32, i32* %index328, align 4
  %arrayidx340 = getelementptr inbounds double, double* %266, i32 %267
  store double %mul339, double* %arrayidx340, align 8
  br label %for.inc341

for.inc341:                                       ; preds = %for.body332
  %268 = load i32, i32* %index328, align 4
  %inc342 = add i32 %268, 1
  store i32 %inc342, i32* %index328, align 4
  br label %for.cond329

for.end343:                                       ; preds = %for.cond329
  br label %if.end401

if.else344:                                       ; preds = %if.end321
  %269 = load i16, i16* %TYPE, align 2
  %conv345 = sext i16 %269 to i32
  %cmp346 = icmp eq i32 %conv345, 1
  br i1 %cmp346, label %if.then348, label %if.else380

if.then348:                                       ; preds = %if.else344
  store double 1.000000e+00, double* %q349, align 8
  store i32 2, i32* %index350, align 4
  br label %for.cond351

for.cond351:                                      ; preds = %for.inc359, %if.then348
  %270 = load i32, i32* %index350, align 4
  %271 = load i32, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
  %add352 = add i32 1, %271
  %cmp353 = icmp ult i32 %270, %add352
  br i1 %cmp353, label %for.body355, label %for.end361

for.body355:                                      ; preds = %for.cond351
  %272 = load i32, i32* %index350, align 4
  %conv356 = uitofp i32 %272 to double
  %div357 = fdiv double 1.000000e+00, %conv356
  %273 = load double, double* %q349, align 8
  %add358 = fadd double %273, %div357
  store double %add358, double* %q349, align 8
  br label %for.inc359

for.inc359:                                       ; preds = %for.body355
  %274 = load i32, i32* %index350, align 4
  %inc360 = add i32 %274, 1
  store i32 %inc360, i32* %index350, align 4
  br label %for.cond351

for.end361:                                       ; preds = %for.cond351
  store i32 0, i32* %index362, align 4
  br label %for.cond363

for.cond363:                                      ; preds = %for.inc377, %for.end361
  %275 = load i32, i32* %index362, align 4
  %276 = load i32, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
  %cmp364 = icmp ult i32 %275, %276
  br i1 %cmp364, label %for.body366, label %for.end379

for.body366:                                      ; preds = %for.cond363
  %277 = load i32, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
  %conv368 = uitofp i32 %277 to double
  %278 = load i32, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
  %279 = load i32, i32* %index362, align 4
  %sub369 = sub i32 %278, %279
  %conv370 = uitofp i32 %sub369 to double
  %div371 = fdiv double %conv368, %conv370
  store double %div371, double* %NI367, align 8
  %280 = load double, double* %q349, align 8
  %281 = load double, double* %NI367, align 8
  %mul372 = fmul double %280, %281
  %282 = load double*, double** %PVALUES.addr, align 4
  %283 = load i32*, i32** %o288, align 4
  %284 = load i32, i32* %index362, align 4
  %arrayidx373 = getelementptr inbounds i32, i32* %283, i32 %284
  %285 = load i32, i32* %arrayidx373, align 4
  %arrayidx374 = getelementptr inbounds double, double* %282, i32 %285
  %286 = load double, double* %arrayidx374, align 8
  %mul375 = fmul double %mul372, %286
  %287 = load double*, double** %cummin_input, align 4
  %288 = load i32, i32* %index362, align 4
  %arrayidx376 = getelementptr inbounds double, double* %287, i32 %288
  store double %mul375, double* %arrayidx376, align 8
  br label %for.inc377

for.inc377:                                       ; preds = %for.body366
  %289 = load i32, i32* %index362, align 4
  %inc378 = add i32 %289, 1
  store i32 %inc378, i32* %index362, align 4
  br label %for.cond363

for.end379:                                       ; preds = %for.cond363
  br label %if.end400

if.else380:                                       ; preds = %if.else344
  %290 = load i16, i16* %TYPE, align 2
  %conv381 = sext i16 %290 to i32
  %cmp382 = icmp eq i32 %conv381, 3
  br i1 %cmp382, label %if.then384, label %if.end399

if.then384:                                       ; preds = %if.else380
  store i32 0, i32* %index385, align 4
  br label %for.cond386

for.cond386:                                      ; preds = %for.inc396, %if.then384
  %291 = load i32, i32* %index385, align 4
  %292 = load i32, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
  %cmp387 = icmp ult i32 %291, %292
  br i1 %cmp387, label %for.body389, label %for.end398

for.body389:                                      ; preds = %for.cond386
  %293 = load i32, i32* %index385, align 4
  %add390 = add i32 %293, 1
  %conv391 = uitofp i32 %add390 to double
  %294 = load double*, double** %PVALUES.addr, align 4
  %295 = load i32*, i32** %o288, align 4
  %296 = load i32, i32* %index385, align 4
  %arrayidx392 = getelementptr inbounds i32, i32* %295, i32 %296
  %297 = load i32, i32* %arrayidx392, align 4
  %arrayidx393 = getelementptr inbounds double, double* %294, i32 %297
  %298 = load double, double* %arrayidx393, align 8
  %mul394 = fmul double %conv391, %298
  %299 = load double*, double** %cummin_input, align 4
  %300 = load i32, i32* %index385, align 4
  %arrayidx395 = getelementptr inbounds double, double* %299, i32 %300
  store double %mul394, double* %arrayidx395, align 8
  br label %for.inc396

for.inc396:                                       ; preds = %for.body389
  %301 = load i32, i32* %index385, align 4
  %inc397 = add i32 %301, 1
  store i32 %inc397, i32* %index385, align 4
  br label %for.cond386

for.end398:                                       ; preds = %for.cond386
  br label %if.end399

if.end399:                                        ; preds = %for.end398, %if.else380
  br label %if.end400

if.end400:                                        ; preds = %if.end399, %for.end379
  br label %if.end401

if.end401:                                        ; preds = %if.end400, %for.end343
  %302 = load i32*, i32** %o288, align 4
  %303 = bitcast i32* %302 to i8*
  call void @free(i8* %303)
  store i32* null, i32** %o288, align 4
  store double* null, double** %cummin_array, align 4
  %304 = load double*, double** %cummin_input, align 4
  %305 = load i32, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
  %call402 = call double* @cummin(double* %304, i32 %305)
  store double* %call402, double** %cummin_array, align 4
  %306 = load double*, double** %cummin_input, align 4
  %307 = bitcast double* %306 to i8*
  call void @free(i8* %307)
  store double* null, double** %cummin_input, align 4
  %308 = load double*, double** %cummin_array, align 4
  %309 = load i32, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
  %call404 = call double* @pminx(double* %308, i32 %309, double 1.000000e+00)
  store double* %call404, double** %pmin403, align 4
  %310 = load double*, double** %cummin_array, align 4
  %311 = bitcast double* %310 to i8*
  call void @free(i8* %311)
  store double* null, double** %cummin_array, align 4
  %312 = load i32, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
  %mul405 = mul i32 %312, 8
  %call406 = call noalias i8* @malloc(i32 %mul405)
  %313 = bitcast i8* %call406 to double*
  store double* %313, double** %q_array, align 4
  store i32 0, i32* %index407, align 4
  br label %for.cond408

for.cond408:                                      ; preds = %for.inc415, %if.end401
  %314 = load i32, i32* %index407, align 4
  %315 = load i32, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
  %cmp409 = icmp ult i32 %314, %315
  br i1 %cmp409, label %for.body411, label %for.end417

for.body411:                                      ; preds = %for.cond408
  %316 = load double*, double** %pmin403, align 4
  %317 = load i32*, i32** %ro315, align 4
  %318 = load i32, i32* %index407, align 4
  %arrayidx412 = getelementptr inbounds i32, i32* %317, i32 %318
  %319 = load i32, i32* %arrayidx412, align 4
  %arrayidx413 = getelementptr inbounds double, double* %316, i32 %319
  %320 = load double, double* %arrayidx413, align 8
  %321 = load double*, double** %q_array, align 4
  %322 = load i32, i32* %index407, align 4
  %arrayidx414 = getelementptr inbounds double, double* %321, i32 %322
  store double %320, double* %arrayidx414, align 8
  br label %for.inc415

for.inc415:                                       ; preds = %for.body411
  %323 = load i32, i32* %index407, align 4
  %inc416 = add i32 %323, 1
  store i32 %inc416, i32* %index407, align 4
  br label %for.cond408

for.end417:                                       ; preds = %for.cond408
  %324 = load i32*, i32** %ro315, align 4
  %325 = bitcast i32* %324 to i8*
  call void @free(i8* %325)
  store i32* null, i32** %ro315, align 4
  %326 = load double*, double** %pmin403, align 4
  %327 = bitcast double* %326 to i8*
  call void @free(i8* %327)
  store double* null, double** %pmin403, align 4
  %328 = load double*, double** %q_array, align 4
  store double* %328, double** %retval, align 4
  br label %return

return:                                           ; preds = %for.end417, %for.end284, %for.end108, %for.end
  %329 = load double*, double** %retval, align 4
  ret double* %329
}

declare i32 @strcasecmp(i8* %0, i8* %1) #1

; Function Attrs: noinline nounwind optnone
define hidden i32 @main() #0 {
entry:
  %retval = alloca i32, align 4
  %PVALUES = alloca [50 x double], align 16
  %CORRECT_ANSWERS = alloca [6 x [50 x double]], align 16
  %TYPES = alloca [6 x i8*], align 16
  %type = alloca i16, align 2
  %q = alloca double*, align 4
  %error = alloca double, align 8
  %i = alloca i32, align 4
  %this_error = alloca double, align 8
  store i32 0, i32* %retval, align 4
  %0 = bitcast [50 x double]* %PVALUES to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 16 %0, i8* align 16 bitcast ([50 x double]* @__const.main.PVALUES to i8*), i32 400, i1 false)
  %1 = bitcast [6 x [50 x double]]* %CORRECT_ANSWERS to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 16 %1, i8* align 16 bitcast ([6 x [50 x double]]* @__const.main.CORRECT_ANSWERS to i8*), i32 2400, i1 false)
  %2 = bitcast [6 x i8*]* %TYPES to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 16 %2, i8* align 16 bitcast ([6 x i8*]* @__const.main.TYPES to i8*), i32 24, i1 false)
  store i16 0, i16* %type, align 2
  br label %for.cond

for.cond:                                         ; preds = %for.inc19, %entry
  %3 = load i16, i16* %type, align 2
  %conv = zext i16 %3 to i32
  %cmp = icmp sle i32 %conv, 5
  br i1 %cmp, label %for.body, label %for.end21

for.body:                                         ; preds = %for.cond
  %arraydecay = getelementptr inbounds [50 x double], [50 x double]* %PVALUES, i32 0, i32 0
  %4 = load i16, i16* %type, align 2
  %idxprom = zext i16 %4 to i32
  %arrayidx = getelementptr inbounds [6 x i8*], [6 x i8*]* %TYPES, i32 0, i32 %idxprom
  %5 = load i8*, i8** %arrayidx, align 4
  %call = call double* @p_adjust(double* %arraydecay, i32 50, i8* %5)
  store double* %call, double** %q, align 4
  %6 = load double*, double** %q, align 4
  %arrayidx2 = getelementptr inbounds double, double* %6, i32 0
  %7 = load double, double* %arrayidx2, align 8
  %8 = load i16, i16* %type, align 2
  %idxprom3 = zext i16 %8 to i32
  %arrayidx4 = getelementptr inbounds [6 x [50 x double]], [6 x [50 x double]]* %CORRECT_ANSWERS, i32 0, i32 %idxprom3
  %arrayidx5 = getelementptr inbounds [50 x double], [50 x double]* %arrayidx4, i32 0, i32 0
  %9 = load double, double* %arrayidx5, align 16
  %sub = fsub double %7, %9
  %10 = call double @llvm.fabs.f64(double %sub)
  store double %10, double* %error, align 8
  store i32 1, i32* %i, align 4
  br label %for.cond6

for.cond6:                                        ; preds = %for.inc, %for.body
  %11 = load i32, i32* %i, align 4
  %cmp7 = icmp ult i32 %11, 50
  br i1 %cmp7, label %for.body9, label %for.end

for.body9:                                        ; preds = %for.cond6
  %12 = load double*, double** %q, align 4
  %13 = load i32, i32* %i, align 4
  %arrayidx10 = getelementptr inbounds double, double* %12, i32 %13
  %14 = load double, double* %arrayidx10, align 8
  %15 = load i16, i16* %type, align 2
  %idxprom11 = zext i16 %15 to i32
  %arrayidx12 = getelementptr inbounds [6 x [50 x double]], [6 x [50 x double]]* %CORRECT_ANSWERS, i32 0, i32 %idxprom11
  %16 = load i32, i32* %i, align 4
  %arrayidx13 = getelementptr inbounds [50 x double], [50 x double]* %arrayidx12, i32 0, i32 %16
  %17 = load double, double* %arrayidx13, align 8
  %sub14 = fsub double %14, %17
  %18 = call double @llvm.fabs.f64(double %sub14)
  store double %18, double* %this_error, align 8
  %19 = load double, double* %this_error, align 8
  %20 = load double, double* %error, align 8
  %add = fadd double %20, %19
  store double %add, double* %error, align 8
  br label %for.inc

for.inc:                                          ; preds = %for.body9
  %21 = load i32, i32* %i, align 4
  %inc = add i32 %21, 1
  store i32 %inc, i32* %i, align 4
  br label %for.cond6

for.end:                                          ; preds = %for.cond6
  %22 = load double*, double** %q, align 4
  call void @double_say(double* %22, i32 50)
  %23 = load double*, double** %q, align 4
  %24 = bitcast double* %23 to i8*
  call void @free(i8* %24)
  store double* null, double** %q, align 4
  %25 = load i16, i16* %type, align 2
  %conv15 = zext i16 %25 to i32
  %26 = load i16, i16* %type, align 2
  %idxprom16 = zext i16 %26 to i32
  %arrayidx17 = getelementptr inbounds [6 x i8*], [6 x i8*]* %TYPES, i32 0, i32 %idxprom16
  %27 = load i8*, i8** %arrayidx17, align 4
  %28 = load double, double* %error, align 8
  %call18 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([44 x i8], [44 x i8]* @.str.28, i32 0, i32 0), i32 %conv15, i8* %27, double %28)
  br label %for.inc19

for.inc19:                                        ; preds = %for.end
  %29 = load i16, i16* %type, align 2
  %inc20 = add i16 %29, 1
  store i16 %inc20, i16* %type, align 2
  br label %for.cond

for.end21:                                        ; preds = %for.cond
  ret i32 0
}

; Function Attrs: argmemonly nounwind willreturn
declare void @llvm.memcpy.p0i8.p0i8.i32(i8* noalias nocapture writeonly %0, i8* noalias nocapture readonly %1, i32 %2, i1 immarg %3) #3

; Function Attrs: nounwind readnone speculatable willreturn
declare double @llvm.fabs.f64(double %0) #4

attributes #0 = { noinline nounwind optnone "correctly-rounded-divide-sqrt-fp-math"="false" "disable-tail-calls"="false" "frame-pointer"="none" "less-precise-fpmad"="false" "min-legal-vector-width"="0" "no-infs-fp-math"="false" "no-jump-tables"="false" "no-nans-fp-math"="false" "no-signed-zeros-fp-math"="false" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="generic" "unsafe-fp-math"="false" "use-soft-float"="false" }
attributes #1 = { "correctly-rounded-divide-sqrt-fp-math"="false" "disable-tail-calls"="false" "frame-pointer"="none" "less-precise-fpmad"="false" "no-infs-fp-math"="false" "no-nans-fp-math"="false" "no-signed-zeros-fp-math"="false" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="generic" "unsafe-fp-math"="false" "use-soft-float"="false" }
attributes #2 = { noreturn "correctly-rounded-divide-sqrt-fp-math"="false" "disable-tail-calls"="false" "frame-pointer"="none" "less-precise-fpmad"="false" "no-infs-fp-math"="false" "no-nans-fp-math"="false" "no-signed-zeros-fp-math"="false" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="generic" "unsafe-fp-math"="false" "use-soft-float"="false" }
attributes #3 = { argmemonly nounwind willreturn }
attributes #4 = { nounwind readnone speculatable willreturn }
attributes #5 = { noreturn }

!llvm.module.flags = !{!0}
!llvm.ident = !{!1}

!0 = !{i32 1, !"wchar_size", i32 4}
!1 = !{!"clang version 11.0.0 (https://github.com/Jacarte/llvm-project.git 0f6dea67136cc1e0b3d200eb2bb165628970c44b)"}

#########################################################
; exiting Souper's runOnFunction() for order()
rescanning function after transformation was applied

; entering Souper's runOnFunction() for order()

; ModuleID = './P-value_correction.c.bc'
source_filename = "./P-value_correction.c"
target datalayout = "e-m:e-p:32:32-i64:64-n32:64-S128"
target triple = "wasm32-unknown-wasi"

@.str = private unnamed_addr constant [29 x i8] c"malloc failed at %s line %u\0A\00", align 1
@.str.1 = private unnamed_addr constant [23 x i8] c"./P-value_correction.c\00", align 1
@.str.2 = private unnamed_addr constant [1 x i8] zeroinitializer, align 1
@base_arr = hidden global double* null, align 4
@.str.3 = private unnamed_addr constant [33 x i8] c"failed to malloc at %s line %u.\0A\00", align 1
@.str.4 = private unnamed_addr constant [48 x i8] c"cummin function requires at least one element.\0A\00", align 1
@.str.5 = private unnamed_addr constant [22 x i8] c"Failed at %s line %u\0A\00", align 1
@.str.6 = private unnamed_addr constant [41 x i8] c"function requires at least one element.\0A\00", align 1
@.str.7 = private unnamed_addr constant [37 x i8] c"pmin requires at least one element.\0A\00", align 1
@.str.8 = private unnamed_addr constant [7 x i8] c"[1] %e\00", align 1
@.str.9 = private unnamed_addr constant [7 x i8] c" %.10f\00", align 1
@.str.10 = private unnamed_addr constant [6 x i8] c"\0A[%u]\00", align 1
@.str.11 = private unnamed_addr constant [2 x i8] c"\0A\00", align 1
@.str.12 = private unnamed_addr constant [34 x i8] c"Failure to malloc at %s line %u.\0A\00", align 1
@.str.13 = private unnamed_addr constant [41 x i8] c"p_adjust requires at least one element.\0A\00", align 1
@.str.14 = private unnamed_addr constant [3 x i8] c"BH\00", align 1
@.str.15 = private unnamed_addr constant [4 x i8] c"fdr\00", align 1
@.str.16 = private unnamed_addr constant [3 x i8] c"by\00", align 1
@.str.17 = private unnamed_addr constant [11 x i8] c"Bonferroni\00", align 1
@.str.18 = private unnamed_addr constant [9 x i8] c"hochberg\00", align 1
@.str.19 = private unnamed_addr constant [5 x i8] c"holm\00", align 1
@.str.20 = private unnamed_addr constant [7 x i8] c"hommel\00", align 1
@.str.21 = private unnamed_addr constant [44 x i8] c"%s doesn't match any accepted FDR methods.\0A\00", align 1
@.str.22 = private unnamed_addr constant [42 x i8] c"%g is outside of the interval I planned.\0A\00", align 1
@.str.23 = private unnamed_addr constant [23 x i8] c"Failure at %s line %u\0A\00", align 1
@.str.24 = private unnamed_addr constant [54 x i8] c"array[%u] = %lf, which is outside the interval [0,1]\0A\00", align 1
@.str.25 = private unnamed_addr constant [20 x i8] c"died at %s line %u\0A\00", align 1
@__const.main.PVALUES = private unnamed_addr constant [50 x double] [double 0x3FDD04160F35FDE9, double 0x3FE758E721E2A8D7, double 0x3FB96FAC8B38D8BA, double 0x3FB73E71D5B04B37, double 0x3FC710AB48EE865B, double 0x3FEC01D953C3CC73, double 0x3FD2B3C4BE0A922A, double 0x3FED2B5A568DAB4F, double 0x3FDBE08D73F16964, double 0x3FE10A218C41C242, double 0x3FDF8810DB1996AA, double 0x3FE291CCB11E1A9D, double 0x3FD64E8C550D788F, double 7.883130e-01, double 0x3FD177B2BF048D2D, double 0x3FEB3543434BAF2B, double 0x3FDB50EAD41ED0A6, double 0x3FE49D4AFF01D33F, double 0x3FD364C9AE345B51, double 0x3FA99BA35F15394D, double 3.194810e-01, double 0x3FE941E405CE761A, double 0x3FEFF94F77369843, double 0x3FC65847BFB23217, double 0x3FECEB8879B6A543, double 0x3FBEAF00332BA677, double 0x3FD96207C7749E38, double 0x3F8CC02620502C93, double 0x3FE773A5B45A0F40, double 0x3FB1642C24762C01, double 4.040730e-03, double 0x3F33E11D79A90777, double 0x3F870B02BD749528, double 0x3F98521BD6A0353F, double 0x3F4310F26148FFAA, double 0x3F3427CD76006778, double 0x3F80E60AFB1F8A4E, double 0x3F5639B74A9E4DA2, double 0x3F8BDDF74195769F, double 0x3F38ABEE3BFA8581, double 0x3EF2E2E96B5466FE, double 0x3E90CE9F65B58A88, double 0x3FA0F2D097879B95, double 0x3F834EE7216A6684, double 0x3F4CCE8DBB40BD9D, double 0x3F2C8B969590F2ED, double 0x3F4FC31F7F1541AD, double 6.610250e-05, double 0x3F9DB44EA6AC26BA, double 5.735490e-03], align 16
@__const.main.CORRECT_ANSWERS = private unnamed_addr constant [6 x [50 x double]] [[50 x double] [double 0x3FE39AFA2199ADBC, double 8.521710e-01, double 0x3FC96FAC6045BAF5, double 0x3FC83660E51D25AB, double 0x3FD498068702BE20, double 0x3FEDC3BF727136A4, double 4.870370e-01, double 0x3FEDC3BF727136A4, double 0x3FE35BF08BEEB62C, double 0x3FE5D879DEE92F03, double 0x3FE4BE91D656B94A, double 0x3FE7363FC28DAEAA, double 0x3FE0E62C4F13638A, double 0x3FEC1052C8FAB035, double 0x3FDE1DD2E43E029A, double 0x3FED92EFFC7CBDC1, double 0x3FE35BF08BEEB62C, double 0x3FE923B90CFC67C5, double 0x3FDF47B8FC357024, double 0x3FBD1996A9FB10AD, double 0x3FDFF2B6D6C14255, double 0x3FEC1052C8FAB035, double 0x3FEFF94F77369843, double 0x3FD498068702BE20, double 0x3FEDC3BF727136A4, double 0x3FCD80E2E96EC403, double 0x3FE2A9F6A93F290B, double 0x3FA3F736D8AF2E2B, double 8.521710e-01, double 0x3FC2E751B350FAC4, double 0x3F913D8E55EE9F05, double 0x3F64FECB88BB3633, double 0x3FA2009A03CCBE34, double 0x3FB0001FB57CF9FC, double 0x3F6DCA7ADA5E274A, double 0x3F64FECB88BB3633, double 0x3F9E2D13B467D120, double 0x3F7941963399C6A1, double 0x3FA3F736D8AF2E2B, double 0x3F6607390CEF853C, double 0x3F3D828C80BA213A, double 0x3EEA42D90EEBA875, double 0x3FB42D4181AA8F8B, double 0x3FA01715F12E0018, double 0x3F73D9F3AF6D490C, double 0x3F64FECB88BB3633, double 0x3F73D9F3AF6D490C, double 0x3F520CE5F51A7C61, double 0x3FB290B112B20952, double 0x3F9696C95AA76B69], [50 x double] [double 1.000000e+00, double 1.000000e+00, double 0x3FEC9C56E33BA41B, double 0x3FEB3BF21E95ED3D, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 0x3FE05DA74553C727, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 0x3FC675198790829A, double 1.000000e+00, double 0x3FE54345648E1F12, double 0x3FB3645F501CA2F9, double 0x3F879D934E50F0DE, double 0x3FC43FC3646E3EA2, double 0x3FD1FF539D36064C, double 0x3F90C123206B855F, double 0x3F879D934E50F0DE, double 0x3FC0F8967F32E606, double 0x3F9C6880470D2FBE, double 0x3FC675198790829A, double 0x3F88C70105E47082, double 2.025930e-03, double 0x3F0D89DE4FA8F818, double 0x3FD6B1E2D11B1027, double 0x3FC219271872BD8D, double 0x3F96542FAD16CEF9, double 0x3F879D934E50F0DE, double 0x3F96542FAD16CEF9, double 0x3F744D9816EB319A, double 0x3FD4E1D5728DBC16, double 0x3FB9687C40426555], [50 x double] [double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 0x3FE6761DC93EA2D3, double 1.000000e+00, double 1.000000e+00, double 0x3FC9DC55000C953A, double 0x3F8F0FBD624BA499, double 0x3FE2009A24031487, double 1.000000e+00, double 0x3F9DCA7AB8020F7A, double 0x3F8F7E310860A1AB, double 0x3FDA677128614819, double 6.782670e-02, double 6.803480e-01, double 0x3F9346521EDBB84D, double 0x3F4D828CB7B3E0EE, double 0x3EEA42D90EEBA875, double 1.000000e+00, double 4.713920e-01, double 0x3FA6815EE53DB1E7, double 0x3F864D0CF90CC6B8, double 0x3FA8D0709B489B4F, double 0x3F6B1359791819D2, double 1.000000e+00, double 0x3FD25A836EB4E981], [50 x double] [double 0x3FEFF94F77369843, double 0x3FEFF94F77369843, double 0x3FEFF94F77369843, double 0x3FEFF94F77369843, double 0x3FEFF94F77369843, double 0x3FEFF94F77369843, double 0x3FEFF94F77369843, double 0x3FEFF94F77369843, double 0x3FEFF94F77369843, double 0x3FEFF94F77369843, double 0x3FEFF94F77369843, double 0x3FEFF94F77369843, double 0x3FEFF94F77369843, double 0x3FEFF94F77369843, double 0x3FEFF94F77369843, double 0x3FEFF94F77369843, double 0x3FEFF94F77369843, double 0x3FEFF94F77369843, double 0x3FEFF94F77369843, double 0x3FEFF94F77369843, double 0x3FEFF94F77369843, double 0x3FEFF94F77369843, double 0x3FEFF94F77369843, double 0x3FEFF94F77369843, double 0x3FEFF94F77369843, double 0x3FEFF94F77369843, double 0x3FEFF94F77369843, double 0x3FDDA6274695E687, double 0x3FEFF94F77369843, double 0x3FEFF94F77369843, double 0x3FC42BDC26DCE39B, double 0x3F8C57F9104CA951, double 0x3FD9340AC9879DEF, double 7.600230e-01, double 0x3F999EC5A86B439B, double 0x3F8C57F9104CA951, double 0x3FD389FCD90412B4, double 0x3FABC8251D45E10B, double 0x3FDD9BD68ABBB045, double 0x3F90F633F956C386, double 8.825610e-04, double 0x3EEA42D90EEBA875, double 0x3FEFC7471C1E43B8, double 0x3FD5B8C4014C305A, double 0x3FA2E78CEC8D068E, double 0x3F84F6832995A599, double 0x3FA459002162FC24, double 3.172920e-03, double 8.992520e-01, double 0x3FCBE5BD5E9AC00A], [50 x double] [double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 0x3FDDA6274695E687, double 1.000000e+00, double 1.000000e+00, double 0x3FC42BDC26DCE39B, double 0x3F8C939AFCF101E0, double 0x3FD9340AC9879DEF, double 7.600230e-01, double 0x3F999EC5A86B439B, double 0x3F8C939AFCF101E0, double 0x3FD389FCD90412B4, double 0x3FABC8251D45E10B, double 0x3FDD9BD68ABBB045, double 0x3F90F633F956C386, double 8.825610e-04, double 0x3EEA42D90EEBA875, double 0x3FEFC7471C1E43B8, double 0x3FD5B8C4014C305A, double 0x3FA2E78CEC8D068E, double 0x3F84F6832995A599, double 0x3FA459002162FC24, double 3.172920e-03, double 8.992520e-01, double 0x3FCBE5BD5E9AC00A], [50 x double] [double 0x3FEFF94F77369843, double 0x3FEFF94F77369843, double 0x3FEFF94F77369843, double 0x3FEFF5DC908F2EDD, double 0x3FEFF94F77369843, double 0x3FEFF94F77369843, double 0x3FEFF94F77369843, double 0x3FEFF94F77369843, double 0x3FEFF94F77369843, double 0x3FEFF94F77369843, double 0x3FEFF94F77369843, double 0x3FEFF94F77369843, double 0x3FEFF94F77369843, double 0x3FEFF94F77369843, double 0x3FEFF94F77369843, double 0x3FEFF94F77369843, double 0x3FEFF94F77369843, double 0x3FEFF94F77369843, double 0x3FEFF94F77369843, double 0x3FEEB45F17BD8BE7, double 0x3FEFF94F77369843, double 0x3FEFF94F77369843, double 0x3FEFF94F77369843, double 0x3FEFF94F77369843, double 0x3FEFF94F77369843, double 0x3FEFF94F77369843, double 0x3FEFF94F77369843, double 0x3FDBDA250F840182, double 0x3FEFF94F77369843, double 0x3FEF40BC1D52205E, double 0x3FC21A3BEB689947, double 1.304340e-02, double 0x3FD69916517B1CD7, double 0x3FE60A69453DF7B2, double 0x3F986DB666D9D3C6, double 0x3F8B157BBD3AB385, double 2.722920e-01, double 0x3FABC8251D45E10B, double 0x3FDAFF07B27BE8AF, double 0x3F9030D45E3B9F93, double 8.825610e-04, double 0x3EEA42D90EEBA875, double 0x3FEBFACC1948A662, double 0x3FD34EE6EDE042CB, double 0x3FA2011883DA6A9A, double 0x3F839FF779153716, double 0x3FA3D9F3D1C960DD, double 3.172920e-03, double 0x3FE9FDC4BC5D1301, double 0x3FC8F5FAC3801CF1]], align 16
@.str.26 = private unnamed_addr constant [3 x i8] c"bh\00", align 1
@.str.27 = private unnamed_addr constant [11 x i8] c"bonferroni\00", align 1
@__const.main.TYPES = private unnamed_addr constant [6 x i8*] [i8* getelementptr inbounds ([3 x i8], [3 x i8]* @.str.26, i32 0, i32 0), i8* getelementptr inbounds ([3 x i8], [3 x i8]* @.str.16, i32 0, i32 0), i8* getelementptr inbounds ([11 x i8], [11 x i8]* @.str.27, i32 0, i32 0), i8* getelementptr inbounds ([9 x i8], [9 x i8]* @.str.18, i32 0, i32 0), i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.19, i32 0, i32 0), i8* getelementptr inbounds ([7 x i8], [7 x i8]* @.str.20, i32 0, i32 0)], align 16
@.str.28 = private unnamed_addr constant [44 x i8] c"\0Atype %u = '%s' has cumulative error of %g\0A\00", align 1
@llvm.used = appending global [1 x i8*] [i8* bitcast (i32 ()* @__main_void to i8*)], section "llvm.metadata"

@__main_void = alias i32 (), i32 ()* @main

; Function Attrs: noinline nounwind optnone
define hidden i32* @seq_len(i32 %START, i32 %END) #0 {
entry:
  %retval = alloca i32*, align 4
  %START.addr = alloca i32, align 4
  %END.addr = alloca i32, align 4
  %start = alloca i32, align 4
  %end = alloca i32, align 4
  %sequence = alloca i32*, align 4
  %i = alloca i32, align 4
  %LENGTH = alloca i32, align 4
  %sequence10 = alloca i32*, align 4
  %index = alloca i32, align 4
  %index28 = alloca i32, align 4
  store i32 %START, i32* %START.addr, align 4
  store i32 %END, i32* %END.addr, align 4
  %0 = load i32, i32* %START.addr, align 4
  store i32 %0, i32* %start, align 4
  %1 = load i32, i32* %END.addr, align 4
  store i32 %1, i32* %end, align 4
  %2 = load i32, i32* %START.addr, align 4
  %3 = load i32, i32* %END.addr, align 4
  %cmp = icmp eq i32 %2, %3
  br i1 %cmp, label %if.then, label %if.end6

if.then:                                          ; preds = %entry
  %4 = load i32, i32* %end, align 4
  %add = add i32 %4, 1
  %mul = mul i32 %add, 4
  %call = call noalias i8* @malloc(i32 %mul)
  %5 = bitcast i8* %call to i32*
  store i32* %5, i32** %sequence, align 4
  %6 = load i32*, i32** %sequence, align 4
  %cmp1 = icmp eq i32* %6, null
  br i1 %cmp1, label %if.then2, label %if.end

if.then2:                                         ; preds = %if.then
  %call3 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([29 x i8], [29 x i8]* @.str, i32 0, i32 0), i8* getelementptr inbounds ([23 x i8], [23 x i8]* @.str.1, i32 0, i32 0), i32 15)
  call void @perror(i8* getelementptr inbounds ([1 x i8], [1 x i8]* @.str.2, i32 0, i32 0))
  call void @exit(i32 1) #5
  unreachable

if.end:                                           ; preds = %if.then
  store i32 0, i32* %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.end
  %7 = load i32, i32* %i, align 4
  %8 = load i32, i32* %end, align 4
  %cmp4 = icmp ult i32 %7, %8
  br i1 %cmp4, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %9 = load i32, i32* %i, align 4
  %add5 = add i32 %9, 1
  %10 = load i32*, i32** %sequence, align 4
  %11 = load i32, i32* %i, align 4
  %arrayidx = getelementptr inbounds i32, i32* %10, i32 %11
  store i32 %add5, i32* %arrayidx, align 4
  br label %for.inc

for.inc:                                          ; preds = %for.body
  %12 = load i32, i32* %i, align 4
  %inc = add i32 %12, 1
  store i32 %inc, i32* %i, align 4
  br label %for.cond

for.end:                                          ; preds = %for.cond
  %13 = load i32*, i32** %sequence, align 4
  store i32* %13, i32** %retval, align 4
  br label %return

if.end6:                                          ; preds = %entry
  %14 = load i32, i32* %START.addr, align 4
  %15 = load i32, i32* %END.addr, align 4
  %cmp7 = icmp ugt i32 %14, %15
  br i1 %cmp7, label %if.then8, label %if.end9

if.then8:                                         ; preds = %if.end6
  %16 = load i32, i32* %START.addr, align 4
  store i32 %16, i32* %end, align 4
  %17 = load i32, i32* %END.addr, align 4
  store i32 %17, i32* %start, align 4
  br label %if.end9

if.end9:                                          ; preds = %if.then8, %if.end6
  %18 = load i32, i32* %end, align 4
  %19 = load i32, i32* %start, align 4
  %sub = sub i32 %18, %19
  store i32 %sub, i32* %LENGTH, align 4
  %20 = load i32, i32* %LENGTH, align 4
  %add11 = add i32 1, %20
  %mul12 = mul i32 %add11, 4
  %call13 = call noalias i8* @malloc(i32 %mul12)
  %21 = bitcast i8* %call13 to i32*
  store i32* %21, i32** %sequence10, align 4
  %22 = load i32*, i32** %sequence10, align 4
  %cmp14 = icmp eq i32* %22, null
  br i1 %cmp14, label %if.then15, label %if.end17

if.then15:                                        ; preds = %if.end9
  %call16 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([29 x i8], [29 x i8]* @.str, i32 0, i32 0), i8* getelementptr inbounds ([23 x i8], [23 x i8]* @.str.1, i32 0, i32 0), i32 31)
  call void @perror(i8* getelementptr inbounds ([1 x i8], [1 x i8]* @.str.2, i32 0, i32 0))
  call void @exit(i32 1) #5
  unreachable

if.end17:                                         ; preds = %if.end9
  %23 = load i32, i32* %START.addr, align 4
  %24 = load i32, i32* %END.addr, align 4
  %cmp18 = icmp ult i32 %23, %24
  br i1 %cmp18, label %if.then19, label %if.else

if.then19:                                        ; preds = %if.end17
  store i32 0, i32* %index, align 4
  br label %for.cond20

for.cond20:                                       ; preds = %for.inc25, %if.then19
  %25 = load i32, i32* %index, align 4
  %26 = load i32, i32* %LENGTH, align 4
  %cmp21 = icmp ule i32 %25, %26
  br i1 %cmp21, label %for.body22, label %for.end27

for.body22:                                       ; preds = %for.cond20
  %27 = load i32, i32* %start, align 4
  %28 = load i32, i32* %index, align 4
  %add23 = add i32 %27, %28
  %29 = load i32*, i32** %sequence10, align 4
  %30 = load i32, i32* %index, align 4
  %arrayidx24 = getelementptr inbounds i32, i32* %29, i32 %30
  store i32 %add23, i32* %arrayidx24, align 4
  br label %for.inc25

for.inc25:                                        ; preds = %for.body22
  %31 = load i32, i32* %index, align 4
  %inc26 = add i32 %31, 1
  store i32 %inc26, i32* %index, align 4
  br label %for.cond20

for.end27:                                        ; preds = %for.cond20
  br label %if.end37

if.else:                                          ; preds = %if.end17
  store i32 0, i32* %index28, align 4
  br label %for.cond29

for.cond29:                                       ; preds = %for.inc34, %if.else
  %32 = load i32, i32* %index28, align 4
  %33 = load i32, i32* %LENGTH, align 4
  %cmp30 = icmp ule i32 %32, %33
  br i1 %cmp30, label %for.body31, label %for.end36

for.body31:                                       ; preds = %for.cond29
  %34 = load i32, i32* %end, align 4
  %35 = load i32, i32* %index28, align 4
  %sub32 = sub i32 %34, %35
  %36 = load i32*, i32** %sequence10, align 4
  %37 = load i32, i32* %index28, align 4
  %arrayidx33 = getelementptr inbounds i32, i32* %36, i32 %37
  store i32 %sub32, i32* %arrayidx33, align 4
  br label %for.inc34

for.inc34:                                        ; preds = %for.body31
  %38 = load i32, i32* %index28, align 4
  %inc35 = add i32 %38, 1
  store i32 %inc35, i32* %index28, align 4
  br label %for.cond29

for.end36:                                        ; preds = %for.cond29
  br label %if.end37

if.end37:                                         ; preds = %for.end36, %for.end27
  %39 = load i32*, i32** %sequence10, align 4
  store i32* %39, i32** %retval, align 4
  br label %return

return:                                           ; preds = %if.end37, %for.end
  %40 = load i32*, i32** %retval, align 4
  ret i32* %40
}

declare noalias i8* @malloc(i32 %0) #1

declare i32 @printf(i8* %0, ...) #1

declare void @perror(i8* %0) #1

; Function Attrs: noreturn
declare void @exit(i32 %0) #2

; Function Attrs: noinline nounwind optnone
define hidden i32* @order(double* noalias %ARRAY, i32 %SIZE, i1 zeroext %DECREASING) #0 {
entry:
  %ARRAY.addr = alloca double*, align 4
  %SIZE.addr = alloca i32, align 4
  %DECREASING.addr = alloca i8, align 1
  %idx = alloca i32*, align 4
  %i = alloca i32, align 4
  store double* %ARRAY, double** %ARRAY.addr, align 4
  store i32 %SIZE, i32* %SIZE.addr, align 4
  %frombool = zext i1 %DECREASING to i8
  store i8 %frombool, i8* %DECREASING.addr, align 1
  %0 = load i32, i32* %SIZE.addr, align 4
  %mul = mul i32 %0, 4
  %call = call noalias i8* @malloc(i32 %mul)
  %1 = bitcast i8* %call to i32*
  store i32* %1, i32** %idx, align 4
  %2 = load i32*, i32** %idx, align 4
  %cmp = icmp eq i32* %2, null
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %call1 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([33 x i8], [33 x i8]* @.str.3, i32 0, i32 0), i8* getelementptr inbounds ([23 x i8], [23 x i8]* @.str.1, i32 0, i32 0), i32 77)
  call void @perror(i8* getelementptr inbounds ([1 x i8], [1 x i8]* @.str.2, i32 0, i32 0))
  call void @exit(i32 1) #5
  unreachable

if.end:                                           ; preds = %entry
  %3 = load i32, i32* %SIZE.addr, align 4
  %mul2 = mul i32 8, %3
  %call3 = call noalias i8* @malloc(i32 %mul2)
  %4 = bitcast i8* %call3 to double*
  store double* %4, double** @base_arr, align 4
  %5 = load double*, double** @base_arr, align 4
  %cmp4 = icmp eq double* %5, null
  br i1 %cmp4, label %if.then5, label %if.end7

if.then5:                                         ; preds = %if.end
  %call6 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([33 x i8], [33 x i8]* @.str.3, i32 0, i32 0), i8* getelementptr inbounds ([23 x i8], [23 x i8]* @.str.1, i32 0, i32 0), i32 83)
  call void @perror(i8* getelementptr inbounds ([1 x i8], [1 x i8]* @.str.2, i32 0, i32 0))
  call void @exit(i32 1) #5
  unreachable

if.end7:                                          ; preds = %if.end
  store i32 0, i32* %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.end7
  %6 = load i32, i32* %i, align 4
  %7 = load i32, i32* %SIZE.addr, align 4
  %cmp8 = icmp ult i32 %6, %7
  br i1 %cmp8, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %8 = load double*, double** %ARRAY.addr, align 4
  %9 = load i32, i32* %i, align 4
  %arrayidx = getelementptr inbounds double, double* %8, i32 %9
  %10 = load double, double* %arrayidx, align 8
  %11 = load double*, double** @base_arr, align 4
  %12 = load i32, i32* %i, align 4
  %arrayidx9 = getelementptr inbounds double, double* %11, i32 %12
  store double %10, double* %arrayidx9, align 8
  %13 = load i32, i32* %i, align 4
  %14 = load i32*, i32** %idx, align 4
  %15 = load i32, i32* %i, align 4
  %arrayidx10 = getelementptr inbounds i32, i32* %14, i32 %15
  store i32 %13, i32* %arrayidx10, align 4
  br label %for.inc

for.inc:                                          ; preds = %for.body
  %16 = load i32, i32* %i, align 4
  %inc = add i32 %16, 1
  store i32 %inc, i32* %i, align 4
  br label %for.cond

for.end:                                          ; preds = %for.cond
  %17 = load i8, i8* %DECREASING.addr, align 1
  %tobool = trunc i8 %17 to i1
  %conv = zext i1 %tobool to i32
  %cmp11 = icmp eq i32 %conv, 0
  br i1 %cmp11, label %if.then13, label %if.else

if.then13:                                        ; preds = %for.end
  %18 = load i32*, i32** %idx, align 4
  %19 = bitcast i32* %18 to i8*
  %20 = load i32, i32* %SIZE.addr, align 4
  call void @qsort(i8* %19, i32 %20, i32 4, i32 (i8*, i8*)* @compar_decrease)
  br label %if.end20

if.else:                                          ; preds = %for.end
  %21 = load i8, i8* %DECREASING.addr, align 1
  %tobool14 = trunc i8 %21 to i1
  br i1 %tobool14, label %if.then18, label %if.end19

if.then18:                                        ; preds = %if.else
  %22 = load i32*, i32** %idx, align 4
  %23 = bitcast i32* %22 to i8*
  %24 = load i32, i32* %SIZE.addr, align 4
  call void @qsort(i8* %23, i32 %24, i32 4, i32 (i8*, i8*)* @compar_increase)
  br label %if.end19

if.end19:                                         ; preds = %if.then18, %if.else
  br label %if.end20

if.end20:                                         ; preds = %if.end19, %if.then13
  %25 = load double*, double** @base_arr, align 4
  %26 = bitcast double* %25 to i8*
  call void @free(i8* %26)
  store double* null, double** @base_arr, align 4
  %27 = load i32*, i32** %idx, align 4
  ret i32* %27
}

declare void @qsort(i8* %0, i32 %1, i32 %2, i32 (i8*, i8*)* %3) #1

; Function Attrs: noinline nounwind optnone
define internal i32 @compar_decrease(i8* noalias %a, i8* noalias %b) #0 {
entry:
  %retval = alloca i32, align 4
  %a.addr = alloca i8*, align 4
  %b.addr = alloca i8*, align 4
  %aa = alloca i32, align 4
  %bb = alloca i32, align 4
  store i8* %a, i8** %a.addr, align 4
  store i8* %b, i8** %b.addr, align 4
  %0 = load i8*, i8** %a.addr, align 4
  %1 = bitcast i8* %0 to i32*
  %2 = load i32, i32* %1, align 4
  store i32 %2, i32* %aa, align 4
  %3 = load i8*, i8** %b.addr, align 4
  %4 = bitcast i8* %3 to i32*
  %5 = load i32, i32* %4, align 4
  store i32 %5, i32* %bb, align 4
  %6 = load double*, double** @base_arr, align 4
  %7 = load i32, i32* %aa, align 4
  %arrayidx = getelementptr inbounds double, double* %6, i32 %7
  %8 = load double, double* %arrayidx, align 8
  %9 = load double*, double** @base_arr, align 4
  %10 = load i32, i32* %bb, align 4
  %arrayidx1 = getelementptr inbounds double, double* %9, i32 %10
  %11 = load double, double* %arrayidx1, align 8
  %cmp = fcmp olt double %8, %11
  br i1 %cmp, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  store i32 -1, i32* %retval, align 4
  br label %return

if.else:                                          ; preds = %entry
  %12 = load double*, double** @base_arr, align 4
  %13 = load i32, i32* %aa, align 4
  %arrayidx2 = getelementptr inbounds double, double* %12, i32 %13
  %14 = load double, double* %arrayidx2, align 8
  %15 = load double*, double** @base_arr, align 4
  %16 = load i32, i32* %bb, align 4
  %arrayidx3 = getelementptr inbounds double, double* %15, i32 %16
  %17 = load double, double* %arrayidx3, align 8
  %cmp4 = fcmp oeq double %14, %17
  br i1 %cmp4, label %if.then5, label %if.else6

if.then5:                                         ; preds = %if.else
  store i32 0, i32* %retval, align 4
  br label %return

if.else6:                                         ; preds = %if.else
  store i32 1, i32* %retval, align 4
  br label %return

return:                                           ; preds = %if.else6, %if.then5, %if.then
  %18 = load i32, i32* %retval, align 4
  ret i32 %18
}

; Function Attrs: noinline nounwind optnone
define internal i32 @compar_increase(i8* noalias %a, i8* noalias %b) #0 {
entry:
  %retval = alloca i32, align 4
  %a.addr = alloca i8*, align 4
  %b.addr = alloca i8*, align 4
  %aa = alloca i32, align 4
  %bb = alloca i32, align 4
  store i8* %a, i8** %a.addr, align 4
  store i8* %b, i8** %b.addr, align 4
  %0 = load i8*, i8** %a.addr, align 4
  %1 = bitcast i8* %0 to i32*
  %2 = load i32, i32* %1, align 4
  store i32 %2, i32* %aa, align 4
  %3 = load i8*, i8** %b.addr, align 4
  %4 = bitcast i8* %3 to i32*
  %5 = load i32, i32* %4, align 4
  store i32 %5, i32* %bb, align 4
  %6 = load double*, double** @base_arr, align 4
  %7 = load i32, i32* %aa, align 4
  %arrayidx = getelementptr inbounds double, double* %6, i32 %7
  %8 = load double, double* %arrayidx, align 8
  %9 = load double*, double** @base_arr, align 4
  %10 = load i32, i32* %bb, align 4
  %arrayidx1 = getelementptr inbounds double, double* %9, i32 %10
  %11 = load double, double* %arrayidx1, align 8
  %cmp = fcmp olt double %8, %11
  br i1 %cmp, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  store i32 1, i32* %retval, align 4
  br label %return

if.else:                                          ; preds = %entry
  %12 = load double*, double** @base_arr, align 4
  %13 = load i32, i32* %aa, align 4
  %arrayidx2 = getelementptr inbounds double, double* %12, i32 %13
  %14 = load double, double* %arrayidx2, align 8
  %15 = load double*, double** @base_arr, align 4
  %16 = load i32, i32* %bb, align 4
  %arrayidx3 = getelementptr inbounds double, double* %15, i32 %16
  %17 = load double, double* %arrayidx3, align 8
  %cmp4 = fcmp oeq double %14, %17
  br i1 %cmp4, label %if.then5, label %if.else6

if.then5:                                         ; preds = %if.else
  store i32 0, i32* %retval, align 4
  br label %return

if.else6:                                         ; preds = %if.else
  store i32 -1, i32* %retval, align 4
  br label %return

return:                                           ; preds = %if.else6, %if.then5, %if.then
  %18 = load i32, i32* %retval, align 4
  ret i32 %18
}

declare void @free(i8* %0) #1

; Function Attrs: noinline nounwind optnone
define hidden double* @cummin(double* noalias %ARRAY, i32 %NO_OF_ARRAY_ELEMENTS) #0 {
entry:
  %ARRAY.addr = alloca double*, align 4
  %NO_OF_ARRAY_ELEMENTS.addr = alloca i32, align 4
  %output = alloca double*, align 4
  %cumulative_min = alloca double, align 8
  %i = alloca i32, align 4
  store double* %ARRAY, double** %ARRAY.addr, align 4
  store i32 %NO_OF_ARRAY_ELEMENTS, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
  %0 = load i32, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
  %cmp = icmp ult i32 %0, 1
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %call = call i32 @puts(i8* getelementptr inbounds ([48 x i8], [48 x i8]* @.str.4, i32 0, i32 0))
  %call1 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([22 x i8], [22 x i8]* @.str.5, i32 0, i32 0), i8* getelementptr inbounds ([23 x i8], [23 x i8]* @.str.1, i32 0, i32 0), i32 105)
  call void @exit(i32 1) #5
  unreachable

if.end:                                           ; preds = %entry
  %1 = load i32, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
  %mul = mul i32 8, %1
  %call2 = call noalias i8* @malloc(i32 %mul)
  %2 = bitcast i8* %call2 to double*
  store double* %2, double** %output, align 4
  %3 = load double*, double** %output, align 4
  %cmp3 = icmp eq double* %3, null
  br i1 %cmp3, label %if.then4, label %if.end6

if.then4:                                         ; preds = %if.end
  %call5 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([33 x i8], [33 x i8]* @.str.3, i32 0, i32 0), i8* getelementptr inbounds ([23 x i8], [23 x i8]* @.str.1, i32 0, i32 0), i32 110)
  call void @perror(i8* getelementptr inbounds ([1 x i8], [1 x i8]* @.str.2, i32 0, i32 0))
  call void @exit(i32 1) #5
  unreachable

if.end6:                                          ; preds = %if.end
  %4 = load double*, double** %ARRAY.addr, align 4
  %arrayidx = getelementptr inbounds double, double* %4, i32 0
  %5 = load double, double* %arrayidx, align 8
  store double %5, double* %cumulative_min, align 8
  store i32 0, i32* %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.end6
  %6 = load i32, i32* %i, align 4
  %7 = load i32, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
  %cmp7 = icmp ult i32 %6, %7
  br i1 %cmp7, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %8 = load double*, double** %ARRAY.addr, align 4
  %9 = load i32, i32* %i, align 4
  %arrayidx8 = getelementptr inbounds double, double* %8, i32 %9
  %10 = load double, double* %arrayidx8, align 8
  %11 = load double, double* %cumulative_min, align 8
  %cmp9 = fcmp olt double %10, %11
  br i1 %cmp9, label %if.then10, label %if.end12

if.then10:                                        ; preds = %for.body
  %12 = load double*, double** %ARRAY.addr, align 4
  %13 = load i32, i32* %i, align 4
  %arrayidx11 = getelementptr inbounds double, double* %12, i32 %13
  %14 = load double, double* %arrayidx11, align 8
  store double %14, double* %cumulative_min, align 8
  br label %if.end12

if.end12:                                         ; preds = %if.then10, %for.body
  %15 = load double, double* %cumulative_min, align 8
  %16 = load double*, double** %output, align 4
  %17 = load i32, i32* %i, align 4
  %arrayidx13 = getelementptr inbounds double, double* %16, i32 %17
  store double %15, double* %arrayidx13, align 8
  br label %for.inc

for.inc:                                          ; preds = %if.end12
  %18 = load i32, i32* %i, align 4
  %inc = add i32 %18, 1
  store i32 %inc, i32* %i, align 4
  br label %for.cond

for.end:                                          ; preds = %for.cond
  %19 = load double*, double** %output, align 4
  ret double* %19
}

declare i32 @puts(i8* %0) #1

; Function Attrs: noinline nounwind optnone
define hidden double* @cummax(double* noalias %ARRAY, i32 %NO_OF_ARRAY_ELEMENTS) #0 {
entry:
  %ARRAY.addr = alloca double*, align 4
  %NO_OF_ARRAY_ELEMENTS.addr = alloca i32, align 4
  %output = alloca double*, align 4
  %cumulative_max = alloca double, align 8
  %i = alloca i32, align 4
  store double* %ARRAY, double** %ARRAY.addr, align 4
  store i32 %NO_OF_ARRAY_ELEMENTS, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
  %0 = load i32, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
  %cmp = icmp ult i32 %0, 1
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %call = call i32 @puts(i8* getelementptr inbounds ([41 x i8], [41 x i8]* @.str.6, i32 0, i32 0))
  %call1 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([22 x i8], [22 x i8]* @.str.5, i32 0, i32 0), i8* getelementptr inbounds ([23 x i8], [23 x i8]* @.str.1, i32 0, i32 0), i32 129)
  call void @exit(i32 1) #5
  unreachable

if.end:                                           ; preds = %entry
  %1 = load i32, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
  %mul = mul i32 8, %1
  %call2 = call noalias i8* @malloc(i32 %mul)
  %2 = bitcast i8* %call2 to double*
  store double* %2, double** %output, align 4
  %3 = load double*, double** %output, align 4
  %cmp3 = icmp eq double* %3, null
  br i1 %cmp3, label %if.then4, label %if.end6

if.then4:                                         ; preds = %if.end
  %call5 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([33 x i8], [33 x i8]* @.str.3, i32 0, i32 0), i8* getelementptr inbounds ([23 x i8], [23 x i8]* @.str.1, i32 0, i32 0), i32 134)
  call void @perror(i8* getelementptr inbounds ([1 x i8], [1 x i8]* @.str.2, i32 0, i32 0))
  call void @exit(i32 1) #5
  unreachable

if.end6:                                          ; preds = %if.end
  %4 = load double*, double** %ARRAY.addr, align 4
  %arrayidx = getelementptr inbounds double, double* %4, i32 0
  %5 = load double, double* %arrayidx, align 8
  store double %5, double* %cumulative_max, align 8
  store i32 0, i32* %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.end6
  %6 = load i32, i32* %i, align 4
  %7 = load i32, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
  %cmp7 = icmp ult i32 %6, %7
  br i1 %cmp7, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %8 = load double*, double** %ARRAY.addr, align 4
  %9 = load i32, i32* %i, align 4
  %arrayidx8 = getelementptr inbounds double, double* %8, i32 %9
  %10 = load double, double* %arrayidx8, align 8
  %11 = load double, double* %cumulative_max, align 8
  %cmp9 = fcmp ogt double %10, %11
  br i1 %cmp9, label %if.then10, label %if.end12

if.then10:                                        ; preds = %for.body
  %12 = load double*, double** %ARRAY.addr, align 4
  %13 = load i32, i32* %i, align 4
  %arrayidx11 = getelementptr inbounds double, double* %12, i32 %13
  %14 = load double, double* %arrayidx11, align 8
  store double %14, double* %cumulative_max, align 8
  br label %if.end12

if.end12:                                         ; preds = %if.then10, %for.body
  %15 = load double, double* %cumulative_max, align 8
  %16 = load double*, double** %output, align 4
  %17 = load i32, i32* %i, align 4
  %arrayidx13 = getelementptr inbounds double, double* %16, i32 %17
  store double %15, double* %arrayidx13, align 8
  br label %for.inc

for.inc:                                          ; preds = %if.end12
  %18 = load i32, i32* %i, align 4
  %inc = add i32 %18, 1
  store i32 %inc, i32* %i, align 4
  br label %for.cond

for.end:                                          ; preds = %for.cond
  %19 = load double*, double** %output, align 4
  ret double* %19
}

; Function Attrs: noinline nounwind optnone
define hidden double* @pminx(double* noalias %ARRAY, i32 %NO_OF_ARRAY_ELEMENTS, double %X) #0 {
entry:
  %ARRAY.addr = alloca double*, align 4
  %NO_OF_ARRAY_ELEMENTS.addr = alloca i32, align 4
  %X.addr = alloca double, align 8
  %pmin_array = alloca double*, align 4
  %index = alloca i32, align 4
  store double* %ARRAY, double** %ARRAY.addr, align 4
  store i32 %NO_OF_ARRAY_ELEMENTS, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
  store double %X, double* %X.addr, align 8
  %0 = load i32, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
  %cmp = icmp ult i32 %0, 1
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %call = call i32 @puts(i8* getelementptr inbounds ([37 x i8], [37 x i8]* @.str.7, i32 0, i32 0))
  %call1 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([22 x i8], [22 x i8]* @.str.5, i32 0, i32 0), i8* getelementptr inbounds ([23 x i8], [23 x i8]* @.str.1, i32 0, i32 0), i32 152)
  call void @exit(i32 1) #5
  unreachable

if.end:                                           ; preds = %entry
  %1 = load i32, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
  %mul = mul i32 8, %1
  %call2 = call noalias i8* @malloc(i32 %mul)
  %2 = bitcast i8* %call2 to double*
  store double* %2, double** %pmin_array, align 4
  %3 = load double*, double** %pmin_array, align 4
  %cmp3 = icmp eq double* %3, null
  br i1 %cmp3, label %if.then4, label %if.end6

if.then4:                                         ; preds = %if.end
  %call5 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([33 x i8], [33 x i8]* @.str.3, i32 0, i32 0), i8* getelementptr inbounds ([23 x i8], [23 x i8]* @.str.1, i32 0, i32 0), i32 157)
  call void @perror(i8* getelementptr inbounds ([1 x i8], [1 x i8]* @.str.2, i32 0, i32 0))
  call void @exit(i32 1) #5
  unreachable

if.end6:                                          ; preds = %if.end
  store i32 0, i32* %index, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.end6
  %4 = load i32, i32* %index, align 4
  %5 = load i32, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
  %cmp7 = icmp ult i32 %4, %5
  br i1 %cmp7, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %6 = load double*, double** %ARRAY.addr, align 4
  %7 = load i32, i32* %index, align 4
  %arrayidx = getelementptr inbounds double, double* %6, i32 %7
  %8 = load double, double* %arrayidx, align 8
  %9 = load double, double* %X.addr, align 8
  %cmp8 = fcmp olt double %8, %9
  br i1 %cmp8, label %if.then9, label %if.else

if.then9:                                         ; preds = %for.body
  %10 = load double*, double** %ARRAY.addr, align 4
  %11 = load i32, i32* %index, align 4
  %arrayidx10 = getelementptr inbounds double, double* %10, i32 %11
  %12 = load double, double* %arrayidx10, align 8
  %13 = load double*, double** %pmin_array, align 4
  %14 = load i32, i32* %index, align 4
  %arrayidx11 = getelementptr inbounds double, double* %13, i32 %14
  store double %12, double* %arrayidx11, align 8
  br label %if.end13

if.else:                                          ; preds = %for.body
  %15 = load double, double* %X.addr, align 8
  %16 = load double*, double** %pmin_array, align 4
  %17 = load i32, i32* %index, align 4
  %arrayidx12 = getelementptr inbounds double, double* %16, i32 %17
  store double %15, double* %arrayidx12, align 8
  br label %if.end13

if.end13:                                         ; preds = %if.else, %if.then9
  br label %for.inc

for.inc:                                          ; preds = %if.end13
  %18 = load i32, i32* %index, align 4
  %inc = add i32 %18, 1
  store i32 %inc, i32* %index, align 4
  br label %for.cond

for.end:                                          ; preds = %for.cond
  %19 = load double*, double** %pmin_array, align 4
  ret double* %19
}

; Function Attrs: noinline nounwind optnone
define hidden void @double_say(double* noalias %ARRAY, i32 %NO_OF_ARRAY_ELEMENTS) #0 {
entry:
  %ARRAY.addr = alloca double*, align 4
  %NO_OF_ARRAY_ELEMENTS.addr = alloca i32, align 4
  %i = alloca i32, align 4
  store double* %ARRAY, double** %ARRAY.addr, align 4
  store i32 %NO_OF_ARRAY_ELEMENTS, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
  %0 = load double*, double** %ARRAY.addr, align 4
  %arrayidx = getelementptr inbounds double, double* %0, i32 0
  %1 = load double, double* %arrayidx, align 8
  %call = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([7 x i8], [7 x i8]* @.str.8, i32 0, i32 0), double %1)
  store i32 1, i32* %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %2 = load i32, i32* %i, align 4
  %3 = load i32, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
  %cmp = icmp ult i32 %2, %3
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %4 = load double*, double** %ARRAY.addr, align 4
  %5 = load i32, i32* %i, align 4
  %arrayidx1 = getelementptr inbounds double, double* %4, i32 %5
  %6 = load double, double* %arrayidx1, align 8
  %call2 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([7 x i8], [7 x i8]* @.str.9, i32 0, i32 0), double %6)
  %7 = load i32, i32* %i, align 4
  %add = add i32 %7, 1
  %rem = urem i32 %add, 5
  %cmp3 = icmp eq i32 %rem, 0
  br i1 %cmp3, label %if.then, label %if.end

if.then:                                          ; preds = %for.body
  %8 = load i32, i32* %i, align 4
  %add4 = add i32 %8, 1
  %call5 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([6 x i8], [6 x i8]* @.str.10, i32 0, i32 0), i32 %add4)
  br label %if.end

if.end:                                           ; preds = %if.then, %for.body
  br label %for.inc

for.inc:                                          ; preds = %if.end
  %9 = load i32, i32* %i, align 4
  %inc = add i32 %9, 1
  store i32 %inc, i32* %i, align 4
  br label %for.cond

for.end:                                          ; preds = %for.cond
  %call6 = call i32 @puts(i8* getelementptr inbounds ([2 x i8], [2 x i8]* @.str.11, i32 0, i32 0))
  ret void
}

; Function Attrs: noinline nounwind optnone
define hidden double* @uint2double(i32* noalias %ARRAY, i32 %NO_OF_ARRAY_ELEMENTS) #0 {
entry:
  %ARRAY.addr = alloca i32*, align 4
  %NO_OF_ARRAY_ELEMENTS.addr = alloca i32, align 4
  %doubleArray = alloca double*, align 4
  %index = alloca i32, align 4
  store i32* %ARRAY, i32** %ARRAY.addr, align 4
  store i32 %NO_OF_ARRAY_ELEMENTS, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
  %0 = load i32, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
  %mul = mul i32 8, %0
  %call = call noalias i8* @malloc(i32 %mul)
  %1 = bitcast i8* %call to double*
  store double* %1, double** %doubleArray, align 4
  %2 = load double*, double** %doubleArray, align 4
  %cmp = icmp eq double* %2, null
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %call1 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([34 x i8], [34 x i8]* @.str.12, i32 0, i32 0), i8* getelementptr inbounds ([23 x i8], [23 x i8]* @.str.1, i32 0, i32 0), i32 194)
  call void @perror(i8* getelementptr inbounds ([1 x i8], [1 x i8]* @.str.2, i32 0, i32 0))
  call void @exit(i32 1) #5
  unreachable

if.end:                                           ; preds = %entry
  store i32 0, i32* %index, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.end
  %3 = load i32, i32* %index, align 4
  %4 = load i32, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
  %cmp2 = icmp ult i32 %3, %4
  br i1 %cmp2, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %5 = load i32*, i32** %ARRAY.addr, align 4
  %6 = load i32, i32* %index, align 4
  %arrayidx = getelementptr inbounds i32, i32* %5, i32 %6
  %7 = load i32, i32* %arrayidx, align 4
  %conv = uitofp i32 %7 to double
  %8 = load double*, double** %doubleArray, align 4
  %9 = load i32, i32* %index, align 4
  %arrayidx3 = getelementptr inbounds double, double* %8, i32 %9
  store double %conv, double* %arrayidx3, align 8
  br label %for.inc

for.inc:                                          ; preds = %for.body
  %10 = load i32, i32* %index, align 4
  %inc = add i32 %10, 1
  store i32 %inc, i32* %index, align 4
  br label %for.cond

for.end:                                          ; preds = %for.cond
  %11 = load double*, double** %doubleArray, align 4
  ret double* %11
}

; Function Attrs: noinline nounwind optnone
define hidden double @min2(double %N1, double %N2) #0 {
entry:
  %retval = alloca double, align 8
  %N1.addr = alloca double, align 8
  %N2.addr = alloca double, align 8
  store double %N1, double* %N1.addr, align 8
  store double %N2, double* %N2.addr, align 8
  %0 = load double, double* %N1.addr, align 8
  %1 = load double, double* %N2.addr, align 8
  %cmp = fcmp olt double %0, %1
  br i1 %cmp, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  %2 = load double, double* %N1.addr, align 8
  store double %2, double* %retval, align 8
  br label %return

if.else:                                          ; preds = %entry
  %3 = load double, double* %N2.addr, align 8
  store double %3, double* %retval, align 8
  br label %return

return:                                           ; preds = %if.else, %if.then
  %4 = load double, double* %retval, align 8
  ret double %4
}

; Function Attrs: noinline nounwind optnone
define hidden double* @p_adjust(double* noalias %PVALUES, i32 %NO_OF_ARRAY_ELEMENTS, i8* noalias %STRING) #0 {
entry:
  %retval = alloca double*, align 4
  %PVALUES.addr = alloca double*, align 4
  %NO_OF_ARRAY_ELEMENTS.addr = alloca i32, align 4
  %STRING.addr = alloca i8*, align 4
  %TYPE = alloca i16, align 2
  %bonferroni = alloca double*, align 4
  %index = alloca i32, align 4
  %BONFERRONI = alloca double, align 8
  %o = alloca i32*, align 4
  %o2double = alloca double*, align 4
  %cummax_input = alloca double*, align 4
  %index80 = alloca i32, align 4
  %ro = alloca i32*, align 4
  %cummax_output = alloca double*, align 4
  %pmin = alloca double*, align 4
  %qvalues = alloca double*, align 4
  %index98 = alloca i32, align 4
  %o114 = alloca i32*, align 4
  %p = alloca double*, align 4
  %index123 = alloca i32, align 4
  %o2double134 = alloca double*, align 4
  %ro136 = alloca i32*, align 4
  %q = alloca double*, align 4
  %pa = alloca double*, align 4
  %min = alloca double, align 8
  %index155 = alloca i32, align 4
  %TEMP = alloca double, align 8
  %index171 = alloca i32, align 4
  %j = alloca i32, align 4
  %ij = alloca i32*, align 4
  %I2_LENGTH = alloca i32, align 4
  %i2 = alloca i32*, align 4
  %i = alloca i32, align 4
  %q1 = alloca double, align 8
  %i208 = alloca i32, align 4
  %TEMP_Q1 = alloca double, align 8
  %i227 = alloca i32, align 4
  %i244 = alloca i32, align 4
  %i256 = alloca i32, align 4
  %index274 = alloca i32, align 4
  %o288 = alloca i32*, align 4
  %o_double = alloca double*, align 4
  %index296 = alloca i32, align 4
  %ro315 = alloca i32*, align 4
  %cummin_input = alloca double*, align 4
  %index328 = alloca i32, align 4
  %NI = alloca double, align 8
  %q349 = alloca double, align 8
  %index350 = alloca i32, align 4
  %index362 = alloca i32, align 4
  %NI367 = alloca double, align 8
  %index385 = alloca i32, align 4
  %cummin_array = alloca double*, align 4
  %pmin403 = alloca double*, align 4
  %q_array = alloca double*, align 4
  %index407 = alloca i32, align 4
  store double* %PVALUES, double** %PVALUES.addr, align 4
  store i32 %NO_OF_ARRAY_ELEMENTS, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
  store i8* %STRING, i8** %STRING.addr, align 4
  %0 = load i32, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
  %cmp = icmp ult i32 %0, 1
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %call = call i32 @puts(i8* getelementptr inbounds ([41 x i8], [41 x i8]* @.str.13, i32 0, i32 0))
  %call1 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([22 x i8], [22 x i8]* @.str.5, i32 0, i32 0), i8* getelementptr inbounds ([23 x i8], [23 x i8]* @.str.1, i32 0, i32 0), i32 217)
  call void @exit(i32 1) #5
  unreachable

if.end:                                           ; preds = %entry
  store i16 -1, i16* %TYPE, align 2
  %1 = load i8*, i8** %STRING.addr, align 4
  %cmp2 = icmp eq i8* %1, null
  br i1 %cmp2, label %if.then3, label %if.else

if.then3:                                         ; preds = %if.end
  store i16 0, i16* %TYPE, align 2
  br label %if.end41

if.else:                                          ; preds = %if.end
  %2 = load i8*, i8** %STRING.addr, align 4
  %call4 = call i32 @strcasecmp(i8* %2, i8* getelementptr inbounds ([3 x i8], [3 x i8]* @.str.14, i32 0, i32 0))
  %cmp5 = icmp eq i32 %call4, 0
  br i1 %cmp5, label %if.then6, label %if.else7

if.then6:                                         ; preds = %if.else
  store i16 0, i16* %TYPE, align 2
  br label %if.end40

if.else7:                                         ; preds = %if.else
  %3 = load i8*, i8** %STRING.addr, align 4
  %call8 = call i32 @strcasecmp(i8* %3, i8* getelementptr inbounds ([4 x i8], [4 x i8]* @.str.15, i32 0, i32 0))
  %cmp9 = icmp eq i32 %call8, 0
  br i1 %cmp9, label %if.then10, label %if.else11

if.then10:                                        ; preds = %if.else7
  store i16 0, i16* %TYPE, align 2
  br label %if.end39

if.else11:                                        ; preds = %if.else7
  %4 = load i8*, i8** %STRING.addr, align 4
  %call12 = call i32 @strcasecmp(i8* %4, i8* getelementptr inbounds ([3 x i8], [3 x i8]* @.str.16, i32 0, i32 0))
  %cmp13 = icmp eq i32 %call12, 0
  br i1 %cmp13, label %if.then14, label %if.else15

if.then14:                                        ; preds = %if.else11
  store i16 1, i16* %TYPE, align 2
  br label %if.end38

if.else15:                                        ; preds = %if.else11
  %5 = load i8*, i8** %STRING.addr, align 4
  %call16 = call i32 @strcasecmp(i8* %5, i8* getelementptr inbounds ([11 x i8], [11 x i8]* @.str.17, i32 0, i32 0))
  %cmp17 = icmp eq i32 %call16, 0
  br i1 %cmp17, label %if.then18, label %if.else19

if.then18:                                        ; preds = %if.else15
  store i16 2, i16* %TYPE, align 2
  br label %if.end37

if.else19:                                        ; preds = %if.else15
  %6 = load i8*, i8** %STRING.addr, align 4
  %call20 = call i32 @strcasecmp(i8* %6, i8* getelementptr inbounds ([9 x i8], [9 x i8]* @.str.18, i32 0, i32 0))
  %cmp21 = icmp eq i32 %call20, 0
  br i1 %cmp21, label %if.then22, label %if.else23

if.then22:                                        ; preds = %if.else19
  store i16 3, i16* %TYPE, align 2
  br label %if.end36

if.else23:                                        ; preds = %if.else19
  %7 = load i8*, i8** %STRING.addr, align 4
  %call24 = call i32 @strcasecmp(i8* %7, i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.19, i32 0, i32 0))
  %cmp25 = icmp eq i32 %call24, 0
  br i1 %cmp25, label %if.then26, label %if.else27

if.then26:                                        ; preds = %if.else23
  store i16 4, i16* %TYPE, align 2
  br label %if.end35

if.else27:                                        ; preds = %if.else23
  %8 = load i8*, i8** %STRING.addr, align 4
  %call28 = call i32 @strcasecmp(i8* %8, i8* getelementptr inbounds ([7 x i8], [7 x i8]* @.str.20, i32 0, i32 0))
  %cmp29 = icmp eq i32 %call28, 0
  br i1 %cmp29, label %if.then30, label %if.else31

if.then30:                                        ; preds = %if.else27
  store i16 5, i16* %TYPE, align 2
  br label %if.end34

if.else31:                                        ; preds = %if.else27
  %9 = load i8*, i8** %STRING.addr, align 4
  %call32 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([44 x i8], [44 x i8]* @.str.21, i32 0, i32 0), i8* %9)
  %call33 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([22 x i8], [22 x i8]* @.str.5, i32 0, i32 0), i8* getelementptr inbounds ([23 x i8], [23 x i8]* @.str.1, i32 0, i32 0), i32 239)
  call void @exit(i32 1) #5
  unreachable

if.end34:                                         ; preds = %if.then30
  br label %if.end35

if.end35:                                         ; preds = %if.end34, %if.then26
  br label %if.end36

if.end36:                                         ; preds = %if.end35, %if.then22
  br label %if.end37

if.end37:                                         ; preds = %if.end36, %if.then18
  br label %if.end38

if.end38:                                         ; preds = %if.end37, %if.then14
  br label %if.end39

if.end39:                                         ; preds = %if.end38, %if.then10
  br label %if.end40

if.end40:                                         ; preds = %if.end39, %if.then6
  br label %if.end41

if.end41:                                         ; preds = %if.end40, %if.then3
  %10 = load i16, i16* %TYPE, align 2
  %conv = sext i16 %10 to i32
  %cmp42 = icmp eq i32 %conv, 2
  br i1 %cmp42, label %if.then44, label %if.else71

if.then44:                                        ; preds = %if.end41
  %11 = load i32, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
  %mul = mul i32 8, %11
  %call45 = call noalias i8* @malloc(i32 %mul)
  %12 = bitcast i8* %call45 to double*
  store double* %12, double** %bonferroni, align 4
  %13 = load double*, double** %bonferroni, align 4
  %cmp46 = icmp eq double* %13, null
  br i1 %cmp46, label %if.then48, label %if.end50

if.then48:                                        ; preds = %if.then44
  %call49 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([33 x i8], [33 x i8]* @.str.3, i32 0, i32 0), i8* getelementptr inbounds ([23 x i8], [23 x i8]* @.str.1, i32 0, i32 0), i32 247)
  call void @perror(i8* getelementptr inbounds ([1 x i8], [1 x i8]* @.str.2, i32 0, i32 0))
  call void @exit(i32 1) #5
  unreachable

if.end50:                                         ; preds = %if.then44
  store i32 0, i32* %index, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.end50
  %14 = load i32, i32* %index, align 4
  %15 = load i32, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
  %cmp51 = icmp ult i32 %14, %15
  br i1 %cmp51, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %16 = load double*, double** %PVALUES.addr, align 4
  %17 = load i32, i32* %index, align 4
  %arrayidx = getelementptr inbounds double, double* %16, i32 %17
  %18 = load double, double* %arrayidx, align 8
  %19 = load i32, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
  %conv53 = uitofp i32 %19 to double
  %mul54 = fmul double %18, %conv53
  store double %mul54, double* %BONFERRONI, align 8
  %20 = load double, double* %BONFERRONI, align 8
  %cmp55 = fcmp oge double %20, 1.000000e+00
  br i1 %cmp55, label %if.then57, label %if.else59

if.then57:                                        ; preds = %for.body
  %21 = load double*, double** %bonferroni, align 4
  %22 = load i32, i32* %index, align 4
  %arrayidx58 = getelementptr inbounds double, double* %21, i32 %22
  store double 1.000000e+00, double* %arrayidx58, align 8
  br label %if.end70

if.else59:                                        ; preds = %for.body
  %23 = load double, double* %BONFERRONI, align 8
  %cmp60 = fcmp ole double 0.000000e+00, %23
  br i1 %cmp60, label %land.lhs.true, label %if.else66

land.lhs.true:                                    ; preds = %if.else59
  %24 = load double, double* %BONFERRONI, align 8
  %cmp62 = fcmp olt double %24, 1.000000e+00
  br i1 %cmp62, label %if.then64, label %if.else66

if.then64:                                        ; preds = %land.lhs.true
  %25 = load double, double* %BONFERRONI, align 8
  %26 = load double*, double** %bonferroni, align 4
  %27 = load i32, i32* %index, align 4
  %arrayidx65 = getelementptr inbounds double, double* %26, i32 %27
  store double %25, double* %arrayidx65, align 8
  br label %if.end69

if.else66:                                        ; preds = %land.lhs.true, %if.else59
  %28 = load double, double* %BONFERRONI, align 8
  %call67 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([42 x i8], [42 x i8]* @.str.22, i32 0, i32 0), double %28)
  %call68 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([23 x i8], [23 x i8]* @.str.23, i32 0, i32 0), i8* getelementptr inbounds ([23 x i8], [23 x i8]* @.str.1, i32 0, i32 0), i32 259)
  call void @exit(i32 1) #5
  unreachable

if.end69:                                         ; preds = %if.then64
  br label %if.end70

if.end70:                                         ; preds = %if.end69, %if.then57
  br label %for.inc

for.inc:                                          ; preds = %if.end70
  %29 = load i32, i32* %index, align 4
  %inc = add i32 %29, 1
  store i32 %inc, i32* %index, align 4
  br label %for.cond

for.end:                                          ; preds = %for.cond
  %30 = load double*, double** %bonferroni, align 4
  store double* %30, double** %retval, align 4
  br label %return

if.else71:                                        ; preds = %if.end41
  %31 = load i16, i16* %TYPE, align 2
  %conv72 = sext i16 %31 to i32
  %cmp73 = icmp eq i32 %conv72, 4
  br i1 %cmp73, label %if.then75, label %if.else109

if.then75:                                        ; preds = %if.else71
  %32 = load double*, double** %PVALUES.addr, align 4
  %33 = load i32, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
  %call76 = call i32* @order(double* %32, i32 %33, i1 zeroext false)
  store i32* %call76, i32** %o, align 4
  %34 = load i32*, i32** %o, align 4
  %35 = load i32, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
  %call77 = call double* @uint2double(i32* %34, i32 %35)
  store double* %call77, double** %o2double, align 4
  %36 = load i32, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
  %mul78 = mul i32 8, %36
  %call79 = call noalias i8* @malloc(i32 %mul78)
  %37 = bitcast i8* %call79 to double*
  store double* %37, double** %cummax_input, align 4
  store i32 0, i32* %index80, align 4
  br label %for.cond81

for.cond81:                                       ; preds = %for.inc90, %if.then75
  %38 = load i32, i32* %index80, align 4
  %39 = load i32, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
  %cmp82 = icmp ult i32 %38, %39
  br i1 %cmp82, label %for.body84, label %for.end92

for.body84:                                       ; preds = %for.cond81
  %40 = load i32, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
  %41 = load i32, i32* %index80, align 4
  %sub = sub i32 %40, %41
  %conv85 = uitofp i32 %sub to double
  %42 = load double*, double** %PVALUES.addr, align 4
  %43 = load i32*, i32** %o, align 4
  %44 = load i32, i32* %index80, align 4
  %arrayidx86 = getelementptr inbounds i32, i32* %43, i32 %44
  %45 = load i32, i32* %arrayidx86, align 4
  %arrayidx87 = getelementptr inbounds double, double* %42, i32 %45
  %46 = load double, double* %arrayidx87, align 8
  %mul88 = fmul double %conv85, %46
  %47 = load double*, double** %cummax_input, align 4
  %48 = load i32, i32* %index80, align 4
  %arrayidx89 = getelementptr inbounds double, double* %47, i32 %48
  store double %mul88, double* %arrayidx89, align 8
  br label %for.inc90

for.inc90:                                        ; preds = %for.body84
  %49 = load i32, i32* %index80, align 4
  %inc91 = add i32 %49, 1
  store i32 %inc91, i32* %index80, align 4
  br label %for.cond81

for.end92:                                        ; preds = %for.cond81
  %50 = load i32*, i32** %o, align 4
  %51 = bitcast i32* %50 to i8*
  call void @free(i8* %51)
  store i32* null, i32** %o, align 4
  %52 = load double*, double** %o2double, align 4
  %53 = load i32, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
  %call93 = call i32* @order(double* %52, i32 %53, i1 zeroext false)
  store i32* %call93, i32** %ro, align 4
  %54 = load double*, double** %o2double, align 4
  %55 = bitcast double* %54 to i8*
  call void @free(i8* %55)
  store double* null, double** %o2double, align 4
  %56 = load double*, double** %cummax_input, align 4
  %57 = load i32, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
  %call94 = call double* @cummax(double* %56, i32 %57)
  store double* %call94, double** %cummax_output, align 4
  %58 = load double*, double** %cummax_input, align 4
  %59 = bitcast double* %58 to i8*
  call void @free(i8* %59)
  store double* null, double** %cummax_input, align 4
  %60 = load double*, double** %cummax_output, align 4
  %61 = load i32, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
  %call95 = call double* @pminx(double* %60, i32 %61, double 1.000000e+00)
  store double* %call95, double** %pmin, align 4
  %62 = load double*, double** %cummax_output, align 4
  %63 = bitcast double* %62 to i8*
  call void @free(i8* %63)
  store double* null, double** %cummax_output, align 4
  %64 = load i32, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
  %mul96 = mul i32 8, %64
  %call97 = call noalias i8* @malloc(i32 %mul96)
  %65 = bitcast i8* %call97 to double*
  store double* %65, double** %qvalues, align 4
  store i32 0, i32* %index98, align 4
  br label %for.cond99

for.cond99:                                       ; preds = %for.inc106, %for.end92
  %66 = load i32, i32* %index98, align 4
  %67 = load i32, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
  %cmp100 = icmp ult i32 %66, %67
  br i1 %cmp100, label %for.body102, label %for.end108

for.body102:                                      ; preds = %for.cond99
  %68 = load double*, double** %pmin, align 4
  %69 = load i32*, i32** %ro, align 4
  %70 = load i32, i32* %index98, align 4
  %arrayidx103 = getelementptr inbounds i32, i32* %69, i32 %70
  %71 = load i32, i32* %arrayidx103, align 4
  %arrayidx104 = getelementptr inbounds double, double* %68, i32 %71
  %72 = load double, double* %arrayidx104, align 8
  %73 = load double*, double** %qvalues, align 4
  %74 = load i32, i32* %index98, align 4
  %arrayidx105 = getelementptr inbounds double, double* %73, i32 %74
  store double %72, double* %arrayidx105, align 8
  br label %for.inc106

for.inc106:                                       ; preds = %for.body102
  %75 = load i32, i32* %index98, align 4
  %inc107 = add i32 %75, 1
  store i32 %inc107, i32* %index98, align 4
  br label %for.cond99

for.end108:                                       ; preds = %for.cond99
  %76 = load double*, double** %pmin, align 4
  %77 = bitcast double* %76 to i8*
  call void @free(i8* %77)
  store double* null, double** %pmin, align 4
  %78 = load i32*, i32** %ro, align 4
  %79 = bitcast i32* %78 to i8*
  call void @free(i8* %79)
  store i32* null, i32** %ro, align 4
  %80 = load double*, double** %qvalues, align 4
  store double* %80, double** %retval, align 4
  br label %return

if.else109:                                       ; preds = %if.else71
  %81 = load i16, i16* %TYPE, align 2
  %conv110 = sext i16 %81 to i32
  %cmp111 = icmp eq i32 %conv110, 5
  br i1 %cmp111, label %if.then113, label %if.end285

if.then113:                                       ; preds = %if.else109
  %82 = load double*, double** %PVALUES.addr, align 4
  %83 = load i32, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
  %call115 = call i32* @order(double* %82, i32 %83, i1 zeroext false)
  store i32* %call115, i32** %o114, align 4
  %84 = load i32, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
  %mul116 = mul i32 8, %84
  %call117 = call noalias i8* @malloc(i32 %mul116)
  %85 = bitcast i8* %call117 to double*
  store double* %85, double** %p, align 4
  %86 = load double*, double** %p, align 4
  %cmp118 = icmp eq double* %86, null
  br i1 %cmp118, label %if.then120, label %if.end122

if.then120:                                       ; preds = %if.then113
  %call121 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([33 x i8], [33 x i8]* @.str.3, i32 0, i32 0), i8* getelementptr inbounds ([23 x i8], [23 x i8]* @.str.1, i32 0, i32 0), i32 302)
  call void @perror(i8* getelementptr inbounds ([1 x i8], [1 x i8]* @.str.2, i32 0, i32 0))
  call void @exit(i32 1) #5
  unreachable

if.end122:                                        ; preds = %if.then113
  store i32 0, i32* %index123, align 4
  br label %for.cond124

for.cond124:                                      ; preds = %for.inc131, %if.end122
  %87 = load i32, i32* %index123, align 4
  %88 = load i32, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
  %cmp125 = icmp ult i32 %87, %88
  br i1 %cmp125, label %for.body127, label %for.end133

for.body127:                                      ; preds = %for.cond124
  %89 = load double*, double** %PVALUES.addr, align 4
  %90 = load i32*, i32** %o114, align 4
  %91 = load i32, i32* %index123, align 4
  %arrayidx128 = getelementptr inbounds i32, i32* %90, i32 %91
  %92 = load i32, i32* %arrayidx128, align 4
  %arrayidx129 = getelementptr inbounds double, double* %89, i32 %92
  %93 = load double, double* %arrayidx129, align 8
  %94 = load double*, double** %p, align 4
  %95 = load i32, i32* %index123, align 4
  %arrayidx130 = getelementptr inbounds double, double* %94, i32 %95
  store double %93, double* %arrayidx130, align 8
  br label %for.inc131

for.inc131:                                       ; preds = %for.body127
  %96 = load i32, i32* %index123, align 4
  %inc132 = add i32 %96, 1
  store i32 %inc132, i32* %index123, align 4
  br label %for.cond124

for.end133:                                       ; preds = %for.cond124
  %97 = load i32*, i32** %o114, align 4
  %98 = load i32, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
  %call135 = call double* @uint2double(i32* %97, i32 %98)
  store double* %call135, double** %o2double134, align 4
  %99 = load i32*, i32** %o114, align 4
  %100 = bitcast i32* %99 to i8*
  call void @free(i8* %100)
  store i32* null, i32** %o114, align 4
  %101 = load double*, double** %o2double134, align 4
  %102 = load i32, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
  %call137 = call i32* @order(double* %101, i32 %102, i1 zeroext false)
  store i32* %call137, i32** %ro136, align 4
  %103 = load double*, double** %o2double134, align 4
  %104 = bitcast double* %103 to i8*
  call void @free(i8* %104)
  store double* null, double** %o2double134, align 4
  %105 = load i32, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
  %mul138 = mul i32 8, %105
  %call139 = call noalias i8* @malloc(i32 %mul138)
  %106 = bitcast i8* %call139 to double*
  store double* %106, double** %q, align 4
  %107 = load double*, double** %q, align 4
  %cmp140 = icmp eq double* %107, null
  br i1 %cmp140, label %if.then142, label %if.end144

if.then142:                                       ; preds = %for.end133
  %call143 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([33 x i8], [33 x i8]* @.str.3, i32 0, i32 0), i8* getelementptr inbounds ([23 x i8], [23 x i8]* @.str.1, i32 0, i32 0), i32 318)
  call void @perror(i8* getelementptr inbounds ([1 x i8], [1 x i8]* @.str.2, i32 0, i32 0))
  call void @exit(i32 1) #5
  unreachable

if.end144:                                        ; preds = %for.end133
  %108 = load i32, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
  %mul145 = mul i32 8, %108
  %call146 = call noalias i8* @malloc(i32 %mul145)
  %109 = bitcast i8* %call146 to double*
  store double* %109, double** %pa, align 4
  %110 = load double*, double** %pa, align 4
  %cmp147 = icmp eq double* %110, null
  br i1 %cmp147, label %if.then149, label %if.end151

if.then149:                                       ; preds = %if.end144
  %call150 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([33 x i8], [33 x i8]* @.str.3, i32 0, i32 0), i8* getelementptr inbounds ([23 x i8], [23 x i8]* @.str.1, i32 0, i32 0), i32 324)
  call void @perror(i8* getelementptr inbounds ([1 x i8], [1 x i8]* @.str.2, i32 0, i32 0))
  call void @exit(i32 1) #5
  unreachable

if.end151:                                        ; preds = %if.end144
  %111 = load i32, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
  %conv152 = uitofp i32 %111 to double
  %112 = load double*, double** %p, align 4
  %arrayidx153 = getelementptr inbounds double, double* %112, i32 0
  %113 = load double, double* %arrayidx153, align 8
  %mul154 = fmul double %conv152, %113
  store double %mul154, double* %min, align 8
  store i32 1, i32* %index155, align 4
  br label %for.cond156

for.cond156:                                      ; preds = %for.inc168, %if.end151
  %114 = load i32, i32* %index155, align 4
  %115 = load i32, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
  %cmp157 = icmp ult i32 %114, %115
  br i1 %cmp157, label %for.body159, label %for.end170

for.body159:                                      ; preds = %for.cond156
  %116 = load i32, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
  %conv160 = uitofp i32 %116 to double
  %117 = load double*, double** %p, align 4
  %118 = load i32, i32* %index155, align 4
  %arrayidx161 = getelementptr inbounds double, double* %117, i32 %118
  %119 = load double, double* %arrayidx161, align 8
  %mul162 = fmul double %conv160, %119
  %120 = load i32, i32* %index155, align 4
  %add = add i32 1, %120
  %conv163 = uitofp i32 %add to double
  %div = fdiv double %mul162, %conv163
  store double %div, double* %TEMP, align 8
  %121 = load double, double* %TEMP, align 8
  %122 = load double, double* %min, align 8
  %cmp164 = fcmp olt double %121, %122
  br i1 %cmp164, label %if.then166, label %if.end167

if.then166:                                       ; preds = %for.body159
  %123 = load double, double* %TEMP, align 8
  store double %123, double* %min, align 8
  br label %if.end167

if.end167:                                        ; preds = %if.then166, %for.body159
  br label %for.inc168

for.inc168:                                       ; preds = %if.end167
  %124 = load i32, i32* %index155, align 4
  %inc169 = add i32 %124, 1
  store i32 %inc169, i32* %index155, align 4
  br label %for.cond156

for.end170:                                       ; preds = %for.cond156
  store i32 0, i32* %index171, align 4
  br label %for.cond172

for.cond172:                                      ; preds = %for.inc178, %for.end170
  %125 = load i32, i32* %index171, align 4
  %126 = load i32, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
  %cmp173 = icmp ult i32 %125, %126
  br i1 %cmp173, label %for.body175, label %for.end180

for.body175:                                      ; preds = %for.cond172
  %127 = load double, double* %min, align 8
  %128 = load double*, double** %pa, align 4
  %129 = load i32, i32* %index171, align 4
  %arrayidx176 = getelementptr inbounds double, double* %128, i32 %129
  store double %127, double* %arrayidx176, align 8
  %130 = load double, double* %min, align 8
  %131 = load double*, double** %q, align 4
  %132 = load i32, i32* %index171, align 4
  %arrayidx177 = getelementptr inbounds double, double* %131, i32 %132
  store double %130, double* %arrayidx177, align 8
  br label %for.inc178

for.inc178:                                       ; preds = %for.body175
  %133 = load i32, i32* %index171, align 4
  %inc179 = add i32 %133, 1
  store i32 %inc179, i32* %index171, align 4
  br label %for.cond172

for.end180:                                       ; preds = %for.cond172
  %134 = load i32, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
  %sub181 = sub i32 %134, 1
  store i32 %sub181, i32* %j, align 4
  br label %for.cond182

for.cond182:                                      ; preds = %for.inc272, %for.end180
  %135 = load i32, i32* %j, align 4
  %cmp183 = icmp uge i32 %135, 2
  br i1 %cmp183, label %for.body185, label %for.end273

for.body185:                                      ; preds = %for.cond182
  %136 = load i32, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
  %137 = load i32, i32* %j, align 4
  %sub186 = sub i32 %136, %137
  %call187 = call i32* @seq_len(i32 0, i32 %sub186)
  store i32* %call187, i32** %ij, align 4
  %138 = load i32, i32* %j, align 4
  %sub188 = sub i32 %138, 1
  store i32 %sub188, i32* %I2_LENGTH, align 4
  %139 = load i32, i32* %I2_LENGTH, align 4
  %mul189 = mul i32 %139, 4
  %call190 = call noalias i8* @malloc(i32 %mul189)
  %140 = bitcast i8* %call190 to i32*
  store i32* %140, i32** %i2, align 4
  store i32 0, i32* %i, align 4
  br label %for.cond191

for.cond191:                                      ; preds = %for.inc200, %for.body185
  %141 = load i32, i32* %i, align 4
  %142 = load i32, i32* %I2_LENGTH, align 4
  %cmp192 = icmp ult i32 %141, %142
  br i1 %cmp192, label %for.body194, label %for.end202

for.body194:                                      ; preds = %for.cond191
  %143 = load i32, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
  %144 = load i32, i32* %j, align 4
  %sub195 = sub i32 %143, %144
  %add196 = add i32 %sub195, 2
  %145 = load i32, i32* %i, align 4
  %add197 = add i32 %add196, %145
  %sub198 = sub i32 %add197, 1
  %146 = load i32*, i32** %i2, align 4
  %147 = load i32, i32* %i, align 4
  %arrayidx199 = getelementptr inbounds i32, i32* %146, i32 %147
  store i32 %sub198, i32* %arrayidx199, align 4
  br label %for.inc200

for.inc200:                                       ; preds = %for.body194
  %148 = load i32, i32* %i, align 4
  %inc201 = add i32 %148, 1
  store i32 %inc201, i32* %i, align 4
  br label %for.cond191

for.end202:                                       ; preds = %for.cond191
  %149 = load i32, i32* %j, align 4
  %conv203 = uitofp i32 %149 to double
  %150 = load double*, double** %p, align 4
  %151 = load i32*, i32** %i2, align 4
  %arrayidx204 = getelementptr inbounds i32, i32* %151, i32 0
  %152 = load i32, i32* %arrayidx204, align 4
  %arrayidx205 = getelementptr inbounds double, double* %150, i32 %152
  %153 = load double, double* %arrayidx205, align 8
  %mul206 = fmul double %conv203, %153
  %div207 = fdiv double %mul206, 2.000000e+00
  store double %div207, double* %q1, align 8
  store i32 1, i32* %i208, align 4
  br label %for.cond209

for.cond209:                                      ; preds = %for.inc224, %for.end202
  %154 = load i32, i32* %i208, align 4
  %155 = load i32, i32* %I2_LENGTH, align 4
  %cmp210 = icmp ult i32 %154, %155
  br i1 %cmp210, label %for.body212, label %for.end226

for.body212:                                      ; preds = %for.cond209
  %156 = load i32, i32* %j, align 4
  %conv213 = uitofp i32 %156 to double
  %157 = load double*, double** %p, align 4
  %158 = load i32*, i32** %i2, align 4
  %159 = load i32, i32* %i208, align 4
  %arrayidx214 = getelementptr inbounds i32, i32* %158, i32 %159
  %160 = load i32, i32* %arrayidx214, align 4
  %arrayidx215 = getelementptr inbounds double, double* %157, i32 %160
  %161 = load double, double* %arrayidx215, align 8
  %mul216 = fmul double %conv213, %161
  %162 = load i32, i32* %i208, align 4
  %add217 = add i32 2, %162
  %conv218 = uitofp i32 %add217 to double
  %div219 = fdiv double %mul216, %conv218
  store double %div219, double* %TEMP_Q1, align 8
  %163 = load double, double* %TEMP_Q1, align 8
  %164 = load double, double* %q1, align 8
  %cmp220 = fcmp olt double %163, %164
  br i1 %cmp220, label %if.then222, label %if.end223

if.then222:                                       ; preds = %for.body212
  %165 = load double, double* %TEMP_Q1, align 8
  store double %165, double* %q1, align 8
  br label %if.end223

if.end223:                                        ; preds = %if.then222, %for.body212
  br label %for.inc224

for.inc224:                                       ; preds = %if.end223
  %166 = load i32, i32* %i208, align 4
  %inc225 = add i32 %166, 1
  store i32 %inc225, i32* %i208, align 4
  br label %for.cond209

for.end226:                                       ; preds = %for.cond209
  store i32 0, i32* %i227, align 4
  br label %for.cond228

for.cond228:                                      ; preds = %for.inc241, %for.end226
  %167 = load i32, i32* %i227, align 4
  %168 = load i32, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
  %169 = load i32, i32* %j, align 4
  %sub229 = sub i32 %168, %169
  %add230 = add i32 %sub229, 1
  %cmp231 = icmp ult i32 %167, %add230
  br i1 %cmp231, label %for.body233, label %for.end243

for.body233:                                      ; preds = %for.cond228
  %170 = load i32, i32* %j, align 4
  %conv234 = uitofp i32 %170 to double
  %171 = load double*, double** %p, align 4
  %172 = load i32*, i32** %ij, align 4
  %173 = load i32, i32* %i227, align 4
  %arrayidx235 = getelementptr inbounds i32, i32* %172, i32 %173
  %174 = load i32, i32* %arrayidx235, align 4
  %arrayidx236 = getelementptr inbounds double, double* %171, i32 %174
  %175 = load double, double* %arrayidx236, align 8
  %mul237 = fmul double %conv234, %175
  %176 = load double, double* %q1, align 8
  %call238 = call double @min2(double %mul237, double %176)
  %177 = load double*, double** %q, align 4
  %178 = load i32*, i32** %ij, align 4
  %179 = load i32, i32* %i227, align 4
  %arrayidx239 = getelementptr inbounds i32, i32* %178, i32 %179
  %180 = load i32, i32* %arrayidx239, align 4
  %arrayidx240 = getelementptr inbounds double, double* %177, i32 %180
  store double %call238, double* %arrayidx240, align 8
  br label %for.inc241

for.inc241:                                       ; preds = %for.body233
  %181 = load i32, i32* %i227, align 4
  %inc242 = add i32 %181, 1
  store i32 %inc242, i32* %i227, align 4
  br label %for.cond228

for.end243:                                       ; preds = %for.cond228
  %182 = load i32*, i32** %ij, align 4
  %183 = bitcast i32* %182 to i8*
  call void @free(i8* %183)
  store i32* null, i32** %ij, align 4
  store i32 0, i32* %i244, align 4
  br label %for.cond245

for.cond245:                                      ; preds = %for.inc253, %for.end243
  %184 = load i32, i32* %i244, align 4
  %185 = load i32, i32* %I2_LENGTH, align 4
  %cmp246 = icmp ult i32 %184, %185
  br i1 %cmp246, label %for.body248, label %for.end255

for.body248:                                      ; preds = %for.cond245
  %186 = load double*, double** %q, align 4
  %187 = load i32, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
  %188 = load i32, i32* %j, align 4
  %sub249 = sub i32 %187, %188
  %arrayidx250 = getelementptr inbounds double, double* %186, i32 %sub249
  %189 = load double, double* %arrayidx250, align 8
  %190 = load double*, double** %q, align 4
  %191 = load i32*, i32** %i2, align 4
  %192 = load i32, i32* %i244, align 4
  %arrayidx251 = getelementptr inbounds i32, i32* %191, i32 %192
  %193 = load i32, i32* %arrayidx251, align 4
  %arrayidx252 = getelementptr inbounds double, double* %190, i32 %193
  store double %189, double* %arrayidx252, align 8
  br label %for.inc253

for.inc253:                                       ; preds = %for.body248
  %194 = load i32, i32* %i244, align 4
  %inc254 = add i32 %194, 1
  store i32 %inc254, i32* %i244, align 4
  br label %for.cond245

for.end255:                                       ; preds = %for.cond245
  %195 = load i32*, i32** %i2, align 4
  %196 = bitcast i32* %195 to i8*
  call void @free(i8* %196)
  store i32* null, i32** %i2, align 4
  store i32 0, i32* %i256, align 4
  br label %for.cond257

for.cond257:                                      ; preds = %for.inc269, %for.end255
  %197 = load i32, i32* %i256, align 4
  %198 = load i32, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
  %cmp258 = icmp ult i32 %197, %198
  br i1 %cmp258, label %for.body260, label %for.end271

for.body260:                                      ; preds = %for.cond257
  %199 = load double*, double** %pa, align 4
  %200 = load i32, i32* %i256, align 4
  %arrayidx261 = getelementptr inbounds double, double* %199, i32 %200
  %201 = load double, double* %arrayidx261, align 8
  %202 = load double*, double** %q, align 4
  %203 = load i32, i32* %i256, align 4
  %arrayidx262 = getelementptr inbounds double, double* %202, i32 %203
  %204 = load double, double* %arrayidx262, align 8
  %cmp263 = fcmp olt double %201, %204
  br i1 %cmp263, label %if.then265, label %if.end268

if.then265:                                       ; preds = %for.body260
  %205 = load double*, double** %q, align 4
  %206 = load i32, i32* %i256, align 4
  %arrayidx266 = getelementptr inbounds double, double* %205, i32 %206
  %207 = load double, double* %arrayidx266, align 8
  %208 = load double*, double** %pa, align 4
  %209 = load i32, i32* %i256, align 4
  %arrayidx267 = getelementptr inbounds double, double* %208, i32 %209
  store double %207, double* %arrayidx267, align 8
  br label %if.end268

if.end268:                                        ; preds = %if.then265, %for.body260
  br label %for.inc269

for.inc269:                                       ; preds = %if.end268
  %210 = load i32, i32* %i256, align 4
  %inc270 = add i32 %210, 1
  store i32 %inc270, i32* %i256, align 4
  br label %for.cond257

for.end271:                                       ; preds = %for.cond257
  br label %for.inc272

for.inc272:                                       ; preds = %for.end271
  %211 = load i32, i32* %j, align 4
  %dec = add i32 %211, -1
  store i32 %dec, i32* %j, align 4
  br label %for.cond182

for.end273:                                       ; preds = %for.cond182
  %212 = load double*, double** %p, align 4
  %213 = bitcast double* %212 to i8*
  call void @free(i8* %213)
  store double* null, double** %p, align 4
  store i32 0, i32* %index274, align 4
  br label %for.cond275

for.cond275:                                      ; preds = %for.inc282, %for.end273
  %214 = load i32, i32* %index274, align 4
  %215 = load i32, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
  %cmp276 = icmp ult i32 %214, %215
  br i1 %cmp276, label %for.body278, label %for.end284

for.body278:                                      ; preds = %for.cond275
  %216 = load double*, double** %pa, align 4
  %217 = load i32*, i32** %ro136, align 4
  %218 = load i32, i32* %index274, align 4
  %arrayidx279 = getelementptr inbounds i32, i32* %217, i32 %218
  %219 = load i32, i32* %arrayidx279, align 4
  %arrayidx280 = getelementptr inbounds double, double* %216, i32 %219
  %220 = load double, double* %arrayidx280, align 8
  %221 = load double*, double** %q, align 4
  %222 = load i32, i32* %index274, align 4
  %arrayidx281 = getelementptr inbounds double, double* %221, i32 %222
  store double %220, double* %arrayidx281, align 8
  br label %for.inc282

for.inc282:                                       ; preds = %for.body278
  %223 = load i32, i32* %index274, align 4
  %inc283 = add i32 %223, 1
  store i32 %inc283, i32* %index274, align 4
  br label %for.cond275

for.end284:                                       ; preds = %for.cond275
  %224 = load i32*, i32** %ro136, align 4
  %225 = bitcast i32* %224 to i8*
  call void @free(i8* %225)
  store i32* null, i32** %ro136, align 4
  %226 = load double*, double** %pa, align 4
  %227 = bitcast double* %226 to i8*
  call void @free(i8* %227)
  store double* null, double** %pa, align 4
  %228 = load double*, double** %q, align 4
  store double* %228, double** %retval, align 4
  br label %return

if.end285:                                        ; preds = %if.else109
  br label %if.end286

if.end286:                                        ; preds = %if.end285
  br label %if.end287

if.end287:                                        ; preds = %if.end286
  %229 = load double*, double** %PVALUES.addr, align 4
  %230 = load i32, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
  %call289 = call i32* @order(double* %229, i32 %230, i1 zeroext true)
  store i32* %call289, i32** %o288, align 4
  %231 = load i32*, i32** %o288, align 4
  %cmp290 = icmp eq i32* %231, null
  br i1 %cmp290, label %if.then292, label %if.end294

if.then292:                                       ; preds = %if.end287
  %call293 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([33 x i8], [33 x i8]* @.str.3, i32 0, i32 0), i8* getelementptr inbounds ([23 x i8], [23 x i8]* @.str.1, i32 0, i32 0), i32 398)
  call void @perror(i8* getelementptr inbounds ([1 x i8], [1 x i8]* @.str.2, i32 0, i32 0))
  call void @exit(i32 1) #5
  unreachable

if.end294:                                        ; preds = %if.end287
  %232 = load i32*, i32** %o288, align 4
  %233 = load i32, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
  %call295 = call double* @uint2double(i32* %232, i32 %233)
  store double* %call295, double** %o_double, align 4
  store i32 0, i32* %index296, align 4
  br label %for.cond297

for.cond297:                                      ; preds = %for.inc312, %if.end294
  %234 = load i32, i32* %index296, align 4
  %235 = load i32, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
  %cmp298 = icmp ult i32 %234, %235
  br i1 %cmp298, label %for.body300, label %for.end314

for.body300:                                      ; preds = %for.cond297
  %236 = load double*, double** %PVALUES.addr, align 4
  %237 = load i32, i32* %index296, align 4
  %arrayidx301 = getelementptr inbounds double, double* %236, i32 %237
  %238 = load double, double* %arrayidx301, align 8
  %cmp302 = fcmp olt double %238, 0.000000e+00
  br i1 %cmp302, label %if.then307, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %for.body300
  %239 = load double*, double** %PVALUES.addr, align 4
  %240 = load i32, i32* %index296, align 4
  %arrayidx304 = getelementptr inbounds double, double* %239, i32 %240
  %241 = load double, double* %arrayidx304, align 8
  %cmp305 = fcmp ogt double %241, 1.000000e+00
  br i1 %cmp305, label %if.then307, label %if.end311

if.then307:                                       ; preds = %lor.lhs.false, %for.body300
  %242 = load i32, i32* %index296, align 4
  %243 = load double*, double** %PVALUES.addr, align 4
  %244 = load i32, i32* %index296, align 4
  %arrayidx308 = getelementptr inbounds double, double* %243, i32 %244
  %245 = load double, double* %arrayidx308, align 8
  %call309 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([54 x i8], [54 x i8]* @.str.24, i32 0, i32 0), i32 %242, double %245)
  %call310 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([20 x i8], [20 x i8]* @.str.25, i32 0, i32 0), i8* getelementptr inbounds ([23 x i8], [23 x i8]* @.str.1, i32 0, i32 0), i32 406)
  call void @exit(i32 1) #5
  unreachable

if.end311:                                        ; preds = %lor.lhs.false
  br label %for.inc312

for.inc312:                                       ; preds = %if.end311
  %246 = load i32, i32* %index296, align 4
  %inc313 = add i32 %246, 1
  store i32 %inc313, i32* %index296, align 4
  br label %for.cond297

for.end314:                                       ; preds = %for.cond297
  %247 = load double*, double** %o_double, align 4
  %248 = load i32, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
  %call316 = call i32* @order(double* %247, i32 %248, i1 zeroext false)
  store i32* %call316, i32** %ro315, align 4
  %249 = load i32*, i32** %ro315, align 4
  %cmp317 = icmp eq i32* %249, null
  br i1 %cmp317, label %if.then319, label %if.end321

if.then319:                                       ; preds = %for.end314
  %call320 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([33 x i8], [33 x i8]* @.str.3, i32 0, i32 0), i8* getelementptr inbounds ([23 x i8], [23 x i8]* @.str.1, i32 0, i32 0), i32 413)
  call void @perror(i8* getelementptr inbounds ([1 x i8], [1 x i8]* @.str.2, i32 0, i32 0))
  call void @exit(i32 1) #5
  unreachable

if.end321:                                        ; preds = %for.end314
  %250 = load double*, double** %o_double, align 4
  %251 = bitcast double* %250 to i8*
  call void @free(i8* %251)
  store double* null, double** %o_double, align 4
  %252 = load i32, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
  %mul322 = mul i32 8, %252
  %call323 = call noalias i8* @malloc(i32 %mul322)
  %253 = bitcast i8* %call323 to double*
  store double* %253, double** %cummin_input, align 4
  %254 = load i16, i16* %TYPE, align 2
  %conv324 = sext i16 %254 to i32
  %cmp325 = icmp eq i32 %conv324, 0
  br i1 %cmp325, label %if.then327, label %if.else344

if.then327:                                       ; preds = %if.end321
  store i32 0, i32* %index328, align 4
  br label %for.cond329

for.cond329:                                      ; preds = %for.inc341, %if.then327
  %255 = load i32, i32* %index328, align 4
  %256 = load i32, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
  %cmp330 = icmp ult i32 %255, %256
  br i1 %cmp330, label %for.body332, label %for.end343

for.body332:                                      ; preds = %for.cond329
  %257 = load i32, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
  %conv333 = uitofp i32 %257 to double
  %258 = load i32, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
  %259 = load i32, i32* %index328, align 4
  %sub334 = sub i32 %258, %259
  %conv335 = uitofp i32 %sub334 to double
  %div336 = fdiv double %conv333, %conv335
  store double %div336, double* %NI, align 8
  %260 = load double, double* %NI, align 8
  %261 = load double*, double** %PVALUES.addr, align 4
  %262 = load i32*, i32** %o288, align 4
  %263 = load i32, i32* %index328, align 4
  %arrayidx337 = getelementptr inbounds i32, i32* %262, i32 %263
  %264 = load i32, i32* %arrayidx337, align 4
  %arrayidx338 = getelementptr inbounds double, double* %261, i32 %264
  %265 = load double, double* %arrayidx338, align 8
  %mul339 = fmul double %260, %265
  %266 = load double*, double** %cummin_input, align 4
  %267 = load i32, i32* %index328, align 4
  %arrayidx340 = getelementptr inbounds double, double* %266, i32 %267
  store double %mul339, double* %arrayidx340, align 8
  br label %for.inc341

for.inc341:                                       ; preds = %for.body332
  %268 = load i32, i32* %index328, align 4
  %inc342 = add i32 %268, 1
  store i32 %inc342, i32* %index328, align 4
  br label %for.cond329

for.end343:                                       ; preds = %for.cond329
  br label %if.end401

if.else344:                                       ; preds = %if.end321
  %269 = load i16, i16* %TYPE, align 2
  %conv345 = sext i16 %269 to i32
  %cmp346 = icmp eq i32 %conv345, 1
  br i1 %cmp346, label %if.then348, label %if.else380

if.then348:                                       ; preds = %if.else344
  store double 1.000000e+00, double* %q349, align 8
  store i32 2, i32* %index350, align 4
  br label %for.cond351

for.cond351:                                      ; preds = %for.inc359, %if.then348
  %270 = load i32, i32* %index350, align 4
  %271 = load i32, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
  %add352 = add i32 1, %271
  %cmp353 = icmp ult i32 %270, %add352
  br i1 %cmp353, label %for.body355, label %for.end361

for.body355:                                      ; preds = %for.cond351
  %272 = load i32, i32* %index350, align 4
  %conv356 = uitofp i32 %272 to double
  %div357 = fdiv double 1.000000e+00, %conv356
  %273 = load double, double* %q349, align 8
  %add358 = fadd double %273, %div357
  store double %add358, double* %q349, align 8
  br label %for.inc359

for.inc359:                                       ; preds = %for.body355
  %274 = load i32, i32* %index350, align 4
  %inc360 = add i32 %274, 1
  store i32 %inc360, i32* %index350, align 4
  br label %for.cond351

for.end361:                                       ; preds = %for.cond351
  store i32 0, i32* %index362, align 4
  br label %for.cond363

for.cond363:                                      ; preds = %for.inc377, %for.end361
  %275 = load i32, i32* %index362, align 4
  %276 = load i32, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
  %cmp364 = icmp ult i32 %275, %276
  br i1 %cmp364, label %for.body366, label %for.end379

for.body366:                                      ; preds = %for.cond363
  %277 = load i32, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
  %conv368 = uitofp i32 %277 to double
  %278 = load i32, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
  %279 = load i32, i32* %index362, align 4
  %sub369 = sub i32 %278, %279
  %conv370 = uitofp i32 %sub369 to double
  %div371 = fdiv double %conv368, %conv370
  store double %div371, double* %NI367, align 8
  %280 = load double, double* %q349, align 8
  %281 = load double, double* %NI367, align 8
  %mul372 = fmul double %280, %281
  %282 = load double*, double** %PVALUES.addr, align 4
  %283 = load i32*, i32** %o288, align 4
  %284 = load i32, i32* %index362, align 4
  %arrayidx373 = getelementptr inbounds i32, i32* %283, i32 %284
  %285 = load i32, i32* %arrayidx373, align 4
  %arrayidx374 = getelementptr inbounds double, double* %282, i32 %285
  %286 = load double, double* %arrayidx374, align 8
  %mul375 = fmul double %mul372, %286
  %287 = load double*, double** %cummin_input, align 4
  %288 = load i32, i32* %index362, align 4
  %arrayidx376 = getelementptr inbounds double, double* %287, i32 %288
  store double %mul375, double* %arrayidx376, align 8
  br label %for.inc377

for.inc377:                                       ; preds = %for.body366
  %289 = load i32, i32* %index362, align 4
  %inc378 = add i32 %289, 1
  store i32 %inc378, i32* %index362, align 4
  br label %for.cond363

for.end379:                                       ; preds = %for.cond363
  br label %if.end400

if.else380:                                       ; preds = %if.else344
  %290 = load i16, i16* %TYPE, align 2
  %conv381 = sext i16 %290 to i32
  %cmp382 = icmp eq i32 %conv381, 3
  br i1 %cmp382, label %if.then384, label %if.end399

if.then384:                                       ; preds = %if.else380
  store i32 0, i32* %index385, align 4
  br label %for.cond386

for.cond386:                                      ; preds = %for.inc396, %if.then384
  %291 = load i32, i32* %index385, align 4
  %292 = load i32, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
  %cmp387 = icmp ult i32 %291, %292
  br i1 %cmp387, label %for.body389, label %for.end398

for.body389:                                      ; preds = %for.cond386
  %293 = load i32, i32* %index385, align 4
  %add390 = add i32 %293, 1
  %conv391 = uitofp i32 %add390 to double
  %294 = load double*, double** %PVALUES.addr, align 4
  %295 = load i32*, i32** %o288, align 4
  %296 = load i32, i32* %index385, align 4
  %arrayidx392 = getelementptr inbounds i32, i32* %295, i32 %296
  %297 = load i32, i32* %arrayidx392, align 4
  %arrayidx393 = getelementptr inbounds double, double* %294, i32 %297
  %298 = load double, double* %arrayidx393, align 8
  %mul394 = fmul double %conv391, %298
  %299 = load double*, double** %cummin_input, align 4
  %300 = load i32, i32* %index385, align 4
  %arrayidx395 = getelementptr inbounds double, double* %299, i32 %300
  store double %mul394, double* %arrayidx395, align 8
  br label %for.inc396

for.inc396:                                       ; preds = %for.body389
  %301 = load i32, i32* %index385, align 4
  %inc397 = add i32 %301, 1
  store i32 %inc397, i32* %index385, align 4
  br label %for.cond386

for.end398:                                       ; preds = %for.cond386
  br label %if.end399

if.end399:                                        ; preds = %for.end398, %if.else380
  br label %if.end400

if.end400:                                        ; preds = %if.end399, %for.end379
  br label %if.end401

if.end401:                                        ; preds = %if.end400, %for.end343
  %302 = load i32*, i32** %o288, align 4
  %303 = bitcast i32* %302 to i8*
  call void @free(i8* %303)
  store i32* null, i32** %o288, align 4
  store double* null, double** %cummin_array, align 4
  %304 = load double*, double** %cummin_input, align 4
  %305 = load i32, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
  %call402 = call double* @cummin(double* %304, i32 %305)
  store double* %call402, double** %cummin_array, align 4
  %306 = load double*, double** %cummin_input, align 4
  %307 = bitcast double* %306 to i8*
  call void @free(i8* %307)
  store double* null, double** %cummin_input, align 4
  %308 = load double*, double** %cummin_array, align 4
  %309 = load i32, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
  %call404 = call double* @pminx(double* %308, i32 %309, double 1.000000e+00)
  store double* %call404, double** %pmin403, align 4
  %310 = load double*, double** %cummin_array, align 4
  %311 = bitcast double* %310 to i8*
  call void @free(i8* %311)
  store double* null, double** %cummin_array, align 4
  %312 = load i32, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
  %mul405 = mul i32 %312, 8
  %call406 = call noalias i8* @malloc(i32 %mul405)
  %313 = bitcast i8* %call406 to double*
  store double* %313, double** %q_array, align 4
  store i32 0, i32* %index407, align 4
  br label %for.cond408

for.cond408:                                      ; preds = %for.inc415, %if.end401
  %314 = load i32, i32* %index407, align 4
  %315 = load i32, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
  %cmp409 = icmp ult i32 %314, %315
  br i1 %cmp409, label %for.body411, label %for.end417

for.body411:                                      ; preds = %for.cond408
  %316 = load double*, double** %pmin403, align 4
  %317 = load i32*, i32** %ro315, align 4
  %318 = load i32, i32* %index407, align 4
  %arrayidx412 = getelementptr inbounds i32, i32* %317, i32 %318
  %319 = load i32, i32* %arrayidx412, align 4
  %arrayidx413 = getelementptr inbounds double, double* %316, i32 %319
  %320 = load double, double* %arrayidx413, align 8
  %321 = load double*, double** %q_array, align 4
  %322 = load i32, i32* %index407, align 4
  %arrayidx414 = getelementptr inbounds double, double* %321, i32 %322
  store double %320, double* %arrayidx414, align 8
  br label %for.inc415

for.inc415:                                       ; preds = %for.body411
  %323 = load i32, i32* %index407, align 4
  %inc416 = add i32 %323, 1
  store i32 %inc416, i32* %index407, align 4
  br label %for.cond408

for.end417:                                       ; preds = %for.cond408
  %324 = load i32*, i32** %ro315, align 4
  %325 = bitcast i32* %324 to i8*
  call void @free(i8* %325)
  store i32* null, i32** %ro315, align 4
  %326 = load double*, double** %pmin403, align 4
  %327 = bitcast double* %326 to i8*
  call void @free(i8* %327)
  store double* null, double** %pmin403, align 4
  %328 = load double*, double** %q_array, align 4
  store double* %328, double** %retval, align 4
  br label %return

return:                                           ; preds = %for.end417, %for.end284, %for.end108, %for.end
  %329 = load double*, double** %retval, align 4
  ret double* %329
}

declare i32 @strcasecmp(i8* %0, i8* %1) #1

; Function Attrs: noinline nounwind optnone
define hidden i32 @main() #0 {
entry:
  %retval = alloca i32, align 4
  %PVALUES = alloca [50 x double], align 16
  %CORRECT_ANSWERS = alloca [6 x [50 x double]], align 16
  %TYPES = alloca [6 x i8*], align 16
  %type = alloca i16, align 2
  %q = alloca double*, align 4
  %error = alloca double, align 8
  %i = alloca i32, align 4
  %this_error = alloca double, align 8
  store i32 0, i32* %retval, align 4
  %0 = bitcast [50 x double]* %PVALUES to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 16 %0, i8* align 16 bitcast ([50 x double]* @__const.main.PVALUES to i8*), i32 400, i1 false)
  %1 = bitcast [6 x [50 x double]]* %CORRECT_ANSWERS to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 16 %1, i8* align 16 bitcast ([6 x [50 x double]]* @__const.main.CORRECT_ANSWERS to i8*), i32 2400, i1 false)
  %2 = bitcast [6 x i8*]* %TYPES to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 16 %2, i8* align 16 bitcast ([6 x i8*]* @__const.main.TYPES to i8*), i32 24, i1 false)
  store i16 0, i16* %type, align 2
  br label %for.cond

for.cond:                                         ; preds = %for.inc19, %entry
  %3 = load i16, i16* %type, align 2
  %conv = zext i16 %3 to i32
  %cmp = icmp sle i32 %conv, 5
  br i1 %cmp, label %for.body, label %for.end21

for.body:                                         ; preds = %for.cond
  %arraydecay = getelementptr inbounds [50 x double], [50 x double]* %PVALUES, i32 0, i32 0
  %4 = load i16, i16* %type, align 2
  %idxprom = zext i16 %4 to i32
  %arrayidx = getelementptr inbounds [6 x i8*], [6 x i8*]* %TYPES, i32 0, i32 %idxprom
  %5 = load i8*, i8** %arrayidx, align 4
  %call = call double* @p_adjust(double* %arraydecay, i32 50, i8* %5)
  store double* %call, double** %q, align 4
  %6 = load double*, double** %q, align 4
  %arrayidx2 = getelementptr inbounds double, double* %6, i32 0
  %7 = load double, double* %arrayidx2, align 8
  %8 = load i16, i16* %type, align 2
  %idxprom3 = zext i16 %8 to i32
  %arrayidx4 = getelementptr inbounds [6 x [50 x double]], [6 x [50 x double]]* %CORRECT_ANSWERS, i32 0, i32 %idxprom3
  %arrayidx5 = getelementptr inbounds [50 x double], [50 x double]* %arrayidx4, i32 0, i32 0
  %9 = load double, double* %arrayidx5, align 16
  %sub = fsub double %7, %9
  %10 = call double @llvm.fabs.f64(double %sub)
  store double %10, double* %error, align 8
  store i32 1, i32* %i, align 4
  br label %for.cond6

for.cond6:                                        ; preds = %for.inc, %for.body
  %11 = load i32, i32* %i, align 4
  %cmp7 = icmp ult i32 %11, 50
  br i1 %cmp7, label %for.body9, label %for.end

for.body9:                                        ; preds = %for.cond6
  %12 = load double*, double** %q, align 4
  %13 = load i32, i32* %i, align 4
  %arrayidx10 = getelementptr inbounds double, double* %12, i32 %13
  %14 = load double, double* %arrayidx10, align 8
  %15 = load i16, i16* %type, align 2
  %idxprom11 = zext i16 %15 to i32
  %arrayidx12 = getelementptr inbounds [6 x [50 x double]], [6 x [50 x double]]* %CORRECT_ANSWERS, i32 0, i32 %idxprom11
  %16 = load i32, i32* %i, align 4
  %arrayidx13 = getelementptr inbounds [50 x double], [50 x double]* %arrayidx12, i32 0, i32 %16
  %17 = load double, double* %arrayidx13, align 8
  %sub14 = fsub double %14, %17
  %18 = call double @llvm.fabs.f64(double %sub14)
  store double %18, double* %this_error, align 8
  %19 = load double, double* %this_error, align 8
  %20 = load double, double* %error, align 8
  %add = fadd double %20, %19
  store double %add, double* %error, align 8
  br label %for.inc

for.inc:                                          ; preds = %for.body9
  %21 = load i32, i32* %i, align 4
  %inc = add i32 %21, 1
  store i32 %inc, i32* %i, align 4
  br label %for.cond6

for.end:                                          ; preds = %for.cond6
  %22 = load double*, double** %q, align 4
  call void @double_say(double* %22, i32 50)
  %23 = load double*, double** %q, align 4
  %24 = bitcast double* %23 to i8*
  call void @free(i8* %24)
  store double* null, double** %q, align 4
  %25 = load i16, i16* %type, align 2
  %conv15 = zext i16 %25 to i32
  %26 = load i16, i16* %type, align 2
  %idxprom16 = zext i16 %26 to i32
  %arrayidx17 = getelementptr inbounds [6 x i8*], [6 x i8*]* %TYPES, i32 0, i32 %idxprom16
  %27 = load i8*, i8** %arrayidx17, align 4
  %28 = load double, double* %error, align 8
  %call18 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([44 x i8], [44 x i8]* @.str.28, i32 0, i32 0), i32 %conv15, i8* %27, double %28)
  br label %for.inc19

for.inc19:                                        ; preds = %for.end
  %29 = load i16, i16* %type, align 2
  %inc20 = add i16 %29, 1
  store i16 %inc20, i16* %type, align 2
  br label %for.cond

for.end21:                                        ; preds = %for.cond
  ret i32 0
}

; Function Attrs: argmemonly nounwind willreturn
declare void @llvm.memcpy.p0i8.p0i8.i32(i8* noalias nocapture writeonly %0, i8* noalias nocapture readonly %1, i32 %2, i1 immarg %3) #3

; Function Attrs: nounwind readnone speculatable willreturn
declare double @llvm.fabs.f64(double %0) #4

attributes #0 = { noinline nounwind optnone "correctly-rounded-divide-sqrt-fp-math"="false" "disable-tail-calls"="false" "frame-pointer"="none" "less-precise-fpmad"="false" "min-legal-vector-width"="0" "no-infs-fp-math"="false" "no-jump-tables"="false" "no-nans-fp-math"="false" "no-signed-zeros-fp-math"="false" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="generic" "unsafe-fp-math"="false" "use-soft-float"="false" }
attributes #1 = { "correctly-rounded-divide-sqrt-fp-math"="false" "disable-tail-calls"="false" "frame-pointer"="none" "less-precise-fpmad"="false" "no-infs-fp-math"="false" "no-nans-fp-math"="false" "no-signed-zeros-fp-math"="false" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="generic" "unsafe-fp-math"="false" "use-soft-float"="false" }
attributes #2 = { noreturn "correctly-rounded-divide-sqrt-fp-math"="false" "disable-tail-calls"="false" "frame-pointer"="none" "less-precise-fpmad"="false" "no-infs-fp-math"="false" "no-nans-fp-math"="false" "no-signed-zeros-fp-math"="false" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="generic" "unsafe-fp-math"="false" "use-soft-float"="false" }
attributes #3 = { argmemonly nounwind willreturn }
attributes #4 = { nounwind readnone speculatable willreturn }
attributes #5 = { noreturn }

!llvm.module.flags = !{!0}
!llvm.ident = !{!1}

!0 = !{i32 1, !"wchar_size", i32 4}
!1 = !{!"clang version 11.0.0 (https://github.com/Jacarte/llvm-project.git 0f6dea67136cc1e0b3d200eb2bb165628970c44b)"}

; extracted candidates

; *****
; For LLVM instruction:
;  %frombool = zext i1 %DECREASING to i8
; Looking for a replacement for:
%0:i1 = var
%1:i8 = zext %0
infer %1

; *****
; For LLVM instruction:
;  %0 = load i32, i32* %SIZE.addr, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %mul = mul i32 %0, 4
; Looking for a replacement for:
%0:i32 = var
%1:i32 = mul 4:i32, %0
infer %1

; *****
; For LLVM instruction:
;  %cmp = icmp eq i32* %2, null
; Looking for a replacement for:
%0:i32 = var
%1:i1 = eq 0:i32, %0
infer %1

; *****
; For LLVM instruction:
;  %3 = load i32, i32* %SIZE.addr, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %mul2 = mul i32 8, %3
; Looking for a replacement for:
%0:i32 = var
%1:i32 = mul 8:i32, %0
infer %1

; *****
; For LLVM instruction:
;  %cmp4 = icmp eq double* %5, null
; Looking for a replacement for:
%0:i32 = var
%1:i1 = eq 0:i32, %0
infer %1

; *****
; For LLVM instruction:
;  %6 = load i32, i32* %i, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %7 = load i32, i32* %SIZE.addr, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %cmp8 = icmp ult i32 %6, %7
; Looking for a replacement for:
%0:i32 = var
%1:i32 = var
%2:i1 = ult %0, %1
infer %2

; *****
; For LLVM instruction:
;  %9 = load i32, i32* %i, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %12 = load i32, i32* %i, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %13 = load i32, i32* %i, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %15 = load i32, i32* %i, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %16 = load i32, i32* %i, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %inc = add i32 %16, 1
; Looking for a replacement for:
%0:i32 = var
%1:i32 = add 1:i32, %0
infer %1

; *****
; For LLVM instruction:
;  %17 = load i8, i8* %DECREASING.addr, align 1
; Looking for a replacement for:
%0:i8 = var
infer %0 (demandedBits=00000001)

; *****
; For LLVM instruction:
;  %tobool = trunc i8 %17 to i1
; Looking for a replacement for:
%0:i8 = var
%1:i1 = trunc %0
infer %1

; *****
; For LLVM instruction:
;  %conv = zext i1 %tobool to i32
; Looking for a replacement for:
%0:i8 = var
%1:i1 = trunc %0
%2:i32 = zext %1
infer %2

; *****
; For LLVM instruction:
;  %cmp11 = icmp eq i32 %conv, 0
; Looking for a replacement for:
%0:i8 = var
%1:i1 = trunc %0
%2:i32 = zext %1
%3:i1 = eq 0:i32, %2
infer %3

; *****
; For LLVM instruction:
;  %20 = load i32, i32* %SIZE.addr, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %21 = load i8, i8* %DECREASING.addr, align 1
; Looking for a replacement for:
%0:i8 = var
infer %0 (demandedBits=00000001)

; *****
; For LLVM instruction:
;  %tobool14 = trunc i8 %21 to i1
; Looking for a replacement for:
%0:i8 = var
%1:i1 = trunc %0
infer %1

; *****
; For LLVM instruction:
;  %24 = load i32, i32* %SIZE.addr, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0
#########################################################
; exiting Souper's runOnFunction() for order()

; entering Souper's runOnFunction() for ./P-value_correction.c.bc:compar_decrease()

; ModuleID = './P-value_correction.c.bc'
source_filename = "./P-value_correction.c"
target datalayout = "e-m:e-p:32:32-i64:64-n32:64-S128"
target triple = "wasm32-unknown-wasi"

@.str = private unnamed_addr constant [29 x i8] c"malloc failed at %s line %u\0A\00", align 1
@.str.1 = private unnamed_addr constant [23 x i8] c"./P-value_correction.c\00", align 1
@.str.2 = private unnamed_addr constant [1 x i8] zeroinitializer, align 1
@base_arr = hidden global double* null, align 4
@.str.3 = private unnamed_addr constant [33 x i8] c"failed to malloc at %s line %u.\0A\00", align 1
@.str.4 = private unnamed_addr constant [48 x i8] c"cummin function requires at least one element.\0A\00", align 1
@.str.5 = private unnamed_addr constant [22 x i8] c"Failed at %s line %u\0A\00", align 1
@.str.6 = private unnamed_addr constant [41 x i8] c"function requires at least one element.\0A\00", align 1
@.str.7 = private unnamed_addr constant [37 x i8] c"pmin requires at least one element.\0A\00", align 1
@.str.8 = private unnamed_addr constant [7 x i8] c"[1] %e\00", align 1
@.str.9 = private unnamed_addr constant [7 x i8] c" %.10f\00", align 1
@.str.10 = private unnamed_addr constant [6 x i8] c"\0A[%u]\00", align 1
@.str.11 = private unnamed_addr constant [2 x i8] c"\0A\00", align 1
@.str.12 = private unnamed_addr constant [34 x i8] c"Failure to malloc at %s line %u.\0A\00", align 1
@.str.13 = private unnamed_addr constant [41 x i8] c"p_adjust requires at least one element.\0A\00", align 1
@.str.14 = private unnamed_addr constant [3 x i8] c"BH\00", align 1
@.str.15 = private unnamed_addr constant [4 x i8] c"fdr\00", align 1
@.str.16 = private unnamed_addr constant [3 x i8] c"by\00", align 1
@.str.17 = private unnamed_addr constant [11 x i8] c"Bonferroni\00", align 1
@.str.18 = private unnamed_addr constant [9 x i8] c"hochberg\00", align 1
@.str.19 = private unnamed_addr constant [5 x i8] c"holm\00", align 1
@.str.20 = private unnamed_addr constant [7 x i8] c"hommel\00", align 1
@.str.21 = private unnamed_addr constant [44 x i8] c"%s doesn't match any accepted FDR methods.\0A\00", align 1
@.str.22 = private unnamed_addr constant [42 x i8] c"%g is outside of the interval I planned.\0A\00", align 1
@.str.23 = private unnamed_addr constant [23 x i8] c"Failure at %s line %u\0A\00", align 1
@.str.24 = private unnamed_addr constant [54 x i8] c"array[%u] = %lf, which is outside the interval [0,1]\0A\00", align 1
@.str.25 = private unnamed_addr constant [20 x i8] c"died at %s line %u\0A\00", align 1
@__const.main.PVALUES = private unnamed_addr constant [50 x double] [double 0x3FDD04160F35FDE9, double 0x3FE758E721E2A8D7, double 0x3FB96FAC8B38D8BA, double 0x3FB73E71D5B04B37, double 0x3FC710AB48EE865B, double 0x3FEC01D953C3CC73, double 0x3FD2B3C4BE0A922A, double 0x3FED2B5A568DAB4F, double 0x3FDBE08D73F16964, double 0x3FE10A218C41C242, double 0x3FDF8810DB1996AA, double 0x3FE291CCB11E1A9D, double 0x3FD64E8C550D788F, double 7.883130e-01, double 0x3FD177B2BF048D2D, double 0x3FEB3543434BAF2B, double 0x3FDB50EAD41ED0A6, double 0x3FE49D4AFF01D33F, double 0x3FD364C9AE345B51, double 0x3FA99BA35F15394D, double 3.194810e-01, double 0x3FE941E405CE761A, double 0x3FEFF94F77369843, double 0x3FC65847BFB23217, double 0x3FECEB8879B6A543, double 0x3FBEAF00332BA677, double 0x3FD96207C7749E38, double 0x3F8CC02620502C93, double 0x3FE773A5B45A0F40, double 0x3FB1642C24762C01, double 4.040730e-03, double 0x3F33E11D79A90777, double 0x3F870B02BD749528, double 0x3F98521BD6A0353F, double 0x3F4310F26148FFAA, double 0x3F3427CD76006778, double 0x3F80E60AFB1F8A4E, double 0x3F5639B74A9E4DA2, double 0x3F8BDDF74195769F, double 0x3F38ABEE3BFA8581, double 0x3EF2E2E96B5466FE, double 0x3E90CE9F65B58A88, double 0x3FA0F2D097879B95, double 0x3F834EE7216A6684, double 0x3F4CCE8DBB40BD9D, double 0x3F2C8B969590F2ED, double 0x3F4FC31F7F1541AD, double 6.610250e-05, double 0x3F9DB44EA6AC26BA, double 5.735490e-03], align 16
@__const.main.CORRECT_ANSWERS = private unnamed_addr constant [6 x [50 x double]] [[50 x double] [double 0x3FE39AFA2199ADBC, double 8.521710e-01, double 0x3FC96FAC6045BAF5, double 0x3FC83660E51D25AB, double 0x3FD498068702BE20, double 0x3FEDC3BF727136A4, double 4.870370e-01, double 0x3FEDC3BF727136A4, double 0x3FE35BF08BEEB62C, double 0x3FE5D879DEE92F03, double 0x3FE4BE91D656B94A, double 0x3FE7363FC28DAEAA, double 0x3FE0E62C4F13638A, double 0x3FEC1052C8FAB035, double 0x3FDE1DD2E43E029A, double 0x3FED92EFFC7CBDC1, double 0x3FE35BF08BEEB62C, double 0x3FE923B90CFC67C5, double 0x3FDF47B8FC357024, double 0x3FBD1996A9FB10AD, double 0x3FDFF2B6D6C14255, double 0x3FEC1052C8FAB035, double 0x3FEFF94F77369843, double 0x3FD498068702BE20, double 0x3FEDC3BF727136A4, double 0x3FCD80E2E96EC403, double 0x3FE2A9F6A93F290B, double 0x3FA3F736D8AF2E2B, double 8.521710e-01, double 0x3FC2E751B350FAC4, double 0x3F913D8E55EE9F05, double 0x3F64FECB88BB3633, double 0x3FA2009A03CCBE34, double 0x3FB0001FB57CF9FC, double 0x3F6DCA7ADA5E274A, double 0x3F64FECB88BB3633, double 0x3F9E2D13B467D120, double 0x3F7941963399C6A1, double 0x3FA3F736D8AF2E2B, double 0x3F6607390CEF853C, double 0x3F3D828C80BA213A, double 0x3EEA42D90EEBA875, double 0x3FB42D4181AA8F8B, double 0x3FA01715F12E0018, double 0x3F73D9F3AF6D490C, double 0x3F64FECB88BB3633, double 0x3F73D9F3AF6D490C, double 0x3F520CE5F51A7C61, double 0x3FB290B112B20952, double 0x3F9696C95AA76B69], [50 x double] [double 1.000000e+00, double 1.000000e+00, double 0x3FEC9C56E33BA41B, double 0x3FEB3BF21E95ED3D, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 0x3FE05DA74553C727, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 0x3FC675198790829A, double 1.000000e+00, double 0x3FE54345648E1F12, double 0x3FB3645F501CA2F9, double 0x3F879D934E50F0DE, double 0x3FC43FC3646E3EA2, double 0x3FD1FF539D36064C, double 0x3F90C123206B855F, double 0x3F879D934E50F0DE, double 0x3FC0F8967F32E606, double 0x3F9C6880470D2FBE, double 0x3FC675198790829A, double 0x3F88C70105E47082, double 2.025930e-03, double 0x3F0D89DE4FA8F818, double 0x3FD6B1E2D11B1027, double 0x3FC219271872BD8D, double 0x3F96542FAD16CEF9, double 0x3F879D934E50F0DE, double 0x3F96542FAD16CEF9, double 0x3F744D9816EB319A, double 0x3FD4E1D5728DBC16, double 0x3FB9687C40426555], [50 x double] [double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 0x3FE6761DC93EA2D3, double 1.000000e+00, double 1.000000e+00, double 0x3FC9DC55000C953A, double 0x3F8F0FBD624BA499, double 0x3FE2009A24031487, double 1.000000e+00, double 0x3F9DCA7AB8020F7A, double 0x3F8F7E310860A1AB, double 0x3FDA677128614819, double 6.782670e-02, double 6.803480e-01, double 0x3F9346521EDBB84D, double 0x3F4D828CB7B3E0EE, double 0x3EEA42D90EEBA875, double 1.000000e+00, double 4.713920e-01, double 0x3FA6815EE53DB1E7, double 0x3F864D0CF90CC6B8, double 0x3FA8D0709B489B4F, double 0x3F6B1359791819D2, double 1.000000e+00, double 0x3FD25A836EB4E981], [50 x double] [double 0x3FEFF94F77369843, double 0x3FEFF94F77369843, double 0x3FEFF94F77369843, double 0x3FEFF94F77369843, double 0x3FEFF94F77369843, double 0x3FEFF94F77369843, double 0x3FEFF94F77369843, double 0x3FEFF94F77369843, double 0x3FEFF94F77369843, double 0x3FEFF94F77369843, double 0x3FEFF94F77369843, double 0x3FEFF94F77369843, double 0x3FEFF94F77369843, double 0x3FEFF94F77369843, double 0x3FEFF94F77369843, double 0x3FEFF94F77369843, double 0x3FEFF94F77369843, double 0x3FEFF94F77369843, double 0x3FEFF94F77369843, double 0x3FEFF94F77369843, double 0x3FEFF94F77369843, double 0x3FEFF94F77369843, double 0x3FEFF94F77369843, double 0x3FEFF94F77369843, double 0x3FEFF94F77369843, double 0x3FEFF94F77369843, double 0x3FEFF94F77369843, double 0x3FDDA6274695E687, double 0x3FEFF94F77369843, double 0x3FEFF94F77369843, double 0x3FC42BDC26DCE39B, double 0x3F8C57F9104CA951, double 0x3FD9340AC9879DEF, double 7.600230e-01, double 0x3F999EC5A86B439B, double 0x3F8C57F9104CA951, double 0x3FD389FCD90412B4, double 0x3FABC8251D45E10B, double 0x3FDD9BD68ABBB045, double 0x3F90F633F956C386, double 8.825610e-04, double 0x3EEA42D90EEBA875, double 0x3FEFC7471C1E43B8, double 0x3FD5B8C4014C305A, double 0x3FA2E78CEC8D068E, double 0x3F84F6832995A599, double 0x3FA459002162FC24, double 3.172920e-03, double 8.992520e-01, double 0x3FCBE5BD5E9AC00A], [50 x double] [double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 0x3FDDA6274695E687, double 1.000000e+00, double 1.000000e+00, double 0x3FC42BDC26DCE39B, double 0x3F8C939AFCF101E0, double 0x3FD9340AC9879DEF, double 7.600230e-01, double 0x3F999EC5A86B439B, double 0x3F8C939AFCF101E0, double 0x3FD389FCD90412B4, double 0x3FABC8251D45E10B, double 0x3FDD9BD68ABBB045, double 0x3F90F633F956C386, double 8.825610e-04, double 0x3EEA42D90EEBA875, double 0x3FEFC7471C1E43B8, double 0x3FD5B8C4014C305A, double 0x3FA2E78CEC8D068E, double 0x3F84F6832995A599, double 0x3FA459002162FC24, double 3.172920e-03, double 8.992520e-01, double 0x3FCBE5BD5E9AC00A], [50 x double] [double 0x3FEFF94F77369843, double 0x3FEFF94F77369843, double 0x3FEFF94F77369843, double 0x3FEFF5DC908F2EDD, double 0x3FEFF94F77369843, double 0x3FEFF94F77369843, double 0x3FEFF94F77369843, double 0x3FEFF94F77369843, double 0x3FEFF94F77369843, double 0x3FEFF94F77369843, double 0x3FEFF94F77369843, double 0x3FEFF94F77369843, double 0x3FEFF94F77369843, double 0x3FEFF94F77369843, double 0x3FEFF94F77369843, double 0x3FEFF94F77369843, double 0x3FEFF94F77369843, double 0x3FEFF94F77369843, double 0x3FEFF94F77369843, double 0x3FEEB45F17BD8BE7, double 0x3FEFF94F77369843, double 0x3FEFF94F77369843, double 0x3FEFF94F77369843, double 0x3FEFF94F77369843, double 0x3FEFF94F77369843, double 0x3FEFF94F77369843, double 0x3FEFF94F77369843, double 0x3FDBDA250F840182, double 0x3FEFF94F77369843, double 0x3FEF40BC1D52205E, double 0x3FC21A3BEB689947, double 1.304340e-02, double 0x3FD69916517B1CD7, double 0x3FE60A69453DF7B2, double 0x3F986DB666D9D3C6, double 0x3F8B157BBD3AB385, double 2.722920e-01, double 0x3FABC8251D45E10B, double 0x3FDAFF07B27BE8AF, double 0x3F9030D45E3B9F93, double 8.825610e-04, double 0x3EEA42D90EEBA875, double 0x3FEBFACC1948A662, double 0x3FD34EE6EDE042CB, double 0x3FA2011883DA6A9A, double 0x3F839FF779153716, double 0x3FA3D9F3D1C960DD, double 3.172920e-03, double 0x3FE9FDC4BC5D1301, double 0x3FC8F5FAC3801CF1]], align 16
@.str.26 = private unnamed_addr constant [3 x i8] c"bh\00", align 1
@.str.27 = private unnamed_addr constant [11 x i8] c"bonferroni\00", align 1
@__const.main.TYPES = private unnamed_addr constant [6 x i8*] [i8* getelementptr inbounds ([3 x i8], [3 x i8]* @.str.26, i32 0, i32 0), i8* getelementptr inbounds ([3 x i8], [3 x i8]* @.str.16, i32 0, i32 0), i8* getelementptr inbounds ([11 x i8], [11 x i8]* @.str.27, i32 0, i32 0), i8* getelementptr inbounds ([9 x i8], [9 x i8]* @.str.18, i32 0, i32 0), i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.19, i32 0, i32 0), i8* getelementptr inbounds ([7 x i8], [7 x i8]* @.str.20, i32 0, i32 0)], align 16
@.str.28 = private unnamed_addr constant [44 x i8] c"\0Atype %u = '%s' has cumulative error of %g\0A\00", align 1
@llvm.used = appending global [1 x i8*] [i8* bitcast (i32 ()* @__main_void to i8*)], section "llvm.metadata"

@__main_void = alias i32 (), i32 ()* @main

; Function Attrs: noinline nounwind optnone
define hidden i32* @seq_len(i32 %START, i32 %END) #0 {
entry:
  %retval = alloca i32*, align 4
  %START.addr = alloca i32, align 4
  %END.addr = alloca i32, align 4
  %start = alloca i32, align 4
  %end = alloca i32, align 4
  %sequence = alloca i32*, align 4
  %i = alloca i32, align 4
  %LENGTH = alloca i32, align 4
  %sequence10 = alloca i32*, align 4
  %index = alloca i32, align 4
  %index28 = alloca i32, align 4
  store i32 %START, i32* %START.addr, align 4
  store i32 %END, i32* %END.addr, align 4
  %0 = load i32, i32* %START.addr, align 4
  store i32 %0, i32* %start, align 4
  %1 = load i32, i32* %END.addr, align 4
  store i32 %1, i32* %end, align 4
  %2 = load i32, i32* %START.addr, align 4
  %3 = load i32, i32* %END.addr, align 4
  %cmp = icmp eq i32 %2, %3
  br i1 %cmp, label %if.then, label %if.end6

if.then:                                          ; preds = %entry
  %4 = load i32, i32* %end, align 4
  %add = add i32 %4, 1
  %mul = mul i32 %add, 4
  %call = call noalias i8* @malloc(i32 %mul)
  %5 = bitcast i8* %call to i32*
  store i32* %5, i32** %sequence, align 4
  %6 = load i32*, i32** %sequence, align 4
  %cmp1 = icmp eq i32* %6, null
  br i1 %cmp1, label %if.then2, label %if.end

if.then2:                                         ; preds = %if.then
  %call3 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([29 x i8], [29 x i8]* @.str, i32 0, i32 0), i8* getelementptr inbounds ([23 x i8], [23 x i8]* @.str.1, i32 0, i32 0), i32 15)
  call void @perror(i8* getelementptr inbounds ([1 x i8], [1 x i8]* @.str.2, i32 0, i32 0))
  call void @exit(i32 1) #5
  unreachable

if.end:                                           ; preds = %if.then
  store i32 0, i32* %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.end
  %7 = load i32, i32* %i, align 4
  %8 = load i32, i32* %end, align 4
  %cmp4 = icmp ult i32 %7, %8
  br i1 %cmp4, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %9 = load i32, i32* %i, align 4
  %add5 = add i32 %9, 1
  %10 = load i32*, i32** %sequence, align 4
  %11 = load i32, i32* %i, align 4
  %arrayidx = getelementptr inbounds i32, i32* %10, i32 %11
  store i32 %add5, i32* %arrayidx, align 4
  br label %for.inc

for.inc:                                          ; preds = %for.body
  %12 = load i32, i32* %i, align 4
  %inc = add i32 %12, 1
  store i32 %inc, i32* %i, align 4
  br label %for.cond

for.end:                                          ; preds = %for.cond
  %13 = load i32*, i32** %sequence, align 4
  store i32* %13, i32** %retval, align 4
  br label %return

if.end6:                                          ; preds = %entry
  %14 = load i32, i32* %START.addr, align 4
  %15 = load i32, i32* %END.addr, align 4
  %cmp7 = icmp ugt i32 %14, %15
  br i1 %cmp7, label %if.then8, label %if.end9

if.then8:                                         ; preds = %if.end6
  %16 = load i32, i32* %START.addr, align 4
  store i32 %16, i32* %end, align 4
  %17 = load i32, i32* %END.addr, align 4
  store i32 %17, i32* %start, align 4
  br label %if.end9

if.end9:                                          ; preds = %if.then8, %if.end6
  %18 = load i32, i32* %end, align 4
  %19 = load i32, i32* %start, align 4
  %sub = sub i32 %18, %19
  store i32 %sub, i32* %LENGTH, align 4
  %20 = load i32, i32* %LENGTH, align 4
  %add11 = add i32 1, %20
  %mul12 = mul i32 %add11, 4
  %call13 = call noalias i8* @malloc(i32 %mul12)
  %21 = bitcast i8* %call13 to i32*
  store i32* %21, i32** %sequence10, align 4
  %22 = load i32*, i32** %sequence10, align 4
  %cmp14 = icmp eq i32* %22, null
  br i1 %cmp14, label %if.then15, label %if.end17

if.then15:                                        ; preds = %if.end9
  %call16 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([29 x i8], [29 x i8]* @.str, i32 0, i32 0), i8* getelementptr inbounds ([23 x i8], [23 x i8]* @.str.1, i32 0, i32 0), i32 31)
  call void @perror(i8* getelementptr inbounds ([1 x i8], [1 x i8]* @.str.2, i32 0, i32 0))
  call void @exit(i32 1) #5
  unreachable

if.end17:                                         ; preds = %if.end9
  %23 = load i32, i32* %START.addr, align 4
  %24 = load i32, i32* %END.addr, align 4
  %cmp18 = icmp ult i32 %23, %24
  br i1 %cmp18, label %if.then19, label %if.else

if.then19:                                        ; preds = %if.end17
  store i32 0, i32* %index, align 4
  br label %for.cond20

for.cond20:                                       ; preds = %for.inc25, %if.then19
  %25 = load i32, i32* %index, align 4
  %26 = load i32, i32* %LENGTH, align 4
  %cmp21 = icmp ule i32 %25, %26
  br i1 %cmp21, label %for.body22, label %for.end27

for.body22:                                       ; preds = %for.cond20
  %27 = load i32, i32* %start, align 4
  %28 = load i32, i32* %index, align 4
  %add23 = add i32 %27, %28
  %29 = load i32*, i32** %sequence10, align 4
  %30 = load i32, i32* %index, align 4
  %arrayidx24 = getelementptr inbounds i32, i32* %29, i32 %30
  store i32 %add23, i32* %arrayidx24, align 4
  br label %for.inc25

for.inc25:                                        ; preds = %for.body22
  %31 = load i32, i32* %index, align 4
  %inc26 = add i32 %31, 1
  store i32 %inc26, i32* %index, align 4
  br label %for.cond20

for.end27:                                        ; preds = %for.cond20
  br label %if.end37

if.else:                                          ; preds = %if.end17
  store i32 0, i32* %index28, align 4
  br label %for.cond29

for.cond29:                                       ; preds = %for.inc34, %if.else
  %32 = load i32, i32* %index28, align 4
  %33 = load i32, i32* %LENGTH, align 4
  %cmp30 = icmp ule i32 %32, %33
  br i1 %cmp30, label %for.body31, label %for.end36

for.body31:                                       ; preds = %for.cond29
  %34 = load i32, i32* %end, align 4
  %35 = load i32, i32* %index28, align 4
  %sub32 = sub i32 %34, %35
  %36 = load i32*, i32** %sequence10, align 4
  %37 = load i32, i32* %index28, align 4
  %arrayidx33 = getelementptr inbounds i32, i32* %36, i32 %37
  store i32 %sub32, i32* %arrayidx33, align 4
  br label %for.inc34

for.inc34:                                        ; preds = %for.body31
  %38 = load i32, i32* %index28, align 4
  %inc35 = add i32 %38, 1
  store i32 %inc35, i32* %index28, align 4
  br label %for.cond29

for.end36:                                        ; preds = %for.cond29
  br label %if.end37

if.end37:                                         ; preds = %for.end36, %for.end27
  %39 = load i32*, i32** %sequence10, align 4
  store i32* %39, i32** %retval, align 4
  br label %return

return:                                           ; preds = %if.end37, %for.end
  %40 = load i32*, i32** %retval, align 4
  ret i32* %40
}

declare noalias i8* @malloc(i32 %0) #1

declare i32 @printf(i8* %0, ...) #1

declare void @perror(i8* %0) #1

; Function Attrs: noreturn
declare void @exit(i32 %0) #2

; Function Attrs: noinline nounwind optnone
define hidden i32* @order(double* noalias %ARRAY, i32 %SIZE, i1 zeroext %DECREASING) #0 {
entry:
  %ARRAY.addr = alloca double*, align 4
  %SIZE.addr = alloca i32, align 4
  %DECREASING.addr = alloca i8, align 1
  %idx = alloca i32*, align 4
  %i = alloca i32, align 4
  store double* %ARRAY, double** %ARRAY.addr, align 4
  store i32 %SIZE, i32* %SIZE.addr, align 4
  %frombool = zext i1 %DECREASING to i8
  store i8 %frombool, i8* %DECREASING.addr, align 1
  %0 = load i32, i32* %SIZE.addr, align 4
  %mul = mul i32 %0, 4
  %call = call noalias i8* @malloc(i32 %mul)
  %1 = bitcast i8* %call to i32*
  store i32* %1, i32** %idx, align 4
  %2 = load i32*, i32** %idx, align 4
  %cmp = icmp eq i32* %2, null
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %call1 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([33 x i8], [33 x i8]* @.str.3, i32 0, i32 0), i8* getelementptr inbounds ([23 x i8], [23 x i8]* @.str.1, i32 0, i32 0), i32 77)
  call void @perror(i8* getelementptr inbounds ([1 x i8], [1 x i8]* @.str.2, i32 0, i32 0))
  call void @exit(i32 1) #5
  unreachable

if.end:                                           ; preds = %entry
  %3 = load i32, i32* %SIZE.addr, align 4
  %mul2 = mul i32 8, %3
  %call3 = call noalias i8* @malloc(i32 %mul2)
  %4 = bitcast i8* %call3 to double*
  store double* %4, double** @base_arr, align 4
  %5 = load double*, double** @base_arr, align 4
  %cmp4 = icmp eq double* %5, null
  br i1 %cmp4, label %if.then5, label %if.end7

if.then5:                                         ; preds = %if.end
  %call6 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([33 x i8], [33 x i8]* @.str.3, i32 0, i32 0), i8* getelementptr inbounds ([23 x i8], [23 x i8]* @.str.1, i32 0, i32 0), i32 83)
  call void @perror(i8* getelementptr inbounds ([1 x i8], [1 x i8]* @.str.2, i32 0, i32 0))
  call void @exit(i32 1) #5
  unreachable

if.end7:                                          ; preds = %if.end
  store i32 0, i32* %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.end7
  %6 = load i32, i32* %i, align 4
  %7 = load i32, i32* %SIZE.addr, align 4
  %cmp8 = icmp ult i32 %6, %7
  br i1 %cmp8, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %8 = load double*, double** %ARRAY.addr, align 4
  %9 = load i32, i32* %i, align 4
  %arrayidx = getelementptr inbounds double, double* %8, i32 %9
  %10 = load double, double* %arrayidx, align 8
  %11 = load double*, double** @base_arr, align 4
  %12 = load i32, i32* %i, align 4
  %arrayidx9 = getelementptr inbounds double, double* %11, i32 %12
  store double %10, double* %arrayidx9, align 8
  %13 = load i32, i32* %i, align 4
  %14 = load i32*, i32** %idx, align 4
  %15 = load i32, i32* %i, align 4
  %arrayidx10 = getelementptr inbounds i32, i32* %14, i32 %15
  store i32 %13, i32* %arrayidx10, align 4
  br label %for.inc

for.inc:                                          ; preds = %for.body
  %16 = load i32, i32* %i, align 4
  %inc = add i32 %16, 1
  store i32 %inc, i32* %i, align 4
  br label %for.cond

for.end:                                          ; preds = %for.cond
  %17 = load i8, i8* %DECREASING.addr, align 1
  %tobool = trunc i8 %17 to i1
  %conv = zext i1 %tobool to i32
  %cmp11 = icmp eq i32 %conv, 0
  br i1 %cmp11, label %if.then13, label %if.else

if.then13:                                        ; preds = %for.end
  %18 = load i32*, i32** %idx, align 4
  %19 = bitcast i32* %18 to i8*
  %20 = load i32, i32* %SIZE.addr, align 4
  call void @qsort(i8* %19, i32 %20, i32 4, i32 (i8*, i8*)* @compar_decrease)
  br label %if.end20

if.else:                                          ; preds = %for.end
  %21 = load i8, i8* %DECREASING.addr, align 1
  %tobool14 = trunc i8 %21 to i1
  br i1 %tobool14, label %if.then18, label %if.end19

if.then18:                                        ; preds = %if.else
  %22 = load i32*, i32** %idx, align 4
  %23 = bitcast i32* %22 to i8*
  %24 = load i32, i32* %SIZE.addr, align 4
  call void @qsort(i8* %23, i32 %24, i32 4, i32 (i8*, i8*)* @compar_increase)
  br label %if.end19

if.end19:                                         ; preds = %if.then18, %if.else
  br label %if.end20

if.end20:                                         ; preds = %if.end19, %if.then13
  %25 = load double*, double** @base_arr, align 4
  %26 = bitcast double* %25 to i8*
  call void @free(i8* %26)
  store double* null, double** @base_arr, align 4
  %27 = load i32*, i32** %idx, align 4
  ret i32* %27
}

declare void @qsort(i8* %0, i32 %1, i32 %2, i32 (i8*, i8*)* %3) #1

; Function Attrs: noinline nounwind optnone
define internal i32 @compar_decrease(i8* noalias %a, i8* noalias %b) #0 {
entry:
  %retval = alloca i32, align 4
  %a.addr = alloca i8*, align 4
  %b.addr = alloca i8*, align 4
  %aa = alloca i32, align 4
  %bb = alloca i32, align 4
  store i8* %a, i8** %a.addr, align 4
  store i8* %b, i8** %b.addr, align 4
  %0 = load i8*, i8** %a.addr, align 4
  %1 = bitcast i8* %0 to i32*
  %2 = load i32, i32* %1, align 4
  store i32 %2, i32* %aa, align 4
  %3 = load i8*, i8** %b.addr, align 4
  %4 = bitcast i8* %3 to i32*
  %5 = load i32, i32* %4, align 4
  store i32 %5, i32* %bb, align 4
  %6 = load double*, double** @base_arr, align 4
  %7 = load i32, i32* %aa, align 4
  %arrayidx = getelementptr inbounds double, double* %6, i32 %7
  %8 = load double, double* %arrayidx, align 8
  %9 = load double*, double** @base_arr, align 4
  %10 = load i32, i32* %bb, align 4
  %arrayidx1 = getelementptr inbounds double, double* %9, i32 %10
  %11 = load double, double* %arrayidx1, align 8
  %cmp = fcmp olt double %8, %11
  br i1 %cmp, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  store i32 -1, i32* %retval, align 4
  br label %return

if.else:                                          ; preds = %entry
  %12 = load double*, double** @base_arr, align 4
  %13 = load i32, i32* %aa, align 4
  %arrayidx2 = getelementptr inbounds double, double* %12, i32 %13
  %14 = load double, double* %arrayidx2, align 8
  %15 = load double*, double** @base_arr, align 4
  %16 = load i32, i32* %bb, align 4
  %arrayidx3 = getelementptr inbounds double, double* %15, i32 %16
  %17 = load double, double* %arrayidx3, align 8
  %cmp4 = fcmp oeq double %14, %17
  br i1 %cmp4, label %if.then5, label %if.else6

if.then5:                                         ; preds = %if.else
  store i32 0, i32* %retval, align 4
  br label %return

if.else6:                                         ; preds = %if.else
  store i32 1, i32* %retval, align 4
  br label %return

return:                                           ; preds = %if.else6, %if.then5, %if.then
  %18 = load i32, i32* %retval, align 4
  ret i32 %18
}

; Function Attrs: noinline nounwind optnone
define internal i32 @compar_increase(i8* noalias %a, i8* noalias %b) #0 {
entry:
  %retval = alloca i32, align 4
  %a.addr = alloca i8*, align 4
  %b.addr = alloca i8*, align 4
  %aa = alloca i32, align 4
  %bb = alloca i32, align 4
  store i8* %a, i8** %a.addr, align 4
  store i8* %b, i8** %b.addr, align 4
  %0 = load i8*, i8** %a.addr, align 4
  %1 = bitcast i8* %0 to i32*
  %2 = load i32, i32* %1, align 4
  store i32 %2, i32* %aa, align 4
  %3 = load i8*, i8** %b.addr, align 4
  %4 = bitcast i8* %3 to i32*
  %5 = load i32, i32* %4, align 4
  store i32 %5, i32* %bb, align 4
  %6 = load double*, double** @base_arr, align 4
  %7 = load i32, i32* %aa, align 4
  %arrayidx = getelementptr inbounds double, double* %6, i32 %7
  %8 = load double, double* %arrayidx, align 8
  %9 = load double*, double** @base_arr, align 4
  %10 = load i32, i32* %bb, align 4
  %arrayidx1 = getelementptr inbounds double, double* %9, i32 %10
  %11 = load double, double* %arrayidx1, align 8
  %cmp = fcmp olt double %8, %11
  br i1 %cmp, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  store i32 1, i32* %retval, align 4
  br label %return

if.else:                                          ; preds = %entry
  %12 = load double*, double** @base_arr, align 4
  %13 = load i32, i32* %aa, align 4
  %arrayidx2 = getelementptr inbounds double, double* %12, i32 %13
  %14 = load double, double* %arrayidx2, align 8
  %15 = load double*, double** @base_arr, align 4
  %16 = load i32, i32* %bb, align 4
  %arrayidx3 = getelementptr inbounds double, double* %15, i32 %16
  %17 = load double, double* %arrayidx3, align 8
  %cmp4 = fcmp oeq double %14, %17
  br i1 %cmp4, label %if.then5, label %if.else6

if.then5:                                         ; preds = %if.else
  store i32 0, i32* %retval, align 4
  br label %return

if.else6:                                         ; preds = %if.else
  store i32 -1, i32* %retval, align 4
  br label %return

return:                                           ; preds = %if.else6, %if.then5, %if.then
  %18 = load i32, i32* %retval, align 4
  ret i32 %18
}

declare void @free(i8* %0) #1

; Function Attrs: noinline nounwind optnone
define hidden double* @cummin(double* noalias %ARRAY, i32 %NO_OF_ARRAY_ELEMENTS) #0 {
entry:
  %ARRAY.addr = alloca double*, align 4
  %NO_OF_ARRAY_ELEMENTS.addr = alloca i32, align 4
  %output = alloca double*, align 4
  %cumulative_min = alloca double, align 8
  %i = alloca i32, align 4
  store double* %ARRAY, double** %ARRAY.addr, align 4
  store i32 %NO_OF_ARRAY_ELEMENTS, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
  %0 = load i32, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
  %cmp = icmp ult i32 %0, 1
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %call = call i32 @puts(i8* getelementptr inbounds ([48 x i8], [48 x i8]* @.str.4, i32 0, i32 0))
  %call1 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([22 x i8], [22 x i8]* @.str.5, i32 0, i32 0), i8* getelementptr inbounds ([23 x i8], [23 x i8]* @.str.1, i32 0, i32 0), i32 105)
  call void @exit(i32 1) #5
  unreachable

if.end:                                           ; preds = %entry
  %1 = load i32, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
  %mul = mul i32 8, %1
  %call2 = call noalias i8* @malloc(i32 %mul)
  %2 = bitcast i8* %call2 to double*
  store double* %2, double** %output, align 4
  %3 = load double*, double** %output, align 4
  %cmp3 = icmp eq double* %3, null
  br i1 %cmp3, label %if.then4, label %if.end6

if.then4:                                         ; preds = %if.end
  %call5 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([33 x i8], [33 x i8]* @.str.3, i32 0, i32 0), i8* getelementptr inbounds ([23 x i8], [23 x i8]* @.str.1, i32 0, i32 0), i32 110)
  call void @perror(i8* getelementptr inbounds ([1 x i8], [1 x i8]* @.str.2, i32 0, i32 0))
  call void @exit(i32 1) #5
  unreachable

if.end6:                                          ; preds = %if.end
  %4 = load double*, double** %ARRAY.addr, align 4
  %arrayidx = getelementptr inbounds double, double* %4, i32 0
  %5 = load double, double* %arrayidx, align 8
  store double %5, double* %cumulative_min, align 8
  store i32 0, i32* %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.end6
  %6 = load i32, i32* %i, align 4
  %7 = load i32, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
  %cmp7 = icmp ult i32 %6, %7
  br i1 %cmp7, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %8 = load double*, double** %ARRAY.addr, align 4
  %9 = load i32, i32* %i, align 4
  %arrayidx8 = getelementptr inbounds double, double* %8, i32 %9
  %10 = load double, double* %arrayidx8, align 8
  %11 = load double, double* %cumulative_min, align 8
  %cmp9 = fcmp olt double %10, %11
  br i1 %cmp9, label %if.then10, label %if.end12

if.then10:                                        ; preds = %for.body
  %12 = load double*, double** %ARRAY.addr, align 4
  %13 = load i32, i32* %i, align 4
  %arrayidx11 = getelementptr inbounds double, double* %12, i32 %13
  %14 = load double, double* %arrayidx11, align 8
  store double %14, double* %cumulative_min, align 8
  br label %if.end12

if.end12:                                         ; preds = %if.then10, %for.body
  %15 = load double, double* %cumulative_min, align 8
  %16 = load double*, double** %output, align 4
  %17 = load i32, i32* %i, align 4
  %arrayidx13 = getelementptr inbounds double, double* %16, i32 %17
  store double %15, double* %arrayidx13, align 8
  br label %for.inc

for.inc:                                          ; preds = %if.end12
  %18 = load i32, i32* %i, align 4
  %inc = add i32 %18, 1
  store i32 %inc, i32* %i, align 4
  br label %for.cond

for.end:                                          ; preds = %for.cond
  %19 = load double*, double** %output, align 4
  ret double* %19
}

declare i32 @puts(i8* %0) #1

; Function Attrs: noinline nounwind optnone
define hidden double* @cummax(double* noalias %ARRAY, i32 %NO_OF_ARRAY_ELEMENTS) #0 {
entry:
  %ARRAY.addr = alloca double*, align 4
  %NO_OF_ARRAY_ELEMENTS.addr = alloca i32, align 4
  %output = alloca double*, align 4
  %cumulative_max = alloca double, align 8
  %i = alloca i32, align 4
  store double* %ARRAY, double** %ARRAY.addr, align 4
  store i32 %NO_OF_ARRAY_ELEMENTS, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
  %0 = load i32, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
  %cmp = icmp ult i32 %0, 1
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %call = call i32 @puts(i8* getelementptr inbounds ([41 x i8], [41 x i8]* @.str.6, i32 0, i32 0))
  %call1 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([22 x i8], [22 x i8]* @.str.5, i32 0, i32 0), i8* getelementptr inbounds ([23 x i8], [23 x i8]* @.str.1, i32 0, i32 0), i32 129)
  call void @exit(i32 1) #5
  unreachable

if.end:                                           ; preds = %entry
  %1 = load i32, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
  %mul = mul i32 8, %1
  %call2 = call noalias i8* @malloc(i32 %mul)
  %2 = bitcast i8* %call2 to double*
  store double* %2, double** %output, align 4
  %3 = load double*, double** %output, align 4
  %cmp3 = icmp eq double* %3, null
  br i1 %cmp3, label %if.then4, label %if.end6

if.then4:                                         ; preds = %if.end
  %call5 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([33 x i8], [33 x i8]* @.str.3, i32 0, i32 0), i8* getelementptr inbounds ([23 x i8], [23 x i8]* @.str.1, i32 0, i32 0), i32 134)
  call void @perror(i8* getelementptr inbounds ([1 x i8], [1 x i8]* @.str.2, i32 0, i32 0))
  call void @exit(i32 1) #5
  unreachable

if.end6:                                          ; preds = %if.end
  %4 = load double*, double** %ARRAY.addr, align 4
  %arrayidx = getelementptr inbounds double, double* %4, i32 0
  %5 = load double, double* %arrayidx, align 8
  store double %5, double* %cumulative_max, align 8
  store i32 0, i32* %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.end6
  %6 = load i32, i32* %i, align 4
  %7 = load i32, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
  %cmp7 = icmp ult i32 %6, %7
  br i1 %cmp7, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %8 = load double*, double** %ARRAY.addr, align 4
  %9 = load i32, i32* %i, align 4
  %arrayidx8 = getelementptr inbounds double, double* %8, i32 %9
  %10 = load double, double* %arrayidx8, align 8
  %11 = load double, double* %cumulative_max, align 8
  %cmp9 = fcmp ogt double %10, %11
  br i1 %cmp9, label %if.then10, label %if.end12

if.then10:                                        ; preds = %for.body
  %12 = load double*, double** %ARRAY.addr, align 4
  %13 = load i32, i32* %i, align 4
  %arrayidx11 = getelementptr inbounds double, double* %12, i32 %13
  %14 = load double, double* %arrayidx11, align 8
  store double %14, double* %cumulative_max, align 8
  br label %if.end12

if.end12:                                         ; preds = %if.then10, %for.body
  %15 = load double, double* %cumulative_max, align 8
  %16 = load double*, double** %output, align 4
  %17 = load i32, i32* %i, align 4
  %arrayidx13 = getelementptr inbounds double, double* %16, i32 %17
  store double %15, double* %arrayidx13, align 8
  br label %for.inc

for.inc:                                          ; preds = %if.end12
  %18 = load i32, i32* %i, align 4
  %inc = add i32 %18, 1
  store i32 %inc, i32* %i, align 4
  br label %for.cond

for.end:                                          ; preds = %for.cond
  %19 = load double*, double** %output, align 4
  ret double* %19
}

; Function Attrs: noinline nounwind optnone
define hidden double* @pminx(double* noalias %ARRAY, i32 %NO_OF_ARRAY_ELEMENTS, double %X) #0 {
entry:
  %ARRAY.addr = alloca double*, align 4
  %NO_OF_ARRAY_ELEMENTS.addr = alloca i32, align 4
  %X.addr = alloca double, align 8
  %pmin_array = alloca double*, align 4
  %index = alloca i32, align 4
  store double* %ARRAY, double** %ARRAY.addr, align 4
  store i32 %NO_OF_ARRAY_ELEMENTS, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
  store double %X, double* %X.addr, align 8
  %0 = load i32, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
  %cmp = icmp ult i32 %0, 1
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %call = call i32 @puts(i8* getelementptr inbounds ([37 x i8], [37 x i8]* @.str.7, i32 0, i32 0))
  %call1 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([22 x i8], [22 x i8]* @.str.5, i32 0, i32 0), i8* getelementptr inbounds ([23 x i8], [23 x i8]* @.str.1, i32 0, i32 0), i32 152)
  call void @exit(i32 1) #5
  unreachable

if.end:                                           ; preds = %entry
  %1 = load i32, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
  %mul = mul i32 8, %1
  %call2 = call noalias i8* @malloc(i32 %mul)
  %2 = bitcast i8* %call2 to double*
  store double* %2, double** %pmin_array, align 4
  %3 = load double*, double** %pmin_array, align 4
  %cmp3 = icmp eq double* %3, null
  br i1 %cmp3, label %if.then4, label %if.end6

if.then4:                                         ; preds = %if.end
  %call5 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([33 x i8], [33 x i8]* @.str.3, i32 0, i32 0), i8* getelementptr inbounds ([23 x i8], [23 x i8]* @.str.1, i32 0, i32 0), i32 157)
  call void @perror(i8* getelementptr inbounds ([1 x i8], [1 x i8]* @.str.2, i32 0, i32 0))
  call void @exit(i32 1) #5
  unreachable

if.end6:                                          ; preds = %if.end
  store i32 0, i32* %index, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.end6
  %4 = load i32, i32* %index, align 4
  %5 = load i32, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
  %cmp7 = icmp ult i32 %4, %5
  br i1 %cmp7, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %6 = load double*, double** %ARRAY.addr, align 4
  %7 = load i32, i32* %index, align 4
  %arrayidx = getelementptr inbounds double, double* %6, i32 %7
  %8 = load double, double* %arrayidx, align 8
  %9 = load double, double* %X.addr, align 8
  %cmp8 = fcmp olt double %8, %9
  br i1 %cmp8, label %if.then9, label %if.else

if.then9:                                         ; preds = %for.body
  %10 = load double*, double** %ARRAY.addr, align 4
  %11 = load i32, i32* %index, align 4
  %arrayidx10 = getelementptr inbounds double, double* %10, i32 %11
  %12 = load double, double* %arrayidx10, align 8
  %13 = load double*, double** %pmin_array, align 4
  %14 = load i32, i32* %index, align 4
  %arrayidx11 = getelementptr inbounds double, double* %13, i32 %14
  store double %12, double* %arrayidx11, align 8
  br label %if.end13

if.else:                                          ; preds = %for.body
  %15 = load double, double* %X.addr, align 8
  %16 = load double*, double** %pmin_array, align 4
  %17 = load i32, i32* %index, align 4
  %arrayidx12 = getelementptr inbounds double, double* %16, i32 %17
  store double %15, double* %arrayidx12, align 8
  br label %if.end13

if.end13:                                         ; preds = %if.else, %if.then9
  br label %for.inc

for.inc:                                          ; preds = %if.end13
  %18 = load i32, i32* %index, align 4
  %inc = add i32 %18, 1
  store i32 %inc, i32* %index, align 4
  br label %for.cond

for.end:                                          ; preds = %for.cond
  %19 = load double*, double** %pmin_array, align 4
  ret double* %19
}

; Function Attrs: noinline nounwind optnone
define hidden void @double_say(double* noalias %ARRAY, i32 %NO_OF_ARRAY_ELEMENTS) #0 {
entry:
  %ARRAY.addr = alloca double*, align 4
  %NO_OF_ARRAY_ELEMENTS.addr = alloca i32, align 4
  %i = alloca i32, align 4
  store double* %ARRAY, double** %ARRAY.addr, align 4
  store i32 %NO_OF_ARRAY_ELEMENTS, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
  %0 = load double*, double** %ARRAY.addr, align 4
  %arrayidx = getelementptr inbounds double, double* %0, i32 0
  %1 = load double, double* %arrayidx, align 8
  %call = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([7 x i8], [7 x i8]* @.str.8, i32 0, i32 0), double %1)
  store i32 1, i32* %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %2 = load i32, i32* %i, align 4
  %3 = load i32, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
  %cmp = icmp ult i32 %2, %3
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %4 = load double*, double** %ARRAY.addr, align 4
  %5 = load i32, i32* %i, align 4
  %arrayidx1 = getelementptr inbounds double, double* %4, i32 %5
  %6 = load double, double* %arrayidx1, align 8
  %call2 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([7 x i8], [7 x i8]* @.str.9, i32 0, i32 0), double %6)
  %7 = load i32, i32* %i, align 4
  %add = add i32 %7, 1
  %rem = urem i32 %add, 5
  %cmp3 = icmp eq i32 %rem, 0
  br i1 %cmp3, label %if.then, label %if.end

if.then:                                          ; preds = %for.body
  %8 = load i32, i32* %i, align 4
  %add4 = add i32 %8, 1
  %call5 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([6 x i8], [6 x i8]* @.str.10, i32 0, i32 0), i32 %add4)
  br label %if.end

if.end:                                           ; preds = %if.then, %for.body
  br label %for.inc

for.inc:                                          ; preds = %if.end
  %9 = load i32, i32* %i, align 4
  %inc = add i32 %9, 1
  store i32 %inc, i32* %i, align 4
  br label %for.cond

for.end:                                          ; preds = %for.cond
  %call6 = call i32 @puts(i8* getelementptr inbounds ([2 x i8], [2 x i8]* @.str.11, i32 0, i32 0))
  ret void
}

; Function Attrs: noinline nounwind optnone
define hidden double* @uint2double(i32* noalias %ARRAY, i32 %NO_OF_ARRAY_ELEMENTS) #0 {
entry:
  %ARRAY.addr = alloca i32*, align 4
  %NO_OF_ARRAY_ELEMENTS.addr = alloca i32, align 4
  %doubleArray = alloca double*, align 4
  %index = alloca i32, align 4
  store i32* %ARRAY, i32** %ARRAY.addr, align 4
  store i32 %NO_OF_ARRAY_ELEMENTS, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
  %0 = load i32, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
  %mul = mul i32 8, %0
  %call = call noalias i8* @malloc(i32 %mul)
  %1 = bitcast i8* %call to double*
  store double* %1, double** %doubleArray, align 4
  %2 = load double*, double** %doubleArray, align 4
  %cmp = icmp eq double* %2, null
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %call1 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([34 x i8], [34 x i8]* @.str.12, i32 0, i32 0), i8* getelementptr inbounds ([23 x i8], [23 x i8]* @.str.1, i32 0, i32 0), i32 194)
  call void @perror(i8* getelementptr inbounds ([1 x i8], [1 x i8]* @.str.2, i32 0, i32 0))
  call void @exit(i32 1) #5
  unreachable

if.end:                                           ; preds = %entry
  store i32 0, i32* %index, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.end
  %3 = load i32, i32* %index, align 4
  %4 = load i32, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
  %cmp2 = icmp ult i32 %3, %4
  br i1 %cmp2, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %5 = load i32*, i32** %ARRAY.addr, align 4
  %6 = load i32, i32* %index, align 4
  %arrayidx = getelementptr inbounds i32, i32* %5, i32 %6
  %7 = load i32, i32* %arrayidx, align 4
  %conv = uitofp i32 %7 to double
  %8 = load double*, double** %doubleArray, align 4
  %9 = load i32, i32* %index, align 4
  %arrayidx3 = getelementptr inbounds double, double* %8, i32 %9
  store double %conv, double* %arrayidx3, align 8
  br label %for.inc

for.inc:                                          ; preds = %for.body
  %10 = load i32, i32* %index, align 4
  %inc = add i32 %10, 1
  store i32 %inc, i32* %index, align 4
  br label %for.cond

for.end:                                          ; preds = %for.cond
  %11 = load double*, double** %doubleArray, align 4
  ret double* %11
}

; Function Attrs: noinline nounwind optnone
define hidden double @min2(double %N1, double %N2) #0 {
entry:
  %retval = alloca double, align 8
  %N1.addr = alloca double, align 8
  %N2.addr = alloca double, align 8
  store double %N1, double* %N1.addr, align 8
  store double %N2, double* %N2.addr, align 8
  %0 = load double, double* %N1.addr, align 8
  %1 = load double, double* %N2.addr, align 8
  %cmp = fcmp olt double %0, %1
  br i1 %cmp, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  %2 = load double, double* %N1.addr, align 8
  store double %2, double* %retval, align 8
  br label %return

if.else:                                          ; preds = %entry
  %3 = load double, double* %N2.addr, align 8
  store double %3, double* %retval, align 8
  br label %return

return:                                           ; preds = %if.else, %if.then
  %4 = load double, double* %retval, align 8
  ret double %4
}

; Function Attrs: noinline nounwind optnone
define hidden double* @p_adjust(double* noalias %PVALUES, i32 %NO_OF_ARRAY_ELEMENTS, i8* noalias %STRING) #0 {
entry:
  %retval = alloca double*, align 4
  %PVALUES.addr = alloca double*, align 4
  %NO_OF_ARRAY_ELEMENTS.addr = alloca i32, align 4
  %STRING.addr = alloca i8*, align 4
  %TYPE = alloca i16, align 2
  %bonferroni = alloca double*, align 4
  %index = alloca i32, align 4
  %BONFERRONI = alloca double, align 8
  %o = alloca i32*, align 4
  %o2double = alloca double*, align 4
  %cummax_input = alloca double*, align 4
  %index80 = alloca i32, align 4
  %ro = alloca i32*, align 4
  %cummax_output = alloca double*, align 4
  %pmin = alloca double*, align 4
  %qvalues = alloca double*, align 4
  %index98 = alloca i32, align 4
  %o114 = alloca i32*, align 4
  %p = alloca double*, align 4
  %index123 = alloca i32, align 4
  %o2double134 = alloca double*, align 4
  %ro136 = alloca i32*, align 4
  %q = alloca double*, align 4
  %pa = alloca double*, align 4
  %min = alloca double, align 8
  %index155 = alloca i32, align 4
  %TEMP = alloca double, align 8
  %index171 = alloca i32, align 4
  %j = alloca i32, align 4
  %ij = alloca i32*, align 4
  %I2_LENGTH = alloca i32, align 4
  %i2 = alloca i32*, align 4
  %i = alloca i32, align 4
  %q1 = alloca double, align 8
  %i208 = alloca i32, align 4
  %TEMP_Q1 = alloca double, align 8
  %i227 = alloca i32, align 4
  %i244 = alloca i32, align 4
  %i256 = alloca i32, align 4
  %index274 = alloca i32, align 4
  %o288 = alloca i32*, align 4
  %o_double = alloca double*, align 4
  %index296 = alloca i32, align 4
  %ro315 = alloca i32*, align 4
  %cummin_input = alloca double*, align 4
  %index328 = alloca i32, align 4
  %NI = alloca double, align 8
  %q349 = alloca double, align 8
  %index350 = alloca i32, align 4
  %index362 = alloca i32, align 4
  %NI367 = alloca double, align 8
  %index385 = alloca i32, align 4
  %cummin_array = alloca double*, align 4
  %pmin403 = alloca double*, align 4
  %q_array = alloca double*, align 4
  %index407 = alloca i32, align 4
  store double* %PVALUES, double** %PVALUES.addr, align 4
  store i32 %NO_OF_ARRAY_ELEMENTS, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
  store i8* %STRING, i8** %STRING.addr, align 4
  %0 = load i32, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
  %cmp = icmp ult i32 %0, 1
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %call = call i32 @puts(i8* getelementptr inbounds ([41 x i8], [41 x i8]* @.str.13, i32 0, i32 0))
  %call1 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([22 x i8], [22 x i8]* @.str.5, i32 0, i32 0), i8* getelementptr inbounds ([23 x i8], [23 x i8]* @.str.1, i32 0, i32 0), i32 217)
  call void @exit(i32 1) #5
  unreachable

if.end:                                           ; preds = %entry
  store i16 -1, i16* %TYPE, align 2
  %1 = load i8*, i8** %STRING.addr, align 4
  %cmp2 = icmp eq i8* %1, null
  br i1 %cmp2, label %if.then3, label %if.else

if.then3:                                         ; preds = %if.end
  store i16 0, i16* %TYPE, align 2
  br label %if.end41

if.else:                                          ; preds = %if.end
  %2 = load i8*, i8** %STRING.addr, align 4
  %call4 = call i32 @strcasecmp(i8* %2, i8* getelementptr inbounds ([3 x i8], [3 x i8]* @.str.14, i32 0, i32 0))
  %cmp5 = icmp eq i32 %call4, 0
  br i1 %cmp5, label %if.then6, label %if.else7

if.then6:                                         ; preds = %if.else
  store i16 0, i16* %TYPE, align 2
  br label %if.end40

if.else7:                                         ; preds = %if.else
  %3 = load i8*, i8** %STRING.addr, align 4
  %call8 = call i32 @strcasecmp(i8* %3, i8* getelementptr inbounds ([4 x i8], [4 x i8]* @.str.15, i32 0, i32 0))
  %cmp9 = icmp eq i32 %call8, 0
  br i1 %cmp9, label %if.then10, label %if.else11

if.then10:                                        ; preds = %if.else7
  store i16 0, i16* %TYPE, align 2
  br label %if.end39

if.else11:                                        ; preds = %if.else7
  %4 = load i8*, i8** %STRING.addr, align 4
  %call12 = call i32 @strcasecmp(i8* %4, i8* getelementptr inbounds ([3 x i8], [3 x i8]* @.str.16, i32 0, i32 0))
  %cmp13 = icmp eq i32 %call12, 0
  br i1 %cmp13, label %if.then14, label %if.else15

if.then14:                                        ; preds = %if.else11
  store i16 1, i16* %TYPE, align 2
  br label %if.end38

if.else15:                                        ; preds = %if.else11
  %5 = load i8*, i8** %STRING.addr, align 4
  %call16 = call i32 @strcasecmp(i8* %5, i8* getelementptr inbounds ([11 x i8], [11 x i8]* @.str.17, i32 0, i32 0))
  %cmp17 = icmp eq i32 %call16, 0
  br i1 %cmp17, label %if.then18, label %if.else19

if.then18:                                        ; preds = %if.else15
  store i16 2, i16* %TYPE, align 2
  br label %if.end37

if.else19:                                        ; preds = %if.else15
  %6 = load i8*, i8** %STRING.addr, align 4
  %call20 = call i32 @strcasecmp(i8* %6, i8* getelementptr inbounds ([9 x i8], [9 x i8]* @.str.18, i32 0, i32 0))
  %cmp21 = icmp eq i32 %call20, 0
  br i1 %cmp21, label %if.then22, label %if.else23

if.then22:                                        ; preds = %if.else19
  store i16 3, i16* %TYPE, align 2
  br label %if.end36

if.else23:                                        ; preds = %if.else19
  %7 = load i8*, i8** %STRING.addr, align 4
  %call24 = call i32 @strcasecmp(i8* %7, i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.19, i32 0, i32 0))
  %cmp25 = icmp eq i32 %call24, 0
  br i1 %cmp25, label %if.then26, label %if.else27

if.then26:                                        ; preds = %if.else23
  store i16 4, i16* %TYPE, align 2
  br label %if.end35

if.else27:                                        ; preds = %if.else23
  %8 = load i8*, i8** %STRING.addr, align 4
  %call28 = call i32 @strcasecmp(i8* %8, i8* getelementptr inbounds ([7 x i8], [7 x i8]* @.str.20, i32 0, i32 0))
  %cmp29 = icmp eq i32 %call28, 0
  br i1 %cmp29, label %if.then30, label %if.else31

if.then30:                                        ; preds = %if.else27
  store i16 5, i16* %TYPE, align 2
  br label %if.end34

if.else31:                                        ; preds = %if.else27
  %9 = load i8*, i8** %STRING.addr, align 4
  %call32 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([44 x i8], [44 x i8]* @.str.21, i32 0, i32 0), i8* %9)
  %call33 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([22 x i8], [22 x i8]* @.str.5, i32 0, i32 0), i8* getelementptr inbounds ([23 x i8], [23 x i8]* @.str.1, i32 0, i32 0), i32 239)
  call void @exit(i32 1) #5
  unreachable

if.end34:                                         ; preds = %if.then30
  br label %if.end35

if.end35:                                         ; preds = %if.end34, %if.then26
  br label %if.end36

if.end36:                                         ; preds = %if.end35, %if.then22
  br label %if.end37

if.end37:                                         ; preds = %if.end36, %if.then18
  br label %if.end38

if.end38:                                         ; preds = %if.end37, %if.then14
  br label %if.end39

if.end39:                                         ; preds = %if.end38, %if.then10
  br label %if.end40

if.end40:                                         ; preds = %if.end39, %if.then6
  br label %if.end41

if.end41:                                         ; preds = %if.end40, %if.then3
  %10 = load i16, i16* %TYPE, align 2
  %conv = sext i16 %10 to i32
  %cmp42 = icmp eq i32 %conv, 2
  br i1 %cmp42, label %if.then44, label %if.else71

if.then44:                                        ; preds = %if.end41
  %11 = load i32, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
  %mul = mul i32 8, %11
  %call45 = call noalias i8* @malloc(i32 %mul)
  %12 = bitcast i8* %call45 to double*
  store double* %12, double** %bonferroni, align 4
  %13 = load double*, double** %bonferroni, align 4
  %cmp46 = icmp eq double* %13, null
  br i1 %cmp46, label %if.then48, label %if.end50

if.then48:                                        ; preds = %if.then44
  %call49 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([33 x i8], [33 x i8]* @.str.3, i32 0, i32 0), i8* getelementptr inbounds ([23 x i8], [23 x i8]* @.str.1, i32 0, i32 0), i32 247)
  call void @perror(i8* getelementptr inbounds ([1 x i8], [1 x i8]* @.str.2, i32 0, i32 0))
  call void @exit(i32 1) #5
  unreachable

if.end50:                                         ; preds = %if.then44
  store i32 0, i32* %index, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.end50
  %14 = load i32, i32* %index, align 4
  %15 = load i32, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
  %cmp51 = icmp ult i32 %14, %15
  br i1 %cmp51, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %16 = load double*, double** %PVALUES.addr, align 4
  %17 = load i32, i32* %index, align 4
  %arrayidx = getelementptr inbounds double, double* %16, i32 %17
  %18 = load double, double* %arrayidx, align 8
  %19 = load i32, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
  %conv53 = uitofp i32 %19 to double
  %mul54 = fmul double %18, %conv53
  store double %mul54, double* %BONFERRONI, align 8
  %20 = load double, double* %BONFERRONI, align 8
  %cmp55 = fcmp oge double %20, 1.000000e+00
  br i1 %cmp55, label %if.then57, label %if.else59

if.then57:                                        ; preds = %for.body
  %21 = load double*, double** %bonferroni, align 4
  %22 = load i32, i32* %index, align 4
  %arrayidx58 = getelementptr inbounds double, double* %21, i32 %22
  store double 1.000000e+00, double* %arrayidx58, align 8
  br label %if.end70

if.else59:                                        ; preds = %for.body
  %23 = load double, double* %BONFERRONI, align 8
  %cmp60 = fcmp ole double 0.000000e+00, %23
  br i1 %cmp60, label %land.lhs.true, label %if.else66

land.lhs.true:                                    ; preds = %if.else59
  %24 = load double, double* %BONFERRONI, align 8
  %cmp62 = fcmp olt double %24, 1.000000e+00
  br i1 %cmp62, label %if.then64, label %if.else66

if.then64:                                        ; preds = %land.lhs.true
  %25 = load double, double* %BONFERRONI, align 8
  %26 = load double*, double** %bonferroni, align 4
  %27 = load i32, i32* %index, align 4
  %arrayidx65 = getelementptr inbounds double, double* %26, i32 %27
  store double %25, double* %arrayidx65, align 8
  br label %if.end69

if.else66:                                        ; preds = %land.lhs.true, %if.else59
  %28 = load double, double* %BONFERRONI, align 8
  %call67 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([42 x i8], [42 x i8]* @.str.22, i32 0, i32 0), double %28)
  %call68 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([23 x i8], [23 x i8]* @.str.23, i32 0, i32 0), i8* getelementptr inbounds ([23 x i8], [23 x i8]* @.str.1, i32 0, i32 0), i32 259)
  call void @exit(i32 1) #5
  unreachable

if.end69:                                         ; preds = %if.then64
  br label %if.end70

if.end70:                                         ; preds = %if.end69, %if.then57
  br label %for.inc

for.inc:                                          ; preds = %if.end70
  %29 = load i32, i32* %index, align 4
  %inc = add i32 %29, 1
  store i32 %inc, i32* %index, align 4
  br label %for.cond

for.end:                                          ; preds = %for.cond
  %30 = load double*, double** %bonferroni, align 4
  store double* %30, double** %retval, align 4
  br label %return

if.else71:                                        ; preds = %if.end41
  %31 = load i16, i16* %TYPE, align 2
  %conv72 = sext i16 %31 to i32
  %cmp73 = icmp eq i32 %conv72, 4
  br i1 %cmp73, label %if.then75, label %if.else109

if.then75:                                        ; preds = %if.else71
  %32 = load double*, double** %PVALUES.addr, align 4
  %33 = load i32, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
  %call76 = call i32* @order(double* %32, i32 %33, i1 zeroext false)
  store i32* %call76, i32** %o, align 4
  %34 = load i32*, i32** %o, align 4
  %35 = load i32, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
  %call77 = call double* @uint2double(i32* %34, i32 %35)
  store double* %call77, double** %o2double, align 4
  %36 = load i32, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
  %mul78 = mul i32 8, %36
  %call79 = call noalias i8* @malloc(i32 %mul78)
  %37 = bitcast i8* %call79 to double*
  store double* %37, double** %cummax_input, align 4
  store i32 0, i32* %index80, align 4
  br label %for.cond81

for.cond81:                                       ; preds = %for.inc90, %if.then75
  %38 = load i32, i32* %index80, align 4
  %39 = load i32, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
  %cmp82 = icmp ult i32 %38, %39
  br i1 %cmp82, label %for.body84, label %for.end92

for.body84:                                       ; preds = %for.cond81
  %40 = load i32, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
  %41 = load i32, i32* %index80, align 4
  %sub = sub i32 %40, %41
  %conv85 = uitofp i32 %sub to double
  %42 = load double*, double** %PVALUES.addr, align 4
  %43 = load i32*, i32** %o, align 4
  %44 = load i32, i32* %index80, align 4
  %arrayidx86 = getelementptr inbounds i32, i32* %43, i32 %44
  %45 = load i32, i32* %arrayidx86, align 4
  %arrayidx87 = getelementptr inbounds double, double* %42, i32 %45
  %46 = load double, double* %arrayidx87, align 8
  %mul88 = fmul double %conv85, %46
  %47 = load double*, double** %cummax_input, align 4
  %48 = load i32, i32* %index80, align 4
  %arrayidx89 = getelementptr inbounds double, double* %47, i32 %48
  store double %mul88, double* %arrayidx89, align 8
  br label %for.inc90

for.inc90:                                        ; preds = %for.body84
  %49 = load i32, i32* %index80, align 4
  %inc91 = add i32 %49, 1
  store i32 %inc91, i32* %index80, align 4
  br label %for.cond81

for.end92:                                        ; preds = %for.cond81
  %50 = load i32*, i32** %o, align 4
  %51 = bitcast i32* %50 to i8*
  call void @free(i8* %51)
  store i32* null, i32** %o, align 4
  %52 = load double*, double** %o2double, align 4
  %53 = load i32, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
  %call93 = call i32* @order(double* %52, i32 %53, i1 zeroext false)
  store i32* %call93, i32** %ro, align 4
  %54 = load double*, double** %o2double, align 4
  %55 = bitcast double* %54 to i8*
  call void @free(i8* %55)
  store double* null, double** %o2double, align 4
  %56 = load double*, double** %cummax_input, align 4
  %57 = load i32, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
  %call94 = call double* @cummax(double* %56, i32 %57)
  store double* %call94, double** %cummax_output, align 4
  %58 = load double*, double** %cummax_input, align 4
  %59 = bitcast double* %58 to i8*
  call void @free(i8* %59)
  store double* null, double** %cummax_input, align 4
  %60 = load double*, double** %cummax_output, align 4
  %61 = load i32, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
  %call95 = call double* @pminx(double* %60, i32 %61, double 1.000000e+00)
  store double* %call95, double** %pmin, align 4
  %62 = load double*, double** %cummax_output, align 4
  %63 = bitcast double* %62 to i8*
  call void @free(i8* %63)
  store double* null, double** %cummax_output, align 4
  %64 = load i32, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
  %mul96 = mul i32 8, %64
  %call97 = call noalias i8* @malloc(i32 %mul96)
  %65 = bitcast i8* %call97 to double*
  store double* %65, double** %qvalues, align 4
  store i32 0, i32* %index98, align 4
  br label %for.cond99

for.cond99:                                       ; preds = %for.inc106, %for.end92
  %66 = load i32, i32* %index98, align 4
  %67 = load i32, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
  %cmp100 = icmp ult i32 %66, %67
  br i1 %cmp100, label %for.body102, label %for.end108

for.body102:                                      ; preds = %for.cond99
  %68 = load double*, double** %pmin, align 4
  %69 = load i32*, i32** %ro, align 4
  %70 = load i32, i32* %index98, align 4
  %arrayidx103 = getelementptr inbounds i32, i32* %69, i32 %70
  %71 = load i32, i32* %arrayidx103, align 4
  %arrayidx104 = getelementptr inbounds double, double* %68, i32 %71
  %72 = load double, double* %arrayidx104, align 8
  %73 = load double*, double** %qvalues, align 4
  %74 = load i32, i32* %index98, align 4
  %arrayidx105 = getelementptr inbounds double, double* %73, i32 %74
  store double %72, double* %arrayidx105, align 8
  br label %for.inc106

for.inc106:                                       ; preds = %for.body102
  %75 = load i32, i32* %index98, align 4
  %inc107 = add i32 %75, 1
  store i32 %inc107, i32* %index98, align 4
  br label %for.cond99

for.end108:                                       ; preds = %for.cond99
  %76 = load double*, double** %pmin, align 4
  %77 = bitcast double* %76 to i8*
  call void @free(i8* %77)
  store double* null, double** %pmin, align 4
  %78 = load i32*, i32** %ro, align 4
  %79 = bitcast i32* %78 to i8*
  call void @free(i8* %79)
  store i32* null, i32** %ro, align 4
  %80 = load double*, double** %qvalues, align 4
  store double* %80, double** %retval, align 4
  br label %return

if.else109:                                       ; preds = %if.else71
  %81 = load i16, i16* %TYPE, align 2
  %conv110 = sext i16 %81 to i32
  %cmp111 = icmp eq i32 %conv110, 5
  br i1 %cmp111, label %if.then113, label %if.end285

if.then113:                                       ; preds = %if.else109
  %82 = load double*, double** %PVALUES.addr, align 4
  %83 = load i32, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
  %call115 = call i32* @order(double* %82, i32 %83, i1 zeroext false)
  store i32* %call115, i32** %o114, align 4
  %84 = load i32, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
  %mul116 = mul i32 8, %84
  %call117 = call noalias i8* @malloc(i32 %mul116)
  %85 = bitcast i8* %call117 to double*
  store double* %85, double** %p, align 4
  %86 = load double*, double** %p, align 4
  %cmp118 = icmp eq double* %86, null
  br i1 %cmp118, label %if.then120, label %if.end122

if.then120:                                       ; preds = %if.then113
  %call121 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([33 x i8], [33 x i8]* @.str.3, i32 0, i32 0), i8* getelementptr inbounds ([23 x i8], [23 x i8]* @.str.1, i32 0, i32 0), i32 302)
  call void @perror(i8* getelementptr inbounds ([1 x i8], [1 x i8]* @.str.2, i32 0, i32 0))
  call void @exit(i32 1) #5
  unreachable

if.end122:                                        ; preds = %if.then113
  store i32 0, i32* %index123, align 4
  br label %for.cond124

for.cond124:                                      ; preds = %for.inc131, %if.end122
  %87 = load i32, i32* %index123, align 4
  %88 = load i32, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
  %cmp125 = icmp ult i32 %87, %88
  br i1 %cmp125, label %for.body127, label %for.end133

for.body127:                                      ; preds = %for.cond124
  %89 = load double*, double** %PVALUES.addr, align 4
  %90 = load i32*, i32** %o114, align 4
  %91 = load i32, i32* %index123, align 4
  %arrayidx128 = getelementptr inbounds i32, i32* %90, i32 %91
  %92 = load i32, i32* %arrayidx128, align 4
  %arrayidx129 = getelementptr inbounds double, double* %89, i32 %92
  %93 = load double, double* %arrayidx129, align 8
  %94 = load double*, double** %p, align 4
  %95 = load i32, i32* %index123, align 4
  %arrayidx130 = getelementptr inbounds double, double* %94, i32 %95
  store double %93, double* %arrayidx130, align 8
  br label %for.inc131

for.inc131:                                       ; preds = %for.body127
  %96 = load i32, i32* %index123, align 4
  %inc132 = add i32 %96, 1
  store i32 %inc132, i32* %index123, align 4
  br label %for.cond124

for.end133:                                       ; preds = %for.cond124
  %97 = load i32*, i32** %o114, align 4
  %98 = load i32, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
  %call135 = call double* @uint2double(i32* %97, i32 %98)
  store double* %call135, double** %o2double134, align 4
  %99 = load i32*, i32** %o114, align 4
  %100 = bitcast i32* %99 to i8*
  call void @free(i8* %100)
  store i32* null, i32** %o114, align 4
  %101 = load double*, double** %o2double134, align 4
  %102 = load i32, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
  %call137 = call i32* @order(double* %101, i32 %102, i1 zeroext false)
  store i32* %call137, i32** %ro136, align 4
  %103 = load double*, double** %o2double134, align 4
  %104 = bitcast double* %103 to i8*
  call void @free(i8* %104)
  store double* null, double** %o2double134, align 4
  %105 = load i32, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
  %mul138 = mul i32 8, %105
  %call139 = call noalias i8* @malloc(i32 %mul138)
  %106 = bitcast i8* %call139 to double*
  store double* %106, double** %q, align 4
  %107 = load double*, double** %q, align 4
  %cmp140 = icmp eq double* %107, null
  br i1 %cmp140, label %if.then142, label %if.end144

if.then142:                                       ; preds = %for.end133
  %call143 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([33 x i8], [33 x i8]* @.str.3, i32 0, i32 0), i8* getelementptr inbounds ([23 x i8], [23 x i8]* @.str.1, i32 0, i32 0), i32 318)
  call void @perror(i8* getelementptr inbounds ([1 x i8], [1 x i8]* @.str.2, i32 0, i32 0))
  call void @exit(i32 1) #5
  unreachable

if.end144:                                        ; preds = %for.end133
  %108 = load i32, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
  %mul145 = mul i32 8, %108
  %call146 = call noalias i8* @malloc(i32 %mul145)
  %109 = bitcast i8* %call146 to double*
  store double* %109, double** %pa, align 4
  %110 = load double*, double** %pa, align 4
  %cmp147 = icmp eq double* %110, null
  br i1 %cmp147, label %if.then149, label %if.end151

if.then149:                                       ; preds = %if.end144
  %call150 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([33 x i8], [33 x i8]* @.str.3, i32 0, i32 0), i8* getelementptr inbounds ([23 x i8], [23 x i8]* @.str.1, i32 0, i32 0), i32 324)
  call void @perror(i8* getelementptr inbounds ([1 x i8], [1 x i8]* @.str.2, i32 0, i32 0))
  call void @exit(i32 1) #5
  unreachable

if.end151:                                        ; preds = %if.end144
  %111 = load i32, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
  %conv152 = uitofp i32 %111 to double
  %112 = load double*, double** %p, align 4
  %arrayidx153 = getelementptr inbounds double, double* %112, i32 0
  %113 = load double, double* %arrayidx153, align 8
  %mul154 = fmul double %conv152, %113
  store double %mul154, double* %min, align 8
  store i32 1, i32* %index155, align 4
  br label %for.cond156

for.cond156:                                      ; preds = %for.inc168, %if.end151
  %114 = load i32, i32* %index155, align 4
  %115 = load i32, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
  %cmp157 = icmp ult i32 %114, %115
  br i1 %cmp157, label %for.body159, label %for.end170

for.body159:                                      ; preds = %for.cond156
  %116 = load i32, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
  %conv160 = uitofp i32 %116 to double
  %117 = load double*, double** %p, align 4
  %118 = load i32, i32* %index155, align 4
  %arrayidx161 = getelementptr inbounds double, double* %117, i32 %118
  %119 = load double, double* %arrayidx161, align 8
  %mul162 = fmul double %conv160, %119
  %120 = load i32, i32* %index155, align 4
  %add = add i32 1, %120
  %conv163 = uitofp i32 %add to double
  %div = fdiv double %mul162, %conv163
  store double %div, double* %TEMP, align 8
  %121 = load double, double* %TEMP, align 8
  %122 = load double, double* %min, align 8
  %cmp164 = fcmp olt double %121, %122
  br i1 %cmp164, label %if.then166, label %if.end167

if.then166:                                       ; preds = %for.body159
  %123 = load double, double* %TEMP, align 8
  store double %123, double* %min, align 8
  br label %if.end167

if.end167:                                        ; preds = %if.then166, %for.body159
  br label %for.inc168

for.inc168:                                       ; preds = %if.end167
  %124 = load i32, i32* %index155, align 4
  %inc169 = add i32 %124, 1
  store i32 %inc169, i32* %index155, align 4
  br label %for.cond156

for.end170:                                       ; preds = %for.cond156
  store i32 0, i32* %index171, align 4
  br label %for.cond172

for.cond172:                                      ; preds = %for.inc178, %for.end170
  %125 = load i32, i32* %index171, align 4
  %126 = load i32, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
  %cmp173 = icmp ult i32 %125, %126
  br i1 %cmp173, label %for.body175, label %for.end180

for.body175:                                      ; preds = %for.cond172
  %127 = load double, double* %min, align 8
  %128 = load double*, double** %pa, align 4
  %129 = load i32, i32* %index171, align 4
  %arrayidx176 = getelementptr inbounds double, double* %128, i32 %129
  store double %127, double* %arrayidx176, align 8
  %130 = load double, double* %min, align 8
  %131 = load double*, double** %q, align 4
  %132 = load i32, i32* %index171, align 4
  %arrayidx177 = getelementptr inbounds double, double* %131, i32 %132
  store double %130, double* %arrayidx177, align 8
  br label %for.inc178

for.inc178:                                       ; preds = %for.body175
  %133 = load i32, i32* %index171, align 4
  %inc179 = add i32 %133, 1
  store i32 %inc179, i32* %index171, align 4
  br label %for.cond172

for.end180:                                       ; preds = %for.cond172
  %134 = load i32, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
  %sub181 = sub i32 %134, 1
  store i32 %sub181, i32* %j, align 4
  br label %for.cond182

for.cond182:                                      ; preds = %for.inc272, %for.end180
  %135 = load i32, i32* %j, align 4
  %cmp183 = icmp uge i32 %135, 2
  br i1 %cmp183, label %for.body185, label %for.end273

for.body185:                                      ; preds = %for.cond182
  %136 = load i32, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
  %137 = load i32, i32* %j, align 4
  %sub186 = sub i32 %136, %137
  %call187 = call i32* @seq_len(i32 0, i32 %sub186)
  store i32* %call187, i32** %ij, align 4
  %138 = load i32, i32* %j, align 4
  %sub188 = sub i32 %138, 1
  store i32 %sub188, i32* %I2_LENGTH, align 4
  %139 = load i32, i32* %I2_LENGTH, align 4
  %mul189 = mul i32 %139, 4
  %call190 = call noalias i8* @malloc(i32 %mul189)
  %140 = bitcast i8* %call190 to i32*
  store i32* %140, i32** %i2, align 4
  store i32 0, i32* %i, align 4
  br label %for.cond191

for.cond191:                                      ; preds = %for.inc200, %for.body185
  %141 = load i32, i32* %i, align 4
  %142 = load i32, i32* %I2_LENGTH, align 4
  %cmp192 = icmp ult i32 %141, %142
  br i1 %cmp192, label %for.body194, label %for.end202

for.body194:                                      ; preds = %for.cond191
  %143 = load i32, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
  %144 = load i32, i32* %j, align 4
  %sub195 = sub i32 %143, %144
  %add196 = add i32 %sub195, 2
  %145 = load i32, i32* %i, align 4
  %add197 = add i32 %add196, %145
  %sub198 = sub i32 %add197, 1
  %146 = load i32*, i32** %i2, align 4
  %147 = load i32, i32* %i, align 4
  %arrayidx199 = getelementptr inbounds i32, i32* %146, i32 %147
  store i32 %sub198, i32* %arrayidx199, align 4
  br label %for.inc200

for.inc200:                                       ; preds = %for.body194
  %148 = load i32, i32* %i, align 4
  %inc201 = add i32 %148, 1
  store i32 %inc201, i32* %i, align 4
  br label %for.cond191

for.end202:                                       ; preds = %for.cond191
  %149 = load i32, i32* %j, align 4
  %conv203 = uitofp i32 %149 to double
  %150 = load double*, double** %p, align 4
  %151 = load i32*, i32** %i2, align 4
  %arrayidx204 = getelementptr inbounds i32, i32* %151, i32 0
  %152 = load i32, i32* %arrayidx204, align 4
  %arrayidx205 = getelementptr inbounds double, double* %150, i32 %152
  %153 = load double, double* %arrayidx205, align 8
  %mul206 = fmul double %conv203, %153
  %div207 = fdiv double %mul206, 2.000000e+00
  store double %div207, double* %q1, align 8
  store i32 1, i32* %i208, align 4
  br label %for.cond209

for.cond209:                                      ; preds = %for.inc224, %for.end202
  %154 = load i32, i32* %i208, align 4
  %155 = load i32, i32* %I2_LENGTH, align 4
  %cmp210 = icmp ult i32 %154, %155
  br i1 %cmp210, label %for.body212, label %for.end226

for.body212:                                      ; preds = %for.cond209
  %156 = load i32, i32* %j, align 4
  %conv213 = uitofp i32 %156 to double
  %157 = load double*, double** %p, align 4
  %158 = load i32*, i32** %i2, align 4
  %159 = load i32, i32* %i208, align 4
  %arrayidx214 = getelementptr inbounds i32, i32* %158, i32 %159
  %160 = load i32, i32* %arrayidx214, align 4
  %arrayidx215 = getelementptr inbounds double, double* %157, i32 %160
  %161 = load double, double* %arrayidx215, align 8
  %mul216 = fmul double %conv213, %161
  %162 = load i32, i32* %i208, align 4
  %add217 = add i32 2, %162
  %conv218 = uitofp i32 %add217 to double
  %div219 = fdiv double %mul216, %conv218
  store double %div219, double* %TEMP_Q1, align 8
  %163 = load double, double* %TEMP_Q1, align 8
  %164 = load double, double* %q1, align 8
  %cmp220 = fcmp olt double %163, %164
  br i1 %cmp220, label %if.then222, label %if.end223

if.then222:                                       ; preds = %for.body212
  %165 = load double, double* %TEMP_Q1, align 8
  store double %165, double* %q1, align 8
  br label %if.end223

if.end223:                                        ; preds = %if.then222, %for.body212
  br label %for.inc224

for.inc224:                                       ; preds = %if.end223
  %166 = load i32, i32* %i208, align 4
  %inc225 = add i32 %166, 1
  store i32 %inc225, i32* %i208, align 4
  br label %for.cond209

for.end226:                                       ; preds = %for.cond209
  store i32 0, i32* %i227, align 4
  br label %for.cond228

for.cond228:                                      ; preds = %for.inc241, %for.end226
  %167 = load i32, i32* %i227, align 4
  %168 = load i32, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
  %169 = load i32, i32* %j, align 4
  %sub229 = sub i32 %168, %169
  %add230 = add i32 %sub229, 1
  %cmp231 = icmp ult i32 %167, %add230
  br i1 %cmp231, label %for.body233, label %for.end243

for.body233:                                      ; preds = %for.cond228
  %170 = load i32, i32* %j, align 4
  %conv234 = uitofp i32 %170 to double
  %171 = load double*, double** %p, align 4
  %172 = load i32*, i32** %ij, align 4
  %173 = load i32, i32* %i227, align 4
  %arrayidx235 = getelementptr inbounds i32, i32* %172, i32 %173
  %174 = load i32, i32* %arrayidx235, align 4
  %arrayidx236 = getelementptr inbounds double, double* %171, i32 %174
  %175 = load double, double* %arrayidx236, align 8
  %mul237 = fmul double %conv234, %175
  %176 = load double, double* %q1, align 8
  %call238 = call double @min2(double %mul237, double %176)
  %177 = load double*, double** %q, align 4
  %178 = load i32*, i32** %ij, align 4
  %179 = load i32, i32* %i227, align 4
  %arrayidx239 = getelementptr inbounds i32, i32* %178, i32 %179
  %180 = load i32, i32* %arrayidx239, align 4
  %arrayidx240 = getelementptr inbounds double, double* %177, i32 %180
  store double %call238, double* %arrayidx240, align 8
  br label %for.inc241

for.inc241:                                       ; preds = %for.body233
  %181 = load i32, i32* %i227, align 4
  %inc242 = add i32 %181, 1
  store i32 %inc242, i32* %i227, align 4
  br label %for.cond228

for.end243:                                       ; preds = %for.cond228
  %182 = load i32*, i32** %ij, align 4
  %183 = bitcast i32* %182 to i8*
  call void @free(i8* %183)
  store i32* null, i32** %ij, align 4
  store i32 0, i32* %i244, align 4
  br label %for.cond245

for.cond245:                                      ; preds = %for.inc253, %for.end243
  %184 = load i32, i32* %i244, align 4
  %185 = load i32, i32* %I2_LENGTH, align 4
  %cmp246 = icmp ult i32 %184, %185
  br i1 %cmp246, label %for.body248, label %for.end255

for.body248:                                      ; preds = %for.cond245
  %186 = load double*, double** %q, align 4
  %187 = load i32, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
  %188 = load i32, i32* %j, align 4
  %sub249 = sub i32 %187, %188
  %arrayidx250 = getelementptr inbounds double, double* %186, i32 %sub249
  %189 = load double, double* %arrayidx250, align 8
  %190 = load double*, double** %q, align 4
  %191 = load i32*, i32** %i2, align 4
  %192 = load i32, i32* %i244, align 4
  %arrayidx251 = getelementptr inbounds i32, i32* %191, i32 %192
  %193 = load i32, i32* %arrayidx251, align 4
  %arrayidx252 = getelementptr inbounds double, double* %190, i32 %193
  store double %189, double* %arrayidx252, align 8
  br label %for.inc253

for.inc253:                                       ; preds = %for.body248
  %194 = load i32, i32* %i244, align 4
  %inc254 = add i32 %194, 1
  store i32 %inc254, i32* %i244, align 4
  br label %for.cond245

for.end255:                                       ; preds = %for.cond245
  %195 = load i32*, i32** %i2, align 4
  %196 = bitcast i32* %195 to i8*
  call void @free(i8* %196)
  store i32* null, i32** %i2, align 4
  store i32 0, i32* %i256, align 4
  br label %for.cond257

for.cond257:                                      ; preds = %for.inc269, %for.end255
  %197 = load i32, i32* %i256, align 4
  %198 = load i32, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
  %cmp258 = icmp ult i32 %197, %198
  br i1 %cmp258, label %for.body260, label %for.end271

for.body260:                                      ; preds = %for.cond257
  %199 = load double*, double** %pa, align 4
  %200 = load i32, i32* %i256, align 4
  %arrayidx261 = getelementptr inbounds double, double* %199, i32 %200
  %201 = load double, double* %arrayidx261, align 8
  %202 = load double*, double** %q, align 4
  %203 = load i32, i32* %i256, align 4
  %arrayidx262 = getelementptr inbounds double, double* %202, i32 %203
  %204 = load double, double* %arrayidx262, align 8
  %cmp263 = fcmp olt double %201, %204
  br i1 %cmp263, label %if.then265, label %if.end268

if.then265:                                       ; preds = %for.body260
  %205 = load double*, double** %q, align 4
  %206 = load i32, i32* %i256, align 4
  %arrayidx266 = getelementptr inbounds double, double* %205, i32 %206
  %207 = load double, double* %arrayidx266, align 8
  %208 = load double*, double** %pa, align 4
  %209 = load i32, i32* %i256, align 4
  %arrayidx267 = getelementptr inbounds double, double* %208, i32 %209
  store double %207, double* %arrayidx267, align 8
  br label %if.end268

if.end268:                                        ; preds = %if.then265, %for.body260
  br label %for.inc269

for.inc269:                                       ; preds = %if.end268
  %210 = load i32, i32* %i256, align 4
  %inc270 = add i32 %210, 1
  store i32 %inc270, i32* %i256, align 4
  br label %for.cond257

for.end271:                                       ; preds = %for.cond257
  br label %for.inc272

for.inc272:                                       ; preds = %for.end271
  %211 = load i32, i32* %j, align 4
  %dec = add i32 %211, -1
  store i32 %dec, i32* %j, align 4
  br label %for.cond182

for.end273:                                       ; preds = %for.cond182
  %212 = load double*, double** %p, align 4
  %213 = bitcast double* %212 to i8*
  call void @free(i8* %213)
  store double* null, double** %p, align 4
  store i32 0, i32* %index274, align 4
  br label %for.cond275

for.cond275:                                      ; preds = %for.inc282, %for.end273
  %214 = load i32, i32* %index274, align 4
  %215 = load i32, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
  %cmp276 = icmp ult i32 %214, %215
  br i1 %cmp276, label %for.body278, label %for.end284

for.body278:                                      ; preds = %for.cond275
  %216 = load double*, double** %pa, align 4
  %217 = load i32*, i32** %ro136, align 4
  %218 = load i32, i32* %index274, align 4
  %arrayidx279 = getelementptr inbounds i32, i32* %217, i32 %218
  %219 = load i32, i32* %arrayidx279, align 4
  %arrayidx280 = getelementptr inbounds double, double* %216, i32 %219
  %220 = load double, double* %arrayidx280, align 8
  %221 = load double*, double** %q, align 4
  %222 = load i32, i32* %index274, align 4
  %arrayidx281 = getelementptr inbounds double, double* %221, i32 %222
  store double %220, double* %arrayidx281, align 8
  br label %for.inc282

for.inc282:                                       ; preds = %for.body278
  %223 = load i32, i32* %index274, align 4
  %inc283 = add i32 %223, 1
  store i32 %inc283, i32* %index274, align 4
  br label %for.cond275

for.end284:                                       ; preds = %for.cond275
  %224 = load i32*, i32** %ro136, align 4
  %225 = bitcast i32* %224 to i8*
  call void @free(i8* %225)
  store i32* null, i32** %ro136, align 4
  %226 = load double*, double** %pa, align 4
  %227 = bitcast double* %226 to i8*
  call void @free(i8* %227)
  store double* null, double** %pa, align 4
  %228 = load double*, double** %q, align 4
  store double* %228, double** %retval, align 4
  br label %return

if.end285:                                        ; preds = %if.else109
  br label %if.end286

if.end286:                                        ; preds = %if.end285
  br label %if.end287

if.end287:                                        ; preds = %if.end286
  %229 = load double*, double** %PVALUES.addr, align 4
  %230 = load i32, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
  %call289 = call i32* @order(double* %229, i32 %230, i1 zeroext true)
  store i32* %call289, i32** %o288, align 4
  %231 = load i32*, i32** %o288, align 4
  %cmp290 = icmp eq i32* %231, null
  br i1 %cmp290, label %if.then292, label %if.end294

if.then292:                                       ; preds = %if.end287
  %call293 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([33 x i8], [33 x i8]* @.str.3, i32 0, i32 0), i8* getelementptr inbounds ([23 x i8], [23 x i8]* @.str.1, i32 0, i32 0), i32 398)
  call void @perror(i8* getelementptr inbounds ([1 x i8], [1 x i8]* @.str.2, i32 0, i32 0))
  call void @exit(i32 1) #5
  unreachable

if.end294:                                        ; preds = %if.end287
  %232 = load i32*, i32** %o288, align 4
  %233 = load i32, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
  %call295 = call double* @uint2double(i32* %232, i32 %233)
  store double* %call295, double** %o_double, align 4
  store i32 0, i32* %index296, align 4
  br label %for.cond297

for.cond297:                                      ; preds = %for.inc312, %if.end294
  %234 = load i32, i32* %index296, align 4
  %235 = load i32, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
  %cmp298 = icmp ult i32 %234, %235
  br i1 %cmp298, label %for.body300, label %for.end314

for.body300:                                      ; preds = %for.cond297
  %236 = load double*, double** %PVALUES.addr, align 4
  %237 = load i32, i32* %index296, align 4
  %arrayidx301 = getelementptr inbounds double, double* %236, i32 %237
  %238 = load double, double* %arrayidx301, align 8
  %cmp302 = fcmp olt double %238, 0.000000e+00
  br i1 %cmp302, label %if.then307, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %for.body300
  %239 = load double*, double** %PVALUES.addr, align 4
  %240 = load i32, i32* %index296, align 4
  %arrayidx304 = getelementptr inbounds double, double* %239, i32 %240
  %241 = load double, double* %arrayidx304, align 8
  %cmp305 = fcmp ogt double %241, 1.000000e+00
  br i1 %cmp305, label %if.then307, label %if.end311

if.then307:                                       ; preds = %lor.lhs.false, %for.body300
  %242 = load i32, i32* %index296, align 4
  %243 = load double*, double** %PVALUES.addr, align 4
  %244 = load i32, i32* %index296, align 4
  %arrayidx308 = getelementptr inbounds double, double* %243, i32 %244
  %245 = load double, double* %arrayidx308, align 8
  %call309 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([54 x i8], [54 x i8]* @.str.24, i32 0, i32 0), i32 %242, double %245)
  %call310 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([20 x i8], [20 x i8]* @.str.25, i32 0, i32 0), i8* getelementptr inbounds ([23 x i8], [23 x i8]* @.str.1, i32 0, i32 0), i32 406)
  call void @exit(i32 1) #5
  unreachable

if.end311:                                        ; preds = %lor.lhs.false
  br label %for.inc312

for.inc312:                                       ; preds = %if.end311
  %246 = load i32, i32* %index296, align 4
  %inc313 = add i32 %246, 1
  store i32 %inc313, i32* %index296, align 4
  br label %for.cond297

for.end314:                                       ; preds = %for.cond297
  %247 = load double*, double** %o_double, align 4
  %248 = load i32, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
  %call316 = call i32* @order(double* %247, i32 %248, i1 zeroext false)
  store i32* %call316, i32** %ro315, align 4
  %249 = load i32*, i32** %ro315, align 4
  %cmp317 = icmp eq i32* %249, null
  br i1 %cmp317, label %if.then319, label %if.end321

if.then319:                                       ; preds = %for.end314
  %call320 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([33 x i8], [33 x i8]* @.str.3, i32 0, i32 0), i8* getelementptr inbounds ([23 x i8], [23 x i8]* @.str.1, i32 0, i32 0), i32 413)
  call void @perror(i8* getelementptr inbounds ([1 x i8], [1 x i8]* @.str.2, i32 0, i32 0))
  call void @exit(i32 1) #5
  unreachable

if.end321:                                        ; preds = %for.end314
  %250 = load double*, double** %o_double, align 4
  %251 = bitcast double* %250 to i8*
  call void @free(i8* %251)
  store double* null, double** %o_double, align 4
  %252 = load i32, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
  %mul322 = mul i32 8, %252
  %call323 = call noalias i8* @malloc(i32 %mul322)
  %253 = bitcast i8* %call323 to double*
  store double* %253, double** %cummin_input, align 4
  %254 = load i16, i16* %TYPE, align 2
  %conv324 = sext i16 %254 to i32
  %cmp325 = icmp eq i32 %conv324, 0
  br i1 %cmp325, label %if.then327, label %if.else344

if.then327:                                       ; preds = %if.end321
  store i32 0, i32* %index328, align 4
  br label %for.cond329

for.cond329:                                      ; preds = %for.inc341, %if.then327
  %255 = load i32, i32* %index328, align 4
  %256 = load i32, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
  %cmp330 = icmp ult i32 %255, %256
  br i1 %cmp330, label %for.body332, label %for.end343

for.body332:                                      ; preds = %for.cond329
  %257 = load i32, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
  %conv333 = uitofp i32 %257 to double
  %258 = load i32, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
  %259 = load i32, i32* %index328, align 4
  %sub334 = sub i32 %258, %259
  %conv335 = uitofp i32 %sub334 to double
  %div336 = fdiv double %conv333, %conv335
  store double %div336, double* %NI, align 8
  %260 = load double, double* %NI, align 8
  %261 = load double*, double** %PVALUES.addr, align 4
  %262 = load i32*, i32** %o288, align 4
  %263 = load i32, i32* %index328, align 4
  %arrayidx337 = getelementptr inbounds i32, i32* %262, i32 %263
  %264 = load i32, i32* %arrayidx337, align 4
  %arrayidx338 = getelementptr inbounds double, double* %261, i32 %264
  %265 = load double, double* %arrayidx338, align 8
  %mul339 = fmul double %260, %265
  %266 = load double*, double** %cummin_input, align 4
  %267 = load i32, i32* %index328, align 4
  %arrayidx340 = getelementptr inbounds double, double* %266, i32 %267
  store double %mul339, double* %arrayidx340, align 8
  br label %for.inc341

for.inc341:                                       ; preds = %for.body332
  %268 = load i32, i32* %index328, align 4
  %inc342 = add i32 %268, 1
  store i32 %inc342, i32* %index328, align 4
  br label %for.cond329

for.end343:                                       ; preds = %for.cond329
  br label %if.end401

if.else344:                                       ; preds = %if.end321
  %269 = load i16, i16* %TYPE, align 2
  %conv345 = sext i16 %269 to i32
  %cmp346 = icmp eq i32 %conv345, 1
  br i1 %cmp346, label %if.then348, label %if.else380

if.then348:                                       ; preds = %if.else344
  store double 1.000000e+00, double* %q349, align 8
  store i32 2, i32* %index350, align 4
  br label %for.cond351

for.cond351:                                      ; preds = %for.inc359, %if.then348
  %270 = load i32, i32* %index350, align 4
  %271 = load i32, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
  %add352 = add i32 1, %271
  %cmp353 = icmp ult i32 %270, %add352
  br i1 %cmp353, label %for.body355, label %for.end361

for.body355:                                      ; preds = %for.cond351
  %272 = load i32, i32* %index350, align 4
  %conv356 = uitofp i32 %272 to double
  %div357 = fdiv double 1.000000e+00, %conv356
  %273 = load double, double* %q349, align 8
  %add358 = fadd double %273, %div357
  store double %add358, double* %q349, align 8
  br label %for.inc359

for.inc359:                                       ; preds = %for.body355
  %274 = load i32, i32* %index350, align 4
  %inc360 = add i32 %274, 1
  store i32 %inc360, i32* %index350, align 4
  br label %for.cond351

for.end361:                                       ; preds = %for.cond351
  store i32 0, i32* %index362, align 4
  br label %for.cond363

for.cond363:                                      ; preds = %for.inc377, %for.end361
  %275 = load i32, i32* %index362, align 4
  %276 = load i32, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
  %cmp364 = icmp ult i32 %275, %276
  br i1 %cmp364, label %for.body366, label %for.end379

for.body366:                                      ; preds = %for.cond363
  %277 = load i32, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
  %conv368 = uitofp i32 %277 to double
  %278 = load i32, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
  %279 = load i32, i32* %index362, align 4
  %sub369 = sub i32 %278, %279
  %conv370 = uitofp i32 %sub369 to double
  %div371 = fdiv double %conv368, %conv370
  store double %div371, double* %NI367, align 8
  %280 = load double, double* %q349, align 8
  %281 = load double, double* %NI367, align 8
  %mul372 = fmul double %280, %281
  %282 = load double*, double** %PVALUES.addr, align 4
  %283 = load i32*, i32** %o288, align 4
  %284 = load i32, i32* %index362, align 4
  %arrayidx373 = getelementptr inbounds i32, i32* %283, i32 %284
  %285 = load i32, i32* %arrayidx373, align 4
  %arrayidx374 = getelementptr inbounds double, double* %282, i32 %285
  %286 = load double, double* %arrayidx374, align 8
  %mul375 = fmul double %mul372, %286
  %287 = load double*, double** %cummin_input, align 4
  %288 = load i32, i32* %index362, align 4
  %arrayidx376 = getelementptr inbounds double, double* %287, i32 %288
  store double %mul375, double* %arrayidx376, align 8
  br label %for.inc377

for.inc377:                                       ; preds = %for.body366
  %289 = load i32, i32* %index362, align 4
  %inc378 = add i32 %289, 1
  store i32 %inc378, i32* %index362, align 4
  br label %for.cond363

for.end379:                                       ; preds = %for.cond363
  br label %if.end400

if.else380:                                       ; preds = %if.else344
  %290 = load i16, i16* %TYPE, align 2
  %conv381 = sext i16 %290 to i32
  %cmp382 = icmp eq i32 %conv381, 3
  br i1 %cmp382, label %if.then384, label %if.end399

if.then384:                                       ; preds = %if.else380
  store i32 0, i32* %index385, align 4
  br label %for.cond386

for.cond386:                                      ; preds = %for.inc396, %if.then384
  %291 = load i32, i32* %index385, align 4
  %292 = load i32, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
  %cmp387 = icmp ult i32 %291, %292
  br i1 %cmp387, label %for.body389, label %for.end398

for.body389:                                      ; preds = %for.cond386
  %293 = load i32, i32* %index385, align 4
  %add390 = add i32 %293, 1
  %conv391 = uitofp i32 %add390 to double
  %294 = load double*, double** %PVALUES.addr, align 4
  %295 = load i32*, i32** %o288, align 4
  %296 = load i32, i32* %index385, align 4
  %arrayidx392 = getelementptr inbounds i32, i32* %295, i32 %296
  %297 = load i32, i32* %arrayidx392, align 4
  %arrayidx393 = getelementptr inbounds double, double* %294, i32 %297
  %298 = load double, double* %arrayidx393, align 8
  %mul394 = fmul double %conv391, %298
  %299 = load double*, double** %cummin_input, align 4
  %300 = load i32, i32* %index385, align 4
  %arrayidx395 = getelementptr inbounds double, double* %299, i32 %300
  store double %mul394, double* %arrayidx395, align 8
  br label %for.inc396

for.inc396:                                       ; preds = %for.body389
  %301 = load i32, i32* %index385, align 4
  %inc397 = add i32 %301, 1
  store i32 %inc397, i32* %index385, align 4
  br label %for.cond386

for.end398:                                       ; preds = %for.cond386
  br label %if.end399

if.end399:                                        ; preds = %for.end398, %if.else380
  br label %if.end400

if.end400:                                        ; preds = %if.end399, %for.end379
  br label %if.end401

if.end401:                                        ; preds = %if.end400, %for.end343
  %302 = load i32*, i32** %o288, align 4
  %303 = bitcast i32* %302 to i8*
  call void @free(i8* %303)
  store i32* null, i32** %o288, align 4
  store double* null, double** %cummin_array, align 4
  %304 = load double*, double** %cummin_input, align 4
  %305 = load i32, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
  %call402 = call double* @cummin(double* %304, i32 %305)
  store double* %call402, double** %cummin_array, align 4
  %306 = load double*, double** %cummin_input, align 4
  %307 = bitcast double* %306 to i8*
  call void @free(i8* %307)
  store double* null, double** %cummin_input, align 4
  %308 = load double*, double** %cummin_array, align 4
  %309 = load i32, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
  %call404 = call double* @pminx(double* %308, i32 %309, double 1.000000e+00)
  store double* %call404, double** %pmin403, align 4
  %310 = load double*, double** %cummin_array, align 4
  %311 = bitcast double* %310 to i8*
  call void @free(i8* %311)
  store double* null, double** %cummin_array, align 4
  %312 = load i32, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
  %mul405 = mul i32 %312, 8
  %call406 = call noalias i8* @malloc(i32 %mul405)
  %313 = bitcast i8* %call406 to double*
  store double* %313, double** %q_array, align 4
  store i32 0, i32* %index407, align 4
  br label %for.cond408

for.cond408:                                      ; preds = %for.inc415, %if.end401
  %314 = load i32, i32* %index407, align 4
  %315 = load i32, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
  %cmp409 = icmp ult i32 %314, %315
  br i1 %cmp409, label %for.body411, label %for.end417

for.body411:                                      ; preds = %for.cond408
  %316 = load double*, double** %pmin403, align 4
  %317 = load i32*, i32** %ro315, align 4
  %318 = load i32, i32* %index407, align 4
  %arrayidx412 = getelementptr inbounds i32, i32* %317, i32 %318
  %319 = load i32, i32* %arrayidx412, align 4
  %arrayidx413 = getelementptr inbounds double, double* %316, i32 %319
  %320 = load double, double* %arrayidx413, align 8
  %321 = load double*, double** %q_array, align 4
  %322 = load i32, i32* %index407, align 4
  %arrayidx414 = getelementptr inbounds double, double* %321, i32 %322
  store double %320, double* %arrayidx414, align 8
  br label %for.inc415

for.inc415:                                       ; preds = %for.body411
  %323 = load i32, i32* %index407, align 4
  %inc416 = add i32 %323, 1
  store i32 %inc416, i32* %index407, align 4
  br label %for.cond408

for.end417:                                       ; preds = %for.cond408
  %324 = load i32*, i32** %ro315, align 4
  %325 = bitcast i32* %324 to i8*
  call void @free(i8* %325)
  store i32* null, i32** %ro315, align 4
  %326 = load double*, double** %pmin403, align 4
  %327 = bitcast double* %326 to i8*
  call void @free(i8* %327)
  store double* null, double** %pmin403, align 4
  %328 = load double*, double** %q_array, align 4
  store double* %328, double** %retval, align 4
  br label %return

return:                                           ; preds = %for.end417, %for.end284, %for.end108, %for.end
  %329 = load double*, double** %retval, align 4
  ret double* %329
}

declare i32 @strcasecmp(i8* %0, i8* %1) #1

; Function Attrs: noinline nounwind optnone
define hidden i32 @main() #0 {
entry:
  %retval = alloca i32, align 4
  %PVALUES = alloca [50 x double], align 16
  %CORRECT_ANSWERS = alloca [6 x [50 x double]], align 16
  %TYPES = alloca [6 x i8*], align 16
  %type = alloca i16, align 2
  %q = alloca double*, align 4
  %error = alloca double, align 8
  %i = alloca i32, align 4
  %this_error = alloca double, align 8
  store i32 0, i32* %retval, align 4
  %0 = bitcast [50 x double]* %PVALUES to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 16 %0, i8* align 16 bitcast ([50 x double]* @__const.main.PVALUES to i8*), i32 400, i1 false)
  %1 = bitcast [6 x [50 x double]]* %CORRECT_ANSWERS to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 16 %1, i8* align 16 bitcast ([6 x [50 x double]]* @__const.main.CORRECT_ANSWERS to i8*), i32 2400, i1 false)
  %2 = bitcast [6 x i8*]* %TYPES to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 16 %2, i8* align 16 bitcast ([6 x i8*]* @__const.main.TYPES to i8*), i32 24, i1 false)
  store i16 0, i16* %type, align 2
  br label %for.cond

for.cond:                                         ; preds = %for.inc19, %entry
  %3 = load i16, i16* %type, align 2
  %conv = zext i16 %3 to i32
  %cmp = icmp sle i32 %conv, 5
  br i1 %cmp, label %for.body, label %for.end21

for.body:                                         ; preds = %for.cond
  %arraydecay = getelementptr inbounds [50 x double], [50 x double]* %PVALUES, i32 0, i32 0
  %4 = load i16, i16* %type, align 2
  %idxprom = zext i16 %4 to i32
  %arrayidx = getelementptr inbounds [6 x i8*], [6 x i8*]* %TYPES, i32 0, i32 %idxprom
  %5 = load i8*, i8** %arrayidx, align 4
  %call = call double* @p_adjust(double* %arraydecay, i32 50, i8* %5)
  store double* %call, double** %q, align 4
  %6 = load double*, double** %q, align 4
  %arrayidx2 = getelementptr inbounds double, double* %6, i32 0
  %7 = load double, double* %arrayidx2, align 8
  %8 = load i16, i16* %type, align 2
  %idxprom3 = zext i16 %8 to i32
  %arrayidx4 = getelementptr inbounds [6 x [50 x double]], [6 x [50 x double]]* %CORRECT_ANSWERS, i32 0, i32 %idxprom3
  %arrayidx5 = getelementptr inbounds [50 x double], [50 x double]* %arrayidx4, i32 0, i32 0
  %9 = load double, double* %arrayidx5, align 16
  %sub = fsub double %7, %9
  %10 = call double @llvm.fabs.f64(double %sub)
  store double %10, double* %error, align 8
  store i32 1, i32* %i, align 4
  br label %for.cond6

for.cond6:                                        ; preds = %for.inc, %for.body
  %11 = load i32, i32* %i, align 4
  %cmp7 = icmp ult i32 %11, 50
  br i1 %cmp7, label %for.body9, label %for.end

for.body9:                                        ; preds = %for.cond6
  %12 = load double*, double** %q, align 4
  %13 = load i32, i32* %i, align 4
  %arrayidx10 = getelementptr inbounds double, double* %12, i32 %13
  %14 = load double, double* %arrayidx10, align 8
  %15 = load i16, i16* %type, align 2
  %idxprom11 = zext i16 %15 to i32
  %arrayidx12 = getelementptr inbounds [6 x [50 x double]], [6 x [50 x double]]* %CORRECT_ANSWERS, i32 0, i32 %idxprom11
  %16 = load i32, i32* %i, align 4
  %arrayidx13 = getelementptr inbounds [50 x double], [50 x double]* %arrayidx12, i32 0, i32 %16
  %17 = load double, double* %arrayidx13, align 8
  %sub14 = fsub double %14, %17
  %18 = call double @llvm.fabs.f64(double %sub14)
  store double %18, double* %this_error, align 8
  %19 = load double, double* %this_error, align 8
  %20 = load double, double* %error, align 8
  %add = fadd double %20, %19
  store double %add, double* %error, align 8
  br label %for.inc

for.inc:                                          ; preds = %for.body9
  %21 = load i32, i32* %i, align 4
  %inc = add i32 %21, 1
  store i32 %inc, i32* %i, align 4
  br label %for.cond6

for.end:                                          ; preds = %for.cond6
  %22 = load double*, double** %q, align 4
  call void @double_say(double* %22, i32 50)
  %23 = load double*, double** %q, align 4
  %24 = bitcast double* %23 to i8*
  call void @free(i8* %24)
  store double* null, double** %q, align 4
  %25 = load i16, i16* %type, align 2
  %conv15 = zext i16 %25 to i32
  %26 = load i16, i16* %type, align 2
  %idxprom16 = zext i16 %26 to i32
  %arrayidx17 = getelementptr inbounds [6 x i8*], [6 x i8*]* %TYPES, i32 0, i32 %idxprom16
  %27 = load i8*, i8** %arrayidx17, align 4
  %28 = load double, double* %error, align 8
  %call18 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([44 x i8], [44 x i8]* @.str.28, i32 0, i32 0), i32 %conv15, i8* %27, double %28)
  br label %for.inc19

for.inc19:                                        ; preds = %for.end
  %29 = load i16, i16* %type, align 2
  %inc20 = add i16 %29, 1
  store i16 %inc20, i16* %type, align 2
  br label %for.cond

for.end21:                                        ; preds = %for.cond
  ret i32 0
}

; Function Attrs: argmemonly nounwind willreturn
declare void @llvm.memcpy.p0i8.p0i8.i32(i8* noalias nocapture writeonly %0, i8* noalias nocapture readonly %1, i32 %2, i1 immarg %3) #3

; Function Attrs: nounwind readnone speculatable willreturn
declare double @llvm.fabs.f64(double %0) #4

attributes #0 = { noinline nounwind optnone "correctly-rounded-divide-sqrt-fp-math"="false" "disable-tail-calls"="false" "frame-pointer"="none" "less-precise-fpmad"="false" "min-legal-vector-width"="0" "no-infs-fp-math"="false" "no-jump-tables"="false" "no-nans-fp-math"="false" "no-signed-zeros-fp-math"="false" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="generic" "unsafe-fp-math"="false" "use-soft-float"="false" }
attributes #1 = { "correctly-rounded-divide-sqrt-fp-math"="false" "disable-tail-calls"="false" "frame-pointer"="none" "less-precise-fpmad"="false" "no-infs-fp-math"="false" "no-nans-fp-math"="false" "no-signed-zeros-fp-math"="false" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="generic" "unsafe-fp-math"="false" "use-soft-float"="false" }
attributes #2 = { noreturn "correctly-rounded-divide-sqrt-fp-math"="false" "disable-tail-calls"="false" "frame-pointer"="none" "less-precise-fpmad"="false" "no-infs-fp-math"="false" "no-nans-fp-math"="false" "no-signed-zeros-fp-math"="false" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="generic" "unsafe-fp-math"="false" "use-soft-float"="false" }
attributes #3 = { argmemonly nounwind willreturn }
attributes #4 = { nounwind readnone speculatable willreturn }
attributes #5 = { noreturn }

!llvm.module.flags = !{!0}
!llvm.ident = !{!1}

!0 = !{i32 1, !"wchar_size", i32 4}
!1 = !{!"clang version 11.0.0 (https://github.com/Jacarte/llvm-project.git 0f6dea67136cc1e0b3d200eb2bb165628970c44b)"}

; extracted candidates

; *****
; For LLVM instruction:
;  %2 = load i32, i32* %1, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %5 = load i32, i32* %4, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %7 = load i32, i32* %aa, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %10 = load i32, i32* %bb, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %cmp = fcmp olt double %8, %11
; Looking for a replacement for:
%0:i1 = var
infer %0

; *****
; For LLVM instruction:
;  %13 = load i32, i32* %aa, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %16 = load i32, i32* %bb, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %cmp4 = fcmp oeq double %14, %17
; Looking for a replacement for:
%0:i1 = var
infer %0

; *****
; For LLVM instruction:
;  %18 = load i32, i32* %retval, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0
got 1 candidates from LHS

-------------------------------------------------
%0:i1 = var
infer %0


--------------------------------
guess 0

%0:i1 = var ; reservedconst_1

Cost = 0
first query is SAT, returning the model:
reservedconst_1: 0
0 th attempt: second query is SAT-- constant doesn't work
first query is SAT, returning the model:
reservedconst_1: -1
1 th attempt: second query is SAT-- constant doesn't work
first query is UNSAT-- no more guesses
Dataflow Pruned 0/0
There are 1 Guesses
There are 0 RHSs before deduplication
There are 0 RHSs after deduplication
#########################################################
; exiting Souper's runOnFunction() for ./P-value_correction.c.bc:compar_decrease()

; entering Souper's runOnFunction() for ./P-value_correction.c.bc:compar_increase()

; ModuleID = './P-value_correction.c.bc'
source_filename = "./P-value_correction.c"
target datalayout = "e-m:e-p:32:32-i64:64-n32:64-S128"
target triple = "wasm32-unknown-wasi"

@.str = private unnamed_addr constant [29 x i8] c"malloc failed at %s line %u\0A\00", align 1
@.str.1 = private unnamed_addr constant [23 x i8] c"./P-value_correction.c\00", align 1
@.str.2 = private unnamed_addr constant [1 x i8] zeroinitializer, align 1
@base_arr = hidden global double* null, align 4
@.str.3 = private unnamed_addr constant [33 x i8] c"failed to malloc at %s line %u.\0A\00", align 1
@.str.4 = private unnamed_addr constant [48 x i8] c"cummin function requires at least one element.\0A\00", align 1
@.str.5 = private unnamed_addr constant [22 x i8] c"Failed at %s line %u\0A\00", align 1
@.str.6 = private unnamed_addr constant [41 x i8] c"function requires at least one element.\0A\00", align 1
@.str.7 = private unnamed_addr constant [37 x i8] c"pmin requires at least one element.\0A\00", align 1
@.str.8 = private unnamed_addr constant [7 x i8] c"[1] %e\00", align 1
@.str.9 = private unnamed_addr constant [7 x i8] c" %.10f\00", align 1
@.str.10 = private unnamed_addr constant [6 x i8] c"\0A[%u]\00", align 1
@.str.11 = private unnamed_addr constant [2 x i8] c"\0A\00", align 1
@.str.12 = private unnamed_addr constant [34 x i8] c"Failure to malloc at %s line %u.\0A\00", align 1
@.str.13 = private unnamed_addr constant [41 x i8] c"p_adjust requires at least one element.\0A\00", align 1
@.str.14 = private unnamed_addr constant [3 x i8] c"BH\00", align 1
@.str.15 = private unnamed_addr constant [4 x i8] c"fdr\00", align 1
@.str.16 = private unnamed_addr constant [3 x i8] c"by\00", align 1
@.str.17 = private unnamed_addr constant [11 x i8] c"Bonferroni\00", align 1
@.str.18 = private unnamed_addr constant [9 x i8] c"hochberg\00", align 1
@.str.19 = private unnamed_addr constant [5 x i8] c"holm\00", align 1
@.str.20 = private unnamed_addr constant [7 x i8] c"hommel\00", align 1
@.str.21 = private unnamed_addr constant [44 x i8] c"%s doesn't match any accepted FDR methods.\0A\00", align 1
@.str.22 = private unnamed_addr constant [42 x i8] c"%g is outside of the interval I planned.\0A\00", align 1
@.str.23 = private unnamed_addr constant [23 x i8] c"Failure at %s line %u\0A\00", align 1
@.str.24 = private unnamed_addr constant [54 x i8] c"array[%u] = %lf, which is outside the interval [0,1]\0A\00", align 1
@.str.25 = private unnamed_addr constant [20 x i8] c"died at %s line %u\0A\00", align 1
@__const.main.PVALUES = private unnamed_addr constant [50 x double] [double 0x3FDD04160F35FDE9, double 0x3FE758E721E2A8D7, double 0x3FB96FAC8B38D8BA, double 0x3FB73E71D5B04B37, double 0x3FC710AB48EE865B, double 0x3FEC01D953C3CC73, double 0x3FD2B3C4BE0A922A, double 0x3FED2B5A568DAB4F, double 0x3FDBE08D73F16964, double 0x3FE10A218C41C242, double 0x3FDF8810DB1996AA, double 0x3FE291CCB11E1A9D, double 0x3FD64E8C550D788F, double 7.883130e-01, double 0x3FD177B2BF048D2D, double 0x3FEB3543434BAF2B, double 0x3FDB50EAD41ED0A6, double 0x3FE49D4AFF01D33F, double 0x3FD364C9AE345B51, double 0x3FA99BA35F15394D, double 3.194810e-01, double 0x3FE941E405CE761A, double 0x3FEFF94F77369843, double 0x3FC65847BFB23217, double 0x3FECEB8879B6A543, double 0x3FBEAF00332BA677, double 0x3FD96207C7749E38, double 0x3F8CC02620502C93, double 0x3FE773A5B45A0F40, double 0x3FB1642C24762C01, double 4.040730e-03, double 0x3F33E11D79A90777, double 0x3F870B02BD749528, double 0x3F98521BD6A0353F, double 0x3F4310F26148FFAA, double 0x3F3427CD76006778, double 0x3F80E60AFB1F8A4E, double 0x3F5639B74A9E4DA2, double 0x3F8BDDF74195769F, double 0x3F38ABEE3BFA8581, double 0x3EF2E2E96B5466FE, double 0x3E90CE9F65B58A88, double 0x3FA0F2D097879B95, double 0x3F834EE7216A6684, double 0x3F4CCE8DBB40BD9D, double 0x3F2C8B969590F2ED, double 0x3F4FC31F7F1541AD, double 6.610250e-05, double 0x3F9DB44EA6AC26BA, double 5.735490e-03], align 16
@__const.main.CORRECT_ANSWERS = private unnamed_addr constant [6 x [50 x double]] [[50 x double] [double 0x3FE39AFA2199ADBC, double 8.521710e-01, double 0x3FC96FAC6045BAF5, double 0x3FC83660E51D25AB, double 0x3FD498068702BE20, double 0x3FEDC3BF727136A4, double 4.870370e-01, double 0x3FEDC3BF727136A4, double 0x3FE35BF08BEEB62C, double 0x3FE5D879DEE92F03, double 0x3FE4BE91D656B94A, double 0x3FE7363FC28DAEAA, double 0x3FE0E62C4F13638A, double 0x3FEC1052C8FAB035, double 0x3FDE1DD2E43E029A, double 0x3FED92EFFC7CBDC1, double 0x3FE35BF08BEEB62C, double 0x3FE923B90CFC67C5, double 0x3FDF47B8FC357024, double 0x3FBD1996A9FB10AD, double 0x3FDFF2B6D6C14255, double 0x3FEC1052C8FAB035, double 0x3FEFF94F77369843, double 0x3FD498068702BE20, double 0x3FEDC3BF727136A4, double 0x3FCD80E2E96EC403, double 0x3FE2A9F6A93F290B, double 0x3FA3F736D8AF2E2B, double 8.521710e-01, double 0x3FC2E751B350FAC4, double 0x3F913D8E55EE9F05, double 0x3F64FECB88BB3633, double 0x3FA2009A03CCBE34, double 0x3FB0001FB57CF9FC, double 0x3F6DCA7ADA5E274A, double 0x3F64FECB88BB3633, double 0x3F9E2D13B467D120, double 0x3F7941963399C6A1, double 0x3FA3F736D8AF2E2B, double 0x3F6607390CEF853C, double 0x3F3D828C80BA213A, double 0x3EEA42D90EEBA875, double 0x3FB42D4181AA8F8B, double 0x3FA01715F12E0018, double 0x3F73D9F3AF6D490C, double 0x3F64FECB88BB3633, double 0x3F73D9F3AF6D490C, double 0x3F520CE5F51A7C61, double 0x3FB290B112B20952, double 0x3F9696C95AA76B69], [50 x double] [double 1.000000e+00, double 1.000000e+00, double 0x3FEC9C56E33BA41B, double 0x3FEB3BF21E95ED3D, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 0x3FE05DA74553C727, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 0x3FC675198790829A, double 1.000000e+00, double 0x3FE54345648E1F12, double 0x3FB3645F501CA2F9, double 0x3F879D934E50F0DE, double 0x3FC43FC3646E3EA2, double 0x3FD1FF539D36064C, double 0x3F90C123206B855F, double 0x3F879D934E50F0DE, double 0x3FC0F8967F32E606, double 0x3F9C6880470D2FBE, double 0x3FC675198790829A, double 0x3F88C70105E47082, double 2.025930e-03, double 0x3F0D89DE4FA8F818, double 0x3FD6B1E2D11B1027, double 0x3FC219271872BD8D, double 0x3F96542FAD16CEF9, double 0x3F879D934E50F0DE, double 0x3F96542FAD16CEF9, double 0x3F744D9816EB319A, double 0x3FD4E1D5728DBC16, double 0x3FB9687C40426555], [50 x double] [double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 0x3FE6761DC93EA2D3, double 1.000000e+00, double 1.000000e+00, double 0x3FC9DC55000C953A, double 0x3F8F0FBD624BA499, double 0x3FE2009A24031487, double 1.000000e+00, double 0x3F9DCA7AB8020F7A, double 0x3F8F7E310860A1AB, double 0x3FDA677128614819, double 6.782670e-02, double 6.803480e-01, double 0x3F9346521EDBB84D, double 0x3F4D828CB7B3E0EE, double 0x3EEA42D90EEBA875, double 1.000000e+00, double 4.713920e-01, double 0x3FA6815EE53DB1E7, double 0x3F864D0CF90CC6B8, double 0x3FA8D0709B489B4F, double 0x3F6B1359791819D2, double 1.000000e+00, double 0x3FD25A836EB4E981], [50 x double] [double 0x3FEFF94F77369843, double 0x3FEFF94F77369843, double 0x3FEFF94F77369843, double 0x3FEFF94F77369843, double 0x3FEFF94F77369843, double 0x3FEFF94F77369843, double 0x3FEFF94F77369843, double 0x3FEFF94F77369843, double 0x3FEFF94F77369843, double 0x3FEFF94F77369843, double 0x3FEFF94F77369843, double 0x3FEFF94F77369843, double 0x3FEFF94F77369843, double 0x3FEFF94F77369843, double 0x3FEFF94F77369843, double 0x3FEFF94F77369843, double 0x3FEFF94F77369843, double 0x3FEFF94F77369843, double 0x3FEFF94F77369843, double 0x3FEFF94F77369843, double 0x3FEFF94F77369843, double 0x3FEFF94F77369843, double 0x3FEFF94F77369843, double 0x3FEFF94F77369843, double 0x3FEFF94F77369843, double 0x3FEFF94F77369843, double 0x3FEFF94F77369843, double 0x3FDDA6274695E687, double 0x3FEFF94F77369843, double 0x3FEFF94F77369843, double 0x3FC42BDC26DCE39B, double 0x3F8C57F9104CA951, double 0x3FD9340AC9879DEF, double 7.600230e-01, double 0x3F999EC5A86B439B, double 0x3F8C57F9104CA951, double 0x3FD389FCD90412B4, double 0x3FABC8251D45E10B, double 0x3FDD9BD68ABBB045, double 0x3F90F633F956C386, double 8.825610e-04, double 0x3EEA42D90EEBA875, double 0x3FEFC7471C1E43B8, double 0x3FD5B8C4014C305A, double 0x3FA2E78CEC8D068E, double 0x3F84F6832995A599, double 0x3FA459002162FC24, double 3.172920e-03, double 8.992520e-01, double 0x3FCBE5BD5E9AC00A], [50 x double] [double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 0x3FDDA6274695E687, double 1.000000e+00, double 1.000000e+00, double 0x3FC42BDC26DCE39B, double 0x3F8C939AFCF101E0, double 0x3FD9340AC9879DEF, double 7.600230e-01, double 0x3F999EC5A86B439B, double 0x3F8C939AFCF101E0, double 0x3FD389FCD90412B4, double 0x3FABC8251D45E10B, double 0x3FDD9BD68ABBB045, double 0x3F90F633F956C386, double 8.825610e-04, double 0x3EEA42D90EEBA875, double 0x3FEFC7471C1E43B8, double 0x3FD5B8C4014C305A, double 0x3FA2E78CEC8D068E, double 0x3F84F6832995A599, double 0x3FA459002162FC24, double 3.172920e-03, double 8.992520e-01, double 0x3FCBE5BD5E9AC00A], [50 x double] [double 0x3FEFF94F77369843, double 0x3FEFF94F77369843, double 0x3FEFF94F77369843, double 0x3FEFF5DC908F2EDD, double 0x3FEFF94F77369843, double 0x3FEFF94F77369843, double 0x3FEFF94F77369843, double 0x3FEFF94F77369843, double 0x3FEFF94F77369843, double 0x3FEFF94F77369843, double 0x3FEFF94F77369843, double 0x3FEFF94F77369843, double 0x3FEFF94F77369843, double 0x3FEFF94F77369843, double 0x3FEFF94F77369843, double 0x3FEFF94F77369843, double 0x3FEFF94F77369843, double 0x3FEFF94F77369843, double 0x3FEFF94F77369843, double 0x3FEEB45F17BD8BE7, double 0x3FEFF94F77369843, double 0x3FEFF94F77369843, double 0x3FEFF94F77369843, double 0x3FEFF94F77369843, double 0x3FEFF94F77369843, double 0x3FEFF94F77369843, double 0x3FEFF94F77369843, double 0x3FDBDA250F840182, double 0x3FEFF94F77369843, double 0x3FEF40BC1D52205E, double 0x3FC21A3BEB689947, double 1.304340e-02, double 0x3FD69916517B1CD7, double 0x3FE60A69453DF7B2, double 0x3F986DB666D9D3C6, double 0x3F8B157BBD3AB385, double 2.722920e-01, double 0x3FABC8251D45E10B, double 0x3FDAFF07B27BE8AF, double 0x3F9030D45E3B9F93, double 8.825610e-04, double 0x3EEA42D90EEBA875, double 0x3FEBFACC1948A662, double 0x3FD34EE6EDE042CB, double 0x3FA2011883DA6A9A, double 0x3F839FF779153716, double 0x3FA3D9F3D1C960DD, double 3.172920e-03, double 0x3FE9FDC4BC5D1301, double 0x3FC8F5FAC3801CF1]], align 16
@.str.26 = private unnamed_addr constant [3 x i8] c"bh\00", align 1
@.str.27 = private unnamed_addr constant [11 x i8] c"bonferroni\00", align 1
@__const.main.TYPES = private unnamed_addr constant [6 x i8*] [i8* getelementptr inbounds ([3 x i8], [3 x i8]* @.str.26, i32 0, i32 0), i8* getelementptr inbounds ([3 x i8], [3 x i8]* @.str.16, i32 0, i32 0), i8* getelementptr inbounds ([11 x i8], [11 x i8]* @.str.27, i32 0, i32 0), i8* getelementptr inbounds ([9 x i8], [9 x i8]* @.str.18, i32 0, i32 0), i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.19, i32 0, i32 0), i8* getelementptr inbounds ([7 x i8], [7 x i8]* @.str.20, i32 0, i32 0)], align 16
@.str.28 = private unnamed_addr constant [44 x i8] c"\0Atype %u = '%s' has cumulative error of %g\0A\00", align 1
@llvm.used = appending global [1 x i8*] [i8* bitcast (i32 ()* @__main_void to i8*)], section "llvm.metadata"

@__main_void = alias i32 (), i32 ()* @main

; Function Attrs: noinline nounwind optnone
define hidden i32* @seq_len(i32 %START, i32 %END) #0 {
entry:
  %retval = alloca i32*, align 4
  %START.addr = alloca i32, align 4
  %END.addr = alloca i32, align 4
  %start = alloca i32, align 4
  %end = alloca i32, align 4
  %sequence = alloca i32*, align 4
  %i = alloca i32, align 4
  %LENGTH = alloca i32, align 4
  %sequence10 = alloca i32*, align 4
  %index = alloca i32, align 4
  %index28 = alloca i32, align 4
  store i32 %START, i32* %START.addr, align 4
  store i32 %END, i32* %END.addr, align 4
  %0 = load i32, i32* %START.addr, align 4
  store i32 %0, i32* %start, align 4
  %1 = load i32, i32* %END.addr, align 4
  store i32 %1, i32* %end, align 4
  %2 = load i32, i32* %START.addr, align 4
  %3 = load i32, i32* %END.addr, align 4
  %cmp = icmp eq i32 %2, %3
  br i1 %cmp, label %if.then, label %if.end6

if.then:                                          ; preds = %entry
  %4 = load i32, i32* %end, align 4
  %add = add i32 %4, 1
  %mul = mul i32 %add, 4
  %call = call noalias i8* @malloc(i32 %mul)
  %5 = bitcast i8* %call to i32*
  store i32* %5, i32** %sequence, align 4
  %6 = load i32*, i32** %sequence, align 4
  %cmp1 = icmp eq i32* %6, null
  br i1 %cmp1, label %if.then2, label %if.end

if.then2:                                         ; preds = %if.then
  %call3 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([29 x i8], [29 x i8]* @.str, i32 0, i32 0), i8* getelementptr inbounds ([23 x i8], [23 x i8]* @.str.1, i32 0, i32 0), i32 15)
  call void @perror(i8* getelementptr inbounds ([1 x i8], [1 x i8]* @.str.2, i32 0, i32 0))
  call void @exit(i32 1) #5
  unreachable

if.end:                                           ; preds = %if.then
  store i32 0, i32* %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.end
  %7 = load i32, i32* %i, align 4
  %8 = load i32, i32* %end, align 4
  %cmp4 = icmp ult i32 %7, %8
  br i1 %cmp4, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %9 = load i32, i32* %i, align 4
  %add5 = add i32 %9, 1
  %10 = load i32*, i32** %sequence, align 4
  %11 = load i32, i32* %i, align 4
  %arrayidx = getelementptr inbounds i32, i32* %10, i32 %11
  store i32 %add5, i32* %arrayidx, align 4
  br label %for.inc

for.inc:                                          ; preds = %for.body
  %12 = load i32, i32* %i, align 4
  %inc = add i32 %12, 1
  store i32 %inc, i32* %i, align 4
  br label %for.cond

for.end:                                          ; preds = %for.cond
  %13 = load i32*, i32** %sequence, align 4
  store i32* %13, i32** %retval, align 4
  br label %return

if.end6:                                          ; preds = %entry
  %14 = load i32, i32* %START.addr, align 4
  %15 = load i32, i32* %END.addr, align 4
  %cmp7 = icmp ugt i32 %14, %15
  br i1 %cmp7, label %if.then8, label %if.end9

if.then8:                                         ; preds = %if.end6
  %16 = load i32, i32* %START.addr, align 4
  store i32 %16, i32* %end, align 4
  %17 = load i32, i32* %END.addr, align 4
  store i32 %17, i32* %start, align 4
  br label %if.end9

if.end9:                                          ; preds = %if.then8, %if.end6
  %18 = load i32, i32* %end, align 4
  %19 = load i32, i32* %start, align 4
  %sub = sub i32 %18, %19
  store i32 %sub, i32* %LENGTH, align 4
  %20 = load i32, i32* %LENGTH, align 4
  %add11 = add i32 1, %20
  %mul12 = mul i32 %add11, 4
  %call13 = call noalias i8* @malloc(i32 %mul12)
  %21 = bitcast i8* %call13 to i32*
  store i32* %21, i32** %sequence10, align 4
  %22 = load i32*, i32** %sequence10, align 4
  %cmp14 = icmp eq i32* %22, null
  br i1 %cmp14, label %if.then15, label %if.end17

if.then15:                                        ; preds = %if.end9
  %call16 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([29 x i8], [29 x i8]* @.str, i32 0, i32 0), i8* getelementptr inbounds ([23 x i8], [23 x i8]* @.str.1, i32 0, i32 0), i32 31)
  call void @perror(i8* getelementptr inbounds ([1 x i8], [1 x i8]* @.str.2, i32 0, i32 0))
  call void @exit(i32 1) #5
  unreachable

if.end17:                                         ; preds = %if.end9
  %23 = load i32, i32* %START.addr, align 4
  %24 = load i32, i32* %END.addr, align 4
  %cmp18 = icmp ult i32 %23, %24
  br i1 %cmp18, label %if.then19, label %if.else

if.then19:                                        ; preds = %if.end17
  store i32 0, i32* %index, align 4
  br label %for.cond20

for.cond20:                                       ; preds = %for.inc25, %if.then19
  %25 = load i32, i32* %index, align 4
  %26 = load i32, i32* %LENGTH, align 4
  %cmp21 = icmp ule i32 %25, %26
  br i1 %cmp21, label %for.body22, label %for.end27

for.body22:                                       ; preds = %for.cond20
  %27 = load i32, i32* %start, align 4
  %28 = load i32, i32* %index, align 4
  %add23 = add i32 %27, %28
  %29 = load i32*, i32** %sequence10, align 4
  %30 = load i32, i32* %index, align 4
  %arrayidx24 = getelementptr inbounds i32, i32* %29, i32 %30
  store i32 %add23, i32* %arrayidx24, align 4
  br label %for.inc25

for.inc25:                                        ; preds = %for.body22
  %31 = load i32, i32* %index, align 4
  %inc26 = add i32 %31, 1
  store i32 %inc26, i32* %index, align 4
  br label %for.cond20

for.end27:                                        ; preds = %for.cond20
  br label %if.end37

if.else:                                          ; preds = %if.end17
  store i32 0, i32* %index28, align 4
  br label %for.cond29

for.cond29:                                       ; preds = %for.inc34, %if.else
  %32 = load i32, i32* %index28, align 4
  %33 = load i32, i32* %LENGTH, align 4
  %cmp30 = icmp ule i32 %32, %33
  br i1 %cmp30, label %for.body31, label %for.end36

for.body31:                                       ; preds = %for.cond29
  %34 = load i32, i32* %end, align 4
  %35 = load i32, i32* %index28, align 4
  %sub32 = sub i32 %34, %35
  %36 = load i32*, i32** %sequence10, align 4
  %37 = load i32, i32* %index28, align 4
  %arrayidx33 = getelementptr inbounds i32, i32* %36, i32 %37
  store i32 %sub32, i32* %arrayidx33, align 4
  br label %for.inc34

for.inc34:                                        ; preds = %for.body31
  %38 = load i32, i32* %index28, align 4
  %inc35 = add i32 %38, 1
  store i32 %inc35, i32* %index28, align 4
  br label %for.cond29

for.end36:                                        ; preds = %for.cond29
  br label %if.end37

if.end37:                                         ; preds = %for.end36, %for.end27
  %39 = load i32*, i32** %sequence10, align 4
  store i32* %39, i32** %retval, align 4
  br label %return

return:                                           ; preds = %if.end37, %for.end
  %40 = load i32*, i32** %retval, align 4
  ret i32* %40
}

declare noalias i8* @malloc(i32 %0) #1

declare i32 @printf(i8* %0, ...) #1

declare void @perror(i8* %0) #1

; Function Attrs: noreturn
declare void @exit(i32 %0) #2

; Function Attrs: noinline nounwind optnone
define hidden i32* @order(double* noalias %ARRAY, i32 %SIZE, i1 zeroext %DECREASING) #0 {
entry:
  %ARRAY.addr = alloca double*, align 4
  %SIZE.addr = alloca i32, align 4
  %DECREASING.addr = alloca i8, align 1
  %idx = alloca i32*, align 4
  %i = alloca i32, align 4
  store double* %ARRAY, double** %ARRAY.addr, align 4
  store i32 %SIZE, i32* %SIZE.addr, align 4
  %frombool = zext i1 %DECREASING to i8
  store i8 %frombool, i8* %DECREASING.addr, align 1
  %0 = load i32, i32* %SIZE.addr, align 4
  %mul = mul i32 %0, 4
  %call = call noalias i8* @malloc(i32 %mul)
  %1 = bitcast i8* %call to i32*
  store i32* %1, i32** %idx, align 4
  %2 = load i32*, i32** %idx, align 4
  %cmp = icmp eq i32* %2, null
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %call1 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([33 x i8], [33 x i8]* @.str.3, i32 0, i32 0), i8* getelementptr inbounds ([23 x i8], [23 x i8]* @.str.1, i32 0, i32 0), i32 77)
  call void @perror(i8* getelementptr inbounds ([1 x i8], [1 x i8]* @.str.2, i32 0, i32 0))
  call void @exit(i32 1) #5
  unreachable

if.end:                                           ; preds = %entry
  %3 = load i32, i32* %SIZE.addr, align 4
  %mul2 = mul i32 8, %3
  %call3 = call noalias i8* @malloc(i32 %mul2)
  %4 = bitcast i8* %call3 to double*
  store double* %4, double** @base_arr, align 4
  %5 = load double*, double** @base_arr, align 4
  %cmp4 = icmp eq double* %5, null
  br i1 %cmp4, label %if.then5, label %if.end7

if.then5:                                         ; preds = %if.end
  %call6 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([33 x i8], [33 x i8]* @.str.3, i32 0, i32 0), i8* getelementptr inbounds ([23 x i8], [23 x i8]* @.str.1, i32 0, i32 0), i32 83)
  call void @perror(i8* getelementptr inbounds ([1 x i8], [1 x i8]* @.str.2, i32 0, i32 0))
  call void @exit(i32 1) #5
  unreachable

if.end7:                                          ; preds = %if.end
  store i32 0, i32* %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.end7
  %6 = load i32, i32* %i, align 4
  %7 = load i32, i32* %SIZE.addr, align 4
  %cmp8 = icmp ult i32 %6, %7
  br i1 %cmp8, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %8 = load double*, double** %ARRAY.addr, align 4
  %9 = load i32, i32* %i, align 4
  %arrayidx = getelementptr inbounds double, double* %8, i32 %9
  %10 = load double, double* %arrayidx, align 8
  %11 = load double*, double** @base_arr, align 4
  %12 = load i32, i32* %i, align 4
  %arrayidx9 = getelementptr inbounds double, double* %11, i32 %12
  store double %10, double* %arrayidx9, align 8
  %13 = load i32, i32* %i, align 4
  %14 = load i32*, i32** %idx, align 4
  %15 = load i32, i32* %i, align 4
  %arrayidx10 = getelementptr inbounds i32, i32* %14, i32 %15
  store i32 %13, i32* %arrayidx10, align 4
  br label %for.inc

for.inc:                                          ; preds = %for.body
  %16 = load i32, i32* %i, align 4
  %inc = add i32 %16, 1
  store i32 %inc, i32* %i, align 4
  br label %for.cond

for.end:                                          ; preds = %for.cond
  %17 = load i8, i8* %DECREASING.addr, align 1
  %tobool = trunc i8 %17 to i1
  %conv = zext i1 %tobool to i32
  %cmp11 = icmp eq i32 %conv, 0
  br i1 %cmp11, label %if.then13, label %if.else

if.then13:                                        ; preds = %for.end
  %18 = load i32*, i32** %idx, align 4
  %19 = bitcast i32* %18 to i8*
  %20 = load i32, i32* %SIZE.addr, align 4
  call void @qsort(i8* %19, i32 %20, i32 4, i32 (i8*, i8*)* @compar_decrease)
  br label %if.end20

if.else:                                          ; preds = %for.end
  %21 = load i8, i8* %DECREASING.addr, align 1
  %tobool14 = trunc i8 %21 to i1
  br i1 %tobool14, label %if.then18, label %if.end19

if.then18:                                        ; preds = %if.else
  %22 = load i32*, i32** %idx, align 4
  %23 = bitcast i32* %22 to i8*
  %24 = load i32, i32* %SIZE.addr, align 4
  call void @qsort(i8* %23, i32 %24, i32 4, i32 (i8*, i8*)* @compar_increase)
  br label %if.end19

if.end19:                                         ; preds = %if.then18, %if.else
  br label %if.end20

if.end20:                                         ; preds = %if.end19, %if.then13
  %25 = load double*, double** @base_arr, align 4
  %26 = bitcast double* %25 to i8*
  call void @free(i8* %26)
  store double* null, double** @base_arr, align 4
  %27 = load i32*, i32** %idx, align 4
  ret i32* %27
}

declare void @qsort(i8* %0, i32 %1, i32 %2, i32 (i8*, i8*)* %3) #1

; Function Attrs: noinline nounwind optnone
define internal i32 @compar_decrease(i8* noalias %a, i8* noalias %b) #0 {
entry:
  %retval = alloca i32, align 4
  %a.addr = alloca i8*, align 4
  %b.addr = alloca i8*, align 4
  %aa = alloca i32, align 4
  %bb = alloca i32, align 4
  store i8* %a, i8** %a.addr, align 4
  store i8* %b, i8** %b.addr, align 4
  %0 = load i8*, i8** %a.addr, align 4
  %1 = bitcast i8* %0 to i32*
  %2 = load i32, i32* %1, align 4
  store i32 %2, i32* %aa, align 4
  %3 = load i8*, i8** %b.addr, align 4
  %4 = bitcast i8* %3 to i32*
  %5 = load i32, i32* %4, align 4
  store i32 %5, i32* %bb, align 4
  %6 = load double*, double** @base_arr, align 4
  %7 = load i32, i32* %aa, align 4
  %arrayidx = getelementptr inbounds double, double* %6, i32 %7
  %8 = load double, double* %arrayidx, align 8
  %9 = load double*, double** @base_arr, align 4
  %10 = load i32, i32* %bb, align 4
  %arrayidx1 = getelementptr inbounds double, double* %9, i32 %10
  %11 = load double, double* %arrayidx1, align 8
  %cmp = fcmp olt double %8, %11
  br i1 %cmp, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  store i32 -1, i32* %retval, align 4
  br label %return

if.else:                                          ; preds = %entry
  %12 = load double*, double** @base_arr, align 4
  %13 = load i32, i32* %aa, align 4
  %arrayidx2 = getelementptr inbounds double, double* %12, i32 %13
  %14 = load double, double* %arrayidx2, align 8
  %15 = load double*, double** @base_arr, align 4
  %16 = load i32, i32* %bb, align 4
  %arrayidx3 = getelementptr inbounds double, double* %15, i32 %16
  %17 = load double, double* %arrayidx3, align 8
  %cmp4 = fcmp oeq double %14, %17
  br i1 %cmp4, label %if.then5, label %if.else6

if.then5:                                         ; preds = %if.else
  store i32 0, i32* %retval, align 4
  br label %return

if.else6:                                         ; preds = %if.else
  store i32 1, i32* %retval, align 4
  br label %return

return:                                           ; preds = %if.else6, %if.then5, %if.then
  %18 = load i32, i32* %retval, align 4
  ret i32 %18
}

; Function Attrs: noinline nounwind optnone
define internal i32 @compar_increase(i8* noalias %a, i8* noalias %b) #0 {
entry:
  %retval = alloca i32, align 4
  %a.addr = alloca i8*, align 4
  %b.addr = alloca i8*, align 4
  %aa = alloca i32, align 4
  %bb = alloca i32, align 4
  store i8* %a, i8** %a.addr, align 4
  store i8* %b, i8** %b.addr, align 4
  %0 = load i8*, i8** %a.addr, align 4
  %1 = bitcast i8* %0 to i32*
  %2 = load i32, i32* %1, align 4
  store i32 %2, i32* %aa, align 4
  %3 = load i8*, i8** %b.addr, align 4
  %4 = bitcast i8* %3 to i32*
  %5 = load i32, i32* %4, align 4
  store i32 %5, i32* %bb, align 4
  %6 = load double*, double** @base_arr, align 4
  %7 = load i32, i32* %aa, align 4
  %arrayidx = getelementptr inbounds double, double* %6, i32 %7
  %8 = load double, double* %arrayidx, align 8
  %9 = load double*, double** @base_arr, align 4
  %10 = load i32, i32* %bb, align 4
  %arrayidx1 = getelementptr inbounds double, double* %9, i32 %10
  %11 = load double, double* %arrayidx1, align 8
  %cmp = fcmp olt double %8, %11
  br i1 %cmp, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  store i32 1, i32* %retval, align 4
  br label %return

if.else:                                          ; preds = %entry
  %12 = load double*, double** @base_arr, align 4
  %13 = load i32, i32* %aa, align 4
  %arrayidx2 = getelementptr inbounds double, double* %12, i32 %13
  %14 = load double, double* %arrayidx2, align 8
  %15 = load double*, double** @base_arr, align 4
  %16 = load i32, i32* %bb, align 4
  %arrayidx3 = getelementptr inbounds double, double* %15, i32 %16
  %17 = load double, double* %arrayidx3, align 8
  %cmp4 = fcmp oeq double %14, %17
  br i1 %cmp4, label %if.then5, label %if.else6

if.then5:                                         ; preds = %if.else
  store i32 0, i32* %retval, align 4
  br label %return

if.else6:                                         ; preds = %if.else
  store i32 -1, i32* %retval, align 4
  br label %return

return:                                           ; preds = %if.else6, %if.then5, %if.then
  %18 = load i32, i32* %retval, align 4
  ret i32 %18
}

declare void @free(i8* %0) #1

; Function Attrs: noinline nounwind optnone
define hidden double* @cummin(double* noalias %ARRAY, i32 %NO_OF_ARRAY_ELEMENTS) #0 {
entry:
  %ARRAY.addr = alloca double*, align 4
  %NO_OF_ARRAY_ELEMENTS.addr = alloca i32, align 4
  %output = alloca double*, align 4
  %cumulative_min = alloca double, align 8
  %i = alloca i32, align 4
  store double* %ARRAY, double** %ARRAY.addr, align 4
  store i32 %NO_OF_ARRAY_ELEMENTS, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
  %0 = load i32, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
  %cmp = icmp ult i32 %0, 1
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %call = call i32 @puts(i8* getelementptr inbounds ([48 x i8], [48 x i8]* @.str.4, i32 0, i32 0))
  %call1 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([22 x i8], [22 x i8]* @.str.5, i32 0, i32 0), i8* getelementptr inbounds ([23 x i8], [23 x i8]* @.str.1, i32 0, i32 0), i32 105)
  call void @exit(i32 1) #5
  unreachable

if.end:                                           ; preds = %entry
  %1 = load i32, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
  %mul = mul i32 8, %1
  %call2 = call noalias i8* @malloc(i32 %mul)
  %2 = bitcast i8* %call2 to double*
  store double* %2, double** %output, align 4
  %3 = load double*, double** %output, align 4
  %cmp3 = icmp eq double* %3, null
  br i1 %cmp3, label %if.then4, label %if.end6

if.then4:                                         ; preds = %if.end
  %call5 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([33 x i8], [33 x i8]* @.str.3, i32 0, i32 0), i8* getelementptr inbounds ([23 x i8], [23 x i8]* @.str.1, i32 0, i32 0), i32 110)
  call void @perror(i8* getelementptr inbounds ([1 x i8], [1 x i8]* @.str.2, i32 0, i32 0))
  call void @exit(i32 1) #5
  unreachable

if.end6:                                          ; preds = %if.end
  %4 = load double*, double** %ARRAY.addr, align 4
  %arrayidx = getelementptr inbounds double, double* %4, i32 0
  %5 = load double, double* %arrayidx, align 8
  store double %5, double* %cumulative_min, align 8
  store i32 0, i32* %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.end6
  %6 = load i32, i32* %i, align 4
  %7 = load i32, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
  %cmp7 = icmp ult i32 %6, %7
  br i1 %cmp7, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %8 = load double*, double** %ARRAY.addr, align 4
  %9 = load i32, i32* %i, align 4
  %arrayidx8 = getelementptr inbounds double, double* %8, i32 %9
  %10 = load double, double* %arrayidx8, align 8
  %11 = load double, double* %cumulative_min, align 8
  %cmp9 = fcmp olt double %10, %11
  br i1 %cmp9, label %if.then10, label %if.end12

if.then10:                                        ; preds = %for.body
  %12 = load double*, double** %ARRAY.addr, align 4
  %13 = load i32, i32* %i, align 4
  %arrayidx11 = getelementptr inbounds double, double* %12, i32 %13
  %14 = load double, double* %arrayidx11, align 8
  store double %14, double* %cumulative_min, align 8
  br label %if.end12

if.end12:                                         ; preds = %if.then10, %for.body
  %15 = load double, double* %cumulative_min, align 8
  %16 = load double*, double** %output, align 4
  %17 = load i32, i32* %i, align 4
  %arrayidx13 = getelementptr inbounds double, double* %16, i32 %17
  store double %15, double* %arrayidx13, align 8
  br label %for.inc

for.inc:                                          ; preds = %if.end12
  %18 = load i32, i32* %i, align 4
  %inc = add i32 %18, 1
  store i32 %inc, i32* %i, align 4
  br label %for.cond

for.end:                                          ; preds = %for.cond
  %19 = load double*, double** %output, align 4
  ret double* %19
}

declare i32 @puts(i8* %0) #1

; Function Attrs: noinline nounwind optnone
define hidden double* @cummax(double* noalias %ARRAY, i32 %NO_OF_ARRAY_ELEMENTS) #0 {
entry:
  %ARRAY.addr = alloca double*, align 4
  %NO_OF_ARRAY_ELEMENTS.addr = alloca i32, align 4
  %output = alloca double*, align 4
  %cumulative_max = alloca double, align 8
  %i = alloca i32, align 4
  store double* %ARRAY, double** %ARRAY.addr, align 4
  store i32 %NO_OF_ARRAY_ELEMENTS, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
  %0 = load i32, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
  %cmp = icmp ult i32 %0, 1
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %call = call i32 @puts(i8* getelementptr inbounds ([41 x i8], [41 x i8]* @.str.6, i32 0, i32 0))
  %call1 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([22 x i8], [22 x i8]* @.str.5, i32 0, i32 0), i8* getelementptr inbounds ([23 x i8], [23 x i8]* @.str.1, i32 0, i32 0), i32 129)
  call void @exit(i32 1) #5
  unreachable

if.end:                                           ; preds = %entry
  %1 = load i32, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
  %mul = mul i32 8, %1
  %call2 = call noalias i8* @malloc(i32 %mul)
  %2 = bitcast i8* %call2 to double*
  store double* %2, double** %output, align 4
  %3 = load double*, double** %output, align 4
  %cmp3 = icmp eq double* %3, null
  br i1 %cmp3, label %if.then4, label %if.end6

if.then4:                                         ; preds = %if.end
  %call5 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([33 x i8], [33 x i8]* @.str.3, i32 0, i32 0), i8* getelementptr inbounds ([23 x i8], [23 x i8]* @.str.1, i32 0, i32 0), i32 134)
  call void @perror(i8* getelementptr inbounds ([1 x i8], [1 x i8]* @.str.2, i32 0, i32 0))
  call void @exit(i32 1) #5
  unreachable

if.end6:                                          ; preds = %if.end
  %4 = load double*, double** %ARRAY.addr, align 4
  %arrayidx = getelementptr inbounds double, double* %4, i32 0
  %5 = load double, double* %arrayidx, align 8
  store double %5, double* %cumulative_max, align 8
  store i32 0, i32* %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.end6
  %6 = load i32, i32* %i, align 4
  %7 = load i32, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
  %cmp7 = icmp ult i32 %6, %7
  br i1 %cmp7, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %8 = load double*, double** %ARRAY.addr, align 4
  %9 = load i32, i32* %i, align 4
  %arrayidx8 = getelementptr inbounds double, double* %8, i32 %9
  %10 = load double, double* %arrayidx8, align 8
  %11 = load double, double* %cumulative_max, align 8
  %cmp9 = fcmp ogt double %10, %11
  br i1 %cmp9, label %if.then10, label %if.end12

if.then10:                                        ; preds = %for.body
  %12 = load double*, double** %ARRAY.addr, align 4
  %13 = load i32, i32* %i, align 4
  %arrayidx11 = getelementptr inbounds double, double* %12, i32 %13
  %14 = load double, double* %arrayidx11, align 8
  store double %14, double* %cumulative_max, align 8
  br label %if.end12

if.end12:                                         ; preds = %if.then10, %for.body
  %15 = load double, double* %cumulative_max, align 8
  %16 = load double*, double** %output, align 4
  %17 = load i32, i32* %i, align 4
  %arrayidx13 = getelementptr inbounds double, double* %16, i32 %17
  store double %15, double* %arrayidx13, align 8
  br label %for.inc

for.inc:                                          ; preds = %if.end12
  %18 = load i32, i32* %i, align 4
  %inc = add i32 %18, 1
  store i32 %inc, i32* %i, align 4
  br label %for.cond

for.end:                                          ; preds = %for.cond
  %19 = load double*, double** %output, align 4
  ret double* %19
}

; Function Attrs: noinline nounwind optnone
define hidden double* @pminx(double* noalias %ARRAY, i32 %NO_OF_ARRAY_ELEMENTS, double %X) #0 {
entry:
  %ARRAY.addr = alloca double*, align 4
  %NO_OF_ARRAY_ELEMENTS.addr = alloca i32, align 4
  %X.addr = alloca double, align 8
  %pmin_array = alloca double*, align 4
  %index = alloca i32, align 4
  store double* %ARRAY, double** %ARRAY.addr, align 4
  store i32 %NO_OF_ARRAY_ELEMENTS, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
  store double %X, double* %X.addr, align 8
  %0 = load i32, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
  %cmp = icmp ult i32 %0, 1
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %call = call i32 @puts(i8* getelementptr inbounds ([37 x i8], [37 x i8]* @.str.7, i32 0, i32 0))
  %call1 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([22 x i8], [22 x i8]* @.str.5, i32 0, i32 0), i8* getelementptr inbounds ([23 x i8], [23 x i8]* @.str.1, i32 0, i32 0), i32 152)
  call void @exit(i32 1) #5
  unreachable

if.end:                                           ; preds = %entry
  %1 = load i32, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
  %mul = mul i32 8, %1
  %call2 = call noalias i8* @malloc(i32 %mul)
  %2 = bitcast i8* %call2 to double*
  store double* %2, double** %pmin_array, align 4
  %3 = load double*, double** %pmin_array, align 4
  %cmp3 = icmp eq double* %3, null
  br i1 %cmp3, label %if.then4, label %if.end6

if.then4:                                         ; preds = %if.end
  %call5 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([33 x i8], [33 x i8]* @.str.3, i32 0, i32 0), i8* getelementptr inbounds ([23 x i8], [23 x i8]* @.str.1, i32 0, i32 0), i32 157)
  call void @perror(i8* getelementptr inbounds ([1 x i8], [1 x i8]* @.str.2, i32 0, i32 0))
  call void @exit(i32 1) #5
  unreachable

if.end6:                                          ; preds = %if.end
  store i32 0, i32* %index, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.end6
  %4 = load i32, i32* %index, align 4
  %5 = load i32, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
  %cmp7 = icmp ult i32 %4, %5
  br i1 %cmp7, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %6 = load double*, double** %ARRAY.addr, align 4
  %7 = load i32, i32* %index, align 4
  %arrayidx = getelementptr inbounds double, double* %6, i32 %7
  %8 = load double, double* %arrayidx, align 8
  %9 = load double, double* %X.addr, align 8
  %cmp8 = fcmp olt double %8, %9
  br i1 %cmp8, label %if.then9, label %if.else

if.then9:                                         ; preds = %for.body
  %10 = load double*, double** %ARRAY.addr, align 4
  %11 = load i32, i32* %index, align 4
  %arrayidx10 = getelementptr inbounds double, double* %10, i32 %11
  %12 = load double, double* %arrayidx10, align 8
  %13 = load double*, double** %pmin_array, align 4
  %14 = load i32, i32* %index, align 4
  %arrayidx11 = getelementptr inbounds double, double* %13, i32 %14
  store double %12, double* %arrayidx11, align 8
  br label %if.end13

if.else:                                          ; preds = %for.body
  %15 = load double, double* %X.addr, align 8
  %16 = load double*, double** %pmin_array, align 4
  %17 = load i32, i32* %index, align 4
  %arrayidx12 = getelementptr inbounds double, double* %16, i32 %17
  store double %15, double* %arrayidx12, align 8
  br label %if.end13

if.end13:                                         ; preds = %if.else, %if.then9
  br label %for.inc

for.inc:                                          ; preds = %if.end13
  %18 = load i32, i32* %index, align 4
  %inc = add i32 %18, 1
  store i32 %inc, i32* %index, align 4
  br label %for.cond

for.end:                                          ; preds = %for.cond
  %19 = load double*, double** %pmin_array, align 4
  ret double* %19
}

; Function Attrs: noinline nounwind optnone
define hidden void @double_say(double* noalias %ARRAY, i32 %NO_OF_ARRAY_ELEMENTS) #0 {
entry:
  %ARRAY.addr = alloca double*, align 4
  %NO_OF_ARRAY_ELEMENTS.addr = alloca i32, align 4
  %i = alloca i32, align 4
  store double* %ARRAY, double** %ARRAY.addr, align 4
  store i32 %NO_OF_ARRAY_ELEMENTS, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
  %0 = load double*, double** %ARRAY.addr, align 4
  %arrayidx = getelementptr inbounds double, double* %0, i32 0
  %1 = load double, double* %arrayidx, align 8
  %call = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([7 x i8], [7 x i8]* @.str.8, i32 0, i32 0), double %1)
  store i32 1, i32* %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %2 = load i32, i32* %i, align 4
  %3 = load i32, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
  %cmp = icmp ult i32 %2, %3
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %4 = load double*, double** %ARRAY.addr, align 4
  %5 = load i32, i32* %i, align 4
  %arrayidx1 = getelementptr inbounds double, double* %4, i32 %5
  %6 = load double, double* %arrayidx1, align 8
  %call2 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([7 x i8], [7 x i8]* @.str.9, i32 0, i32 0), double %6)
  %7 = load i32, i32* %i, align 4
  %add = add i32 %7, 1
  %rem = urem i32 %add, 5
  %cmp3 = icmp eq i32 %rem, 0
  br i1 %cmp3, label %if.then, label %if.end

if.then:                                          ; preds = %for.body
  %8 = load i32, i32* %i, align 4
  %add4 = add i32 %8, 1
  %call5 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([6 x i8], [6 x i8]* @.str.10, i32 0, i32 0), i32 %add4)
  br label %if.end

if.end:                                           ; preds = %if.then, %for.body
  br label %for.inc

for.inc:                                          ; preds = %if.end
  %9 = load i32, i32* %i, align 4
  %inc = add i32 %9, 1
  store i32 %inc, i32* %i, align 4
  br label %for.cond

for.end:                                          ; preds = %for.cond
  %call6 = call i32 @puts(i8* getelementptr inbounds ([2 x i8], [2 x i8]* @.str.11, i32 0, i32 0))
  ret void
}

; Function Attrs: noinline nounwind optnone
define hidden double* @uint2double(i32* noalias %ARRAY, i32 %NO_OF_ARRAY_ELEMENTS) #0 {
entry:
  %ARRAY.addr = alloca i32*, align 4
  %NO_OF_ARRAY_ELEMENTS.addr = alloca i32, align 4
  %doubleArray = alloca double*, align 4
  %index = alloca i32, align 4
  store i32* %ARRAY, i32** %ARRAY.addr, align 4
  store i32 %NO_OF_ARRAY_ELEMENTS, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
  %0 = load i32, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
  %mul = mul i32 8, %0
  %call = call noalias i8* @malloc(i32 %mul)
  %1 = bitcast i8* %call to double*
  store double* %1, double** %doubleArray, align 4
  %2 = load double*, double** %doubleArray, align 4
  %cmp = icmp eq double* %2, null
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %call1 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([34 x i8], [34 x i8]* @.str.12, i32 0, i32 0), i8* getelementptr inbounds ([23 x i8], [23 x i8]* @.str.1, i32 0, i32 0), i32 194)
  call void @perror(i8* getelementptr inbounds ([1 x i8], [1 x i8]* @.str.2, i32 0, i32 0))
  call void @exit(i32 1) #5
  unreachable

if.end:                                           ; preds = %entry
  store i32 0, i32* %index, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.end
  %3 = load i32, i32* %index, align 4
  %4 = load i32, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
  %cmp2 = icmp ult i32 %3, %4
  br i1 %cmp2, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %5 = load i32*, i32** %ARRAY.addr, align 4
  %6 = load i32, i32* %index, align 4
  %arrayidx = getelementptr inbounds i32, i32* %5, i32 %6
  %7 = load i32, i32* %arrayidx, align 4
  %conv = uitofp i32 %7 to double
  %8 = load double*, double** %doubleArray, align 4
  %9 = load i32, i32* %index, align 4
  %arrayidx3 = getelementptr inbounds double, double* %8, i32 %9
  store double %conv, double* %arrayidx3, align 8
  br label %for.inc

for.inc:                                          ; preds = %for.body
  %10 = load i32, i32* %index, align 4
  %inc = add i32 %10, 1
  store i32 %inc, i32* %index, align 4
  br label %for.cond

for.end:                                          ; preds = %for.cond
  %11 = load double*, double** %doubleArray, align 4
  ret double* %11
}

; Function Attrs: noinline nounwind optnone
define hidden double @min2(double %N1, double %N2) #0 {
entry:
  %retval = alloca double, align 8
  %N1.addr = alloca double, align 8
  %N2.addr = alloca double, align 8
  store double %N1, double* %N1.addr, align 8
  store double %N2, double* %N2.addr, align 8
  %0 = load double, double* %N1.addr, align 8
  %1 = load double, double* %N2.addr, align 8
  %cmp = fcmp olt double %0, %1
  br i1 %cmp, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  %2 = load double, double* %N1.addr, align 8
  store double %2, double* %retval, align 8
  br label %return

if.else:                                          ; preds = %entry
  %3 = load double, double* %N2.addr, align 8
  store double %3, double* %retval, align 8
  br label %return

return:                                           ; preds = %if.else, %if.then
  %4 = load double, double* %retval, align 8
  ret double %4
}

; Function Attrs: noinline nounwind optnone
define hidden double* @p_adjust(double* noalias %PVALUES, i32 %NO_OF_ARRAY_ELEMENTS, i8* noalias %STRING) #0 {
entry:
  %retval = alloca double*, align 4
  %PVALUES.addr = alloca double*, align 4
  %NO_OF_ARRAY_ELEMENTS.addr = alloca i32, align 4
  %STRING.addr = alloca i8*, align 4
  %TYPE = alloca i16, align 2
  %bonferroni = alloca double*, align 4
  %index = alloca i32, align 4
  %BONFERRONI = alloca double, align 8
  %o = alloca i32*, align 4
  %o2double = alloca double*, align 4
  %cummax_input = alloca double*, align 4
  %index80 = alloca i32, align 4
  %ro = alloca i32*, align 4
  %cummax_output = alloca double*, align 4
  %pmin = alloca double*, align 4
  %qvalues = alloca double*, align 4
  %index98 = alloca i32, align 4
  %o114 = alloca i32*, align 4
  %p = alloca double*, align 4
  %index123 = alloca i32, align 4
  %o2double134 = alloca double*, align 4
  %ro136 = alloca i32*, align 4
  %q = alloca double*, align 4
  %pa = alloca double*, align 4
  %min = alloca double, align 8
  %index155 = alloca i32, align 4
  %TEMP = alloca double, align 8
  %index171 = alloca i32, align 4
  %j = alloca i32, align 4
  %ij = alloca i32*, align 4
  %I2_LENGTH = alloca i32, align 4
  %i2 = alloca i32*, align 4
  %i = alloca i32, align 4
  %q1 = alloca double, align 8
  %i208 = alloca i32, align 4
  %TEMP_Q1 = alloca double, align 8
  %i227 = alloca i32, align 4
  %i244 = alloca i32, align 4
  %i256 = alloca i32, align 4
  %index274 = alloca i32, align 4
  %o288 = alloca i32*, align 4
  %o_double = alloca double*, align 4
  %index296 = alloca i32, align 4
  %ro315 = alloca i32*, align 4
  %cummin_input = alloca double*, align 4
  %index328 = alloca i32, align 4
  %NI = alloca double, align 8
  %q349 = alloca double, align 8
  %index350 = alloca i32, align 4
  %index362 = alloca i32, align 4
  %NI367 = alloca double, align 8
  %index385 = alloca i32, align 4
  %cummin_array = alloca double*, align 4
  %pmin403 = alloca double*, align 4
  %q_array = alloca double*, align 4
  %index407 = alloca i32, align 4
  store double* %PVALUES, double** %PVALUES.addr, align 4
  store i32 %NO_OF_ARRAY_ELEMENTS, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
  store i8* %STRING, i8** %STRING.addr, align 4
  %0 = load i32, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
  %cmp = icmp ult i32 %0, 1
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %call = call i32 @puts(i8* getelementptr inbounds ([41 x i8], [41 x i8]* @.str.13, i32 0, i32 0))
  %call1 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([22 x i8], [22 x i8]* @.str.5, i32 0, i32 0), i8* getelementptr inbounds ([23 x i8], [23 x i8]* @.str.1, i32 0, i32 0), i32 217)
  call void @exit(i32 1) #5
  unreachable

if.end:                                           ; preds = %entry
  store i16 -1, i16* %TYPE, align 2
  %1 = load i8*, i8** %STRING.addr, align 4
  %cmp2 = icmp eq i8* %1, null
  br i1 %cmp2, label %if.then3, label %if.else

if.then3:                                         ; preds = %if.end
  store i16 0, i16* %TYPE, align 2
  br label %if.end41

if.else:                                          ; preds = %if.end
  %2 = load i8*, i8** %STRING.addr, align 4
  %call4 = call i32 @strcasecmp(i8* %2, i8* getelementptr inbounds ([3 x i8], [3 x i8]* @.str.14, i32 0, i32 0))
  %cmp5 = icmp eq i32 %call4, 0
  br i1 %cmp5, label %if.then6, label %if.else7

if.then6:                                         ; preds = %if.else
  store i16 0, i16* %TYPE, align 2
  br label %if.end40

if.else7:                                         ; preds = %if.else
  %3 = load i8*, i8** %STRING.addr, align 4
  %call8 = call i32 @strcasecmp(i8* %3, i8* getelementptr inbounds ([4 x i8], [4 x i8]* @.str.15, i32 0, i32 0))
  %cmp9 = icmp eq i32 %call8, 0
  br i1 %cmp9, label %if.then10, label %if.else11

if.then10:                                        ; preds = %if.else7
  store i16 0, i16* %TYPE, align 2
  br label %if.end39

if.else11:                                        ; preds = %if.else7
  %4 = load i8*, i8** %STRING.addr, align 4
  %call12 = call i32 @strcasecmp(i8* %4, i8* getelementptr inbounds ([3 x i8], [3 x i8]* @.str.16, i32 0, i32 0))
  %cmp13 = icmp eq i32 %call12, 0
  br i1 %cmp13, label %if.then14, label %if.else15

if.then14:                                        ; preds = %if.else11
  store i16 1, i16* %TYPE, align 2
  br label %if.end38

if.else15:                                        ; preds = %if.else11
  %5 = load i8*, i8** %STRING.addr, align 4
  %call16 = call i32 @strcasecmp(i8* %5, i8* getelementptr inbounds ([11 x i8], [11 x i8]* @.str.17, i32 0, i32 0))
  %cmp17 = icmp eq i32 %call16, 0
  br i1 %cmp17, label %if.then18, label %if.else19

if.then18:                                        ; preds = %if.else15
  store i16 2, i16* %TYPE, align 2
  br label %if.end37

if.else19:                                        ; preds = %if.else15
  %6 = load i8*, i8** %STRING.addr, align 4
  %call20 = call i32 @strcasecmp(i8* %6, i8* getelementptr inbounds ([9 x i8], [9 x i8]* @.str.18, i32 0, i32 0))
  %cmp21 = icmp eq i32 %call20, 0
  br i1 %cmp21, label %if.then22, label %if.else23

if.then22:                                        ; preds = %if.else19
  store i16 3, i16* %TYPE, align 2
  br label %if.end36

if.else23:                                        ; preds = %if.else19
  %7 = load i8*, i8** %STRING.addr, align 4
  %call24 = call i32 @strcasecmp(i8* %7, i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.19, i32 0, i32 0))
  %cmp25 = icmp eq i32 %call24, 0
  br i1 %cmp25, label %if.then26, label %if.else27

if.then26:                                        ; preds = %if.else23
  store i16 4, i16* %TYPE, align 2
  br label %if.end35

if.else27:                                        ; preds = %if.else23
  %8 = load i8*, i8** %STRING.addr, align 4
  %call28 = call i32 @strcasecmp(i8* %8, i8* getelementptr inbounds ([7 x i8], [7 x i8]* @.str.20, i32 0, i32 0))
  %cmp29 = icmp eq i32 %call28, 0
  br i1 %cmp29, label %if.then30, label %if.else31

if.then30:                                        ; preds = %if.else27
  store i16 5, i16* %TYPE, align 2
  br label %if.end34

if.else31:                                        ; preds = %if.else27
  %9 = load i8*, i8** %STRING.addr, align 4
  %call32 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([44 x i8], [44 x i8]* @.str.21, i32 0, i32 0), i8* %9)
  %call33 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([22 x i8], [22 x i8]* @.str.5, i32 0, i32 0), i8* getelementptr inbounds ([23 x i8], [23 x i8]* @.str.1, i32 0, i32 0), i32 239)
  call void @exit(i32 1) #5
  unreachable

if.end34:                                         ; preds = %if.then30
  br label %if.end35

if.end35:                                         ; preds = %if.end34, %if.then26
  br label %if.end36

if.end36:                                         ; preds = %if.end35, %if.then22
  br label %if.end37

if.end37:                                         ; preds = %if.end36, %if.then18
  br label %if.end38

if.end38:                                         ; preds = %if.end37, %if.then14
  br label %if.end39

if.end39:                                         ; preds = %if.end38, %if.then10
  br label %if.end40

if.end40:                                         ; preds = %if.end39, %if.then6
  br label %if.end41

if.end41:                                         ; preds = %if.end40, %if.then3
  %10 = load i16, i16* %TYPE, align 2
  %conv = sext i16 %10 to i32
  %cmp42 = icmp eq i32 %conv, 2
  br i1 %cmp42, label %if.then44, label %if.else71

if.then44:                                        ; preds = %if.end41
  %11 = load i32, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
  %mul = mul i32 8, %11
  %call45 = call noalias i8* @malloc(i32 %mul)
  %12 = bitcast i8* %call45 to double*
  store double* %12, double** %bonferroni, align 4
  %13 = load double*, double** %bonferroni, align 4
  %cmp46 = icmp eq double* %13, null
  br i1 %cmp46, label %if.then48, label %if.end50

if.then48:                                        ; preds = %if.then44
  %call49 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([33 x i8], [33 x i8]* @.str.3, i32 0, i32 0), i8* getelementptr inbounds ([23 x i8], [23 x i8]* @.str.1, i32 0, i32 0), i32 247)
  call void @perror(i8* getelementptr inbounds ([1 x i8], [1 x i8]* @.str.2, i32 0, i32 0))
  call void @exit(i32 1) #5
  unreachable

if.end50:                                         ; preds = %if.then44
  store i32 0, i32* %index, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.end50
  %14 = load i32, i32* %index, align 4
  %15 = load i32, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
  %cmp51 = icmp ult i32 %14, %15
  br i1 %cmp51, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %16 = load double*, double** %PVALUES.addr, align 4
  %17 = load i32, i32* %index, align 4
  %arrayidx = getelementptr inbounds double, double* %16, i32 %17
  %18 = load double, double* %arrayidx, align 8
  %19 = load i32, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
  %conv53 = uitofp i32 %19 to double
  %mul54 = fmul double %18, %conv53
  store double %mul54, double* %BONFERRONI, align 8
  %20 = load double, double* %BONFERRONI, align 8
  %cmp55 = fcmp oge double %20, 1.000000e+00
  br i1 %cmp55, label %if.then57, label %if.else59

if.then57:                                        ; preds = %for.body
  %21 = load double*, double** %bonferroni, align 4
  %22 = load i32, i32* %index, align 4
  %arrayidx58 = getelementptr inbounds double, double* %21, i32 %22
  store double 1.000000e+00, double* %arrayidx58, align 8
  br label %if.end70

if.else59:                                        ; preds = %for.body
  %23 = load double, double* %BONFERRONI, align 8
  %cmp60 = fcmp ole double 0.000000e+00, %23
  br i1 %cmp60, label %land.lhs.true, label %if.else66

land.lhs.true:                                    ; preds = %if.else59
  %24 = load double, double* %BONFERRONI, align 8
  %cmp62 = fcmp olt double %24, 1.000000e+00
  br i1 %cmp62, label %if.then64, label %if.else66

if.then64:                                        ; preds = %land.lhs.true
  %25 = load double, double* %BONFERRONI, align 8
  %26 = load double*, double** %bonferroni, align 4
  %27 = load i32, i32* %index, align 4
  %arrayidx65 = getelementptr inbounds double, double* %26, i32 %27
  store double %25, double* %arrayidx65, align 8
  br label %if.end69

if.else66:                                        ; preds = %land.lhs.true, %if.else59
  %28 = load double, double* %BONFERRONI, align 8
  %call67 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([42 x i8], [42 x i8]* @.str.22, i32 0, i32 0), double %28)
  %call68 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([23 x i8], [23 x i8]* @.str.23, i32 0, i32 0), i8* getelementptr inbounds ([23 x i8], [23 x i8]* @.str.1, i32 0, i32 0), i32 259)
  call void @exit(i32 1) #5
  unreachable

if.end69:                                         ; preds = %if.then64
  br label %if.end70

if.end70:                                         ; preds = %if.end69, %if.then57
  br label %for.inc

for.inc:                                          ; preds = %if.end70
  %29 = load i32, i32* %index, align 4
  %inc = add i32 %29, 1
  store i32 %inc, i32* %index, align 4
  br label %for.cond

for.end:                                          ; preds = %for.cond
  %30 = load double*, double** %bonferroni, align 4
  store double* %30, double** %retval, align 4
  br label %return

if.else71:                                        ; preds = %if.end41
  %31 = load i16, i16* %TYPE, align 2
  %conv72 = sext i16 %31 to i32
  %cmp73 = icmp eq i32 %conv72, 4
  br i1 %cmp73, label %if.then75, label %if.else109

if.then75:                                        ; preds = %if.else71
  %32 = load double*, double** %PVALUES.addr, align 4
  %33 = load i32, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
  %call76 = call i32* @order(double* %32, i32 %33, i1 zeroext false)
  store i32* %call76, i32** %o, align 4
  %34 = load i32*, i32** %o, align 4
  %35 = load i32, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
  %call77 = call double* @uint2double(i32* %34, i32 %35)
  store double* %call77, double** %o2double, align 4
  %36 = load i32, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
  %mul78 = mul i32 8, %36
  %call79 = call noalias i8* @malloc(i32 %mul78)
  %37 = bitcast i8* %call79 to double*
  store double* %37, double** %cummax_input, align 4
  store i32 0, i32* %index80, align 4
  br label %for.cond81

for.cond81:                                       ; preds = %for.inc90, %if.then75
  %38 = load i32, i32* %index80, align 4
  %39 = load i32, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
  %cmp82 = icmp ult i32 %38, %39
  br i1 %cmp82, label %for.body84, label %for.end92

for.body84:                                       ; preds = %for.cond81
  %40 = load i32, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
  %41 = load i32, i32* %index80, align 4
  %sub = sub i32 %40, %41
  %conv85 = uitofp i32 %sub to double
  %42 = load double*, double** %PVALUES.addr, align 4
  %43 = load i32*, i32** %o, align 4
  %44 = load i32, i32* %index80, align 4
  %arrayidx86 = getelementptr inbounds i32, i32* %43, i32 %44
  %45 = load i32, i32* %arrayidx86, align 4
  %arrayidx87 = getelementptr inbounds double, double* %42, i32 %45
  %46 = load double, double* %arrayidx87, align 8
  %mul88 = fmul double %conv85, %46
  %47 = load double*, double** %cummax_input, align 4
  %48 = load i32, i32* %index80, align 4
  %arrayidx89 = getelementptr inbounds double, double* %47, i32 %48
  store double %mul88, double* %arrayidx89, align 8
  br label %for.inc90

for.inc90:                                        ; preds = %for.body84
  %49 = load i32, i32* %index80, align 4
  %inc91 = add i32 %49, 1
  store i32 %inc91, i32* %index80, align 4
  br label %for.cond81

for.end92:                                        ; preds = %for.cond81
  %50 = load i32*, i32** %o, align 4
  %51 = bitcast i32* %50 to i8*
  call void @free(i8* %51)
  store i32* null, i32** %o, align 4
  %52 = load double*, double** %o2double, align 4
  %53 = load i32, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
  %call93 = call i32* @order(double* %52, i32 %53, i1 zeroext false)
  store i32* %call93, i32** %ro, align 4
  %54 = load double*, double** %o2double, align 4
  %55 = bitcast double* %54 to i8*
  call void @free(i8* %55)
  store double* null, double** %o2double, align 4
  %56 = load double*, double** %cummax_input, align 4
  %57 = load i32, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
  %call94 = call double* @cummax(double* %56, i32 %57)
  store double* %call94, double** %cummax_output, align 4
  %58 = load double*, double** %cummax_input, align 4
  %59 = bitcast double* %58 to i8*
  call void @free(i8* %59)
  store double* null, double** %cummax_input, align 4
  %60 = load double*, double** %cummax_output, align 4
  %61 = load i32, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
  %call95 = call double* @pminx(double* %60, i32 %61, double 1.000000e+00)
  store double* %call95, double** %pmin, align 4
  %62 = load double*, double** %cummax_output, align 4
  %63 = bitcast double* %62 to i8*
  call void @free(i8* %63)
  store double* null, double** %cummax_output, align 4
  %64 = load i32, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
  %mul96 = mul i32 8, %64
  %call97 = call noalias i8* @malloc(i32 %mul96)
  %65 = bitcast i8* %call97 to double*
  store double* %65, double** %qvalues, align 4
  store i32 0, i32* %index98, align 4
  br label %for.cond99

for.cond99:                                       ; preds = %for.inc106, %for.end92
  %66 = load i32, i32* %index98, align 4
  %67 = load i32, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
  %cmp100 = icmp ult i32 %66, %67
  br i1 %cmp100, label %for.body102, label %for.end108

for.body102:                                      ; preds = %for.cond99
  %68 = load double*, double** %pmin, align 4
  %69 = load i32*, i32** %ro, align 4
  %70 = load i32, i32* %index98, align 4
  %arrayidx103 = getelementptr inbounds i32, i32* %69, i32 %70
  %71 = load i32, i32* %arrayidx103, align 4
  %arrayidx104 = getelementptr inbounds double, double* %68, i32 %71
  %72 = load double, double* %arrayidx104, align 8
  %73 = load double*, double** %qvalues, align 4
  %74 = load i32, i32* %index98, align 4
  %arrayidx105 = getelementptr inbounds double, double* %73, i32 %74
  store double %72, double* %arrayidx105, align 8
  br label %for.inc106

for.inc106:                                       ; preds = %for.body102
  %75 = load i32, i32* %index98, align 4
  %inc107 = add i32 %75, 1
  store i32 %inc107, i32* %index98, align 4
  br label %for.cond99

for.end108:                                       ; preds = %for.cond99
  %76 = load double*, double** %pmin, align 4
  %77 = bitcast double* %76 to i8*
  call void @free(i8* %77)
  store double* null, double** %pmin, align 4
  %78 = load i32*, i32** %ro, align 4
  %79 = bitcast i32* %78 to i8*
  call void @free(i8* %79)
  store i32* null, i32** %ro, align 4
  %80 = load double*, double** %qvalues, align 4
  store double* %80, double** %retval, align 4
  br label %return

if.else109:                                       ; preds = %if.else71
  %81 = load i16, i16* %TYPE, align 2
  %conv110 = sext i16 %81 to i32
  %cmp111 = icmp eq i32 %conv110, 5
  br i1 %cmp111, label %if.then113, label %if.end285

if.then113:                                       ; preds = %if.else109
  %82 = load double*, double** %PVALUES.addr, align 4
  %83 = load i32, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
  %call115 = call i32* @order(double* %82, i32 %83, i1 zeroext false)
  store i32* %call115, i32** %o114, align 4
  %84 = load i32, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
  %mul116 = mul i32 8, %84
  %call117 = call noalias i8* @malloc(i32 %mul116)
  %85 = bitcast i8* %call117 to double*
  store double* %85, double** %p, align 4
  %86 = load double*, double** %p, align 4
  %cmp118 = icmp eq double* %86, null
  br i1 %cmp118, label %if.then120, label %if.end122

if.then120:                                       ; preds = %if.then113
  %call121 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([33 x i8], [33 x i8]* @.str.3, i32 0, i32 0), i8* getelementptr inbounds ([23 x i8], [23 x i8]* @.str.1, i32 0, i32 0), i32 302)
  call void @perror(i8* getelementptr inbounds ([1 x i8], [1 x i8]* @.str.2, i32 0, i32 0))
  call void @exit(i32 1) #5
  unreachable

if.end122:                                        ; preds = %if.then113
  store i32 0, i32* %index123, align 4
  br label %for.cond124

for.cond124:                                      ; preds = %for.inc131, %if.end122
  %87 = load i32, i32* %index123, align 4
  %88 = load i32, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
  %cmp125 = icmp ult i32 %87, %88
  br i1 %cmp125, label %for.body127, label %for.end133

for.body127:                                      ; preds = %for.cond124
  %89 = load double*, double** %PVALUES.addr, align 4
  %90 = load i32*, i32** %o114, align 4
  %91 = load i32, i32* %index123, align 4
  %arrayidx128 = getelementptr inbounds i32, i32* %90, i32 %91
  %92 = load i32, i32* %arrayidx128, align 4
  %arrayidx129 = getelementptr inbounds double, double* %89, i32 %92
  %93 = load double, double* %arrayidx129, align 8
  %94 = load double*, double** %p, align 4
  %95 = load i32, i32* %index123, align 4
  %arrayidx130 = getelementptr inbounds double, double* %94, i32 %95
  store double %93, double* %arrayidx130, align 8
  br label %for.inc131

for.inc131:                                       ; preds = %for.body127
  %96 = load i32, i32* %index123, align 4
  %inc132 = add i32 %96, 1
  store i32 %inc132, i32* %index123, align 4
  br label %for.cond124

for.end133:                                       ; preds = %for.cond124
  %97 = load i32*, i32** %o114, align 4
  %98 = load i32, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
  %call135 = call double* @uint2double(i32* %97, i32 %98)
  store double* %call135, double** %o2double134, align 4
  %99 = load i32*, i32** %o114, align 4
  %100 = bitcast i32* %99 to i8*
  call void @free(i8* %100)
  store i32* null, i32** %o114, align 4
  %101 = load double*, double** %o2double134, align 4
  %102 = load i32, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
  %call137 = call i32* @order(double* %101, i32 %102, i1 zeroext false)
  store i32* %call137, i32** %ro136, align 4
  %103 = load double*, double** %o2double134, align 4
  %104 = bitcast double* %103 to i8*
  call void @free(i8* %104)
  store double* null, double** %o2double134, align 4
  %105 = load i32, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
  %mul138 = mul i32 8, %105
  %call139 = call noalias i8* @malloc(i32 %mul138)
  %106 = bitcast i8* %call139 to double*
  store double* %106, double** %q, align 4
  %107 = load double*, double** %q, align 4
  %cmp140 = icmp eq double* %107, null
  br i1 %cmp140, label %if.then142, label %if.end144

if.then142:                                       ; preds = %for.end133
  %call143 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([33 x i8], [33 x i8]* @.str.3, i32 0, i32 0), i8* getelementptr inbounds ([23 x i8], [23 x i8]* @.str.1, i32 0, i32 0), i32 318)
  call void @perror(i8* getelementptr inbounds ([1 x i8], [1 x i8]* @.str.2, i32 0, i32 0))
  call void @exit(i32 1) #5
  unreachable

if.end144:                                        ; preds = %for.end133
  %108 = load i32, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
  %mul145 = mul i32 8, %108
  %call146 = call noalias i8* @malloc(i32 %mul145)
  %109 = bitcast i8* %call146 to double*
  store double* %109, double** %pa, align 4
  %110 = load double*, double** %pa, align 4
  %cmp147 = icmp eq double* %110, null
  br i1 %cmp147, label %if.then149, label %if.end151

if.then149:                                       ; preds = %if.end144
  %call150 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([33 x i8], [33 x i8]* @.str.3, i32 0, i32 0), i8* getelementptr inbounds ([23 x i8], [23 x i8]* @.str.1, i32 0, i32 0), i32 324)
  call void @perror(i8* getelementptr inbounds ([1 x i8], [1 x i8]* @.str.2, i32 0, i32 0))
  call void @exit(i32 1) #5
  unreachable

if.end151:                                        ; preds = %if.end144
  %111 = load i32, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
  %conv152 = uitofp i32 %111 to double
  %112 = load double*, double** %p, align 4
  %arrayidx153 = getelementptr inbounds double, double* %112, i32 0
  %113 = load double, double* %arrayidx153, align 8
  %mul154 = fmul double %conv152, %113
  store double %mul154, double* %min, align 8
  store i32 1, i32* %index155, align 4
  br label %for.cond156

for.cond156:                                      ; preds = %for.inc168, %if.end151
  %114 = load i32, i32* %index155, align 4
  %115 = load i32, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
  %cmp157 = icmp ult i32 %114, %115
  br i1 %cmp157, label %for.body159, label %for.end170

for.body159:                                      ; preds = %for.cond156
  %116 = load i32, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
  %conv160 = uitofp i32 %116 to double
  %117 = load double*, double** %p, align 4
  %118 = load i32, i32* %index155, align 4
  %arrayidx161 = getelementptr inbounds double, double* %117, i32 %118
  %119 = load double, double* %arrayidx161, align 8
  %mul162 = fmul double %conv160, %119
  %120 = load i32, i32* %index155, align 4
  %add = add i32 1, %120
  %conv163 = uitofp i32 %add to double
  %div = fdiv double %mul162, %conv163
  store double %div, double* %TEMP, align 8
  %121 = load double, double* %TEMP, align 8
  %122 = load double, double* %min, align 8
  %cmp164 = fcmp olt double %121, %122
  br i1 %cmp164, label %if.then166, label %if.end167

if.then166:                                       ; preds = %for.body159
  %123 = load double, double* %TEMP, align 8
  store double %123, double* %min, align 8
  br label %if.end167

if.end167:                                        ; preds = %if.then166, %for.body159
  br label %for.inc168

for.inc168:                                       ; preds = %if.end167
  %124 = load i32, i32* %index155, align 4
  %inc169 = add i32 %124, 1
  store i32 %inc169, i32* %index155, align 4
  br label %for.cond156

for.end170:                                       ; preds = %for.cond156
  store i32 0, i32* %index171, align 4
  br label %for.cond172

for.cond172:                                      ; preds = %for.inc178, %for.end170
  %125 = load i32, i32* %index171, align 4
  %126 = load i32, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
  %cmp173 = icmp ult i32 %125, %126
  br i1 %cmp173, label %for.body175, label %for.end180

for.body175:                                      ; preds = %for.cond172
  %127 = load double, double* %min, align 8
  %128 = load double*, double** %pa, align 4
  %129 = load i32, i32* %index171, align 4
  %arrayidx176 = getelementptr inbounds double, double* %128, i32 %129
  store double %127, double* %arrayidx176, align 8
  %130 = load double, double* %min, align 8
  %131 = load double*, double** %q, align 4
  %132 = load i32, i32* %index171, align 4
  %arrayidx177 = getelementptr inbounds double, double* %131, i32 %132
  store double %130, double* %arrayidx177, align 8
  br label %for.inc178

for.inc178:                                       ; preds = %for.body175
  %133 = load i32, i32* %index171, align 4
  %inc179 = add i32 %133, 1
  store i32 %inc179, i32* %index171, align 4
  br label %for.cond172

for.end180:                                       ; preds = %for.cond172
  %134 = load i32, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
  %sub181 = sub i32 %134, 1
  store i32 %sub181, i32* %j, align 4
  br label %for.cond182

for.cond182:                                      ; preds = %for.inc272, %for.end180
  %135 = load i32, i32* %j, align 4
  %cmp183 = icmp uge i32 %135, 2
  br i1 %cmp183, label %for.body185, label %for.end273

for.body185:                                      ; preds = %for.cond182
  %136 = load i32, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
  %137 = load i32, i32* %j, align 4
  %sub186 = sub i32 %136, %137
  %call187 = call i32* @seq_len(i32 0, i32 %sub186)
  store i32* %call187, i32** %ij, align 4
  %138 = load i32, i32* %j, align 4
  %sub188 = sub i32 %138, 1
  store i32 %sub188, i32* %I2_LENGTH, align 4
  %139 = load i32, i32* %I2_LENGTH, align 4
  %mul189 = mul i32 %139, 4
  %call190 = call noalias i8* @malloc(i32 %mul189)
  %140 = bitcast i8* %call190 to i32*
  store i32* %140, i32** %i2, align 4
  store i32 0, i32* %i, align 4
  br label %for.cond191

for.cond191:                                      ; preds = %for.inc200, %for.body185
  %141 = load i32, i32* %i, align 4
  %142 = load i32, i32* %I2_LENGTH, align 4
  %cmp192 = icmp ult i32 %141, %142
  br i1 %cmp192, label %for.body194, label %for.end202

for.body194:                                      ; preds = %for.cond191
  %143 = load i32, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
  %144 = load i32, i32* %j, align 4
  %sub195 = sub i32 %143, %144
  %add196 = add i32 %sub195, 2
  %145 = load i32, i32* %i, align 4
  %add197 = add i32 %add196, %145
  %sub198 = sub i32 %add197, 1
  %146 = load i32*, i32** %i2, align 4
  %147 = load i32, i32* %i, align 4
  %arrayidx199 = getelementptr inbounds i32, i32* %146, i32 %147
  store i32 %sub198, i32* %arrayidx199, align 4
  br label %for.inc200

for.inc200:                                       ; preds = %for.body194
  %148 = load i32, i32* %i, align 4
  %inc201 = add i32 %148, 1
  store i32 %inc201, i32* %i, align 4
  br label %for.cond191

for.end202:                                       ; preds = %for.cond191
  %149 = load i32, i32* %j, align 4
  %conv203 = uitofp i32 %149 to double
  %150 = load double*, double** %p, align 4
  %151 = load i32*, i32** %i2, align 4
  %arrayidx204 = getelementptr inbounds i32, i32* %151, i32 0
  %152 = load i32, i32* %arrayidx204, align 4
  %arrayidx205 = getelementptr inbounds double, double* %150, i32 %152
  %153 = load double, double* %arrayidx205, align 8
  %mul206 = fmul double %conv203, %153
  %div207 = fdiv double %mul206, 2.000000e+00
  store double %div207, double* %q1, align 8
  store i32 1, i32* %i208, align 4
  br label %for.cond209

for.cond209:                                      ; preds = %for.inc224, %for.end202
  %154 = load i32, i32* %i208, align 4
  %155 = load i32, i32* %I2_LENGTH, align 4
  %cmp210 = icmp ult i32 %154, %155
  br i1 %cmp210, label %for.body212, label %for.end226

for.body212:                                      ; preds = %for.cond209
  %156 = load i32, i32* %j, align 4
  %conv213 = uitofp i32 %156 to double
  %157 = load double*, double** %p, align 4
  %158 = load i32*, i32** %i2, align 4
  %159 = load i32, i32* %i208, align 4
  %arrayidx214 = getelementptr inbounds i32, i32* %158, i32 %159
  %160 = load i32, i32* %arrayidx214, align 4
  %arrayidx215 = getelementptr inbounds double, double* %157, i32 %160
  %161 = load double, double* %arrayidx215, align 8
  %mul216 = fmul double %conv213, %161
  %162 = load i32, i32* %i208, align 4
  %add217 = add i32 2, %162
  %conv218 = uitofp i32 %add217 to double
  %div219 = fdiv double %mul216, %conv218
  store double %div219, double* %TEMP_Q1, align 8
  %163 = load double, double* %TEMP_Q1, align 8
  %164 = load double, double* %q1, align 8
  %cmp220 = fcmp olt double %163, %164
  br i1 %cmp220, label %if.then222, label %if.end223

if.then222:                                       ; preds = %for.body212
  %165 = load double, double* %TEMP_Q1, align 8
  store double %165, double* %q1, align 8
  br label %if.end223

if.end223:                                        ; preds = %if.then222, %for.body212
  br label %for.inc224

for.inc224:                                       ; preds = %if.end223
  %166 = load i32, i32* %i208, align 4
  %inc225 = add i32 %166, 1
  store i32 %inc225, i32* %i208, align 4
  br label %for.cond209

for.end226:                                       ; preds = %for.cond209
  store i32 0, i32* %i227, align 4
  br label %for.cond228

for.cond228:                                      ; preds = %for.inc241, %for.end226
  %167 = load i32, i32* %i227, align 4
  %168 = load i32, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
  %169 = load i32, i32* %j, align 4
  %sub229 = sub i32 %168, %169
  %add230 = add i32 %sub229, 1
  %cmp231 = icmp ult i32 %167, %add230
  br i1 %cmp231, label %for.body233, label %for.end243

for.body233:                                      ; preds = %for.cond228
  %170 = load i32, i32* %j, align 4
  %conv234 = uitofp i32 %170 to double
  %171 = load double*, double** %p, align 4
  %172 = load i32*, i32** %ij, align 4
  %173 = load i32, i32* %i227, align 4
  %arrayidx235 = getelementptr inbounds i32, i32* %172, i32 %173
  %174 = load i32, i32* %arrayidx235, align 4
  %arrayidx236 = getelementptr inbounds double, double* %171, i32 %174
  %175 = load double, double* %arrayidx236, align 8
  %mul237 = fmul double %conv234, %175
  %176 = load double, double* %q1, align 8
  %call238 = call double @min2(double %mul237, double %176)
  %177 = load double*, double** %q, align 4
  %178 = load i32*, i32** %ij, align 4
  %179 = load i32, i32* %i227, align 4
  %arrayidx239 = getelementptr inbounds i32, i32* %178, i32 %179
  %180 = load i32, i32* %arrayidx239, align 4
  %arrayidx240 = getelementptr inbounds double, double* %177, i32 %180
  store double %call238, double* %arrayidx240, align 8
  br label %for.inc241

for.inc241:                                       ; preds = %for.body233
  %181 = load i32, i32* %i227, align 4
  %inc242 = add i32 %181, 1
  store i32 %inc242, i32* %i227, align 4
  br label %for.cond228

for.end243:                                       ; preds = %for.cond228
  %182 = load i32*, i32** %ij, align 4
  %183 = bitcast i32* %182 to i8*
  call void @free(i8* %183)
  store i32* null, i32** %ij, align 4
  store i32 0, i32* %i244, align 4
  br label %for.cond245

for.cond245:                                      ; preds = %for.inc253, %for.end243
  %184 = load i32, i32* %i244, align 4
  %185 = load i32, i32* %I2_LENGTH, align 4
  %cmp246 = icmp ult i32 %184, %185
  br i1 %cmp246, label %for.body248, label %for.end255

for.body248:                                      ; preds = %for.cond245
  %186 = load double*, double** %q, align 4
  %187 = load i32, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
  %188 = load i32, i32* %j, align 4
  %sub249 = sub i32 %187, %188
  %arrayidx250 = getelementptr inbounds double, double* %186, i32 %sub249
  %189 = load double, double* %arrayidx250, align 8
  %190 = load double*, double** %q, align 4
  %191 = load i32*, i32** %i2, align 4
  %192 = load i32, i32* %i244, align 4
  %arrayidx251 = getelementptr inbounds i32, i32* %191, i32 %192
  %193 = load i32, i32* %arrayidx251, align 4
  %arrayidx252 = getelementptr inbounds double, double* %190, i32 %193
  store double %189, double* %arrayidx252, align 8
  br label %for.inc253

for.inc253:                                       ; preds = %for.body248
  %194 = load i32, i32* %i244, align 4
  %inc254 = add i32 %194, 1
  store i32 %inc254, i32* %i244, align 4
  br label %for.cond245

for.end255:                                       ; preds = %for.cond245
  %195 = load i32*, i32** %i2, align 4
  %196 = bitcast i32* %195 to i8*
  call void @free(i8* %196)
  store i32* null, i32** %i2, align 4
  store i32 0, i32* %i256, align 4
  br label %for.cond257

for.cond257:                                      ; preds = %for.inc269, %for.end255
  %197 = load i32, i32* %i256, align 4
  %198 = load i32, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
  %cmp258 = icmp ult i32 %197, %198
  br i1 %cmp258, label %for.body260, label %for.end271

for.body260:                                      ; preds = %for.cond257
  %199 = load double*, double** %pa, align 4
  %200 = load i32, i32* %i256, align 4
  %arrayidx261 = getelementptr inbounds double, double* %199, i32 %200
  %201 = load double, double* %arrayidx261, align 8
  %202 = load double*, double** %q, align 4
  %203 = load i32, i32* %i256, align 4
  %arrayidx262 = getelementptr inbounds double, double* %202, i32 %203
  %204 = load double, double* %arrayidx262, align 8
  %cmp263 = fcmp olt double %201, %204
  br i1 %cmp263, label %if.then265, label %if.end268

if.then265:                                       ; preds = %for.body260
  %205 = load double*, double** %q, align 4
  %206 = load i32, i32* %i256, align 4
  %arrayidx266 = getelementptr inbounds double, double* %205, i32 %206
  %207 = load double, double* %arrayidx266, align 8
  %208 = load double*, double** %pa, align 4
  %209 = load i32, i32* %i256, align 4
  %arrayidx267 = getelementptr inbounds double, double* %208, i32 %209
  store double %207, double* %arrayidx267, align 8
  br label %if.end268

if.end268:                                        ; preds = %if.then265, %for.body260
  br label %for.inc269

for.inc269:                                       ; preds = %if.end268
  %210 = load i32, i32* %i256, align 4
  %inc270 = add i32 %210, 1
  store i32 %inc270, i32* %i256, align 4
  br label %for.cond257

for.end271:                                       ; preds = %for.cond257
  br label %for.inc272

for.inc272:                                       ; preds = %for.end271
  %211 = load i32, i32* %j, align 4
  %dec = add i32 %211, -1
  store i32 %dec, i32* %j, align 4
  br label %for.cond182

for.end273:                                       ; preds = %for.cond182
  %212 = load double*, double** %p, align 4
  %213 = bitcast double* %212 to i8*
  call void @free(i8* %213)
  store double* null, double** %p, align 4
  store i32 0, i32* %index274, align 4
  br label %for.cond275

for.cond275:                                      ; preds = %for.inc282, %for.end273
  %214 = load i32, i32* %index274, align 4
  %215 = load i32, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
  %cmp276 = icmp ult i32 %214, %215
  br i1 %cmp276, label %for.body278, label %for.end284

for.body278:                                      ; preds = %for.cond275
  %216 = load double*, double** %pa, align 4
  %217 = load i32*, i32** %ro136, align 4
  %218 = load i32, i32* %index274, align 4
  %arrayidx279 = getelementptr inbounds i32, i32* %217, i32 %218
  %219 = load i32, i32* %arrayidx279, align 4
  %arrayidx280 = getelementptr inbounds double, double* %216, i32 %219
  %220 = load double, double* %arrayidx280, align 8
  %221 = load double*, double** %q, align 4
  %222 = load i32, i32* %index274, align 4
  %arrayidx281 = getelementptr inbounds double, double* %221, i32 %222
  store double %220, double* %arrayidx281, align 8
  br label %for.inc282

for.inc282:                                       ; preds = %for.body278
  %223 = load i32, i32* %index274, align 4
  %inc283 = add i32 %223, 1
  store i32 %inc283, i32* %index274, align 4
  br label %for.cond275

for.end284:                                       ; preds = %for.cond275
  %224 = load i32*, i32** %ro136, align 4
  %225 = bitcast i32* %224 to i8*
  call void @free(i8* %225)
  store i32* null, i32** %ro136, align 4
  %226 = load double*, double** %pa, align 4
  %227 = bitcast double* %226 to i8*
  call void @free(i8* %227)
  store double* null, double** %pa, align 4
  %228 = load double*, double** %q, align 4
  store double* %228, double** %retval, align 4
  br label %return

if.end285:                                        ; preds = %if.else109
  br label %if.end286

if.end286:                                        ; preds = %if.end285
  br label %if.end287

if.end287:                                        ; preds = %if.end286
  %229 = load double*, double** %PVALUES.addr, align 4
  %230 = load i32, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
  %call289 = call i32* @order(double* %229, i32 %230, i1 zeroext true)
  store i32* %call289, i32** %o288, align 4
  %231 = load i32*, i32** %o288, align 4
  %cmp290 = icmp eq i32* %231, null
  br i1 %cmp290, label %if.then292, label %if.end294

if.then292:                                       ; preds = %if.end287
  %call293 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([33 x i8], [33 x i8]* @.str.3, i32 0, i32 0), i8* getelementptr inbounds ([23 x i8], [23 x i8]* @.str.1, i32 0, i32 0), i32 398)
  call void @perror(i8* getelementptr inbounds ([1 x i8], [1 x i8]* @.str.2, i32 0, i32 0))
  call void @exit(i32 1) #5
  unreachable

if.end294:                                        ; preds = %if.end287
  %232 = load i32*, i32** %o288, align 4
  %233 = load i32, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
  %call295 = call double* @uint2double(i32* %232, i32 %233)
  store double* %call295, double** %o_double, align 4
  store i32 0, i32* %index296, align 4
  br label %for.cond297

for.cond297:                                      ; preds = %for.inc312, %if.end294
  %234 = load i32, i32* %index296, align 4
  %235 = load i32, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
  %cmp298 = icmp ult i32 %234, %235
  br i1 %cmp298, label %for.body300, label %for.end314

for.body300:                                      ; preds = %for.cond297
  %236 = load double*, double** %PVALUES.addr, align 4
  %237 = load i32, i32* %index296, align 4
  %arrayidx301 = getelementptr inbounds double, double* %236, i32 %237
  %238 = load double, double* %arrayidx301, align 8
  %cmp302 = fcmp olt double %238, 0.000000e+00
  br i1 %cmp302, label %if.then307, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %for.body300
  %239 = load double*, double** %PVALUES.addr, align 4
  %240 = load i32, i32* %index296, align 4
  %arrayidx304 = getelementptr inbounds double, double* %239, i32 %240
  %241 = load double, double* %arrayidx304, align 8
  %cmp305 = fcmp ogt double %241, 1.000000e+00
  br i1 %cmp305, label %if.then307, label %if.end311

if.then307:                                       ; preds = %lor.lhs.false, %for.body300
  %242 = load i32, i32* %index296, align 4
  %243 = load double*, double** %PVALUES.addr, align 4
  %244 = load i32, i32* %index296, align 4
  %arrayidx308 = getelementptr inbounds double, double* %243, i32 %244
  %245 = load double, double* %arrayidx308, align 8
  %call309 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([54 x i8], [54 x i8]* @.str.24, i32 0, i32 0), i32 %242, double %245)
  %call310 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([20 x i8], [20 x i8]* @.str.25, i32 0, i32 0), i8* getelementptr inbounds ([23 x i8], [23 x i8]* @.str.1, i32 0, i32 0), i32 406)
  call void @exit(i32 1) #5
  unreachable

if.end311:                                        ; preds = %lor.lhs.false
  br label %for.inc312

for.inc312:                                       ; preds = %if.end311
  %246 = load i32, i32* %index296, align 4
  %inc313 = add i32 %246, 1
  store i32 %inc313, i32* %index296, align 4
  br label %for.cond297

for.end314:                                       ; preds = %for.cond297
  %247 = load double*, double** %o_double, align 4
  %248 = load i32, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
  %call316 = call i32* @order(double* %247, i32 %248, i1 zeroext false)
  store i32* %call316, i32** %ro315, align 4
  %249 = load i32*, i32** %ro315, align 4
  %cmp317 = icmp eq i32* %249, null
  br i1 %cmp317, label %if.then319, label %if.end321

if.then319:                                       ; preds = %for.end314
  %call320 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([33 x i8], [33 x i8]* @.str.3, i32 0, i32 0), i8* getelementptr inbounds ([23 x i8], [23 x i8]* @.str.1, i32 0, i32 0), i32 413)
  call void @perror(i8* getelementptr inbounds ([1 x i8], [1 x i8]* @.str.2, i32 0, i32 0))
  call void @exit(i32 1) #5
  unreachable

if.end321:                                        ; preds = %for.end314
  %250 = load double*, double** %o_double, align 4
  %251 = bitcast double* %250 to i8*
  call void @free(i8* %251)
  store double* null, double** %o_double, align 4
  %252 = load i32, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
  %mul322 = mul i32 8, %252
  %call323 = call noalias i8* @malloc(i32 %mul322)
  %253 = bitcast i8* %call323 to double*
  store double* %253, double** %cummin_input, align 4
  %254 = load i16, i16* %TYPE, align 2
  %conv324 = sext i16 %254 to i32
  %cmp325 = icmp eq i32 %conv324, 0
  br i1 %cmp325, label %if.then327, label %if.else344

if.then327:                                       ; preds = %if.end321
  store i32 0, i32* %index328, align 4
  br label %for.cond329

for.cond329:                                      ; preds = %for.inc341, %if.then327
  %255 = load i32, i32* %index328, align 4
  %256 = load i32, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
  %cmp330 = icmp ult i32 %255, %256
  br i1 %cmp330, label %for.body332, label %for.end343

for.body332:                                      ; preds = %for.cond329
  %257 = load i32, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
  %conv333 = uitofp i32 %257 to double
  %258 = load i32, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
  %259 = load i32, i32* %index328, align 4
  %sub334 = sub i32 %258, %259
  %conv335 = uitofp i32 %sub334 to double
  %div336 = fdiv double %conv333, %conv335
  store double %div336, double* %NI, align 8
  %260 = load double, double* %NI, align 8
  %261 = load double*, double** %PVALUES.addr, align 4
  %262 = load i32*, i32** %o288, align 4
  %263 = load i32, i32* %index328, align 4
  %arrayidx337 = getelementptr inbounds i32, i32* %262, i32 %263
  %264 = load i32, i32* %arrayidx337, align 4
  %arrayidx338 = getelementptr inbounds double, double* %261, i32 %264
  %265 = load double, double* %arrayidx338, align 8
  %mul339 = fmul double %260, %265
  %266 = load double*, double** %cummin_input, align 4
  %267 = load i32, i32* %index328, align 4
  %arrayidx340 = getelementptr inbounds double, double* %266, i32 %267
  store double %mul339, double* %arrayidx340, align 8
  br label %for.inc341

for.inc341:                                       ; preds = %for.body332
  %268 = load i32, i32* %index328, align 4
  %inc342 = add i32 %268, 1
  store i32 %inc342, i32* %index328, align 4
  br label %for.cond329

for.end343:                                       ; preds = %for.cond329
  br label %if.end401

if.else344:                                       ; preds = %if.end321
  %269 = load i16, i16* %TYPE, align 2
  %conv345 = sext i16 %269 to i32
  %cmp346 = icmp eq i32 %conv345, 1
  br i1 %cmp346, label %if.then348, label %if.else380

if.then348:                                       ; preds = %if.else344
  store double 1.000000e+00, double* %q349, align 8
  store i32 2, i32* %index350, align 4
  br label %for.cond351

for.cond351:                                      ; preds = %for.inc359, %if.then348
  %270 = load i32, i32* %index350, align 4
  %271 = load i32, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
  %add352 = add i32 1, %271
  %cmp353 = icmp ult i32 %270, %add352
  br i1 %cmp353, label %for.body355, label %for.end361

for.body355:                                      ; preds = %for.cond351
  %272 = load i32, i32* %index350, align 4
  %conv356 = uitofp i32 %272 to double
  %div357 = fdiv double 1.000000e+00, %conv356
  %273 = load double, double* %q349, align 8
  %add358 = fadd double %273, %div357
  store double %add358, double* %q349, align 8
  br label %for.inc359

for.inc359:                                       ; preds = %for.body355
  %274 = load i32, i32* %index350, align 4
  %inc360 = add i32 %274, 1
  store i32 %inc360, i32* %index350, align 4
  br label %for.cond351

for.end361:                                       ; preds = %for.cond351
  store i32 0, i32* %index362, align 4
  br label %for.cond363

for.cond363:                                      ; preds = %for.inc377, %for.end361
  %275 = load i32, i32* %index362, align 4
  %276 = load i32, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
  %cmp364 = icmp ult i32 %275, %276
  br i1 %cmp364, label %for.body366, label %for.end379

for.body366:                                      ; preds = %for.cond363
  %277 = load i32, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
  %conv368 = uitofp i32 %277 to double
  %278 = load i32, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
  %279 = load i32, i32* %index362, align 4
  %sub369 = sub i32 %278, %279
  %conv370 = uitofp i32 %sub369 to double
  %div371 = fdiv double %conv368, %conv370
  store double %div371, double* %NI367, align 8
  %280 = load double, double* %q349, align 8
  %281 = load double, double* %NI367, align 8
  %mul372 = fmul double %280, %281
  %282 = load double*, double** %PVALUES.addr, align 4
  %283 = load i32*, i32** %o288, align 4
  %284 = load i32, i32* %index362, align 4
  %arrayidx373 = getelementptr inbounds i32, i32* %283, i32 %284
  %285 = load i32, i32* %arrayidx373, align 4
  %arrayidx374 = getelementptr inbounds double, double* %282, i32 %285
  %286 = load double, double* %arrayidx374, align 8
  %mul375 = fmul double %mul372, %286
  %287 = load double*, double** %cummin_input, align 4
  %288 = load i32, i32* %index362, align 4
  %arrayidx376 = getelementptr inbounds double, double* %287, i32 %288
  store double %mul375, double* %arrayidx376, align 8
  br label %for.inc377

for.inc377:                                       ; preds = %for.body366
  %289 = load i32, i32* %index362, align 4
  %inc378 = add i32 %289, 1
  store i32 %inc378, i32* %index362, align 4
  br label %for.cond363

for.end379:                                       ; preds = %for.cond363
  br label %if.end400

if.else380:                                       ; preds = %if.else344
  %290 = load i16, i16* %TYPE, align 2
  %conv381 = sext i16 %290 to i32
  %cmp382 = icmp eq i32 %conv381, 3
  br i1 %cmp382, label %if.then384, label %if.end399

if.then384:                                       ; preds = %if.else380
  store i32 0, i32* %index385, align 4
  br label %for.cond386

for.cond386:                                      ; preds = %for.inc396, %if.then384
  %291 = load i32, i32* %index385, align 4
  %292 = load i32, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
  %cmp387 = icmp ult i32 %291, %292
  br i1 %cmp387, label %for.body389, label %for.end398

for.body389:                                      ; preds = %for.cond386
  %293 = load i32, i32* %index385, align 4
  %add390 = add i32 %293, 1
  %conv391 = uitofp i32 %add390 to double
  %294 = load double*, double** %PVALUES.addr, align 4
  %295 = load i32*, i32** %o288, align 4
  %296 = load i32, i32* %index385, align 4
  %arrayidx392 = getelementptr inbounds i32, i32* %295, i32 %296
  %297 = load i32, i32* %arrayidx392, align 4
  %arrayidx393 = getelementptr inbounds double, double* %294, i32 %297
  %298 = load double, double* %arrayidx393, align 8
  %mul394 = fmul double %conv391, %298
  %299 = load double*, double** %cummin_input, align 4
  %300 = load i32, i32* %index385, align 4
  %arrayidx395 = getelementptr inbounds double, double* %299, i32 %300
  store double %mul394, double* %arrayidx395, align 8
  br label %for.inc396

for.inc396:                                       ; preds = %for.body389
  %301 = load i32, i32* %index385, align 4
  %inc397 = add i32 %301, 1
  store i32 %inc397, i32* %index385, align 4
  br label %for.cond386

for.end398:                                       ; preds = %for.cond386
  br label %if.end399

if.end399:                                        ; preds = %for.end398, %if.else380
  br label %if.end400

if.end400:                                        ; preds = %if.end399, %for.end379
  br label %if.end401

if.end401:                                        ; preds = %if.end400, %for.end343
  %302 = load i32*, i32** %o288, align 4
  %303 = bitcast i32* %302 to i8*
  call void @free(i8* %303)
  store i32* null, i32** %o288, align 4
  store double* null, double** %cummin_array, align 4
  %304 = load double*, double** %cummin_input, align 4
  %305 = load i32, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
  %call402 = call double* @cummin(double* %304, i32 %305)
  store double* %call402, double** %cummin_array, align 4
  %306 = load double*, double** %cummin_input, align 4
  %307 = bitcast double* %306 to i8*
  call void @free(i8* %307)
  store double* null, double** %cummin_input, align 4
  %308 = load double*, double** %cummin_array, align 4
  %309 = load i32, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
  %call404 = call double* @pminx(double* %308, i32 %309, double 1.000000e+00)
  store double* %call404, double** %pmin403, align 4
  %310 = load double*, double** %cummin_array, align 4
  %311 = bitcast double* %310 to i8*
  call void @free(i8* %311)
  store double* null, double** %cummin_array, align 4
  %312 = load i32, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
  %mul405 = mul i32 %312, 8
  %call406 = call noalias i8* @malloc(i32 %mul405)
  %313 = bitcast i8* %call406 to double*
  store double* %313, double** %q_array, align 4
  store i32 0, i32* %index407, align 4
  br label %for.cond408

for.cond408:                                      ; preds = %for.inc415, %if.end401
  %314 = load i32, i32* %index407, align 4
  %315 = load i32, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
  %cmp409 = icmp ult i32 %314, %315
  br i1 %cmp409, label %for.body411, label %for.end417

for.body411:                                      ; preds = %for.cond408
  %316 = load double*, double** %pmin403, align 4
  %317 = load i32*, i32** %ro315, align 4
  %318 = load i32, i32* %index407, align 4
  %arrayidx412 = getelementptr inbounds i32, i32* %317, i32 %318
  %319 = load i32, i32* %arrayidx412, align 4
  %arrayidx413 = getelementptr inbounds double, double* %316, i32 %319
  %320 = load double, double* %arrayidx413, align 8
  %321 = load double*, double** %q_array, align 4
  %322 = load i32, i32* %index407, align 4
  %arrayidx414 = getelementptr inbounds double, double* %321, i32 %322
  store double %320, double* %arrayidx414, align 8
  br label %for.inc415

for.inc415:                                       ; preds = %for.body411
  %323 = load i32, i32* %index407, align 4
  %inc416 = add i32 %323, 1
  store i32 %inc416, i32* %index407, align 4
  br label %for.cond408

for.end417:                                       ; preds = %for.cond408
  %324 = load i32*, i32** %ro315, align 4
  %325 = bitcast i32* %324 to i8*
  call void @free(i8* %325)
  store i32* null, i32** %ro315, align 4
  %326 = load double*, double** %pmin403, align 4
  %327 = bitcast double* %326 to i8*
  call void @free(i8* %327)
  store double* null, double** %pmin403, align 4
  %328 = load double*, double** %q_array, align 4
  store double* %328, double** %retval, align 4
  br label %return

return:                                           ; preds = %for.end417, %for.end284, %for.end108, %for.end
  %329 = load double*, double** %retval, align 4
  ret double* %329
}

declare i32 @strcasecmp(i8* %0, i8* %1) #1

; Function Attrs: noinline nounwind optnone
define hidden i32 @main() #0 {
entry:
  %retval = alloca i32, align 4
  %PVALUES = alloca [50 x double], align 16
  %CORRECT_ANSWERS = alloca [6 x [50 x double]], align 16
  %TYPES = alloca [6 x i8*], align 16
  %type = alloca i16, align 2
  %q = alloca double*, align 4
  %error = alloca double, align 8
  %i = alloca i32, align 4
  %this_error = alloca double, align 8
  store i32 0, i32* %retval, align 4
  %0 = bitcast [50 x double]* %PVALUES to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 16 %0, i8* align 16 bitcast ([50 x double]* @__const.main.PVALUES to i8*), i32 400, i1 false)
  %1 = bitcast [6 x [50 x double]]* %CORRECT_ANSWERS to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 16 %1, i8* align 16 bitcast ([6 x [50 x double]]* @__const.main.CORRECT_ANSWERS to i8*), i32 2400, i1 false)
  %2 = bitcast [6 x i8*]* %TYPES to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 16 %2, i8* align 16 bitcast ([6 x i8*]* @__const.main.TYPES to i8*), i32 24, i1 false)
  store i16 0, i16* %type, align 2
  br label %for.cond

for.cond:                                         ; preds = %for.inc19, %entry
  %3 = load i16, i16* %type, align 2
  %conv = zext i16 %3 to i32
  %cmp = icmp sle i32 %conv, 5
  br i1 %cmp, label %for.body, label %for.end21

for.body:                                         ; preds = %for.cond
  %arraydecay = getelementptr inbounds [50 x double], [50 x double]* %PVALUES, i32 0, i32 0
  %4 = load i16, i16* %type, align 2
  %idxprom = zext i16 %4 to i32
  %arrayidx = getelementptr inbounds [6 x i8*], [6 x i8*]* %TYPES, i32 0, i32 %idxprom
  %5 = load i8*, i8** %arrayidx, align 4
  %call = call double* @p_adjust(double* %arraydecay, i32 50, i8* %5)
  store double* %call, double** %q, align 4
  %6 = load double*, double** %q, align 4
  %arrayidx2 = getelementptr inbounds double, double* %6, i32 0
  %7 = load double, double* %arrayidx2, align 8
  %8 = load i16, i16* %type, align 2
  %idxprom3 = zext i16 %8 to i32
  %arrayidx4 = getelementptr inbounds [6 x [50 x double]], [6 x [50 x double]]* %CORRECT_ANSWERS, i32 0, i32 %idxprom3
  %arrayidx5 = getelementptr inbounds [50 x double], [50 x double]* %arrayidx4, i32 0, i32 0
  %9 = load double, double* %arrayidx5, align 16
  %sub = fsub double %7, %9
  %10 = call double @llvm.fabs.f64(double %sub)
  store double %10, double* %error, align 8
  store i32 1, i32* %i, align 4
  br label %for.cond6

for.cond6:                                        ; preds = %for.inc, %for.body
  %11 = load i32, i32* %i, align 4
  %cmp7 = icmp ult i32 %11, 50
  br i1 %cmp7, label %for.body9, label %for.end

for.body9:                                        ; preds = %for.cond6
  %12 = load double*, double** %q, align 4
  %13 = load i32, i32* %i, align 4
  %arrayidx10 = getelementptr inbounds double, double* %12, i32 %13
  %14 = load double, double* %arrayidx10, align 8
  %15 = load i16, i16* %type, align 2
  %idxprom11 = zext i16 %15 to i32
  %arrayidx12 = getelementptr inbounds [6 x [50 x double]], [6 x [50 x double]]* %CORRECT_ANSWERS, i32 0, i32 %idxprom11
  %16 = load i32, i32* %i, align 4
  %arrayidx13 = getelementptr inbounds [50 x double], [50 x double]* %arrayidx12, i32 0, i32 %16
  %17 = load double, double* %arrayidx13, align 8
  %sub14 = fsub double %14, %17
  %18 = call double @llvm.fabs.f64(double %sub14)
  store double %18, double* %this_error, align 8
  %19 = load double, double* %this_error, align 8
  %20 = load double, double* %error, align 8
  %add = fadd double %20, %19
  store double %add, double* %error, align 8
  br label %for.inc

for.inc:                                          ; preds = %for.body9
  %21 = load i32, i32* %i, align 4
  %inc = add i32 %21, 1
  store i32 %inc, i32* %i, align 4
  br label %for.cond6

for.end:                                          ; preds = %for.cond6
  %22 = load double*, double** %q, align 4
  call void @double_say(double* %22, i32 50)
  %23 = load double*, double** %q, align 4
  %24 = bitcast double* %23 to i8*
  call void @free(i8* %24)
  store double* null, double** %q, align 4
  %25 = load i16, i16* %type, align 2
  %conv15 = zext i16 %25 to i32
  %26 = load i16, i16* %type, align 2
  %idxprom16 = zext i16 %26 to i32
  %arrayidx17 = getelementptr inbounds [6 x i8*], [6 x i8*]* %TYPES, i32 0, i32 %idxprom16
  %27 = load i8*, i8** %arrayidx17, align 4
  %28 = load double, double* %error, align 8
  %call18 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([44 x i8], [44 x i8]* @.str.28, i32 0, i32 0), i32 %conv15, i8* %27, double %28)
  br label %for.inc19

for.inc19:                                        ; preds = %for.end
  %29 = load i16, i16* %type, align 2
  %inc20 = add i16 %29, 1
  store i16 %inc20, i16* %type, align 2
  br label %for.cond

for.end21:                                        ; preds = %for.cond
  ret i32 0
}

; Function Attrs: argmemonly nounwind willreturn
declare void @llvm.memcpy.p0i8.p0i8.i32(i8* noalias nocapture writeonly %0, i8* noalias nocapture readonly %1, i32 %2, i1 immarg %3) #3

; Function Attrs: nounwind readnone speculatable willreturn
declare double @llvm.fabs.f64(double %0) #4

attributes #0 = { noinline nounwind optnone "correctly-rounded-divide-sqrt-fp-math"="false" "disable-tail-calls"="false" "frame-pointer"="none" "less-precise-fpmad"="false" "min-legal-vector-width"="0" "no-infs-fp-math"="false" "no-jump-tables"="false" "no-nans-fp-math"="false" "no-signed-zeros-fp-math"="false" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="generic" "unsafe-fp-math"="false" "use-soft-float"="false" }
attributes #1 = { "correctly-rounded-divide-sqrt-fp-math"="false" "disable-tail-calls"="false" "frame-pointer"="none" "less-precise-fpmad"="false" "no-infs-fp-math"="false" "no-nans-fp-math"="false" "no-signed-zeros-fp-math"="false" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="generic" "unsafe-fp-math"="false" "use-soft-float"="false" }
attributes #2 = { noreturn "correctly-rounded-divide-sqrt-fp-math"="false" "disable-tail-calls"="false" "frame-pointer"="none" "less-precise-fpmad"="false" "no-infs-fp-math"="false" "no-nans-fp-math"="false" "no-signed-zeros-fp-math"="false" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="generic" "unsafe-fp-math"="false" "use-soft-float"="false" }
attributes #3 = { argmemonly nounwind willreturn }
attributes #4 = { nounwind readnone speculatable willreturn }
attributes #5 = { noreturn }

!llvm.module.flags = !{!0}
!llvm.ident = !{!1}

!0 = !{i32 1, !"wchar_size", i32 4}
!1 = !{!"clang version 11.0.0 (https://github.com/Jacarte/llvm-project.git 0f6dea67136cc1e0b3d200eb2bb165628970c44b)"}

; extracted candidates

; *****
; For LLVM instruction:
;  %2 = load i32, i32* %1, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %5 = load i32, i32* %4, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %7 = load i32, i32* %aa, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %10 = load i32, i32* %bb, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %cmp = fcmp olt double %8, %11
; Looking for a replacement for:
%0:i1 = var
infer %0

; *****
; For LLVM instruction:
;  %13 = load i32, i32* %aa, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %16 = load i32, i32* %bb, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %cmp4 = fcmp oeq double %14, %17
; Looking for a replacement for:
%0:i1 = var
infer %0

; *****
; For LLVM instruction:
;  %18 = load i32, i32* %retval, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0
#########################################################
; exiting Souper's runOnFunction() for ./P-value_correction.c.bc:compar_increase()

; entering Souper's runOnFunction() for cummin()

; ModuleID = './P-value_correction.c.bc'
source_filename = "./P-value_correction.c"
target datalayout = "e-m:e-p:32:32-i64:64-n32:64-S128"
target triple = "wasm32-unknown-wasi"

@.str = private unnamed_addr constant [29 x i8] c"malloc failed at %s line %u\0A\00", align 1
@.str.1 = private unnamed_addr constant [23 x i8] c"./P-value_correction.c\00", align 1
@.str.2 = private unnamed_addr constant [1 x i8] zeroinitializer, align 1
@base_arr = hidden global double* null, align 4
@.str.3 = private unnamed_addr constant [33 x i8] c"failed to malloc at %s line %u.\0A\00", align 1
@.str.4 = private unnamed_addr constant [48 x i8] c"cummin function requires at least one element.\0A\00", align 1
@.str.5 = private unnamed_addr constant [22 x i8] c"Failed at %s line %u\0A\00", align 1
@.str.6 = private unnamed_addr constant [41 x i8] c"function requires at least one element.\0A\00", align 1
@.str.7 = private unnamed_addr constant [37 x i8] c"pmin requires at least one element.\0A\00", align 1
@.str.8 = private unnamed_addr constant [7 x i8] c"[1] %e\00", align 1
@.str.9 = private unnamed_addr constant [7 x i8] c" %.10f\00", align 1
@.str.10 = private unnamed_addr constant [6 x i8] c"\0A[%u]\00", align 1
@.str.11 = private unnamed_addr constant [2 x i8] c"\0A\00", align 1
@.str.12 = private unnamed_addr constant [34 x i8] c"Failure to malloc at %s line %u.\0A\00", align 1
@.str.13 = private unnamed_addr constant [41 x i8] c"p_adjust requires at least one element.\0A\00", align 1
@.str.14 = private unnamed_addr constant [3 x i8] c"BH\00", align 1
@.str.15 = private unnamed_addr constant [4 x i8] c"fdr\00", align 1
@.str.16 = private unnamed_addr constant [3 x i8] c"by\00", align 1
@.str.17 = private unnamed_addr constant [11 x i8] c"Bonferroni\00", align 1
@.str.18 = private unnamed_addr constant [9 x i8] c"hochberg\00", align 1
@.str.19 = private unnamed_addr constant [5 x i8] c"holm\00", align 1
@.str.20 = private unnamed_addr constant [7 x i8] c"hommel\00", align 1
@.str.21 = private unnamed_addr constant [44 x i8] c"%s doesn't match any accepted FDR methods.\0A\00", align 1
@.str.22 = private unnamed_addr constant [42 x i8] c"%g is outside of the interval I planned.\0A\00", align 1
@.str.23 = private unnamed_addr constant [23 x i8] c"Failure at %s line %u\0A\00", align 1
@.str.24 = private unnamed_addr constant [54 x i8] c"array[%u] = %lf, which is outside the interval [0,1]\0A\00", align 1
@.str.25 = private unnamed_addr constant [20 x i8] c"died at %s line %u\0A\00", align 1
@__const.main.PVALUES = private unnamed_addr constant [50 x double] [double 0x3FDD04160F35FDE9, double 0x3FE758E721E2A8D7, double 0x3FB96FAC8B38D8BA, double 0x3FB73E71D5B04B37, double 0x3FC710AB48EE865B, double 0x3FEC01D953C3CC73, double 0x3FD2B3C4BE0A922A, double 0x3FED2B5A568DAB4F, double 0x3FDBE08D73F16964, double 0x3FE10A218C41C242, double 0x3FDF8810DB1996AA, double 0x3FE291CCB11E1A9D, double 0x3FD64E8C550D788F, double 7.883130e-01, double 0x3FD177B2BF048D2D, double 0x3FEB3543434BAF2B, double 0x3FDB50EAD41ED0A6, double 0x3FE49D4AFF01D33F, double 0x3FD364C9AE345B51, double 0x3FA99BA35F15394D, double 3.194810e-01, double 0x3FE941E405CE761A, double 0x3FEFF94F77369843, double 0x3FC65847BFB23217, double 0x3FECEB8879B6A543, double 0x3FBEAF00332BA677, double 0x3FD96207C7749E38, double 0x3F8CC02620502C93, double 0x3FE773A5B45A0F40, double 0x3FB1642C24762C01, double 4.040730e-03, double 0x3F33E11D79A90777, double 0x3F870B02BD749528, double 0x3F98521BD6A0353F, double 0x3F4310F26148FFAA, double 0x3F3427CD76006778, double 0x3F80E60AFB1F8A4E, double 0x3F5639B74A9E4DA2, double 0x3F8BDDF74195769F, double 0x3F38ABEE3BFA8581, double 0x3EF2E2E96B5466FE, double 0x3E90CE9F65B58A88, double 0x3FA0F2D097879B95, double 0x3F834EE7216A6684, double 0x3F4CCE8DBB40BD9D, double 0x3F2C8B969590F2ED, double 0x3F4FC31F7F1541AD, double 6.610250e-05, double 0x3F9DB44EA6AC26BA, double 5.735490e-03], align 16
@__const.main.CORRECT_ANSWERS = private unnamed_addr constant [6 x [50 x double]] [[50 x double] [double 0x3FE39AFA2199ADBC, double 8.521710e-01, double 0x3FC96FAC6045BAF5, double 0x3FC83660E51D25AB, double 0x3FD498068702BE20, double 0x3FEDC3BF727136A4, double 4.870370e-01, double 0x3FEDC3BF727136A4, double 0x3FE35BF08BEEB62C, double 0x3FE5D879DEE92F03, double 0x3FE4BE91D656B94A, double 0x3FE7363FC28DAEAA, double 0x3FE0E62C4F13638A, double 0x3FEC1052C8FAB035, double 0x3FDE1DD2E43E029A, double 0x3FED92EFFC7CBDC1, double 0x3FE35BF08BEEB62C, double 0x3FE923B90CFC67C5, double 0x3FDF47B8FC357024, double 0x3FBD1996A9FB10AD, double 0x3FDFF2B6D6C14255, double 0x3FEC1052C8FAB035, double 0x3FEFF94F77369843, double 0x3FD498068702BE20, double 0x3FEDC3BF727136A4, double 0x3FCD80E2E96EC403, double 0x3FE2A9F6A93F290B, double 0x3FA3F736D8AF2E2B, double 8.521710e-01, double 0x3FC2E751B350FAC4, double 0x3F913D8E55EE9F05, double 0x3F64FECB88BB3633, double 0x3FA2009A03CCBE34, double 0x3FB0001FB57CF9FC, double 0x3F6DCA7ADA5E274A, double 0x3F64FECB88BB3633, double 0x3F9E2D13B467D120, double 0x3F7941963399C6A1, double 0x3FA3F736D8AF2E2B, double 0x3F6607390CEF853C, double 0x3F3D828C80BA213A, double 0x3EEA42D90EEBA875, double 0x3FB42D4181AA8F8B, double 0x3FA01715F12E0018, double 0x3F73D9F3AF6D490C, double 0x3F64FECB88BB3633, double 0x3F73D9F3AF6D490C, double 0x3F520CE5F51A7C61, double 0x3FB290B112B20952, double 0x3F9696C95AA76B69], [50 x double] [double 1.000000e+00, double 1.000000e+00, double 0x3FEC9C56E33BA41B, double 0x3FEB3BF21E95ED3D, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 0x3FE05DA74553C727, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 0x3FC675198790829A, double 1.000000e+00, double 0x3FE54345648E1F12, double 0x3FB3645F501CA2F9, double 0x3F879D934E50F0DE, double 0x3FC43FC3646E3EA2, double 0x3FD1FF539D36064C, double 0x3F90C123206B855F, double 0x3F879D934E50F0DE, double 0x3FC0F8967F32E606, double 0x3F9C6880470D2FBE, double 0x3FC675198790829A, double 0x3F88C70105E47082, double 2.025930e-03, double 0x3F0D89DE4FA8F818, double 0x3FD6B1E2D11B1027, double 0x3FC219271872BD8D, double 0x3F96542FAD16CEF9, double 0x3F879D934E50F0DE, double 0x3F96542FAD16CEF9, double 0x3F744D9816EB319A, double 0x3FD4E1D5728DBC16, double 0x3FB9687C40426555], [50 x double] [double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 0x3FE6761DC93EA2D3, double 1.000000e+00, double 1.000000e+00, double 0x3FC9DC55000C953A, double 0x3F8F0FBD624BA499, double 0x3FE2009A24031487, double 1.000000e+00, double 0x3F9DCA7AB8020F7A, double 0x3F8F7E310860A1AB, double 0x3FDA677128614819, double 6.782670e-02, double 6.803480e-01, double 0x3F9346521EDBB84D, double 0x3F4D828CB7B3E0EE, double 0x3EEA42D90EEBA875, double 1.000000e+00, double 4.713920e-01, double 0x3FA6815EE53DB1E7, double 0x3F864D0CF90CC6B8, double 0x3FA8D0709B489B4F, double 0x3F6B1359791819D2, double 1.000000e+00, double 0x3FD25A836EB4E981], [50 x double] [double 0x3FEFF94F77369843, double 0x3FEFF94F77369843, double 0x3FEFF94F77369843, double 0x3FEFF94F77369843, double 0x3FEFF94F77369843, double 0x3FEFF94F77369843, double 0x3FEFF94F77369843, double 0x3FEFF94F77369843, double 0x3FEFF94F77369843, double 0x3FEFF94F77369843, double 0x3FEFF94F77369843, double 0x3FEFF94F77369843, double 0x3FEFF94F77369843, double 0x3FEFF94F77369843, double 0x3FEFF94F77369843, double 0x3FEFF94F77369843, double 0x3FEFF94F77369843, double 0x3FEFF94F77369843, double 0x3FEFF94F77369843, double 0x3FEFF94F77369843, double 0x3FEFF94F77369843, double 0x3FEFF94F77369843, double 0x3FEFF94F77369843, double 0x3FEFF94F77369843, double 0x3FEFF94F77369843, double 0x3FEFF94F77369843, double 0x3FEFF94F77369843, double 0x3FDDA6274695E687, double 0x3FEFF94F77369843, double 0x3FEFF94F77369843, double 0x3FC42BDC26DCE39B, double 0x3F8C57F9104CA951, double 0x3FD9340AC9879DEF, double 7.600230e-01, double 0x3F999EC5A86B439B, double 0x3F8C57F9104CA951, double 0x3FD389FCD90412B4, double 0x3FABC8251D45E10B, double 0x3FDD9BD68ABBB045, double 0x3F90F633F956C386, double 8.825610e-04, double 0x3EEA42D90EEBA875, double 0x3FEFC7471C1E43B8, double 0x3FD5B8C4014C305A, double 0x3FA2E78CEC8D068E, double 0x3F84F6832995A599, double 0x3FA459002162FC24, double 3.172920e-03, double 8.992520e-01, double 0x3FCBE5BD5E9AC00A], [50 x double] [double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 0x3FDDA6274695E687, double 1.000000e+00, double 1.000000e+00, double 0x3FC42BDC26DCE39B, double 0x3F8C939AFCF101E0, double 0x3FD9340AC9879DEF, double 7.600230e-01, double 0x3F999EC5A86B439B, double 0x3F8C939AFCF101E0, double 0x3FD389FCD90412B4, double 0x3FABC8251D45E10B, double 0x3FDD9BD68ABBB045, double 0x3F90F633F956C386, double 8.825610e-04, double 0x3EEA42D90EEBA875, double 0x3FEFC7471C1E43B8, double 0x3FD5B8C4014C305A, double 0x3FA2E78CEC8D068E, double 0x3F84F6832995A599, double 0x3FA459002162FC24, double 3.172920e-03, double 8.992520e-01, double 0x3FCBE5BD5E9AC00A], [50 x double] [double 0x3FEFF94F77369843, double 0x3FEFF94F77369843, double 0x3FEFF94F77369843, double 0x3FEFF5DC908F2EDD, double 0x3FEFF94F77369843, double 0x3FEFF94F77369843, double 0x3FEFF94F77369843, double 0x3FEFF94F77369843, double 0x3FEFF94F77369843, double 0x3FEFF94F77369843, double 0x3FEFF94F77369843, double 0x3FEFF94F77369843, double 0x3FEFF94F77369843, double 0x3FEFF94F77369843, double 0x3FEFF94F77369843, double 0x3FEFF94F77369843, double 0x3FEFF94F77369843, double 0x3FEFF94F77369843, double 0x3FEFF94F77369843, double 0x3FEEB45F17BD8BE7, double 0x3FEFF94F77369843, double 0x3FEFF94F77369843, double 0x3FEFF94F77369843, double 0x3FEFF94F77369843, double 0x3FEFF94F77369843, double 0x3FEFF94F77369843, double 0x3FEFF94F77369843, double 0x3FDBDA250F840182, double 0x3FEFF94F77369843, double 0x3FEF40BC1D52205E, double 0x3FC21A3BEB689947, double 1.304340e-02, double 0x3FD69916517B1CD7, double 0x3FE60A69453DF7B2, double 0x3F986DB666D9D3C6, double 0x3F8B157BBD3AB385, double 2.722920e-01, double 0x3FABC8251D45E10B, double 0x3FDAFF07B27BE8AF, double 0x3F9030D45E3B9F93, double 8.825610e-04, double 0x3EEA42D90EEBA875, double 0x3FEBFACC1948A662, double 0x3FD34EE6EDE042CB, double 0x3FA2011883DA6A9A, double 0x3F839FF779153716, double 0x3FA3D9F3D1C960DD, double 3.172920e-03, double 0x3FE9FDC4BC5D1301, double 0x3FC8F5FAC3801CF1]], align 16
@.str.26 = private unnamed_addr constant [3 x i8] c"bh\00", align 1
@.str.27 = private unnamed_addr constant [11 x i8] c"bonferroni\00", align 1
@__const.main.TYPES = private unnamed_addr constant [6 x i8*] [i8* getelementptr inbounds ([3 x i8], [3 x i8]* @.str.26, i32 0, i32 0), i8* getelementptr inbounds ([3 x i8], [3 x i8]* @.str.16, i32 0, i32 0), i8* getelementptr inbounds ([11 x i8], [11 x i8]* @.str.27, i32 0, i32 0), i8* getelementptr inbounds ([9 x i8], [9 x i8]* @.str.18, i32 0, i32 0), i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.19, i32 0, i32 0), i8* getelementptr inbounds ([7 x i8], [7 x i8]* @.str.20, i32 0, i32 0)], align 16
@.str.28 = private unnamed_addr constant [44 x i8] c"\0Atype %u = '%s' has cumulative error of %g\0A\00", align 1
@llvm.used = appending global [1 x i8*] [i8* bitcast (i32 ()* @__main_void to i8*)], section "llvm.metadata"

@__main_void = alias i32 (), i32 ()* @main

; Function Attrs: noinline nounwind optnone
define hidden i32* @seq_len(i32 %START, i32 %END) #0 {
entry:
  %retval = alloca i32*, align 4
  %START.addr = alloca i32, align 4
  %END.addr = alloca i32, align 4
  %start = alloca i32, align 4
  %end = alloca i32, align 4
  %sequence = alloca i32*, align 4
  %i = alloca i32, align 4
  %LENGTH = alloca i32, align 4
  %sequence10 = alloca i32*, align 4
  %index = alloca i32, align 4
  %index28 = alloca i32, align 4
  store i32 %START, i32* %START.addr, align 4
  store i32 %END, i32* %END.addr, align 4
  %0 = load i32, i32* %START.addr, align 4
  store i32 %0, i32* %start, align 4
  %1 = load i32, i32* %END.addr, align 4
  store i32 %1, i32* %end, align 4
  %2 = load i32, i32* %START.addr, align 4
  %3 = load i32, i32* %END.addr, align 4
  %cmp = icmp eq i32 %2, %3
  br i1 %cmp, label %if.then, label %if.end6

if.then:                                          ; preds = %entry
  %4 = load i32, i32* %end, align 4
  %add = add i32 %4, 1
  %mul = mul i32 %add, 4
  %call = call noalias i8* @malloc(i32 %mul)
  %5 = bitcast i8* %call to i32*
  store i32* %5, i32** %sequence, align 4
  %6 = load i32*, i32** %sequence, align 4
  %cmp1 = icmp eq i32* %6, null
  br i1 %cmp1, label %if.then2, label %if.end

if.then2:                                         ; preds = %if.then
  %call3 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([29 x i8], [29 x i8]* @.str, i32 0, i32 0), i8* getelementptr inbounds ([23 x i8], [23 x i8]* @.str.1, i32 0, i32 0), i32 15)
  call void @perror(i8* getelementptr inbounds ([1 x i8], [1 x i8]* @.str.2, i32 0, i32 0))
  call void @exit(i32 1) #5
  unreachable

if.end:                                           ; preds = %if.then
  store i32 0, i32* %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.end
  %7 = load i32, i32* %i, align 4
  %8 = load i32, i32* %end, align 4
  %cmp4 = icmp ult i32 %7, %8
  br i1 %cmp4, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %9 = load i32, i32* %i, align 4
  %add5 = add i32 %9, 1
  %10 = load i32*, i32** %sequence, align 4
  %11 = load i32, i32* %i, align 4
  %arrayidx = getelementptr inbounds i32, i32* %10, i32 %11
  store i32 %add5, i32* %arrayidx, align 4
  br label %for.inc

for.inc:                                          ; preds = %for.body
  %12 = load i32, i32* %i, align 4
  %inc = add i32 %12, 1
  store i32 %inc, i32* %i, align 4
  br label %for.cond

for.end:                                          ; preds = %for.cond
  %13 = load i32*, i32** %sequence, align 4
  store i32* %13, i32** %retval, align 4
  br label %return

if.end6:                                          ; preds = %entry
  %14 = load i32, i32* %START.addr, align 4
  %15 = load i32, i32* %END.addr, align 4
  %cmp7 = icmp ugt i32 %14, %15
  br i1 %cmp7, label %if.then8, label %if.end9

if.then8:                                         ; preds = %if.end6
  %16 = load i32, i32* %START.addr, align 4
  store i32 %16, i32* %end, align 4
  %17 = load i32, i32* %END.addr, align 4
  store i32 %17, i32* %start, align 4
  br label %if.end9

if.end9:                                          ; preds = %if.then8, %if.end6
  %18 = load i32, i32* %end, align 4
  %19 = load i32, i32* %start, align 4
  %sub = sub i32 %18, %19
  store i32 %sub, i32* %LENGTH, align 4
  %20 = load i32, i32* %LENGTH, align 4
  %add11 = add i32 1, %20
  %mul12 = mul i32 %add11, 4
  %call13 = call noalias i8* @malloc(i32 %mul12)
  %21 = bitcast i8* %call13 to i32*
  store i32* %21, i32** %sequence10, align 4
  %22 = load i32*, i32** %sequence10, align 4
  %cmp14 = icmp eq i32* %22, null
  br i1 %cmp14, label %if.then15, label %if.end17

if.then15:                                        ; preds = %if.end9
  %call16 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([29 x i8], [29 x i8]* @.str, i32 0, i32 0), i8* getelementptr inbounds ([23 x i8], [23 x i8]* @.str.1, i32 0, i32 0), i32 31)
  call void @perror(i8* getelementptr inbounds ([1 x i8], [1 x i8]* @.str.2, i32 0, i32 0))
  call void @exit(i32 1) #5
  unreachable

if.end17:                                         ; preds = %if.end9
  %23 = load i32, i32* %START.addr, align 4
  %24 = load i32, i32* %END.addr, align 4
  %cmp18 = icmp ult i32 %23, %24
  br i1 %cmp18, label %if.then19, label %if.else

if.then19:                                        ; preds = %if.end17
  store i32 0, i32* %index, align 4
  br label %for.cond20

for.cond20:                                       ; preds = %for.inc25, %if.then19
  %25 = load i32, i32* %index, align 4
  %26 = load i32, i32* %LENGTH, align 4
  %cmp21 = icmp ule i32 %25, %26
  br i1 %cmp21, label %for.body22, label %for.end27

for.body22:                                       ; preds = %for.cond20
  %27 = load i32, i32* %start, align 4
  %28 = load i32, i32* %index, align 4
  %add23 = add i32 %27, %28
  %29 = load i32*, i32** %sequence10, align 4
  %30 = load i32, i32* %index, align 4
  %arrayidx24 = getelementptr inbounds i32, i32* %29, i32 %30
  store i32 %add23, i32* %arrayidx24, align 4
  br label %for.inc25

for.inc25:                                        ; preds = %for.body22
  %31 = load i32, i32* %index, align 4
  %inc26 = add i32 %31, 1
  store i32 %inc26, i32* %index, align 4
  br label %for.cond20

for.end27:                                        ; preds = %for.cond20
  br label %if.end37

if.else:                                          ; preds = %if.end17
  store i32 0, i32* %index28, align 4
  br label %for.cond29

for.cond29:                                       ; preds = %for.inc34, %if.else
  %32 = load i32, i32* %index28, align 4
  %33 = load i32, i32* %LENGTH, align 4
  %cmp30 = icmp ule i32 %32, %33
  br i1 %cmp30, label %for.body31, label %for.end36

for.body31:                                       ; preds = %for.cond29
  %34 = load i32, i32* %end, align 4
  %35 = load i32, i32* %index28, align 4
  %sub32 = sub i32 %34, %35
  %36 = load i32*, i32** %sequence10, align 4
  %37 = load i32, i32* %index28, align 4
  %arrayidx33 = getelementptr inbounds i32, i32* %36, i32 %37
  store i32 %sub32, i32* %arrayidx33, align 4
  br label %for.inc34

for.inc34:                                        ; preds = %for.body31
  %38 = load i32, i32* %index28, align 4
  %inc35 = add i32 %38, 1
  store i32 %inc35, i32* %index28, align 4
  br label %for.cond29

for.end36:                                        ; preds = %for.cond29
  br label %if.end37

if.end37:                                         ; preds = %for.end36, %for.end27
  %39 = load i32*, i32** %sequence10, align 4
  store i32* %39, i32** %retval, align 4
  br label %return

return:                                           ; preds = %if.end37, %for.end
  %40 = load i32*, i32** %retval, align 4
  ret i32* %40
}

declare noalias i8* @malloc(i32 %0) #1

declare i32 @printf(i8* %0, ...) #1

declare void @perror(i8* %0) #1

; Function Attrs: noreturn
declare void @exit(i32 %0) #2

; Function Attrs: noinline nounwind optnone
define hidden i32* @order(double* noalias %ARRAY, i32 %SIZE, i1 zeroext %DECREASING) #0 {
entry:
  %ARRAY.addr = alloca double*, align 4
  %SIZE.addr = alloca i32, align 4
  %DECREASING.addr = alloca i8, align 1
  %idx = alloca i32*, align 4
  %i = alloca i32, align 4
  store double* %ARRAY, double** %ARRAY.addr, align 4
  store i32 %SIZE, i32* %SIZE.addr, align 4
  %frombool = zext i1 %DECREASING to i8
  store i8 %frombool, i8* %DECREASING.addr, align 1
  %0 = load i32, i32* %SIZE.addr, align 4
  %mul = mul i32 %0, 4
  %call = call noalias i8* @malloc(i32 %mul)
  %1 = bitcast i8* %call to i32*
  store i32* %1, i32** %idx, align 4
  %2 = load i32*, i32** %idx, align 4
  %cmp = icmp eq i32* %2, null
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %call1 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([33 x i8], [33 x i8]* @.str.3, i32 0, i32 0), i8* getelementptr inbounds ([23 x i8], [23 x i8]* @.str.1, i32 0, i32 0), i32 77)
  call void @perror(i8* getelementptr inbounds ([1 x i8], [1 x i8]* @.str.2, i32 0, i32 0))
  call void @exit(i32 1) #5
  unreachable

if.end:                                           ; preds = %entry
  %3 = load i32, i32* %SIZE.addr, align 4
  %mul2 = mul i32 8, %3
  %call3 = call noalias i8* @malloc(i32 %mul2)
  %4 = bitcast i8* %call3 to double*
  store double* %4, double** @base_arr, align 4
  %5 = load double*, double** @base_arr, align 4
  %cmp4 = icmp eq double* %5, null
  br i1 %cmp4, label %if.then5, label %if.end7

if.then5:                                         ; preds = %if.end
  %call6 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([33 x i8], [33 x i8]* @.str.3, i32 0, i32 0), i8* getelementptr inbounds ([23 x i8], [23 x i8]* @.str.1, i32 0, i32 0), i32 83)
  call void @perror(i8* getelementptr inbounds ([1 x i8], [1 x i8]* @.str.2, i32 0, i32 0))
  call void @exit(i32 1) #5
  unreachable

if.end7:                                          ; preds = %if.end
  store i32 0, i32* %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.end7
  %6 = load i32, i32* %i, align 4
  %7 = load i32, i32* %SIZE.addr, align 4
  %cmp8 = icmp ult i32 %6, %7
  br i1 %cmp8, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %8 = load double*, double** %ARRAY.addr, align 4
  %9 = load i32, i32* %i, align 4
  %arrayidx = getelementptr inbounds double, double* %8, i32 %9
  %10 = load double, double* %arrayidx, align 8
  %11 = load double*, double** @base_arr, align 4
  %12 = load i32, i32* %i, align 4
  %arrayidx9 = getelementptr inbounds double, double* %11, i32 %12
  store double %10, double* %arrayidx9, align 8
  %13 = load i32, i32* %i, align 4
  %14 = load i32*, i32** %idx, align 4
  %15 = load i32, i32* %i, align 4
  %arrayidx10 = getelementptr inbounds i32, i32* %14, i32 %15
  store i32 %13, i32* %arrayidx10, align 4
  br label %for.inc

for.inc:                                          ; preds = %for.body
  %16 = load i32, i32* %i, align 4
  %inc = add i32 %16, 1
  store i32 %inc, i32* %i, align 4
  br label %for.cond

for.end:                                          ; preds = %for.cond
  %17 = load i8, i8* %DECREASING.addr, align 1
  %tobool = trunc i8 %17 to i1
  %conv = zext i1 %tobool to i32
  %cmp11 = icmp eq i32 %conv, 0
  br i1 %cmp11, label %if.then13, label %if.else

if.then13:                                        ; preds = %for.end
  %18 = load i32*, i32** %idx, align 4
  %19 = bitcast i32* %18 to i8*
  %20 = load i32, i32* %SIZE.addr, align 4
  call void @qsort(i8* %19, i32 %20, i32 4, i32 (i8*, i8*)* @compar_decrease)
  br label %if.end20

if.else:                                          ; preds = %for.end
  %21 = load i8, i8* %DECREASING.addr, align 1
  %tobool14 = trunc i8 %21 to i1
  br i1 %tobool14, label %if.then18, label %if.end19

if.then18:                                        ; preds = %if.else
  %22 = load i32*, i32** %idx, align 4
  %23 = bitcast i32* %22 to i8*
  %24 = load i32, i32* %SIZE.addr, align 4
  call void @qsort(i8* %23, i32 %24, i32 4, i32 (i8*, i8*)* @compar_increase)
  br label %if.end19

if.end19:                                         ; preds = %if.then18, %if.else
  br label %if.end20

if.end20:                                         ; preds = %if.end19, %if.then13
  %25 = load double*, double** @base_arr, align 4
  %26 = bitcast double* %25 to i8*
  call void @free(i8* %26)
  store double* null, double** @base_arr, align 4
  %27 = load i32*, i32** %idx, align 4
  ret i32* %27
}

declare void @qsort(i8* %0, i32 %1, i32 %2, i32 (i8*, i8*)* %3) #1

; Function Attrs: noinline nounwind optnone
define internal i32 @compar_decrease(i8* noalias %a, i8* noalias %b) #0 {
entry:
  %retval = alloca i32, align 4
  %a.addr = alloca i8*, align 4
  %b.addr = alloca i8*, align 4
  %aa = alloca i32, align 4
  %bb = alloca i32, align 4
  store i8* %a, i8** %a.addr, align 4
  store i8* %b, i8** %b.addr, align 4
  %0 = load i8*, i8** %a.addr, align 4
  %1 = bitcast i8* %0 to i32*
  %2 = load i32, i32* %1, align 4
  store i32 %2, i32* %aa, align 4
  %3 = load i8*, i8** %b.addr, align 4
  %4 = bitcast i8* %3 to i32*
  %5 = load i32, i32* %4, align 4
  store i32 %5, i32* %bb, align 4
  %6 = load double*, double** @base_arr, align 4
  %7 = load i32, i32* %aa, align 4
  %arrayidx = getelementptr inbounds double, double* %6, i32 %7
  %8 = load double, double* %arrayidx, align 8
  %9 = load double*, double** @base_arr, align 4
  %10 = load i32, i32* %bb, align 4
  %arrayidx1 = getelementptr inbounds double, double* %9, i32 %10
  %11 = load double, double* %arrayidx1, align 8
  %cmp = fcmp olt double %8, %11
  br i1 %cmp, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  store i32 -1, i32* %retval, align 4
  br label %return

if.else:                                          ; preds = %entry
  %12 = load double*, double** @base_arr, align 4
  %13 = load i32, i32* %aa, align 4
  %arrayidx2 = getelementptr inbounds double, double* %12, i32 %13
  %14 = load double, double* %arrayidx2, align 8
  %15 = load double*, double** @base_arr, align 4
  %16 = load i32, i32* %bb, align 4
  %arrayidx3 = getelementptr inbounds double, double* %15, i32 %16
  %17 = load double, double* %arrayidx3, align 8
  %cmp4 = fcmp oeq double %14, %17
  br i1 %cmp4, label %if.then5, label %if.else6

if.then5:                                         ; preds = %if.else
  store i32 0, i32* %retval, align 4
  br label %return

if.else6:                                         ; preds = %if.else
  store i32 1, i32* %retval, align 4
  br label %return

return:                                           ; preds = %if.else6, %if.then5, %if.then
  %18 = load i32, i32* %retval, align 4
  ret i32 %18
}

; Function Attrs: noinline nounwind optnone
define internal i32 @compar_increase(i8* noalias %a, i8* noalias %b) #0 {
entry:
  %retval = alloca i32, align 4
  %a.addr = alloca i8*, align 4
  %b.addr = alloca i8*, align 4
  %aa = alloca i32, align 4
  %bb = alloca i32, align 4
  store i8* %a, i8** %a.addr, align 4
  store i8* %b, i8** %b.addr, align 4
  %0 = load i8*, i8** %a.addr, align 4
  %1 = bitcast i8* %0 to i32*
  %2 = load i32, i32* %1, align 4
  store i32 %2, i32* %aa, align 4
  %3 = load i8*, i8** %b.addr, align 4
  %4 = bitcast i8* %3 to i32*
  %5 = load i32, i32* %4, align 4
  store i32 %5, i32* %bb, align 4
  %6 = load double*, double** @base_arr, align 4
  %7 = load i32, i32* %aa, align 4
  %arrayidx = getelementptr inbounds double, double* %6, i32 %7
  %8 = load double, double* %arrayidx, align 8
  %9 = load double*, double** @base_arr, align 4
  %10 = load i32, i32* %bb, align 4
  %arrayidx1 = getelementptr inbounds double, double* %9, i32 %10
  %11 = load double, double* %arrayidx1, align 8
  %cmp = fcmp olt double %8, %11
  br i1 %cmp, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  store i32 1, i32* %retval, align 4
  br label %return

if.else:                                          ; preds = %entry
  %12 = load double*, double** @base_arr, align 4
  %13 = load i32, i32* %aa, align 4
  %arrayidx2 = getelementptr inbounds double, double* %12, i32 %13
  %14 = load double, double* %arrayidx2, align 8
  %15 = load double*, double** @base_arr, align 4
  %16 = load i32, i32* %bb, align 4
  %arrayidx3 = getelementptr inbounds double, double* %15, i32 %16
  %17 = load double, double* %arrayidx3, align 8
  %cmp4 = fcmp oeq double %14, %17
  br i1 %cmp4, label %if.then5, label %if.else6

if.then5:                                         ; preds = %if.else
  store i32 0, i32* %retval, align 4
  br label %return

if.else6:                                         ; preds = %if.else
  store i32 -1, i32* %retval, align 4
  br label %return

return:                                           ; preds = %if.else6, %if.then5, %if.then
  %18 = load i32, i32* %retval, align 4
  ret i32 %18
}

declare void @free(i8* %0) #1

; Function Attrs: noinline nounwind optnone
define hidden double* @cummin(double* noalias %ARRAY, i32 %NO_OF_ARRAY_ELEMENTS) #0 {
entry:
  %ARRAY.addr = alloca double*, align 4
  %NO_OF_ARRAY_ELEMENTS.addr = alloca i32, align 4
  %output = alloca double*, align 4
  %cumulative_min = alloca double, align 8
  %i = alloca i32, align 4
  store double* %ARRAY, double** %ARRAY.addr, align 4
  store i32 %NO_OF_ARRAY_ELEMENTS, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
  %0 = load i32, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
  %cmp = icmp ult i32 %0, 1
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %call = call i32 @puts(i8* getelementptr inbounds ([48 x i8], [48 x i8]* @.str.4, i32 0, i32 0))
  %call1 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([22 x i8], [22 x i8]* @.str.5, i32 0, i32 0), i8* getelementptr inbounds ([23 x i8], [23 x i8]* @.str.1, i32 0, i32 0), i32 105)
  call void @exit(i32 1) #5
  unreachable

if.end:                                           ; preds = %entry
  %1 = load i32, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
  %mul = mul i32 8, %1
  %call2 = call noalias i8* @malloc(i32 %mul)
  %2 = bitcast i8* %call2 to double*
  store double* %2, double** %output, align 4
  %3 = load double*, double** %output, align 4
  %cmp3 = icmp eq double* %3, null
  br i1 %cmp3, label %if.then4, label %if.end6

if.then4:                                         ; preds = %if.end
  %call5 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([33 x i8], [33 x i8]* @.str.3, i32 0, i32 0), i8* getelementptr inbounds ([23 x i8], [23 x i8]* @.str.1, i32 0, i32 0), i32 110)
  call void @perror(i8* getelementptr inbounds ([1 x i8], [1 x i8]* @.str.2, i32 0, i32 0))
  call void @exit(i32 1) #5
  unreachable

if.end6:                                          ; preds = %if.end
  %4 = load double*, double** %ARRAY.addr, align 4
  %arrayidx = getelementptr inbounds double, double* %4, i32 0
  %5 = load double, double* %arrayidx, align 8
  store double %5, double* %cumulative_min, align 8
  store i32 0, i32* %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.end6
  %6 = load i32, i32* %i, align 4
  %7 = load i32, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
  %cmp7 = icmp ult i32 %6, %7
  br i1 %cmp7, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %8 = load double*, double** %ARRAY.addr, align 4
  %9 = load i32, i32* %i, align 4
  %arrayidx8 = getelementptr inbounds double, double* %8, i32 %9
  %10 = load double, double* %arrayidx8, align 8
  %11 = load double, double* %cumulative_min, align 8
  %cmp9 = fcmp olt double %10, %11
  br i1 %cmp9, label %if.then10, label %if.end12

if.then10:                                        ; preds = %for.body
  %12 = load double*, double** %ARRAY.addr, align 4
  %13 = load i32, i32* %i, align 4
  %arrayidx11 = getelementptr inbounds double, double* %12, i32 %13
  %14 = load double, double* %arrayidx11, align 8
  store double %14, double* %cumulative_min, align 8
  br label %if.end12

if.end12:                                         ; preds = %if.then10, %for.body
  %15 = load double, double* %cumulative_min, align 8
  %16 = load double*, double** %output, align 4
  %17 = load i32, i32* %i, align 4
  %arrayidx13 = getelementptr inbounds double, double* %16, i32 %17
  store double %15, double* %arrayidx13, align 8
  br label %for.inc

for.inc:                                          ; preds = %if.end12
  %18 = load i32, i32* %i, align 4
  %inc = add i32 %18, 1
  store i32 %inc, i32* %i, align 4
  br label %for.cond

for.end:                                          ; preds = %for.cond
  %19 = load double*, double** %output, align 4
  ret double* %19
}

declare i32 @puts(i8* %0) #1

; Function Attrs: noinline nounwind optnone
define hidden double* @cummax(double* noalias %ARRAY, i32 %NO_OF_ARRAY_ELEMENTS) #0 {
entry:
  %ARRAY.addr = alloca double*, align 4
  %NO_OF_ARRAY_ELEMENTS.addr = alloca i32, align 4
  %output = alloca double*, align 4
  %cumulative_max = alloca double, align 8
  %i = alloca i32, align 4
  store double* %ARRAY, double** %ARRAY.addr, align 4
  store i32 %NO_OF_ARRAY_ELEMENTS, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
  %0 = load i32, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
  %cmp = icmp ult i32 %0, 1
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %call = call i32 @puts(i8* getelementptr inbounds ([41 x i8], [41 x i8]* @.str.6, i32 0, i32 0))
  %call1 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([22 x i8], [22 x i8]* @.str.5, i32 0, i32 0), i8* getelementptr inbounds ([23 x i8], [23 x i8]* @.str.1, i32 0, i32 0), i32 129)
  call void @exit(i32 1) #5
  unreachable

if.end:                                           ; preds = %entry
  %1 = load i32, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
  %mul = mul i32 8, %1
  %call2 = call noalias i8* @malloc(i32 %mul)
  %2 = bitcast i8* %call2 to double*
  store double* %2, double** %output, align 4
  %3 = load double*, double** %output, align 4
  %cmp3 = icmp eq double* %3, null
  br i1 %cmp3, label %if.then4, label %if.end6

if.then4:                                         ; preds = %if.end
  %call5 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([33 x i8], [33 x i8]* @.str.3, i32 0, i32 0), i8* getelementptr inbounds ([23 x i8], [23 x i8]* @.str.1, i32 0, i32 0), i32 134)
  call void @perror(i8* getelementptr inbounds ([1 x i8], [1 x i8]* @.str.2, i32 0, i32 0))
  call void @exit(i32 1) #5
  unreachable

if.end6:                                          ; preds = %if.end
  %4 = load double*, double** %ARRAY.addr, align 4
  %arrayidx = getelementptr inbounds double, double* %4, i32 0
  %5 = load double, double* %arrayidx, align 8
  store double %5, double* %cumulative_max, align 8
  store i32 0, i32* %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.end6
  %6 = load i32, i32* %i, align 4
  %7 = load i32, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
  %cmp7 = icmp ult i32 %6, %7
  br i1 %cmp7, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %8 = load double*, double** %ARRAY.addr, align 4
  %9 = load i32, i32* %i, align 4
  %arrayidx8 = getelementptr inbounds double, double* %8, i32 %9
  %10 = load double, double* %arrayidx8, align 8
  %11 = load double, double* %cumulative_max, align 8
  %cmp9 = fcmp ogt double %10, %11
  br i1 %cmp9, label %if.then10, label %if.end12

if.then10:                                        ; preds = %for.body
  %12 = load double*, double** %ARRAY.addr, align 4
  %13 = load i32, i32* %i, align 4
  %arrayidx11 = getelementptr inbounds double, double* %12, i32 %13
  %14 = load double, double* %arrayidx11, align 8
  store double %14, double* %cumulative_max, align 8
  br label %if.end12

if.end12:                                         ; preds = %if.then10, %for.body
  %15 = load double, double* %cumulative_max, align 8
  %16 = load double*, double** %output, align 4
  %17 = load i32, i32* %i, align 4
  %arrayidx13 = getelementptr inbounds double, double* %16, i32 %17
  store double %15, double* %arrayidx13, align 8
  br label %for.inc

for.inc:                                          ; preds = %if.end12
  %18 = load i32, i32* %i, align 4
  %inc = add i32 %18, 1
  store i32 %inc, i32* %i, align 4
  br label %for.cond

for.end:                                          ; preds = %for.cond
  %19 = load double*, double** %output, align 4
  ret double* %19
}

; Function Attrs: noinline nounwind optnone
define hidden double* @pminx(double* noalias %ARRAY, i32 %NO_OF_ARRAY_ELEMENTS, double %X) #0 {
entry:
  %ARRAY.addr = alloca double*, align 4
  %NO_OF_ARRAY_ELEMENTS.addr = alloca i32, align 4
  %X.addr = alloca double, align 8
  %pmin_array = alloca double*, align 4
  %index = alloca i32, align 4
  store double* %ARRAY, double** %ARRAY.addr, align 4
  store i32 %NO_OF_ARRAY_ELEMENTS, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
  store double %X, double* %X.addr, align 8
  %0 = load i32, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
  %cmp = icmp ult i32 %0, 1
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %call = call i32 @puts(i8* getelementptr inbounds ([37 x i8], [37 x i8]* @.str.7, i32 0, i32 0))
  %call1 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([22 x i8], [22 x i8]* @.str.5, i32 0, i32 0), i8* getelementptr inbounds ([23 x i8], [23 x i8]* @.str.1, i32 0, i32 0), i32 152)
  call void @exit(i32 1) #5
  unreachable

if.end:                                           ; preds = %entry
  %1 = load i32, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
  %mul = mul i32 8, %1
  %call2 = call noalias i8* @malloc(i32 %mul)
  %2 = bitcast i8* %call2 to double*
  store double* %2, double** %pmin_array, align 4
  %3 = load double*, double** %pmin_array, align 4
  %cmp3 = icmp eq double* %3, null
  br i1 %cmp3, label %if.then4, label %if.end6

if.then4:                                         ; preds = %if.end
  %call5 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([33 x i8], [33 x i8]* @.str.3, i32 0, i32 0), i8* getelementptr inbounds ([23 x i8], [23 x i8]* @.str.1, i32 0, i32 0), i32 157)
  call void @perror(i8* getelementptr inbounds ([1 x i8], [1 x i8]* @.str.2, i32 0, i32 0))
  call void @exit(i32 1) #5
  unreachable

if.end6:                                          ; preds = %if.end
  store i32 0, i32* %index, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.end6
  %4 = load i32, i32* %index, align 4
  %5 = load i32, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
  %cmp7 = icmp ult i32 %4, %5
  br i1 %cmp7, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %6 = load double*, double** %ARRAY.addr, align 4
  %7 = load i32, i32* %index, align 4
  %arrayidx = getelementptr inbounds double, double* %6, i32 %7
  %8 = load double, double* %arrayidx, align 8
  %9 = load double, double* %X.addr, align 8
  %cmp8 = fcmp olt double %8, %9
  br i1 %cmp8, label %if.then9, label %if.else

if.then9:                                         ; preds = %for.body
  %10 = load double*, double** %ARRAY.addr, align 4
  %11 = load i32, i32* %index, align 4
  %arrayidx10 = getelementptr inbounds double, double* %10, i32 %11
  %12 = load double, double* %arrayidx10, align 8
  %13 = load double*, double** %pmin_array, align 4
  %14 = load i32, i32* %index, align 4
  %arrayidx11 = getelementptr inbounds double, double* %13, i32 %14
  store double %12, double* %arrayidx11, align 8
  br label %if.end13

if.else:                                          ; preds = %for.body
  %15 = load double, double* %X.addr, align 8
  %16 = load double*, double** %pmin_array, align 4
  %17 = load i32, i32* %index, align 4
  %arrayidx12 = getelementptr inbounds double, double* %16, i32 %17
  store double %15, double* %arrayidx12, align 8
  br label %if.end13

if.end13:                                         ; preds = %if.else, %if.then9
  br label %for.inc

for.inc:                                          ; preds = %if.end13
  %18 = load i32, i32* %index, align 4
  %inc = add i32 %18, 1
  store i32 %inc, i32* %index, align 4
  br label %for.cond

for.end:                                          ; preds = %for.cond
  %19 = load double*, double** %pmin_array, align 4
  ret double* %19
}

; Function Attrs: noinline nounwind optnone
define hidden void @double_say(double* noalias %ARRAY, i32 %NO_OF_ARRAY_ELEMENTS) #0 {
entry:
  %ARRAY.addr = alloca double*, align 4
  %NO_OF_ARRAY_ELEMENTS.addr = alloca i32, align 4
  %i = alloca i32, align 4
  store double* %ARRAY, double** %ARRAY.addr, align 4
  store i32 %NO_OF_ARRAY_ELEMENTS, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
  %0 = load double*, double** %ARRAY.addr, align 4
  %arrayidx = getelementptr inbounds double, double* %0, i32 0
  %1 = load double, double* %arrayidx, align 8
  %call = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([7 x i8], [7 x i8]* @.str.8, i32 0, i32 0), double %1)
  store i32 1, i32* %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %2 = load i32, i32* %i, align 4
  %3 = load i32, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
  %cmp = icmp ult i32 %2, %3
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %4 = load double*, double** %ARRAY.addr, align 4
  %5 = load i32, i32* %i, align 4
  %arrayidx1 = getelementptr inbounds double, double* %4, i32 %5
  %6 = load double, double* %arrayidx1, align 8
  %call2 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([7 x i8], [7 x i8]* @.str.9, i32 0, i32 0), double %6)
  %7 = load i32, i32* %i, align 4
  %add = add i32 %7, 1
  %rem = urem i32 %add, 5
  %cmp3 = icmp eq i32 %rem, 0
  br i1 %cmp3, label %if.then, label %if.end

if.then:                                          ; preds = %for.body
  %8 = load i32, i32* %i, align 4
  %add4 = add i32 %8, 1
  %call5 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([6 x i8], [6 x i8]* @.str.10, i32 0, i32 0), i32 %add4)
  br label %if.end

if.end:                                           ; preds = %if.then, %for.body
  br label %for.inc

for.inc:                                          ; preds = %if.end
  %9 = load i32, i32* %i, align 4
  %inc = add i32 %9, 1
  store i32 %inc, i32* %i, align 4
  br label %for.cond

for.end:                                          ; preds = %for.cond
  %call6 = call i32 @puts(i8* getelementptr inbounds ([2 x i8], [2 x i8]* @.str.11, i32 0, i32 0))
  ret void
}

; Function Attrs: noinline nounwind optnone
define hidden double* @uint2double(i32* noalias %ARRAY, i32 %NO_OF_ARRAY_ELEMENTS) #0 {
entry:
  %ARRAY.addr = alloca i32*, align 4
  %NO_OF_ARRAY_ELEMENTS.addr = alloca i32, align 4
  %doubleArray = alloca double*, align 4
  %index = alloca i32, align 4
  store i32* %ARRAY, i32** %ARRAY.addr, align 4
  store i32 %NO_OF_ARRAY_ELEMENTS, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
  %0 = load i32, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
  %mul = mul i32 8, %0
  %call = call noalias i8* @malloc(i32 %mul)
  %1 = bitcast i8* %call to double*
  store double* %1, double** %doubleArray, align 4
  %2 = load double*, double** %doubleArray, align 4
  %cmp = icmp eq double* %2, null
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %call1 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([34 x i8], [34 x i8]* @.str.12, i32 0, i32 0), i8* getelementptr inbounds ([23 x i8], [23 x i8]* @.str.1, i32 0, i32 0), i32 194)
  call void @perror(i8* getelementptr inbounds ([1 x i8], [1 x i8]* @.str.2, i32 0, i32 0))
  call void @exit(i32 1) #5
  unreachable

if.end:                                           ; preds = %entry
  store i32 0, i32* %index, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.end
  %3 = load i32, i32* %index, align 4
  %4 = load i32, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
  %cmp2 = icmp ult i32 %3, %4
  br i1 %cmp2, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %5 = load i32*, i32** %ARRAY.addr, align 4
  %6 = load i32, i32* %index, align 4
  %arrayidx = getelementptr inbounds i32, i32* %5, i32 %6
  %7 = load i32, i32* %arrayidx, align 4
  %conv = uitofp i32 %7 to double
  %8 = load double*, double** %doubleArray, align 4
  %9 = load i32, i32* %index, align 4
  %arrayidx3 = getelementptr inbounds double, double* %8, i32 %9
  store double %conv, double* %arrayidx3, align 8
  br label %for.inc

for.inc:                                          ; preds = %for.body
  %10 = load i32, i32* %index, align 4
  %inc = add i32 %10, 1
  store i32 %inc, i32* %index, align 4
  br label %for.cond

for.end:                                          ; preds = %for.cond
  %11 = load double*, double** %doubleArray, align 4
  ret double* %11
}

; Function Attrs: noinline nounwind optnone
define hidden double @min2(double %N1, double %N2) #0 {
entry:
  %retval = alloca double, align 8
  %N1.addr = alloca double, align 8
  %N2.addr = alloca double, align 8
  store double %N1, double* %N1.addr, align 8
  store double %N2, double* %N2.addr, align 8
  %0 = load double, double* %N1.addr, align 8
  %1 = load double, double* %N2.addr, align 8
  %cmp = fcmp olt double %0, %1
  br i1 %cmp, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  %2 = load double, double* %N1.addr, align 8
  store double %2, double* %retval, align 8
  br label %return

if.else:                                          ; preds = %entry
  %3 = load double, double* %N2.addr, align 8
  store double %3, double* %retval, align 8
  br label %return

return:                                           ; preds = %if.else, %if.then
  %4 = load double, double* %retval, align 8
  ret double %4
}

; Function Attrs: noinline nounwind optnone
define hidden double* @p_adjust(double* noalias %PVALUES, i32 %NO_OF_ARRAY_ELEMENTS, i8* noalias %STRING) #0 {
entry:
  %retval = alloca double*, align 4
  %PVALUES.addr = alloca double*, align 4
  %NO_OF_ARRAY_ELEMENTS.addr = alloca i32, align 4
  %STRING.addr = alloca i8*, align 4
  %TYPE = alloca i16, align 2
  %bonferroni = alloca double*, align 4
  %index = alloca i32, align 4
  %BONFERRONI = alloca double, align 8
  %o = alloca i32*, align 4
  %o2double = alloca double*, align 4
  %cummax_input = alloca double*, align 4
  %index80 = alloca i32, align 4
  %ro = alloca i32*, align 4
  %cummax_output = alloca double*, align 4
  %pmin = alloca double*, align 4
  %qvalues = alloca double*, align 4
  %index98 = alloca i32, align 4
  %o114 = alloca i32*, align 4
  %p = alloca double*, align 4
  %index123 = alloca i32, align 4
  %o2double134 = alloca double*, align 4
  %ro136 = alloca i32*, align 4
  %q = alloca double*, align 4
  %pa = alloca double*, align 4
  %min = alloca double, align 8
  %index155 = alloca i32, align 4
  %TEMP = alloca double, align 8
  %index171 = alloca i32, align 4
  %j = alloca i32, align 4
  %ij = alloca i32*, align 4
  %I2_LENGTH = alloca i32, align 4
  %i2 = alloca i32*, align 4
  %i = alloca i32, align 4
  %q1 = alloca double, align 8
  %i208 = alloca i32, align 4
  %TEMP_Q1 = alloca double, align 8
  %i227 = alloca i32, align 4
  %i244 = alloca i32, align 4
  %i256 = alloca i32, align 4
  %index274 = alloca i32, align 4
  %o288 = alloca i32*, align 4
  %o_double = alloca double*, align 4
  %index296 = alloca i32, align 4
  %ro315 = alloca i32*, align 4
  %cummin_input = alloca double*, align 4
  %index328 = alloca i32, align 4
  %NI = alloca double, align 8
  %q349 = alloca double, align 8
  %index350 = alloca i32, align 4
  %index362 = alloca i32, align 4
  %NI367 = alloca double, align 8
  %index385 = alloca i32, align 4
  %cummin_array = alloca double*, align 4
  %pmin403 = alloca double*, align 4
  %q_array = alloca double*, align 4
  %index407 = alloca i32, align 4
  store double* %PVALUES, double** %PVALUES.addr, align 4
  store i32 %NO_OF_ARRAY_ELEMENTS, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
  store i8* %STRING, i8** %STRING.addr, align 4
  %0 = load i32, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
  %cmp = icmp ult i32 %0, 1
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %call = call i32 @puts(i8* getelementptr inbounds ([41 x i8], [41 x i8]* @.str.13, i32 0, i32 0))
  %call1 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([22 x i8], [22 x i8]* @.str.5, i32 0, i32 0), i8* getelementptr inbounds ([23 x i8], [23 x i8]* @.str.1, i32 0, i32 0), i32 217)
  call void @exit(i32 1) #5
  unreachable

if.end:                                           ; preds = %entry
  store i16 -1, i16* %TYPE, align 2
  %1 = load i8*, i8** %STRING.addr, align 4
  %cmp2 = icmp eq i8* %1, null
  br i1 %cmp2, label %if.then3, label %if.else

if.then3:                                         ; preds = %if.end
  store i16 0, i16* %TYPE, align 2
  br label %if.end41

if.else:                                          ; preds = %if.end
  %2 = load i8*, i8** %STRING.addr, align 4
  %call4 = call i32 @strcasecmp(i8* %2, i8* getelementptr inbounds ([3 x i8], [3 x i8]* @.str.14, i32 0, i32 0))
  %cmp5 = icmp eq i32 %call4, 0
  br i1 %cmp5, label %if.then6, label %if.else7

if.then6:                                         ; preds = %if.else
  store i16 0, i16* %TYPE, align 2
  br label %if.end40

if.else7:                                         ; preds = %if.else
  %3 = load i8*, i8** %STRING.addr, align 4
  %call8 = call i32 @strcasecmp(i8* %3, i8* getelementptr inbounds ([4 x i8], [4 x i8]* @.str.15, i32 0, i32 0))
  %cmp9 = icmp eq i32 %call8, 0
  br i1 %cmp9, label %if.then10, label %if.else11

if.then10:                                        ; preds = %if.else7
  store i16 0, i16* %TYPE, align 2
  br label %if.end39

if.else11:                                        ; preds = %if.else7
  %4 = load i8*, i8** %STRING.addr, align 4
  %call12 = call i32 @strcasecmp(i8* %4, i8* getelementptr inbounds ([3 x i8], [3 x i8]* @.str.16, i32 0, i32 0))
  %cmp13 = icmp eq i32 %call12, 0
  br i1 %cmp13, label %if.then14, label %if.else15

if.then14:                                        ; preds = %if.else11
  store i16 1, i16* %TYPE, align 2
  br label %if.end38

if.else15:                                        ; preds = %if.else11
  %5 = load i8*, i8** %STRING.addr, align 4
  %call16 = call i32 @strcasecmp(i8* %5, i8* getelementptr inbounds ([11 x i8], [11 x i8]* @.str.17, i32 0, i32 0))
  %cmp17 = icmp eq i32 %call16, 0
  br i1 %cmp17, label %if.then18, label %if.else19

if.then18:                                        ; preds = %if.else15
  store i16 2, i16* %TYPE, align 2
  br label %if.end37

if.else19:                                        ; preds = %if.else15
  %6 = load i8*, i8** %STRING.addr, align 4
  %call20 = call i32 @strcasecmp(i8* %6, i8* getelementptr inbounds ([9 x i8], [9 x i8]* @.str.18, i32 0, i32 0))
  %cmp21 = icmp eq i32 %call20, 0
  br i1 %cmp21, label %if.then22, label %if.else23

if.then22:                                        ; preds = %if.else19
  store i16 3, i16* %TYPE, align 2
  br label %if.end36

if.else23:                                        ; preds = %if.else19
  %7 = load i8*, i8** %STRING.addr, align 4
  %call24 = call i32 @strcasecmp(i8* %7, i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.19, i32 0, i32 0))
  %cmp25 = icmp eq i32 %call24, 0
  br i1 %cmp25, label %if.then26, label %if.else27

if.then26:                                        ; preds = %if.else23
  store i16 4, i16* %TYPE, align 2
  br label %if.end35

if.else27:                                        ; preds = %if.else23
  %8 = load i8*, i8** %STRING.addr, align 4
  %call28 = call i32 @strcasecmp(i8* %8, i8* getelementptr inbounds ([7 x i8], [7 x i8]* @.str.20, i32 0, i32 0))
  %cmp29 = icmp eq i32 %call28, 0
  br i1 %cmp29, label %if.then30, label %if.else31

if.then30:                                        ; preds = %if.else27
  store i16 5, i16* %TYPE, align 2
  br label %if.end34

if.else31:                                        ; preds = %if.else27
  %9 = load i8*, i8** %STRING.addr, align 4
  %call32 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([44 x i8], [44 x i8]* @.str.21, i32 0, i32 0), i8* %9)
  %call33 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([22 x i8], [22 x i8]* @.str.5, i32 0, i32 0), i8* getelementptr inbounds ([23 x i8], [23 x i8]* @.str.1, i32 0, i32 0), i32 239)
  call void @exit(i32 1) #5
  unreachable

if.end34:                                         ; preds = %if.then30
  br label %if.end35

if.end35:                                         ; preds = %if.end34, %if.then26
  br label %if.end36

if.end36:                                         ; preds = %if.end35, %if.then22
  br label %if.end37

if.end37:                                         ; preds = %if.end36, %if.then18
  br label %if.end38

if.end38:                                         ; preds = %if.end37, %if.then14
  br label %if.end39

if.end39:                                         ; preds = %if.end38, %if.then10
  br label %if.end40

if.end40:                                         ; preds = %if.end39, %if.then6
  br label %if.end41

if.end41:                                         ; preds = %if.end40, %if.then3
  %10 = load i16, i16* %TYPE, align 2
  %conv = sext i16 %10 to i32
  %cmp42 = icmp eq i32 %conv, 2
  br i1 %cmp42, label %if.then44, label %if.else71

if.then44:                                        ; preds = %if.end41
  %11 = load i32, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
  %mul = mul i32 8, %11
  %call45 = call noalias i8* @malloc(i32 %mul)
  %12 = bitcast i8* %call45 to double*
  store double* %12, double** %bonferroni, align 4
  %13 = load double*, double** %bonferroni, align 4
  %cmp46 = icmp eq double* %13, null
  br i1 %cmp46, label %if.then48, label %if.end50

if.then48:                                        ; preds = %if.then44
  %call49 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([33 x i8], [33 x i8]* @.str.3, i32 0, i32 0), i8* getelementptr inbounds ([23 x i8], [23 x i8]* @.str.1, i32 0, i32 0), i32 247)
  call void @perror(i8* getelementptr inbounds ([1 x i8], [1 x i8]* @.str.2, i32 0, i32 0))
  call void @exit(i32 1) #5
  unreachable

if.end50:                                         ; preds = %if.then44
  store i32 0, i32* %index, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.end50
  %14 = load i32, i32* %index, align 4
  %15 = load i32, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
  %cmp51 = icmp ult i32 %14, %15
  br i1 %cmp51, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %16 = load double*, double** %PVALUES.addr, align 4
  %17 = load i32, i32* %index, align 4
  %arrayidx = getelementptr inbounds double, double* %16, i32 %17
  %18 = load double, double* %arrayidx, align 8
  %19 = load i32, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
  %conv53 = uitofp i32 %19 to double
  %mul54 = fmul double %18, %conv53
  store double %mul54, double* %BONFERRONI, align 8
  %20 = load double, double* %BONFERRONI, align 8
  %cmp55 = fcmp oge double %20, 1.000000e+00
  br i1 %cmp55, label %if.then57, label %if.else59

if.then57:                                        ; preds = %for.body
  %21 = load double*, double** %bonferroni, align 4
  %22 = load i32, i32* %index, align 4
  %arrayidx58 = getelementptr inbounds double, double* %21, i32 %22
  store double 1.000000e+00, double* %arrayidx58, align 8
  br label %if.end70

if.else59:                                        ; preds = %for.body
  %23 = load double, double* %BONFERRONI, align 8
  %cmp60 = fcmp ole double 0.000000e+00, %23
  br i1 %cmp60, label %land.lhs.true, label %if.else66

land.lhs.true:                                    ; preds = %if.else59
  %24 = load double, double* %BONFERRONI, align 8
  %cmp62 = fcmp olt double %24, 1.000000e+00
  br i1 %cmp62, label %if.then64, label %if.else66

if.then64:                                        ; preds = %land.lhs.true
  %25 = load double, double* %BONFERRONI, align 8
  %26 = load double*, double** %bonferroni, align 4
  %27 = load i32, i32* %index, align 4
  %arrayidx65 = getelementptr inbounds double, double* %26, i32 %27
  store double %25, double* %arrayidx65, align 8
  br label %if.end69

if.else66:                                        ; preds = %land.lhs.true, %if.else59
  %28 = load double, double* %BONFERRONI, align 8
  %call67 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([42 x i8], [42 x i8]* @.str.22, i32 0, i32 0), double %28)
  %call68 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([23 x i8], [23 x i8]* @.str.23, i32 0, i32 0), i8* getelementptr inbounds ([23 x i8], [23 x i8]* @.str.1, i32 0, i32 0), i32 259)
  call void @exit(i32 1) #5
  unreachable

if.end69:                                         ; preds = %if.then64
  br label %if.end70

if.end70:                                         ; preds = %if.end69, %if.then57
  br label %for.inc

for.inc:                                          ; preds = %if.end70
  %29 = load i32, i32* %index, align 4
  %inc = add i32 %29, 1
  store i32 %inc, i32* %index, align 4
  br label %for.cond

for.end:                                          ; preds = %for.cond
  %30 = load double*, double** %bonferroni, align 4
  store double* %30, double** %retval, align 4
  br label %return

if.else71:                                        ; preds = %if.end41
  %31 = load i16, i16* %TYPE, align 2
  %conv72 = sext i16 %31 to i32
  %cmp73 = icmp eq i32 %conv72, 4
  br i1 %cmp73, label %if.then75, label %if.else109

if.then75:                                        ; preds = %if.else71
  %32 = load double*, double** %PVALUES.addr, align 4
  %33 = load i32, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
  %call76 = call i32* @order(double* %32, i32 %33, i1 zeroext false)
  store i32* %call76, i32** %o, align 4
  %34 = load i32*, i32** %o, align 4
  %35 = load i32, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
  %call77 = call double* @uint2double(i32* %34, i32 %35)
  store double* %call77, double** %o2double, align 4
  %36 = load i32, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
  %mul78 = mul i32 8, %36
  %call79 = call noalias i8* @malloc(i32 %mul78)
  %37 = bitcast i8* %call79 to double*
  store double* %37, double** %cummax_input, align 4
  store i32 0, i32* %index80, align 4
  br label %for.cond81

for.cond81:                                       ; preds = %for.inc90, %if.then75
  %38 = load i32, i32* %index80, align 4
  %39 = load i32, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
  %cmp82 = icmp ult i32 %38, %39
  br i1 %cmp82, label %for.body84, label %for.end92

for.body84:                                       ; preds = %for.cond81
  %40 = load i32, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
  %41 = load i32, i32* %index80, align 4
  %sub = sub i32 %40, %41
  %conv85 = uitofp i32 %sub to double
  %42 = load double*, double** %PVALUES.addr, align 4
  %43 = load i32*, i32** %o, align 4
  %44 = load i32, i32* %index80, align 4
  %arrayidx86 = getelementptr inbounds i32, i32* %43, i32 %44
  %45 = load i32, i32* %arrayidx86, align 4
  %arrayidx87 = getelementptr inbounds double, double* %42, i32 %45
  %46 = load double, double* %arrayidx87, align 8
  %mul88 = fmul double %conv85, %46
  %47 = load double*, double** %cummax_input, align 4
  %48 = load i32, i32* %index80, align 4
  %arrayidx89 = getelementptr inbounds double, double* %47, i32 %48
  store double %mul88, double* %arrayidx89, align 8
  br label %for.inc90

for.inc90:                                        ; preds = %for.body84
  %49 = load i32, i32* %index80, align 4
  %inc91 = add i32 %49, 1
  store i32 %inc91, i32* %index80, align 4
  br label %for.cond81

for.end92:                                        ; preds = %for.cond81
  %50 = load i32*, i32** %o, align 4
  %51 = bitcast i32* %50 to i8*
  call void @free(i8* %51)
  store i32* null, i32** %o, align 4
  %52 = load double*, double** %o2double, align 4
  %53 = load i32, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
  %call93 = call i32* @order(double* %52, i32 %53, i1 zeroext false)
  store i32* %call93, i32** %ro, align 4
  %54 = load double*, double** %o2double, align 4
  %55 = bitcast double* %54 to i8*
  call void @free(i8* %55)
  store double* null, double** %o2double, align 4
  %56 = load double*, double** %cummax_input, align 4
  %57 = load i32, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
  %call94 = call double* @cummax(double* %56, i32 %57)
  store double* %call94, double** %cummax_output, align 4
  %58 = load double*, double** %cummax_input, align 4
  %59 = bitcast double* %58 to i8*
  call void @free(i8* %59)
  store double* null, double** %cummax_input, align 4
  %60 = load double*, double** %cummax_output, align 4
  %61 = load i32, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
  %call95 = call double* @pminx(double* %60, i32 %61, double 1.000000e+00)
  store double* %call95, double** %pmin, align 4
  %62 = load double*, double** %cummax_output, align 4
  %63 = bitcast double* %62 to i8*
  call void @free(i8* %63)
  store double* null, double** %cummax_output, align 4
  %64 = load i32, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
  %mul96 = mul i32 8, %64
  %call97 = call noalias i8* @malloc(i32 %mul96)
  %65 = bitcast i8* %call97 to double*
  store double* %65, double** %qvalues, align 4
  store i32 0, i32* %index98, align 4
  br label %for.cond99

for.cond99:                                       ; preds = %for.inc106, %for.end92
  %66 = load i32, i32* %index98, align 4
  %67 = load i32, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
  %cmp100 = icmp ult i32 %66, %67
  br i1 %cmp100, label %for.body102, label %for.end108

for.body102:                                      ; preds = %for.cond99
  %68 = load double*, double** %pmin, align 4
  %69 = load i32*, i32** %ro, align 4
  %70 = load i32, i32* %index98, align 4
  %arrayidx103 = getelementptr inbounds i32, i32* %69, i32 %70
  %71 = load i32, i32* %arrayidx103, align 4
  %arrayidx104 = getelementptr inbounds double, double* %68, i32 %71
  %72 = load double, double* %arrayidx104, align 8
  %73 = load double*, double** %qvalues, align 4
  %74 = load i32, i32* %index98, align 4
  %arrayidx105 = getelementptr inbounds double, double* %73, i32 %74
  store double %72, double* %arrayidx105, align 8
  br label %for.inc106

for.inc106:                                       ; preds = %for.body102
  %75 = load i32, i32* %index98, align 4
  %inc107 = add i32 %75, 1
  store i32 %inc107, i32* %index98, align 4
  br label %for.cond99

for.end108:                                       ; preds = %for.cond99
  %76 = load double*, double** %pmin, align 4
  %77 = bitcast double* %76 to i8*
  call void @free(i8* %77)
  store double* null, double** %pmin, align 4
  %78 = load i32*, i32** %ro, align 4
  %79 = bitcast i32* %78 to i8*
  call void @free(i8* %79)
  store i32* null, i32** %ro, align 4
  %80 = load double*, double** %qvalues, align 4
  store double* %80, double** %retval, align 4
  br label %return

if.else109:                                       ; preds = %if.else71
  %81 = load i16, i16* %TYPE, align 2
  %conv110 = sext i16 %81 to i32
  %cmp111 = icmp eq i32 %conv110, 5
  br i1 %cmp111, label %if.then113, label %if.end285

if.then113:                                       ; preds = %if.else109
  %82 = load double*, double** %PVALUES.addr, align 4
  %83 = load i32, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
  %call115 = call i32* @order(double* %82, i32 %83, i1 zeroext false)
  store i32* %call115, i32** %o114, align 4
  %84 = load i32, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
  %mul116 = mul i32 8, %84
  %call117 = call noalias i8* @malloc(i32 %mul116)
  %85 = bitcast i8* %call117 to double*
  store double* %85, double** %p, align 4
  %86 = load double*, double** %p, align 4
  %cmp118 = icmp eq double* %86, null
  br i1 %cmp118, label %if.then120, label %if.end122

if.then120:                                       ; preds = %if.then113
  %call121 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([33 x i8], [33 x i8]* @.str.3, i32 0, i32 0), i8* getelementptr inbounds ([23 x i8], [23 x i8]* @.str.1, i32 0, i32 0), i32 302)
  call void @perror(i8* getelementptr inbounds ([1 x i8], [1 x i8]* @.str.2, i32 0, i32 0))
  call void @exit(i32 1) #5
  unreachable

if.end122:                                        ; preds = %if.then113
  store i32 0, i32* %index123, align 4
  br label %for.cond124

for.cond124:                                      ; preds = %for.inc131, %if.end122
  %87 = load i32, i32* %index123, align 4
  %88 = load i32, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
  %cmp125 = icmp ult i32 %87, %88
  br i1 %cmp125, label %for.body127, label %for.end133

for.body127:                                      ; preds = %for.cond124
  %89 = load double*, double** %PVALUES.addr, align 4
  %90 = load i32*, i32** %o114, align 4
  %91 = load i32, i32* %index123, align 4
  %arrayidx128 = getelementptr inbounds i32, i32* %90, i32 %91
  %92 = load i32, i32* %arrayidx128, align 4
  %arrayidx129 = getelementptr inbounds double, double* %89, i32 %92
  %93 = load double, double* %arrayidx129, align 8
  %94 = load double*, double** %p, align 4
  %95 = load i32, i32* %index123, align 4
  %arrayidx130 = getelementptr inbounds double, double* %94, i32 %95
  store double %93, double* %arrayidx130, align 8
  br label %for.inc131

for.inc131:                                       ; preds = %for.body127
  %96 = load i32, i32* %index123, align 4
  %inc132 = add i32 %96, 1
  store i32 %inc132, i32* %index123, align 4
  br label %for.cond124

for.end133:                                       ; preds = %for.cond124
  %97 = load i32*, i32** %o114, align 4
  %98 = load i32, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
  %call135 = call double* @uint2double(i32* %97, i32 %98)
  store double* %call135, double** %o2double134, align 4
  %99 = load i32*, i32** %o114, align 4
  %100 = bitcast i32* %99 to i8*
  call void @free(i8* %100)
  store i32* null, i32** %o114, align 4
  %101 = load double*, double** %o2double134, align 4
  %102 = load i32, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
  %call137 = call i32* @order(double* %101, i32 %102, i1 zeroext false)
  store i32* %call137, i32** %ro136, align 4
  %103 = load double*, double** %o2double134, align 4
  %104 = bitcast double* %103 to i8*
  call void @free(i8* %104)
  store double* null, double** %o2double134, align 4
  %105 = load i32, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
  %mul138 = mul i32 8, %105
  %call139 = call noalias i8* @malloc(i32 %mul138)
  %106 = bitcast i8* %call139 to double*
  store double* %106, double** %q, align 4
  %107 = load double*, double** %q, align 4
  %cmp140 = icmp eq double* %107, null
  br i1 %cmp140, label %if.then142, label %if.end144

if.then142:                                       ; preds = %for.end133
  %call143 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([33 x i8], [33 x i8]* @.str.3, i32 0, i32 0), i8* getelementptr inbounds ([23 x i8], [23 x i8]* @.str.1, i32 0, i32 0), i32 318)
  call void @perror(i8* getelementptr inbounds ([1 x i8], [1 x i8]* @.str.2, i32 0, i32 0))
  call void @exit(i32 1) #5
  unreachable

if.end144:                                        ; preds = %for.end133
  %108 = load i32, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
  %mul145 = mul i32 8, %108
  %call146 = call noalias i8* @malloc(i32 %mul145)
  %109 = bitcast i8* %call146 to double*
  store double* %109, double** %pa, align 4
  %110 = load double*, double** %pa, align 4
  %cmp147 = icmp eq double* %110, null
  br i1 %cmp147, label %if.then149, label %if.end151

if.then149:                                       ; preds = %if.end144
  %call150 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([33 x i8], [33 x i8]* @.str.3, i32 0, i32 0), i8* getelementptr inbounds ([23 x i8], [23 x i8]* @.str.1, i32 0, i32 0), i32 324)
  call void @perror(i8* getelementptr inbounds ([1 x i8], [1 x i8]* @.str.2, i32 0, i32 0))
  call void @exit(i32 1) #5
  unreachable

if.end151:                                        ; preds = %if.end144
  %111 = load i32, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
  %conv152 = uitofp i32 %111 to double
  %112 = load double*, double** %p, align 4
  %arrayidx153 = getelementptr inbounds double, double* %112, i32 0
  %113 = load double, double* %arrayidx153, align 8
  %mul154 = fmul double %conv152, %113
  store double %mul154, double* %min, align 8
  store i32 1, i32* %index155, align 4
  br label %for.cond156

for.cond156:                                      ; preds = %for.inc168, %if.end151
  %114 = load i32, i32* %index155, align 4
  %115 = load i32, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
  %cmp157 = icmp ult i32 %114, %115
  br i1 %cmp157, label %for.body159, label %for.end170

for.body159:                                      ; preds = %for.cond156
  %116 = load i32, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
  %conv160 = uitofp i32 %116 to double
  %117 = load double*, double** %p, align 4
  %118 = load i32, i32* %index155, align 4
  %arrayidx161 = getelementptr inbounds double, double* %117, i32 %118
  %119 = load double, double* %arrayidx161, align 8
  %mul162 = fmul double %conv160, %119
  %120 = load i32, i32* %index155, align 4
  %add = add i32 1, %120
  %conv163 = uitofp i32 %add to double
  %div = fdiv double %mul162, %conv163
  store double %div, double* %TEMP, align 8
  %121 = load double, double* %TEMP, align 8
  %122 = load double, double* %min, align 8
  %cmp164 = fcmp olt double %121, %122
  br i1 %cmp164, label %if.then166, label %if.end167

if.then166:                                       ; preds = %for.body159
  %123 = load double, double* %TEMP, align 8
  store double %123, double* %min, align 8
  br label %if.end167

if.end167:                                        ; preds = %if.then166, %for.body159
  br label %for.inc168

for.inc168:                                       ; preds = %if.end167
  %124 = load i32, i32* %index155, align 4
  %inc169 = add i32 %124, 1
  store i32 %inc169, i32* %index155, align 4
  br label %for.cond156

for.end170:                                       ; preds = %for.cond156
  store i32 0, i32* %index171, align 4
  br label %for.cond172

for.cond172:                                      ; preds = %for.inc178, %for.end170
  %125 = load i32, i32* %index171, align 4
  %126 = load i32, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
  %cmp173 = icmp ult i32 %125, %126
  br i1 %cmp173, label %for.body175, label %for.end180

for.body175:                                      ; preds = %for.cond172
  %127 = load double, double* %min, align 8
  %128 = load double*, double** %pa, align 4
  %129 = load i32, i32* %index171, align 4
  %arrayidx176 = getelementptr inbounds double, double* %128, i32 %129
  store double %127, double* %arrayidx176, align 8
  %130 = load double, double* %min, align 8
  %131 = load double*, double** %q, align 4
  %132 = load i32, i32* %index171, align 4
  %arrayidx177 = getelementptr inbounds double, double* %131, i32 %132
  store double %130, double* %arrayidx177, align 8
  br label %for.inc178

for.inc178:                                       ; preds = %for.body175
  %133 = load i32, i32* %index171, align 4
  %inc179 = add i32 %133, 1
  store i32 %inc179, i32* %index171, align 4
  br label %for.cond172

for.end180:                                       ; preds = %for.cond172
  %134 = load i32, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
  %sub181 = sub i32 %134, 1
  store i32 %sub181, i32* %j, align 4
  br label %for.cond182

for.cond182:                                      ; preds = %for.inc272, %for.end180
  %135 = load i32, i32* %j, align 4
  %cmp183 = icmp uge i32 %135, 2
  br i1 %cmp183, label %for.body185, label %for.end273

for.body185:                                      ; preds = %for.cond182
  %136 = load i32, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
  %137 = load i32, i32* %j, align 4
  %sub186 = sub i32 %136, %137
  %call187 = call i32* @seq_len(i32 0, i32 %sub186)
  store i32* %call187, i32** %ij, align 4
  %138 = load i32, i32* %j, align 4
  %sub188 = sub i32 %138, 1
  store i32 %sub188, i32* %I2_LENGTH, align 4
  %139 = load i32, i32* %I2_LENGTH, align 4
  %mul189 = mul i32 %139, 4
  %call190 = call noalias i8* @malloc(i32 %mul189)
  %140 = bitcast i8* %call190 to i32*
  store i32* %140, i32** %i2, align 4
  store i32 0, i32* %i, align 4
  br label %for.cond191

for.cond191:                                      ; preds = %for.inc200, %for.body185
  %141 = load i32, i32* %i, align 4
  %142 = load i32, i32* %I2_LENGTH, align 4
  %cmp192 = icmp ult i32 %141, %142
  br i1 %cmp192, label %for.body194, label %for.end202

for.body194:                                      ; preds = %for.cond191
  %143 = load i32, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
  %144 = load i32, i32* %j, align 4
  %sub195 = sub i32 %143, %144
  %add196 = add i32 %sub195, 2
  %145 = load i32, i32* %i, align 4
  %add197 = add i32 %add196, %145
  %sub198 = sub i32 %add197, 1
  %146 = load i32*, i32** %i2, align 4
  %147 = load i32, i32* %i, align 4
  %arrayidx199 = getelementptr inbounds i32, i32* %146, i32 %147
  store i32 %sub198, i32* %arrayidx199, align 4
  br label %for.inc200

for.inc200:                                       ; preds = %for.body194
  %148 = load i32, i32* %i, align 4
  %inc201 = add i32 %148, 1
  store i32 %inc201, i32* %i, align 4
  br label %for.cond191

for.end202:                                       ; preds = %for.cond191
  %149 = load i32, i32* %j, align 4
  %conv203 = uitofp i32 %149 to double
  %150 = load double*, double** %p, align 4
  %151 = load i32*, i32** %i2, align 4
  %arrayidx204 = getelementptr inbounds i32, i32* %151, i32 0
  %152 = load i32, i32* %arrayidx204, align 4
  %arrayidx205 = getelementptr inbounds double, double* %150, i32 %152
  %153 = load double, double* %arrayidx205, align 8
  %mul206 = fmul double %conv203, %153
  %div207 = fdiv double %mul206, 2.000000e+00
  store double %div207, double* %q1, align 8
  store i32 1, i32* %i208, align 4
  br label %for.cond209

for.cond209:                                      ; preds = %for.inc224, %for.end202
  %154 = load i32, i32* %i208, align 4
  %155 = load i32, i32* %I2_LENGTH, align 4
  %cmp210 = icmp ult i32 %154, %155
  br i1 %cmp210, label %for.body212, label %for.end226

for.body212:                                      ; preds = %for.cond209
  %156 = load i32, i32* %j, align 4
  %conv213 = uitofp i32 %156 to double
  %157 = load double*, double** %p, align 4
  %158 = load i32*, i32** %i2, align 4
  %159 = load i32, i32* %i208, align 4
  %arrayidx214 = getelementptr inbounds i32, i32* %158, i32 %159
  %160 = load i32, i32* %arrayidx214, align 4
  %arrayidx215 = getelementptr inbounds double, double* %157, i32 %160
  %161 = load double, double* %arrayidx215, align 8
  %mul216 = fmul double %conv213, %161
  %162 = load i32, i32* %i208, align 4
  %add217 = add i32 2, %162
  %conv218 = uitofp i32 %add217 to double
  %div219 = fdiv double %mul216, %conv218
  store double %div219, double* %TEMP_Q1, align 8
  %163 = load double, double* %TEMP_Q1, align 8
  %164 = load double, double* %q1, align 8
  %cmp220 = fcmp olt double %163, %164
  br i1 %cmp220, label %if.then222, label %if.end223

if.then222:                                       ; preds = %for.body212
  %165 = load double, double* %TEMP_Q1, align 8
  store double %165, double* %q1, align 8
  br label %if.end223

if.end223:                                        ; preds = %if.then222, %for.body212
  br label %for.inc224

for.inc224:                                       ; preds = %if.end223
  %166 = load i32, i32* %i208, align 4
  %inc225 = add i32 %166, 1
  store i32 %inc225, i32* %i208, align 4
  br label %for.cond209

for.end226:                                       ; preds = %for.cond209
  store i32 0, i32* %i227, align 4
  br label %for.cond228

for.cond228:                                      ; preds = %for.inc241, %for.end226
  %167 = load i32, i32* %i227, align 4
  %168 = load i32, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
  %169 = load i32, i32* %j, align 4
  %sub229 = sub i32 %168, %169
  %add230 = add i32 %sub229, 1
  %cmp231 = icmp ult i32 %167, %add230
  br i1 %cmp231, label %for.body233, label %for.end243

for.body233:                                      ; preds = %for.cond228
  %170 = load i32, i32* %j, align 4
  %conv234 = uitofp i32 %170 to double
  %171 = load double*, double** %p, align 4
  %172 = load i32*, i32** %ij, align 4
  %173 = load i32, i32* %i227, align 4
  %arrayidx235 = getelementptr inbounds i32, i32* %172, i32 %173
  %174 = load i32, i32* %arrayidx235, align 4
  %arrayidx236 = getelementptr inbounds double, double* %171, i32 %174
  %175 = load double, double* %arrayidx236, align 8
  %mul237 = fmul double %conv234, %175
  %176 = load double, double* %q1, align 8
  %call238 = call double @min2(double %mul237, double %176)
  %177 = load double*, double** %q, align 4
  %178 = load i32*, i32** %ij, align 4
  %179 = load i32, i32* %i227, align 4
  %arrayidx239 = getelementptr inbounds i32, i32* %178, i32 %179
  %180 = load i32, i32* %arrayidx239, align 4
  %arrayidx240 = getelementptr inbounds double, double* %177, i32 %180
  store double %call238, double* %arrayidx240, align 8
  br label %for.inc241

for.inc241:                                       ; preds = %for.body233
  %181 = load i32, i32* %i227, align 4
  %inc242 = add i32 %181, 1
  store i32 %inc242, i32* %i227, align 4
  br label %for.cond228

for.end243:                                       ; preds = %for.cond228
  %182 = load i32*, i32** %ij, align 4
  %183 = bitcast i32* %182 to i8*
  call void @free(i8* %183)
  store i32* null, i32** %ij, align 4
  store i32 0, i32* %i244, align 4
  br label %for.cond245

for.cond245:                                      ; preds = %for.inc253, %for.end243
  %184 = load i32, i32* %i244, align 4
  %185 = load i32, i32* %I2_LENGTH, align 4
  %cmp246 = icmp ult i32 %184, %185
  br i1 %cmp246, label %for.body248, label %for.end255

for.body248:                                      ; preds = %for.cond245
  %186 = load double*, double** %q, align 4
  %187 = load i32, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
  %188 = load i32, i32* %j, align 4
  %sub249 = sub i32 %187, %188
  %arrayidx250 = getelementptr inbounds double, double* %186, i32 %sub249
  %189 = load double, double* %arrayidx250, align 8
  %190 = load double*, double** %q, align 4
  %191 = load i32*, i32** %i2, align 4
  %192 = load i32, i32* %i244, align 4
  %arrayidx251 = getelementptr inbounds i32, i32* %191, i32 %192
  %193 = load i32, i32* %arrayidx251, align 4
  %arrayidx252 = getelementptr inbounds double, double* %190, i32 %193
  store double %189, double* %arrayidx252, align 8
  br label %for.inc253

for.inc253:                                       ; preds = %for.body248
  %194 = load i32, i32* %i244, align 4
  %inc254 = add i32 %194, 1
  store i32 %inc254, i32* %i244, align 4
  br label %for.cond245

for.end255:                                       ; preds = %for.cond245
  %195 = load i32*, i32** %i2, align 4
  %196 = bitcast i32* %195 to i8*
  call void @free(i8* %196)
  store i32* null, i32** %i2, align 4
  store i32 0, i32* %i256, align 4
  br label %for.cond257

for.cond257:                                      ; preds = %for.inc269, %for.end255
  %197 = load i32, i32* %i256, align 4
  %198 = load i32, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
  %cmp258 = icmp ult i32 %197, %198
  br i1 %cmp258, label %for.body260, label %for.end271

for.body260:                                      ; preds = %for.cond257
  %199 = load double*, double** %pa, align 4
  %200 = load i32, i32* %i256, align 4
  %arrayidx261 = getelementptr inbounds double, double* %199, i32 %200
  %201 = load double, double* %arrayidx261, align 8
  %202 = load double*, double** %q, align 4
  %203 = load i32, i32* %i256, align 4
  %arrayidx262 = getelementptr inbounds double, double* %202, i32 %203
  %204 = load double, double* %arrayidx262, align 8
  %cmp263 = fcmp olt double %201, %204
  br i1 %cmp263, label %if.then265, label %if.end268

if.then265:                                       ; preds = %for.body260
  %205 = load double*, double** %q, align 4
  %206 = load i32, i32* %i256, align 4
  %arrayidx266 = getelementptr inbounds double, double* %205, i32 %206
  %207 = load double, double* %arrayidx266, align 8
  %208 = load double*, double** %pa, align 4
  %209 = load i32, i32* %i256, align 4
  %arrayidx267 = getelementptr inbounds double, double* %208, i32 %209
  store double %207, double* %arrayidx267, align 8
  br label %if.end268

if.end268:                                        ; preds = %if.then265, %for.body260
  br label %for.inc269

for.inc269:                                       ; preds = %if.end268
  %210 = load i32, i32* %i256, align 4
  %inc270 = add i32 %210, 1
  store i32 %inc270, i32* %i256, align 4
  br label %for.cond257

for.end271:                                       ; preds = %for.cond257
  br label %for.inc272

for.inc272:                                       ; preds = %for.end271
  %211 = load i32, i32* %j, align 4
  %dec = add i32 %211, -1
  store i32 %dec, i32* %j, align 4
  br label %for.cond182

for.end273:                                       ; preds = %for.cond182
  %212 = load double*, double** %p, align 4
  %213 = bitcast double* %212 to i8*
  call void @free(i8* %213)
  store double* null, double** %p, align 4
  store i32 0, i32* %index274, align 4
  br label %for.cond275

for.cond275:                                      ; preds = %for.inc282, %for.end273
  %214 = load i32, i32* %index274, align 4
  %215 = load i32, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
  %cmp276 = icmp ult i32 %214, %215
  br i1 %cmp276, label %for.body278, label %for.end284

for.body278:                                      ; preds = %for.cond275
  %216 = load double*, double** %pa, align 4
  %217 = load i32*, i32** %ro136, align 4
  %218 = load i32, i32* %index274, align 4
  %arrayidx279 = getelementptr inbounds i32, i32* %217, i32 %218
  %219 = load i32, i32* %arrayidx279, align 4
  %arrayidx280 = getelementptr inbounds double, double* %216, i32 %219
  %220 = load double, double* %arrayidx280, align 8
  %221 = load double*, double** %q, align 4
  %222 = load i32, i32* %index274, align 4
  %arrayidx281 = getelementptr inbounds double, double* %221, i32 %222
  store double %220, double* %arrayidx281, align 8
  br label %for.inc282

for.inc282:                                       ; preds = %for.body278
  %223 = load i32, i32* %index274, align 4
  %inc283 = add i32 %223, 1
  store i32 %inc283, i32* %index274, align 4
  br label %for.cond275

for.end284:                                       ; preds = %for.cond275
  %224 = load i32*, i32** %ro136, align 4
  %225 = bitcast i32* %224 to i8*
  call void @free(i8* %225)
  store i32* null, i32** %ro136, align 4
  %226 = load double*, double** %pa, align 4
  %227 = bitcast double* %226 to i8*
  call void @free(i8* %227)
  store double* null, double** %pa, align 4
  %228 = load double*, double** %q, align 4
  store double* %228, double** %retval, align 4
  br label %return

if.end285:                                        ; preds = %if.else109
  br label %if.end286

if.end286:                                        ; preds = %if.end285
  br label %if.end287

if.end287:                                        ; preds = %if.end286
  %229 = load double*, double** %PVALUES.addr, align 4
  %230 = load i32, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
  %call289 = call i32* @order(double* %229, i32 %230, i1 zeroext true)
  store i32* %call289, i32** %o288, align 4
  %231 = load i32*, i32** %o288, align 4
  %cmp290 = icmp eq i32* %231, null
  br i1 %cmp290, label %if.then292, label %if.end294

if.then292:                                       ; preds = %if.end287
  %call293 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([33 x i8], [33 x i8]* @.str.3, i32 0, i32 0), i8* getelementptr inbounds ([23 x i8], [23 x i8]* @.str.1, i32 0, i32 0), i32 398)
  call void @perror(i8* getelementptr inbounds ([1 x i8], [1 x i8]* @.str.2, i32 0, i32 0))
  call void @exit(i32 1) #5
  unreachable

if.end294:                                        ; preds = %if.end287
  %232 = load i32*, i32** %o288, align 4
  %233 = load i32, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
  %call295 = call double* @uint2double(i32* %232, i32 %233)
  store double* %call295, double** %o_double, align 4
  store i32 0, i32* %index296, align 4
  br label %for.cond297

for.cond297:                                      ; preds = %for.inc312, %if.end294
  %234 = load i32, i32* %index296, align 4
  %235 = load i32, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
  %cmp298 = icmp ult i32 %234, %235
  br i1 %cmp298, label %for.body300, label %for.end314

for.body300:                                      ; preds = %for.cond297
  %236 = load double*, double** %PVALUES.addr, align 4
  %237 = load i32, i32* %index296, align 4
  %arrayidx301 = getelementptr inbounds double, double* %236, i32 %237
  %238 = load double, double* %arrayidx301, align 8
  %cmp302 = fcmp olt double %238, 0.000000e+00
  br i1 %cmp302, label %if.then307, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %for.body300
  %239 = load double*, double** %PVALUES.addr, align 4
  %240 = load i32, i32* %index296, align 4
  %arrayidx304 = getelementptr inbounds double, double* %239, i32 %240
  %241 = load double, double* %arrayidx304, align 8
  %cmp305 = fcmp ogt double %241, 1.000000e+00
  br i1 %cmp305, label %if.then307, label %if.end311

if.then307:                                       ; preds = %lor.lhs.false, %for.body300
  %242 = load i32, i32* %index296, align 4
  %243 = load double*, double** %PVALUES.addr, align 4
  %244 = load i32, i32* %index296, align 4
  %arrayidx308 = getelementptr inbounds double, double* %243, i32 %244
  %245 = load double, double* %arrayidx308, align 8
  %call309 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([54 x i8], [54 x i8]* @.str.24, i32 0, i32 0), i32 %242, double %245)
  %call310 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([20 x i8], [20 x i8]* @.str.25, i32 0, i32 0), i8* getelementptr inbounds ([23 x i8], [23 x i8]* @.str.1, i32 0, i32 0), i32 406)
  call void @exit(i32 1) #5
  unreachable

if.end311:                                        ; preds = %lor.lhs.false
  br label %for.inc312

for.inc312:                                       ; preds = %if.end311
  %246 = load i32, i32* %index296, align 4
  %inc313 = add i32 %246, 1
  store i32 %inc313, i32* %index296, align 4
  br label %for.cond297

for.end314:                                       ; preds = %for.cond297
  %247 = load double*, double** %o_double, align 4
  %248 = load i32, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
  %call316 = call i32* @order(double* %247, i32 %248, i1 zeroext false)
  store i32* %call316, i32** %ro315, align 4
  %249 = load i32*, i32** %ro315, align 4
  %cmp317 = icmp eq i32* %249, null
  br i1 %cmp317, label %if.then319, label %if.end321

if.then319:                                       ; preds = %for.end314
  %call320 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([33 x i8], [33 x i8]* @.str.3, i32 0, i32 0), i8* getelementptr inbounds ([23 x i8], [23 x i8]* @.str.1, i32 0, i32 0), i32 413)
  call void @perror(i8* getelementptr inbounds ([1 x i8], [1 x i8]* @.str.2, i32 0, i32 0))
  call void @exit(i32 1) #5
  unreachable

if.end321:                                        ; preds = %for.end314
  %250 = load double*, double** %o_double, align 4
  %251 = bitcast double* %250 to i8*
  call void @free(i8* %251)
  store double* null, double** %o_double, align 4
  %252 = load i32, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
  %mul322 = mul i32 8, %252
  %call323 = call noalias i8* @malloc(i32 %mul322)
  %253 = bitcast i8* %call323 to double*
  store double* %253, double** %cummin_input, align 4
  %254 = load i16, i16* %TYPE, align 2
  %conv324 = sext i16 %254 to i32
  %cmp325 = icmp eq i32 %conv324, 0
  br i1 %cmp325, label %if.then327, label %if.else344

if.then327:                                       ; preds = %if.end321
  store i32 0, i32* %index328, align 4
  br label %for.cond329

for.cond329:                                      ; preds = %for.inc341, %if.then327
  %255 = load i32, i32* %index328, align 4
  %256 = load i32, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
  %cmp330 = icmp ult i32 %255, %256
  br i1 %cmp330, label %for.body332, label %for.end343

for.body332:                                      ; preds = %for.cond329
  %257 = load i32, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
  %conv333 = uitofp i32 %257 to double
  %258 = load i32, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
  %259 = load i32, i32* %index328, align 4
  %sub334 = sub i32 %258, %259
  %conv335 = uitofp i32 %sub334 to double
  %div336 = fdiv double %conv333, %conv335
  store double %div336, double* %NI, align 8
  %260 = load double, double* %NI, align 8
  %261 = load double*, double** %PVALUES.addr, align 4
  %262 = load i32*, i32** %o288, align 4
  %263 = load i32, i32* %index328, align 4
  %arrayidx337 = getelementptr inbounds i32, i32* %262, i32 %263
  %264 = load i32, i32* %arrayidx337, align 4
  %arrayidx338 = getelementptr inbounds double, double* %261, i32 %264
  %265 = load double, double* %arrayidx338, align 8
  %mul339 = fmul double %260, %265
  %266 = load double*, double** %cummin_input, align 4
  %267 = load i32, i32* %index328, align 4
  %arrayidx340 = getelementptr inbounds double, double* %266, i32 %267
  store double %mul339, double* %arrayidx340, align 8
  br label %for.inc341

for.inc341:                                       ; preds = %for.body332
  %268 = load i32, i32* %index328, align 4
  %inc342 = add i32 %268, 1
  store i32 %inc342, i32* %index328, align 4
  br label %for.cond329

for.end343:                                       ; preds = %for.cond329
  br label %if.end401

if.else344:                                       ; preds = %if.end321
  %269 = load i16, i16* %TYPE, align 2
  %conv345 = sext i16 %269 to i32
  %cmp346 = icmp eq i32 %conv345, 1
  br i1 %cmp346, label %if.then348, label %if.else380

if.then348:                                       ; preds = %if.else344
  store double 1.000000e+00, double* %q349, align 8
  store i32 2, i32* %index350, align 4
  br label %for.cond351

for.cond351:                                      ; preds = %for.inc359, %if.then348
  %270 = load i32, i32* %index350, align 4
  %271 = load i32, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
  %add352 = add i32 1, %271
  %cmp353 = icmp ult i32 %270, %add352
  br i1 %cmp353, label %for.body355, label %for.end361

for.body355:                                      ; preds = %for.cond351
  %272 = load i32, i32* %index350, align 4
  %conv356 = uitofp i32 %272 to double
  %div357 = fdiv double 1.000000e+00, %conv356
  %273 = load double, double* %q349, align 8
  %add358 = fadd double %273, %div357
  store double %add358, double* %q349, align 8
  br label %for.inc359

for.inc359:                                       ; preds = %for.body355
  %274 = load i32, i32* %index350, align 4
  %inc360 = add i32 %274, 1
  store i32 %inc360, i32* %index350, align 4
  br label %for.cond351

for.end361:                                       ; preds = %for.cond351
  store i32 0, i32* %index362, align 4
  br label %for.cond363

for.cond363:                                      ; preds = %for.inc377, %for.end361
  %275 = load i32, i32* %index362, align 4
  %276 = load i32, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
  %cmp364 = icmp ult i32 %275, %276
  br i1 %cmp364, label %for.body366, label %for.end379

for.body366:                                      ; preds = %for.cond363
  %277 = load i32, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
  %conv368 = uitofp i32 %277 to double
  %278 = load i32, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
  %279 = load i32, i32* %index362, align 4
  %sub369 = sub i32 %278, %279
  %conv370 = uitofp i32 %sub369 to double
  %div371 = fdiv double %conv368, %conv370
  store double %div371, double* %NI367, align 8
  %280 = load double, double* %q349, align 8
  %281 = load double, double* %NI367, align 8
  %mul372 = fmul double %280, %281
  %282 = load double*, double** %PVALUES.addr, align 4
  %283 = load i32*, i32** %o288, align 4
  %284 = load i32, i32* %index362, align 4
  %arrayidx373 = getelementptr inbounds i32, i32* %283, i32 %284
  %285 = load i32, i32* %arrayidx373, align 4
  %arrayidx374 = getelementptr inbounds double, double* %282, i32 %285
  %286 = load double, double* %arrayidx374, align 8
  %mul375 = fmul double %mul372, %286
  %287 = load double*, double** %cummin_input, align 4
  %288 = load i32, i32* %index362, align 4
  %arrayidx376 = getelementptr inbounds double, double* %287, i32 %288
  store double %mul375, double* %arrayidx376, align 8
  br label %for.inc377

for.inc377:                                       ; preds = %for.body366
  %289 = load i32, i32* %index362, align 4
  %inc378 = add i32 %289, 1
  store i32 %inc378, i32* %index362, align 4
  br label %for.cond363

for.end379:                                       ; preds = %for.cond363
  br label %if.end400

if.else380:                                       ; preds = %if.else344
  %290 = load i16, i16* %TYPE, align 2
  %conv381 = sext i16 %290 to i32
  %cmp382 = icmp eq i32 %conv381, 3
  br i1 %cmp382, label %if.then384, label %if.end399

if.then384:                                       ; preds = %if.else380
  store i32 0, i32* %index385, align 4
  br label %for.cond386

for.cond386:                                      ; preds = %for.inc396, %if.then384
  %291 = load i32, i32* %index385, align 4
  %292 = load i32, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
  %cmp387 = icmp ult i32 %291, %292
  br i1 %cmp387, label %for.body389, label %for.end398

for.body389:                                      ; preds = %for.cond386
  %293 = load i32, i32* %index385, align 4
  %add390 = add i32 %293, 1
  %conv391 = uitofp i32 %add390 to double
  %294 = load double*, double** %PVALUES.addr, align 4
  %295 = load i32*, i32** %o288, align 4
  %296 = load i32, i32* %index385, align 4
  %arrayidx392 = getelementptr inbounds i32, i32* %295, i32 %296
  %297 = load i32, i32* %arrayidx392, align 4
  %arrayidx393 = getelementptr inbounds double, double* %294, i32 %297
  %298 = load double, double* %arrayidx393, align 8
  %mul394 = fmul double %conv391, %298
  %299 = load double*, double** %cummin_input, align 4
  %300 = load i32, i32* %index385, align 4
  %arrayidx395 = getelementptr inbounds double, double* %299, i32 %300
  store double %mul394, double* %arrayidx395, align 8
  br label %for.inc396

for.inc396:                                       ; preds = %for.body389
  %301 = load i32, i32* %index385, align 4
  %inc397 = add i32 %301, 1
  store i32 %inc397, i32* %index385, align 4
  br label %for.cond386

for.end398:                                       ; preds = %for.cond386
  br label %if.end399

if.end399:                                        ; preds = %for.end398, %if.else380
  br label %if.end400

if.end400:                                        ; preds = %if.end399, %for.end379
  br label %if.end401

if.end401:                                        ; preds = %if.end400, %for.end343
  %302 = load i32*, i32** %o288, align 4
  %303 = bitcast i32* %302 to i8*
  call void @free(i8* %303)
  store i32* null, i32** %o288, align 4
  store double* null, double** %cummin_array, align 4
  %304 = load double*, double** %cummin_input, align 4
  %305 = load i32, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
  %call402 = call double* @cummin(double* %304, i32 %305)
  store double* %call402, double** %cummin_array, align 4
  %306 = load double*, double** %cummin_input, align 4
  %307 = bitcast double* %306 to i8*
  call void @free(i8* %307)
  store double* null, double** %cummin_input, align 4
  %308 = load double*, double** %cummin_array, align 4
  %309 = load i32, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
  %call404 = call double* @pminx(double* %308, i32 %309, double 1.000000e+00)
  store double* %call404, double** %pmin403, align 4
  %310 = load double*, double** %cummin_array, align 4
  %311 = bitcast double* %310 to i8*
  call void @free(i8* %311)
  store double* null, double** %cummin_array, align 4
  %312 = load i32, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
  %mul405 = mul i32 %312, 8
  %call406 = call noalias i8* @malloc(i32 %mul405)
  %313 = bitcast i8* %call406 to double*
  store double* %313, double** %q_array, align 4
  store i32 0, i32* %index407, align 4
  br label %for.cond408

for.cond408:                                      ; preds = %for.inc415, %if.end401
  %314 = load i32, i32* %index407, align 4
  %315 = load i32, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
  %cmp409 = icmp ult i32 %314, %315
  br i1 %cmp409, label %for.body411, label %for.end417

for.body411:                                      ; preds = %for.cond408
  %316 = load double*, double** %pmin403, align 4
  %317 = load i32*, i32** %ro315, align 4
  %318 = load i32, i32* %index407, align 4
  %arrayidx412 = getelementptr inbounds i32, i32* %317, i32 %318
  %319 = load i32, i32* %arrayidx412, align 4
  %arrayidx413 = getelementptr inbounds double, double* %316, i32 %319
  %320 = load double, double* %arrayidx413, align 8
  %321 = load double*, double** %q_array, align 4
  %322 = load i32, i32* %index407, align 4
  %arrayidx414 = getelementptr inbounds double, double* %321, i32 %322
  store double %320, double* %arrayidx414, align 8
  br label %for.inc415

for.inc415:                                       ; preds = %for.body411
  %323 = load i32, i32* %index407, align 4
  %inc416 = add i32 %323, 1
  store i32 %inc416, i32* %index407, align 4
  br label %for.cond408

for.end417:                                       ; preds = %for.cond408
  %324 = load i32*, i32** %ro315, align 4
  %325 = bitcast i32* %324 to i8*
  call void @free(i8* %325)
  store i32* null, i32** %ro315, align 4
  %326 = load double*, double** %pmin403, align 4
  %327 = bitcast double* %326 to i8*
  call void @free(i8* %327)
  store double* null, double** %pmin403, align 4
  %328 = load double*, double** %q_array, align 4
  store double* %328, double** %retval, align 4
  br label %return

return:                                           ; preds = %for.end417, %for.end284, %for.end108, %for.end
  %329 = load double*, double** %retval, align 4
  ret double* %329
}

declare i32 @strcasecmp(i8* %0, i8* %1) #1

; Function Attrs: noinline nounwind optnone
define hidden i32 @main() #0 {
entry:
  %retval = alloca i32, align 4
  %PVALUES = alloca [50 x double], align 16
  %CORRECT_ANSWERS = alloca [6 x [50 x double]], align 16
  %TYPES = alloca [6 x i8*], align 16
  %type = alloca i16, align 2
  %q = alloca double*, align 4
  %error = alloca double, align 8
  %i = alloca i32, align 4
  %this_error = alloca double, align 8
  store i32 0, i32* %retval, align 4
  %0 = bitcast [50 x double]* %PVALUES to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 16 %0, i8* align 16 bitcast ([50 x double]* @__const.main.PVALUES to i8*), i32 400, i1 false)
  %1 = bitcast [6 x [50 x double]]* %CORRECT_ANSWERS to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 16 %1, i8* align 16 bitcast ([6 x [50 x double]]* @__const.main.CORRECT_ANSWERS to i8*), i32 2400, i1 false)
  %2 = bitcast [6 x i8*]* %TYPES to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 16 %2, i8* align 16 bitcast ([6 x i8*]* @__const.main.TYPES to i8*), i32 24, i1 false)
  store i16 0, i16* %type, align 2
  br label %for.cond

for.cond:                                         ; preds = %for.inc19, %entry
  %3 = load i16, i16* %type, align 2
  %conv = zext i16 %3 to i32
  %cmp = icmp sle i32 %conv, 5
  br i1 %cmp, label %for.body, label %for.end21

for.body:                                         ; preds = %for.cond
  %arraydecay = getelementptr inbounds [50 x double], [50 x double]* %PVALUES, i32 0, i32 0
  %4 = load i16, i16* %type, align 2
  %idxprom = zext i16 %4 to i32
  %arrayidx = getelementptr inbounds [6 x i8*], [6 x i8*]* %TYPES, i32 0, i32 %idxprom
  %5 = load i8*, i8** %arrayidx, align 4
  %call = call double* @p_adjust(double* %arraydecay, i32 50, i8* %5)
  store double* %call, double** %q, align 4
  %6 = load double*, double** %q, align 4
  %arrayidx2 = getelementptr inbounds double, double* %6, i32 0
  %7 = load double, double* %arrayidx2, align 8
  %8 = load i16, i16* %type, align 2
  %idxprom3 = zext i16 %8 to i32
  %arrayidx4 = getelementptr inbounds [6 x [50 x double]], [6 x [50 x double]]* %CORRECT_ANSWERS, i32 0, i32 %idxprom3
  %arrayidx5 = getelementptr inbounds [50 x double], [50 x double]* %arrayidx4, i32 0, i32 0
  %9 = load double, double* %arrayidx5, align 16
  %sub = fsub double %7, %9
  %10 = call double @llvm.fabs.f64(double %sub)
  store double %10, double* %error, align 8
  store i32 1, i32* %i, align 4
  br label %for.cond6

for.cond6:                                        ; preds = %for.inc, %for.body
  %11 = load i32, i32* %i, align 4
  %cmp7 = icmp ult i32 %11, 50
  br i1 %cmp7, label %for.body9, label %for.end

for.body9:                                        ; preds = %for.cond6
  %12 = load double*, double** %q, align 4
  %13 = load i32, i32* %i, align 4
  %arrayidx10 = getelementptr inbounds double, double* %12, i32 %13
  %14 = load double, double* %arrayidx10, align 8
  %15 = load i16, i16* %type, align 2
  %idxprom11 = zext i16 %15 to i32
  %arrayidx12 = getelementptr inbounds [6 x [50 x double]], [6 x [50 x double]]* %CORRECT_ANSWERS, i32 0, i32 %idxprom11
  %16 = load i32, i32* %i, align 4
  %arrayidx13 = getelementptr inbounds [50 x double], [50 x double]* %arrayidx12, i32 0, i32 %16
  %17 = load double, double* %arrayidx13, align 8
  %sub14 = fsub double %14, %17
  %18 = call double @llvm.fabs.f64(double %sub14)
  store double %18, double* %this_error, align 8
  %19 = load double, double* %this_error, align 8
  %20 = load double, double* %error, align 8
  %add = fadd double %20, %19
  store double %add, double* %error, align 8
  br label %for.inc

for.inc:                                          ; preds = %for.body9
  %21 = load i32, i32* %i, align 4
  %inc = add i32 %21, 1
  store i32 %inc, i32* %i, align 4
  br label %for.cond6

for.end:                                          ; preds = %for.cond6
  %22 = load double*, double** %q, align 4
  call void @double_say(double* %22, i32 50)
  %23 = load double*, double** %q, align 4
  %24 = bitcast double* %23 to i8*
  call void @free(i8* %24)
  store double* null, double** %q, align 4
  %25 = load i16, i16* %type, align 2
  %conv15 = zext i16 %25 to i32
  %26 = load i16, i16* %type, align 2
  %idxprom16 = zext i16 %26 to i32
  %arrayidx17 = getelementptr inbounds [6 x i8*], [6 x i8*]* %TYPES, i32 0, i32 %idxprom16
  %27 = load i8*, i8** %arrayidx17, align 4
  %28 = load double, double* %error, align 8
  %call18 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([44 x i8], [44 x i8]* @.str.28, i32 0, i32 0), i32 %conv15, i8* %27, double %28)
  br label %for.inc19

for.inc19:                                        ; preds = %for.end
  %29 = load i16, i16* %type, align 2
  %inc20 = add i16 %29, 1
  store i16 %inc20, i16* %type, align 2
  br label %for.cond

for.end21:                                        ; preds = %for.cond
  ret i32 0
}

; Function Attrs: argmemonly nounwind willreturn
declare void @llvm.memcpy.p0i8.p0i8.i32(i8* noalias nocapture writeonly %0, i8* noalias nocapture readonly %1, i32 %2, i1 immarg %3) #3

; Function Attrs: nounwind readnone speculatable willreturn
declare double @llvm.fabs.f64(double %0) #4

attributes #0 = { noinline nounwind optnone "correctly-rounded-divide-sqrt-fp-math"="false" "disable-tail-calls"="false" "frame-pointer"="none" "less-precise-fpmad"="false" "min-legal-vector-width"="0" "no-infs-fp-math"="false" "no-jump-tables"="false" "no-nans-fp-math"="false" "no-signed-zeros-fp-math"="false" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="generic" "unsafe-fp-math"="false" "use-soft-float"="false" }
attributes #1 = { "correctly-rounded-divide-sqrt-fp-math"="false" "disable-tail-calls"="false" "frame-pointer"="none" "less-precise-fpmad"="false" "no-infs-fp-math"="false" "no-nans-fp-math"="false" "no-signed-zeros-fp-math"="false" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="generic" "unsafe-fp-math"="false" "use-soft-float"="false" }
attributes #2 = { noreturn "correctly-rounded-divide-sqrt-fp-math"="false" "disable-tail-calls"="false" "frame-pointer"="none" "less-precise-fpmad"="false" "no-infs-fp-math"="false" "no-nans-fp-math"="false" "no-signed-zeros-fp-math"="false" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="generic" "unsafe-fp-math"="false" "use-soft-float"="false" }
attributes #3 = { argmemonly nounwind willreturn }
attributes #4 = { nounwind readnone speculatable willreturn }
attributes #5 = { noreturn }

!llvm.module.flags = !{!0}
!llvm.ident = !{!1}

!0 = !{i32 1, !"wchar_size", i32 4}
!1 = !{!"clang version 11.0.0 (https://github.com/Jacarte/llvm-project.git 0f6dea67136cc1e0b3d200eb2bb165628970c44b)"}

; extracted candidates

; *****
; For LLVM instruction:
;  %0 = load i32, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %cmp = icmp ult i32 %0, 1
; Looking for a replacement for:
%0:i32 = var
%1:i1 = ult %0, 1:i32
infer %1

; *****
; For LLVM instruction:
;  %1 = load i32, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %mul = mul i32 8, %1
; Looking for a replacement for:
%0:i32 = var
%1:i32 = mul 8:i32, %0
infer %1

; *****
; For LLVM instruction:
;  %cmp3 = icmp eq double* %3, null
; Looking for a replacement for:
%0:i32 = var
%1:i1 = eq 0:i32, %0
infer %1

; *****
; For LLVM instruction:
;  %6 = load i32, i32* %i, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %7 = load i32, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %cmp7 = icmp ult i32 %6, %7
; Looking for a replacement for:
%0:i32 = var
%1:i32 = var
%2:i1 = ult %0, %1
infer %2

; *****
; For LLVM instruction:
;  %9 = load i32, i32* %i, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %cmp9 = fcmp olt double %10, %11
; Looking for a replacement for:
%0:i1 = var
infer %0

; *****
; For LLVM instruction:
;  %13 = load i32, i32* %i, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %17 = load i32, i32* %i, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %18 = load i32, i32* %i, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %inc = add i32 %18, 1
; Looking for a replacement for:
%0:i32 = var
%1:i32 = add 1:i32, %0
infer %1
got 2 candidates from LHS

-------------------------------------------------
%0:i32 = var
%1:i1 = ult %0, 1:i32
infer %1


--------------------------------
guess 0

%0:i1 = var ; reservedconst_1

Cost = 0
first query is SAT, returning the model:
reservedconst_1: -1
0 th attempt: second query is SAT-- constant doesn't work
first query is SAT, returning the model:
reservedconst_1: 0
1 th attempt: second query is SAT-- constant doesn't work
first query is UNSAT-- no more guesses
Dataflow Pruned 0/0
There are 1 Guesses
There are 0 RHSs before deduplication
There are 0 RHSs after deduplication
#########################################################
; exiting Souper's runOnFunction() for cummin()

; entering Souper's runOnFunction() for cummax()

; ModuleID = './P-value_correction.c.bc'
source_filename = "./P-value_correction.c"
target datalayout = "e-m:e-p:32:32-i64:64-n32:64-S128"
target triple = "wasm32-unknown-wasi"

@.str = private unnamed_addr constant [29 x i8] c"malloc failed at %s line %u\0A\00", align 1
@.str.1 = private unnamed_addr constant [23 x i8] c"./P-value_correction.c\00", align 1
@.str.2 = private unnamed_addr constant [1 x i8] zeroinitializer, align 1
@base_arr = hidden global double* null, align 4
@.str.3 = private unnamed_addr constant [33 x i8] c"failed to malloc at %s line %u.\0A\00", align 1
@.str.4 = private unnamed_addr constant [48 x i8] c"cummin function requires at least one element.\0A\00", align 1
@.str.5 = private unnamed_addr constant [22 x i8] c"Failed at %s line %u\0A\00", align 1
@.str.6 = private unnamed_addr constant [41 x i8] c"function requires at least one element.\0A\00", align 1
@.str.7 = private unnamed_addr constant [37 x i8] c"pmin requires at least one element.\0A\00", align 1
@.str.8 = private unnamed_addr constant [7 x i8] c"[1] %e\00", align 1
@.str.9 = private unnamed_addr constant [7 x i8] c" %.10f\00", align 1
@.str.10 = private unnamed_addr constant [6 x i8] c"\0A[%u]\00", align 1
@.str.11 = private unnamed_addr constant [2 x i8] c"\0A\00", align 1
@.str.12 = private unnamed_addr constant [34 x i8] c"Failure to malloc at %s line %u.\0A\00", align 1
@.str.13 = private unnamed_addr constant [41 x i8] c"p_adjust requires at least one element.\0A\00", align 1
@.str.14 = private unnamed_addr constant [3 x i8] c"BH\00", align 1
@.str.15 = private unnamed_addr constant [4 x i8] c"fdr\00", align 1
@.str.16 = private unnamed_addr constant [3 x i8] c"by\00", align 1
@.str.17 = private unnamed_addr constant [11 x i8] c"Bonferroni\00", align 1
@.str.18 = private unnamed_addr constant [9 x i8] c"hochberg\00", align 1
@.str.19 = private unnamed_addr constant [5 x i8] c"holm\00", align 1
@.str.20 = private unnamed_addr constant [7 x i8] c"hommel\00", align 1
@.str.21 = private unnamed_addr constant [44 x i8] c"%s doesn't match any accepted FDR methods.\0A\00", align 1
@.str.22 = private unnamed_addr constant [42 x i8] c"%g is outside of the interval I planned.\0A\00", align 1
@.str.23 = private unnamed_addr constant [23 x i8] c"Failure at %s line %u\0A\00", align 1
@.str.24 = private unnamed_addr constant [54 x i8] c"array[%u] = %lf, which is outside the interval [0,1]\0A\00", align 1
@.str.25 = private unnamed_addr constant [20 x i8] c"died at %s line %u\0A\00", align 1
@__const.main.PVALUES = private unnamed_addr constant [50 x double] [double 0x3FDD04160F35FDE9, double 0x3FE758E721E2A8D7, double 0x3FB96FAC8B38D8BA, double 0x3FB73E71D5B04B37, double 0x3FC710AB48EE865B, double 0x3FEC01D953C3CC73, double 0x3FD2B3C4BE0A922A, double 0x3FED2B5A568DAB4F, double 0x3FDBE08D73F16964, double 0x3FE10A218C41C242, double 0x3FDF8810DB1996AA, double 0x3FE291CCB11E1A9D, double 0x3FD64E8C550D788F, double 7.883130e-01, double 0x3FD177B2BF048D2D, double 0x3FEB3543434BAF2B, double 0x3FDB50EAD41ED0A6, double 0x3FE49D4AFF01D33F, double 0x3FD364C9AE345B51, double 0x3FA99BA35F15394D, double 3.194810e-01, double 0x3FE941E405CE761A, double 0x3FEFF94F77369843, double 0x3FC65847BFB23217, double 0x3FECEB8879B6A543, double 0x3FBEAF00332BA677, double 0x3FD96207C7749E38, double 0x3F8CC02620502C93, double 0x3FE773A5B45A0F40, double 0x3FB1642C24762C01, double 4.040730e-03, double 0x3F33E11D79A90777, double 0x3F870B02BD749528, double 0x3F98521BD6A0353F, double 0x3F4310F26148FFAA, double 0x3F3427CD76006778, double 0x3F80E60AFB1F8A4E, double 0x3F5639B74A9E4DA2, double 0x3F8BDDF74195769F, double 0x3F38ABEE3BFA8581, double 0x3EF2E2E96B5466FE, double 0x3E90CE9F65B58A88, double 0x3FA0F2D097879B95, double 0x3F834EE7216A6684, double 0x3F4CCE8DBB40BD9D, double 0x3F2C8B969590F2ED, double 0x3F4FC31F7F1541AD, double 6.610250e-05, double 0x3F9DB44EA6AC26BA, double 5.735490e-03], align 16
@__const.main.CORRECT_ANSWERS = private unnamed_addr constant [6 x [50 x double]] [[50 x double] [double 0x3FE39AFA2199ADBC, double 8.521710e-01, double 0x3FC96FAC6045BAF5, double 0x3FC83660E51D25AB, double 0x3FD498068702BE20, double 0x3FEDC3BF727136A4, double 4.870370e-01, double 0x3FEDC3BF727136A4, double 0x3FE35BF08BEEB62C, double 0x3FE5D879DEE92F03, double 0x3FE4BE91D656B94A, double 0x3FE7363FC28DAEAA, double 0x3FE0E62C4F13638A, double 0x3FEC1052C8FAB035, double 0x3FDE1DD2E43E029A, double 0x3FED92EFFC7CBDC1, double 0x3FE35BF08BEEB62C, double 0x3FE923B90CFC67C5, double 0x3FDF47B8FC357024, double 0x3FBD1996A9FB10AD, double 0x3FDFF2B6D6C14255, double 0x3FEC1052C8FAB035, double 0x3FEFF94F77369843, double 0x3FD498068702BE20, double 0x3FEDC3BF727136A4, double 0x3FCD80E2E96EC403, double 0x3FE2A9F6A93F290B, double 0x3FA3F736D8AF2E2B, double 8.521710e-01, double 0x3FC2E751B350FAC4, double 0x3F913D8E55EE9F05, double 0x3F64FECB88BB3633, double 0x3FA2009A03CCBE34, double 0x3FB0001FB57CF9FC, double 0x3F6DCA7ADA5E274A, double 0x3F64FECB88BB3633, double 0x3F9E2D13B467D120, double 0x3F7941963399C6A1, double 0x3FA3F736D8AF2E2B, double 0x3F6607390CEF853C, double 0x3F3D828C80BA213A, double 0x3EEA42D90EEBA875, double 0x3FB42D4181AA8F8B, double 0x3FA01715F12E0018, double 0x3F73D9F3AF6D490C, double 0x3F64FECB88BB3633, double 0x3F73D9F3AF6D490C, double 0x3F520CE5F51A7C61, double 0x3FB290B112B20952, double 0x3F9696C95AA76B69], [50 x double] [double 1.000000e+00, double 1.000000e+00, double 0x3FEC9C56E33BA41B, double 0x3FEB3BF21E95ED3D, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 0x3FE05DA74553C727, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 0x3FC675198790829A, double 1.000000e+00, double 0x3FE54345648E1F12, double 0x3FB3645F501CA2F9, double 0x3F879D934E50F0DE, double 0x3FC43FC3646E3EA2, double 0x3FD1FF539D36064C, double 0x3F90C123206B855F, double 0x3F879D934E50F0DE, double 0x3FC0F8967F32E606, double 0x3F9C6880470D2FBE, double 0x3FC675198790829A, double 0x3F88C70105E47082, double 2.025930e-03, double 0x3F0D89DE4FA8F818, double 0x3FD6B1E2D11B1027, double 0x3FC219271872BD8D, double 0x3F96542FAD16CEF9, double 0x3F879D934E50F0DE, double 0x3F96542FAD16CEF9, double 0x3F744D9816EB319A, double 0x3FD4E1D5728DBC16, double 0x3FB9687C40426555], [50 x double] [double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 0x3FE6761DC93EA2D3, double 1.000000e+00, double 1.000000e+00, double 0x3FC9DC55000C953A, double 0x3F8F0FBD624BA499, double 0x3FE2009A24031487, double 1.000000e+00, double 0x3F9DCA7AB8020F7A, double 0x3F8F7E310860A1AB, double 0x3FDA677128614819, double 6.782670e-02, double 6.803480e-01, double 0x3F9346521EDBB84D, double 0x3F4D828CB7B3E0EE, double 0x3EEA42D90EEBA875, double 1.000000e+00, double 4.713920e-01, double 0x3FA6815EE53DB1E7, double 0x3F864D0CF90CC6B8, double 0x3FA8D0709B489B4F, double 0x3F6B1359791819D2, double 1.000000e+00, double 0x3FD25A836EB4E981], [50 x double] [double 0x3FEFF94F77369843, double 0x3FEFF94F77369843, double 0x3FEFF94F77369843, double 0x3FEFF94F77369843, double 0x3FEFF94F77369843, double 0x3FEFF94F77369843, double 0x3FEFF94F77369843, double 0x3FEFF94F77369843, double 0x3FEFF94F77369843, double 0x3FEFF94F77369843, double 0x3FEFF94F77369843, double 0x3FEFF94F77369843, double 0x3FEFF94F77369843, double 0x3FEFF94F77369843, double 0x3FEFF94F77369843, double 0x3FEFF94F77369843, double 0x3FEFF94F77369843, double 0x3FEFF94F77369843, double 0x3FEFF94F77369843, double 0x3FEFF94F77369843, double 0x3FEFF94F77369843, double 0x3FEFF94F77369843, double 0x3FEFF94F77369843, double 0x3FEFF94F77369843, double 0x3FEFF94F77369843, double 0x3FEFF94F77369843, double 0x3FEFF94F77369843, double 0x3FDDA6274695E687, double 0x3FEFF94F77369843, double 0x3FEFF94F77369843, double 0x3FC42BDC26DCE39B, double 0x3F8C57F9104CA951, double 0x3FD9340AC9879DEF, double 7.600230e-01, double 0x3F999EC5A86B439B, double 0x3F8C57F9104CA951, double 0x3FD389FCD90412B4, double 0x3FABC8251D45E10B, double 0x3FDD9BD68ABBB045, double 0x3F90F633F956C386, double 8.825610e-04, double 0x3EEA42D90EEBA875, double 0x3FEFC7471C1E43B8, double 0x3FD5B8C4014C305A, double 0x3FA2E78CEC8D068E, double 0x3F84F6832995A599, double 0x3FA459002162FC24, double 3.172920e-03, double 8.992520e-01, double 0x3FCBE5BD5E9AC00A], [50 x double] [double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 0x3FDDA6274695E687, double 1.000000e+00, double 1.000000e+00, double 0x3FC42BDC26DCE39B, double 0x3F8C939AFCF101E0, double 0x3FD9340AC9879DEF, double 7.600230e-01, double 0x3F999EC5A86B439B, double 0x3F8C939AFCF101E0, double 0x3FD389FCD90412B4, double 0x3FABC8251D45E10B, double 0x3FDD9BD68ABBB045, double 0x3F90F633F956C386, double 8.825610e-04, double 0x3EEA42D90EEBA875, double 0x3FEFC7471C1E43B8, double 0x3FD5B8C4014C305A, double 0x3FA2E78CEC8D068E, double 0x3F84F6832995A599, double 0x3FA459002162FC24, double 3.172920e-03, double 8.992520e-01, double 0x3FCBE5BD5E9AC00A], [50 x double] [double 0x3FEFF94F77369843, double 0x3FEFF94F77369843, double 0x3FEFF94F77369843, double 0x3FEFF5DC908F2EDD, double 0x3FEFF94F77369843, double 0x3FEFF94F77369843, double 0x3FEFF94F77369843, double 0x3FEFF94F77369843, double 0x3FEFF94F77369843, double 0x3FEFF94F77369843, double 0x3FEFF94F77369843, double 0x3FEFF94F77369843, double 0x3FEFF94F77369843, double 0x3FEFF94F77369843, double 0x3FEFF94F77369843, double 0x3FEFF94F77369843, double 0x3FEFF94F77369843, double 0x3FEFF94F77369843, double 0x3FEFF94F77369843, double 0x3FEEB45F17BD8BE7, double 0x3FEFF94F77369843, double 0x3FEFF94F77369843, double 0x3FEFF94F77369843, double 0x3FEFF94F77369843, double 0x3FEFF94F77369843, double 0x3FEFF94F77369843, double 0x3FEFF94F77369843, double 0x3FDBDA250F840182, double 0x3FEFF94F77369843, double 0x3FEF40BC1D52205E, double 0x3FC21A3BEB689947, double 1.304340e-02, double 0x3FD69916517B1CD7, double 0x3FE60A69453DF7B2, double 0x3F986DB666D9D3C6, double 0x3F8B157BBD3AB385, double 2.722920e-01, double 0x3FABC8251D45E10B, double 0x3FDAFF07B27BE8AF, double 0x3F9030D45E3B9F93, double 8.825610e-04, double 0x3EEA42D90EEBA875, double 0x3FEBFACC1948A662, double 0x3FD34EE6EDE042CB, double 0x3FA2011883DA6A9A, double 0x3F839FF779153716, double 0x3FA3D9F3D1C960DD, double 3.172920e-03, double 0x3FE9FDC4BC5D1301, double 0x3FC8F5FAC3801CF1]], align 16
@.str.26 = private unnamed_addr constant [3 x i8] c"bh\00", align 1
@.str.27 = private unnamed_addr constant [11 x i8] c"bonferroni\00", align 1
@__const.main.TYPES = private unnamed_addr constant [6 x i8*] [i8* getelementptr inbounds ([3 x i8], [3 x i8]* @.str.26, i32 0, i32 0), i8* getelementptr inbounds ([3 x i8], [3 x i8]* @.str.16, i32 0, i32 0), i8* getelementptr inbounds ([11 x i8], [11 x i8]* @.str.27, i32 0, i32 0), i8* getelementptr inbounds ([9 x i8], [9 x i8]* @.str.18, i32 0, i32 0), i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.19, i32 0, i32 0), i8* getelementptr inbounds ([7 x i8], [7 x i8]* @.str.20, i32 0, i32 0)], align 16
@.str.28 = private unnamed_addr constant [44 x i8] c"\0Atype %u = '%s' has cumulative error of %g\0A\00", align 1
@llvm.used = appending global [1 x i8*] [i8* bitcast (i32 ()* @__main_void to i8*)], section "llvm.metadata"

@__main_void = alias i32 (), i32 ()* @main

; Function Attrs: noinline nounwind optnone
define hidden i32* @seq_len(i32 %START, i32 %END) #0 {
entry:
  %retval = alloca i32*, align 4
  %START.addr = alloca i32, align 4
  %END.addr = alloca i32, align 4
  %start = alloca i32, align 4
  %end = alloca i32, align 4
  %sequence = alloca i32*, align 4
  %i = alloca i32, align 4
  %LENGTH = alloca i32, align 4
  %sequence10 = alloca i32*, align 4
  %index = alloca i32, align 4
  %index28 = alloca i32, align 4
  store i32 %START, i32* %START.addr, align 4
  store i32 %END, i32* %END.addr, align 4
  %0 = load i32, i32* %START.addr, align 4
  store i32 %0, i32* %start, align 4
  %1 = load i32, i32* %END.addr, align 4
  store i32 %1, i32* %end, align 4
  %2 = load i32, i32* %START.addr, align 4
  %3 = load i32, i32* %END.addr, align 4
  %cmp = icmp eq i32 %2, %3
  br i1 %cmp, label %if.then, label %if.end6

if.then:                                          ; preds = %entry
  %4 = load i32, i32* %end, align 4
  %add = add i32 %4, 1
  %mul = mul i32 %add, 4
  %call = call noalias i8* @malloc(i32 %mul)
  %5 = bitcast i8* %call to i32*
  store i32* %5, i32** %sequence, align 4
  %6 = load i32*, i32** %sequence, align 4
  %cmp1 = icmp eq i32* %6, null
  br i1 %cmp1, label %if.then2, label %if.end

if.then2:                                         ; preds = %if.then
  %call3 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([29 x i8], [29 x i8]* @.str, i32 0, i32 0), i8* getelementptr inbounds ([23 x i8], [23 x i8]* @.str.1, i32 0, i32 0), i32 15)
  call void @perror(i8* getelementptr inbounds ([1 x i8], [1 x i8]* @.str.2, i32 0, i32 0))
  call void @exit(i32 1) #5
  unreachable

if.end:                                           ; preds = %if.then
  store i32 0, i32* %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.end
  %7 = load i32, i32* %i, align 4
  %8 = load i32, i32* %end, align 4
  %cmp4 = icmp ult i32 %7, %8
  br i1 %cmp4, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %9 = load i32, i32* %i, align 4
  %add5 = add i32 %9, 1
  %10 = load i32*, i32** %sequence, align 4
  %11 = load i32, i32* %i, align 4
  %arrayidx = getelementptr inbounds i32, i32* %10, i32 %11
  store i32 %add5, i32* %arrayidx, align 4
  br label %for.inc

for.inc:                                          ; preds = %for.body
  %12 = load i32, i32* %i, align 4
  %inc = add i32 %12, 1
  store i32 %inc, i32* %i, align 4
  br label %for.cond

for.end:                                          ; preds = %for.cond
  %13 = load i32*, i32** %sequence, align 4
  store i32* %13, i32** %retval, align 4
  br label %return

if.end6:                                          ; preds = %entry
  %14 = load i32, i32* %START.addr, align 4
  %15 = load i32, i32* %END.addr, align 4
  %cmp7 = icmp ugt i32 %14, %15
  br i1 %cmp7, label %if.then8, label %if.end9

if.then8:                                         ; preds = %if.end6
  %16 = load i32, i32* %START.addr, align 4
  store i32 %16, i32* %end, align 4
  %17 = load i32, i32* %END.addr, align 4
  store i32 %17, i32* %start, align 4
  br label %if.end9

if.end9:                                          ; preds = %if.then8, %if.end6
  %18 = load i32, i32* %end, align 4
  %19 = load i32, i32* %start, align 4
  %sub = sub i32 %18, %19
  store i32 %sub, i32* %LENGTH, align 4
  %20 = load i32, i32* %LENGTH, align 4
  %add11 = add i32 1, %20
  %mul12 = mul i32 %add11, 4
  %call13 = call noalias i8* @malloc(i32 %mul12)
  %21 = bitcast i8* %call13 to i32*
  store i32* %21, i32** %sequence10, align 4
  %22 = load i32*, i32** %sequence10, align 4
  %cmp14 = icmp eq i32* %22, null
  br i1 %cmp14, label %if.then15, label %if.end17

if.then15:                                        ; preds = %if.end9
  %call16 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([29 x i8], [29 x i8]* @.str, i32 0, i32 0), i8* getelementptr inbounds ([23 x i8], [23 x i8]* @.str.1, i32 0, i32 0), i32 31)
  call void @perror(i8* getelementptr inbounds ([1 x i8], [1 x i8]* @.str.2, i32 0, i32 0))
  call void @exit(i32 1) #5
  unreachable

if.end17:                                         ; preds = %if.end9
  %23 = load i32, i32* %START.addr, align 4
  %24 = load i32, i32* %END.addr, align 4
  %cmp18 = icmp ult i32 %23, %24
  br i1 %cmp18, label %if.then19, label %if.else

if.then19:                                        ; preds = %if.end17
  store i32 0, i32* %index, align 4
  br label %for.cond20

for.cond20:                                       ; preds = %for.inc25, %if.then19
  %25 = load i32, i32* %index, align 4
  %26 = load i32, i32* %LENGTH, align 4
  %cmp21 = icmp ule i32 %25, %26
  br i1 %cmp21, label %for.body22, label %for.end27

for.body22:                                       ; preds = %for.cond20
  %27 = load i32, i32* %start, align 4
  %28 = load i32, i32* %index, align 4
  %add23 = add i32 %27, %28
  %29 = load i32*, i32** %sequence10, align 4
  %30 = load i32, i32* %index, align 4
  %arrayidx24 = getelementptr inbounds i32, i32* %29, i32 %30
  store i32 %add23, i32* %arrayidx24, align 4
  br label %for.inc25

for.inc25:                                        ; preds = %for.body22
  %31 = load i32, i32* %index, align 4
  %inc26 = add i32 %31, 1
  store i32 %inc26, i32* %index, align 4
  br label %for.cond20

for.end27:                                        ; preds = %for.cond20
  br label %if.end37

if.else:                                          ; preds = %if.end17
  store i32 0, i32* %index28, align 4
  br label %for.cond29

for.cond29:                                       ; preds = %for.inc34, %if.else
  %32 = load i32, i32* %index28, align 4
  %33 = load i32, i32* %LENGTH, align 4
  %cmp30 = icmp ule i32 %32, %33
  br i1 %cmp30, label %for.body31, label %for.end36

for.body31:                                       ; preds = %for.cond29
  %34 = load i32, i32* %end, align 4
  %35 = load i32, i32* %index28, align 4
  %sub32 = sub i32 %34, %35
  %36 = load i32*, i32** %sequence10, align 4
  %37 = load i32, i32* %index28, align 4
  %arrayidx33 = getelementptr inbounds i32, i32* %36, i32 %37
  store i32 %sub32, i32* %arrayidx33, align 4
  br label %for.inc34

for.inc34:                                        ; preds = %for.body31
  %38 = load i32, i32* %index28, align 4
  %inc35 = add i32 %38, 1
  store i32 %inc35, i32* %index28, align 4
  br label %for.cond29

for.end36:                                        ; preds = %for.cond29
  br label %if.end37

if.end37:                                         ; preds = %for.end36, %for.end27
  %39 = load i32*, i32** %sequence10, align 4
  store i32* %39, i32** %retval, align 4
  br label %return

return:                                           ; preds = %if.end37, %for.end
  %40 = load i32*, i32** %retval, align 4
  ret i32* %40
}

declare noalias i8* @malloc(i32 %0) #1

declare i32 @printf(i8* %0, ...) #1

declare void @perror(i8* %0) #1

; Function Attrs: noreturn
declare void @exit(i32 %0) #2

; Function Attrs: noinline nounwind optnone
define hidden i32* @order(double* noalias %ARRAY, i32 %SIZE, i1 zeroext %DECREASING) #0 {
entry:
  %ARRAY.addr = alloca double*, align 4
  %SIZE.addr = alloca i32, align 4
  %DECREASING.addr = alloca i8, align 1
  %idx = alloca i32*, align 4
  %i = alloca i32, align 4
  store double* %ARRAY, double** %ARRAY.addr, align 4
  store i32 %SIZE, i32* %SIZE.addr, align 4
  %frombool = zext i1 %DECREASING to i8
  store i8 %frombool, i8* %DECREASING.addr, align 1
  %0 = load i32, i32* %SIZE.addr, align 4
  %mul = mul i32 %0, 4
  %call = call noalias i8* @malloc(i32 %mul)
  %1 = bitcast i8* %call to i32*
  store i32* %1, i32** %idx, align 4
  %2 = load i32*, i32** %idx, align 4
  %cmp = icmp eq i32* %2, null
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %call1 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([33 x i8], [33 x i8]* @.str.3, i32 0, i32 0), i8* getelementptr inbounds ([23 x i8], [23 x i8]* @.str.1, i32 0, i32 0), i32 77)
  call void @perror(i8* getelementptr inbounds ([1 x i8], [1 x i8]* @.str.2, i32 0, i32 0))
  call void @exit(i32 1) #5
  unreachable

if.end:                                           ; preds = %entry
  %3 = load i32, i32* %SIZE.addr, align 4
  %mul2 = mul i32 8, %3
  %call3 = call noalias i8* @malloc(i32 %mul2)
  %4 = bitcast i8* %call3 to double*
  store double* %4, double** @base_arr, align 4
  %5 = load double*, double** @base_arr, align 4
  %cmp4 = icmp eq double* %5, null
  br i1 %cmp4, label %if.then5, label %if.end7

if.then5:                                         ; preds = %if.end
  %call6 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([33 x i8], [33 x i8]* @.str.3, i32 0, i32 0), i8* getelementptr inbounds ([23 x i8], [23 x i8]* @.str.1, i32 0, i32 0), i32 83)
  call void @perror(i8* getelementptr inbounds ([1 x i8], [1 x i8]* @.str.2, i32 0, i32 0))
  call void @exit(i32 1) #5
  unreachable

if.end7:                                          ; preds = %if.end
  store i32 0, i32* %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.end7
  %6 = load i32, i32* %i, align 4
  %7 = load i32, i32* %SIZE.addr, align 4
  %cmp8 = icmp ult i32 %6, %7
  br i1 %cmp8, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %8 = load double*, double** %ARRAY.addr, align 4
  %9 = load i32, i32* %i, align 4
  %arrayidx = getelementptr inbounds double, double* %8, i32 %9
  %10 = load double, double* %arrayidx, align 8
  %11 = load double*, double** @base_arr, align 4
  %12 = load i32, i32* %i, align 4
  %arrayidx9 = getelementptr inbounds double, double* %11, i32 %12
  store double %10, double* %arrayidx9, align 8
  %13 = load i32, i32* %i, align 4
  %14 = load i32*, i32** %idx, align 4
  %15 = load i32, i32* %i, align 4
  %arrayidx10 = getelementptr inbounds i32, i32* %14, i32 %15
  store i32 %13, i32* %arrayidx10, align 4
  br label %for.inc

for.inc:                                          ; preds = %for.body
  %16 = load i32, i32* %i, align 4
  %inc = add i32 %16, 1
  store i32 %inc, i32* %i, align 4
  br label %for.cond

for.end:                                          ; preds = %for.cond
  %17 = load i8, i8* %DECREASING.addr, align 1
  %tobool = trunc i8 %17 to i1
  %conv = zext i1 %tobool to i32
  %cmp11 = icmp eq i32 %conv, 0
  br i1 %cmp11, label %if.then13, label %if.else

if.then13:                                        ; preds = %for.end
  %18 = load i32*, i32** %idx, align 4
  %19 = bitcast i32* %18 to i8*
  %20 = load i32, i32* %SIZE.addr, align 4
  call void @qsort(i8* %19, i32 %20, i32 4, i32 (i8*, i8*)* @compar_decrease)
  br label %if.end20

if.else:                                          ; preds = %for.end
  %21 = load i8, i8* %DECREASING.addr, align 1
  %tobool14 = trunc i8 %21 to i1
  br i1 %tobool14, label %if.then18, label %if.end19

if.then18:                                        ; preds = %if.else
  %22 = load i32*, i32** %idx, align 4
  %23 = bitcast i32* %22 to i8*
  %24 = load i32, i32* %SIZE.addr, align 4
  call void @qsort(i8* %23, i32 %24, i32 4, i32 (i8*, i8*)* @compar_increase)
  br label %if.end19

if.end19:                                         ; preds = %if.then18, %if.else
  br label %if.end20

if.end20:                                         ; preds = %if.end19, %if.then13
  %25 = load double*, double** @base_arr, align 4
  %26 = bitcast double* %25 to i8*
  call void @free(i8* %26)
  store double* null, double** @base_arr, align 4
  %27 = load i32*, i32** %idx, align 4
  ret i32* %27
}

declare void @qsort(i8* %0, i32 %1, i32 %2, i32 (i8*, i8*)* %3) #1

; Function Attrs: noinline nounwind optnone
define internal i32 @compar_decrease(i8* noalias %a, i8* noalias %b) #0 {
entry:
  %retval = alloca i32, align 4
  %a.addr = alloca i8*, align 4
  %b.addr = alloca i8*, align 4
  %aa = alloca i32, align 4
  %bb = alloca i32, align 4
  store i8* %a, i8** %a.addr, align 4
  store i8* %b, i8** %b.addr, align 4
  %0 = load i8*, i8** %a.addr, align 4
  %1 = bitcast i8* %0 to i32*
  %2 = load i32, i32* %1, align 4
  store i32 %2, i32* %aa, align 4
  %3 = load i8*, i8** %b.addr, align 4
  %4 = bitcast i8* %3 to i32*
  %5 = load i32, i32* %4, align 4
  store i32 %5, i32* %bb, align 4
  %6 = load double*, double** @base_arr, align 4
  %7 = load i32, i32* %aa, align 4
  %arrayidx = getelementptr inbounds double, double* %6, i32 %7
  %8 = load double, double* %arrayidx, align 8
  %9 = load double*, double** @base_arr, align 4
  %10 = load i32, i32* %bb, align 4
  %arrayidx1 = getelementptr inbounds double, double* %9, i32 %10
  %11 = load double, double* %arrayidx1, align 8
  %cmp = fcmp olt double %8, %11
  br i1 %cmp, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  store i32 -1, i32* %retval, align 4
  br label %return

if.else:                                          ; preds = %entry
  %12 = load double*, double** @base_arr, align 4
  %13 = load i32, i32* %aa, align 4
  %arrayidx2 = getelementptr inbounds double, double* %12, i32 %13
  %14 = load double, double* %arrayidx2, align 8
  %15 = load double*, double** @base_arr, align 4
  %16 = load i32, i32* %bb, align 4
  %arrayidx3 = getelementptr inbounds double, double* %15, i32 %16
  %17 = load double, double* %arrayidx3, align 8
  %cmp4 = fcmp oeq double %14, %17
  br i1 %cmp4, label %if.then5, label %if.else6

if.then5:                                         ; preds = %if.else
  store i32 0, i32* %retval, align 4
  br label %return

if.else6:                                         ; preds = %if.else
  store i32 1, i32* %retval, align 4
  br label %return

return:                                           ; preds = %if.else6, %if.then5, %if.then
  %18 = load i32, i32* %retval, align 4
  ret i32 %18
}

; Function Attrs: noinline nounwind optnone
define internal i32 @compar_increase(i8* noalias %a, i8* noalias %b) #0 {
entry:
  %retval = alloca i32, align 4
  %a.addr = alloca i8*, align 4
  %b.addr = alloca i8*, align 4
  %aa = alloca i32, align 4
  %bb = alloca i32, align 4
  store i8* %a, i8** %a.addr, align 4
  store i8* %b, i8** %b.addr, align 4
  %0 = load i8*, i8** %a.addr, align 4
  %1 = bitcast i8* %0 to i32*
  %2 = load i32, i32* %1, align 4
  store i32 %2, i32* %aa, align 4
  %3 = load i8*, i8** %b.addr, align 4
  %4 = bitcast i8* %3 to i32*
  %5 = load i32, i32* %4, align 4
  store i32 %5, i32* %bb, align 4
  %6 = load double*, double** @base_arr, align 4
  %7 = load i32, i32* %aa, align 4
  %arrayidx = getelementptr inbounds double, double* %6, i32 %7
  %8 = load double, double* %arrayidx, align 8
  %9 = load double*, double** @base_arr, align 4
  %10 = load i32, i32* %bb, align 4
  %arrayidx1 = getelementptr inbounds double, double* %9, i32 %10
  %11 = load double, double* %arrayidx1, align 8
  %cmp = fcmp olt double %8, %11
  br i1 %cmp, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  store i32 1, i32* %retval, align 4
  br label %return

if.else:                                          ; preds = %entry
  %12 = load double*, double** @base_arr, align 4
  %13 = load i32, i32* %aa, align 4
  %arrayidx2 = getelementptr inbounds double, double* %12, i32 %13
  %14 = load double, double* %arrayidx2, align 8
  %15 = load double*, double** @base_arr, align 4
  %16 = load i32, i32* %bb, align 4
  %arrayidx3 = getelementptr inbounds double, double* %15, i32 %16
  %17 = load double, double* %arrayidx3, align 8
  %cmp4 = fcmp oeq double %14, %17
  br i1 %cmp4, label %if.then5, label %if.else6

if.then5:                                         ; preds = %if.else
  store i32 0, i32* %retval, align 4
  br label %return

if.else6:                                         ; preds = %if.else
  store i32 -1, i32* %retval, align 4
  br label %return

return:                                           ; preds = %if.else6, %if.then5, %if.then
  %18 = load i32, i32* %retval, align 4
  ret i32 %18
}

declare void @free(i8* %0) #1

; Function Attrs: noinline nounwind optnone
define hidden double* @cummin(double* noalias %ARRAY, i32 %NO_OF_ARRAY_ELEMENTS) #0 {
entry:
  %ARRAY.addr = alloca double*, align 4
  %NO_OF_ARRAY_ELEMENTS.addr = alloca i32, align 4
  %output = alloca double*, align 4
  %cumulative_min = alloca double, align 8
  %i = alloca i32, align 4
  store double* %ARRAY, double** %ARRAY.addr, align 4
  store i32 %NO_OF_ARRAY_ELEMENTS, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
  %0 = load i32, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
  %cmp = icmp ult i32 %0, 1
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %call = call i32 @puts(i8* getelementptr inbounds ([48 x i8], [48 x i8]* @.str.4, i32 0, i32 0))
  %call1 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([22 x i8], [22 x i8]* @.str.5, i32 0, i32 0), i8* getelementptr inbounds ([23 x i8], [23 x i8]* @.str.1, i32 0, i32 0), i32 105)
  call void @exit(i32 1) #5
  unreachable

if.end:                                           ; preds = %entry
  %1 = load i32, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
  %mul = mul i32 8, %1
  %call2 = call noalias i8* @malloc(i32 %mul)
  %2 = bitcast i8* %call2 to double*
  store double* %2, double** %output, align 4
  %3 = load double*, double** %output, align 4
  %cmp3 = icmp eq double* %3, null
  br i1 %cmp3, label %if.then4, label %if.end6

if.then4:                                         ; preds = %if.end
  %call5 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([33 x i8], [33 x i8]* @.str.3, i32 0, i32 0), i8* getelementptr inbounds ([23 x i8], [23 x i8]* @.str.1, i32 0, i32 0), i32 110)
  call void @perror(i8* getelementptr inbounds ([1 x i8], [1 x i8]* @.str.2, i32 0, i32 0))
  call void @exit(i32 1) #5
  unreachable

if.end6:                                          ; preds = %if.end
  %4 = load double*, double** %ARRAY.addr, align 4
  %arrayidx = getelementptr inbounds double, double* %4, i32 0
  %5 = load double, double* %arrayidx, align 8
  store double %5, double* %cumulative_min, align 8
  store i32 0, i32* %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.end6
  %6 = load i32, i32* %i, align 4
  %7 = load i32, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
  %cmp7 = icmp ult i32 %6, %7
  br i1 %cmp7, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %8 = load double*, double** %ARRAY.addr, align 4
  %9 = load i32, i32* %i, align 4
  %arrayidx8 = getelementptr inbounds double, double* %8, i32 %9
  %10 = load double, double* %arrayidx8, align 8
  %11 = load double, double* %cumulative_min, align 8
  %cmp9 = fcmp olt double %10, %11
  br i1 %cmp9, label %if.then10, label %if.end12

if.then10:                                        ; preds = %for.body
  %12 = load double*, double** %ARRAY.addr, align 4
  %13 = load i32, i32* %i, align 4
  %arrayidx11 = getelementptr inbounds double, double* %12, i32 %13
  %14 = load double, double* %arrayidx11, align 8
  store double %14, double* %cumulative_min, align 8
  br label %if.end12

if.end12:                                         ; preds = %if.then10, %for.body
  %15 = load double, double* %cumulative_min, align 8
  %16 = load double*, double** %output, align 4
  %17 = load i32, i32* %i, align 4
  %arrayidx13 = getelementptr inbounds double, double* %16, i32 %17
  store double %15, double* %arrayidx13, align 8
  br label %for.inc

for.inc:                                          ; preds = %if.end12
  %18 = load i32, i32* %i, align 4
  %inc = add i32 %18, 1
  store i32 %inc, i32* %i, align 4
  br label %for.cond

for.end:                                          ; preds = %for.cond
  %19 = load double*, double** %output, align 4
  ret double* %19
}

declare i32 @puts(i8* %0) #1

; Function Attrs: noinline nounwind optnone
define hidden double* @cummax(double* noalias %ARRAY, i32 %NO_OF_ARRAY_ELEMENTS) #0 {
entry:
  %ARRAY.addr = alloca double*, align 4
  %NO_OF_ARRAY_ELEMENTS.addr = alloca i32, align 4
  %output = alloca double*, align 4
  %cumulative_max = alloca double, align 8
  %i = alloca i32, align 4
  store double* %ARRAY, double** %ARRAY.addr, align 4
  store i32 %NO_OF_ARRAY_ELEMENTS, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
  %0 = load i32, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
  %cmp = icmp ult i32 %0, 1
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %call = call i32 @puts(i8* getelementptr inbounds ([41 x i8], [41 x i8]* @.str.6, i32 0, i32 0))
  %call1 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([22 x i8], [22 x i8]* @.str.5, i32 0, i32 0), i8* getelementptr inbounds ([23 x i8], [23 x i8]* @.str.1, i32 0, i32 0), i32 129)
  call void @exit(i32 1) #5
  unreachable

if.end:                                           ; preds = %entry
  %1 = load i32, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
  %mul = mul i32 8, %1
  %call2 = call noalias i8* @malloc(i32 %mul)
  %2 = bitcast i8* %call2 to double*
  store double* %2, double** %output, align 4
  %3 = load double*, double** %output, align 4
  %cmp3 = icmp eq double* %3, null
  br i1 %cmp3, label %if.then4, label %if.end6

if.then4:                                         ; preds = %if.end
  %call5 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([33 x i8], [33 x i8]* @.str.3, i32 0, i32 0), i8* getelementptr inbounds ([23 x i8], [23 x i8]* @.str.1, i32 0, i32 0), i32 134)
  call void @perror(i8* getelementptr inbounds ([1 x i8], [1 x i8]* @.str.2, i32 0, i32 0))
  call void @exit(i32 1) #5
  unreachable

if.end6:                                          ; preds = %if.end
  %4 = load double*, double** %ARRAY.addr, align 4
  %arrayidx = getelementptr inbounds double, double* %4, i32 0
  %5 = load double, double* %arrayidx, align 8
  store double %5, double* %cumulative_max, align 8
  store i32 0, i32* %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.end6
  %6 = load i32, i32* %i, align 4
  %7 = load i32, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
  %cmp7 = icmp ult i32 %6, %7
  br i1 %cmp7, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %8 = load double*, double** %ARRAY.addr, align 4
  %9 = load i32, i32* %i, align 4
  %arrayidx8 = getelementptr inbounds double, double* %8, i32 %9
  %10 = load double, double* %arrayidx8, align 8
  %11 = load double, double* %cumulative_max, align 8
  %cmp9 = fcmp ogt double %10, %11
  br i1 %cmp9, label %if.then10, label %if.end12

if.then10:                                        ; preds = %for.body
  %12 = load double*, double** %ARRAY.addr, align 4
  %13 = load i32, i32* %i, align 4
  %arrayidx11 = getelementptr inbounds double, double* %12, i32 %13
  %14 = load double, double* %arrayidx11, align 8
  store double %14, double* %cumulative_max, align 8
  br label %if.end12

if.end12:                                         ; preds = %if.then10, %for.body
  %15 = load double, double* %cumulative_max, align 8
  %16 = load double*, double** %output, align 4
  %17 = load i32, i32* %i, align 4
  %arrayidx13 = getelementptr inbounds double, double* %16, i32 %17
  store double %15, double* %arrayidx13, align 8
  br label %for.inc

for.inc:                                          ; preds = %if.end12
  %18 = load i32, i32* %i, align 4
  %inc = add i32 %18, 1
  store i32 %inc, i32* %i, align 4
  br label %for.cond

for.end:                                          ; preds = %for.cond
  %19 = load double*, double** %output, align 4
  ret double* %19
}

; Function Attrs: noinline nounwind optnone
define hidden double* @pminx(double* noalias %ARRAY, i32 %NO_OF_ARRAY_ELEMENTS, double %X) #0 {
entry:
  %ARRAY.addr = alloca double*, align 4
  %NO_OF_ARRAY_ELEMENTS.addr = alloca i32, align 4
  %X.addr = alloca double, align 8
  %pmin_array = alloca double*, align 4
  %index = alloca i32, align 4
  store double* %ARRAY, double** %ARRAY.addr, align 4
  store i32 %NO_OF_ARRAY_ELEMENTS, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
  store double %X, double* %X.addr, align 8
  %0 = load i32, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
  %cmp = icmp ult i32 %0, 1
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %call = call i32 @puts(i8* getelementptr inbounds ([37 x i8], [37 x i8]* @.str.7, i32 0, i32 0))
  %call1 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([22 x i8], [22 x i8]* @.str.5, i32 0, i32 0), i8* getelementptr inbounds ([23 x i8], [23 x i8]* @.str.1, i32 0, i32 0), i32 152)
  call void @exit(i32 1) #5
  unreachable

if.end:                                           ; preds = %entry
  %1 = load i32, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
  %mul = mul i32 8, %1
  %call2 = call noalias i8* @malloc(i32 %mul)
  %2 = bitcast i8* %call2 to double*
  store double* %2, double** %pmin_array, align 4
  %3 = load double*, double** %pmin_array, align 4
  %cmp3 = icmp eq double* %3, null
  br i1 %cmp3, label %if.then4, label %if.end6

if.then4:                                         ; preds = %if.end
  %call5 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([33 x i8], [33 x i8]* @.str.3, i32 0, i32 0), i8* getelementptr inbounds ([23 x i8], [23 x i8]* @.str.1, i32 0, i32 0), i32 157)
  call void @perror(i8* getelementptr inbounds ([1 x i8], [1 x i8]* @.str.2, i32 0, i32 0))
  call void @exit(i32 1) #5
  unreachable

if.end6:                                          ; preds = %if.end
  store i32 0, i32* %index, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.end6
  %4 = load i32, i32* %index, align 4
  %5 = load i32, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
  %cmp7 = icmp ult i32 %4, %5
  br i1 %cmp7, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %6 = load double*, double** %ARRAY.addr, align 4
  %7 = load i32, i32* %index, align 4
  %arrayidx = getelementptr inbounds double, double* %6, i32 %7
  %8 = load double, double* %arrayidx, align 8
  %9 = load double, double* %X.addr, align 8
  %cmp8 = fcmp olt double %8, %9
  br i1 %cmp8, label %if.then9, label %if.else

if.then9:                                         ; preds = %for.body
  %10 = load double*, double** %ARRAY.addr, align 4
  %11 = load i32, i32* %index, align 4
  %arrayidx10 = getelementptr inbounds double, double* %10, i32 %11
  %12 = load double, double* %arrayidx10, align 8
  %13 = load double*, double** %pmin_array, align 4
  %14 = load i32, i32* %index, align 4
  %arrayidx11 = getelementptr inbounds double, double* %13, i32 %14
  store double %12, double* %arrayidx11, align 8
  br label %if.end13

if.else:                                          ; preds = %for.body
  %15 = load double, double* %X.addr, align 8
  %16 = load double*, double** %pmin_array, align 4
  %17 = load i32, i32* %index, align 4
  %arrayidx12 = getelementptr inbounds double, double* %16, i32 %17
  store double %15, double* %arrayidx12, align 8
  br label %if.end13

if.end13:                                         ; preds = %if.else, %if.then9
  br label %for.inc

for.inc:                                          ; preds = %if.end13
  %18 = load i32, i32* %index, align 4
  %inc = add i32 %18, 1
  store i32 %inc, i32* %index, align 4
  br label %for.cond

for.end:                                          ; preds = %for.cond
  %19 = load double*, double** %pmin_array, align 4
  ret double* %19
}

; Function Attrs: noinline nounwind optnone
define hidden void @double_say(double* noalias %ARRAY, i32 %NO_OF_ARRAY_ELEMENTS) #0 {
entry:
  %ARRAY.addr = alloca double*, align 4
  %NO_OF_ARRAY_ELEMENTS.addr = alloca i32, align 4
  %i = alloca i32, align 4
  store double* %ARRAY, double** %ARRAY.addr, align 4
  store i32 %NO_OF_ARRAY_ELEMENTS, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
  %0 = load double*, double** %ARRAY.addr, align 4
  %arrayidx = getelementptr inbounds double, double* %0, i32 0
  %1 = load double, double* %arrayidx, align 8
  %call = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([7 x i8], [7 x i8]* @.str.8, i32 0, i32 0), double %1)
  store i32 1, i32* %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %2 = load i32, i32* %i, align 4
  %3 = load i32, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
  %cmp = icmp ult i32 %2, %3
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %4 = load double*, double** %ARRAY.addr, align 4
  %5 = load i32, i32* %i, align 4
  %arrayidx1 = getelementptr inbounds double, double* %4, i32 %5
  %6 = load double, double* %arrayidx1, align 8
  %call2 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([7 x i8], [7 x i8]* @.str.9, i32 0, i32 0), double %6)
  %7 = load i32, i32* %i, align 4
  %add = add i32 %7, 1
  %rem = urem i32 %add, 5
  %cmp3 = icmp eq i32 %rem, 0
  br i1 %cmp3, label %if.then, label %if.end

if.then:                                          ; preds = %for.body
  %8 = load i32, i32* %i, align 4
  %add4 = add i32 %8, 1
  %call5 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([6 x i8], [6 x i8]* @.str.10, i32 0, i32 0), i32 %add4)
  br label %if.end

if.end:                                           ; preds = %if.then, %for.body
  br label %for.inc

for.inc:                                          ; preds = %if.end
  %9 = load i32, i32* %i, align 4
  %inc = add i32 %9, 1
  store i32 %inc, i32* %i, align 4
  br label %for.cond

for.end:                                          ; preds = %for.cond
  %call6 = call i32 @puts(i8* getelementptr inbounds ([2 x i8], [2 x i8]* @.str.11, i32 0, i32 0))
  ret void
}

; Function Attrs: noinline nounwind optnone
define hidden double* @uint2double(i32* noalias %ARRAY, i32 %NO_OF_ARRAY_ELEMENTS) #0 {
entry:
  %ARRAY.addr = alloca i32*, align 4
  %NO_OF_ARRAY_ELEMENTS.addr = alloca i32, align 4
  %doubleArray = alloca double*, align 4
  %index = alloca i32, align 4
  store i32* %ARRAY, i32** %ARRAY.addr, align 4
  store i32 %NO_OF_ARRAY_ELEMENTS, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
  %0 = load i32, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
  %mul = mul i32 8, %0
  %call = call noalias i8* @malloc(i32 %mul)
  %1 = bitcast i8* %call to double*
  store double* %1, double** %doubleArray, align 4
  %2 = load double*, double** %doubleArray, align 4
  %cmp = icmp eq double* %2, null
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %call1 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([34 x i8], [34 x i8]* @.str.12, i32 0, i32 0), i8* getelementptr inbounds ([23 x i8], [23 x i8]* @.str.1, i32 0, i32 0), i32 194)
  call void @perror(i8* getelementptr inbounds ([1 x i8], [1 x i8]* @.str.2, i32 0, i32 0))
  call void @exit(i32 1) #5
  unreachable

if.end:                                           ; preds = %entry
  store i32 0, i32* %index, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.end
  %3 = load i32, i32* %index, align 4
  %4 = load i32, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
  %cmp2 = icmp ult i32 %3, %4
  br i1 %cmp2, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %5 = load i32*, i32** %ARRAY.addr, align 4
  %6 = load i32, i32* %index, align 4
  %arrayidx = getelementptr inbounds i32, i32* %5, i32 %6
  %7 = load i32, i32* %arrayidx, align 4
  %conv = uitofp i32 %7 to double
  %8 = load double*, double** %doubleArray, align 4
  %9 = load i32, i32* %index, align 4
  %arrayidx3 = getelementptr inbounds double, double* %8, i32 %9
  store double %conv, double* %arrayidx3, align 8
  br label %for.inc

for.inc:                                          ; preds = %for.body
  %10 = load i32, i32* %index, align 4
  %inc = add i32 %10, 1
  store i32 %inc, i32* %index, align 4
  br label %for.cond

for.end:                                          ; preds = %for.cond
  %11 = load double*, double** %doubleArray, align 4
  ret double* %11
}

; Function Attrs: noinline nounwind optnone
define hidden double @min2(double %N1, double %N2) #0 {
entry:
  %retval = alloca double, align 8
  %N1.addr = alloca double, align 8
  %N2.addr = alloca double, align 8
  store double %N1, double* %N1.addr, align 8
  store double %N2, double* %N2.addr, align 8
  %0 = load double, double* %N1.addr, align 8
  %1 = load double, double* %N2.addr, align 8
  %cmp = fcmp olt double %0, %1
  br i1 %cmp, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  %2 = load double, double* %N1.addr, align 8
  store double %2, double* %retval, align 8
  br label %return

if.else:                                          ; preds = %entry
  %3 = load double, double* %N2.addr, align 8
  store double %3, double* %retval, align 8
  br label %return

return:                                           ; preds = %if.else, %if.then
  %4 = load double, double* %retval, align 8
  ret double %4
}

; Function Attrs: noinline nounwind optnone
define hidden double* @p_adjust(double* noalias %PVALUES, i32 %NO_OF_ARRAY_ELEMENTS, i8* noalias %STRING) #0 {
entry:
  %retval = alloca double*, align 4
  %PVALUES.addr = alloca double*, align 4
  %NO_OF_ARRAY_ELEMENTS.addr = alloca i32, align 4
  %STRING.addr = alloca i8*, align 4
  %TYPE = alloca i16, align 2
  %bonferroni = alloca double*, align 4
  %index = alloca i32, align 4
  %BONFERRONI = alloca double, align 8
  %o = alloca i32*, align 4
  %o2double = alloca double*, align 4
  %cummax_input = alloca double*, align 4
  %index80 = alloca i32, align 4
  %ro = alloca i32*, align 4
  %cummax_output = alloca double*, align 4
  %pmin = alloca double*, align 4
  %qvalues = alloca double*, align 4
  %index98 = alloca i32, align 4
  %o114 = alloca i32*, align 4
  %p = alloca double*, align 4
  %index123 = alloca i32, align 4
  %o2double134 = alloca double*, align 4
  %ro136 = alloca i32*, align 4
  %q = alloca double*, align 4
  %pa = alloca double*, align 4
  %min = alloca double, align 8
  %index155 = alloca i32, align 4
  %TEMP = alloca double, align 8
  %index171 = alloca i32, align 4
  %j = alloca i32, align 4
  %ij = alloca i32*, align 4
  %I2_LENGTH = alloca i32, align 4
  %i2 = alloca i32*, align 4
  %i = alloca i32, align 4
  %q1 = alloca double, align 8
  %i208 = alloca i32, align 4
  %TEMP_Q1 = alloca double, align 8
  %i227 = alloca i32, align 4
  %i244 = alloca i32, align 4
  %i256 = alloca i32, align 4
  %index274 = alloca i32, align 4
  %o288 = alloca i32*, align 4
  %o_double = alloca double*, align 4
  %index296 = alloca i32, align 4
  %ro315 = alloca i32*, align 4
  %cummin_input = alloca double*, align 4
  %index328 = alloca i32, align 4
  %NI = alloca double, align 8
  %q349 = alloca double, align 8
  %index350 = alloca i32, align 4
  %index362 = alloca i32, align 4
  %NI367 = alloca double, align 8
  %index385 = alloca i32, align 4
  %cummin_array = alloca double*, align 4
  %pmin403 = alloca double*, align 4
  %q_array = alloca double*, align 4
  %index407 = alloca i32, align 4
  store double* %PVALUES, double** %PVALUES.addr, align 4
  store i32 %NO_OF_ARRAY_ELEMENTS, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
  store i8* %STRING, i8** %STRING.addr, align 4
  %0 = load i32, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
  %cmp = icmp ult i32 %0, 1
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %call = call i32 @puts(i8* getelementptr inbounds ([41 x i8], [41 x i8]* @.str.13, i32 0, i32 0))
  %call1 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([22 x i8], [22 x i8]* @.str.5, i32 0, i32 0), i8* getelementptr inbounds ([23 x i8], [23 x i8]* @.str.1, i32 0, i32 0), i32 217)
  call void @exit(i32 1) #5
  unreachable

if.end:                                           ; preds = %entry
  store i16 -1, i16* %TYPE, align 2
  %1 = load i8*, i8** %STRING.addr, align 4
  %cmp2 = icmp eq i8* %1, null
  br i1 %cmp2, label %if.then3, label %if.else

if.then3:                                         ; preds = %if.end
  store i16 0, i16* %TYPE, align 2
  br label %if.end41

if.else:                                          ; preds = %if.end
  %2 = load i8*, i8** %STRING.addr, align 4
  %call4 = call i32 @strcasecmp(i8* %2, i8* getelementptr inbounds ([3 x i8], [3 x i8]* @.str.14, i32 0, i32 0))
  %cmp5 = icmp eq i32 %call4, 0
  br i1 %cmp5, label %if.then6, label %if.else7

if.then6:                                         ; preds = %if.else
  store i16 0, i16* %TYPE, align 2
  br label %if.end40

if.else7:                                         ; preds = %if.else
  %3 = load i8*, i8** %STRING.addr, align 4
  %call8 = call i32 @strcasecmp(i8* %3, i8* getelementptr inbounds ([4 x i8], [4 x i8]* @.str.15, i32 0, i32 0))
  %cmp9 = icmp eq i32 %call8, 0
  br i1 %cmp9, label %if.then10, label %if.else11

if.then10:                                        ; preds = %if.else7
  store i16 0, i16* %TYPE, align 2
  br label %if.end39

if.else11:                                        ; preds = %if.else7
  %4 = load i8*, i8** %STRING.addr, align 4
  %call12 = call i32 @strcasecmp(i8* %4, i8* getelementptr inbounds ([3 x i8], [3 x i8]* @.str.16, i32 0, i32 0))
  %cmp13 = icmp eq i32 %call12, 0
  br i1 %cmp13, label %if.then14, label %if.else15

if.then14:                                        ; preds = %if.else11
  store i16 1, i16* %TYPE, align 2
  br label %if.end38

if.else15:                                        ; preds = %if.else11
  %5 = load i8*, i8** %STRING.addr, align 4
  %call16 = call i32 @strcasecmp(i8* %5, i8* getelementptr inbounds ([11 x i8], [11 x i8]* @.str.17, i32 0, i32 0))
  %cmp17 = icmp eq i32 %call16, 0
  br i1 %cmp17, label %if.then18, label %if.else19

if.then18:                                        ; preds = %if.else15
  store i16 2, i16* %TYPE, align 2
  br label %if.end37

if.else19:                                        ; preds = %if.else15
  %6 = load i8*, i8** %STRING.addr, align 4
  %call20 = call i32 @strcasecmp(i8* %6, i8* getelementptr inbounds ([9 x i8], [9 x i8]* @.str.18, i32 0, i32 0))
  %cmp21 = icmp eq i32 %call20, 0
  br i1 %cmp21, label %if.then22, label %if.else23

if.then22:                                        ; preds = %if.else19
  store i16 3, i16* %TYPE, align 2
  br label %if.end36

if.else23:                                        ; preds = %if.else19
  %7 = load i8*, i8** %STRING.addr, align 4
  %call24 = call i32 @strcasecmp(i8* %7, i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.19, i32 0, i32 0))
  %cmp25 = icmp eq i32 %call24, 0
  br i1 %cmp25, label %if.then26, label %if.else27

if.then26:                                        ; preds = %if.else23
  store i16 4, i16* %TYPE, align 2
  br label %if.end35

if.else27:                                        ; preds = %if.else23
  %8 = load i8*, i8** %STRING.addr, align 4
  %call28 = call i32 @strcasecmp(i8* %8, i8* getelementptr inbounds ([7 x i8], [7 x i8]* @.str.20, i32 0, i32 0))
  %cmp29 = icmp eq i32 %call28, 0
  br i1 %cmp29, label %if.then30, label %if.else31

if.then30:                                        ; preds = %if.else27
  store i16 5, i16* %TYPE, align 2
  br label %if.end34

if.else31:                                        ; preds = %if.else27
  %9 = load i8*, i8** %STRING.addr, align 4
  %call32 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([44 x i8], [44 x i8]* @.str.21, i32 0, i32 0), i8* %9)
  %call33 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([22 x i8], [22 x i8]* @.str.5, i32 0, i32 0), i8* getelementptr inbounds ([23 x i8], [23 x i8]* @.str.1, i32 0, i32 0), i32 239)
  call void @exit(i32 1) #5
  unreachable

if.end34:                                         ; preds = %if.then30
  br label %if.end35

if.end35:                                         ; preds = %if.end34, %if.then26
  br label %if.end36

if.end36:                                         ; preds = %if.end35, %if.then22
  br label %if.end37

if.end37:                                         ; preds = %if.end36, %if.then18
  br label %if.end38

if.end38:                                         ; preds = %if.end37, %if.then14
  br label %if.end39

if.end39:                                         ; preds = %if.end38, %if.then10
  br label %if.end40

if.end40:                                         ; preds = %if.end39, %if.then6
  br label %if.end41

if.end41:                                         ; preds = %if.end40, %if.then3
  %10 = load i16, i16* %TYPE, align 2
  %conv = sext i16 %10 to i32
  %cmp42 = icmp eq i32 %conv, 2
  br i1 %cmp42, label %if.then44, label %if.else71

if.then44:                                        ; preds = %if.end41
  %11 = load i32, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
  %mul = mul i32 8, %11
  %call45 = call noalias i8* @malloc(i32 %mul)
  %12 = bitcast i8* %call45 to double*
  store double* %12, double** %bonferroni, align 4
  %13 = load double*, double** %bonferroni, align 4
  %cmp46 = icmp eq double* %13, null
  br i1 %cmp46, label %if.then48, label %if.end50

if.then48:                                        ; preds = %if.then44
  %call49 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([33 x i8], [33 x i8]* @.str.3, i32 0, i32 0), i8* getelementptr inbounds ([23 x i8], [23 x i8]* @.str.1, i32 0, i32 0), i32 247)
  call void @perror(i8* getelementptr inbounds ([1 x i8], [1 x i8]* @.str.2, i32 0, i32 0))
  call void @exit(i32 1) #5
  unreachable

if.end50:                                         ; preds = %if.then44
  store i32 0, i32* %index, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.end50
  %14 = load i32, i32* %index, align 4
  %15 = load i32, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
  %cmp51 = icmp ult i32 %14, %15
  br i1 %cmp51, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %16 = load double*, double** %PVALUES.addr, align 4
  %17 = load i32, i32* %index, align 4
  %arrayidx = getelementptr inbounds double, double* %16, i32 %17
  %18 = load double, double* %arrayidx, align 8
  %19 = load i32, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
  %conv53 = uitofp i32 %19 to double
  %mul54 = fmul double %18, %conv53
  store double %mul54, double* %BONFERRONI, align 8
  %20 = load double, double* %BONFERRONI, align 8
  %cmp55 = fcmp oge double %20, 1.000000e+00
  br i1 %cmp55, label %if.then57, label %if.else59

if.then57:                                        ; preds = %for.body
  %21 = load double*, double** %bonferroni, align 4
  %22 = load i32, i32* %index, align 4
  %arrayidx58 = getelementptr inbounds double, double* %21, i32 %22
  store double 1.000000e+00, double* %arrayidx58, align 8
  br label %if.end70

if.else59:                                        ; preds = %for.body
  %23 = load double, double* %BONFERRONI, align 8
  %cmp60 = fcmp ole double 0.000000e+00, %23
  br i1 %cmp60, label %land.lhs.true, label %if.else66

land.lhs.true:                                    ; preds = %if.else59
  %24 = load double, double* %BONFERRONI, align 8
  %cmp62 = fcmp olt double %24, 1.000000e+00
  br i1 %cmp62, label %if.then64, label %if.else66

if.then64:                                        ; preds = %land.lhs.true
  %25 = load double, double* %BONFERRONI, align 8
  %26 = load double*, double** %bonferroni, align 4
  %27 = load i32, i32* %index, align 4
  %arrayidx65 = getelementptr inbounds double, double* %26, i32 %27
  store double %25, double* %arrayidx65, align 8
  br label %if.end69

if.else66:                                        ; preds = %land.lhs.true, %if.else59
  %28 = load double, double* %BONFERRONI, align 8
  %call67 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([42 x i8], [42 x i8]* @.str.22, i32 0, i32 0), double %28)
  %call68 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([23 x i8], [23 x i8]* @.str.23, i32 0, i32 0), i8* getelementptr inbounds ([23 x i8], [23 x i8]* @.str.1, i32 0, i32 0), i32 259)
  call void @exit(i32 1) #5
  unreachable

if.end69:                                         ; preds = %if.then64
  br label %if.end70

if.end70:                                         ; preds = %if.end69, %if.then57
  br label %for.inc

for.inc:                                          ; preds = %if.end70
  %29 = load i32, i32* %index, align 4
  %inc = add i32 %29, 1
  store i32 %inc, i32* %index, align 4
  br label %for.cond

for.end:                                          ; preds = %for.cond
  %30 = load double*, double** %bonferroni, align 4
  store double* %30, double** %retval, align 4
  br label %return

if.else71:                                        ; preds = %if.end41
  %31 = load i16, i16* %TYPE, align 2
  %conv72 = sext i16 %31 to i32
  %cmp73 = icmp eq i32 %conv72, 4
  br i1 %cmp73, label %if.then75, label %if.else109

if.then75:                                        ; preds = %if.else71
  %32 = load double*, double** %PVALUES.addr, align 4
  %33 = load i32, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
  %call76 = call i32* @order(double* %32, i32 %33, i1 zeroext false)
  store i32* %call76, i32** %o, align 4
  %34 = load i32*, i32** %o, align 4
  %35 = load i32, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
  %call77 = call double* @uint2double(i32* %34, i32 %35)
  store double* %call77, double** %o2double, align 4
  %36 = load i32, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
  %mul78 = mul i32 8, %36
  %call79 = call noalias i8* @malloc(i32 %mul78)
  %37 = bitcast i8* %call79 to double*
  store double* %37, double** %cummax_input, align 4
  store i32 0, i32* %index80, align 4
  br label %for.cond81

for.cond81:                                       ; preds = %for.inc90, %if.then75
  %38 = load i32, i32* %index80, align 4
  %39 = load i32, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
  %cmp82 = icmp ult i32 %38, %39
  br i1 %cmp82, label %for.body84, label %for.end92

for.body84:                                       ; preds = %for.cond81
  %40 = load i32, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
  %41 = load i32, i32* %index80, align 4
  %sub = sub i32 %40, %41
  %conv85 = uitofp i32 %sub to double
  %42 = load double*, double** %PVALUES.addr, align 4
  %43 = load i32*, i32** %o, align 4
  %44 = load i32, i32* %index80, align 4
  %arrayidx86 = getelementptr inbounds i32, i32* %43, i32 %44
  %45 = load i32, i32* %arrayidx86, align 4
  %arrayidx87 = getelementptr inbounds double, double* %42, i32 %45
  %46 = load double, double* %arrayidx87, align 8
  %mul88 = fmul double %conv85, %46
  %47 = load double*, double** %cummax_input, align 4
  %48 = load i32, i32* %index80, align 4
  %arrayidx89 = getelementptr inbounds double, double* %47, i32 %48
  store double %mul88, double* %arrayidx89, align 8
  br label %for.inc90

for.inc90:                                        ; preds = %for.body84
  %49 = load i32, i32* %index80, align 4
  %inc91 = add i32 %49, 1
  store i32 %inc91, i32* %index80, align 4
  br label %for.cond81

for.end92:                                        ; preds = %for.cond81
  %50 = load i32*, i32** %o, align 4
  %51 = bitcast i32* %50 to i8*
  call void @free(i8* %51)
  store i32* null, i32** %o, align 4
  %52 = load double*, double** %o2double, align 4
  %53 = load i32, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
  %call93 = call i32* @order(double* %52, i32 %53, i1 zeroext false)
  store i32* %call93, i32** %ro, align 4
  %54 = load double*, double** %o2double, align 4
  %55 = bitcast double* %54 to i8*
  call void @free(i8* %55)
  store double* null, double** %o2double, align 4
  %56 = load double*, double** %cummax_input, align 4
  %57 = load i32, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
  %call94 = call double* @cummax(double* %56, i32 %57)
  store double* %call94, double** %cummax_output, align 4
  %58 = load double*, double** %cummax_input, align 4
  %59 = bitcast double* %58 to i8*
  call void @free(i8* %59)
  store double* null, double** %cummax_input, align 4
  %60 = load double*, double** %cummax_output, align 4
  %61 = load i32, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
  %call95 = call double* @pminx(double* %60, i32 %61, double 1.000000e+00)
  store double* %call95, double** %pmin, align 4
  %62 = load double*, double** %cummax_output, align 4
  %63 = bitcast double* %62 to i8*
  call void @free(i8* %63)
  store double* null, double** %cummax_output, align 4
  %64 = load i32, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
  %mul96 = mul i32 8, %64
  %call97 = call noalias i8* @malloc(i32 %mul96)
  %65 = bitcast i8* %call97 to double*
  store double* %65, double** %qvalues, align 4
  store i32 0, i32* %index98, align 4
  br label %for.cond99

for.cond99:                                       ; preds = %for.inc106, %for.end92
  %66 = load i32, i32* %index98, align 4
  %67 = load i32, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
  %cmp100 = icmp ult i32 %66, %67
  br i1 %cmp100, label %for.body102, label %for.end108

for.body102:                                      ; preds = %for.cond99
  %68 = load double*, double** %pmin, align 4
  %69 = load i32*, i32** %ro, align 4
  %70 = load i32, i32* %index98, align 4
  %arrayidx103 = getelementptr inbounds i32, i32* %69, i32 %70
  %71 = load i32, i32* %arrayidx103, align 4
  %arrayidx104 = getelementptr inbounds double, double* %68, i32 %71
  %72 = load double, double* %arrayidx104, align 8
  %73 = load double*, double** %qvalues, align 4
  %74 = load i32, i32* %index98, align 4
  %arrayidx105 = getelementptr inbounds double, double* %73, i32 %74
  store double %72, double* %arrayidx105, align 8
  br label %for.inc106

for.inc106:                                       ; preds = %for.body102
  %75 = load i32, i32* %index98, align 4
  %inc107 = add i32 %75, 1
  store i32 %inc107, i32* %index98, align 4
  br label %for.cond99

for.end108:                                       ; preds = %for.cond99
  %76 = load double*, double** %pmin, align 4
  %77 = bitcast double* %76 to i8*
  call void @free(i8* %77)
  store double* null, double** %pmin, align 4
  %78 = load i32*, i32** %ro, align 4
  %79 = bitcast i32* %78 to i8*
  call void @free(i8* %79)
  store i32* null, i32** %ro, align 4
  %80 = load double*, double** %qvalues, align 4
  store double* %80, double** %retval, align 4
  br label %return

if.else109:                                       ; preds = %if.else71
  %81 = load i16, i16* %TYPE, align 2
  %conv110 = sext i16 %81 to i32
  %cmp111 = icmp eq i32 %conv110, 5
  br i1 %cmp111, label %if.then113, label %if.end285

if.then113:                                       ; preds = %if.else109
  %82 = load double*, double** %PVALUES.addr, align 4
  %83 = load i32, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
  %call115 = call i32* @order(double* %82, i32 %83, i1 zeroext false)
  store i32* %call115, i32** %o114, align 4
  %84 = load i32, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
  %mul116 = mul i32 8, %84
  %call117 = call noalias i8* @malloc(i32 %mul116)
  %85 = bitcast i8* %call117 to double*
  store double* %85, double** %p, align 4
  %86 = load double*, double** %p, align 4
  %cmp118 = icmp eq double* %86, null
  br i1 %cmp118, label %if.then120, label %if.end122

if.then120:                                       ; preds = %if.then113
  %call121 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([33 x i8], [33 x i8]* @.str.3, i32 0, i32 0), i8* getelementptr inbounds ([23 x i8], [23 x i8]* @.str.1, i32 0, i32 0), i32 302)
  call void @perror(i8* getelementptr inbounds ([1 x i8], [1 x i8]* @.str.2, i32 0, i32 0))
  call void @exit(i32 1) #5
  unreachable

if.end122:                                        ; preds = %if.then113
  store i32 0, i32* %index123, align 4
  br label %for.cond124

for.cond124:                                      ; preds = %for.inc131, %if.end122
  %87 = load i32, i32* %index123, align 4
  %88 = load i32, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
  %cmp125 = icmp ult i32 %87, %88
  br i1 %cmp125, label %for.body127, label %for.end133

for.body127:                                      ; preds = %for.cond124
  %89 = load double*, double** %PVALUES.addr, align 4
  %90 = load i32*, i32** %o114, align 4
  %91 = load i32, i32* %index123, align 4
  %arrayidx128 = getelementptr inbounds i32, i32* %90, i32 %91
  %92 = load i32, i32* %arrayidx128, align 4
  %arrayidx129 = getelementptr inbounds double, double* %89, i32 %92
  %93 = load double, double* %arrayidx129, align 8
  %94 = load double*, double** %p, align 4
  %95 = load i32, i32* %index123, align 4
  %arrayidx130 = getelementptr inbounds double, double* %94, i32 %95
  store double %93, double* %arrayidx130, align 8
  br label %for.inc131

for.inc131:                                       ; preds = %for.body127
  %96 = load i32, i32* %index123, align 4
  %inc132 = add i32 %96, 1
  store i32 %inc132, i32* %index123, align 4
  br label %for.cond124

for.end133:                                       ; preds = %for.cond124
  %97 = load i32*, i32** %o114, align 4
  %98 = load i32, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
  %call135 = call double* @uint2double(i32* %97, i32 %98)
  store double* %call135, double** %o2double134, align 4
  %99 = load i32*, i32** %o114, align 4
  %100 = bitcast i32* %99 to i8*
  call void @free(i8* %100)
  store i32* null, i32** %o114, align 4
  %101 = load double*, double** %o2double134, align 4
  %102 = load i32, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
  %call137 = call i32* @order(double* %101, i32 %102, i1 zeroext false)
  store i32* %call137, i32** %ro136, align 4
  %103 = load double*, double** %o2double134, align 4
  %104 = bitcast double* %103 to i8*
  call void @free(i8* %104)
  store double* null, double** %o2double134, align 4
  %105 = load i32, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
  %mul138 = mul i32 8, %105
  %call139 = call noalias i8* @malloc(i32 %mul138)
  %106 = bitcast i8* %call139 to double*
  store double* %106, double** %q, align 4
  %107 = load double*, double** %q, align 4
  %cmp140 = icmp eq double* %107, null
  br i1 %cmp140, label %if.then142, label %if.end144

if.then142:                                       ; preds = %for.end133
  %call143 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([33 x i8], [33 x i8]* @.str.3, i32 0, i32 0), i8* getelementptr inbounds ([23 x i8], [23 x i8]* @.str.1, i32 0, i32 0), i32 318)
  call void @perror(i8* getelementptr inbounds ([1 x i8], [1 x i8]* @.str.2, i32 0, i32 0))
  call void @exit(i32 1) #5
  unreachable

if.end144:                                        ; preds = %for.end133
  %108 = load i32, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
  %mul145 = mul i32 8, %108
  %call146 = call noalias i8* @malloc(i32 %mul145)
  %109 = bitcast i8* %call146 to double*
  store double* %109, double** %pa, align 4
  %110 = load double*, double** %pa, align 4
  %cmp147 = icmp eq double* %110, null
  br i1 %cmp147, label %if.then149, label %if.end151

if.then149:                                       ; preds = %if.end144
  %call150 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([33 x i8], [33 x i8]* @.str.3, i32 0, i32 0), i8* getelementptr inbounds ([23 x i8], [23 x i8]* @.str.1, i32 0, i32 0), i32 324)
  call void @perror(i8* getelementptr inbounds ([1 x i8], [1 x i8]* @.str.2, i32 0, i32 0))
  call void @exit(i32 1) #5
  unreachable

if.end151:                                        ; preds = %if.end144
  %111 = load i32, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
  %conv152 = uitofp i32 %111 to double
  %112 = load double*, double** %p, align 4
  %arrayidx153 = getelementptr inbounds double, double* %112, i32 0
  %113 = load double, double* %arrayidx153, align 8
  %mul154 = fmul double %conv152, %113
  store double %mul154, double* %min, align 8
  store i32 1, i32* %index155, align 4
  br label %for.cond156

for.cond156:                                      ; preds = %for.inc168, %if.end151
  %114 = load i32, i32* %index155, align 4
  %115 = load i32, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
  %cmp157 = icmp ult i32 %114, %115
  br i1 %cmp157, label %for.body159, label %for.end170

for.body159:                                      ; preds = %for.cond156
  %116 = load i32, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
  %conv160 = uitofp i32 %116 to double
  %117 = load double*, double** %p, align 4
  %118 = load i32, i32* %index155, align 4
  %arrayidx161 = getelementptr inbounds double, double* %117, i32 %118
  %119 = load double, double* %arrayidx161, align 8
  %mul162 = fmul double %conv160, %119
  %120 = load i32, i32* %index155, align 4
  %add = add i32 1, %120
  %conv163 = uitofp i32 %add to double
  %div = fdiv double %mul162, %conv163
  store double %div, double* %TEMP, align 8
  %121 = load double, double* %TEMP, align 8
  %122 = load double, double* %min, align 8
  %cmp164 = fcmp olt double %121, %122
  br i1 %cmp164, label %if.then166, label %if.end167

if.then166:                                       ; preds = %for.body159
  %123 = load double, double* %TEMP, align 8
  store double %123, double* %min, align 8
  br label %if.end167

if.end167:                                        ; preds = %if.then166, %for.body159
  br label %for.inc168

for.inc168:                                       ; preds = %if.end167
  %124 = load i32, i32* %index155, align 4
  %inc169 = add i32 %124, 1
  store i32 %inc169, i32* %index155, align 4
  br label %for.cond156

for.end170:                                       ; preds = %for.cond156
  store i32 0, i32* %index171, align 4
  br label %for.cond172

for.cond172:                                      ; preds = %for.inc178, %for.end170
  %125 = load i32, i32* %index171, align 4
  %126 = load i32, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
  %cmp173 = icmp ult i32 %125, %126
  br i1 %cmp173, label %for.body175, label %for.end180

for.body175:                                      ; preds = %for.cond172
  %127 = load double, double* %min, align 8
  %128 = load double*, double** %pa, align 4
  %129 = load i32, i32* %index171, align 4
  %arrayidx176 = getelementptr inbounds double, double* %128, i32 %129
  store double %127, double* %arrayidx176, align 8
  %130 = load double, double* %min, align 8
  %131 = load double*, double** %q, align 4
  %132 = load i32, i32* %index171, align 4
  %arrayidx177 = getelementptr inbounds double, double* %131, i32 %132
  store double %130, double* %arrayidx177, align 8
  br label %for.inc178

for.inc178:                                       ; preds = %for.body175
  %133 = load i32, i32* %index171, align 4
  %inc179 = add i32 %133, 1
  store i32 %inc179, i32* %index171, align 4
  br label %for.cond172

for.end180:                                       ; preds = %for.cond172
  %134 = load i32, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
  %sub181 = sub i32 %134, 1
  store i32 %sub181, i32* %j, align 4
  br label %for.cond182

for.cond182:                                      ; preds = %for.inc272, %for.end180
  %135 = load i32, i32* %j, align 4
  %cmp183 = icmp uge i32 %135, 2
  br i1 %cmp183, label %for.body185, label %for.end273

for.body185:                                      ; preds = %for.cond182
  %136 = load i32, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
  %137 = load i32, i32* %j, align 4
  %sub186 = sub i32 %136, %137
  %call187 = call i32* @seq_len(i32 0, i32 %sub186)
  store i32* %call187, i32** %ij, align 4
  %138 = load i32, i32* %j, align 4
  %sub188 = sub i32 %138, 1
  store i32 %sub188, i32* %I2_LENGTH, align 4
  %139 = load i32, i32* %I2_LENGTH, align 4
  %mul189 = mul i32 %139, 4
  %call190 = call noalias i8* @malloc(i32 %mul189)
  %140 = bitcast i8* %call190 to i32*
  store i32* %140, i32** %i2, align 4
  store i32 0, i32* %i, align 4
  br label %for.cond191

for.cond191:                                      ; preds = %for.inc200, %for.body185
  %141 = load i32, i32* %i, align 4
  %142 = load i32, i32* %I2_LENGTH, align 4
  %cmp192 = icmp ult i32 %141, %142
  br i1 %cmp192, label %for.body194, label %for.end202

for.body194:                                      ; preds = %for.cond191
  %143 = load i32, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
  %144 = load i32, i32* %j, align 4
  %sub195 = sub i32 %143, %144
  %add196 = add i32 %sub195, 2
  %145 = load i32, i32* %i, align 4
  %add197 = add i32 %add196, %145
  %sub198 = sub i32 %add197, 1
  %146 = load i32*, i32** %i2, align 4
  %147 = load i32, i32* %i, align 4
  %arrayidx199 = getelementptr inbounds i32, i32* %146, i32 %147
  store i32 %sub198, i32* %arrayidx199, align 4
  br label %for.inc200

for.inc200:                                       ; preds = %for.body194
  %148 = load i32, i32* %i, align 4
  %inc201 = add i32 %148, 1
  store i32 %inc201, i32* %i, align 4
  br label %for.cond191

for.end202:                                       ; preds = %for.cond191
  %149 = load i32, i32* %j, align 4
  %conv203 = uitofp i32 %149 to double
  %150 = load double*, double** %p, align 4
  %151 = load i32*, i32** %i2, align 4
  %arrayidx204 = getelementptr inbounds i32, i32* %151, i32 0
  %152 = load i32, i32* %arrayidx204, align 4
  %arrayidx205 = getelementptr inbounds double, double* %150, i32 %152
  %153 = load double, double* %arrayidx205, align 8
  %mul206 = fmul double %conv203, %153
  %div207 = fdiv double %mul206, 2.000000e+00
  store double %div207, double* %q1, align 8
  store i32 1, i32* %i208, align 4
  br label %for.cond209

for.cond209:                                      ; preds = %for.inc224, %for.end202
  %154 = load i32, i32* %i208, align 4
  %155 = load i32, i32* %I2_LENGTH, align 4
  %cmp210 = icmp ult i32 %154, %155
  br i1 %cmp210, label %for.body212, label %for.end226

for.body212:                                      ; preds = %for.cond209
  %156 = load i32, i32* %j, align 4
  %conv213 = uitofp i32 %156 to double
  %157 = load double*, double** %p, align 4
  %158 = load i32*, i32** %i2, align 4
  %159 = load i32, i32* %i208, align 4
  %arrayidx214 = getelementptr inbounds i32, i32* %158, i32 %159
  %160 = load i32, i32* %arrayidx214, align 4
  %arrayidx215 = getelementptr inbounds double, double* %157, i32 %160
  %161 = load double, double* %arrayidx215, align 8
  %mul216 = fmul double %conv213, %161
  %162 = load i32, i32* %i208, align 4
  %add217 = add i32 2, %162
  %conv218 = uitofp i32 %add217 to double
  %div219 = fdiv double %mul216, %conv218
  store double %div219, double* %TEMP_Q1, align 8
  %163 = load double, double* %TEMP_Q1, align 8
  %164 = load double, double* %q1, align 8
  %cmp220 = fcmp olt double %163, %164
  br i1 %cmp220, label %if.then222, label %if.end223

if.then222:                                       ; preds = %for.body212
  %165 = load double, double* %TEMP_Q1, align 8
  store double %165, double* %q1, align 8
  br label %if.end223

if.end223:                                        ; preds = %if.then222, %for.body212
  br label %for.inc224

for.inc224:                                       ; preds = %if.end223
  %166 = load i32, i32* %i208, align 4
  %inc225 = add i32 %166, 1
  store i32 %inc225, i32* %i208, align 4
  br label %for.cond209

for.end226:                                       ; preds = %for.cond209
  store i32 0, i32* %i227, align 4
  br label %for.cond228

for.cond228:                                      ; preds = %for.inc241, %for.end226
  %167 = load i32, i32* %i227, align 4
  %168 = load i32, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
  %169 = load i32, i32* %j, align 4
  %sub229 = sub i32 %168, %169
  %add230 = add i32 %sub229, 1
  %cmp231 = icmp ult i32 %167, %add230
  br i1 %cmp231, label %for.body233, label %for.end243

for.body233:                                      ; preds = %for.cond228
  %170 = load i32, i32* %j, align 4
  %conv234 = uitofp i32 %170 to double
  %171 = load double*, double** %p, align 4
  %172 = load i32*, i32** %ij, align 4
  %173 = load i32, i32* %i227, align 4
  %arrayidx235 = getelementptr inbounds i32, i32* %172, i32 %173
  %174 = load i32, i32* %arrayidx235, align 4
  %arrayidx236 = getelementptr inbounds double, double* %171, i32 %174
  %175 = load double, double* %arrayidx236, align 8
  %mul237 = fmul double %conv234, %175
  %176 = load double, double* %q1, align 8
  %call238 = call double @min2(double %mul237, double %176)
  %177 = load double*, double** %q, align 4
  %178 = load i32*, i32** %ij, align 4
  %179 = load i32, i32* %i227, align 4
  %arrayidx239 = getelementptr inbounds i32, i32* %178, i32 %179
  %180 = load i32, i32* %arrayidx239, align 4
  %arrayidx240 = getelementptr inbounds double, double* %177, i32 %180
  store double %call238, double* %arrayidx240, align 8
  br label %for.inc241

for.inc241:                                       ; preds = %for.body233
  %181 = load i32, i32* %i227, align 4
  %inc242 = add i32 %181, 1
  store i32 %inc242, i32* %i227, align 4
  br label %for.cond228

for.end243:                                       ; preds = %for.cond228
  %182 = load i32*, i32** %ij, align 4
  %183 = bitcast i32* %182 to i8*
  call void @free(i8* %183)
  store i32* null, i32** %ij, align 4
  store i32 0, i32* %i244, align 4
  br label %for.cond245

for.cond245:                                      ; preds = %for.inc253, %for.end243
  %184 = load i32, i32* %i244, align 4
  %185 = load i32, i32* %I2_LENGTH, align 4
  %cmp246 = icmp ult i32 %184, %185
  br i1 %cmp246, label %for.body248, label %for.end255

for.body248:                                      ; preds = %for.cond245
  %186 = load double*, double** %q, align 4
  %187 = load i32, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
  %188 = load i32, i32* %j, align 4
  %sub249 = sub i32 %187, %188
  %arrayidx250 = getelementptr inbounds double, double* %186, i32 %sub249
  %189 = load double, double* %arrayidx250, align 8
  %190 = load double*, double** %q, align 4
  %191 = load i32*, i32** %i2, align 4
  %192 = load i32, i32* %i244, align 4
  %arrayidx251 = getelementptr inbounds i32, i32* %191, i32 %192
  %193 = load i32, i32* %arrayidx251, align 4
  %arrayidx252 = getelementptr inbounds double, double* %190, i32 %193
  store double %189, double* %arrayidx252, align 8
  br label %for.inc253

for.inc253:                                       ; preds = %for.body248
  %194 = load i32, i32* %i244, align 4
  %inc254 = add i32 %194, 1
  store i32 %inc254, i32* %i244, align 4
  br label %for.cond245

for.end255:                                       ; preds = %for.cond245
  %195 = load i32*, i32** %i2, align 4
  %196 = bitcast i32* %195 to i8*
  call void @free(i8* %196)
  store i32* null, i32** %i2, align 4
  store i32 0, i32* %i256, align 4
  br label %for.cond257

for.cond257:                                      ; preds = %for.inc269, %for.end255
  %197 = load i32, i32* %i256, align 4
  %198 = load i32, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
  %cmp258 = icmp ult i32 %197, %198
  br i1 %cmp258, label %for.body260, label %for.end271

for.body260:                                      ; preds = %for.cond257
  %199 = load double*, double** %pa, align 4
  %200 = load i32, i32* %i256, align 4
  %arrayidx261 = getelementptr inbounds double, double* %199, i32 %200
  %201 = load double, double* %arrayidx261, align 8
  %202 = load double*, double** %q, align 4
  %203 = load i32, i32* %i256, align 4
  %arrayidx262 = getelementptr inbounds double, double* %202, i32 %203
  %204 = load double, double* %arrayidx262, align 8
  %cmp263 = fcmp olt double %201, %204
  br i1 %cmp263, label %if.then265, label %if.end268

if.then265:                                       ; preds = %for.body260
  %205 = load double*, double** %q, align 4
  %206 = load i32, i32* %i256, align 4
  %arrayidx266 = getelementptr inbounds double, double* %205, i32 %206
  %207 = load double, double* %arrayidx266, align 8
  %208 = load double*, double** %pa, align 4
  %209 = load i32, i32* %i256, align 4
  %arrayidx267 = getelementptr inbounds double, double* %208, i32 %209
  store double %207, double* %arrayidx267, align 8
  br label %if.end268

if.end268:                                        ; preds = %if.then265, %for.body260
  br label %for.inc269

for.inc269:                                       ; preds = %if.end268
  %210 = load i32, i32* %i256, align 4
  %inc270 = add i32 %210, 1
  store i32 %inc270, i32* %i256, align 4
  br label %for.cond257

for.end271:                                       ; preds = %for.cond257
  br label %for.inc272

for.inc272:                                       ; preds = %for.end271
  %211 = load i32, i32* %j, align 4
  %dec = add i32 %211, -1
  store i32 %dec, i32* %j, align 4
  br label %for.cond182

for.end273:                                       ; preds = %for.cond182
  %212 = load double*, double** %p, align 4
  %213 = bitcast double* %212 to i8*
  call void @free(i8* %213)
  store double* null, double** %p, align 4
  store i32 0, i32* %index274, align 4
  br label %for.cond275

for.cond275:                                      ; preds = %for.inc282, %for.end273
  %214 = load i32, i32* %index274, align 4
  %215 = load i32, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
  %cmp276 = icmp ult i32 %214, %215
  br i1 %cmp276, label %for.body278, label %for.end284

for.body278:                                      ; preds = %for.cond275
  %216 = load double*, double** %pa, align 4
  %217 = load i32*, i32** %ro136, align 4
  %218 = load i32, i32* %index274, align 4
  %arrayidx279 = getelementptr inbounds i32, i32* %217, i32 %218
  %219 = load i32, i32* %arrayidx279, align 4
  %arrayidx280 = getelementptr inbounds double, double* %216, i32 %219
  %220 = load double, double* %arrayidx280, align 8
  %221 = load double*, double** %q, align 4
  %222 = load i32, i32* %index274, align 4
  %arrayidx281 = getelementptr inbounds double, double* %221, i32 %222
  store double %220, double* %arrayidx281, align 8
  br label %for.inc282

for.inc282:                                       ; preds = %for.body278
  %223 = load i32, i32* %index274, align 4
  %inc283 = add i32 %223, 1
  store i32 %inc283, i32* %index274, align 4
  br label %for.cond275

for.end284:                                       ; preds = %for.cond275
  %224 = load i32*, i32** %ro136, align 4
  %225 = bitcast i32* %224 to i8*
  call void @free(i8* %225)
  store i32* null, i32** %ro136, align 4
  %226 = load double*, double** %pa, align 4
  %227 = bitcast double* %226 to i8*
  call void @free(i8* %227)
  store double* null, double** %pa, align 4
  %228 = load double*, double** %q, align 4
  store double* %228, double** %retval, align 4
  br label %return

if.end285:                                        ; preds = %if.else109
  br label %if.end286

if.end286:                                        ; preds = %if.end285
  br label %if.end287

if.end287:                                        ; preds = %if.end286
  %229 = load double*, double** %PVALUES.addr, align 4
  %230 = load i32, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
  %call289 = call i32* @order(double* %229, i32 %230, i1 zeroext true)
  store i32* %call289, i32** %o288, align 4
  %231 = load i32*, i32** %o288, align 4
  %cmp290 = icmp eq i32* %231, null
  br i1 %cmp290, label %if.then292, label %if.end294

if.then292:                                       ; preds = %if.end287
  %call293 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([33 x i8], [33 x i8]* @.str.3, i32 0, i32 0), i8* getelementptr inbounds ([23 x i8], [23 x i8]* @.str.1, i32 0, i32 0), i32 398)
  call void @perror(i8* getelementptr inbounds ([1 x i8], [1 x i8]* @.str.2, i32 0, i32 0))
  call void @exit(i32 1) #5
  unreachable

if.end294:                                        ; preds = %if.end287
  %232 = load i32*, i32** %o288, align 4
  %233 = load i32, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
  %call295 = call double* @uint2double(i32* %232, i32 %233)
  store double* %call295, double** %o_double, align 4
  store i32 0, i32* %index296, align 4
  br label %for.cond297

for.cond297:                                      ; preds = %for.inc312, %if.end294
  %234 = load i32, i32* %index296, align 4
  %235 = load i32, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
  %cmp298 = icmp ult i32 %234, %235
  br i1 %cmp298, label %for.body300, label %for.end314

for.body300:                                      ; preds = %for.cond297
  %236 = load double*, double** %PVALUES.addr, align 4
  %237 = load i32, i32* %index296, align 4
  %arrayidx301 = getelementptr inbounds double, double* %236, i32 %237
  %238 = load double, double* %arrayidx301, align 8
  %cmp302 = fcmp olt double %238, 0.000000e+00
  br i1 %cmp302, label %if.then307, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %for.body300
  %239 = load double*, double** %PVALUES.addr, align 4
  %240 = load i32, i32* %index296, align 4
  %arrayidx304 = getelementptr inbounds double, double* %239, i32 %240
  %241 = load double, double* %arrayidx304, align 8
  %cmp305 = fcmp ogt double %241, 1.000000e+00
  br i1 %cmp305, label %if.then307, label %if.end311

if.then307:                                       ; preds = %lor.lhs.false, %for.body300
  %242 = load i32, i32* %index296, align 4
  %243 = load double*, double** %PVALUES.addr, align 4
  %244 = load i32, i32* %index296, align 4
  %arrayidx308 = getelementptr inbounds double, double* %243, i32 %244
  %245 = load double, double* %arrayidx308, align 8
  %call309 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([54 x i8], [54 x i8]* @.str.24, i32 0, i32 0), i32 %242, double %245)
  %call310 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([20 x i8], [20 x i8]* @.str.25, i32 0, i32 0), i8* getelementptr inbounds ([23 x i8], [23 x i8]* @.str.1, i32 0, i32 0), i32 406)
  call void @exit(i32 1) #5
  unreachable

if.end311:                                        ; preds = %lor.lhs.false
  br label %for.inc312

for.inc312:                                       ; preds = %if.end311
  %246 = load i32, i32* %index296, align 4
  %inc313 = add i32 %246, 1
  store i32 %inc313, i32* %index296, align 4
  br label %for.cond297

for.end314:                                       ; preds = %for.cond297
  %247 = load double*, double** %o_double, align 4
  %248 = load i32, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
  %call316 = call i32* @order(double* %247, i32 %248, i1 zeroext false)
  store i32* %call316, i32** %ro315, align 4
  %249 = load i32*, i32** %ro315, align 4
  %cmp317 = icmp eq i32* %249, null
  br i1 %cmp317, label %if.then319, label %if.end321

if.then319:                                       ; preds = %for.end314
  %call320 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([33 x i8], [33 x i8]* @.str.3, i32 0, i32 0), i8* getelementptr inbounds ([23 x i8], [23 x i8]* @.str.1, i32 0, i32 0), i32 413)
  call void @perror(i8* getelementptr inbounds ([1 x i8], [1 x i8]* @.str.2, i32 0, i32 0))
  call void @exit(i32 1) #5
  unreachable

if.end321:                                        ; preds = %for.end314
  %250 = load double*, double** %o_double, align 4
  %251 = bitcast double* %250 to i8*
  call void @free(i8* %251)
  store double* null, double** %o_double, align 4
  %252 = load i32, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
  %mul322 = mul i32 8, %252
  %call323 = call noalias i8* @malloc(i32 %mul322)
  %253 = bitcast i8* %call323 to double*
  store double* %253, double** %cummin_input, align 4
  %254 = load i16, i16* %TYPE, align 2
  %conv324 = sext i16 %254 to i32
  %cmp325 = icmp eq i32 %conv324, 0
  br i1 %cmp325, label %if.then327, label %if.else344

if.then327:                                       ; preds = %if.end321
  store i32 0, i32* %index328, align 4
  br label %for.cond329

for.cond329:                                      ; preds = %for.inc341, %if.then327
  %255 = load i32, i32* %index328, align 4
  %256 = load i32, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
  %cmp330 = icmp ult i32 %255, %256
  br i1 %cmp330, label %for.body332, label %for.end343

for.body332:                                      ; preds = %for.cond329
  %257 = load i32, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
  %conv333 = uitofp i32 %257 to double
  %258 = load i32, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
  %259 = load i32, i32* %index328, align 4
  %sub334 = sub i32 %258, %259
  %conv335 = uitofp i32 %sub334 to double
  %div336 = fdiv double %conv333, %conv335
  store double %div336, double* %NI, align 8
  %260 = load double, double* %NI, align 8
  %261 = load double*, double** %PVALUES.addr, align 4
  %262 = load i32*, i32** %o288, align 4
  %263 = load i32, i32* %index328, align 4
  %arrayidx337 = getelementptr inbounds i32, i32* %262, i32 %263
  %264 = load i32, i32* %arrayidx337, align 4
  %arrayidx338 = getelementptr inbounds double, double* %261, i32 %264
  %265 = load double, double* %arrayidx338, align 8
  %mul339 = fmul double %260, %265
  %266 = load double*, double** %cummin_input, align 4
  %267 = load i32, i32* %index328, align 4
  %arrayidx340 = getelementptr inbounds double, double* %266, i32 %267
  store double %mul339, double* %arrayidx340, align 8
  br label %for.inc341

for.inc341:                                       ; preds = %for.body332
  %268 = load i32, i32* %index328, align 4
  %inc342 = add i32 %268, 1
  store i32 %inc342, i32* %index328, align 4
  br label %for.cond329

for.end343:                                       ; preds = %for.cond329
  br label %if.end401

if.else344:                                       ; preds = %if.end321
  %269 = load i16, i16* %TYPE, align 2
  %conv345 = sext i16 %269 to i32
  %cmp346 = icmp eq i32 %conv345, 1
  br i1 %cmp346, label %if.then348, label %if.else380

if.then348:                                       ; preds = %if.else344
  store double 1.000000e+00, double* %q349, align 8
  store i32 2, i32* %index350, align 4
  br label %for.cond351

for.cond351:                                      ; preds = %for.inc359, %if.then348
  %270 = load i32, i32* %index350, align 4
  %271 = load i32, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
  %add352 = add i32 1, %271
  %cmp353 = icmp ult i32 %270, %add352
  br i1 %cmp353, label %for.body355, label %for.end361

for.body355:                                      ; preds = %for.cond351
  %272 = load i32, i32* %index350, align 4
  %conv356 = uitofp i32 %272 to double
  %div357 = fdiv double 1.000000e+00, %conv356
  %273 = load double, double* %q349, align 8
  %add358 = fadd double %273, %div357
  store double %add358, double* %q349, align 8
  br label %for.inc359

for.inc359:                                       ; preds = %for.body355
  %274 = load i32, i32* %index350, align 4
  %inc360 = add i32 %274, 1
  store i32 %inc360, i32* %index350, align 4
  br label %for.cond351

for.end361:                                       ; preds = %for.cond351
  store i32 0, i32* %index362, align 4
  br label %for.cond363

for.cond363:                                      ; preds = %for.inc377, %for.end361
  %275 = load i32, i32* %index362, align 4
  %276 = load i32, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
  %cmp364 = icmp ult i32 %275, %276
  br i1 %cmp364, label %for.body366, label %for.end379

for.body366:                                      ; preds = %for.cond363
  %277 = load i32, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
  %conv368 = uitofp i32 %277 to double
  %278 = load i32, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
  %279 = load i32, i32* %index362, align 4
  %sub369 = sub i32 %278, %279
  %conv370 = uitofp i32 %sub369 to double
  %div371 = fdiv double %conv368, %conv370
  store double %div371, double* %NI367, align 8
  %280 = load double, double* %q349, align 8
  %281 = load double, double* %NI367, align 8
  %mul372 = fmul double %280, %281
  %282 = load double*, double** %PVALUES.addr, align 4
  %283 = load i32*, i32** %o288, align 4
  %284 = load i32, i32* %index362, align 4
  %arrayidx373 = getelementptr inbounds i32, i32* %283, i32 %284
  %285 = load i32, i32* %arrayidx373, align 4
  %arrayidx374 = getelementptr inbounds double, double* %282, i32 %285
  %286 = load double, double* %arrayidx374, align 8
  %mul375 = fmul double %mul372, %286
  %287 = load double*, double** %cummin_input, align 4
  %288 = load i32, i32* %index362, align 4
  %arrayidx376 = getelementptr inbounds double, double* %287, i32 %288
  store double %mul375, double* %arrayidx376, align 8
  br label %for.inc377

for.inc377:                                       ; preds = %for.body366
  %289 = load i32, i32* %index362, align 4
  %inc378 = add i32 %289, 1
  store i32 %inc378, i32* %index362, align 4
  br label %for.cond363

for.end379:                                       ; preds = %for.cond363
  br label %if.end400

if.else380:                                       ; preds = %if.else344
  %290 = load i16, i16* %TYPE, align 2
  %conv381 = sext i16 %290 to i32
  %cmp382 = icmp eq i32 %conv381, 3
  br i1 %cmp382, label %if.then384, label %if.end399

if.then384:                                       ; preds = %if.else380
  store i32 0, i32* %index385, align 4
  br label %for.cond386

for.cond386:                                      ; preds = %for.inc396, %if.then384
  %291 = load i32, i32* %index385, align 4
  %292 = load i32, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
  %cmp387 = icmp ult i32 %291, %292
  br i1 %cmp387, label %for.body389, label %for.end398

for.body389:                                      ; preds = %for.cond386
  %293 = load i32, i32* %index385, align 4
  %add390 = add i32 %293, 1
  %conv391 = uitofp i32 %add390 to double
  %294 = load double*, double** %PVALUES.addr, align 4
  %295 = load i32*, i32** %o288, align 4
  %296 = load i32, i32* %index385, align 4
  %arrayidx392 = getelementptr inbounds i32, i32* %295, i32 %296
  %297 = load i32, i32* %arrayidx392, align 4
  %arrayidx393 = getelementptr inbounds double, double* %294, i32 %297
  %298 = load double, double* %arrayidx393, align 8
  %mul394 = fmul double %conv391, %298
  %299 = load double*, double** %cummin_input, align 4
  %300 = load i32, i32* %index385, align 4
  %arrayidx395 = getelementptr inbounds double, double* %299, i32 %300
  store double %mul394, double* %arrayidx395, align 8
  br label %for.inc396

for.inc396:                                       ; preds = %for.body389
  %301 = load i32, i32* %index385, align 4
  %inc397 = add i32 %301, 1
  store i32 %inc397, i32* %index385, align 4
  br label %for.cond386

for.end398:                                       ; preds = %for.cond386
  br label %if.end399

if.end399:                                        ; preds = %for.end398, %if.else380
  br label %if.end400

if.end400:                                        ; preds = %if.end399, %for.end379
  br label %if.end401

if.end401:                                        ; preds = %if.end400, %for.end343
  %302 = load i32*, i32** %o288, align 4
  %303 = bitcast i32* %302 to i8*
  call void @free(i8* %303)
  store i32* null, i32** %o288, align 4
  store double* null, double** %cummin_array, align 4
  %304 = load double*, double** %cummin_input, align 4
  %305 = load i32, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
  %call402 = call double* @cummin(double* %304, i32 %305)
  store double* %call402, double** %cummin_array, align 4
  %306 = load double*, double** %cummin_input, align 4
  %307 = bitcast double* %306 to i8*
  call void @free(i8* %307)
  store double* null, double** %cummin_input, align 4
  %308 = load double*, double** %cummin_array, align 4
  %309 = load i32, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
  %call404 = call double* @pminx(double* %308, i32 %309, double 1.000000e+00)
  store double* %call404, double** %pmin403, align 4
  %310 = load double*, double** %cummin_array, align 4
  %311 = bitcast double* %310 to i8*
  call void @free(i8* %311)
  store double* null, double** %cummin_array, align 4
  %312 = load i32, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
  %mul405 = mul i32 %312, 8
  %call406 = call noalias i8* @malloc(i32 %mul405)
  %313 = bitcast i8* %call406 to double*
  store double* %313, double** %q_array, align 4
  store i32 0, i32* %index407, align 4
  br label %for.cond408

for.cond408:                                      ; preds = %for.inc415, %if.end401
  %314 = load i32, i32* %index407, align 4
  %315 = load i32, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
  %cmp409 = icmp ult i32 %314, %315
  br i1 %cmp409, label %for.body411, label %for.end417

for.body411:                                      ; preds = %for.cond408
  %316 = load double*, double** %pmin403, align 4
  %317 = load i32*, i32** %ro315, align 4
  %318 = load i32, i32* %index407, align 4
  %arrayidx412 = getelementptr inbounds i32, i32* %317, i32 %318
  %319 = load i32, i32* %arrayidx412, align 4
  %arrayidx413 = getelementptr inbounds double, double* %316, i32 %319
  %320 = load double, double* %arrayidx413, align 8
  %321 = load double*, double** %q_array, align 4
  %322 = load i32, i32* %index407, align 4
  %arrayidx414 = getelementptr inbounds double, double* %321, i32 %322
  store double %320, double* %arrayidx414, align 8
  br label %for.inc415

for.inc415:                                       ; preds = %for.body411
  %323 = load i32, i32* %index407, align 4
  %inc416 = add i32 %323, 1
  store i32 %inc416, i32* %index407, align 4
  br label %for.cond408

for.end417:                                       ; preds = %for.cond408
  %324 = load i32*, i32** %ro315, align 4
  %325 = bitcast i32* %324 to i8*
  call void @free(i8* %325)
  store i32* null, i32** %ro315, align 4
  %326 = load double*, double** %pmin403, align 4
  %327 = bitcast double* %326 to i8*
  call void @free(i8* %327)
  store double* null, double** %pmin403, align 4
  %328 = load double*, double** %q_array, align 4
  store double* %328, double** %retval, align 4
  br label %return

return:                                           ; preds = %for.end417, %for.end284, %for.end108, %for.end
  %329 = load double*, double** %retval, align 4
  ret double* %329
}

declare i32 @strcasecmp(i8* %0, i8* %1) #1

; Function Attrs: noinline nounwind optnone
define hidden i32 @main() #0 {
entry:
  %retval = alloca i32, align 4
  %PVALUES = alloca [50 x double], align 16
  %CORRECT_ANSWERS = alloca [6 x [50 x double]], align 16
  %TYPES = alloca [6 x i8*], align 16
  %type = alloca i16, align 2
  %q = alloca double*, align 4
  %error = alloca double, align 8
  %i = alloca i32, align 4
  %this_error = alloca double, align 8
  store i32 0, i32* %retval, align 4
  %0 = bitcast [50 x double]* %PVALUES to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 16 %0, i8* align 16 bitcast ([50 x double]* @__const.main.PVALUES to i8*), i32 400, i1 false)
  %1 = bitcast [6 x [50 x double]]* %CORRECT_ANSWERS to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 16 %1, i8* align 16 bitcast ([6 x [50 x double]]* @__const.main.CORRECT_ANSWERS to i8*), i32 2400, i1 false)
  %2 = bitcast [6 x i8*]* %TYPES to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 16 %2, i8* align 16 bitcast ([6 x i8*]* @__const.main.TYPES to i8*), i32 24, i1 false)
  store i16 0, i16* %type, align 2
  br label %for.cond

for.cond:                                         ; preds = %for.inc19, %entry
  %3 = load i16, i16* %type, align 2
  %conv = zext i16 %3 to i32
  %cmp = icmp sle i32 %conv, 5
  br i1 %cmp, label %for.body, label %for.end21

for.body:                                         ; preds = %for.cond
  %arraydecay = getelementptr inbounds [50 x double], [50 x double]* %PVALUES, i32 0, i32 0
  %4 = load i16, i16* %type, align 2
  %idxprom = zext i16 %4 to i32
  %arrayidx = getelementptr inbounds [6 x i8*], [6 x i8*]* %TYPES, i32 0, i32 %idxprom
  %5 = load i8*, i8** %arrayidx, align 4
  %call = call double* @p_adjust(double* %arraydecay, i32 50, i8* %5)
  store double* %call, double** %q, align 4
  %6 = load double*, double** %q, align 4
  %arrayidx2 = getelementptr inbounds double, double* %6, i32 0
  %7 = load double, double* %arrayidx2, align 8
  %8 = load i16, i16* %type, align 2
  %idxprom3 = zext i16 %8 to i32
  %arrayidx4 = getelementptr inbounds [6 x [50 x double]], [6 x [50 x double]]* %CORRECT_ANSWERS, i32 0, i32 %idxprom3
  %arrayidx5 = getelementptr inbounds [50 x double], [50 x double]* %arrayidx4, i32 0, i32 0
  %9 = load double, double* %arrayidx5, align 16
  %sub = fsub double %7, %9
  %10 = call double @llvm.fabs.f64(double %sub)
  store double %10, double* %error, align 8
  store i32 1, i32* %i, align 4
  br label %for.cond6

for.cond6:                                        ; preds = %for.inc, %for.body
  %11 = load i32, i32* %i, align 4
  %cmp7 = icmp ult i32 %11, 50
  br i1 %cmp7, label %for.body9, label %for.end

for.body9:                                        ; preds = %for.cond6
  %12 = load double*, double** %q, align 4
  %13 = load i32, i32* %i, align 4
  %arrayidx10 = getelementptr inbounds double, double* %12, i32 %13
  %14 = load double, double* %arrayidx10, align 8
  %15 = load i16, i16* %type, align 2
  %idxprom11 = zext i16 %15 to i32
  %arrayidx12 = getelementptr inbounds [6 x [50 x double]], [6 x [50 x double]]* %CORRECT_ANSWERS, i32 0, i32 %idxprom11
  %16 = load i32, i32* %i, align 4
  %arrayidx13 = getelementptr inbounds [50 x double], [50 x double]* %arrayidx12, i32 0, i32 %16
  %17 = load double, double* %arrayidx13, align 8
  %sub14 = fsub double %14, %17
  %18 = call double @llvm.fabs.f64(double %sub14)
  store double %18, double* %this_error, align 8
  %19 = load double, double* %this_error, align 8
  %20 = load double, double* %error, align 8
  %add = fadd double %20, %19
  store double %add, double* %error, align 8
  br label %for.inc

for.inc:                                          ; preds = %for.body9
  %21 = load i32, i32* %i, align 4
  %inc = add i32 %21, 1
  store i32 %inc, i32* %i, align 4
  br label %for.cond6

for.end:                                          ; preds = %for.cond6
  %22 = load double*, double** %q, align 4
  call void @double_say(double* %22, i32 50)
  %23 = load double*, double** %q, align 4
  %24 = bitcast double* %23 to i8*
  call void @free(i8* %24)
  store double* null, double** %q, align 4
  %25 = load i16, i16* %type, align 2
  %conv15 = zext i16 %25 to i32
  %26 = load i16, i16* %type, align 2
  %idxprom16 = zext i16 %26 to i32
  %arrayidx17 = getelementptr inbounds [6 x i8*], [6 x i8*]* %TYPES, i32 0, i32 %idxprom16
  %27 = load i8*, i8** %arrayidx17, align 4
  %28 = load double, double* %error, align 8
  %call18 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([44 x i8], [44 x i8]* @.str.28, i32 0, i32 0), i32 %conv15, i8* %27, double %28)
  br label %for.inc19

for.inc19:                                        ; preds = %for.end
  %29 = load i16, i16* %type, align 2
  %inc20 = add i16 %29, 1
  store i16 %inc20, i16* %type, align 2
  br label %for.cond

for.end21:                                        ; preds = %for.cond
  ret i32 0
}

; Function Attrs: argmemonly nounwind willreturn
declare void @llvm.memcpy.p0i8.p0i8.i32(i8* noalias nocapture writeonly %0, i8* noalias nocapture readonly %1, i32 %2, i1 immarg %3) #3

; Function Attrs: nounwind readnone speculatable willreturn
declare double @llvm.fabs.f64(double %0) #4

attributes #0 = { noinline nounwind optnone "correctly-rounded-divide-sqrt-fp-math"="false" "disable-tail-calls"="false" "frame-pointer"="none" "less-precise-fpmad"="false" "min-legal-vector-width"="0" "no-infs-fp-math"="false" "no-jump-tables"="false" "no-nans-fp-math"="false" "no-signed-zeros-fp-math"="false" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="generic" "unsafe-fp-math"="false" "use-soft-float"="false" }
attributes #1 = { "correctly-rounded-divide-sqrt-fp-math"="false" "disable-tail-calls"="false" "frame-pointer"="none" "less-precise-fpmad"="false" "no-infs-fp-math"="false" "no-nans-fp-math"="false" "no-signed-zeros-fp-math"="false" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="generic" "unsafe-fp-math"="false" "use-soft-float"="false" }
attributes #2 = { noreturn "correctly-rounded-divide-sqrt-fp-math"="false" "disable-tail-calls"="false" "frame-pointer"="none" "less-precise-fpmad"="false" "no-infs-fp-math"="false" "no-nans-fp-math"="false" "no-signed-zeros-fp-math"="false" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="generic" "unsafe-fp-math"="false" "use-soft-float"="false" }
attributes #3 = { argmemonly nounwind willreturn }
attributes #4 = { nounwind readnone speculatable willreturn }
attributes #5 = { noreturn }

!llvm.module.flags = !{!0}
!llvm.ident = !{!1}

!0 = !{i32 1, !"wchar_size", i32 4}
!1 = !{!"clang version 11.0.0 (https://github.com/Jacarte/llvm-project.git 0f6dea67136cc1e0b3d200eb2bb165628970c44b)"}

; extracted candidates

; *****
; For LLVM instruction:
;  %0 = load i32, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %cmp = icmp ult i32 %0, 1
; Looking for a replacement for:
%0:i32 = var
%1:i1 = ult %0, 1:i32
infer %1

; *****
; For LLVM instruction:
;  %1 = load i32, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %mul = mul i32 8, %1
; Looking for a replacement for:
%0:i32 = var
%1:i32 = mul 8:i32, %0
infer %1

; *****
; For LLVM instruction:
;  %cmp3 = icmp eq double* %3, null
; Looking for a replacement for:
%0:i32 = var
%1:i1 = eq 0:i32, %0
infer %1

; *****
; For LLVM instruction:
;  %6 = load i32, i32* %i, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %7 = load i32, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %cmp7 = icmp ult i32 %6, %7
; Looking for a replacement for:
%0:i32 = var
%1:i32 = var
%2:i1 = ult %0, %1
infer %2

; *****
; For LLVM instruction:
;  %9 = load i32, i32* %i, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %cmp9 = fcmp ogt double %10, %11
; Looking for a replacement for:
%0:i1 = var
infer %0

; *****
; For LLVM instruction:
;  %13 = load i32, i32* %i, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %17 = load i32, i32* %i, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %18 = load i32, i32* %i, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %inc = add i32 %18, 1
; Looking for a replacement for:
%0:i32 = var
%1:i32 = add 1:i32, %0
infer %1
#########################################################
; exiting Souper's runOnFunction() for cummax()

; entering Souper's runOnFunction() for pminx()

; ModuleID = './P-value_correction.c.bc'
source_filename = "./P-value_correction.c"
target datalayout = "e-m:e-p:32:32-i64:64-n32:64-S128"
target triple = "wasm32-unknown-wasi"

@.str = private unnamed_addr constant [29 x i8] c"malloc failed at %s line %u\0A\00", align 1
@.str.1 = private unnamed_addr constant [23 x i8] c"./P-value_correction.c\00", align 1
@.str.2 = private unnamed_addr constant [1 x i8] zeroinitializer, align 1
@base_arr = hidden global double* null, align 4
@.str.3 = private unnamed_addr constant [33 x i8] c"failed to malloc at %s line %u.\0A\00", align 1
@.str.4 = private unnamed_addr constant [48 x i8] c"cummin function requires at least one element.\0A\00", align 1
@.str.5 = private unnamed_addr constant [22 x i8] c"Failed at %s line %u\0A\00", align 1
@.str.6 = private unnamed_addr constant [41 x i8] c"function requires at least one element.\0A\00", align 1
@.str.7 = private unnamed_addr constant [37 x i8] c"pmin requires at least one element.\0A\00", align 1
@.str.8 = private unnamed_addr constant [7 x i8] c"[1] %e\00", align 1
@.str.9 = private unnamed_addr constant [7 x i8] c" %.10f\00", align 1
@.str.10 = private unnamed_addr constant [6 x i8] c"\0A[%u]\00", align 1
@.str.11 = private unnamed_addr constant [2 x i8] c"\0A\00", align 1
@.str.12 = private unnamed_addr constant [34 x i8] c"Failure to malloc at %s line %u.\0A\00", align 1
@.str.13 = private unnamed_addr constant [41 x i8] c"p_adjust requires at least one element.\0A\00", align 1
@.str.14 = private unnamed_addr constant [3 x i8] c"BH\00", align 1
@.str.15 = private unnamed_addr constant [4 x i8] c"fdr\00", align 1
@.str.16 = private unnamed_addr constant [3 x i8] c"by\00", align 1
@.str.17 = private unnamed_addr constant [11 x i8] c"Bonferroni\00", align 1
@.str.18 = private unnamed_addr constant [9 x i8] c"hochberg\00", align 1
@.str.19 = private unnamed_addr constant [5 x i8] c"holm\00", align 1
@.str.20 = private unnamed_addr constant [7 x i8] c"hommel\00", align 1
@.str.21 = private unnamed_addr constant [44 x i8] c"%s doesn't match any accepted FDR methods.\0A\00", align 1
@.str.22 = private unnamed_addr constant [42 x i8] c"%g is outside of the interval I planned.\0A\00", align 1
@.str.23 = private unnamed_addr constant [23 x i8] c"Failure at %s line %u\0A\00", align 1
@.str.24 = private unnamed_addr constant [54 x i8] c"array[%u] = %lf, which is outside the interval [0,1]\0A\00", align 1
@.str.25 = private unnamed_addr constant [20 x i8] c"died at %s line %u\0A\00", align 1
@__const.main.PVALUES = private unnamed_addr constant [50 x double] [double 0x3FDD04160F35FDE9, double 0x3FE758E721E2A8D7, double 0x3FB96FAC8B38D8BA, double 0x3FB73E71D5B04B37, double 0x3FC710AB48EE865B, double 0x3FEC01D953C3CC73, double 0x3FD2B3C4BE0A922A, double 0x3FED2B5A568DAB4F, double 0x3FDBE08D73F16964, double 0x3FE10A218C41C242, double 0x3FDF8810DB1996AA, double 0x3FE291CCB11E1A9D, double 0x3FD64E8C550D788F, double 7.883130e-01, double 0x3FD177B2BF048D2D, double 0x3FEB3543434BAF2B, double 0x3FDB50EAD41ED0A6, double 0x3FE49D4AFF01D33F, double 0x3FD364C9AE345B51, double 0x3FA99BA35F15394D, double 3.194810e-01, double 0x3FE941E405CE761A, double 0x3FEFF94F77369843, double 0x3FC65847BFB23217, double 0x3FECEB8879B6A543, double 0x3FBEAF00332BA677, double 0x3FD96207C7749E38, double 0x3F8CC02620502C93, double 0x3FE773A5B45A0F40, double 0x3FB1642C24762C01, double 4.040730e-03, double 0x3F33E11D79A90777, double 0x3F870B02BD749528, double 0x3F98521BD6A0353F, double 0x3F4310F26148FFAA, double 0x3F3427CD76006778, double 0x3F80E60AFB1F8A4E, double 0x3F5639B74A9E4DA2, double 0x3F8BDDF74195769F, double 0x3F38ABEE3BFA8581, double 0x3EF2E2E96B5466FE, double 0x3E90CE9F65B58A88, double 0x3FA0F2D097879B95, double 0x3F834EE7216A6684, double 0x3F4CCE8DBB40BD9D, double 0x3F2C8B969590F2ED, double 0x3F4FC31F7F1541AD, double 6.610250e-05, double 0x3F9DB44EA6AC26BA, double 5.735490e-03], align 16
@__const.main.CORRECT_ANSWERS = private unnamed_addr constant [6 x [50 x double]] [[50 x double] [double 0x3FE39AFA2199ADBC, double 8.521710e-01, double 0x3FC96FAC6045BAF5, double 0x3FC83660E51D25AB, double 0x3FD498068702BE20, double 0x3FEDC3BF727136A4, double 4.870370e-01, double 0x3FEDC3BF727136A4, double 0x3FE35BF08BEEB62C, double 0x3FE5D879DEE92F03, double 0x3FE4BE91D656B94A, double 0x3FE7363FC28DAEAA, double 0x3FE0E62C4F13638A, double 0x3FEC1052C8FAB035, double 0x3FDE1DD2E43E029A, double 0x3FED92EFFC7CBDC1, double 0x3FE35BF08BEEB62C, double 0x3FE923B90CFC67C5, double 0x3FDF47B8FC357024, double 0x3FBD1996A9FB10AD, double 0x3FDFF2B6D6C14255, double 0x3FEC1052C8FAB035, double 0x3FEFF94F77369843, double 0x3FD498068702BE20, double 0x3FEDC3BF727136A4, double 0x3FCD80E2E96EC403, double 0x3FE2A9F6A93F290B, double 0x3FA3F736D8AF2E2B, double 8.521710e-01, double 0x3FC2E751B350FAC4, double 0x3F913D8E55EE9F05, double 0x3F64FECB88BB3633, double 0x3FA2009A03CCBE34, double 0x3FB0001FB57CF9FC, double 0x3F6DCA7ADA5E274A, double 0x3F64FECB88BB3633, double 0x3F9E2D13B467D120, double 0x3F7941963399C6A1, double 0x3FA3F736D8AF2E2B, double 0x3F6607390CEF853C, double 0x3F3D828C80BA213A, double 0x3EEA42D90EEBA875, double 0x3FB42D4181AA8F8B, double 0x3FA01715F12E0018, double 0x3F73D9F3AF6D490C, double 0x3F64FECB88BB3633, double 0x3F73D9F3AF6D490C, double 0x3F520CE5F51A7C61, double 0x3FB290B112B20952, double 0x3F9696C95AA76B69], [50 x double] [double 1.000000e+00, double 1.000000e+00, double 0x3FEC9C56E33BA41B, double 0x3FEB3BF21E95ED3D, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 0x3FE05DA74553C727, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 0x3FC675198790829A, double 1.000000e+00, double 0x3FE54345648E1F12, double 0x3FB3645F501CA2F9, double 0x3F879D934E50F0DE, double 0x3FC43FC3646E3EA2, double 0x3FD1FF539D36064C, double 0x3F90C123206B855F, double 0x3F879D934E50F0DE, double 0x3FC0F8967F32E606, double 0x3F9C6880470D2FBE, double 0x3FC675198790829A, double 0x3F88C70105E47082, double 2.025930e-03, double 0x3F0D89DE4FA8F818, double 0x3FD6B1E2D11B1027, double 0x3FC219271872BD8D, double 0x3F96542FAD16CEF9, double 0x3F879D934E50F0DE, double 0x3F96542FAD16CEF9, double 0x3F744D9816EB319A, double 0x3FD4E1D5728DBC16, double 0x3FB9687C40426555], [50 x double] [double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 0x3FE6761DC93EA2D3, double 1.000000e+00, double 1.000000e+00, double 0x3FC9DC55000C953A, double 0x3F8F0FBD624BA499, double 0x3FE2009A24031487, double 1.000000e+00, double 0x3F9DCA7AB8020F7A, double 0x3F8F7E310860A1AB, double 0x3FDA677128614819, double 6.782670e-02, double 6.803480e-01, double 0x3F9346521EDBB84D, double 0x3F4D828CB7B3E0EE, double 0x3EEA42D90EEBA875, double 1.000000e+00, double 4.713920e-01, double 0x3FA6815EE53DB1E7, double 0x3F864D0CF90CC6B8, double 0x3FA8D0709B489B4F, double 0x3F6B1359791819D2, double 1.000000e+00, double 0x3FD25A836EB4E981], [50 x double] [double 0x3FEFF94F77369843, double 0x3FEFF94F77369843, double 0x3FEFF94F77369843, double 0x3FEFF94F77369843, double 0x3FEFF94F77369843, double 0x3FEFF94F77369843, double 0x3FEFF94F77369843, double 0x3FEFF94F77369843, double 0x3FEFF94F77369843, double 0x3FEFF94F77369843, double 0x3FEFF94F77369843, double 0x3FEFF94F77369843, double 0x3FEFF94F77369843, double 0x3FEFF94F77369843, double 0x3FEFF94F77369843, double 0x3FEFF94F77369843, double 0x3FEFF94F77369843, double 0x3FEFF94F77369843, double 0x3FEFF94F77369843, double 0x3FEFF94F77369843, double 0x3FEFF94F77369843, double 0x3FEFF94F77369843, double 0x3FEFF94F77369843, double 0x3FEFF94F77369843, double 0x3FEFF94F77369843, double 0x3FEFF94F77369843, double 0x3FEFF94F77369843, double 0x3FDDA6274695E687, double 0x3FEFF94F77369843, double 0x3FEFF94F77369843, double 0x3FC42BDC26DCE39B, double 0x3F8C57F9104CA951, double 0x3FD9340AC9879DEF, double 7.600230e-01, double 0x3F999EC5A86B439B, double 0x3F8C57F9104CA951, double 0x3FD389FCD90412B4, double 0x3FABC8251D45E10B, double 0x3FDD9BD68ABBB045, double 0x3F90F633F956C386, double 8.825610e-04, double 0x3EEA42D90EEBA875, double 0x3FEFC7471C1E43B8, double 0x3FD5B8C4014C305A, double 0x3FA2E78CEC8D068E, double 0x3F84F6832995A599, double 0x3FA459002162FC24, double 3.172920e-03, double 8.992520e-01, double 0x3FCBE5BD5E9AC00A], [50 x double] [double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 0x3FDDA6274695E687, double 1.000000e+00, double 1.000000e+00, double 0x3FC42BDC26DCE39B, double 0x3F8C939AFCF101E0, double 0x3FD9340AC9879DEF, double 7.600230e-01, double 0x3F999EC5A86B439B, double 0x3F8C939AFCF101E0, double 0x3FD389FCD90412B4, double 0x3FABC8251D45E10B, double 0x3FDD9BD68ABBB045, double 0x3F90F633F956C386, double 8.825610e-04, double 0x3EEA42D90EEBA875, double 0x3FEFC7471C1E43B8, double 0x3FD5B8C4014C305A, double 0x3FA2E78CEC8D068E, double 0x3F84F6832995A599, double 0x3FA459002162FC24, double 3.172920e-03, double 8.992520e-01, double 0x3FCBE5BD5E9AC00A], [50 x double] [double 0x3FEFF94F77369843, double 0x3FEFF94F77369843, double 0x3FEFF94F77369843, double 0x3FEFF5DC908F2EDD, double 0x3FEFF94F77369843, double 0x3FEFF94F77369843, double 0x3FEFF94F77369843, double 0x3FEFF94F77369843, double 0x3FEFF94F77369843, double 0x3FEFF94F77369843, double 0x3FEFF94F77369843, double 0x3FEFF94F77369843, double 0x3FEFF94F77369843, double 0x3FEFF94F77369843, double 0x3FEFF94F77369843, double 0x3FEFF94F77369843, double 0x3FEFF94F77369843, double 0x3FEFF94F77369843, double 0x3FEFF94F77369843, double 0x3FEEB45F17BD8BE7, double 0x3FEFF94F77369843, double 0x3FEFF94F77369843, double 0x3FEFF94F77369843, double 0x3FEFF94F77369843, double 0x3FEFF94F77369843, double 0x3FEFF94F77369843, double 0x3FEFF94F77369843, double 0x3FDBDA250F840182, double 0x3FEFF94F77369843, double 0x3FEF40BC1D52205E, double 0x3FC21A3BEB689947, double 1.304340e-02, double 0x3FD69916517B1CD7, double 0x3FE60A69453DF7B2, double 0x3F986DB666D9D3C6, double 0x3F8B157BBD3AB385, double 2.722920e-01, double 0x3FABC8251D45E10B, double 0x3FDAFF07B27BE8AF, double 0x3F9030D45E3B9F93, double 8.825610e-04, double 0x3EEA42D90EEBA875, double 0x3FEBFACC1948A662, double 0x3FD34EE6EDE042CB, double 0x3FA2011883DA6A9A, double 0x3F839FF779153716, double 0x3FA3D9F3D1C960DD, double 3.172920e-03, double 0x3FE9FDC4BC5D1301, double 0x3FC8F5FAC3801CF1]], align 16
@.str.26 = private unnamed_addr constant [3 x i8] c"bh\00", align 1
@.str.27 = private unnamed_addr constant [11 x i8] c"bonferroni\00", align 1
@__const.main.TYPES = private unnamed_addr constant [6 x i8*] [i8* getelementptr inbounds ([3 x i8], [3 x i8]* @.str.26, i32 0, i32 0), i8* getelementptr inbounds ([3 x i8], [3 x i8]* @.str.16, i32 0, i32 0), i8* getelementptr inbounds ([11 x i8], [11 x i8]* @.str.27, i32 0, i32 0), i8* getelementptr inbounds ([9 x i8], [9 x i8]* @.str.18, i32 0, i32 0), i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.19, i32 0, i32 0), i8* getelementptr inbounds ([7 x i8], [7 x i8]* @.str.20, i32 0, i32 0)], align 16
@.str.28 = private unnamed_addr constant [44 x i8] c"\0Atype %u = '%s' has cumulative error of %g\0A\00", align 1
@llvm.used = appending global [1 x i8*] [i8* bitcast (i32 ()* @__main_void to i8*)], section "llvm.metadata"

@__main_void = alias i32 (), i32 ()* @main

; Function Attrs: noinline nounwind optnone
define hidden i32* @seq_len(i32 %START, i32 %END) #0 {
entry:
  %retval = alloca i32*, align 4
  %START.addr = alloca i32, align 4
  %END.addr = alloca i32, align 4
  %start = alloca i32, align 4
  %end = alloca i32, align 4
  %sequence = alloca i32*, align 4
  %i = alloca i32, align 4
  %LENGTH = alloca i32, align 4
  %sequence10 = alloca i32*, align 4
  %index = alloca i32, align 4
  %index28 = alloca i32, align 4
  store i32 %START, i32* %START.addr, align 4
  store i32 %END, i32* %END.addr, align 4
  %0 = load i32, i32* %START.addr, align 4
  store i32 %0, i32* %start, align 4
  %1 = load i32, i32* %END.addr, align 4
  store i32 %1, i32* %end, align 4
  %2 = load i32, i32* %START.addr, align 4
  %3 = load i32, i32* %END.addr, align 4
  %cmp = icmp eq i32 %2, %3
  br i1 %cmp, label %if.then, label %if.end6

if.then:                                          ; preds = %entry
  %4 = load i32, i32* %end, align 4
  %add = add i32 %4, 1
  %mul = mul i32 %add, 4
  %call = call noalias i8* @malloc(i32 %mul)
  %5 = bitcast i8* %call to i32*
  store i32* %5, i32** %sequence, align 4
  %6 = load i32*, i32** %sequence, align 4
  %cmp1 = icmp eq i32* %6, null
  br i1 %cmp1, label %if.then2, label %if.end

if.then2:                                         ; preds = %if.then
  %call3 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([29 x i8], [29 x i8]* @.str, i32 0, i32 0), i8* getelementptr inbounds ([23 x i8], [23 x i8]* @.str.1, i32 0, i32 0), i32 15)
  call void @perror(i8* getelementptr inbounds ([1 x i8], [1 x i8]* @.str.2, i32 0, i32 0))
  call void @exit(i32 1) #5
  unreachable

if.end:                                           ; preds = %if.then
  store i32 0, i32* %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.end
  %7 = load i32, i32* %i, align 4
  %8 = load i32, i32* %end, align 4
  %cmp4 = icmp ult i32 %7, %8
  br i1 %cmp4, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %9 = load i32, i32* %i, align 4
  %add5 = add i32 %9, 1
  %10 = load i32*, i32** %sequence, align 4
  %11 = load i32, i32* %i, align 4
  %arrayidx = getelementptr inbounds i32, i32* %10, i32 %11
  store i32 %add5, i32* %arrayidx, align 4
  br label %for.inc

for.inc:                                          ; preds = %for.body
  %12 = load i32, i32* %i, align 4
  %inc = add i32 %12, 1
  store i32 %inc, i32* %i, align 4
  br label %for.cond

for.end:                                          ; preds = %for.cond
  %13 = load i32*, i32** %sequence, align 4
  store i32* %13, i32** %retval, align 4
  br label %return

if.end6:                                          ; preds = %entry
  %14 = load i32, i32* %START.addr, align 4
  %15 = load i32, i32* %END.addr, align 4
  %cmp7 = icmp ugt i32 %14, %15
  br i1 %cmp7, label %if.then8, label %if.end9

if.then8:                                         ; preds = %if.end6
  %16 = load i32, i32* %START.addr, align 4
  store i32 %16, i32* %end, align 4
  %17 = load i32, i32* %END.addr, align 4
  store i32 %17, i32* %start, align 4
  br label %if.end9

if.end9:                                          ; preds = %if.then8, %if.end6
  %18 = load i32, i32* %end, align 4
  %19 = load i32, i32* %start, align 4
  %sub = sub i32 %18, %19
  store i32 %sub, i32* %LENGTH, align 4
  %20 = load i32, i32* %LENGTH, align 4
  %add11 = add i32 1, %20
  %mul12 = mul i32 %add11, 4
  %call13 = call noalias i8* @malloc(i32 %mul12)
  %21 = bitcast i8* %call13 to i32*
  store i32* %21, i32** %sequence10, align 4
  %22 = load i32*, i32** %sequence10, align 4
  %cmp14 = icmp eq i32* %22, null
  br i1 %cmp14, label %if.then15, label %if.end17

if.then15:                                        ; preds = %if.end9
  %call16 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([29 x i8], [29 x i8]* @.str, i32 0, i32 0), i8* getelementptr inbounds ([23 x i8], [23 x i8]* @.str.1, i32 0, i32 0), i32 31)
  call void @perror(i8* getelementptr inbounds ([1 x i8], [1 x i8]* @.str.2, i32 0, i32 0))
  call void @exit(i32 1) #5
  unreachable

if.end17:                                         ; preds = %if.end9
  %23 = load i32, i32* %START.addr, align 4
  %24 = load i32, i32* %END.addr, align 4
  %cmp18 = icmp ult i32 %23, %24
  br i1 %cmp18, label %if.then19, label %if.else

if.then19:                                        ; preds = %if.end17
  store i32 0, i32* %index, align 4
  br label %for.cond20

for.cond20:                                       ; preds = %for.inc25, %if.then19
  %25 = load i32, i32* %index, align 4
  %26 = load i32, i32* %LENGTH, align 4
  %cmp21 = icmp ule i32 %25, %26
  br i1 %cmp21, label %for.body22, label %for.end27

for.body22:                                       ; preds = %for.cond20
  %27 = load i32, i32* %start, align 4
  %28 = load i32, i32* %index, align 4
  %add23 = add i32 %27, %28
  %29 = load i32*, i32** %sequence10, align 4
  %30 = load i32, i32* %index, align 4
  %arrayidx24 = getelementptr inbounds i32, i32* %29, i32 %30
  store i32 %add23, i32* %arrayidx24, align 4
  br label %for.inc25

for.inc25:                                        ; preds = %for.body22
  %31 = load i32, i32* %index, align 4
  %inc26 = add i32 %31, 1
  store i32 %inc26, i32* %index, align 4
  br label %for.cond20

for.end27:                                        ; preds = %for.cond20
  br label %if.end37

if.else:                                          ; preds = %if.end17
  store i32 0, i32* %index28, align 4
  br label %for.cond29

for.cond29:                                       ; preds = %for.inc34, %if.else
  %32 = load i32, i32* %index28, align 4
  %33 = load i32, i32* %LENGTH, align 4
  %cmp30 = icmp ule i32 %32, %33
  br i1 %cmp30, label %for.body31, label %for.end36

for.body31:                                       ; preds = %for.cond29
  %34 = load i32, i32* %end, align 4
  %35 = load i32, i32* %index28, align 4
  %sub32 = sub i32 %34, %35
  %36 = load i32*, i32** %sequence10, align 4
  %37 = load i32, i32* %index28, align 4
  %arrayidx33 = getelementptr inbounds i32, i32* %36, i32 %37
  store i32 %sub32, i32* %arrayidx33, align 4
  br label %for.inc34

for.inc34:                                        ; preds = %for.body31
  %38 = load i32, i32* %index28, align 4
  %inc35 = add i32 %38, 1
  store i32 %inc35, i32* %index28, align 4
  br label %for.cond29

for.end36:                                        ; preds = %for.cond29
  br label %if.end37

if.end37:                                         ; preds = %for.end36, %for.end27
  %39 = load i32*, i32** %sequence10, align 4
  store i32* %39, i32** %retval, align 4
  br label %return

return:                                           ; preds = %if.end37, %for.end
  %40 = load i32*, i32** %retval, align 4
  ret i32* %40
}

declare noalias i8* @malloc(i32 %0) #1

declare i32 @printf(i8* %0, ...) #1

declare void @perror(i8* %0) #1

; Function Attrs: noreturn
declare void @exit(i32 %0) #2

; Function Attrs: noinline nounwind optnone
define hidden i32* @order(double* noalias %ARRAY, i32 %SIZE, i1 zeroext %DECREASING) #0 {
entry:
  %ARRAY.addr = alloca double*, align 4
  %SIZE.addr = alloca i32, align 4
  %DECREASING.addr = alloca i8, align 1
  %idx = alloca i32*, align 4
  %i = alloca i32, align 4
  store double* %ARRAY, double** %ARRAY.addr, align 4
  store i32 %SIZE, i32* %SIZE.addr, align 4
  %frombool = zext i1 %DECREASING to i8
  store i8 %frombool, i8* %DECREASING.addr, align 1
  %0 = load i32, i32* %SIZE.addr, align 4
  %mul = mul i32 %0, 4
  %call = call noalias i8* @malloc(i32 %mul)
  %1 = bitcast i8* %call to i32*
  store i32* %1, i32** %idx, align 4
  %2 = load i32*, i32** %idx, align 4
  %cmp = icmp eq i32* %2, null
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %call1 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([33 x i8], [33 x i8]* @.str.3, i32 0, i32 0), i8* getelementptr inbounds ([23 x i8], [23 x i8]* @.str.1, i32 0, i32 0), i32 77)
  call void @perror(i8* getelementptr inbounds ([1 x i8], [1 x i8]* @.str.2, i32 0, i32 0))
  call void @exit(i32 1) #5
  unreachable

if.end:                                           ; preds = %entry
  %3 = load i32, i32* %SIZE.addr, align 4
  %mul2 = mul i32 8, %3
  %call3 = call noalias i8* @malloc(i32 %mul2)
  %4 = bitcast i8* %call3 to double*
  store double* %4, double** @base_arr, align 4
  %5 = load double*, double** @base_arr, align 4
  %cmp4 = icmp eq double* %5, null
  br i1 %cmp4, label %if.then5, label %if.end7

if.then5:                                         ; preds = %if.end
  %call6 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([33 x i8], [33 x i8]* @.str.3, i32 0, i32 0), i8* getelementptr inbounds ([23 x i8], [23 x i8]* @.str.1, i32 0, i32 0), i32 83)
  call void @perror(i8* getelementptr inbounds ([1 x i8], [1 x i8]* @.str.2, i32 0, i32 0))
  call void @exit(i32 1) #5
  unreachable

if.end7:                                          ; preds = %if.end
  store i32 0, i32* %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.end7
  %6 = load i32, i32* %i, align 4
  %7 = load i32, i32* %SIZE.addr, align 4
  %cmp8 = icmp ult i32 %6, %7
  br i1 %cmp8, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %8 = load double*, double** %ARRAY.addr, align 4
  %9 = load i32, i32* %i, align 4
  %arrayidx = getelementptr inbounds double, double* %8, i32 %9
  %10 = load double, double* %arrayidx, align 8
  %11 = load double*, double** @base_arr, align 4
  %12 = load i32, i32* %i, align 4
  %arrayidx9 = getelementptr inbounds double, double* %11, i32 %12
  store double %10, double* %arrayidx9, align 8
  %13 = load i32, i32* %i, align 4
  %14 = load i32*, i32** %idx, align 4
  %15 = load i32, i32* %i, align 4
  %arrayidx10 = getelementptr inbounds i32, i32* %14, i32 %15
  store i32 %13, i32* %arrayidx10, align 4
  br label %for.inc

for.inc:                                          ; preds = %for.body
  %16 = load i32, i32* %i, align 4
  %inc = add i32 %16, 1
  store i32 %inc, i32* %i, align 4
  br label %for.cond

for.end:                                          ; preds = %for.cond
  %17 = load i8, i8* %DECREASING.addr, align 1
  %tobool = trunc i8 %17 to i1
  %conv = zext i1 %tobool to i32
  %cmp11 = icmp eq i32 %conv, 0
  br i1 %cmp11, label %if.then13, label %if.else

if.then13:                                        ; preds = %for.end
  %18 = load i32*, i32** %idx, align 4
  %19 = bitcast i32* %18 to i8*
  %20 = load i32, i32* %SIZE.addr, align 4
  call void @qsort(i8* %19, i32 %20, i32 4, i32 (i8*, i8*)* @compar_decrease)
  br label %if.end20

if.else:                                          ; preds = %for.end
  %21 = load i8, i8* %DECREASING.addr, align 1
  %tobool14 = trunc i8 %21 to i1
  br i1 %tobool14, label %if.then18, label %if.end19

if.then18:                                        ; preds = %if.else
  %22 = load i32*, i32** %idx, align 4
  %23 = bitcast i32* %22 to i8*
  %24 = load i32, i32* %SIZE.addr, align 4
  call void @qsort(i8* %23, i32 %24, i32 4, i32 (i8*, i8*)* @compar_increase)
  br label %if.end19

if.end19:                                         ; preds = %if.then18, %if.else
  br label %if.end20

if.end20:                                         ; preds = %if.end19, %if.then13
  %25 = load double*, double** @base_arr, align 4
  %26 = bitcast double* %25 to i8*
  call void @free(i8* %26)
  store double* null, double** @base_arr, align 4
  %27 = load i32*, i32** %idx, align 4
  ret i32* %27
}

declare void @qsort(i8* %0, i32 %1, i32 %2, i32 (i8*, i8*)* %3) #1

; Function Attrs: noinline nounwind optnone
define internal i32 @compar_decrease(i8* noalias %a, i8* noalias %b) #0 {
entry:
  %retval = alloca i32, align 4
  %a.addr = alloca i8*, align 4
  %b.addr = alloca i8*, align 4
  %aa = alloca i32, align 4
  %bb = alloca i32, align 4
  store i8* %a, i8** %a.addr, align 4
  store i8* %b, i8** %b.addr, align 4
  %0 = load i8*, i8** %a.addr, align 4
  %1 = bitcast i8* %0 to i32*
  %2 = load i32, i32* %1, align 4
  store i32 %2, i32* %aa, align 4
  %3 = load i8*, i8** %b.addr, align 4
  %4 = bitcast i8* %3 to i32*
  %5 = load i32, i32* %4, align 4
  store i32 %5, i32* %bb, align 4
  %6 = load double*, double** @base_arr, align 4
  %7 = load i32, i32* %aa, align 4
  %arrayidx = getelementptr inbounds double, double* %6, i32 %7
  %8 = load double, double* %arrayidx, align 8
  %9 = load double*, double** @base_arr, align 4
  %10 = load i32, i32* %bb, align 4
  %arrayidx1 = getelementptr inbounds double, double* %9, i32 %10
  %11 = load double, double* %arrayidx1, align 8
  %cmp = fcmp olt double %8, %11
  br i1 %cmp, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  store i32 -1, i32* %retval, align 4
  br label %return

if.else:                                          ; preds = %entry
  %12 = load double*, double** @base_arr, align 4
  %13 = load i32, i32* %aa, align 4
  %arrayidx2 = getelementptr inbounds double, double* %12, i32 %13
  %14 = load double, double* %arrayidx2, align 8
  %15 = load double*, double** @base_arr, align 4
  %16 = load i32, i32* %bb, align 4
  %arrayidx3 = getelementptr inbounds double, double* %15, i32 %16
  %17 = load double, double* %arrayidx3, align 8
  %cmp4 = fcmp oeq double %14, %17
  br i1 %cmp4, label %if.then5, label %if.else6

if.then5:                                         ; preds = %if.else
  store i32 0, i32* %retval, align 4
  br label %return

if.else6:                                         ; preds = %if.else
  store i32 1, i32* %retval, align 4
  br label %return

return:                                           ; preds = %if.else6, %if.then5, %if.then
  %18 = load i32, i32* %retval, align 4
  ret i32 %18
}

; Function Attrs: noinline nounwind optnone
define internal i32 @compar_increase(i8* noalias %a, i8* noalias %b) #0 {
entry:
  %retval = alloca i32, align 4
  %a.addr = alloca i8*, align 4
  %b.addr = alloca i8*, align 4
  %aa = alloca i32, align 4
  %bb = alloca i32, align 4
  store i8* %a, i8** %a.addr, align 4
  store i8* %b, i8** %b.addr, align 4
  %0 = load i8*, i8** %a.addr, align 4
  %1 = bitcast i8* %0 to i32*
  %2 = load i32, i32* %1, align 4
  store i32 %2, i32* %aa, align 4
  %3 = load i8*, i8** %b.addr, align 4
  %4 = bitcast i8* %3 to i32*
  %5 = load i32, i32* %4, align 4
  store i32 %5, i32* %bb, align 4
  %6 = load double*, double** @base_arr, align 4
  %7 = load i32, i32* %aa, align 4
  %arrayidx = getelementptr inbounds double, double* %6, i32 %7
  %8 = load double, double* %arrayidx, align 8
  %9 = load double*, double** @base_arr, align 4
  %10 = load i32, i32* %bb, align 4
  %arrayidx1 = getelementptr inbounds double, double* %9, i32 %10
  %11 = load double, double* %arrayidx1, align 8
  %cmp = fcmp olt double %8, %11
  br i1 %cmp, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  store i32 1, i32* %retval, align 4
  br label %return

if.else:                                          ; preds = %entry
  %12 = load double*, double** @base_arr, align 4
  %13 = load i32, i32* %aa, align 4
  %arrayidx2 = getelementptr inbounds double, double* %12, i32 %13
  %14 = load double, double* %arrayidx2, align 8
  %15 = load double*, double** @base_arr, align 4
  %16 = load i32, i32* %bb, align 4
  %arrayidx3 = getelementptr inbounds double, double* %15, i32 %16
  %17 = load double, double* %arrayidx3, align 8
  %cmp4 = fcmp oeq double %14, %17
  br i1 %cmp4, label %if.then5, label %if.else6

if.then5:                                         ; preds = %if.else
  store i32 0, i32* %retval, align 4
  br label %return

if.else6:                                         ; preds = %if.else
  store i32 -1, i32* %retval, align 4
  br label %return

return:                                           ; preds = %if.else6, %if.then5, %if.then
  %18 = load i32, i32* %retval, align 4
  ret i32 %18
}

declare void @free(i8* %0) #1

; Function Attrs: noinline nounwind optnone
define hidden double* @cummin(double* noalias %ARRAY, i32 %NO_OF_ARRAY_ELEMENTS) #0 {
entry:
  %ARRAY.addr = alloca double*, align 4
  %NO_OF_ARRAY_ELEMENTS.addr = alloca i32, align 4
  %output = alloca double*, align 4
  %cumulative_min = alloca double, align 8
  %i = alloca i32, align 4
  store double* %ARRAY, double** %ARRAY.addr, align 4
  store i32 %NO_OF_ARRAY_ELEMENTS, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
  %0 = load i32, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
  %cmp = icmp ult i32 %0, 1
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %call = call i32 @puts(i8* getelementptr inbounds ([48 x i8], [48 x i8]* @.str.4, i32 0, i32 0))
  %call1 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([22 x i8], [22 x i8]* @.str.5, i32 0, i32 0), i8* getelementptr inbounds ([23 x i8], [23 x i8]* @.str.1, i32 0, i32 0), i32 105)
  call void @exit(i32 1) #5
  unreachable

if.end:                                           ; preds = %entry
  %1 = load i32, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
  %mul = mul i32 8, %1
  %call2 = call noalias i8* @malloc(i32 %mul)
  %2 = bitcast i8* %call2 to double*
  store double* %2, double** %output, align 4
  %3 = load double*, double** %output, align 4
  %cmp3 = icmp eq double* %3, null
  br i1 %cmp3, label %if.then4, label %if.end6

if.then4:                                         ; preds = %if.end
  %call5 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([33 x i8], [33 x i8]* @.str.3, i32 0, i32 0), i8* getelementptr inbounds ([23 x i8], [23 x i8]* @.str.1, i32 0, i32 0), i32 110)
  call void @perror(i8* getelementptr inbounds ([1 x i8], [1 x i8]* @.str.2, i32 0, i32 0))
  call void @exit(i32 1) #5
  unreachable

if.end6:                                          ; preds = %if.end
  %4 = load double*, double** %ARRAY.addr, align 4
  %arrayidx = getelementptr inbounds double, double* %4, i32 0
  %5 = load double, double* %arrayidx, align 8
  store double %5, double* %cumulative_min, align 8
  store i32 0, i32* %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.end6
  %6 = load i32, i32* %i, align 4
  %7 = load i32, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
  %cmp7 = icmp ult i32 %6, %7
  br i1 %cmp7, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %8 = load double*, double** %ARRAY.addr, align 4
  %9 = load i32, i32* %i, align 4
  %arrayidx8 = getelementptr inbounds double, double* %8, i32 %9
  %10 = load double, double* %arrayidx8, align 8
  %11 = load double, double* %cumulative_min, align 8
  %cmp9 = fcmp olt double %10, %11
  br i1 %cmp9, label %if.then10, label %if.end12

if.then10:                                        ; preds = %for.body
  %12 = load double*, double** %ARRAY.addr, align 4
  %13 = load i32, i32* %i, align 4
  %arrayidx11 = getelementptr inbounds double, double* %12, i32 %13
  %14 = load double, double* %arrayidx11, align 8
  store double %14, double* %cumulative_min, align 8
  br label %if.end12

if.end12:                                         ; preds = %if.then10, %for.body
  %15 = load double, double* %cumulative_min, align 8
  %16 = load double*, double** %output, align 4
  %17 = load i32, i32* %i, align 4
  %arrayidx13 = getelementptr inbounds double, double* %16, i32 %17
  store double %15, double* %arrayidx13, align 8
  br label %for.inc

for.inc:                                          ; preds = %if.end12
  %18 = load i32, i32* %i, align 4
  %inc = add i32 %18, 1
  store i32 %inc, i32* %i, align 4
  br label %for.cond

for.end:                                          ; preds = %for.cond
  %19 = load double*, double** %output, align 4
  ret double* %19
}

declare i32 @puts(i8* %0) #1

; Function Attrs: noinline nounwind optnone
define hidden double* @cummax(double* noalias %ARRAY, i32 %NO_OF_ARRAY_ELEMENTS) #0 {
entry:
  %ARRAY.addr = alloca double*, align 4
  %NO_OF_ARRAY_ELEMENTS.addr = alloca i32, align 4
  %output = alloca double*, align 4
  %cumulative_max = alloca double, align 8
  %i = alloca i32, align 4
  store double* %ARRAY, double** %ARRAY.addr, align 4
  store i32 %NO_OF_ARRAY_ELEMENTS, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
  %0 = load i32, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
  %cmp = icmp ult i32 %0, 1
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %call = call i32 @puts(i8* getelementptr inbounds ([41 x i8], [41 x i8]* @.str.6, i32 0, i32 0))
  %call1 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([22 x i8], [22 x i8]* @.str.5, i32 0, i32 0), i8* getelementptr inbounds ([23 x i8], [23 x i8]* @.str.1, i32 0, i32 0), i32 129)
  call void @exit(i32 1) #5
  unreachable

if.end:                                           ; preds = %entry
  %1 = load i32, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
  %mul = mul i32 8, %1
  %call2 = call noalias i8* @malloc(i32 %mul)
  %2 = bitcast i8* %call2 to double*
  store double* %2, double** %output, align 4
  %3 = load double*, double** %output, align 4
  %cmp3 = icmp eq double* %3, null
  br i1 %cmp3, label %if.then4, label %if.end6

if.then4:                                         ; preds = %if.end
  %call5 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([33 x i8], [33 x i8]* @.str.3, i32 0, i32 0), i8* getelementptr inbounds ([23 x i8], [23 x i8]* @.str.1, i32 0, i32 0), i32 134)
  call void @perror(i8* getelementptr inbounds ([1 x i8], [1 x i8]* @.str.2, i32 0, i32 0))
  call void @exit(i32 1) #5
  unreachable

if.end6:                                          ; preds = %if.end
  %4 = load double*, double** %ARRAY.addr, align 4
  %arrayidx = getelementptr inbounds double, double* %4, i32 0
  %5 = load double, double* %arrayidx, align 8
  store double %5, double* %cumulative_max, align 8
  store i32 0, i32* %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.end6
  %6 = load i32, i32* %i, align 4
  %7 = load i32, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
  %cmp7 = icmp ult i32 %6, %7
  br i1 %cmp7, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %8 = load double*, double** %ARRAY.addr, align 4
  %9 = load i32, i32* %i, align 4
  %arrayidx8 = getelementptr inbounds double, double* %8, i32 %9
  %10 = load double, double* %arrayidx8, align 8
  %11 = load double, double* %cumulative_max, align 8
  %cmp9 = fcmp ogt double %10, %11
  br i1 %cmp9, label %if.then10, label %if.end12

if.then10:                                        ; preds = %for.body
  %12 = load double*, double** %ARRAY.addr, align 4
  %13 = load i32, i32* %i, align 4
  %arrayidx11 = getelementptr inbounds double, double* %12, i32 %13
  %14 = load double, double* %arrayidx11, align 8
  store double %14, double* %cumulative_max, align 8
  br label %if.end12

if.end12:                                         ; preds = %if.then10, %for.body
  %15 = load double, double* %cumulative_max, align 8
  %16 = load double*, double** %output, align 4
  %17 = load i32, i32* %i, align 4
  %arrayidx13 = getelementptr inbounds double, double* %16, i32 %17
  store double %15, double* %arrayidx13, align 8
  br label %for.inc

for.inc:                                          ; preds = %if.end12
  %18 = load i32, i32* %i, align 4
  %inc = add i32 %18, 1
  store i32 %inc, i32* %i, align 4
  br label %for.cond

for.end:                                          ; preds = %for.cond
  %19 = load double*, double** %output, align 4
  ret double* %19
}

; Function Attrs: noinline nounwind optnone
define hidden double* @pminx(double* noalias %ARRAY, i32 %NO_OF_ARRAY_ELEMENTS, double %X) #0 {
entry:
  %ARRAY.addr = alloca double*, align 4
  %NO_OF_ARRAY_ELEMENTS.addr = alloca i32, align 4
  %X.addr = alloca double, align 8
  %pmin_array = alloca double*, align 4
  %index = alloca i32, align 4
  store double* %ARRAY, double** %ARRAY.addr, align 4
  store i32 %NO_OF_ARRAY_ELEMENTS, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
  store double %X, double* %X.addr, align 8
  %0 = load i32, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
  %cmp = icmp ult i32 %0, 1
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %call = call i32 @puts(i8* getelementptr inbounds ([37 x i8], [37 x i8]* @.str.7, i32 0, i32 0))
  %call1 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([22 x i8], [22 x i8]* @.str.5, i32 0, i32 0), i8* getelementptr inbounds ([23 x i8], [23 x i8]* @.str.1, i32 0, i32 0), i32 152)
  call void @exit(i32 1) #5
  unreachable

if.end:                                           ; preds = %entry
  %1 = load i32, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
  %mul = mul i32 8, %1
  %call2 = call noalias i8* @malloc(i32 %mul)
  %2 = bitcast i8* %call2 to double*
  store double* %2, double** %pmin_array, align 4
  %3 = load double*, double** %pmin_array, align 4
  %cmp3 = icmp eq double* %3, null
  br i1 %cmp3, label %if.then4, label %if.end6

if.then4:                                         ; preds = %if.end
  %call5 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([33 x i8], [33 x i8]* @.str.3, i32 0, i32 0), i8* getelementptr inbounds ([23 x i8], [23 x i8]* @.str.1, i32 0, i32 0), i32 157)
  call void @perror(i8* getelementptr inbounds ([1 x i8], [1 x i8]* @.str.2, i32 0, i32 0))
  call void @exit(i32 1) #5
  unreachable

if.end6:                                          ; preds = %if.end
  store i32 0, i32* %index, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.end6
  %4 = load i32, i32* %index, align 4
  %5 = load i32, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
  %cmp7 = icmp ult i32 %4, %5
  br i1 %cmp7, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %6 = load double*, double** %ARRAY.addr, align 4
  %7 = load i32, i32* %index, align 4
  %arrayidx = getelementptr inbounds double, double* %6, i32 %7
  %8 = load double, double* %arrayidx, align 8
  %9 = load double, double* %X.addr, align 8
  %cmp8 = fcmp olt double %8, %9
  br i1 %cmp8, label %if.then9, label %if.else

if.then9:                                         ; preds = %for.body
  %10 = load double*, double** %ARRAY.addr, align 4
  %11 = load i32, i32* %index, align 4
  %arrayidx10 = getelementptr inbounds double, double* %10, i32 %11
  %12 = load double, double* %arrayidx10, align 8
  %13 = load double*, double** %pmin_array, align 4
  %14 = load i32, i32* %index, align 4
  %arrayidx11 = getelementptr inbounds double, double* %13, i32 %14
  store double %12, double* %arrayidx11, align 8
  br label %if.end13

if.else:                                          ; preds = %for.body
  %15 = load double, double* %X.addr, align 8
  %16 = load double*, double** %pmin_array, align 4
  %17 = load i32, i32* %index, align 4
  %arrayidx12 = getelementptr inbounds double, double* %16, i32 %17
  store double %15, double* %arrayidx12, align 8
  br label %if.end13

if.end13:                                         ; preds = %if.else, %if.then9
  br label %for.inc

for.inc:                                          ; preds = %if.end13
  %18 = load i32, i32* %index, align 4
  %inc = add i32 %18, 1
  store i32 %inc, i32* %index, align 4
  br label %for.cond

for.end:                                          ; preds = %for.cond
  %19 = load double*, double** %pmin_array, align 4
  ret double* %19
}

; Function Attrs: noinline nounwind optnone
define hidden void @double_say(double* noalias %ARRAY, i32 %NO_OF_ARRAY_ELEMENTS) #0 {
entry:
  %ARRAY.addr = alloca double*, align 4
  %NO_OF_ARRAY_ELEMENTS.addr = alloca i32, align 4
  %i = alloca i32, align 4
  store double* %ARRAY, double** %ARRAY.addr, align 4
  store i32 %NO_OF_ARRAY_ELEMENTS, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
  %0 = load double*, double** %ARRAY.addr, align 4
  %arrayidx = getelementptr inbounds double, double* %0, i32 0
  %1 = load double, double* %arrayidx, align 8
  %call = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([7 x i8], [7 x i8]* @.str.8, i32 0, i32 0), double %1)
  store i32 1, i32* %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %2 = load i32, i32* %i, align 4
  %3 = load i32, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
  %cmp = icmp ult i32 %2, %3
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %4 = load double*, double** %ARRAY.addr, align 4
  %5 = load i32, i32* %i, align 4
  %arrayidx1 = getelementptr inbounds double, double* %4, i32 %5
  %6 = load double, double* %arrayidx1, align 8
  %call2 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([7 x i8], [7 x i8]* @.str.9, i32 0, i32 0), double %6)
  %7 = load i32, i32* %i, align 4
  %add = add i32 %7, 1
  %rem = urem i32 %add, 5
  %cmp3 = icmp eq i32 %rem, 0
  br i1 %cmp3, label %if.then, label %if.end

if.then:                                          ; preds = %for.body
  %8 = load i32, i32* %i, align 4
  %add4 = add i32 %8, 1
  %call5 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([6 x i8], [6 x i8]* @.str.10, i32 0, i32 0), i32 %add4)
  br label %if.end

if.end:                                           ; preds = %if.then, %for.body
  br label %for.inc

for.inc:                                          ; preds = %if.end
  %9 = load i32, i32* %i, align 4
  %inc = add i32 %9, 1
  store i32 %inc, i32* %i, align 4
  br label %for.cond

for.end:                                          ; preds = %for.cond
  %call6 = call i32 @puts(i8* getelementptr inbounds ([2 x i8], [2 x i8]* @.str.11, i32 0, i32 0))
  ret void
}

; Function Attrs: noinline nounwind optnone
define hidden double* @uint2double(i32* noalias %ARRAY, i32 %NO_OF_ARRAY_ELEMENTS) #0 {
entry:
  %ARRAY.addr = alloca i32*, align 4
  %NO_OF_ARRAY_ELEMENTS.addr = alloca i32, align 4
  %doubleArray = alloca double*, align 4
  %index = alloca i32, align 4
  store i32* %ARRAY, i32** %ARRAY.addr, align 4
  store i32 %NO_OF_ARRAY_ELEMENTS, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
  %0 = load i32, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
  %mul = mul i32 8, %0
  %call = call noalias i8* @malloc(i32 %mul)
  %1 = bitcast i8* %call to double*
  store double* %1, double** %doubleArray, align 4
  %2 = load double*, double** %doubleArray, align 4
  %cmp = icmp eq double* %2, null
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %call1 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([34 x i8], [34 x i8]* @.str.12, i32 0, i32 0), i8* getelementptr inbounds ([23 x i8], [23 x i8]* @.str.1, i32 0, i32 0), i32 194)
  call void @perror(i8* getelementptr inbounds ([1 x i8], [1 x i8]* @.str.2, i32 0, i32 0))
  call void @exit(i32 1) #5
  unreachable

if.end:                                           ; preds = %entry
  store i32 0, i32* %index, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.end
  %3 = load i32, i32* %index, align 4
  %4 = load i32, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
  %cmp2 = icmp ult i32 %3, %4
  br i1 %cmp2, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %5 = load i32*, i32** %ARRAY.addr, align 4
  %6 = load i32, i32* %index, align 4
  %arrayidx = getelementptr inbounds i32, i32* %5, i32 %6
  %7 = load i32, i32* %arrayidx, align 4
  %conv = uitofp i32 %7 to double
  %8 = load double*, double** %doubleArray, align 4
  %9 = load i32, i32* %index, align 4
  %arrayidx3 = getelementptr inbounds double, double* %8, i32 %9
  store double %conv, double* %arrayidx3, align 8
  br label %for.inc

for.inc:                                          ; preds = %for.body
  %10 = load i32, i32* %index, align 4
  %inc = add i32 %10, 1
  store i32 %inc, i32* %index, align 4
  br label %for.cond

for.end:                                          ; preds = %for.cond
  %11 = load double*, double** %doubleArray, align 4
  ret double* %11
}

; Function Attrs: noinline nounwind optnone
define hidden double @min2(double %N1, double %N2) #0 {
entry:
  %retval = alloca double, align 8
  %N1.addr = alloca double, align 8
  %N2.addr = alloca double, align 8
  store double %N1, double* %N1.addr, align 8
  store double %N2, double* %N2.addr, align 8
  %0 = load double, double* %N1.addr, align 8
  %1 = load double, double* %N2.addr, align 8
  %cmp = fcmp olt double %0, %1
  br i1 %cmp, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  %2 = load double, double* %N1.addr, align 8
  store double %2, double* %retval, align 8
  br label %return

if.else:                                          ; preds = %entry
  %3 = load double, double* %N2.addr, align 8
  store double %3, double* %retval, align 8
  br label %return

return:                                           ; preds = %if.else, %if.then
  %4 = load double, double* %retval, align 8
  ret double %4
}

; Function Attrs: noinline nounwind optnone
define hidden double* @p_adjust(double* noalias %PVALUES, i32 %NO_OF_ARRAY_ELEMENTS, i8* noalias %STRING) #0 {
entry:
  %retval = alloca double*, align 4
  %PVALUES.addr = alloca double*, align 4
  %NO_OF_ARRAY_ELEMENTS.addr = alloca i32, align 4
  %STRING.addr = alloca i8*, align 4
  %TYPE = alloca i16, align 2
  %bonferroni = alloca double*, align 4
  %index = alloca i32, align 4
  %BONFERRONI = alloca double, align 8
  %o = alloca i32*, align 4
  %o2double = alloca double*, align 4
  %cummax_input = alloca double*, align 4
  %index80 = alloca i32, align 4
  %ro = alloca i32*, align 4
  %cummax_output = alloca double*, align 4
  %pmin = alloca double*, align 4
  %qvalues = alloca double*, align 4
  %index98 = alloca i32, align 4
  %o114 = alloca i32*, align 4
  %p = alloca double*, align 4
  %index123 = alloca i32, align 4
  %o2double134 = alloca double*, align 4
  %ro136 = alloca i32*, align 4
  %q = alloca double*, align 4
  %pa = alloca double*, align 4
  %min = alloca double, align 8
  %index155 = alloca i32, align 4
  %TEMP = alloca double, align 8
  %index171 = alloca i32, align 4
  %j = alloca i32, align 4
  %ij = alloca i32*, align 4
  %I2_LENGTH = alloca i32, align 4
  %i2 = alloca i32*, align 4
  %i = alloca i32, align 4
  %q1 = alloca double, align 8
  %i208 = alloca i32, align 4
  %TEMP_Q1 = alloca double, align 8
  %i227 = alloca i32, align 4
  %i244 = alloca i32, align 4
  %i256 = alloca i32, align 4
  %index274 = alloca i32, align 4
  %o288 = alloca i32*, align 4
  %o_double = alloca double*, align 4
  %index296 = alloca i32, align 4
  %ro315 = alloca i32*, align 4
  %cummin_input = alloca double*, align 4
  %index328 = alloca i32, align 4
  %NI = alloca double, align 8
  %q349 = alloca double, align 8
  %index350 = alloca i32, align 4
  %index362 = alloca i32, align 4
  %NI367 = alloca double, align 8
  %index385 = alloca i32, align 4
  %cummin_array = alloca double*, align 4
  %pmin403 = alloca double*, align 4
  %q_array = alloca double*, align 4
  %index407 = alloca i32, align 4
  store double* %PVALUES, double** %PVALUES.addr, align 4
  store i32 %NO_OF_ARRAY_ELEMENTS, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
  store i8* %STRING, i8** %STRING.addr, align 4
  %0 = load i32, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
  %cmp = icmp ult i32 %0, 1
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %call = call i32 @puts(i8* getelementptr inbounds ([41 x i8], [41 x i8]* @.str.13, i32 0, i32 0))
  %call1 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([22 x i8], [22 x i8]* @.str.5, i32 0, i32 0), i8* getelementptr inbounds ([23 x i8], [23 x i8]* @.str.1, i32 0, i32 0), i32 217)
  call void @exit(i32 1) #5
  unreachable

if.end:                                           ; preds = %entry
  store i16 -1, i16* %TYPE, align 2
  %1 = load i8*, i8** %STRING.addr, align 4
  %cmp2 = icmp eq i8* %1, null
  br i1 %cmp2, label %if.then3, label %if.else

if.then3:                                         ; preds = %if.end
  store i16 0, i16* %TYPE, align 2
  br label %if.end41

if.else:                                          ; preds = %if.end
  %2 = load i8*, i8** %STRING.addr, align 4
  %call4 = call i32 @strcasecmp(i8* %2, i8* getelementptr inbounds ([3 x i8], [3 x i8]* @.str.14, i32 0, i32 0))
  %cmp5 = icmp eq i32 %call4, 0
  br i1 %cmp5, label %if.then6, label %if.else7

if.then6:                                         ; preds = %if.else
  store i16 0, i16* %TYPE, align 2
  br label %if.end40

if.else7:                                         ; preds = %if.else
  %3 = load i8*, i8** %STRING.addr, align 4
  %call8 = call i32 @strcasecmp(i8* %3, i8* getelementptr inbounds ([4 x i8], [4 x i8]* @.str.15, i32 0, i32 0))
  %cmp9 = icmp eq i32 %call8, 0
  br i1 %cmp9, label %if.then10, label %if.else11

if.then10:                                        ; preds = %if.else7
  store i16 0, i16* %TYPE, align 2
  br label %if.end39

if.else11:                                        ; preds = %if.else7
  %4 = load i8*, i8** %STRING.addr, align 4
  %call12 = call i32 @strcasecmp(i8* %4, i8* getelementptr inbounds ([3 x i8], [3 x i8]* @.str.16, i32 0, i32 0))
  %cmp13 = icmp eq i32 %call12, 0
  br i1 %cmp13, label %if.then14, label %if.else15

if.then14:                                        ; preds = %if.else11
  store i16 1, i16* %TYPE, align 2
  br label %if.end38

if.else15:                                        ; preds = %if.else11
  %5 = load i8*, i8** %STRING.addr, align 4
  %call16 = call i32 @strcasecmp(i8* %5, i8* getelementptr inbounds ([11 x i8], [11 x i8]* @.str.17, i32 0, i32 0))
  %cmp17 = icmp eq i32 %call16, 0
  br i1 %cmp17, label %if.then18, label %if.else19

if.then18:                                        ; preds = %if.else15
  store i16 2, i16* %TYPE, align 2
  br label %if.end37

if.else19:                                        ; preds = %if.else15
  %6 = load i8*, i8** %STRING.addr, align 4
  %call20 = call i32 @strcasecmp(i8* %6, i8* getelementptr inbounds ([9 x i8], [9 x i8]* @.str.18, i32 0, i32 0))
  %cmp21 = icmp eq i32 %call20, 0
  br i1 %cmp21, label %if.then22, label %if.else23

if.then22:                                        ; preds = %if.else19
  store i16 3, i16* %TYPE, align 2
  br label %if.end36

if.else23:                                        ; preds = %if.else19
  %7 = load i8*, i8** %STRING.addr, align 4
  %call24 = call i32 @strcasecmp(i8* %7, i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.19, i32 0, i32 0))
  %cmp25 = icmp eq i32 %call24, 0
  br i1 %cmp25, label %if.then26, label %if.else27

if.then26:                                        ; preds = %if.else23
  store i16 4, i16* %TYPE, align 2
  br label %if.end35

if.else27:                                        ; preds = %if.else23
  %8 = load i8*, i8** %STRING.addr, align 4
  %call28 = call i32 @strcasecmp(i8* %8, i8* getelementptr inbounds ([7 x i8], [7 x i8]* @.str.20, i32 0, i32 0))
  %cmp29 = icmp eq i32 %call28, 0
  br i1 %cmp29, label %if.then30, label %if.else31

if.then30:                                        ; preds = %if.else27
  store i16 5, i16* %TYPE, align 2
  br label %if.end34

if.else31:                                        ; preds = %if.else27
  %9 = load i8*, i8** %STRING.addr, align 4
  %call32 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([44 x i8], [44 x i8]* @.str.21, i32 0, i32 0), i8* %9)
  %call33 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([22 x i8], [22 x i8]* @.str.5, i32 0, i32 0), i8* getelementptr inbounds ([23 x i8], [23 x i8]* @.str.1, i32 0, i32 0), i32 239)
  call void @exit(i32 1) #5
  unreachable

if.end34:                                         ; preds = %if.then30
  br label %if.end35

if.end35:                                         ; preds = %if.end34, %if.then26
  br label %if.end36

if.end36:                                         ; preds = %if.end35, %if.then22
  br label %if.end37

if.end37:                                         ; preds = %if.end36, %if.then18
  br label %if.end38

if.end38:                                         ; preds = %if.end37, %if.then14
  br label %if.end39

if.end39:                                         ; preds = %if.end38, %if.then10
  br label %if.end40

if.end40:                                         ; preds = %if.end39, %if.then6
  br label %if.end41

if.end41:                                         ; preds = %if.end40, %if.then3
  %10 = load i16, i16* %TYPE, align 2
  %conv = sext i16 %10 to i32
  %cmp42 = icmp eq i32 %conv, 2
  br i1 %cmp42, label %if.then44, label %if.else71

if.then44:                                        ; preds = %if.end41
  %11 = load i32, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
  %mul = mul i32 8, %11
  %call45 = call noalias i8* @malloc(i32 %mul)
  %12 = bitcast i8* %call45 to double*
  store double* %12, double** %bonferroni, align 4
  %13 = load double*, double** %bonferroni, align 4
  %cmp46 = icmp eq double* %13, null
  br i1 %cmp46, label %if.then48, label %if.end50

if.then48:                                        ; preds = %if.then44
  %call49 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([33 x i8], [33 x i8]* @.str.3, i32 0, i32 0), i8* getelementptr inbounds ([23 x i8], [23 x i8]* @.str.1, i32 0, i32 0), i32 247)
  call void @perror(i8* getelementptr inbounds ([1 x i8], [1 x i8]* @.str.2, i32 0, i32 0))
  call void @exit(i32 1) #5
  unreachable

if.end50:                                         ; preds = %if.then44
  store i32 0, i32* %index, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.end50
  %14 = load i32, i32* %index, align 4
  %15 = load i32, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
  %cmp51 = icmp ult i32 %14, %15
  br i1 %cmp51, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %16 = load double*, double** %PVALUES.addr, align 4
  %17 = load i32, i32* %index, align 4
  %arrayidx = getelementptr inbounds double, double* %16, i32 %17
  %18 = load double, double* %arrayidx, align 8
  %19 = load i32, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
  %conv53 = uitofp i32 %19 to double
  %mul54 = fmul double %18, %conv53
  store double %mul54, double* %BONFERRONI, align 8
  %20 = load double, double* %BONFERRONI, align 8
  %cmp55 = fcmp oge double %20, 1.000000e+00
  br i1 %cmp55, label %if.then57, label %if.else59

if.then57:                                        ; preds = %for.body
  %21 = load double*, double** %bonferroni, align 4
  %22 = load i32, i32* %index, align 4
  %arrayidx58 = getelementptr inbounds double, double* %21, i32 %22
  store double 1.000000e+00, double* %arrayidx58, align 8
  br label %if.end70

if.else59:                                        ; preds = %for.body
  %23 = load double, double* %BONFERRONI, align 8
  %cmp60 = fcmp ole double 0.000000e+00, %23
  br i1 %cmp60, label %land.lhs.true, label %if.else66

land.lhs.true:                                    ; preds = %if.else59
  %24 = load double, double* %BONFERRONI, align 8
  %cmp62 = fcmp olt double %24, 1.000000e+00
  br i1 %cmp62, label %if.then64, label %if.else66

if.then64:                                        ; preds = %land.lhs.true
  %25 = load double, double* %BONFERRONI, align 8
  %26 = load double*, double** %bonferroni, align 4
  %27 = load i32, i32* %index, align 4
  %arrayidx65 = getelementptr inbounds double, double* %26, i32 %27
  store double %25, double* %arrayidx65, align 8
  br label %if.end69

if.else66:                                        ; preds = %land.lhs.true, %if.else59
  %28 = load double, double* %BONFERRONI, align 8
  %call67 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([42 x i8], [42 x i8]* @.str.22, i32 0, i32 0), double %28)
  %call68 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([23 x i8], [23 x i8]* @.str.23, i32 0, i32 0), i8* getelementptr inbounds ([23 x i8], [23 x i8]* @.str.1, i32 0, i32 0), i32 259)
  call void @exit(i32 1) #5
  unreachable

if.end69:                                         ; preds = %if.then64
  br label %if.end70

if.end70:                                         ; preds = %if.end69, %if.then57
  br label %for.inc

for.inc:                                          ; preds = %if.end70
  %29 = load i32, i32* %index, align 4
  %inc = add i32 %29, 1
  store i32 %inc, i32* %index, align 4
  br label %for.cond

for.end:                                          ; preds = %for.cond
  %30 = load double*, double** %bonferroni, align 4
  store double* %30, double** %retval, align 4
  br label %return

if.else71:                                        ; preds = %if.end41
  %31 = load i16, i16* %TYPE, align 2
  %conv72 = sext i16 %31 to i32
  %cmp73 = icmp eq i32 %conv72, 4
  br i1 %cmp73, label %if.then75, label %if.else109

if.then75:                                        ; preds = %if.else71
  %32 = load double*, double** %PVALUES.addr, align 4
  %33 = load i32, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
  %call76 = call i32* @order(double* %32, i32 %33, i1 zeroext false)
  store i32* %call76, i32** %o, align 4
  %34 = load i32*, i32** %o, align 4
  %35 = load i32, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
  %call77 = call double* @uint2double(i32* %34, i32 %35)
  store double* %call77, double** %o2double, align 4
  %36 = load i32, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
  %mul78 = mul i32 8, %36
  %call79 = call noalias i8* @malloc(i32 %mul78)
  %37 = bitcast i8* %call79 to double*
  store double* %37, double** %cummax_input, align 4
  store i32 0, i32* %index80, align 4
  br label %for.cond81

for.cond81:                                       ; preds = %for.inc90, %if.then75
  %38 = load i32, i32* %index80, align 4
  %39 = load i32, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
  %cmp82 = icmp ult i32 %38, %39
  br i1 %cmp82, label %for.body84, label %for.end92

for.body84:                                       ; preds = %for.cond81
  %40 = load i32, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
  %41 = load i32, i32* %index80, align 4
  %sub = sub i32 %40, %41
  %conv85 = uitofp i32 %sub to double
  %42 = load double*, double** %PVALUES.addr, align 4
  %43 = load i32*, i32** %o, align 4
  %44 = load i32, i32* %index80, align 4
  %arrayidx86 = getelementptr inbounds i32, i32* %43, i32 %44
  %45 = load i32, i32* %arrayidx86, align 4
  %arrayidx87 = getelementptr inbounds double, double* %42, i32 %45
  %46 = load double, double* %arrayidx87, align 8
  %mul88 = fmul double %conv85, %46
  %47 = load double*, double** %cummax_input, align 4
  %48 = load i32, i32* %index80, align 4
  %arrayidx89 = getelementptr inbounds double, double* %47, i32 %48
  store double %mul88, double* %arrayidx89, align 8
  br label %for.inc90

for.inc90:                                        ; preds = %for.body84
  %49 = load i32, i32* %index80, align 4
  %inc91 = add i32 %49, 1
  store i32 %inc91, i32* %index80, align 4
  br label %for.cond81

for.end92:                                        ; preds = %for.cond81
  %50 = load i32*, i32** %o, align 4
  %51 = bitcast i32* %50 to i8*
  call void @free(i8* %51)
  store i32* null, i32** %o, align 4
  %52 = load double*, double** %o2double, align 4
  %53 = load i32, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
  %call93 = call i32* @order(double* %52, i32 %53, i1 zeroext false)
  store i32* %call93, i32** %ro, align 4
  %54 = load double*, double** %o2double, align 4
  %55 = bitcast double* %54 to i8*
  call void @free(i8* %55)
  store double* null, double** %o2double, align 4
  %56 = load double*, double** %cummax_input, align 4
  %57 = load i32, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
  %call94 = call double* @cummax(double* %56, i32 %57)
  store double* %call94, double** %cummax_output, align 4
  %58 = load double*, double** %cummax_input, align 4
  %59 = bitcast double* %58 to i8*
  call void @free(i8* %59)
  store double* null, double** %cummax_input, align 4
  %60 = load double*, double** %cummax_output, align 4
  %61 = load i32, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
  %call95 = call double* @pminx(double* %60, i32 %61, double 1.000000e+00)
  store double* %call95, double** %pmin, align 4
  %62 = load double*, double** %cummax_output, align 4
  %63 = bitcast double* %62 to i8*
  call void @free(i8* %63)
  store double* null, double** %cummax_output, align 4
  %64 = load i32, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
  %mul96 = mul i32 8, %64
  %call97 = call noalias i8* @malloc(i32 %mul96)
  %65 = bitcast i8* %call97 to double*
  store double* %65, double** %qvalues, align 4
  store i32 0, i32* %index98, align 4
  br label %for.cond99

for.cond99:                                       ; preds = %for.inc106, %for.end92
  %66 = load i32, i32* %index98, align 4
  %67 = load i32, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
  %cmp100 = icmp ult i32 %66, %67
  br i1 %cmp100, label %for.body102, label %for.end108

for.body102:                                      ; preds = %for.cond99
  %68 = load double*, double** %pmin, align 4
  %69 = load i32*, i32** %ro, align 4
  %70 = load i32, i32* %index98, align 4
  %arrayidx103 = getelementptr inbounds i32, i32* %69, i32 %70
  %71 = load i32, i32* %arrayidx103, align 4
  %arrayidx104 = getelementptr inbounds double, double* %68, i32 %71
  %72 = load double, double* %arrayidx104, align 8
  %73 = load double*, double** %qvalues, align 4
  %74 = load i32, i32* %index98, align 4
  %arrayidx105 = getelementptr inbounds double, double* %73, i32 %74
  store double %72, double* %arrayidx105, align 8
  br label %for.inc106

for.inc106:                                       ; preds = %for.body102
  %75 = load i32, i32* %index98, align 4
  %inc107 = add i32 %75, 1
  store i32 %inc107, i32* %index98, align 4
  br label %for.cond99

for.end108:                                       ; preds = %for.cond99
  %76 = load double*, double** %pmin, align 4
  %77 = bitcast double* %76 to i8*
  call void @free(i8* %77)
  store double* null, double** %pmin, align 4
  %78 = load i32*, i32** %ro, align 4
  %79 = bitcast i32* %78 to i8*
  call void @free(i8* %79)
  store i32* null, i32** %ro, align 4
  %80 = load double*, double** %qvalues, align 4
  store double* %80, double** %retval, align 4
  br label %return

if.else109:                                       ; preds = %if.else71
  %81 = load i16, i16* %TYPE, align 2
  %conv110 = sext i16 %81 to i32
  %cmp111 = icmp eq i32 %conv110, 5
  br i1 %cmp111, label %if.then113, label %if.end285

if.then113:                                       ; preds = %if.else109
  %82 = load double*, double** %PVALUES.addr, align 4
  %83 = load i32, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
  %call115 = call i32* @order(double* %82, i32 %83, i1 zeroext false)
  store i32* %call115, i32** %o114, align 4
  %84 = load i32, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
  %mul116 = mul i32 8, %84
  %call117 = call noalias i8* @malloc(i32 %mul116)
  %85 = bitcast i8* %call117 to double*
  store double* %85, double** %p, align 4
  %86 = load double*, double** %p, align 4
  %cmp118 = icmp eq double* %86, null
  br i1 %cmp118, label %if.then120, label %if.end122

if.then120:                                       ; preds = %if.then113
  %call121 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([33 x i8], [33 x i8]* @.str.3, i32 0, i32 0), i8* getelementptr inbounds ([23 x i8], [23 x i8]* @.str.1, i32 0, i32 0), i32 302)
  call void @perror(i8* getelementptr inbounds ([1 x i8], [1 x i8]* @.str.2, i32 0, i32 0))
  call void @exit(i32 1) #5
  unreachable

if.end122:                                        ; preds = %if.then113
  store i32 0, i32* %index123, align 4
  br label %for.cond124

for.cond124:                                      ; preds = %for.inc131, %if.end122
  %87 = load i32, i32* %index123, align 4
  %88 = load i32, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
  %cmp125 = icmp ult i32 %87, %88
  br i1 %cmp125, label %for.body127, label %for.end133

for.body127:                                      ; preds = %for.cond124
  %89 = load double*, double** %PVALUES.addr, align 4
  %90 = load i32*, i32** %o114, align 4
  %91 = load i32, i32* %index123, align 4
  %arrayidx128 = getelementptr inbounds i32, i32* %90, i32 %91
  %92 = load i32, i32* %arrayidx128, align 4
  %arrayidx129 = getelementptr inbounds double, double* %89, i32 %92
  %93 = load double, double* %arrayidx129, align 8
  %94 = load double*, double** %p, align 4
  %95 = load i32, i32* %index123, align 4
  %arrayidx130 = getelementptr inbounds double, double* %94, i32 %95
  store double %93, double* %arrayidx130, align 8
  br label %for.inc131

for.inc131:                                       ; preds = %for.body127
  %96 = load i32, i32* %index123, align 4
  %inc132 = add i32 %96, 1
  store i32 %inc132, i32* %index123, align 4
  br label %for.cond124

for.end133:                                       ; preds = %for.cond124
  %97 = load i32*, i32** %o114, align 4
  %98 = load i32, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
  %call135 = call double* @uint2double(i32* %97, i32 %98)
  store double* %call135, double** %o2double134, align 4
  %99 = load i32*, i32** %o114, align 4
  %100 = bitcast i32* %99 to i8*
  call void @free(i8* %100)
  store i32* null, i32** %o114, align 4
  %101 = load double*, double** %o2double134, align 4
  %102 = load i32, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
  %call137 = call i32* @order(double* %101, i32 %102, i1 zeroext false)
  store i32* %call137, i32** %ro136, align 4
  %103 = load double*, double** %o2double134, align 4
  %104 = bitcast double* %103 to i8*
  call void @free(i8* %104)
  store double* null, double** %o2double134, align 4
  %105 = load i32, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
  %mul138 = mul i32 8, %105
  %call139 = call noalias i8* @malloc(i32 %mul138)
  %106 = bitcast i8* %call139 to double*
  store double* %106, double** %q, align 4
  %107 = load double*, double** %q, align 4
  %cmp140 = icmp eq double* %107, null
  br i1 %cmp140, label %if.then142, label %if.end144

if.then142:                                       ; preds = %for.end133
  %call143 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([33 x i8], [33 x i8]* @.str.3, i32 0, i32 0), i8* getelementptr inbounds ([23 x i8], [23 x i8]* @.str.1, i32 0, i32 0), i32 318)
  call void @perror(i8* getelementptr inbounds ([1 x i8], [1 x i8]* @.str.2, i32 0, i32 0))
  call void @exit(i32 1) #5
  unreachable

if.end144:                                        ; preds = %for.end133
  %108 = load i32, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
  %mul145 = mul i32 8, %108
  %call146 = call noalias i8* @malloc(i32 %mul145)
  %109 = bitcast i8* %call146 to double*
  store double* %109, double** %pa, align 4
  %110 = load double*, double** %pa, align 4
  %cmp147 = icmp eq double* %110, null
  br i1 %cmp147, label %if.then149, label %if.end151

if.then149:                                       ; preds = %if.end144
  %call150 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([33 x i8], [33 x i8]* @.str.3, i32 0, i32 0), i8* getelementptr inbounds ([23 x i8], [23 x i8]* @.str.1, i32 0, i32 0), i32 324)
  call void @perror(i8* getelementptr inbounds ([1 x i8], [1 x i8]* @.str.2, i32 0, i32 0))
  call void @exit(i32 1) #5
  unreachable

if.end151:                                        ; preds = %if.end144
  %111 = load i32, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
  %conv152 = uitofp i32 %111 to double
  %112 = load double*, double** %p, align 4
  %arrayidx153 = getelementptr inbounds double, double* %112, i32 0
  %113 = load double, double* %arrayidx153, align 8
  %mul154 = fmul double %conv152, %113
  store double %mul154, double* %min, align 8
  store i32 1, i32* %index155, align 4
  br label %for.cond156

for.cond156:                                      ; preds = %for.inc168, %if.end151
  %114 = load i32, i32* %index155, align 4
  %115 = load i32, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
  %cmp157 = icmp ult i32 %114, %115
  br i1 %cmp157, label %for.body159, label %for.end170

for.body159:                                      ; preds = %for.cond156
  %116 = load i32, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
  %conv160 = uitofp i32 %116 to double
  %117 = load double*, double** %p, align 4
  %118 = load i32, i32* %index155, align 4
  %arrayidx161 = getelementptr inbounds double, double* %117, i32 %118
  %119 = load double, double* %arrayidx161, align 8
  %mul162 = fmul double %conv160, %119
  %120 = load i32, i32* %index155, align 4
  %add = add i32 1, %120
  %conv163 = uitofp i32 %add to double
  %div = fdiv double %mul162, %conv163
  store double %div, double* %TEMP, align 8
  %121 = load double, double* %TEMP, align 8
  %122 = load double, double* %min, align 8
  %cmp164 = fcmp olt double %121, %122
  br i1 %cmp164, label %if.then166, label %if.end167

if.then166:                                       ; preds = %for.body159
  %123 = load double, double* %TEMP, align 8
  store double %123, double* %min, align 8
  br label %if.end167

if.end167:                                        ; preds = %if.then166, %for.body159
  br label %for.inc168

for.inc168:                                       ; preds = %if.end167
  %124 = load i32, i32* %index155, align 4
  %inc169 = add i32 %124, 1
  store i32 %inc169, i32* %index155, align 4
  br label %for.cond156

for.end170:                                       ; preds = %for.cond156
  store i32 0, i32* %index171, align 4
  br label %for.cond172

for.cond172:                                      ; preds = %for.inc178, %for.end170
  %125 = load i32, i32* %index171, align 4
  %126 = load i32, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
  %cmp173 = icmp ult i32 %125, %126
  br i1 %cmp173, label %for.body175, label %for.end180

for.body175:                                      ; preds = %for.cond172
  %127 = load double, double* %min, align 8
  %128 = load double*, double** %pa, align 4
  %129 = load i32, i32* %index171, align 4
  %arrayidx176 = getelementptr inbounds double, double* %128, i32 %129
  store double %127, double* %arrayidx176, align 8
  %130 = load double, double* %min, align 8
  %131 = load double*, double** %q, align 4
  %132 = load i32, i32* %index171, align 4
  %arrayidx177 = getelementptr inbounds double, double* %131, i32 %132
  store double %130, double* %arrayidx177, align 8
  br label %for.inc178

for.inc178:                                       ; preds = %for.body175
  %133 = load i32, i32* %index171, align 4
  %inc179 = add i32 %133, 1
  store i32 %inc179, i32* %index171, align 4
  br label %for.cond172

for.end180:                                       ; preds = %for.cond172
  %134 = load i32, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
  %sub181 = sub i32 %134, 1
  store i32 %sub181, i32* %j, align 4
  br label %for.cond182

for.cond182:                                      ; preds = %for.inc272, %for.end180
  %135 = load i32, i32* %j, align 4
  %cmp183 = icmp uge i32 %135, 2
  br i1 %cmp183, label %for.body185, label %for.end273

for.body185:                                      ; preds = %for.cond182
  %136 = load i32, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
  %137 = load i32, i32* %j, align 4
  %sub186 = sub i32 %136, %137
  %call187 = call i32* @seq_len(i32 0, i32 %sub186)
  store i32* %call187, i32** %ij, align 4
  %138 = load i32, i32* %j, align 4
  %sub188 = sub i32 %138, 1
  store i32 %sub188, i32* %I2_LENGTH, align 4
  %139 = load i32, i32* %I2_LENGTH, align 4
  %mul189 = mul i32 %139, 4
  %call190 = call noalias i8* @malloc(i32 %mul189)
  %140 = bitcast i8* %call190 to i32*
  store i32* %140, i32** %i2, align 4
  store i32 0, i32* %i, align 4
  br label %for.cond191

for.cond191:                                      ; preds = %for.inc200, %for.body185
  %141 = load i32, i32* %i, align 4
  %142 = load i32, i32* %I2_LENGTH, align 4
  %cmp192 = icmp ult i32 %141, %142
  br i1 %cmp192, label %for.body194, label %for.end202

for.body194:                                      ; preds = %for.cond191
  %143 = load i32, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
  %144 = load i32, i32* %j, align 4
  %sub195 = sub i32 %143, %144
  %add196 = add i32 %sub195, 2
  %145 = load i32, i32* %i, align 4
  %add197 = add i32 %add196, %145
  %sub198 = sub i32 %add197, 1
  %146 = load i32*, i32** %i2, align 4
  %147 = load i32, i32* %i, align 4
  %arrayidx199 = getelementptr inbounds i32, i32* %146, i32 %147
  store i32 %sub198, i32* %arrayidx199, align 4
  br label %for.inc200

for.inc200:                                       ; preds = %for.body194
  %148 = load i32, i32* %i, align 4
  %inc201 = add i32 %148, 1
  store i32 %inc201, i32* %i, align 4
  br label %for.cond191

for.end202:                                       ; preds = %for.cond191
  %149 = load i32, i32* %j, align 4
  %conv203 = uitofp i32 %149 to double
  %150 = load double*, double** %p, align 4
  %151 = load i32*, i32** %i2, align 4
  %arrayidx204 = getelementptr inbounds i32, i32* %151, i32 0
  %152 = load i32, i32* %arrayidx204, align 4
  %arrayidx205 = getelementptr inbounds double, double* %150, i32 %152
  %153 = load double, double* %arrayidx205, align 8
  %mul206 = fmul double %conv203, %153
  %div207 = fdiv double %mul206, 2.000000e+00
  store double %div207, double* %q1, align 8
  store i32 1, i32* %i208, align 4
  br label %for.cond209

for.cond209:                                      ; preds = %for.inc224, %for.end202
  %154 = load i32, i32* %i208, align 4
  %155 = load i32, i32* %I2_LENGTH, align 4
  %cmp210 = icmp ult i32 %154, %155
  br i1 %cmp210, label %for.body212, label %for.end226

for.body212:                                      ; preds = %for.cond209
  %156 = load i32, i32* %j, align 4
  %conv213 = uitofp i32 %156 to double
  %157 = load double*, double** %p, align 4
  %158 = load i32*, i32** %i2, align 4
  %159 = load i32, i32* %i208, align 4
  %arrayidx214 = getelementptr inbounds i32, i32* %158, i32 %159
  %160 = load i32, i32* %arrayidx214, align 4
  %arrayidx215 = getelementptr inbounds double, double* %157, i32 %160
  %161 = load double, double* %arrayidx215, align 8
  %mul216 = fmul double %conv213, %161
  %162 = load i32, i32* %i208, align 4
  %add217 = add i32 2, %162
  %conv218 = uitofp i32 %add217 to double
  %div219 = fdiv double %mul216, %conv218
  store double %div219, double* %TEMP_Q1, align 8
  %163 = load double, double* %TEMP_Q1, align 8
  %164 = load double, double* %q1, align 8
  %cmp220 = fcmp olt double %163, %164
  br i1 %cmp220, label %if.then222, label %if.end223

if.then222:                                       ; preds = %for.body212
  %165 = load double, double* %TEMP_Q1, align 8
  store double %165, double* %q1, align 8
  br label %if.end223

if.end223:                                        ; preds = %if.then222, %for.body212
  br label %for.inc224

for.inc224:                                       ; preds = %if.end223
  %166 = load i32, i32* %i208, align 4
  %inc225 = add i32 %166, 1
  store i32 %inc225, i32* %i208, align 4
  br label %for.cond209

for.end226:                                       ; preds = %for.cond209
  store i32 0, i32* %i227, align 4
  br label %for.cond228

for.cond228:                                      ; preds = %for.inc241, %for.end226
  %167 = load i32, i32* %i227, align 4
  %168 = load i32, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
  %169 = load i32, i32* %j, align 4
  %sub229 = sub i32 %168, %169
  %add230 = add i32 %sub229, 1
  %cmp231 = icmp ult i32 %167, %add230
  br i1 %cmp231, label %for.body233, label %for.end243

for.body233:                                      ; preds = %for.cond228
  %170 = load i32, i32* %j, align 4
  %conv234 = uitofp i32 %170 to double
  %171 = load double*, double** %p, align 4
  %172 = load i32*, i32** %ij, align 4
  %173 = load i32, i32* %i227, align 4
  %arrayidx235 = getelementptr inbounds i32, i32* %172, i32 %173
  %174 = load i32, i32* %arrayidx235, align 4
  %arrayidx236 = getelementptr inbounds double, double* %171, i32 %174
  %175 = load double, double* %arrayidx236, align 8
  %mul237 = fmul double %conv234, %175
  %176 = load double, double* %q1, align 8
  %call238 = call double @min2(double %mul237, double %176)
  %177 = load double*, double** %q, align 4
  %178 = load i32*, i32** %ij, align 4
  %179 = load i32, i32* %i227, align 4
  %arrayidx239 = getelementptr inbounds i32, i32* %178, i32 %179
  %180 = load i32, i32* %arrayidx239, align 4
  %arrayidx240 = getelementptr inbounds double, double* %177, i32 %180
  store double %call238, double* %arrayidx240, align 8
  br label %for.inc241

for.inc241:                                       ; preds = %for.body233
  %181 = load i32, i32* %i227, align 4
  %inc242 = add i32 %181, 1
  store i32 %inc242, i32* %i227, align 4
  br label %for.cond228

for.end243:                                       ; preds = %for.cond228
  %182 = load i32*, i32** %ij, align 4
  %183 = bitcast i32* %182 to i8*
  call void @free(i8* %183)
  store i32* null, i32** %ij, align 4
  store i32 0, i32* %i244, align 4
  br label %for.cond245

for.cond245:                                      ; preds = %for.inc253, %for.end243
  %184 = load i32, i32* %i244, align 4
  %185 = load i32, i32* %I2_LENGTH, align 4
  %cmp246 = icmp ult i32 %184, %185
  br i1 %cmp246, label %for.body248, label %for.end255

for.body248:                                      ; preds = %for.cond245
  %186 = load double*, double** %q, align 4
  %187 = load i32, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
  %188 = load i32, i32* %j, align 4
  %sub249 = sub i32 %187, %188
  %arrayidx250 = getelementptr inbounds double, double* %186, i32 %sub249
  %189 = load double, double* %arrayidx250, align 8
  %190 = load double*, double** %q, align 4
  %191 = load i32*, i32** %i2, align 4
  %192 = load i32, i32* %i244, align 4
  %arrayidx251 = getelementptr inbounds i32, i32* %191, i32 %192
  %193 = load i32, i32* %arrayidx251, align 4
  %arrayidx252 = getelementptr inbounds double, double* %190, i32 %193
  store double %189, double* %arrayidx252, align 8
  br label %for.inc253

for.inc253:                                       ; preds = %for.body248
  %194 = load i32, i32* %i244, align 4
  %inc254 = add i32 %194, 1
  store i32 %inc254, i32* %i244, align 4
  br label %for.cond245

for.end255:                                       ; preds = %for.cond245
  %195 = load i32*, i32** %i2, align 4
  %196 = bitcast i32* %195 to i8*
  call void @free(i8* %196)
  store i32* null, i32** %i2, align 4
  store i32 0, i32* %i256, align 4
  br label %for.cond257

for.cond257:                                      ; preds = %for.inc269, %for.end255
  %197 = load i32, i32* %i256, align 4
  %198 = load i32, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
  %cmp258 = icmp ult i32 %197, %198
  br i1 %cmp258, label %for.body260, label %for.end271

for.body260:                                      ; preds = %for.cond257
  %199 = load double*, double** %pa, align 4
  %200 = load i32, i32* %i256, align 4
  %arrayidx261 = getelementptr inbounds double, double* %199, i32 %200
  %201 = load double, double* %arrayidx261, align 8
  %202 = load double*, double** %q, align 4
  %203 = load i32, i32* %i256, align 4
  %arrayidx262 = getelementptr inbounds double, double* %202, i32 %203
  %204 = load double, double* %arrayidx262, align 8
  %cmp263 = fcmp olt double %201, %204
  br i1 %cmp263, label %if.then265, label %if.end268

if.then265:                                       ; preds = %for.body260
  %205 = load double*, double** %q, align 4
  %206 = load i32, i32* %i256, align 4
  %arrayidx266 = getelementptr inbounds double, double* %205, i32 %206
  %207 = load double, double* %arrayidx266, align 8
  %208 = load double*, double** %pa, align 4
  %209 = load i32, i32* %i256, align 4
  %arrayidx267 = getelementptr inbounds double, double* %208, i32 %209
  store double %207, double* %arrayidx267, align 8
  br label %if.end268

if.end268:                                        ; preds = %if.then265, %for.body260
  br label %for.inc269

for.inc269:                                       ; preds = %if.end268
  %210 = load i32, i32* %i256, align 4
  %inc270 = add i32 %210, 1
  store i32 %inc270, i32* %i256, align 4
  br label %for.cond257

for.end271:                                       ; preds = %for.cond257
  br label %for.inc272

for.inc272:                                       ; preds = %for.end271
  %211 = load i32, i32* %j, align 4
  %dec = add i32 %211, -1
  store i32 %dec, i32* %j, align 4
  br label %for.cond182

for.end273:                                       ; preds = %for.cond182
  %212 = load double*, double** %p, align 4
  %213 = bitcast double* %212 to i8*
  call void @free(i8* %213)
  store double* null, double** %p, align 4
  store i32 0, i32* %index274, align 4
  br label %for.cond275

for.cond275:                                      ; preds = %for.inc282, %for.end273
  %214 = load i32, i32* %index274, align 4
  %215 = load i32, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
  %cmp276 = icmp ult i32 %214, %215
  br i1 %cmp276, label %for.body278, label %for.end284

for.body278:                                      ; preds = %for.cond275
  %216 = load double*, double** %pa, align 4
  %217 = load i32*, i32** %ro136, align 4
  %218 = load i32, i32* %index274, align 4
  %arrayidx279 = getelementptr inbounds i32, i32* %217, i32 %218
  %219 = load i32, i32* %arrayidx279, align 4
  %arrayidx280 = getelementptr inbounds double, double* %216, i32 %219
  %220 = load double, double* %arrayidx280, align 8
  %221 = load double*, double** %q, align 4
  %222 = load i32, i32* %index274, align 4
  %arrayidx281 = getelementptr inbounds double, double* %221, i32 %222
  store double %220, double* %arrayidx281, align 8
  br label %for.inc282

for.inc282:                                       ; preds = %for.body278
  %223 = load i32, i32* %index274, align 4
  %inc283 = add i32 %223, 1
  store i32 %inc283, i32* %index274, align 4
  br label %for.cond275

for.end284:                                       ; preds = %for.cond275
  %224 = load i32*, i32** %ro136, align 4
  %225 = bitcast i32* %224 to i8*
  call void @free(i8* %225)
  store i32* null, i32** %ro136, align 4
  %226 = load double*, double** %pa, align 4
  %227 = bitcast double* %226 to i8*
  call void @free(i8* %227)
  store double* null, double** %pa, align 4
  %228 = load double*, double** %q, align 4
  store double* %228, double** %retval, align 4
  br label %return

if.end285:                                        ; preds = %if.else109
  br label %if.end286

if.end286:                                        ; preds = %if.end285
  br label %if.end287

if.end287:                                        ; preds = %if.end286
  %229 = load double*, double** %PVALUES.addr, align 4
  %230 = load i32, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
  %call289 = call i32* @order(double* %229, i32 %230, i1 zeroext true)
  store i32* %call289, i32** %o288, align 4
  %231 = load i32*, i32** %o288, align 4
  %cmp290 = icmp eq i32* %231, null
  br i1 %cmp290, label %if.then292, label %if.end294

if.then292:                                       ; preds = %if.end287
  %call293 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([33 x i8], [33 x i8]* @.str.3, i32 0, i32 0), i8* getelementptr inbounds ([23 x i8], [23 x i8]* @.str.1, i32 0, i32 0), i32 398)
  call void @perror(i8* getelementptr inbounds ([1 x i8], [1 x i8]* @.str.2, i32 0, i32 0))
  call void @exit(i32 1) #5
  unreachable

if.end294:                                        ; preds = %if.end287
  %232 = load i32*, i32** %o288, align 4
  %233 = load i32, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
  %call295 = call double* @uint2double(i32* %232, i32 %233)
  store double* %call295, double** %o_double, align 4
  store i32 0, i32* %index296, align 4
  br label %for.cond297

for.cond297:                                      ; preds = %for.inc312, %if.end294
  %234 = load i32, i32* %index296, align 4
  %235 = load i32, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
  %cmp298 = icmp ult i32 %234, %235
  br i1 %cmp298, label %for.body300, label %for.end314

for.body300:                                      ; preds = %for.cond297
  %236 = load double*, double** %PVALUES.addr, align 4
  %237 = load i32, i32* %index296, align 4
  %arrayidx301 = getelementptr inbounds double, double* %236, i32 %237
  %238 = load double, double* %arrayidx301, align 8
  %cmp302 = fcmp olt double %238, 0.000000e+00
  br i1 %cmp302, label %if.then307, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %for.body300
  %239 = load double*, double** %PVALUES.addr, align 4
  %240 = load i32, i32* %index296, align 4
  %arrayidx304 = getelementptr inbounds double, double* %239, i32 %240
  %241 = load double, double* %arrayidx304, align 8
  %cmp305 = fcmp ogt double %241, 1.000000e+00
  br i1 %cmp305, label %if.then307, label %if.end311

if.then307:                                       ; preds = %lor.lhs.false, %for.body300
  %242 = load i32, i32* %index296, align 4
  %243 = load double*, double** %PVALUES.addr, align 4
  %244 = load i32, i32* %index296, align 4
  %arrayidx308 = getelementptr inbounds double, double* %243, i32 %244
  %245 = load double, double* %arrayidx308, align 8
  %call309 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([54 x i8], [54 x i8]* @.str.24, i32 0, i32 0), i32 %242, double %245)
  %call310 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([20 x i8], [20 x i8]* @.str.25, i32 0, i32 0), i8* getelementptr inbounds ([23 x i8], [23 x i8]* @.str.1, i32 0, i32 0), i32 406)
  call void @exit(i32 1) #5
  unreachable

if.end311:                                        ; preds = %lor.lhs.false
  br label %for.inc312

for.inc312:                                       ; preds = %if.end311
  %246 = load i32, i32* %index296, align 4
  %inc313 = add i32 %246, 1
  store i32 %inc313, i32* %index296, align 4
  br label %for.cond297

for.end314:                                       ; preds = %for.cond297
  %247 = load double*, double** %o_double, align 4
  %248 = load i32, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
  %call316 = call i32* @order(double* %247, i32 %248, i1 zeroext false)
  store i32* %call316, i32** %ro315, align 4
  %249 = load i32*, i32** %ro315, align 4
  %cmp317 = icmp eq i32* %249, null
  br i1 %cmp317, label %if.then319, label %if.end321

if.then319:                                       ; preds = %for.end314
  %call320 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([33 x i8], [33 x i8]* @.str.3, i32 0, i32 0), i8* getelementptr inbounds ([23 x i8], [23 x i8]* @.str.1, i32 0, i32 0), i32 413)
  call void @perror(i8* getelementptr inbounds ([1 x i8], [1 x i8]* @.str.2, i32 0, i32 0))
  call void @exit(i32 1) #5
  unreachable

if.end321:                                        ; preds = %for.end314
  %250 = load double*, double** %o_double, align 4
  %251 = bitcast double* %250 to i8*
  call void @free(i8* %251)
  store double* null, double** %o_double, align 4
  %252 = load i32, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
  %mul322 = mul i32 8, %252
  %call323 = call noalias i8* @malloc(i32 %mul322)
  %253 = bitcast i8* %call323 to double*
  store double* %253, double** %cummin_input, align 4
  %254 = load i16, i16* %TYPE, align 2
  %conv324 = sext i16 %254 to i32
  %cmp325 = icmp eq i32 %conv324, 0
  br i1 %cmp325, label %if.then327, label %if.else344

if.then327:                                       ; preds = %if.end321
  store i32 0, i32* %index328, align 4
  br label %for.cond329

for.cond329:                                      ; preds = %for.inc341, %if.then327
  %255 = load i32, i32* %index328, align 4
  %256 = load i32, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
  %cmp330 = icmp ult i32 %255, %256
  br i1 %cmp330, label %for.body332, label %for.end343

for.body332:                                      ; preds = %for.cond329
  %257 = load i32, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
  %conv333 = uitofp i32 %257 to double
  %258 = load i32, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
  %259 = load i32, i32* %index328, align 4
  %sub334 = sub i32 %258, %259
  %conv335 = uitofp i32 %sub334 to double
  %div336 = fdiv double %conv333, %conv335
  store double %div336, double* %NI, align 8
  %260 = load double, double* %NI, align 8
  %261 = load double*, double** %PVALUES.addr, align 4
  %262 = load i32*, i32** %o288, align 4
  %263 = load i32, i32* %index328, align 4
  %arrayidx337 = getelementptr inbounds i32, i32* %262, i32 %263
  %264 = load i32, i32* %arrayidx337, align 4
  %arrayidx338 = getelementptr inbounds double, double* %261, i32 %264
  %265 = load double, double* %arrayidx338, align 8
  %mul339 = fmul double %260, %265
  %266 = load double*, double** %cummin_input, align 4
  %267 = load i32, i32* %index328, align 4
  %arrayidx340 = getelementptr inbounds double, double* %266, i32 %267
  store double %mul339, double* %arrayidx340, align 8
  br label %for.inc341

for.inc341:                                       ; preds = %for.body332
  %268 = load i32, i32* %index328, align 4
  %inc342 = add i32 %268, 1
  store i32 %inc342, i32* %index328, align 4
  br label %for.cond329

for.end343:                                       ; preds = %for.cond329
  br label %if.end401

if.else344:                                       ; preds = %if.end321
  %269 = load i16, i16* %TYPE, align 2
  %conv345 = sext i16 %269 to i32
  %cmp346 = icmp eq i32 %conv345, 1
  br i1 %cmp346, label %if.then348, label %if.else380

if.then348:                                       ; preds = %if.else344
  store double 1.000000e+00, double* %q349, align 8
  store i32 2, i32* %index350, align 4
  br label %for.cond351

for.cond351:                                      ; preds = %for.inc359, %if.then348
  %270 = load i32, i32* %index350, align 4
  %271 = load i32, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
  %add352 = add i32 1, %271
  %cmp353 = icmp ult i32 %270, %add352
  br i1 %cmp353, label %for.body355, label %for.end361

for.body355:                                      ; preds = %for.cond351
  %272 = load i32, i32* %index350, align 4
  %conv356 = uitofp i32 %272 to double
  %div357 = fdiv double 1.000000e+00, %conv356
  %273 = load double, double* %q349, align 8
  %add358 = fadd double %273, %div357
  store double %add358, double* %q349, align 8
  br label %for.inc359

for.inc359:                                       ; preds = %for.body355
  %274 = load i32, i32* %index350, align 4
  %inc360 = add i32 %274, 1
  store i32 %inc360, i32* %index350, align 4
  br label %for.cond351

for.end361:                                       ; preds = %for.cond351
  store i32 0, i32* %index362, align 4
  br label %for.cond363

for.cond363:                                      ; preds = %for.inc377, %for.end361
  %275 = load i32, i32* %index362, align 4
  %276 = load i32, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
  %cmp364 = icmp ult i32 %275, %276
  br i1 %cmp364, label %for.body366, label %for.end379

for.body366:                                      ; preds = %for.cond363
  %277 = load i32, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
  %conv368 = uitofp i32 %277 to double
  %278 = load i32, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
  %279 = load i32, i32* %index362, align 4
  %sub369 = sub i32 %278, %279
  %conv370 = uitofp i32 %sub369 to double
  %div371 = fdiv double %conv368, %conv370
  store double %div371, double* %NI367, align 8
  %280 = load double, double* %q349, align 8
  %281 = load double, double* %NI367, align 8
  %mul372 = fmul double %280, %281
  %282 = load double*, double** %PVALUES.addr, align 4
  %283 = load i32*, i32** %o288, align 4
  %284 = load i32, i32* %index362, align 4
  %arrayidx373 = getelementptr inbounds i32, i32* %283, i32 %284
  %285 = load i32, i32* %arrayidx373, align 4
  %arrayidx374 = getelementptr inbounds double, double* %282, i32 %285
  %286 = load double, double* %arrayidx374, align 8
  %mul375 = fmul double %mul372, %286
  %287 = load double*, double** %cummin_input, align 4
  %288 = load i32, i32* %index362, align 4
  %arrayidx376 = getelementptr inbounds double, double* %287, i32 %288
  store double %mul375, double* %arrayidx376, align 8
  br label %for.inc377

for.inc377:                                       ; preds = %for.body366
  %289 = load i32, i32* %index362, align 4
  %inc378 = add i32 %289, 1
  store i32 %inc378, i32* %index362, align 4
  br label %for.cond363

for.end379:                                       ; preds = %for.cond363
  br label %if.end400

if.else380:                                       ; preds = %if.else344
  %290 = load i16, i16* %TYPE, align 2
  %conv381 = sext i16 %290 to i32
  %cmp382 = icmp eq i32 %conv381, 3
  br i1 %cmp382, label %if.then384, label %if.end399

if.then384:                                       ; preds = %if.else380
  store i32 0, i32* %index385, align 4
  br label %for.cond386

for.cond386:                                      ; preds = %for.inc396, %if.then384
  %291 = load i32, i32* %index385, align 4
  %292 = load i32, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
  %cmp387 = icmp ult i32 %291, %292
  br i1 %cmp387, label %for.body389, label %for.end398

for.body389:                                      ; preds = %for.cond386
  %293 = load i32, i32* %index385, align 4
  %add390 = add i32 %293, 1
  %conv391 = uitofp i32 %add390 to double
  %294 = load double*, double** %PVALUES.addr, align 4
  %295 = load i32*, i32** %o288, align 4
  %296 = load i32, i32* %index385, align 4
  %arrayidx392 = getelementptr inbounds i32, i32* %295, i32 %296
  %297 = load i32, i32* %arrayidx392, align 4
  %arrayidx393 = getelementptr inbounds double, double* %294, i32 %297
  %298 = load double, double* %arrayidx393, align 8
  %mul394 = fmul double %conv391, %298
  %299 = load double*, double** %cummin_input, align 4
  %300 = load i32, i32* %index385, align 4
  %arrayidx395 = getelementptr inbounds double, double* %299, i32 %300
  store double %mul394, double* %arrayidx395, align 8
  br label %for.inc396

for.inc396:                                       ; preds = %for.body389
  %301 = load i32, i32* %index385, align 4
  %inc397 = add i32 %301, 1
  store i32 %inc397, i32* %index385, align 4
  br label %for.cond386

for.end398:                                       ; preds = %for.cond386
  br label %if.end399

if.end399:                                        ; preds = %for.end398, %if.else380
  br label %if.end400

if.end400:                                        ; preds = %if.end399, %for.end379
  br label %if.end401

if.end401:                                        ; preds = %if.end400, %for.end343
  %302 = load i32*, i32** %o288, align 4
  %303 = bitcast i32* %302 to i8*
  call void @free(i8* %303)
  store i32* null, i32** %o288, align 4
  store double* null, double** %cummin_array, align 4
  %304 = load double*, double** %cummin_input, align 4
  %305 = load i32, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
  %call402 = call double* @cummin(double* %304, i32 %305)
  store double* %call402, double** %cummin_array, align 4
  %306 = load double*, double** %cummin_input, align 4
  %307 = bitcast double* %306 to i8*
  call void @free(i8* %307)
  store double* null, double** %cummin_input, align 4
  %308 = load double*, double** %cummin_array, align 4
  %309 = load i32, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
  %call404 = call double* @pminx(double* %308, i32 %309, double 1.000000e+00)
  store double* %call404, double** %pmin403, align 4
  %310 = load double*, double** %cummin_array, align 4
  %311 = bitcast double* %310 to i8*
  call void @free(i8* %311)
  store double* null, double** %cummin_array, align 4
  %312 = load i32, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
  %mul405 = mul i32 %312, 8
  %call406 = call noalias i8* @malloc(i32 %mul405)
  %313 = bitcast i8* %call406 to double*
  store double* %313, double** %q_array, align 4
  store i32 0, i32* %index407, align 4
  br label %for.cond408

for.cond408:                                      ; preds = %for.inc415, %if.end401
  %314 = load i32, i32* %index407, align 4
  %315 = load i32, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
  %cmp409 = icmp ult i32 %314, %315
  br i1 %cmp409, label %for.body411, label %for.end417

for.body411:                                      ; preds = %for.cond408
  %316 = load double*, double** %pmin403, align 4
  %317 = load i32*, i32** %ro315, align 4
  %318 = load i32, i32* %index407, align 4
  %arrayidx412 = getelementptr inbounds i32, i32* %317, i32 %318
  %319 = load i32, i32* %arrayidx412, align 4
  %arrayidx413 = getelementptr inbounds double, double* %316, i32 %319
  %320 = load double, double* %arrayidx413, align 8
  %321 = load double*, double** %q_array, align 4
  %322 = load i32, i32* %index407, align 4
  %arrayidx414 = getelementptr inbounds double, double* %321, i32 %322
  store double %320, double* %arrayidx414, align 8
  br label %for.inc415

for.inc415:                                       ; preds = %for.body411
  %323 = load i32, i32* %index407, align 4
  %inc416 = add i32 %323, 1
  store i32 %inc416, i32* %index407, align 4
  br label %for.cond408

for.end417:                                       ; preds = %for.cond408
  %324 = load i32*, i32** %ro315, align 4
  %325 = bitcast i32* %324 to i8*
  call void @free(i8* %325)
  store i32* null, i32** %ro315, align 4
  %326 = load double*, double** %pmin403, align 4
  %327 = bitcast double* %326 to i8*
  call void @free(i8* %327)
  store double* null, double** %pmin403, align 4
  %328 = load double*, double** %q_array, align 4
  store double* %328, double** %retval, align 4
  br label %return

return:                                           ; preds = %for.end417, %for.end284, %for.end108, %for.end
  %329 = load double*, double** %retval, align 4
  ret double* %329
}

declare i32 @strcasecmp(i8* %0, i8* %1) #1

; Function Attrs: noinline nounwind optnone
define hidden i32 @main() #0 {
entry:
  %retval = alloca i32, align 4
  %PVALUES = alloca [50 x double], align 16
  %CORRECT_ANSWERS = alloca [6 x [50 x double]], align 16
  %TYPES = alloca [6 x i8*], align 16
  %type = alloca i16, align 2
  %q = alloca double*, align 4
  %error = alloca double, align 8
  %i = alloca i32, align 4
  %this_error = alloca double, align 8
  store i32 0, i32* %retval, align 4
  %0 = bitcast [50 x double]* %PVALUES to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 16 %0, i8* align 16 bitcast ([50 x double]* @__const.main.PVALUES to i8*), i32 400, i1 false)
  %1 = bitcast [6 x [50 x double]]* %CORRECT_ANSWERS to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 16 %1, i8* align 16 bitcast ([6 x [50 x double]]* @__const.main.CORRECT_ANSWERS to i8*), i32 2400, i1 false)
  %2 = bitcast [6 x i8*]* %TYPES to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 16 %2, i8* align 16 bitcast ([6 x i8*]* @__const.main.TYPES to i8*), i32 24, i1 false)
  store i16 0, i16* %type, align 2
  br label %for.cond

for.cond:                                         ; preds = %for.inc19, %entry
  %3 = load i16, i16* %type, align 2
  %conv = zext i16 %3 to i32
  %cmp = icmp sle i32 %conv, 5
  br i1 %cmp, label %for.body, label %for.end21

for.body:                                         ; preds = %for.cond
  %arraydecay = getelementptr inbounds [50 x double], [50 x double]* %PVALUES, i32 0, i32 0
  %4 = load i16, i16* %type, align 2
  %idxprom = zext i16 %4 to i32
  %arrayidx = getelementptr inbounds [6 x i8*], [6 x i8*]* %TYPES, i32 0, i32 %idxprom
  %5 = load i8*, i8** %arrayidx, align 4
  %call = call double* @p_adjust(double* %arraydecay, i32 50, i8* %5)
  store double* %call, double** %q, align 4
  %6 = load double*, double** %q, align 4
  %arrayidx2 = getelementptr inbounds double, double* %6, i32 0
  %7 = load double, double* %arrayidx2, align 8
  %8 = load i16, i16* %type, align 2
  %idxprom3 = zext i16 %8 to i32
  %arrayidx4 = getelementptr inbounds [6 x [50 x double]], [6 x [50 x double]]* %CORRECT_ANSWERS, i32 0, i32 %idxprom3
  %arrayidx5 = getelementptr inbounds [50 x double], [50 x double]* %arrayidx4, i32 0, i32 0
  %9 = load double, double* %arrayidx5, align 16
  %sub = fsub double %7, %9
  %10 = call double @llvm.fabs.f64(double %sub)
  store double %10, double* %error, align 8
  store i32 1, i32* %i, align 4
  br label %for.cond6

for.cond6:                                        ; preds = %for.inc, %for.body
  %11 = load i32, i32* %i, align 4
  %cmp7 = icmp ult i32 %11, 50
  br i1 %cmp7, label %for.body9, label %for.end

for.body9:                                        ; preds = %for.cond6
  %12 = load double*, double** %q, align 4
  %13 = load i32, i32* %i, align 4
  %arrayidx10 = getelementptr inbounds double, double* %12, i32 %13
  %14 = load double, double* %arrayidx10, align 8
  %15 = load i16, i16* %type, align 2
  %idxprom11 = zext i16 %15 to i32
  %arrayidx12 = getelementptr inbounds [6 x [50 x double]], [6 x [50 x double]]* %CORRECT_ANSWERS, i32 0, i32 %idxprom11
  %16 = load i32, i32* %i, align 4
  %arrayidx13 = getelementptr inbounds [50 x double], [50 x double]* %arrayidx12, i32 0, i32 %16
  %17 = load double, double* %arrayidx13, align 8
  %sub14 = fsub double %14, %17
  %18 = call double @llvm.fabs.f64(double %sub14)
  store double %18, double* %this_error, align 8
  %19 = load double, double* %this_error, align 8
  %20 = load double, double* %error, align 8
  %add = fadd double %20, %19
  store double %add, double* %error, align 8
  br label %for.inc

for.inc:                                          ; preds = %for.body9
  %21 = load i32, i32* %i, align 4
  %inc = add i32 %21, 1
  store i32 %inc, i32* %i, align 4
  br label %for.cond6

for.end:                                          ; preds = %for.cond6
  %22 = load double*, double** %q, align 4
  call void @double_say(double* %22, i32 50)
  %23 = load double*, double** %q, align 4
  %24 = bitcast double* %23 to i8*
  call void @free(i8* %24)
  store double* null, double** %q, align 4
  %25 = load i16, i16* %type, align 2
  %conv15 = zext i16 %25 to i32
  %26 = load i16, i16* %type, align 2
  %idxprom16 = zext i16 %26 to i32
  %arrayidx17 = getelementptr inbounds [6 x i8*], [6 x i8*]* %TYPES, i32 0, i32 %idxprom16
  %27 = load i8*, i8** %arrayidx17, align 4
  %28 = load double, double* %error, align 8
  %call18 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([44 x i8], [44 x i8]* @.str.28, i32 0, i32 0), i32 %conv15, i8* %27, double %28)
  br label %for.inc19

for.inc19:                                        ; preds = %for.end
  %29 = load i16, i16* %type, align 2
  %inc20 = add i16 %29, 1
  store i16 %inc20, i16* %type, align 2
  br label %for.cond

for.end21:                                        ; preds = %for.cond
  ret i32 0
}

; Function Attrs: argmemonly nounwind willreturn
declare void @llvm.memcpy.p0i8.p0i8.i32(i8* noalias nocapture writeonly %0, i8* noalias nocapture readonly %1, i32 %2, i1 immarg %3) #3

; Function Attrs: nounwind readnone speculatable willreturn
declare double @llvm.fabs.f64(double %0) #4

attributes #0 = { noinline nounwind optnone "correctly-rounded-divide-sqrt-fp-math"="false" "disable-tail-calls"="false" "frame-pointer"="none" "less-precise-fpmad"="false" "min-legal-vector-width"="0" "no-infs-fp-math"="false" "no-jump-tables"="false" "no-nans-fp-math"="false" "no-signed-zeros-fp-math"="false" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="generic" "unsafe-fp-math"="false" "use-soft-float"="false" }
attributes #1 = { "correctly-rounded-divide-sqrt-fp-math"="false" "disable-tail-calls"="false" "frame-pointer"="none" "less-precise-fpmad"="false" "no-infs-fp-math"="false" "no-nans-fp-math"="false" "no-signed-zeros-fp-math"="false" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="generic" "unsafe-fp-math"="false" "use-soft-float"="false" }
attributes #2 = { noreturn "correctly-rounded-divide-sqrt-fp-math"="false" "disable-tail-calls"="false" "frame-pointer"="none" "less-precise-fpmad"="false" "no-infs-fp-math"="false" "no-nans-fp-math"="false" "no-signed-zeros-fp-math"="false" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="generic" "unsafe-fp-math"="false" "use-soft-float"="false" }
attributes #3 = { argmemonly nounwind willreturn }
attributes #4 = { nounwind readnone speculatable willreturn }
attributes #5 = { noreturn }

!llvm.module.flags = !{!0}
!llvm.ident = !{!1}

!0 = !{i32 1, !"wchar_size", i32 4}
!1 = !{!"clang version 11.0.0 (https://github.com/Jacarte/llvm-project.git 0f6dea67136cc1e0b3d200eb2bb165628970c44b)"}

; extracted candidates

; *****
; For LLVM instruction:
;  %0 = load i32, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %cmp = icmp ult i32 %0, 1
; Looking for a replacement for:
%0:i32 = var
%1:i1 = ult %0, 1:i32
infer %1

; *****
; For LLVM instruction:
;  %1 = load i32, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %mul = mul i32 8, %1
; Looking for a replacement for:
%0:i32 = var
%1:i32 = mul 8:i32, %0
infer %1

; *****
; For LLVM instruction:
;  %cmp3 = icmp eq double* %3, null
; Looking for a replacement for:
%0:i32 = var
%1:i1 = eq 0:i32, %0
infer %1

; *****
; For LLVM instruction:
;  %4 = load i32, i32* %index, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %5 = load i32, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %cmp7 = icmp ult i32 %4, %5
; Looking for a replacement for:
%0:i32 = var
%1:i32 = var
%2:i1 = ult %0, %1
infer %2

; *****
; For LLVM instruction:
;  %7 = load i32, i32* %index, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %cmp8 = fcmp olt double %8, %9
; Looking for a replacement for:
%0:i1 = var
infer %0

; *****
; For LLVM instruction:
;  %11 = load i32, i32* %index, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %14 = load i32, i32* %index, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %17 = load i32, i32* %index, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %18 = load i32, i32* %index, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %inc = add i32 %18, 1
; Looking for a replacement for:
%0:i32 = var
%1:i32 = add 1:i32, %0
infer %1
#########################################################
; exiting Souper's runOnFunction() for pminx()

; entering Souper's runOnFunction() for double_say()

; ModuleID = './P-value_correction.c.bc'
source_filename = "./P-value_correction.c"
target datalayout = "e-m:e-p:32:32-i64:64-n32:64-S128"
target triple = "wasm32-unknown-wasi"

@.str = private unnamed_addr constant [29 x i8] c"malloc failed at %s line %u\0A\00", align 1
@.str.1 = private unnamed_addr constant [23 x i8] c"./P-value_correction.c\00", align 1
@.str.2 = private unnamed_addr constant [1 x i8] zeroinitializer, align 1
@base_arr = hidden global double* null, align 4
@.str.3 = private unnamed_addr constant [33 x i8] c"failed to malloc at %s line %u.\0A\00", align 1
@.str.4 = private unnamed_addr constant [48 x i8] c"cummin function requires at least one element.\0A\00", align 1
@.str.5 = private unnamed_addr constant [22 x i8] c"Failed at %s line %u\0A\00", align 1
@.str.6 = private unnamed_addr constant [41 x i8] c"function requires at least one element.\0A\00", align 1
@.str.7 = private unnamed_addr constant [37 x i8] c"pmin requires at least one element.\0A\00", align 1
@.str.8 = private unnamed_addr constant [7 x i8] c"[1] %e\00", align 1
@.str.9 = private unnamed_addr constant [7 x i8] c" %.10f\00", align 1
@.str.10 = private unnamed_addr constant [6 x i8] c"\0A[%u]\00", align 1
@.str.11 = private unnamed_addr constant [2 x i8] c"\0A\00", align 1
@.str.12 = private unnamed_addr constant [34 x i8] c"Failure to malloc at %s line %u.\0A\00", align 1
@.str.13 = private unnamed_addr constant [41 x i8] c"p_adjust requires at least one element.\0A\00", align 1
@.str.14 = private unnamed_addr constant [3 x i8] c"BH\00", align 1
@.str.15 = private unnamed_addr constant [4 x i8] c"fdr\00", align 1
@.str.16 = private unnamed_addr constant [3 x i8] c"by\00", align 1
@.str.17 = private unnamed_addr constant [11 x i8] c"Bonferroni\00", align 1
@.str.18 = private unnamed_addr constant [9 x i8] c"hochberg\00", align 1
@.str.19 = private unnamed_addr constant [5 x i8] c"holm\00", align 1
@.str.20 = private unnamed_addr constant [7 x i8] c"hommel\00", align 1
@.str.21 = private unnamed_addr constant [44 x i8] c"%s doesn't match any accepted FDR methods.\0A\00", align 1
@.str.22 = private unnamed_addr constant [42 x i8] c"%g is outside of the interval I planned.\0A\00", align 1
@.str.23 = private unnamed_addr constant [23 x i8] c"Failure at %s line %u\0A\00", align 1
@.str.24 = private unnamed_addr constant [54 x i8] c"array[%u] = %lf, which is outside the interval [0,1]\0A\00", align 1
@.str.25 = private unnamed_addr constant [20 x i8] c"died at %s line %u\0A\00", align 1
@__const.main.PVALUES = private unnamed_addr constant [50 x double] [double 0x3FDD04160F35FDE9, double 0x3FE758E721E2A8D7, double 0x3FB96FAC8B38D8BA, double 0x3FB73E71D5B04B37, double 0x3FC710AB48EE865B, double 0x3FEC01D953C3CC73, double 0x3FD2B3C4BE0A922A, double 0x3FED2B5A568DAB4F, double 0x3FDBE08D73F16964, double 0x3FE10A218C41C242, double 0x3FDF8810DB1996AA, double 0x3FE291CCB11E1A9D, double 0x3FD64E8C550D788F, double 7.883130e-01, double 0x3FD177B2BF048D2D, double 0x3FEB3543434BAF2B, double 0x3FDB50EAD41ED0A6, double 0x3FE49D4AFF01D33F, double 0x3FD364C9AE345B51, double 0x3FA99BA35F15394D, double 3.194810e-01, double 0x3FE941E405CE761A, double 0x3FEFF94F77369843, double 0x3FC65847BFB23217, double 0x3FECEB8879B6A543, double 0x3FBEAF00332BA677, double 0x3FD96207C7749E38, double 0x3F8CC02620502C93, double 0x3FE773A5B45A0F40, double 0x3FB1642C24762C01, double 4.040730e-03, double 0x3F33E11D79A90777, double 0x3F870B02BD749528, double 0x3F98521BD6A0353F, double 0x3F4310F26148FFAA, double 0x3F3427CD76006778, double 0x3F80E60AFB1F8A4E, double 0x3F5639B74A9E4DA2, double 0x3F8BDDF74195769F, double 0x3F38ABEE3BFA8581, double 0x3EF2E2E96B5466FE, double 0x3E90CE9F65B58A88, double 0x3FA0F2D097879B95, double 0x3F834EE7216A6684, double 0x3F4CCE8DBB40BD9D, double 0x3F2C8B969590F2ED, double 0x3F4FC31F7F1541AD, double 6.610250e-05, double 0x3F9DB44EA6AC26BA, double 5.735490e-03], align 16
@__const.main.CORRECT_ANSWERS = private unnamed_addr constant [6 x [50 x double]] [[50 x double] [double 0x3FE39AFA2199ADBC, double 8.521710e-01, double 0x3FC96FAC6045BAF5, double 0x3FC83660E51D25AB, double 0x3FD498068702BE20, double 0x3FEDC3BF727136A4, double 4.870370e-01, double 0x3FEDC3BF727136A4, double 0x3FE35BF08BEEB62C, double 0x3FE5D879DEE92F03, double 0x3FE4BE91D656B94A, double 0x3FE7363FC28DAEAA, double 0x3FE0E62C4F13638A, double 0x3FEC1052C8FAB035, double 0x3FDE1DD2E43E029A, double 0x3FED92EFFC7CBDC1, double 0x3FE35BF08BEEB62C, double 0x3FE923B90CFC67C5, double 0x3FDF47B8FC357024, double 0x3FBD1996A9FB10AD, double 0x3FDFF2B6D6C14255, double 0x3FEC1052C8FAB035, double 0x3FEFF94F77369843, double 0x3FD498068702BE20, double 0x3FEDC3BF727136A4, double 0x3FCD80E2E96EC403, double 0x3FE2A9F6A93F290B, double 0x3FA3F736D8AF2E2B, double 8.521710e-01, double 0x3FC2E751B350FAC4, double 0x3F913D8E55EE9F05, double 0x3F64FECB88BB3633, double 0x3FA2009A03CCBE34, double 0x3FB0001FB57CF9FC, double 0x3F6DCA7ADA5E274A, double 0x3F64FECB88BB3633, double 0x3F9E2D13B467D120, double 0x3F7941963399C6A1, double 0x3FA3F736D8AF2E2B, double 0x3F6607390CEF853C, double 0x3F3D828C80BA213A, double 0x3EEA42D90EEBA875, double 0x3FB42D4181AA8F8B, double 0x3FA01715F12E0018, double 0x3F73D9F3AF6D490C, double 0x3F64FECB88BB3633, double 0x3F73D9F3AF6D490C, double 0x3F520CE5F51A7C61, double 0x3FB290B112B20952, double 0x3F9696C95AA76B69], [50 x double] [double 1.000000e+00, double 1.000000e+00, double 0x3FEC9C56E33BA41B, double 0x3FEB3BF21E95ED3D, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 0x3FE05DA74553C727, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 0x3FC675198790829A, double 1.000000e+00, double 0x3FE54345648E1F12, double 0x3FB3645F501CA2F9, double 0x3F879D934E50F0DE, double 0x3FC43FC3646E3EA2, double 0x3FD1FF539D36064C, double 0x3F90C123206B855F, double 0x3F879D934E50F0DE, double 0x3FC0F8967F32E606, double 0x3F9C6880470D2FBE, double 0x3FC675198790829A, double 0x3F88C70105E47082, double 2.025930e-03, double 0x3F0D89DE4FA8F818, double 0x3FD6B1E2D11B1027, double 0x3FC219271872BD8D, double 0x3F96542FAD16CEF9, double 0x3F879D934E50F0DE, double 0x3F96542FAD16CEF9, double 0x3F744D9816EB319A, double 0x3FD4E1D5728DBC16, double 0x3FB9687C40426555], [50 x double] [double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 0x3FE6761DC93EA2D3, double 1.000000e+00, double 1.000000e+00, double 0x3FC9DC55000C953A, double 0x3F8F0FBD624BA499, double 0x3FE2009A24031487, double 1.000000e+00, double 0x3F9DCA7AB8020F7A, double 0x3F8F7E310860A1AB, double 0x3FDA677128614819, double 6.782670e-02, double 6.803480e-01, double 0x3F9346521EDBB84D, double 0x3F4D828CB7B3E0EE, double 0x3EEA42D90EEBA875, double 1.000000e+00, double 4.713920e-01, double 0x3FA6815EE53DB1E7, double 0x3F864D0CF90CC6B8, double 0x3FA8D0709B489B4F, double 0x3F6B1359791819D2, double 1.000000e+00, double 0x3FD25A836EB4E981], [50 x double] [double 0x3FEFF94F77369843, double 0x3FEFF94F77369843, double 0x3FEFF94F77369843, double 0x3FEFF94F77369843, double 0x3FEFF94F77369843, double 0x3FEFF94F77369843, double 0x3FEFF94F77369843, double 0x3FEFF94F77369843, double 0x3FEFF94F77369843, double 0x3FEFF94F77369843, double 0x3FEFF94F77369843, double 0x3FEFF94F77369843, double 0x3FEFF94F77369843, double 0x3FEFF94F77369843, double 0x3FEFF94F77369843, double 0x3FEFF94F77369843, double 0x3FEFF94F77369843, double 0x3FEFF94F77369843, double 0x3FEFF94F77369843, double 0x3FEFF94F77369843, double 0x3FEFF94F77369843, double 0x3FEFF94F77369843, double 0x3FEFF94F77369843, double 0x3FEFF94F77369843, double 0x3FEFF94F77369843, double 0x3FEFF94F77369843, double 0x3FEFF94F77369843, double 0x3FDDA6274695E687, double 0x3FEFF94F77369843, double 0x3FEFF94F77369843, double 0x3FC42BDC26DCE39B, double 0x3F8C57F9104CA951, double 0x3FD9340AC9879DEF, double 7.600230e-01, double 0x3F999EC5A86B439B, double 0x3F8C57F9104CA951, double 0x3FD389FCD90412B4, double 0x3FABC8251D45E10B, double 0x3FDD9BD68ABBB045, double 0x3F90F633F956C386, double 8.825610e-04, double 0x3EEA42D90EEBA875, double 0x3FEFC7471C1E43B8, double 0x3FD5B8C4014C305A, double 0x3FA2E78CEC8D068E, double 0x3F84F6832995A599, double 0x3FA459002162FC24, double 3.172920e-03, double 8.992520e-01, double 0x3FCBE5BD5E9AC00A], [50 x double] [double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 0x3FDDA6274695E687, double 1.000000e+00, double 1.000000e+00, double 0x3FC42BDC26DCE39B, double 0x3F8C939AFCF101E0, double 0x3FD9340AC9879DEF, double 7.600230e-01, double 0x3F999EC5A86B439B, double 0x3F8C939AFCF101E0, double 0x3FD389FCD90412B4, double 0x3FABC8251D45E10B, double 0x3FDD9BD68ABBB045, double 0x3F90F633F956C386, double 8.825610e-04, double 0x3EEA42D90EEBA875, double 0x3FEFC7471C1E43B8, double 0x3FD5B8C4014C305A, double 0x3FA2E78CEC8D068E, double 0x3F84F6832995A599, double 0x3FA459002162FC24, double 3.172920e-03, double 8.992520e-01, double 0x3FCBE5BD5E9AC00A], [50 x double] [double 0x3FEFF94F77369843, double 0x3FEFF94F77369843, double 0x3FEFF94F77369843, double 0x3FEFF5DC908F2EDD, double 0x3FEFF94F77369843, double 0x3FEFF94F77369843, double 0x3FEFF94F77369843, double 0x3FEFF94F77369843, double 0x3FEFF94F77369843, double 0x3FEFF94F77369843, double 0x3FEFF94F77369843, double 0x3FEFF94F77369843, double 0x3FEFF94F77369843, double 0x3FEFF94F77369843, double 0x3FEFF94F77369843, double 0x3FEFF94F77369843, double 0x3FEFF94F77369843, double 0x3FEFF94F77369843, double 0x3FEFF94F77369843, double 0x3FEEB45F17BD8BE7, double 0x3FEFF94F77369843, double 0x3FEFF94F77369843, double 0x3FEFF94F77369843, double 0x3FEFF94F77369843, double 0x3FEFF94F77369843, double 0x3FEFF94F77369843, double 0x3FEFF94F77369843, double 0x3FDBDA250F840182, double 0x3FEFF94F77369843, double 0x3FEF40BC1D52205E, double 0x3FC21A3BEB689947, double 1.304340e-02, double 0x3FD69916517B1CD7, double 0x3FE60A69453DF7B2, double 0x3F986DB666D9D3C6, double 0x3F8B157BBD3AB385, double 2.722920e-01, double 0x3FABC8251D45E10B, double 0x3FDAFF07B27BE8AF, double 0x3F9030D45E3B9F93, double 8.825610e-04, double 0x3EEA42D90EEBA875, double 0x3FEBFACC1948A662, double 0x3FD34EE6EDE042CB, double 0x3FA2011883DA6A9A, double 0x3F839FF779153716, double 0x3FA3D9F3D1C960DD, double 3.172920e-03, double 0x3FE9FDC4BC5D1301, double 0x3FC8F5FAC3801CF1]], align 16
@.str.26 = private unnamed_addr constant [3 x i8] c"bh\00", align 1
@.str.27 = private unnamed_addr constant [11 x i8] c"bonferroni\00", align 1
@__const.main.TYPES = private unnamed_addr constant [6 x i8*] [i8* getelementptr inbounds ([3 x i8], [3 x i8]* @.str.26, i32 0, i32 0), i8* getelementptr inbounds ([3 x i8], [3 x i8]* @.str.16, i32 0, i32 0), i8* getelementptr inbounds ([11 x i8], [11 x i8]* @.str.27, i32 0, i32 0), i8* getelementptr inbounds ([9 x i8], [9 x i8]* @.str.18, i32 0, i32 0), i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.19, i32 0, i32 0), i8* getelementptr inbounds ([7 x i8], [7 x i8]* @.str.20, i32 0, i32 0)], align 16
@.str.28 = private unnamed_addr constant [44 x i8] c"\0Atype %u = '%s' has cumulative error of %g\0A\00", align 1
@llvm.used = appending global [1 x i8*] [i8* bitcast (i32 ()* @__main_void to i8*)], section "llvm.metadata"

@__main_void = alias i32 (), i32 ()* @main

; Function Attrs: noinline nounwind optnone
define hidden i32* @seq_len(i32 %START, i32 %END) #0 {
entry:
  %retval = alloca i32*, align 4
  %START.addr = alloca i32, align 4
  %END.addr = alloca i32, align 4
  %start = alloca i32, align 4
  %end = alloca i32, align 4
  %sequence = alloca i32*, align 4
  %i = alloca i32, align 4
  %LENGTH = alloca i32, align 4
  %sequence10 = alloca i32*, align 4
  %index = alloca i32, align 4
  %index28 = alloca i32, align 4
  store i32 %START, i32* %START.addr, align 4
  store i32 %END, i32* %END.addr, align 4
  %0 = load i32, i32* %START.addr, align 4
  store i32 %0, i32* %start, align 4
  %1 = load i32, i32* %END.addr, align 4
  store i32 %1, i32* %end, align 4
  %2 = load i32, i32* %START.addr, align 4
  %3 = load i32, i32* %END.addr, align 4
  %cmp = icmp eq i32 %2, %3
  br i1 %cmp, label %if.then, label %if.end6

if.then:                                          ; preds = %entry
  %4 = load i32, i32* %end, align 4
  %add = add i32 %4, 1
  %mul = mul i32 %add, 4
  %call = call noalias i8* @malloc(i32 %mul)
  %5 = bitcast i8* %call to i32*
  store i32* %5, i32** %sequence, align 4
  %6 = load i32*, i32** %sequence, align 4
  %cmp1 = icmp eq i32* %6, null
  br i1 %cmp1, label %if.then2, label %if.end

if.then2:                                         ; preds = %if.then
  %call3 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([29 x i8], [29 x i8]* @.str, i32 0, i32 0), i8* getelementptr inbounds ([23 x i8], [23 x i8]* @.str.1, i32 0, i32 0), i32 15)
  call void @perror(i8* getelementptr inbounds ([1 x i8], [1 x i8]* @.str.2, i32 0, i32 0))
  call void @exit(i32 1) #5
  unreachable

if.end:                                           ; preds = %if.then
  store i32 0, i32* %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.end
  %7 = load i32, i32* %i, align 4
  %8 = load i32, i32* %end, align 4
  %cmp4 = icmp ult i32 %7, %8
  br i1 %cmp4, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %9 = load i32, i32* %i, align 4
  %add5 = add i32 %9, 1
  %10 = load i32*, i32** %sequence, align 4
  %11 = load i32, i32* %i, align 4
  %arrayidx = getelementptr inbounds i32, i32* %10, i32 %11
  store i32 %add5, i32* %arrayidx, align 4
  br label %for.inc

for.inc:                                          ; preds = %for.body
  %12 = load i32, i32* %i, align 4
  %inc = add i32 %12, 1
  store i32 %inc, i32* %i, align 4
  br label %for.cond

for.end:                                          ; preds = %for.cond
  %13 = load i32*, i32** %sequence, align 4
  store i32* %13, i32** %retval, align 4
  br label %return

if.end6:                                          ; preds = %entry
  %14 = load i32, i32* %START.addr, align 4
  %15 = load i32, i32* %END.addr, align 4
  %cmp7 = icmp ugt i32 %14, %15
  br i1 %cmp7, label %if.then8, label %if.end9

if.then8:                                         ; preds = %if.end6
  %16 = load i32, i32* %START.addr, align 4
  store i32 %16, i32* %end, align 4
  %17 = load i32, i32* %END.addr, align 4
  store i32 %17, i32* %start, align 4
  br label %if.end9

if.end9:                                          ; preds = %if.then8, %if.end6
  %18 = load i32, i32* %end, align 4
  %19 = load i32, i32* %start, align 4
  %sub = sub i32 %18, %19
  store i32 %sub, i32* %LENGTH, align 4
  %20 = load i32, i32* %LENGTH, align 4
  %add11 = add i32 1, %20
  %mul12 = mul i32 %add11, 4
  %call13 = call noalias i8* @malloc(i32 %mul12)
  %21 = bitcast i8* %call13 to i32*
  store i32* %21, i32** %sequence10, align 4
  %22 = load i32*, i32** %sequence10, align 4
  %cmp14 = icmp eq i32* %22, null
  br i1 %cmp14, label %if.then15, label %if.end17

if.then15:                                        ; preds = %if.end9
  %call16 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([29 x i8], [29 x i8]* @.str, i32 0, i32 0), i8* getelementptr inbounds ([23 x i8], [23 x i8]* @.str.1, i32 0, i32 0), i32 31)
  call void @perror(i8* getelementptr inbounds ([1 x i8], [1 x i8]* @.str.2, i32 0, i32 0))
  call void @exit(i32 1) #5
  unreachable

if.end17:                                         ; preds = %if.end9
  %23 = load i32, i32* %START.addr, align 4
  %24 = load i32, i32* %END.addr, align 4
  %cmp18 = icmp ult i32 %23, %24
  br i1 %cmp18, label %if.then19, label %if.else

if.then19:                                        ; preds = %if.end17
  store i32 0, i32* %index, align 4
  br label %for.cond20

for.cond20:                                       ; preds = %for.inc25, %if.then19
  %25 = load i32, i32* %index, align 4
  %26 = load i32, i32* %LENGTH, align 4
  %cmp21 = icmp ule i32 %25, %26
  br i1 %cmp21, label %for.body22, label %for.end27

for.body22:                                       ; preds = %for.cond20
  %27 = load i32, i32* %start, align 4
  %28 = load i32, i32* %index, align 4
  %add23 = add i32 %27, %28
  %29 = load i32*, i32** %sequence10, align 4
  %30 = load i32, i32* %index, align 4
  %arrayidx24 = getelementptr inbounds i32, i32* %29, i32 %30
  store i32 %add23, i32* %arrayidx24, align 4
  br label %for.inc25

for.inc25:                                        ; preds = %for.body22
  %31 = load i32, i32* %index, align 4
  %inc26 = add i32 %31, 1
  store i32 %inc26, i32* %index, align 4
  br label %for.cond20

for.end27:                                        ; preds = %for.cond20
  br label %if.end37

if.else:                                          ; preds = %if.end17
  store i32 0, i32* %index28, align 4
  br label %for.cond29

for.cond29:                                       ; preds = %for.inc34, %if.else
  %32 = load i32, i32* %index28, align 4
  %33 = load i32, i32* %LENGTH, align 4
  %cmp30 = icmp ule i32 %32, %33
  br i1 %cmp30, label %for.body31, label %for.end36

for.body31:                                       ; preds = %for.cond29
  %34 = load i32, i32* %end, align 4
  %35 = load i32, i32* %index28, align 4
  %sub32 = sub i32 %34, %35
  %36 = load i32*, i32** %sequence10, align 4
  %37 = load i32, i32* %index28, align 4
  %arrayidx33 = getelementptr inbounds i32, i32* %36, i32 %37
  store i32 %sub32, i32* %arrayidx33, align 4
  br label %for.inc34

for.inc34:                                        ; preds = %for.body31
  %38 = load i32, i32* %index28, align 4
  %inc35 = add i32 %38, 1
  store i32 %inc35, i32* %index28, align 4
  br label %for.cond29

for.end36:                                        ; preds = %for.cond29
  br label %if.end37

if.end37:                                         ; preds = %for.end36, %for.end27
  %39 = load i32*, i32** %sequence10, align 4
  store i32* %39, i32** %retval, align 4
  br label %return

return:                                           ; preds = %if.end37, %for.end
  %40 = load i32*, i32** %retval, align 4
  ret i32* %40
}

declare noalias i8* @malloc(i32 %0) #1

declare i32 @printf(i8* %0, ...) #1

declare void @perror(i8* %0) #1

; Function Attrs: noreturn
declare void @exit(i32 %0) #2

; Function Attrs: noinline nounwind optnone
define hidden i32* @order(double* noalias %ARRAY, i32 %SIZE, i1 zeroext %DECREASING) #0 {
entry:
  %ARRAY.addr = alloca double*, align 4
  %SIZE.addr = alloca i32, align 4
  %DECREASING.addr = alloca i8, align 1
  %idx = alloca i32*, align 4
  %i = alloca i32, align 4
  store double* %ARRAY, double** %ARRAY.addr, align 4
  store i32 %SIZE, i32* %SIZE.addr, align 4
  %frombool = zext i1 %DECREASING to i8
  store i8 %frombool, i8* %DECREASING.addr, align 1
  %0 = load i32, i32* %SIZE.addr, align 4
  %mul = mul i32 %0, 4
  %call = call noalias i8* @malloc(i32 %mul)
  %1 = bitcast i8* %call to i32*
  store i32* %1, i32** %idx, align 4
  %2 = load i32*, i32** %idx, align 4
  %cmp = icmp eq i32* %2, null
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %call1 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([33 x i8], [33 x i8]* @.str.3, i32 0, i32 0), i8* getelementptr inbounds ([23 x i8], [23 x i8]* @.str.1, i32 0, i32 0), i32 77)
  call void @perror(i8* getelementptr inbounds ([1 x i8], [1 x i8]* @.str.2, i32 0, i32 0))
  call void @exit(i32 1) #5
  unreachable

if.end:                                           ; preds = %entry
  %3 = load i32, i32* %SIZE.addr, align 4
  %mul2 = mul i32 8, %3
  %call3 = call noalias i8* @malloc(i32 %mul2)
  %4 = bitcast i8* %call3 to double*
  store double* %4, double** @base_arr, align 4
  %5 = load double*, double** @base_arr, align 4
  %cmp4 = icmp eq double* %5, null
  br i1 %cmp4, label %if.then5, label %if.end7

if.then5:                                         ; preds = %if.end
  %call6 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([33 x i8], [33 x i8]* @.str.3, i32 0, i32 0), i8* getelementptr inbounds ([23 x i8], [23 x i8]* @.str.1, i32 0, i32 0), i32 83)
  call void @perror(i8* getelementptr inbounds ([1 x i8], [1 x i8]* @.str.2, i32 0, i32 0))
  call void @exit(i32 1) #5
  unreachable

if.end7:                                          ; preds = %if.end
  store i32 0, i32* %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.end7
  %6 = load i32, i32* %i, align 4
  %7 = load i32, i32* %SIZE.addr, align 4
  %cmp8 = icmp ult i32 %6, %7
  br i1 %cmp8, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %8 = load double*, double** %ARRAY.addr, align 4
  %9 = load i32, i32* %i, align 4
  %arrayidx = getelementptr inbounds double, double* %8, i32 %9
  %10 = load double, double* %arrayidx, align 8
  %11 = load double*, double** @base_arr, align 4
  %12 = load i32, i32* %i, align 4
  %arrayidx9 = getelementptr inbounds double, double* %11, i32 %12
  store double %10, double* %arrayidx9, align 8
  %13 = load i32, i32* %i, align 4
  %14 = load i32*, i32** %idx, align 4
  %15 = load i32, i32* %i, align 4
  %arrayidx10 = getelementptr inbounds i32, i32* %14, i32 %15
  store i32 %13, i32* %arrayidx10, align 4
  br label %for.inc

for.inc:                                          ; preds = %for.body
  %16 = load i32, i32* %i, align 4
  %inc = add i32 %16, 1
  store i32 %inc, i32* %i, align 4
  br label %for.cond

for.end:                                          ; preds = %for.cond
  %17 = load i8, i8* %DECREASING.addr, align 1
  %tobool = trunc i8 %17 to i1
  %conv = zext i1 %tobool to i32
  %cmp11 = icmp eq i32 %conv, 0
  br i1 %cmp11, label %if.then13, label %if.else

if.then13:                                        ; preds = %for.end
  %18 = load i32*, i32** %idx, align 4
  %19 = bitcast i32* %18 to i8*
  %20 = load i32, i32* %SIZE.addr, align 4
  call void @qsort(i8* %19, i32 %20, i32 4, i32 (i8*, i8*)* @compar_decrease)
  br label %if.end20

if.else:                                          ; preds = %for.end
  %21 = load i8, i8* %DECREASING.addr, align 1
  %tobool14 = trunc i8 %21 to i1
  br i1 %tobool14, label %if.then18, label %if.end19

if.then18:                                        ; preds = %if.else
  %22 = load i32*, i32** %idx, align 4
  %23 = bitcast i32* %22 to i8*
  %24 = load i32, i32* %SIZE.addr, align 4
  call void @qsort(i8* %23, i32 %24, i32 4, i32 (i8*, i8*)* @compar_increase)
  br label %if.end19

if.end19:                                         ; preds = %if.then18, %if.else
  br label %if.end20

if.end20:                                         ; preds = %if.end19, %if.then13
  %25 = load double*, double** @base_arr, align 4
  %26 = bitcast double* %25 to i8*
  call void @free(i8* %26)
  store double* null, double** @base_arr, align 4
  %27 = load i32*, i32** %idx, align 4
  ret i32* %27
}

declare void @qsort(i8* %0, i32 %1, i32 %2, i32 (i8*, i8*)* %3) #1

; Function Attrs: noinline nounwind optnone
define internal i32 @compar_decrease(i8* noalias %a, i8* noalias %b) #0 {
entry:
  %retval = alloca i32, align 4
  %a.addr = alloca i8*, align 4
  %b.addr = alloca i8*, align 4
  %aa = alloca i32, align 4
  %bb = alloca i32, align 4
  store i8* %a, i8** %a.addr, align 4
  store i8* %b, i8** %b.addr, align 4
  %0 = load i8*, i8** %a.addr, align 4
  %1 = bitcast i8* %0 to i32*
  %2 = load i32, i32* %1, align 4
  store i32 %2, i32* %aa, align 4
  %3 = load i8*, i8** %b.addr, align 4
  %4 = bitcast i8* %3 to i32*
  %5 = load i32, i32* %4, align 4
  store i32 %5, i32* %bb, align 4
  %6 = load double*, double** @base_arr, align 4
  %7 = load i32, i32* %aa, align 4
  %arrayidx = getelementptr inbounds double, double* %6, i32 %7
  %8 = load double, double* %arrayidx, align 8
  %9 = load double*, double** @base_arr, align 4
  %10 = load i32, i32* %bb, align 4
  %arrayidx1 = getelementptr inbounds double, double* %9, i32 %10
  %11 = load double, double* %arrayidx1, align 8
  %cmp = fcmp olt double %8, %11
  br i1 %cmp, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  store i32 -1, i32* %retval, align 4
  br label %return

if.else:                                          ; preds = %entry
  %12 = load double*, double** @base_arr, align 4
  %13 = load i32, i32* %aa, align 4
  %arrayidx2 = getelementptr inbounds double, double* %12, i32 %13
  %14 = load double, double* %arrayidx2, align 8
  %15 = load double*, double** @base_arr, align 4
  %16 = load i32, i32* %bb, align 4
  %arrayidx3 = getelementptr inbounds double, double* %15, i32 %16
  %17 = load double, double* %arrayidx3, align 8
  %cmp4 = fcmp oeq double %14, %17
  br i1 %cmp4, label %if.then5, label %if.else6

if.then5:                                         ; preds = %if.else
  store i32 0, i32* %retval, align 4
  br label %return

if.else6:                                         ; preds = %if.else
  store i32 1, i32* %retval, align 4
  br label %return

return:                                           ; preds = %if.else6, %if.then5, %if.then
  %18 = load i32, i32* %retval, align 4
  ret i32 %18
}

; Function Attrs: noinline nounwind optnone
define internal i32 @compar_increase(i8* noalias %a, i8* noalias %b) #0 {
entry:
  %retval = alloca i32, align 4
  %a.addr = alloca i8*, align 4
  %b.addr = alloca i8*, align 4
  %aa = alloca i32, align 4
  %bb = alloca i32, align 4
  store i8* %a, i8** %a.addr, align 4
  store i8* %b, i8** %b.addr, align 4
  %0 = load i8*, i8** %a.addr, align 4
  %1 = bitcast i8* %0 to i32*
  %2 = load i32, i32* %1, align 4
  store i32 %2, i32* %aa, align 4
  %3 = load i8*, i8** %b.addr, align 4
  %4 = bitcast i8* %3 to i32*
  %5 = load i32, i32* %4, align 4
  store i32 %5, i32* %bb, align 4
  %6 = load double*, double** @base_arr, align 4
  %7 = load i32, i32* %aa, align 4
  %arrayidx = getelementptr inbounds double, double* %6, i32 %7
  %8 = load double, double* %arrayidx, align 8
  %9 = load double*, double** @base_arr, align 4
  %10 = load i32, i32* %bb, align 4
  %arrayidx1 = getelementptr inbounds double, double* %9, i32 %10
  %11 = load double, double* %arrayidx1, align 8
  %cmp = fcmp olt double %8, %11
  br i1 %cmp, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  store i32 1, i32* %retval, align 4
  br label %return

if.else:                                          ; preds = %entry
  %12 = load double*, double** @base_arr, align 4
  %13 = load i32, i32* %aa, align 4
  %arrayidx2 = getelementptr inbounds double, double* %12, i32 %13
  %14 = load double, double* %arrayidx2, align 8
  %15 = load double*, double** @base_arr, align 4
  %16 = load i32, i32* %bb, align 4
  %arrayidx3 = getelementptr inbounds double, double* %15, i32 %16
  %17 = load double, double* %arrayidx3, align 8
  %cmp4 = fcmp oeq double %14, %17
  br i1 %cmp4, label %if.then5, label %if.else6

if.then5:                                         ; preds = %if.else
  store i32 0, i32* %retval, align 4
  br label %return

if.else6:                                         ; preds = %if.else
  store i32 -1, i32* %retval, align 4
  br label %return

return:                                           ; preds = %if.else6, %if.then5, %if.then
  %18 = load i32, i32* %retval, align 4
  ret i32 %18
}

declare void @free(i8* %0) #1

; Function Attrs: noinline nounwind optnone
define hidden double* @cummin(double* noalias %ARRAY, i32 %NO_OF_ARRAY_ELEMENTS) #0 {
entry:
  %ARRAY.addr = alloca double*, align 4
  %NO_OF_ARRAY_ELEMENTS.addr = alloca i32, align 4
  %output = alloca double*, align 4
  %cumulative_min = alloca double, align 8
  %i = alloca i32, align 4
  store double* %ARRAY, double** %ARRAY.addr, align 4
  store i32 %NO_OF_ARRAY_ELEMENTS, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
  %0 = load i32, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
  %cmp = icmp ult i32 %0, 1
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %call = call i32 @puts(i8* getelementptr inbounds ([48 x i8], [48 x i8]* @.str.4, i32 0, i32 0))
  %call1 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([22 x i8], [22 x i8]* @.str.5, i32 0, i32 0), i8* getelementptr inbounds ([23 x i8], [23 x i8]* @.str.1, i32 0, i32 0), i32 105)
  call void @exit(i32 1) #5
  unreachable

if.end:                                           ; preds = %entry
  %1 = load i32, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
  %mul = mul i32 8, %1
  %call2 = call noalias i8* @malloc(i32 %mul)
  %2 = bitcast i8* %call2 to double*
  store double* %2, double** %output, align 4
  %3 = load double*, double** %output, align 4
  %cmp3 = icmp eq double* %3, null
  br i1 %cmp3, label %if.then4, label %if.end6

if.then4:                                         ; preds = %if.end
  %call5 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([33 x i8], [33 x i8]* @.str.3, i32 0, i32 0), i8* getelementptr inbounds ([23 x i8], [23 x i8]* @.str.1, i32 0, i32 0), i32 110)
  call void @perror(i8* getelementptr inbounds ([1 x i8], [1 x i8]* @.str.2, i32 0, i32 0))
  call void @exit(i32 1) #5
  unreachable

if.end6:                                          ; preds = %if.end
  %4 = load double*, double** %ARRAY.addr, align 4
  %arrayidx = getelementptr inbounds double, double* %4, i32 0
  %5 = load double, double* %arrayidx, align 8
  store double %5, double* %cumulative_min, align 8
  store i32 0, i32* %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.end6
  %6 = load i32, i32* %i, align 4
  %7 = load i32, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
  %cmp7 = icmp ult i32 %6, %7
  br i1 %cmp7, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %8 = load double*, double** %ARRAY.addr, align 4
  %9 = load i32, i32* %i, align 4
  %arrayidx8 = getelementptr inbounds double, double* %8, i32 %9
  %10 = load double, double* %arrayidx8, align 8
  %11 = load double, double* %cumulative_min, align 8
  %cmp9 = fcmp olt double %10, %11
  br i1 %cmp9, label %if.then10, label %if.end12

if.then10:                                        ; preds = %for.body
  %12 = load double*, double** %ARRAY.addr, align 4
  %13 = load i32, i32* %i, align 4
  %arrayidx11 = getelementptr inbounds double, double* %12, i32 %13
  %14 = load double, double* %arrayidx11, align 8
  store double %14, double* %cumulative_min, align 8
  br label %if.end12

if.end12:                                         ; preds = %if.then10, %for.body
  %15 = load double, double* %cumulative_min, align 8
  %16 = load double*, double** %output, align 4
  %17 = load i32, i32* %i, align 4
  %arrayidx13 = getelementptr inbounds double, double* %16, i32 %17
  store double %15, double* %arrayidx13, align 8
  br label %for.inc

for.inc:                                          ; preds = %if.end12
  %18 = load i32, i32* %i, align 4
  %inc = add i32 %18, 1
  store i32 %inc, i32* %i, align 4
  br label %for.cond

for.end:                                          ; preds = %for.cond
  %19 = load double*, double** %output, align 4
  ret double* %19
}

declare i32 @puts(i8* %0) #1

; Function Attrs: noinline nounwind optnone
define hidden double* @cummax(double* noalias %ARRAY, i32 %NO_OF_ARRAY_ELEMENTS) #0 {
entry:
  %ARRAY.addr = alloca double*, align 4
  %NO_OF_ARRAY_ELEMENTS.addr = alloca i32, align 4
  %output = alloca double*, align 4
  %cumulative_max = alloca double, align 8
  %i = alloca i32, align 4
  store double* %ARRAY, double** %ARRAY.addr, align 4
  store i32 %NO_OF_ARRAY_ELEMENTS, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
  %0 = load i32, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
  %cmp = icmp ult i32 %0, 1
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %call = call i32 @puts(i8* getelementptr inbounds ([41 x i8], [41 x i8]* @.str.6, i32 0, i32 0))
  %call1 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([22 x i8], [22 x i8]* @.str.5, i32 0, i32 0), i8* getelementptr inbounds ([23 x i8], [23 x i8]* @.str.1, i32 0, i32 0), i32 129)
  call void @exit(i32 1) #5
  unreachable

if.end:                                           ; preds = %entry
  %1 = load i32, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
  %mul = mul i32 8, %1
  %call2 = call noalias i8* @malloc(i32 %mul)
  %2 = bitcast i8* %call2 to double*
  store double* %2, double** %output, align 4
  %3 = load double*, double** %output, align 4
  %cmp3 = icmp eq double* %3, null
  br i1 %cmp3, label %if.then4, label %if.end6

if.then4:                                         ; preds = %if.end
  %call5 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([33 x i8], [33 x i8]* @.str.3, i32 0, i32 0), i8* getelementptr inbounds ([23 x i8], [23 x i8]* @.str.1, i32 0, i32 0), i32 134)
  call void @perror(i8* getelementptr inbounds ([1 x i8], [1 x i8]* @.str.2, i32 0, i32 0))
  call void @exit(i32 1) #5
  unreachable

if.end6:                                          ; preds = %if.end
  %4 = load double*, double** %ARRAY.addr, align 4
  %arrayidx = getelementptr inbounds double, double* %4, i32 0
  %5 = load double, double* %arrayidx, align 8
  store double %5, double* %cumulative_max, align 8
  store i32 0, i32* %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.end6
  %6 = load i32, i32* %i, align 4
  %7 = load i32, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
  %cmp7 = icmp ult i32 %6, %7
  br i1 %cmp7, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %8 = load double*, double** %ARRAY.addr, align 4
  %9 = load i32, i32* %i, align 4
  %arrayidx8 = getelementptr inbounds double, double* %8, i32 %9
  %10 = load double, double* %arrayidx8, align 8
  %11 = load double, double* %cumulative_max, align 8
  %cmp9 = fcmp ogt double %10, %11
  br i1 %cmp9, label %if.then10, label %if.end12

if.then10:                                        ; preds = %for.body
  %12 = load double*, double** %ARRAY.addr, align 4
  %13 = load i32, i32* %i, align 4
  %arrayidx11 = getelementptr inbounds double, double* %12, i32 %13
  %14 = load double, double* %arrayidx11, align 8
  store double %14, double* %cumulative_max, align 8
  br label %if.end12

if.end12:                                         ; preds = %if.then10, %for.body
  %15 = load double, double* %cumulative_max, align 8
  %16 = load double*, double** %output, align 4
  %17 = load i32, i32* %i, align 4
  %arrayidx13 = getelementptr inbounds double, double* %16, i32 %17
  store double %15, double* %arrayidx13, align 8
  br label %for.inc

for.inc:                                          ; preds = %if.end12
  %18 = load i32, i32* %i, align 4
  %inc = add i32 %18, 1
  store i32 %inc, i32* %i, align 4
  br label %for.cond

for.end:                                          ; preds = %for.cond
  %19 = load double*, double** %output, align 4
  ret double* %19
}

; Function Attrs: noinline nounwind optnone
define hidden double* @pminx(double* noalias %ARRAY, i32 %NO_OF_ARRAY_ELEMENTS, double %X) #0 {
entry:
  %ARRAY.addr = alloca double*, align 4
  %NO_OF_ARRAY_ELEMENTS.addr = alloca i32, align 4
  %X.addr = alloca double, align 8
  %pmin_array = alloca double*, align 4
  %index = alloca i32, align 4
  store double* %ARRAY, double** %ARRAY.addr, align 4
  store i32 %NO_OF_ARRAY_ELEMENTS, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
  store double %X, double* %X.addr, align 8
  %0 = load i32, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
  %cmp = icmp ult i32 %0, 1
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %call = call i32 @puts(i8* getelementptr inbounds ([37 x i8], [37 x i8]* @.str.7, i32 0, i32 0))
  %call1 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([22 x i8], [22 x i8]* @.str.5, i32 0, i32 0), i8* getelementptr inbounds ([23 x i8], [23 x i8]* @.str.1, i32 0, i32 0), i32 152)
  call void @exit(i32 1) #5
  unreachable

if.end:                                           ; preds = %entry
  %1 = load i32, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
  %mul = mul i32 8, %1
  %call2 = call noalias i8* @malloc(i32 %mul)
  %2 = bitcast i8* %call2 to double*
  store double* %2, double** %pmin_array, align 4
  %3 = load double*, double** %pmin_array, align 4
  %cmp3 = icmp eq double* %3, null
  br i1 %cmp3, label %if.then4, label %if.end6

if.then4:                                         ; preds = %if.end
  %call5 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([33 x i8], [33 x i8]* @.str.3, i32 0, i32 0), i8* getelementptr inbounds ([23 x i8], [23 x i8]* @.str.1, i32 0, i32 0), i32 157)
  call void @perror(i8* getelementptr inbounds ([1 x i8], [1 x i8]* @.str.2, i32 0, i32 0))
  call void @exit(i32 1) #5
  unreachable

if.end6:                                          ; preds = %if.end
  store i32 0, i32* %index, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.end6
  %4 = load i32, i32* %index, align 4
  %5 = load i32, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
  %cmp7 = icmp ult i32 %4, %5
  br i1 %cmp7, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %6 = load double*, double** %ARRAY.addr, align 4
  %7 = load i32, i32* %index, align 4
  %arrayidx = getelementptr inbounds double, double* %6, i32 %7
  %8 = load double, double* %arrayidx, align 8
  %9 = load double, double* %X.addr, align 8
  %cmp8 = fcmp olt double %8, %9
  br i1 %cmp8, label %if.then9, label %if.else

if.then9:                                         ; preds = %for.body
  %10 = load double*, double** %ARRAY.addr, align 4
  %11 = load i32, i32* %index, align 4
  %arrayidx10 = getelementptr inbounds double, double* %10, i32 %11
  %12 = load double, double* %arrayidx10, align 8
  %13 = load double*, double** %pmin_array, align 4
  %14 = load i32, i32* %index, align 4
  %arrayidx11 = getelementptr inbounds double, double* %13, i32 %14
  store double %12, double* %arrayidx11, align 8
  br label %if.end13

if.else:                                          ; preds = %for.body
  %15 = load double, double* %X.addr, align 8
  %16 = load double*, double** %pmin_array, align 4
  %17 = load i32, i32* %index, align 4
  %arrayidx12 = getelementptr inbounds double, double* %16, i32 %17
  store double %15, double* %arrayidx12, align 8
  br label %if.end13

if.end13:                                         ; preds = %if.else, %if.then9
  br label %for.inc

for.inc:                                          ; preds = %if.end13
  %18 = load i32, i32* %index, align 4
  %inc = add i32 %18, 1
  store i32 %inc, i32* %index, align 4
  br label %for.cond

for.end:                                          ; preds = %for.cond
  %19 = load double*, double** %pmin_array, align 4
  ret double* %19
}

; Function Attrs: noinline nounwind optnone
define hidden void @double_say(double* noalias %ARRAY, i32 %NO_OF_ARRAY_ELEMENTS) #0 {
entry:
  %ARRAY.addr = alloca double*, align 4
  %NO_OF_ARRAY_ELEMENTS.addr = alloca i32, align 4
  %i = alloca i32, align 4
  store double* %ARRAY, double** %ARRAY.addr, align 4
  store i32 %NO_OF_ARRAY_ELEMENTS, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
  %0 = load double*, double** %ARRAY.addr, align 4
  %arrayidx = getelementptr inbounds double, double* %0, i32 0
  %1 = load double, double* %arrayidx, align 8
  %call = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([7 x i8], [7 x i8]* @.str.8, i32 0, i32 0), double %1)
  store i32 1, i32* %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %2 = load i32, i32* %i, align 4
  %3 = load i32, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
  %cmp = icmp ult i32 %2, %3
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %4 = load double*, double** %ARRAY.addr, align 4
  %5 = load i32, i32* %i, align 4
  %arrayidx1 = getelementptr inbounds double, double* %4, i32 %5
  %6 = load double, double* %arrayidx1, align 8
  %call2 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([7 x i8], [7 x i8]* @.str.9, i32 0, i32 0), double %6)
  %7 = load i32, i32* %i, align 4
  %add = add i32 %7, 1
  %rem = urem i32 %add, 5
  %cmp3 = icmp eq i32 %rem, 0
  br i1 %cmp3, label %if.then, label %if.end

if.then:                                          ; preds = %for.body
  %8 = load i32, i32* %i, align 4
  %add4 = add i32 %8, 1
  %call5 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([6 x i8], [6 x i8]* @.str.10, i32 0, i32 0), i32 %add4)
  br label %if.end

if.end:                                           ; preds = %if.then, %for.body
  br label %for.inc

for.inc:                                          ; preds = %if.end
  %9 = load i32, i32* %i, align 4
  %inc = add i32 %9, 1
  store i32 %inc, i32* %i, align 4
  br label %for.cond

for.end:                                          ; preds = %for.cond
  %call6 = call i32 @puts(i8* getelementptr inbounds ([2 x i8], [2 x i8]* @.str.11, i32 0, i32 0))
  ret void
}

; Function Attrs: noinline nounwind optnone
define hidden double* @uint2double(i32* noalias %ARRAY, i32 %NO_OF_ARRAY_ELEMENTS) #0 {
entry:
  %ARRAY.addr = alloca i32*, align 4
  %NO_OF_ARRAY_ELEMENTS.addr = alloca i32, align 4
  %doubleArray = alloca double*, align 4
  %index = alloca i32, align 4
  store i32* %ARRAY, i32** %ARRAY.addr, align 4
  store i32 %NO_OF_ARRAY_ELEMENTS, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
  %0 = load i32, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
  %mul = mul i32 8, %0
  %call = call noalias i8* @malloc(i32 %mul)
  %1 = bitcast i8* %call to double*
  store double* %1, double** %doubleArray, align 4
  %2 = load double*, double** %doubleArray, align 4
  %cmp = icmp eq double* %2, null
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %call1 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([34 x i8], [34 x i8]* @.str.12, i32 0, i32 0), i8* getelementptr inbounds ([23 x i8], [23 x i8]* @.str.1, i32 0, i32 0), i32 194)
  call void @perror(i8* getelementptr inbounds ([1 x i8], [1 x i8]* @.str.2, i32 0, i32 0))
  call void @exit(i32 1) #5
  unreachable

if.end:                                           ; preds = %entry
  store i32 0, i32* %index, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.end
  %3 = load i32, i32* %index, align 4
  %4 = load i32, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
  %cmp2 = icmp ult i32 %3, %4
  br i1 %cmp2, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %5 = load i32*, i32** %ARRAY.addr, align 4
  %6 = load i32, i32* %index, align 4
  %arrayidx = getelementptr inbounds i32, i32* %5, i32 %6
  %7 = load i32, i32* %arrayidx, align 4
  %conv = uitofp i32 %7 to double
  %8 = load double*, double** %doubleArray, align 4
  %9 = load i32, i32* %index, align 4
  %arrayidx3 = getelementptr inbounds double, double* %8, i32 %9
  store double %conv, double* %arrayidx3, align 8
  br label %for.inc

for.inc:                                          ; preds = %for.body
  %10 = load i32, i32* %index, align 4
  %inc = add i32 %10, 1
  store i32 %inc, i32* %index, align 4
  br label %for.cond

for.end:                                          ; preds = %for.cond
  %11 = load double*, double** %doubleArray, align 4
  ret double* %11
}

; Function Attrs: noinline nounwind optnone
define hidden double @min2(double %N1, double %N2) #0 {
entry:
  %retval = alloca double, align 8
  %N1.addr = alloca double, align 8
  %N2.addr = alloca double, align 8
  store double %N1, double* %N1.addr, align 8
  store double %N2, double* %N2.addr, align 8
  %0 = load double, double* %N1.addr, align 8
  %1 = load double, double* %N2.addr, align 8
  %cmp = fcmp olt double %0, %1
  br i1 %cmp, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  %2 = load double, double* %N1.addr, align 8
  store double %2, double* %retval, align 8
  br label %return

if.else:                                          ; preds = %entry
  %3 = load double, double* %N2.addr, align 8
  store double %3, double* %retval, align 8
  br label %return

return:                                           ; preds = %if.else, %if.then
  %4 = load double, double* %retval, align 8
  ret double %4
}

; Function Attrs: noinline nounwind optnone
define hidden double* @p_adjust(double* noalias %PVALUES, i32 %NO_OF_ARRAY_ELEMENTS, i8* noalias %STRING) #0 {
entry:
  %retval = alloca double*, align 4
  %PVALUES.addr = alloca double*, align 4
  %NO_OF_ARRAY_ELEMENTS.addr = alloca i32, align 4
  %STRING.addr = alloca i8*, align 4
  %TYPE = alloca i16, align 2
  %bonferroni = alloca double*, align 4
  %index = alloca i32, align 4
  %BONFERRONI = alloca double, align 8
  %o = alloca i32*, align 4
  %o2double = alloca double*, align 4
  %cummax_input = alloca double*, align 4
  %index80 = alloca i32, align 4
  %ro = alloca i32*, align 4
  %cummax_output = alloca double*, align 4
  %pmin = alloca double*, align 4
  %qvalues = alloca double*, align 4
  %index98 = alloca i32, align 4
  %o114 = alloca i32*, align 4
  %p = alloca double*, align 4
  %index123 = alloca i32, align 4
  %o2double134 = alloca double*, align 4
  %ro136 = alloca i32*, align 4
  %q = alloca double*, align 4
  %pa = alloca double*, align 4
  %min = alloca double, align 8
  %index155 = alloca i32, align 4
  %TEMP = alloca double, align 8
  %index171 = alloca i32, align 4
  %j = alloca i32, align 4
  %ij = alloca i32*, align 4
  %I2_LENGTH = alloca i32, align 4
  %i2 = alloca i32*, align 4
  %i = alloca i32, align 4
  %q1 = alloca double, align 8
  %i208 = alloca i32, align 4
  %TEMP_Q1 = alloca double, align 8
  %i227 = alloca i32, align 4
  %i244 = alloca i32, align 4
  %i256 = alloca i32, align 4
  %index274 = alloca i32, align 4
  %o288 = alloca i32*, align 4
  %o_double = alloca double*, align 4
  %index296 = alloca i32, align 4
  %ro315 = alloca i32*, align 4
  %cummin_input = alloca double*, align 4
  %index328 = alloca i32, align 4
  %NI = alloca double, align 8
  %q349 = alloca double, align 8
  %index350 = alloca i32, align 4
  %index362 = alloca i32, align 4
  %NI367 = alloca double, align 8
  %index385 = alloca i32, align 4
  %cummin_array = alloca double*, align 4
  %pmin403 = alloca double*, align 4
  %q_array = alloca double*, align 4
  %index407 = alloca i32, align 4
  store double* %PVALUES, double** %PVALUES.addr, align 4
  store i32 %NO_OF_ARRAY_ELEMENTS, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
  store i8* %STRING, i8** %STRING.addr, align 4
  %0 = load i32, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
  %cmp = icmp ult i32 %0, 1
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %call = call i32 @puts(i8* getelementptr inbounds ([41 x i8], [41 x i8]* @.str.13, i32 0, i32 0))
  %call1 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([22 x i8], [22 x i8]* @.str.5, i32 0, i32 0), i8* getelementptr inbounds ([23 x i8], [23 x i8]* @.str.1, i32 0, i32 0), i32 217)
  call void @exit(i32 1) #5
  unreachable

if.end:                                           ; preds = %entry
  store i16 -1, i16* %TYPE, align 2
  %1 = load i8*, i8** %STRING.addr, align 4
  %cmp2 = icmp eq i8* %1, null
  br i1 %cmp2, label %if.then3, label %if.else

if.then3:                                         ; preds = %if.end
  store i16 0, i16* %TYPE, align 2
  br label %if.end41

if.else:                                          ; preds = %if.end
  %2 = load i8*, i8** %STRING.addr, align 4
  %call4 = call i32 @strcasecmp(i8* %2, i8* getelementptr inbounds ([3 x i8], [3 x i8]* @.str.14, i32 0, i32 0))
  %cmp5 = icmp eq i32 %call4, 0
  br i1 %cmp5, label %if.then6, label %if.else7

if.then6:                                         ; preds = %if.else
  store i16 0, i16* %TYPE, align 2
  br label %if.end40

if.else7:                                         ; preds = %if.else
  %3 = load i8*, i8** %STRING.addr, align 4
  %call8 = call i32 @strcasecmp(i8* %3, i8* getelementptr inbounds ([4 x i8], [4 x i8]* @.str.15, i32 0, i32 0))
  %cmp9 = icmp eq i32 %call8, 0
  br i1 %cmp9, label %if.then10, label %if.else11

if.then10:                                        ; preds = %if.else7
  store i16 0, i16* %TYPE, align 2
  br label %if.end39

if.else11:                                        ; preds = %if.else7
  %4 = load i8*, i8** %STRING.addr, align 4
  %call12 = call i32 @strcasecmp(i8* %4, i8* getelementptr inbounds ([3 x i8], [3 x i8]* @.str.16, i32 0, i32 0))
  %cmp13 = icmp eq i32 %call12, 0
  br i1 %cmp13, label %if.then14, label %if.else15

if.then14:                                        ; preds = %if.else11
  store i16 1, i16* %TYPE, align 2
  br label %if.end38

if.else15:                                        ; preds = %if.else11
  %5 = load i8*, i8** %STRING.addr, align 4
  %call16 = call i32 @strcasecmp(i8* %5, i8* getelementptr inbounds ([11 x i8], [11 x i8]* @.str.17, i32 0, i32 0))
  %cmp17 = icmp eq i32 %call16, 0
  br i1 %cmp17, label %if.then18, label %if.else19

if.then18:                                        ; preds = %if.else15
  store i16 2, i16* %TYPE, align 2
  br label %if.end37

if.else19:                                        ; preds = %if.else15
  %6 = load i8*, i8** %STRING.addr, align 4
  %call20 = call i32 @strcasecmp(i8* %6, i8* getelementptr inbounds ([9 x i8], [9 x i8]* @.str.18, i32 0, i32 0))
  %cmp21 = icmp eq i32 %call20, 0
  br i1 %cmp21, label %if.then22, label %if.else23

if.then22:                                        ; preds = %if.else19
  store i16 3, i16* %TYPE, align 2
  br label %if.end36

if.else23:                                        ; preds = %if.else19
  %7 = load i8*, i8** %STRING.addr, align 4
  %call24 = call i32 @strcasecmp(i8* %7, i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.19, i32 0, i32 0))
  %cmp25 = icmp eq i32 %call24, 0
  br i1 %cmp25, label %if.then26, label %if.else27

if.then26:                                        ; preds = %if.else23
  store i16 4, i16* %TYPE, align 2
  br label %if.end35

if.else27:                                        ; preds = %if.else23
  %8 = load i8*, i8** %STRING.addr, align 4
  %call28 = call i32 @strcasecmp(i8* %8, i8* getelementptr inbounds ([7 x i8], [7 x i8]* @.str.20, i32 0, i32 0))
  %cmp29 = icmp eq i32 %call28, 0
  br i1 %cmp29, label %if.then30, label %if.else31

if.then30:                                        ; preds = %if.else27
  store i16 5, i16* %TYPE, align 2
  br label %if.end34

if.else31:                                        ; preds = %if.else27
  %9 = load i8*, i8** %STRING.addr, align 4
  %call32 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([44 x i8], [44 x i8]* @.str.21, i32 0, i32 0), i8* %9)
  %call33 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([22 x i8], [22 x i8]* @.str.5, i32 0, i32 0), i8* getelementptr inbounds ([23 x i8], [23 x i8]* @.str.1, i32 0, i32 0), i32 239)
  call void @exit(i32 1) #5
  unreachable

if.end34:                                         ; preds = %if.then30
  br label %if.end35

if.end35:                                         ; preds = %if.end34, %if.then26
  br label %if.end36

if.end36:                                         ; preds = %if.end35, %if.then22
  br label %if.end37

if.end37:                                         ; preds = %if.end36, %if.then18
  br label %if.end38

if.end38:                                         ; preds = %if.end37, %if.then14
  br label %if.end39

if.end39:                                         ; preds = %if.end38, %if.then10
  br label %if.end40

if.end40:                                         ; preds = %if.end39, %if.then6
  br label %if.end41

if.end41:                                         ; preds = %if.end40, %if.then3
  %10 = load i16, i16* %TYPE, align 2
  %conv = sext i16 %10 to i32
  %cmp42 = icmp eq i32 %conv, 2
  br i1 %cmp42, label %if.then44, label %if.else71

if.then44:                                        ; preds = %if.end41
  %11 = load i32, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
  %mul = mul i32 8, %11
  %call45 = call noalias i8* @malloc(i32 %mul)
  %12 = bitcast i8* %call45 to double*
  store double* %12, double** %bonferroni, align 4
  %13 = load double*, double** %bonferroni, align 4
  %cmp46 = icmp eq double* %13, null
  br i1 %cmp46, label %if.then48, label %if.end50

if.then48:                                        ; preds = %if.then44
  %call49 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([33 x i8], [33 x i8]* @.str.3, i32 0, i32 0), i8* getelementptr inbounds ([23 x i8], [23 x i8]* @.str.1, i32 0, i32 0), i32 247)
  call void @perror(i8* getelementptr inbounds ([1 x i8], [1 x i8]* @.str.2, i32 0, i32 0))
  call void @exit(i32 1) #5
  unreachable

if.end50:                                         ; preds = %if.then44
  store i32 0, i32* %index, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.end50
  %14 = load i32, i32* %index, align 4
  %15 = load i32, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
  %cmp51 = icmp ult i32 %14, %15
  br i1 %cmp51, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %16 = load double*, double** %PVALUES.addr, align 4
  %17 = load i32, i32* %index, align 4
  %arrayidx = getelementptr inbounds double, double* %16, i32 %17
  %18 = load double, double* %arrayidx, align 8
  %19 = load i32, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
  %conv53 = uitofp i32 %19 to double
  %mul54 = fmul double %18, %conv53
  store double %mul54, double* %BONFERRONI, align 8
  %20 = load double, double* %BONFERRONI, align 8
  %cmp55 = fcmp oge double %20, 1.000000e+00
  br i1 %cmp55, label %if.then57, label %if.else59

if.then57:                                        ; preds = %for.body
  %21 = load double*, double** %bonferroni, align 4
  %22 = load i32, i32* %index, align 4
  %arrayidx58 = getelementptr inbounds double, double* %21, i32 %22
  store double 1.000000e+00, double* %arrayidx58, align 8
  br label %if.end70

if.else59:                                        ; preds = %for.body
  %23 = load double, double* %BONFERRONI, align 8
  %cmp60 = fcmp ole double 0.000000e+00, %23
  br i1 %cmp60, label %land.lhs.true, label %if.else66

land.lhs.true:                                    ; preds = %if.else59
  %24 = load double, double* %BONFERRONI, align 8
  %cmp62 = fcmp olt double %24, 1.000000e+00
  br i1 %cmp62, label %if.then64, label %if.else66

if.then64:                                        ; preds = %land.lhs.true
  %25 = load double, double* %BONFERRONI, align 8
  %26 = load double*, double** %bonferroni, align 4
  %27 = load i32, i32* %index, align 4
  %arrayidx65 = getelementptr inbounds double, double* %26, i32 %27
  store double %25, double* %arrayidx65, align 8
  br label %if.end69

if.else66:                                        ; preds = %land.lhs.true, %if.else59
  %28 = load double, double* %BONFERRONI, align 8
  %call67 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([42 x i8], [42 x i8]* @.str.22, i32 0, i32 0), double %28)
  %call68 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([23 x i8], [23 x i8]* @.str.23, i32 0, i32 0), i8* getelementptr inbounds ([23 x i8], [23 x i8]* @.str.1, i32 0, i32 0), i32 259)
  call void @exit(i32 1) #5
  unreachable

if.end69:                                         ; preds = %if.then64
  br label %if.end70

if.end70:                                         ; preds = %if.end69, %if.then57
  br label %for.inc

for.inc:                                          ; preds = %if.end70
  %29 = load i32, i32* %index, align 4
  %inc = add i32 %29, 1
  store i32 %inc, i32* %index, align 4
  br label %for.cond

for.end:                                          ; preds = %for.cond
  %30 = load double*, double** %bonferroni, align 4
  store double* %30, double** %retval, align 4
  br label %return

if.else71:                                        ; preds = %if.end41
  %31 = load i16, i16* %TYPE, align 2
  %conv72 = sext i16 %31 to i32
  %cmp73 = icmp eq i32 %conv72, 4
  br i1 %cmp73, label %if.then75, label %if.else109

if.then75:                                        ; preds = %if.else71
  %32 = load double*, double** %PVALUES.addr, align 4
  %33 = load i32, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
  %call76 = call i32* @order(double* %32, i32 %33, i1 zeroext false)
  store i32* %call76, i32** %o, align 4
  %34 = load i32*, i32** %o, align 4
  %35 = load i32, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
  %call77 = call double* @uint2double(i32* %34, i32 %35)
  store double* %call77, double** %o2double, align 4
  %36 = load i32, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
  %mul78 = mul i32 8, %36
  %call79 = call noalias i8* @malloc(i32 %mul78)
  %37 = bitcast i8* %call79 to double*
  store double* %37, double** %cummax_input, align 4
  store i32 0, i32* %index80, align 4
  br label %for.cond81

for.cond81:                                       ; preds = %for.inc90, %if.then75
  %38 = load i32, i32* %index80, align 4
  %39 = load i32, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
  %cmp82 = icmp ult i32 %38, %39
  br i1 %cmp82, label %for.body84, label %for.end92

for.body84:                                       ; preds = %for.cond81
  %40 = load i32, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
  %41 = load i32, i32* %index80, align 4
  %sub = sub i32 %40, %41
  %conv85 = uitofp i32 %sub to double
  %42 = load double*, double** %PVALUES.addr, align 4
  %43 = load i32*, i32** %o, align 4
  %44 = load i32, i32* %index80, align 4
  %arrayidx86 = getelementptr inbounds i32, i32* %43, i32 %44
  %45 = load i32, i32* %arrayidx86, align 4
  %arrayidx87 = getelementptr inbounds double, double* %42, i32 %45
  %46 = load double, double* %arrayidx87, align 8
  %mul88 = fmul double %conv85, %46
  %47 = load double*, double** %cummax_input, align 4
  %48 = load i32, i32* %index80, align 4
  %arrayidx89 = getelementptr inbounds double, double* %47, i32 %48
  store double %mul88, double* %arrayidx89, align 8
  br label %for.inc90

for.inc90:                                        ; preds = %for.body84
  %49 = load i32, i32* %index80, align 4
  %inc91 = add i32 %49, 1
  store i32 %inc91, i32* %index80, align 4
  br label %for.cond81

for.end92:                                        ; preds = %for.cond81
  %50 = load i32*, i32** %o, align 4
  %51 = bitcast i32* %50 to i8*
  call void @free(i8* %51)
  store i32* null, i32** %o, align 4
  %52 = load double*, double** %o2double, align 4
  %53 = load i32, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
  %call93 = call i32* @order(double* %52, i32 %53, i1 zeroext false)
  store i32* %call93, i32** %ro, align 4
  %54 = load double*, double** %o2double, align 4
  %55 = bitcast double* %54 to i8*
  call void @free(i8* %55)
  store double* null, double** %o2double, align 4
  %56 = load double*, double** %cummax_input, align 4
  %57 = load i32, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
  %call94 = call double* @cummax(double* %56, i32 %57)
  store double* %call94, double** %cummax_output, align 4
  %58 = load double*, double** %cummax_input, align 4
  %59 = bitcast double* %58 to i8*
  call void @free(i8* %59)
  store double* null, double** %cummax_input, align 4
  %60 = load double*, double** %cummax_output, align 4
  %61 = load i32, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
  %call95 = call double* @pminx(double* %60, i32 %61, double 1.000000e+00)
  store double* %call95, double** %pmin, align 4
  %62 = load double*, double** %cummax_output, align 4
  %63 = bitcast double* %62 to i8*
  call void @free(i8* %63)
  store double* null, double** %cummax_output, align 4
  %64 = load i32, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
  %mul96 = mul i32 8, %64
  %call97 = call noalias i8* @malloc(i32 %mul96)
  %65 = bitcast i8* %call97 to double*
  store double* %65, double** %qvalues, align 4
  store i32 0, i32* %index98, align 4
  br label %for.cond99

for.cond99:                                       ; preds = %for.inc106, %for.end92
  %66 = load i32, i32* %index98, align 4
  %67 = load i32, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
  %cmp100 = icmp ult i32 %66, %67
  br i1 %cmp100, label %for.body102, label %for.end108

for.body102:                                      ; preds = %for.cond99
  %68 = load double*, double** %pmin, align 4
  %69 = load i32*, i32** %ro, align 4
  %70 = load i32, i32* %index98, align 4
  %arrayidx103 = getelementptr inbounds i32, i32* %69, i32 %70
  %71 = load i32, i32* %arrayidx103, align 4
  %arrayidx104 = getelementptr inbounds double, double* %68, i32 %71
  %72 = load double, double* %arrayidx104, align 8
  %73 = load double*, double** %qvalues, align 4
  %74 = load i32, i32* %index98, align 4
  %arrayidx105 = getelementptr inbounds double, double* %73, i32 %74
  store double %72, double* %arrayidx105, align 8
  br label %for.inc106

for.inc106:                                       ; preds = %for.body102
  %75 = load i32, i32* %index98, align 4
  %inc107 = add i32 %75, 1
  store i32 %inc107, i32* %index98, align 4
  br label %for.cond99

for.end108:                                       ; preds = %for.cond99
  %76 = load double*, double** %pmin, align 4
  %77 = bitcast double* %76 to i8*
  call void @free(i8* %77)
  store double* null, double** %pmin, align 4
  %78 = load i32*, i32** %ro, align 4
  %79 = bitcast i32* %78 to i8*
  call void @free(i8* %79)
  store i32* null, i32** %ro, align 4
  %80 = load double*, double** %qvalues, align 4
  store double* %80, double** %retval, align 4
  br label %return

if.else109:                                       ; preds = %if.else71
  %81 = load i16, i16* %TYPE, align 2
  %conv110 = sext i16 %81 to i32
  %cmp111 = icmp eq i32 %conv110, 5
  br i1 %cmp111, label %if.then113, label %if.end285

if.then113:                                       ; preds = %if.else109
  %82 = load double*, double** %PVALUES.addr, align 4
  %83 = load i32, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
  %call115 = call i32* @order(double* %82, i32 %83, i1 zeroext false)
  store i32* %call115, i32** %o114, align 4
  %84 = load i32, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
  %mul116 = mul i32 8, %84
  %call117 = call noalias i8* @malloc(i32 %mul116)
  %85 = bitcast i8* %call117 to double*
  store double* %85, double** %p, align 4
  %86 = load double*, double** %p, align 4
  %cmp118 = icmp eq double* %86, null
  br i1 %cmp118, label %if.then120, label %if.end122

if.then120:                                       ; preds = %if.then113
  %call121 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([33 x i8], [33 x i8]* @.str.3, i32 0, i32 0), i8* getelementptr inbounds ([23 x i8], [23 x i8]* @.str.1, i32 0, i32 0), i32 302)
  call void @perror(i8* getelementptr inbounds ([1 x i8], [1 x i8]* @.str.2, i32 0, i32 0))
  call void @exit(i32 1) #5
  unreachable

if.end122:                                        ; preds = %if.then113
  store i32 0, i32* %index123, align 4
  br label %for.cond124

for.cond124:                                      ; preds = %for.inc131, %if.end122
  %87 = load i32, i32* %index123, align 4
  %88 = load i32, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
  %cmp125 = icmp ult i32 %87, %88
  br i1 %cmp125, label %for.body127, label %for.end133

for.body127:                                      ; preds = %for.cond124
  %89 = load double*, double** %PVALUES.addr, align 4
  %90 = load i32*, i32** %o114, align 4
  %91 = load i32, i32* %index123, align 4
  %arrayidx128 = getelementptr inbounds i32, i32* %90, i32 %91
  %92 = load i32, i32* %arrayidx128, align 4
  %arrayidx129 = getelementptr inbounds double, double* %89, i32 %92
  %93 = load double, double* %arrayidx129, align 8
  %94 = load double*, double** %p, align 4
  %95 = load i32, i32* %index123, align 4
  %arrayidx130 = getelementptr inbounds double, double* %94, i32 %95
  store double %93, double* %arrayidx130, align 8
  br label %for.inc131

for.inc131:                                       ; preds = %for.body127
  %96 = load i32, i32* %index123, align 4
  %inc132 = add i32 %96, 1
  store i32 %inc132, i32* %index123, align 4
  br label %for.cond124

for.end133:                                       ; preds = %for.cond124
  %97 = load i32*, i32** %o114, align 4
  %98 = load i32, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
  %call135 = call double* @uint2double(i32* %97, i32 %98)
  store double* %call135, double** %o2double134, align 4
  %99 = load i32*, i32** %o114, align 4
  %100 = bitcast i32* %99 to i8*
  call void @free(i8* %100)
  store i32* null, i32** %o114, align 4
  %101 = load double*, double** %o2double134, align 4
  %102 = load i32, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
  %call137 = call i32* @order(double* %101, i32 %102, i1 zeroext false)
  store i32* %call137, i32** %ro136, align 4
  %103 = load double*, double** %o2double134, align 4
  %104 = bitcast double* %103 to i8*
  call void @free(i8* %104)
  store double* null, double** %o2double134, align 4
  %105 = load i32, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
  %mul138 = mul i32 8, %105
  %call139 = call noalias i8* @malloc(i32 %mul138)
  %106 = bitcast i8* %call139 to double*
  store double* %106, double** %q, align 4
  %107 = load double*, double** %q, align 4
  %cmp140 = icmp eq double* %107, null
  br i1 %cmp140, label %if.then142, label %if.end144

if.then142:                                       ; preds = %for.end133
  %call143 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([33 x i8], [33 x i8]* @.str.3, i32 0, i32 0), i8* getelementptr inbounds ([23 x i8], [23 x i8]* @.str.1, i32 0, i32 0), i32 318)
  call void @perror(i8* getelementptr inbounds ([1 x i8], [1 x i8]* @.str.2, i32 0, i32 0))
  call void @exit(i32 1) #5
  unreachable

if.end144:                                        ; preds = %for.end133
  %108 = load i32, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
  %mul145 = mul i32 8, %108
  %call146 = call noalias i8* @malloc(i32 %mul145)
  %109 = bitcast i8* %call146 to double*
  store double* %109, double** %pa, align 4
  %110 = load double*, double** %pa, align 4
  %cmp147 = icmp eq double* %110, null
  br i1 %cmp147, label %if.then149, label %if.end151

if.then149:                                       ; preds = %if.end144
  %call150 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([33 x i8], [33 x i8]* @.str.3, i32 0, i32 0), i8* getelementptr inbounds ([23 x i8], [23 x i8]* @.str.1, i32 0, i32 0), i32 324)
  call void @perror(i8* getelementptr inbounds ([1 x i8], [1 x i8]* @.str.2, i32 0, i32 0))
  call void @exit(i32 1) #5
  unreachable

if.end151:                                        ; preds = %if.end144
  %111 = load i32, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
  %conv152 = uitofp i32 %111 to double
  %112 = load double*, double** %p, align 4
  %arrayidx153 = getelementptr inbounds double, double* %112, i32 0
  %113 = load double, double* %arrayidx153, align 8
  %mul154 = fmul double %conv152, %113
  store double %mul154, double* %min, align 8
  store i32 1, i32* %index155, align 4
  br label %for.cond156

for.cond156:                                      ; preds = %for.inc168, %if.end151
  %114 = load i32, i32* %index155, align 4
  %115 = load i32, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
  %cmp157 = icmp ult i32 %114, %115
  br i1 %cmp157, label %for.body159, label %for.end170

for.body159:                                      ; preds = %for.cond156
  %116 = load i32, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
  %conv160 = uitofp i32 %116 to double
  %117 = load double*, double** %p, align 4
  %118 = load i32, i32* %index155, align 4
  %arrayidx161 = getelementptr inbounds double, double* %117, i32 %118
  %119 = load double, double* %arrayidx161, align 8
  %mul162 = fmul double %conv160, %119
  %120 = load i32, i32* %index155, align 4
  %add = add i32 1, %120
  %conv163 = uitofp i32 %add to double
  %div = fdiv double %mul162, %conv163
  store double %div, double* %TEMP, align 8
  %121 = load double, double* %TEMP, align 8
  %122 = load double, double* %min, align 8
  %cmp164 = fcmp olt double %121, %122
  br i1 %cmp164, label %if.then166, label %if.end167

if.then166:                                       ; preds = %for.body159
  %123 = load double, double* %TEMP, align 8
  store double %123, double* %min, align 8
  br label %if.end167

if.end167:                                        ; preds = %if.then166, %for.body159
  br label %for.inc168

for.inc168:                                       ; preds = %if.end167
  %124 = load i32, i32* %index155, align 4
  %inc169 = add i32 %124, 1
  store i32 %inc169, i32* %index155, align 4
  br label %for.cond156

for.end170:                                       ; preds = %for.cond156
  store i32 0, i32* %index171, align 4
  br label %for.cond172

for.cond172:                                      ; preds = %for.inc178, %for.end170
  %125 = load i32, i32* %index171, align 4
  %126 = load i32, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
  %cmp173 = icmp ult i32 %125, %126
  br i1 %cmp173, label %for.body175, label %for.end180

for.body175:                                      ; preds = %for.cond172
  %127 = load double, double* %min, align 8
  %128 = load double*, double** %pa, align 4
  %129 = load i32, i32* %index171, align 4
  %arrayidx176 = getelementptr inbounds double, double* %128, i32 %129
  store double %127, double* %arrayidx176, align 8
  %130 = load double, double* %min, align 8
  %131 = load double*, double** %q, align 4
  %132 = load i32, i32* %index171, align 4
  %arrayidx177 = getelementptr inbounds double, double* %131, i32 %132
  store double %130, double* %arrayidx177, align 8
  br label %for.inc178

for.inc178:                                       ; preds = %for.body175
  %133 = load i32, i32* %index171, align 4
  %inc179 = add i32 %133, 1
  store i32 %inc179, i32* %index171, align 4
  br label %for.cond172

for.end180:                                       ; preds = %for.cond172
  %134 = load i32, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
  %sub181 = sub i32 %134, 1
  store i32 %sub181, i32* %j, align 4
  br label %for.cond182

for.cond182:                                      ; preds = %for.inc272, %for.end180
  %135 = load i32, i32* %j, align 4
  %cmp183 = icmp uge i32 %135, 2
  br i1 %cmp183, label %for.body185, label %for.end273

for.body185:                                      ; preds = %for.cond182
  %136 = load i32, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
  %137 = load i32, i32* %j, align 4
  %sub186 = sub i32 %136, %137
  %call187 = call i32* @seq_len(i32 0, i32 %sub186)
  store i32* %call187, i32** %ij, align 4
  %138 = load i32, i32* %j, align 4
  %sub188 = sub i32 %138, 1
  store i32 %sub188, i32* %I2_LENGTH, align 4
  %139 = load i32, i32* %I2_LENGTH, align 4
  %mul189 = mul i32 %139, 4
  %call190 = call noalias i8* @malloc(i32 %mul189)
  %140 = bitcast i8* %call190 to i32*
  store i32* %140, i32** %i2, align 4
  store i32 0, i32* %i, align 4
  br label %for.cond191

for.cond191:                                      ; preds = %for.inc200, %for.body185
  %141 = load i32, i32* %i, align 4
  %142 = load i32, i32* %I2_LENGTH, align 4
  %cmp192 = icmp ult i32 %141, %142
  br i1 %cmp192, label %for.body194, label %for.end202

for.body194:                                      ; preds = %for.cond191
  %143 = load i32, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
  %144 = load i32, i32* %j, align 4
  %sub195 = sub i32 %143, %144
  %add196 = add i32 %sub195, 2
  %145 = load i32, i32* %i, align 4
  %add197 = add i32 %add196, %145
  %sub198 = sub i32 %add197, 1
  %146 = load i32*, i32** %i2, align 4
  %147 = load i32, i32* %i, align 4
  %arrayidx199 = getelementptr inbounds i32, i32* %146, i32 %147
  store i32 %sub198, i32* %arrayidx199, align 4
  br label %for.inc200

for.inc200:                                       ; preds = %for.body194
  %148 = load i32, i32* %i, align 4
  %inc201 = add i32 %148, 1
  store i32 %inc201, i32* %i, align 4
  br label %for.cond191

for.end202:                                       ; preds = %for.cond191
  %149 = load i32, i32* %j, align 4
  %conv203 = uitofp i32 %149 to double
  %150 = load double*, double** %p, align 4
  %151 = load i32*, i32** %i2, align 4
  %arrayidx204 = getelementptr inbounds i32, i32* %151, i32 0
  %152 = load i32, i32* %arrayidx204, align 4
  %arrayidx205 = getelementptr inbounds double, double* %150, i32 %152
  %153 = load double, double* %arrayidx205, align 8
  %mul206 = fmul double %conv203, %153
  %div207 = fdiv double %mul206, 2.000000e+00
  store double %div207, double* %q1, align 8
  store i32 1, i32* %i208, align 4
  br label %for.cond209

for.cond209:                                      ; preds = %for.inc224, %for.end202
  %154 = load i32, i32* %i208, align 4
  %155 = load i32, i32* %I2_LENGTH, align 4
  %cmp210 = icmp ult i32 %154, %155
  br i1 %cmp210, label %for.body212, label %for.end226

for.body212:                                      ; preds = %for.cond209
  %156 = load i32, i32* %j, align 4
  %conv213 = uitofp i32 %156 to double
  %157 = load double*, double** %p, align 4
  %158 = load i32*, i32** %i2, align 4
  %159 = load i32, i32* %i208, align 4
  %arrayidx214 = getelementptr inbounds i32, i32* %158, i32 %159
  %160 = load i32, i32* %arrayidx214, align 4
  %arrayidx215 = getelementptr inbounds double, double* %157, i32 %160
  %161 = load double, double* %arrayidx215, align 8
  %mul216 = fmul double %conv213, %161
  %162 = load i32, i32* %i208, align 4
  %add217 = add i32 2, %162
  %conv218 = uitofp i32 %add217 to double
  %div219 = fdiv double %mul216, %conv218
  store double %div219, double* %TEMP_Q1, align 8
  %163 = load double, double* %TEMP_Q1, align 8
  %164 = load double, double* %q1, align 8
  %cmp220 = fcmp olt double %163, %164
  br i1 %cmp220, label %if.then222, label %if.end223

if.then222:                                       ; preds = %for.body212
  %165 = load double, double* %TEMP_Q1, align 8
  store double %165, double* %q1, align 8
  br label %if.end223

if.end223:                                        ; preds = %if.then222, %for.body212
  br label %for.inc224

for.inc224:                                       ; preds = %if.end223
  %166 = load i32, i32* %i208, align 4
  %inc225 = add i32 %166, 1
  store i32 %inc225, i32* %i208, align 4
  br label %for.cond209

for.end226:                                       ; preds = %for.cond209
  store i32 0, i32* %i227, align 4
  br label %for.cond228

for.cond228:                                      ; preds = %for.inc241, %for.end226
  %167 = load i32, i32* %i227, align 4
  %168 = load i32, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
  %169 = load i32, i32* %j, align 4
  %sub229 = sub i32 %168, %169
  %add230 = add i32 %sub229, 1
  %cmp231 = icmp ult i32 %167, %add230
  br i1 %cmp231, label %for.body233, label %for.end243

for.body233:                                      ; preds = %for.cond228
  %170 = load i32, i32* %j, align 4
  %conv234 = uitofp i32 %170 to double
  %171 = load double*, double** %p, align 4
  %172 = load i32*, i32** %ij, align 4
  %173 = load i32, i32* %i227, align 4
  %arrayidx235 = getelementptr inbounds i32, i32* %172, i32 %173
  %174 = load i32, i32* %arrayidx235, align 4
  %arrayidx236 = getelementptr inbounds double, double* %171, i32 %174
  %175 = load double, double* %arrayidx236, align 8
  %mul237 = fmul double %conv234, %175
  %176 = load double, double* %q1, align 8
  %call238 = call double @min2(double %mul237, double %176)
  %177 = load double*, double** %q, align 4
  %178 = load i32*, i32** %ij, align 4
  %179 = load i32, i32* %i227, align 4
  %arrayidx239 = getelementptr inbounds i32, i32* %178, i32 %179
  %180 = load i32, i32* %arrayidx239, align 4
  %arrayidx240 = getelementptr inbounds double, double* %177, i32 %180
  store double %call238, double* %arrayidx240, align 8
  br label %for.inc241

for.inc241:                                       ; preds = %for.body233
  %181 = load i32, i32* %i227, align 4
  %inc242 = add i32 %181, 1
  store i32 %inc242, i32* %i227, align 4
  br label %for.cond228

for.end243:                                       ; preds = %for.cond228
  %182 = load i32*, i32** %ij, align 4
  %183 = bitcast i32* %182 to i8*
  call void @free(i8* %183)
  store i32* null, i32** %ij, align 4
  store i32 0, i32* %i244, align 4
  br label %for.cond245

for.cond245:                                      ; preds = %for.inc253, %for.end243
  %184 = load i32, i32* %i244, align 4
  %185 = load i32, i32* %I2_LENGTH, align 4
  %cmp246 = icmp ult i32 %184, %185
  br i1 %cmp246, label %for.body248, label %for.end255

for.body248:                                      ; preds = %for.cond245
  %186 = load double*, double** %q, align 4
  %187 = load i32, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
  %188 = load i32, i32* %j, align 4
  %sub249 = sub i32 %187, %188
  %arrayidx250 = getelementptr inbounds double, double* %186, i32 %sub249
  %189 = load double, double* %arrayidx250, align 8
  %190 = load double*, double** %q, align 4
  %191 = load i32*, i32** %i2, align 4
  %192 = load i32, i32* %i244, align 4
  %arrayidx251 = getelementptr inbounds i32, i32* %191, i32 %192
  %193 = load i32, i32* %arrayidx251, align 4
  %arrayidx252 = getelementptr inbounds double, double* %190, i32 %193
  store double %189, double* %arrayidx252, align 8
  br label %for.inc253

for.inc253:                                       ; preds = %for.body248
  %194 = load i32, i32* %i244, align 4
  %inc254 = add i32 %194, 1
  store i32 %inc254, i32* %i244, align 4
  br label %for.cond245

for.end255:                                       ; preds = %for.cond245
  %195 = load i32*, i32** %i2, align 4
  %196 = bitcast i32* %195 to i8*
  call void @free(i8* %196)
  store i32* null, i32** %i2, align 4
  store i32 0, i32* %i256, align 4
  br label %for.cond257

for.cond257:                                      ; preds = %for.inc269, %for.end255
  %197 = load i32, i32* %i256, align 4
  %198 = load i32, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
  %cmp258 = icmp ult i32 %197, %198
  br i1 %cmp258, label %for.body260, label %for.end271

for.body260:                                      ; preds = %for.cond257
  %199 = load double*, double** %pa, align 4
  %200 = load i32, i32* %i256, align 4
  %arrayidx261 = getelementptr inbounds double, double* %199, i32 %200
  %201 = load double, double* %arrayidx261, align 8
  %202 = load double*, double** %q, align 4
  %203 = load i32, i32* %i256, align 4
  %arrayidx262 = getelementptr inbounds double, double* %202, i32 %203
  %204 = load double, double* %arrayidx262, align 8
  %cmp263 = fcmp olt double %201, %204
  br i1 %cmp263, label %if.then265, label %if.end268

if.then265:                                       ; preds = %for.body260
  %205 = load double*, double** %q, align 4
  %206 = load i32, i32* %i256, align 4
  %arrayidx266 = getelementptr inbounds double, double* %205, i32 %206
  %207 = load double, double* %arrayidx266, align 8
  %208 = load double*, double** %pa, align 4
  %209 = load i32, i32* %i256, align 4
  %arrayidx267 = getelementptr inbounds double, double* %208, i32 %209
  store double %207, double* %arrayidx267, align 8
  br label %if.end268

if.end268:                                        ; preds = %if.then265, %for.body260
  br label %for.inc269

for.inc269:                                       ; preds = %if.end268
  %210 = load i32, i32* %i256, align 4
  %inc270 = add i32 %210, 1
  store i32 %inc270, i32* %i256, align 4
  br label %for.cond257

for.end271:                                       ; preds = %for.cond257
  br label %for.inc272

for.inc272:                                       ; preds = %for.end271
  %211 = load i32, i32* %j, align 4
  %dec = add i32 %211, -1
  store i32 %dec, i32* %j, align 4
  br label %for.cond182

for.end273:                                       ; preds = %for.cond182
  %212 = load double*, double** %p, align 4
  %213 = bitcast double* %212 to i8*
  call void @free(i8* %213)
  store double* null, double** %p, align 4
  store i32 0, i32* %index274, align 4
  br label %for.cond275

for.cond275:                                      ; preds = %for.inc282, %for.end273
  %214 = load i32, i32* %index274, align 4
  %215 = load i32, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
  %cmp276 = icmp ult i32 %214, %215
  br i1 %cmp276, label %for.body278, label %for.end284

for.body278:                                      ; preds = %for.cond275
  %216 = load double*, double** %pa, align 4
  %217 = load i32*, i32** %ro136, align 4
  %218 = load i32, i32* %index274, align 4
  %arrayidx279 = getelementptr inbounds i32, i32* %217, i32 %218
  %219 = load i32, i32* %arrayidx279, align 4
  %arrayidx280 = getelementptr inbounds double, double* %216, i32 %219
  %220 = load double, double* %arrayidx280, align 8
  %221 = load double*, double** %q, align 4
  %222 = load i32, i32* %index274, align 4
  %arrayidx281 = getelementptr inbounds double, double* %221, i32 %222
  store double %220, double* %arrayidx281, align 8
  br label %for.inc282

for.inc282:                                       ; preds = %for.body278
  %223 = load i32, i32* %index274, align 4
  %inc283 = add i32 %223, 1
  store i32 %inc283, i32* %index274, align 4
  br label %for.cond275

for.end284:                                       ; preds = %for.cond275
  %224 = load i32*, i32** %ro136, align 4
  %225 = bitcast i32* %224 to i8*
  call void @free(i8* %225)
  store i32* null, i32** %ro136, align 4
  %226 = load double*, double** %pa, align 4
  %227 = bitcast double* %226 to i8*
  call void @free(i8* %227)
  store double* null, double** %pa, align 4
  %228 = load double*, double** %q, align 4
  store double* %228, double** %retval, align 4
  br label %return

if.end285:                                        ; preds = %if.else109
  br label %if.end286

if.end286:                                        ; preds = %if.end285
  br label %if.end287

if.end287:                                        ; preds = %if.end286
  %229 = load double*, double** %PVALUES.addr, align 4
  %230 = load i32, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
  %call289 = call i32* @order(double* %229, i32 %230, i1 zeroext true)
  store i32* %call289, i32** %o288, align 4
  %231 = load i32*, i32** %o288, align 4
  %cmp290 = icmp eq i32* %231, null
  br i1 %cmp290, label %if.then292, label %if.end294

if.then292:                                       ; preds = %if.end287
  %call293 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([33 x i8], [33 x i8]* @.str.3, i32 0, i32 0), i8* getelementptr inbounds ([23 x i8], [23 x i8]* @.str.1, i32 0, i32 0), i32 398)
  call void @perror(i8* getelementptr inbounds ([1 x i8], [1 x i8]* @.str.2, i32 0, i32 0))
  call void @exit(i32 1) #5
  unreachable

if.end294:                                        ; preds = %if.end287
  %232 = load i32*, i32** %o288, align 4
  %233 = load i32, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
  %call295 = call double* @uint2double(i32* %232, i32 %233)
  store double* %call295, double** %o_double, align 4
  store i32 0, i32* %index296, align 4
  br label %for.cond297

for.cond297:                                      ; preds = %for.inc312, %if.end294
  %234 = load i32, i32* %index296, align 4
  %235 = load i32, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
  %cmp298 = icmp ult i32 %234, %235
  br i1 %cmp298, label %for.body300, label %for.end314

for.body300:                                      ; preds = %for.cond297
  %236 = load double*, double** %PVALUES.addr, align 4
  %237 = load i32, i32* %index296, align 4
  %arrayidx301 = getelementptr inbounds double, double* %236, i32 %237
  %238 = load double, double* %arrayidx301, align 8
  %cmp302 = fcmp olt double %238, 0.000000e+00
  br i1 %cmp302, label %if.then307, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %for.body300
  %239 = load double*, double** %PVALUES.addr, align 4
  %240 = load i32, i32* %index296, align 4
  %arrayidx304 = getelementptr inbounds double, double* %239, i32 %240
  %241 = load double, double* %arrayidx304, align 8
  %cmp305 = fcmp ogt double %241, 1.000000e+00
  br i1 %cmp305, label %if.then307, label %if.end311

if.then307:                                       ; preds = %lor.lhs.false, %for.body300
  %242 = load i32, i32* %index296, align 4
  %243 = load double*, double** %PVALUES.addr, align 4
  %244 = load i32, i32* %index296, align 4
  %arrayidx308 = getelementptr inbounds double, double* %243, i32 %244
  %245 = load double, double* %arrayidx308, align 8
  %call309 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([54 x i8], [54 x i8]* @.str.24, i32 0, i32 0), i32 %242, double %245)
  %call310 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([20 x i8], [20 x i8]* @.str.25, i32 0, i32 0), i8* getelementptr inbounds ([23 x i8], [23 x i8]* @.str.1, i32 0, i32 0), i32 406)
  call void @exit(i32 1) #5
  unreachable

if.end311:                                        ; preds = %lor.lhs.false
  br label %for.inc312

for.inc312:                                       ; preds = %if.end311
  %246 = load i32, i32* %index296, align 4
  %inc313 = add i32 %246, 1
  store i32 %inc313, i32* %index296, align 4
  br label %for.cond297

for.end314:                                       ; preds = %for.cond297
  %247 = load double*, double** %o_double, align 4
  %248 = load i32, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
  %call316 = call i32* @order(double* %247, i32 %248, i1 zeroext false)
  store i32* %call316, i32** %ro315, align 4
  %249 = load i32*, i32** %ro315, align 4
  %cmp317 = icmp eq i32* %249, null
  br i1 %cmp317, label %if.then319, label %if.end321

if.then319:                                       ; preds = %for.end314
  %call320 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([33 x i8], [33 x i8]* @.str.3, i32 0, i32 0), i8* getelementptr inbounds ([23 x i8], [23 x i8]* @.str.1, i32 0, i32 0), i32 413)
  call void @perror(i8* getelementptr inbounds ([1 x i8], [1 x i8]* @.str.2, i32 0, i32 0))
  call void @exit(i32 1) #5
  unreachable

if.end321:                                        ; preds = %for.end314
  %250 = load double*, double** %o_double, align 4
  %251 = bitcast double* %250 to i8*
  call void @free(i8* %251)
  store double* null, double** %o_double, align 4
  %252 = load i32, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
  %mul322 = mul i32 8, %252
  %call323 = call noalias i8* @malloc(i32 %mul322)
  %253 = bitcast i8* %call323 to double*
  store double* %253, double** %cummin_input, align 4
  %254 = load i16, i16* %TYPE, align 2
  %conv324 = sext i16 %254 to i32
  %cmp325 = icmp eq i32 %conv324, 0
  br i1 %cmp325, label %if.then327, label %if.else344

if.then327:                                       ; preds = %if.end321
  store i32 0, i32* %index328, align 4
  br label %for.cond329

for.cond329:                                      ; preds = %for.inc341, %if.then327
  %255 = load i32, i32* %index328, align 4
  %256 = load i32, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
  %cmp330 = icmp ult i32 %255, %256
  br i1 %cmp330, label %for.body332, label %for.end343

for.body332:                                      ; preds = %for.cond329
  %257 = load i32, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
  %conv333 = uitofp i32 %257 to double
  %258 = load i32, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
  %259 = load i32, i32* %index328, align 4
  %sub334 = sub i32 %258, %259
  %conv335 = uitofp i32 %sub334 to double
  %div336 = fdiv double %conv333, %conv335
  store double %div336, double* %NI, align 8
  %260 = load double, double* %NI, align 8
  %261 = load double*, double** %PVALUES.addr, align 4
  %262 = load i32*, i32** %o288, align 4
  %263 = load i32, i32* %index328, align 4
  %arrayidx337 = getelementptr inbounds i32, i32* %262, i32 %263
  %264 = load i32, i32* %arrayidx337, align 4
  %arrayidx338 = getelementptr inbounds double, double* %261, i32 %264
  %265 = load double, double* %arrayidx338, align 8
  %mul339 = fmul double %260, %265
  %266 = load double*, double** %cummin_input, align 4
  %267 = load i32, i32* %index328, align 4
  %arrayidx340 = getelementptr inbounds double, double* %266, i32 %267
  store double %mul339, double* %arrayidx340, align 8
  br label %for.inc341

for.inc341:                                       ; preds = %for.body332
  %268 = load i32, i32* %index328, align 4
  %inc342 = add i32 %268, 1
  store i32 %inc342, i32* %index328, align 4
  br label %for.cond329

for.end343:                                       ; preds = %for.cond329
  br label %if.end401

if.else344:                                       ; preds = %if.end321
  %269 = load i16, i16* %TYPE, align 2
  %conv345 = sext i16 %269 to i32
  %cmp346 = icmp eq i32 %conv345, 1
  br i1 %cmp346, label %if.then348, label %if.else380

if.then348:                                       ; preds = %if.else344
  store double 1.000000e+00, double* %q349, align 8
  store i32 2, i32* %index350, align 4
  br label %for.cond351

for.cond351:                                      ; preds = %for.inc359, %if.then348
  %270 = load i32, i32* %index350, align 4
  %271 = load i32, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
  %add352 = add i32 1, %271
  %cmp353 = icmp ult i32 %270, %add352
  br i1 %cmp353, label %for.body355, label %for.end361

for.body355:                                      ; preds = %for.cond351
  %272 = load i32, i32* %index350, align 4
  %conv356 = uitofp i32 %272 to double
  %div357 = fdiv double 1.000000e+00, %conv356
  %273 = load double, double* %q349, align 8
  %add358 = fadd double %273, %div357
  store double %add358, double* %q349, align 8
  br label %for.inc359

for.inc359:                                       ; preds = %for.body355
  %274 = load i32, i32* %index350, align 4
  %inc360 = add i32 %274, 1
  store i32 %inc360, i32* %index350, align 4
  br label %for.cond351

for.end361:                                       ; preds = %for.cond351
  store i32 0, i32* %index362, align 4
  br label %for.cond363

for.cond363:                                      ; preds = %for.inc377, %for.end361
  %275 = load i32, i32* %index362, align 4
  %276 = load i32, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
  %cmp364 = icmp ult i32 %275, %276
  br i1 %cmp364, label %for.body366, label %for.end379

for.body366:                                      ; preds = %for.cond363
  %277 = load i32, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
  %conv368 = uitofp i32 %277 to double
  %278 = load i32, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
  %279 = load i32, i32* %index362, align 4
  %sub369 = sub i32 %278, %279
  %conv370 = uitofp i32 %sub369 to double
  %div371 = fdiv double %conv368, %conv370
  store double %div371, double* %NI367, align 8
  %280 = load double, double* %q349, align 8
  %281 = load double, double* %NI367, align 8
  %mul372 = fmul double %280, %281
  %282 = load double*, double** %PVALUES.addr, align 4
  %283 = load i32*, i32** %o288, align 4
  %284 = load i32, i32* %index362, align 4
  %arrayidx373 = getelementptr inbounds i32, i32* %283, i32 %284
  %285 = load i32, i32* %arrayidx373, align 4
  %arrayidx374 = getelementptr inbounds double, double* %282, i32 %285
  %286 = load double, double* %arrayidx374, align 8
  %mul375 = fmul double %mul372, %286
  %287 = load double*, double** %cummin_input, align 4
  %288 = load i32, i32* %index362, align 4
  %arrayidx376 = getelementptr inbounds double, double* %287, i32 %288
  store double %mul375, double* %arrayidx376, align 8
  br label %for.inc377

for.inc377:                                       ; preds = %for.body366
  %289 = load i32, i32* %index362, align 4
  %inc378 = add i32 %289, 1
  store i32 %inc378, i32* %index362, align 4
  br label %for.cond363

for.end379:                                       ; preds = %for.cond363
  br label %if.end400

if.else380:                                       ; preds = %if.else344
  %290 = load i16, i16* %TYPE, align 2
  %conv381 = sext i16 %290 to i32
  %cmp382 = icmp eq i32 %conv381, 3
  br i1 %cmp382, label %if.then384, label %if.end399

if.then384:                                       ; preds = %if.else380
  store i32 0, i32* %index385, align 4
  br label %for.cond386

for.cond386:                                      ; preds = %for.inc396, %if.then384
  %291 = load i32, i32* %index385, align 4
  %292 = load i32, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
  %cmp387 = icmp ult i32 %291, %292
  br i1 %cmp387, label %for.body389, label %for.end398

for.body389:                                      ; preds = %for.cond386
  %293 = load i32, i32* %index385, align 4
  %add390 = add i32 %293, 1
  %conv391 = uitofp i32 %add390 to double
  %294 = load double*, double** %PVALUES.addr, align 4
  %295 = load i32*, i32** %o288, align 4
  %296 = load i32, i32* %index385, align 4
  %arrayidx392 = getelementptr inbounds i32, i32* %295, i32 %296
  %297 = load i32, i32* %arrayidx392, align 4
  %arrayidx393 = getelementptr inbounds double, double* %294, i32 %297
  %298 = load double, double* %arrayidx393, align 8
  %mul394 = fmul double %conv391, %298
  %299 = load double*, double** %cummin_input, align 4
  %300 = load i32, i32* %index385, align 4
  %arrayidx395 = getelementptr inbounds double, double* %299, i32 %300
  store double %mul394, double* %arrayidx395, align 8
  br label %for.inc396

for.inc396:                                       ; preds = %for.body389
  %301 = load i32, i32* %index385, align 4
  %inc397 = add i32 %301, 1
  store i32 %inc397, i32* %index385, align 4
  br label %for.cond386

for.end398:                                       ; preds = %for.cond386
  br label %if.end399

if.end399:                                        ; preds = %for.end398, %if.else380
  br label %if.end400

if.end400:                                        ; preds = %if.end399, %for.end379
  br label %if.end401

if.end401:                                        ; preds = %if.end400, %for.end343
  %302 = load i32*, i32** %o288, align 4
  %303 = bitcast i32* %302 to i8*
  call void @free(i8* %303)
  store i32* null, i32** %o288, align 4
  store double* null, double** %cummin_array, align 4
  %304 = load double*, double** %cummin_input, align 4
  %305 = load i32, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
  %call402 = call double* @cummin(double* %304, i32 %305)
  store double* %call402, double** %cummin_array, align 4
  %306 = load double*, double** %cummin_input, align 4
  %307 = bitcast double* %306 to i8*
  call void @free(i8* %307)
  store double* null, double** %cummin_input, align 4
  %308 = load double*, double** %cummin_array, align 4
  %309 = load i32, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
  %call404 = call double* @pminx(double* %308, i32 %309, double 1.000000e+00)
  store double* %call404, double** %pmin403, align 4
  %310 = load double*, double** %cummin_array, align 4
  %311 = bitcast double* %310 to i8*
  call void @free(i8* %311)
  store double* null, double** %cummin_array, align 4
  %312 = load i32, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
  %mul405 = mul i32 %312, 8
  %call406 = call noalias i8* @malloc(i32 %mul405)
  %313 = bitcast i8* %call406 to double*
  store double* %313, double** %q_array, align 4
  store i32 0, i32* %index407, align 4
  br label %for.cond408

for.cond408:                                      ; preds = %for.inc415, %if.end401
  %314 = load i32, i32* %index407, align 4
  %315 = load i32, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
  %cmp409 = icmp ult i32 %314, %315
  br i1 %cmp409, label %for.body411, label %for.end417

for.body411:                                      ; preds = %for.cond408
  %316 = load double*, double** %pmin403, align 4
  %317 = load i32*, i32** %ro315, align 4
  %318 = load i32, i32* %index407, align 4
  %arrayidx412 = getelementptr inbounds i32, i32* %317, i32 %318
  %319 = load i32, i32* %arrayidx412, align 4
  %arrayidx413 = getelementptr inbounds double, double* %316, i32 %319
  %320 = load double, double* %arrayidx413, align 8
  %321 = load double*, double** %q_array, align 4
  %322 = load i32, i32* %index407, align 4
  %arrayidx414 = getelementptr inbounds double, double* %321, i32 %322
  store double %320, double* %arrayidx414, align 8
  br label %for.inc415

for.inc415:                                       ; preds = %for.body411
  %323 = load i32, i32* %index407, align 4
  %inc416 = add i32 %323, 1
  store i32 %inc416, i32* %index407, align 4
  br label %for.cond408

for.end417:                                       ; preds = %for.cond408
  %324 = load i32*, i32** %ro315, align 4
  %325 = bitcast i32* %324 to i8*
  call void @free(i8* %325)
  store i32* null, i32** %ro315, align 4
  %326 = load double*, double** %pmin403, align 4
  %327 = bitcast double* %326 to i8*
  call void @free(i8* %327)
  store double* null, double** %pmin403, align 4
  %328 = load double*, double** %q_array, align 4
  store double* %328, double** %retval, align 4
  br label %return

return:                                           ; preds = %for.end417, %for.end284, %for.end108, %for.end
  %329 = load double*, double** %retval, align 4
  ret double* %329
}

declare i32 @strcasecmp(i8* %0, i8* %1) #1

; Function Attrs: noinline nounwind optnone
define hidden i32 @main() #0 {
entry:
  %retval = alloca i32, align 4
  %PVALUES = alloca [50 x double], align 16
  %CORRECT_ANSWERS = alloca [6 x [50 x double]], align 16
  %TYPES = alloca [6 x i8*], align 16
  %type = alloca i16, align 2
  %q = alloca double*, align 4
  %error = alloca double, align 8
  %i = alloca i32, align 4
  %this_error = alloca double, align 8
  store i32 0, i32* %retval, align 4
  %0 = bitcast [50 x double]* %PVALUES to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 16 %0, i8* align 16 bitcast ([50 x double]* @__const.main.PVALUES to i8*), i32 400, i1 false)
  %1 = bitcast [6 x [50 x double]]* %CORRECT_ANSWERS to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 16 %1, i8* align 16 bitcast ([6 x [50 x double]]* @__const.main.CORRECT_ANSWERS to i8*), i32 2400, i1 false)
  %2 = bitcast [6 x i8*]* %TYPES to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 16 %2, i8* align 16 bitcast ([6 x i8*]* @__const.main.TYPES to i8*), i32 24, i1 false)
  store i16 0, i16* %type, align 2
  br label %for.cond

for.cond:                                         ; preds = %for.inc19, %entry
  %3 = load i16, i16* %type, align 2
  %conv = zext i16 %3 to i32
  %cmp = icmp sle i32 %conv, 5
  br i1 %cmp, label %for.body, label %for.end21

for.body:                                         ; preds = %for.cond
  %arraydecay = getelementptr inbounds [50 x double], [50 x double]* %PVALUES, i32 0, i32 0
  %4 = load i16, i16* %type, align 2
  %idxprom = zext i16 %4 to i32
  %arrayidx = getelementptr inbounds [6 x i8*], [6 x i8*]* %TYPES, i32 0, i32 %idxprom
  %5 = load i8*, i8** %arrayidx, align 4
  %call = call double* @p_adjust(double* %arraydecay, i32 50, i8* %5)
  store double* %call, double** %q, align 4
  %6 = load double*, double** %q, align 4
  %arrayidx2 = getelementptr inbounds double, double* %6, i32 0
  %7 = load double, double* %arrayidx2, align 8
  %8 = load i16, i16* %type, align 2
  %idxprom3 = zext i16 %8 to i32
  %arrayidx4 = getelementptr inbounds [6 x [50 x double]], [6 x [50 x double]]* %CORRECT_ANSWERS, i32 0, i32 %idxprom3
  %arrayidx5 = getelementptr inbounds [50 x double], [50 x double]* %arrayidx4, i32 0, i32 0
  %9 = load double, double* %arrayidx5, align 16
  %sub = fsub double %7, %9
  %10 = call double @llvm.fabs.f64(double %sub)
  store double %10, double* %error, align 8
  store i32 1, i32* %i, align 4
  br label %for.cond6

for.cond6:                                        ; preds = %for.inc, %for.body
  %11 = load i32, i32* %i, align 4
  %cmp7 = icmp ult i32 %11, 50
  br i1 %cmp7, label %for.body9, label %for.end

for.body9:                                        ; preds = %for.cond6
  %12 = load double*, double** %q, align 4
  %13 = load i32, i32* %i, align 4
  %arrayidx10 = getelementptr inbounds double, double* %12, i32 %13
  %14 = load double, double* %arrayidx10, align 8
  %15 = load i16, i16* %type, align 2
  %idxprom11 = zext i16 %15 to i32
  %arrayidx12 = getelementptr inbounds [6 x [50 x double]], [6 x [50 x double]]* %CORRECT_ANSWERS, i32 0, i32 %idxprom11
  %16 = load i32, i32* %i, align 4
  %arrayidx13 = getelementptr inbounds [50 x double], [50 x double]* %arrayidx12, i32 0, i32 %16
  %17 = load double, double* %arrayidx13, align 8
  %sub14 = fsub double %14, %17
  %18 = call double @llvm.fabs.f64(double %sub14)
  store double %18, double* %this_error, align 8
  %19 = load double, double* %this_error, align 8
  %20 = load double, double* %error, align 8
  %add = fadd double %20, %19
  store double %add, double* %error, align 8
  br label %for.inc

for.inc:                                          ; preds = %for.body9
  %21 = load i32, i32* %i, align 4
  %inc = add i32 %21, 1
  store i32 %inc, i32* %i, align 4
  br label %for.cond6

for.end:                                          ; preds = %for.cond6
  %22 = load double*, double** %q, align 4
  call void @double_say(double* %22, i32 50)
  %23 = load double*, double** %q, align 4
  %24 = bitcast double* %23 to i8*
  call void @free(i8* %24)
  store double* null, double** %q, align 4
  %25 = load i16, i16* %type, align 2
  %conv15 = zext i16 %25 to i32
  %26 = load i16, i16* %type, align 2
  %idxprom16 = zext i16 %26 to i32
  %arrayidx17 = getelementptr inbounds [6 x i8*], [6 x i8*]* %TYPES, i32 0, i32 %idxprom16
  %27 = load i8*, i8** %arrayidx17, align 4
  %28 = load double, double* %error, align 8
  %call18 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([44 x i8], [44 x i8]* @.str.28, i32 0, i32 0), i32 %conv15, i8* %27, double %28)
  br label %for.inc19

for.inc19:                                        ; preds = %for.end
  %29 = load i16, i16* %type, align 2
  %inc20 = add i16 %29, 1
  store i16 %inc20, i16* %type, align 2
  br label %for.cond

for.end21:                                        ; preds = %for.cond
  ret i32 0
}

; Function Attrs: argmemonly nounwind willreturn
declare void @llvm.memcpy.p0i8.p0i8.i32(i8* noalias nocapture writeonly %0, i8* noalias nocapture readonly %1, i32 %2, i1 immarg %3) #3

; Function Attrs: nounwind readnone speculatable willreturn
declare double @llvm.fabs.f64(double %0) #4

attributes #0 = { noinline nounwind optnone "correctly-rounded-divide-sqrt-fp-math"="false" "disable-tail-calls"="false" "frame-pointer"="none" "less-precise-fpmad"="false" "min-legal-vector-width"="0" "no-infs-fp-math"="false" "no-jump-tables"="false" "no-nans-fp-math"="false" "no-signed-zeros-fp-math"="false" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="generic" "unsafe-fp-math"="false" "use-soft-float"="false" }
attributes #1 = { "correctly-rounded-divide-sqrt-fp-math"="false" "disable-tail-calls"="false" "frame-pointer"="none" "less-precise-fpmad"="false" "no-infs-fp-math"="false" "no-nans-fp-math"="false" "no-signed-zeros-fp-math"="false" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="generic" "unsafe-fp-math"="false" "use-soft-float"="false" }
attributes #2 = { noreturn "correctly-rounded-divide-sqrt-fp-math"="false" "disable-tail-calls"="false" "frame-pointer"="none" "less-precise-fpmad"="false" "no-infs-fp-math"="false" "no-nans-fp-math"="false" "no-signed-zeros-fp-math"="false" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="generic" "unsafe-fp-math"="false" "use-soft-float"="false" }
attributes #3 = { argmemonly nounwind willreturn }
attributes #4 = { nounwind readnone speculatable willreturn }
attributes #5 = { noreturn }

!llvm.module.flags = !{!0}
!llvm.ident = !{!1}

!0 = !{i32 1, !"wchar_size", i32 4}
!1 = !{!"clang version 11.0.0 (https://github.com/Jacarte/llvm-project.git 0f6dea67136cc1e0b3d200eb2bb165628970c44b)"}

; extracted candidates

; *****
; For LLVM instruction:
;  %2 = load i32, i32* %i, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %3 = load i32, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %cmp = icmp ult i32 %2, %3
; Looking for a replacement for:
%0:i32 = var
%1:i32 = var
%2:i1 = ult %0, %1
infer %2

; *****
; For LLVM instruction:
;  %5 = load i32, i32* %i, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %7 = load i32, i32* %i, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %add = add i32 %7, 1
; Looking for a replacement for:
%0:i32 = var
%1:i32 = add 1:i32, %0
infer %1

; *****
; For LLVM instruction:
;  %rem = urem i32 %add, 5
; Looking for a replacement for:
%0:i32 = var
%1:i32 = add 1:i32, %0
%2:i32 = urem %1, 5:i32
infer %2

; *****
; For LLVM instruction:
;  %cmp3 = icmp eq i32 %rem, 0
; Looking for a replacement for:
%0:i32 = var
%1:i32 = add 1:i32, %0
%2:i32 = urem %1, 5:i32
%3:i1 = eq 0:i32, %2
infer %3

; *****
; For LLVM instruction:
;  %8 = load i32, i32* %i, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %add4 = add i32 %8, 1
; Looking for a replacement for:
%0:i32 = var
%1:i32 = add 1:i32, %0
infer %1

; *****
; For LLVM instruction:
;  %9 = load i32, i32* %i, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %inc = add i32 %9, 1
; Looking for a replacement for:
%0:i32 = var
%1:i32 = add 1:i32, %0
infer %1
got 3 candidates from LHS

-------------------------------------------------
%0:i32 = var
%1:i32 = add 1:i32, %0
%2:i32 = urem %1, 5:i32
infer %2


--------------------------------
guess 0

%0:i32 = var ; reservedconst_1

Cost = 0
first query is SAT, returning the model:
reservedconst_1: 1
0 th attempt: second query is SAT-- constant doesn't work
first query is SAT, returning the model:
reservedconst_1: 3
1 th attempt: second query is SAT-- constant doesn't work
first query is UNSAT-- no more guesses

--------------------------------
guess 1

%0:i32 = var

Cost = 0
second query is SAT-- constant doesn't work

--------------------------------
guess 2

%0:i32 = var
%1:i32 = add 1:i32, %0

Cost = 1
second query is SAT-- constant doesn't work
Dataflow Pruned 0/0
There are 3 Guesses
There are 0 RHSs before deduplication
There are 0 RHSs after deduplication
got 4 candidates from LHS

-------------------------------------------------
%0:i32 = var
%1:i32 = add 1:i32, %0
%2:i32 = urem %1, 5:i32
%3:i1 = eq 0:i32, %2
infer %3


--------------------------------
guess 0

%0:i1 = var ; reservedconst_1

Cost = 0
first query is SAT, returning the model:
reservedconst_1: 0
0 th attempt: second query is SAT-- constant doesn't work
first query is SAT, returning the model:
reservedconst_1: -1
1 th attempt: second query is SAT-- constant doesn't work
first query is UNSAT-- no more guesses
Dataflow Pruned 0/0
There are 1 Guesses
There are 0 RHSs before deduplication
There are 0 RHSs after deduplication
#########################################################
; exiting Souper's runOnFunction() for double_say()

; entering Souper's runOnFunction() for uint2double()

; ModuleID = './P-value_correction.c.bc'
source_filename = "./P-value_correction.c"
target datalayout = "e-m:e-p:32:32-i64:64-n32:64-S128"
target triple = "wasm32-unknown-wasi"

@.str = private unnamed_addr constant [29 x i8] c"malloc failed at %s line %u\0A\00", align 1
@.str.1 = private unnamed_addr constant [23 x i8] c"./P-value_correction.c\00", align 1
@.str.2 = private unnamed_addr constant [1 x i8] zeroinitializer, align 1
@base_arr = hidden global double* null, align 4
@.str.3 = private unnamed_addr constant [33 x i8] c"failed to malloc at %s line %u.\0A\00", align 1
@.str.4 = private unnamed_addr constant [48 x i8] c"cummin function requires at least one element.\0A\00", align 1
@.str.5 = private unnamed_addr constant [22 x i8] c"Failed at %s line %u\0A\00", align 1
@.str.6 = private unnamed_addr constant [41 x i8] c"function requires at least one element.\0A\00", align 1
@.str.7 = private unnamed_addr constant [37 x i8] c"pmin requires at least one element.\0A\00", align 1
@.str.8 = private unnamed_addr constant [7 x i8] c"[1] %e\00", align 1
@.str.9 = private unnamed_addr constant [7 x i8] c" %.10f\00", align 1
@.str.10 = private unnamed_addr constant [6 x i8] c"\0A[%u]\00", align 1
@.str.11 = private unnamed_addr constant [2 x i8] c"\0A\00", align 1
@.str.12 = private unnamed_addr constant [34 x i8] c"Failure to malloc at %s line %u.\0A\00", align 1
@.str.13 = private unnamed_addr constant [41 x i8] c"p_adjust requires at least one element.\0A\00", align 1
@.str.14 = private unnamed_addr constant [3 x i8] c"BH\00", align 1
@.str.15 = private unnamed_addr constant [4 x i8] c"fdr\00", align 1
@.str.16 = private unnamed_addr constant [3 x i8] c"by\00", align 1
@.str.17 = private unnamed_addr constant [11 x i8] c"Bonferroni\00", align 1
@.str.18 = private unnamed_addr constant [9 x i8] c"hochberg\00", align 1
@.str.19 = private unnamed_addr constant [5 x i8] c"holm\00", align 1
@.str.20 = private unnamed_addr constant [7 x i8] c"hommel\00", align 1
@.str.21 = private unnamed_addr constant [44 x i8] c"%s doesn't match any accepted FDR methods.\0A\00", align 1
@.str.22 = private unnamed_addr constant [42 x i8] c"%g is outside of the interval I planned.\0A\00", align 1
@.str.23 = private unnamed_addr constant [23 x i8] c"Failure at %s line %u\0A\00", align 1
@.str.24 = private unnamed_addr constant [54 x i8] c"array[%u] = %lf, which is outside the interval [0,1]\0A\00", align 1
@.str.25 = private unnamed_addr constant [20 x i8] c"died at %s line %u\0A\00", align 1
@__const.main.PVALUES = private unnamed_addr constant [50 x double] [double 0x3FDD04160F35FDE9, double 0x3FE758E721E2A8D7, double 0x3FB96FAC8B38D8BA, double 0x3FB73E71D5B04B37, double 0x3FC710AB48EE865B, double 0x3FEC01D953C3CC73, double 0x3FD2B3C4BE0A922A, double 0x3FED2B5A568DAB4F, double 0x3FDBE08D73F16964, double 0x3FE10A218C41C242, double 0x3FDF8810DB1996AA, double 0x3FE291CCB11E1A9D, double 0x3FD64E8C550D788F, double 7.883130e-01, double 0x3FD177B2BF048D2D, double 0x3FEB3543434BAF2B, double 0x3FDB50EAD41ED0A6, double 0x3FE49D4AFF01D33F, double 0x3FD364C9AE345B51, double 0x3FA99BA35F15394D, double 3.194810e-01, double 0x3FE941E405CE761A, double 0x3FEFF94F77369843, double 0x3FC65847BFB23217, double 0x3FECEB8879B6A543, double 0x3FBEAF00332BA677, double 0x3FD96207C7749E38, double 0x3F8CC02620502C93, double 0x3FE773A5B45A0F40, double 0x3FB1642C24762C01, double 4.040730e-03, double 0x3F33E11D79A90777, double 0x3F870B02BD749528, double 0x3F98521BD6A0353F, double 0x3F4310F26148FFAA, double 0x3F3427CD76006778, double 0x3F80E60AFB1F8A4E, double 0x3F5639B74A9E4DA2, double 0x3F8BDDF74195769F, double 0x3F38ABEE3BFA8581, double 0x3EF2E2E96B5466FE, double 0x3E90CE9F65B58A88, double 0x3FA0F2D097879B95, double 0x3F834EE7216A6684, double 0x3F4CCE8DBB40BD9D, double 0x3F2C8B969590F2ED, double 0x3F4FC31F7F1541AD, double 6.610250e-05, double 0x3F9DB44EA6AC26BA, double 5.735490e-03], align 16
@__const.main.CORRECT_ANSWERS = private unnamed_addr constant [6 x [50 x double]] [[50 x double] [double 0x3FE39AFA2199ADBC, double 8.521710e-01, double 0x3FC96FAC6045BAF5, double 0x3FC83660E51D25AB, double 0x3FD498068702BE20, double 0x3FEDC3BF727136A4, double 4.870370e-01, double 0x3FEDC3BF727136A4, double 0x3FE35BF08BEEB62C, double 0x3FE5D879DEE92F03, double 0x3FE4BE91D656B94A, double 0x3FE7363FC28DAEAA, double 0x3FE0E62C4F13638A, double 0x3FEC1052C8FAB035, double 0x3FDE1DD2E43E029A, double 0x3FED92EFFC7CBDC1, double 0x3FE35BF08BEEB62C, double 0x3FE923B90CFC67C5, double 0x3FDF47B8FC357024, double 0x3FBD1996A9FB10AD, double 0x3FDFF2B6D6C14255, double 0x3FEC1052C8FAB035, double 0x3FEFF94F77369843, double 0x3FD498068702BE20, double 0x3FEDC3BF727136A4, double 0x3FCD80E2E96EC403, double 0x3FE2A9F6A93F290B, double 0x3FA3F736D8AF2E2B, double 8.521710e-01, double 0x3FC2E751B350FAC4, double 0x3F913D8E55EE9F05, double 0x3F64FECB88BB3633, double 0x3FA2009A03CCBE34, double 0x3FB0001FB57CF9FC, double 0x3F6DCA7ADA5E274A, double 0x3F64FECB88BB3633, double 0x3F9E2D13B467D120, double 0x3F7941963399C6A1, double 0x3FA3F736D8AF2E2B, double 0x3F6607390CEF853C, double 0x3F3D828C80BA213A, double 0x3EEA42D90EEBA875, double 0x3FB42D4181AA8F8B, double 0x3FA01715F12E0018, double 0x3F73D9F3AF6D490C, double 0x3F64FECB88BB3633, double 0x3F73D9F3AF6D490C, double 0x3F520CE5F51A7C61, double 0x3FB290B112B20952, double 0x3F9696C95AA76B69], [50 x double] [double 1.000000e+00, double 1.000000e+00, double 0x3FEC9C56E33BA41B, double 0x3FEB3BF21E95ED3D, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 0x3FE05DA74553C727, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 0x3FC675198790829A, double 1.000000e+00, double 0x3FE54345648E1F12, double 0x3FB3645F501CA2F9, double 0x3F879D934E50F0DE, double 0x3FC43FC3646E3EA2, double 0x3FD1FF539D36064C, double 0x3F90C123206B855F, double 0x3F879D934E50F0DE, double 0x3FC0F8967F32E606, double 0x3F9C6880470D2FBE, double 0x3FC675198790829A, double 0x3F88C70105E47082, double 2.025930e-03, double 0x3F0D89DE4FA8F818, double 0x3FD6B1E2D11B1027, double 0x3FC219271872BD8D, double 0x3F96542FAD16CEF9, double 0x3F879D934E50F0DE, double 0x3F96542FAD16CEF9, double 0x3F744D9816EB319A, double 0x3FD4E1D5728DBC16, double 0x3FB9687C40426555], [50 x double] [double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 0x3FE6761DC93EA2D3, double 1.000000e+00, double 1.000000e+00, double 0x3FC9DC55000C953A, double 0x3F8F0FBD624BA499, double 0x3FE2009A24031487, double 1.000000e+00, double 0x3F9DCA7AB8020F7A, double 0x3F8F7E310860A1AB, double 0x3FDA677128614819, double 6.782670e-02, double 6.803480e-01, double 0x3F9346521EDBB84D, double 0x3F4D828CB7B3E0EE, double 0x3EEA42D90EEBA875, double 1.000000e+00, double 4.713920e-01, double 0x3FA6815EE53DB1E7, double 0x3F864D0CF90CC6B8, double 0x3FA8D0709B489B4F, double 0x3F6B1359791819D2, double 1.000000e+00, double 0x3FD25A836EB4E981], [50 x double] [double 0x3FEFF94F77369843, double 0x3FEFF94F77369843, double 0x3FEFF94F77369843, double 0x3FEFF94F77369843, double 0x3FEFF94F77369843, double 0x3FEFF94F77369843, double 0x3FEFF94F77369843, double 0x3FEFF94F77369843, double 0x3FEFF94F77369843, double 0x3FEFF94F77369843, double 0x3FEFF94F77369843, double 0x3FEFF94F77369843, double 0x3FEFF94F77369843, double 0x3FEFF94F77369843, double 0x3FEFF94F77369843, double 0x3FEFF94F77369843, double 0x3FEFF94F77369843, double 0x3FEFF94F77369843, double 0x3FEFF94F77369843, double 0x3FEFF94F77369843, double 0x3FEFF94F77369843, double 0x3FEFF94F77369843, double 0x3FEFF94F77369843, double 0x3FEFF94F77369843, double 0x3FEFF94F77369843, double 0x3FEFF94F77369843, double 0x3FEFF94F77369843, double 0x3FDDA6274695E687, double 0x3FEFF94F77369843, double 0x3FEFF94F77369843, double 0x3FC42BDC26DCE39B, double 0x3F8C57F9104CA951, double 0x3FD9340AC9879DEF, double 7.600230e-01, double 0x3F999EC5A86B439B, double 0x3F8C57F9104CA951, double 0x3FD389FCD90412B4, double 0x3FABC8251D45E10B, double 0x3FDD9BD68ABBB045, double 0x3F90F633F956C386, double 8.825610e-04, double 0x3EEA42D90EEBA875, double 0x3FEFC7471C1E43B8, double 0x3FD5B8C4014C305A, double 0x3FA2E78CEC8D068E, double 0x3F84F6832995A599, double 0x3FA459002162FC24, double 3.172920e-03, double 8.992520e-01, double 0x3FCBE5BD5E9AC00A], [50 x double] [double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 0x3FDDA6274695E687, double 1.000000e+00, double 1.000000e+00, double 0x3FC42BDC26DCE39B, double 0x3F8C939AFCF101E0, double 0x3FD9340AC9879DEF, double 7.600230e-01, double 0x3F999EC5A86B439B, double 0x3F8C939AFCF101E0, double 0x3FD389FCD90412B4, double 0x3FABC8251D45E10B, double 0x3FDD9BD68ABBB045, double 0x3F90F633F956C386, double 8.825610e-04, double 0x3EEA42D90EEBA875, double 0x3FEFC7471C1E43B8, double 0x3FD5B8C4014C305A, double 0x3FA2E78CEC8D068E, double 0x3F84F6832995A599, double 0x3FA459002162FC24, double 3.172920e-03, double 8.992520e-01, double 0x3FCBE5BD5E9AC00A], [50 x double] [double 0x3FEFF94F77369843, double 0x3FEFF94F77369843, double 0x3FEFF94F77369843, double 0x3FEFF5DC908F2EDD, double 0x3FEFF94F77369843, double 0x3FEFF94F77369843, double 0x3FEFF94F77369843, double 0x3FEFF94F77369843, double 0x3FEFF94F77369843, double 0x3FEFF94F77369843, double 0x3FEFF94F77369843, double 0x3FEFF94F77369843, double 0x3FEFF94F77369843, double 0x3FEFF94F77369843, double 0x3FEFF94F77369843, double 0x3FEFF94F77369843, double 0x3FEFF94F77369843, double 0x3FEFF94F77369843, double 0x3FEFF94F77369843, double 0x3FEEB45F17BD8BE7, double 0x3FEFF94F77369843, double 0x3FEFF94F77369843, double 0x3FEFF94F77369843, double 0x3FEFF94F77369843, double 0x3FEFF94F77369843, double 0x3FEFF94F77369843, double 0x3FEFF94F77369843, double 0x3FDBDA250F840182, double 0x3FEFF94F77369843, double 0x3FEF40BC1D52205E, double 0x3FC21A3BEB689947, double 1.304340e-02, double 0x3FD69916517B1CD7, double 0x3FE60A69453DF7B2, double 0x3F986DB666D9D3C6, double 0x3F8B157BBD3AB385, double 2.722920e-01, double 0x3FABC8251D45E10B, double 0x3FDAFF07B27BE8AF, double 0x3F9030D45E3B9F93, double 8.825610e-04, double 0x3EEA42D90EEBA875, double 0x3FEBFACC1948A662, double 0x3FD34EE6EDE042CB, double 0x3FA2011883DA6A9A, double 0x3F839FF779153716, double 0x3FA3D9F3D1C960DD, double 3.172920e-03, double 0x3FE9FDC4BC5D1301, double 0x3FC8F5FAC3801CF1]], align 16
@.str.26 = private unnamed_addr constant [3 x i8] c"bh\00", align 1
@.str.27 = private unnamed_addr constant [11 x i8] c"bonferroni\00", align 1
@__const.main.TYPES = private unnamed_addr constant [6 x i8*] [i8* getelementptr inbounds ([3 x i8], [3 x i8]* @.str.26, i32 0, i32 0), i8* getelementptr inbounds ([3 x i8], [3 x i8]* @.str.16, i32 0, i32 0), i8* getelementptr inbounds ([11 x i8], [11 x i8]* @.str.27, i32 0, i32 0), i8* getelementptr inbounds ([9 x i8], [9 x i8]* @.str.18, i32 0, i32 0), i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.19, i32 0, i32 0), i8* getelementptr inbounds ([7 x i8], [7 x i8]* @.str.20, i32 0, i32 0)], align 16
@.str.28 = private unnamed_addr constant [44 x i8] c"\0Atype %u = '%s' has cumulative error of %g\0A\00", align 1
@llvm.used = appending global [1 x i8*] [i8* bitcast (i32 ()* @__main_void to i8*)], section "llvm.metadata"

@__main_void = alias i32 (), i32 ()* @main

; Function Attrs: noinline nounwind optnone
define hidden i32* @seq_len(i32 %START, i32 %END) #0 {
entry:
  %retval = alloca i32*, align 4
  %START.addr = alloca i32, align 4
  %END.addr = alloca i32, align 4
  %start = alloca i32, align 4
  %end = alloca i32, align 4
  %sequence = alloca i32*, align 4
  %i = alloca i32, align 4
  %LENGTH = alloca i32, align 4
  %sequence10 = alloca i32*, align 4
  %index = alloca i32, align 4
  %index28 = alloca i32, align 4
  store i32 %START, i32* %START.addr, align 4
  store i32 %END, i32* %END.addr, align 4
  %0 = load i32, i32* %START.addr, align 4
  store i32 %0, i32* %start, align 4
  %1 = load i32, i32* %END.addr, align 4
  store i32 %1, i32* %end, align 4
  %2 = load i32, i32* %START.addr, align 4
  %3 = load i32, i32* %END.addr, align 4
  %cmp = icmp eq i32 %2, %3
  br i1 %cmp, label %if.then, label %if.end6

if.then:                                          ; preds = %entry
  %4 = load i32, i32* %end, align 4
  %add = add i32 %4, 1
  %mul = mul i32 %add, 4
  %call = call noalias i8* @malloc(i32 %mul)
  %5 = bitcast i8* %call to i32*
  store i32* %5, i32** %sequence, align 4
  %6 = load i32*, i32** %sequence, align 4
  %cmp1 = icmp eq i32* %6, null
  br i1 %cmp1, label %if.then2, label %if.end

if.then2:                                         ; preds = %if.then
  %call3 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([29 x i8], [29 x i8]* @.str, i32 0, i32 0), i8* getelementptr inbounds ([23 x i8], [23 x i8]* @.str.1, i32 0, i32 0), i32 15)
  call void @perror(i8* getelementptr inbounds ([1 x i8], [1 x i8]* @.str.2, i32 0, i32 0))
  call void @exit(i32 1) #5
  unreachable

if.end:                                           ; preds = %if.then
  store i32 0, i32* %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.end
  %7 = load i32, i32* %i, align 4
  %8 = load i32, i32* %end, align 4
  %cmp4 = icmp ult i32 %7, %8
  br i1 %cmp4, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %9 = load i32, i32* %i, align 4
  %add5 = add i32 %9, 1
  %10 = load i32*, i32** %sequence, align 4
  %11 = load i32, i32* %i, align 4
  %arrayidx = getelementptr inbounds i32, i32* %10, i32 %11
  store i32 %add5, i32* %arrayidx, align 4
  br label %for.inc

for.inc:                                          ; preds = %for.body
  %12 = load i32, i32* %i, align 4
  %inc = add i32 %12, 1
  store i32 %inc, i32* %i, align 4
  br label %for.cond

for.end:                                          ; preds = %for.cond
  %13 = load i32*, i32** %sequence, align 4
  store i32* %13, i32** %retval, align 4
  br label %return

if.end6:                                          ; preds = %entry
  %14 = load i32, i32* %START.addr, align 4
  %15 = load i32, i32* %END.addr, align 4
  %cmp7 = icmp ugt i32 %14, %15
  br i1 %cmp7, label %if.then8, label %if.end9

if.then8:                                         ; preds = %if.end6
  %16 = load i32, i32* %START.addr, align 4
  store i32 %16, i32* %end, align 4
  %17 = load i32, i32* %END.addr, align 4
  store i32 %17, i32* %start, align 4
  br label %if.end9

if.end9:                                          ; preds = %if.then8, %if.end6
  %18 = load i32, i32* %end, align 4
  %19 = load i32, i32* %start, align 4
  %sub = sub i32 %18, %19
  store i32 %sub, i32* %LENGTH, align 4
  %20 = load i32, i32* %LENGTH, align 4
  %add11 = add i32 1, %20
  %mul12 = mul i32 %add11, 4
  %call13 = call noalias i8* @malloc(i32 %mul12)
  %21 = bitcast i8* %call13 to i32*
  store i32* %21, i32** %sequence10, align 4
  %22 = load i32*, i32** %sequence10, align 4
  %cmp14 = icmp eq i32* %22, null
  br i1 %cmp14, label %if.then15, label %if.end17

if.then15:                                        ; preds = %if.end9
  %call16 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([29 x i8], [29 x i8]* @.str, i32 0, i32 0), i8* getelementptr inbounds ([23 x i8], [23 x i8]* @.str.1, i32 0, i32 0), i32 31)
  call void @perror(i8* getelementptr inbounds ([1 x i8], [1 x i8]* @.str.2, i32 0, i32 0))
  call void @exit(i32 1) #5
  unreachable

if.end17:                                         ; preds = %if.end9
  %23 = load i32, i32* %START.addr, align 4
  %24 = load i32, i32* %END.addr, align 4
  %cmp18 = icmp ult i32 %23, %24
  br i1 %cmp18, label %if.then19, label %if.else

if.then19:                                        ; preds = %if.end17
  store i32 0, i32* %index, align 4
  br label %for.cond20

for.cond20:                                       ; preds = %for.inc25, %if.then19
  %25 = load i32, i32* %index, align 4
  %26 = load i32, i32* %LENGTH, align 4
  %cmp21 = icmp ule i32 %25, %26
  br i1 %cmp21, label %for.body22, label %for.end27

for.body22:                                       ; preds = %for.cond20
  %27 = load i32, i32* %start, align 4
  %28 = load i32, i32* %index, align 4
  %add23 = add i32 %27, %28
  %29 = load i32*, i32** %sequence10, align 4
  %30 = load i32, i32* %index, align 4
  %arrayidx24 = getelementptr inbounds i32, i32* %29, i32 %30
  store i32 %add23, i32* %arrayidx24, align 4
  br label %for.inc25

for.inc25:                                        ; preds = %for.body22
  %31 = load i32, i32* %index, align 4
  %inc26 = add i32 %31, 1
  store i32 %inc26, i32* %index, align 4
  br label %for.cond20

for.end27:                                        ; preds = %for.cond20
  br label %if.end37

if.else:                                          ; preds = %if.end17
  store i32 0, i32* %index28, align 4
  br label %for.cond29

for.cond29:                                       ; preds = %for.inc34, %if.else
  %32 = load i32, i32* %index28, align 4
  %33 = load i32, i32* %LENGTH, align 4
  %cmp30 = icmp ule i32 %32, %33
  br i1 %cmp30, label %for.body31, label %for.end36

for.body31:                                       ; preds = %for.cond29
  %34 = load i32, i32* %end, align 4
  %35 = load i32, i32* %index28, align 4
  %sub32 = sub i32 %34, %35
  %36 = load i32*, i32** %sequence10, align 4
  %37 = load i32, i32* %index28, align 4
  %arrayidx33 = getelementptr inbounds i32, i32* %36, i32 %37
  store i32 %sub32, i32* %arrayidx33, align 4
  br label %for.inc34

for.inc34:                                        ; preds = %for.body31
  %38 = load i32, i32* %index28, align 4
  %inc35 = add i32 %38, 1
  store i32 %inc35, i32* %index28, align 4
  br label %for.cond29

for.end36:                                        ; preds = %for.cond29
  br label %if.end37

if.end37:                                         ; preds = %for.end36, %for.end27
  %39 = load i32*, i32** %sequence10, align 4
  store i32* %39, i32** %retval, align 4
  br label %return

return:                                           ; preds = %if.end37, %for.end
  %40 = load i32*, i32** %retval, align 4
  ret i32* %40
}

declare noalias i8* @malloc(i32 %0) #1

declare i32 @printf(i8* %0, ...) #1

declare void @perror(i8* %0) #1

; Function Attrs: noreturn
declare void @exit(i32 %0) #2

; Function Attrs: noinline nounwind optnone
define hidden i32* @order(double* noalias %ARRAY, i32 %SIZE, i1 zeroext %DECREASING) #0 {
entry:
  %ARRAY.addr = alloca double*, align 4
  %SIZE.addr = alloca i32, align 4
  %DECREASING.addr = alloca i8, align 1
  %idx = alloca i32*, align 4
  %i = alloca i32, align 4
  store double* %ARRAY, double** %ARRAY.addr, align 4
  store i32 %SIZE, i32* %SIZE.addr, align 4
  %frombool = zext i1 %DECREASING to i8
  store i8 %frombool, i8* %DECREASING.addr, align 1
  %0 = load i32, i32* %SIZE.addr, align 4
  %mul = mul i32 %0, 4
  %call = call noalias i8* @malloc(i32 %mul)
  %1 = bitcast i8* %call to i32*
  store i32* %1, i32** %idx, align 4
  %2 = load i32*, i32** %idx, align 4
  %cmp = icmp eq i32* %2, null
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %call1 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([33 x i8], [33 x i8]* @.str.3, i32 0, i32 0), i8* getelementptr inbounds ([23 x i8], [23 x i8]* @.str.1, i32 0, i32 0), i32 77)
  call void @perror(i8* getelementptr inbounds ([1 x i8], [1 x i8]* @.str.2, i32 0, i32 0))
  call void @exit(i32 1) #5
  unreachable

if.end:                                           ; preds = %entry
  %3 = load i32, i32* %SIZE.addr, align 4
  %mul2 = mul i32 8, %3
  %call3 = call noalias i8* @malloc(i32 %mul2)
  %4 = bitcast i8* %call3 to double*
  store double* %4, double** @base_arr, align 4
  %5 = load double*, double** @base_arr, align 4
  %cmp4 = icmp eq double* %5, null
  br i1 %cmp4, label %if.then5, label %if.end7

if.then5:                                         ; preds = %if.end
  %call6 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([33 x i8], [33 x i8]* @.str.3, i32 0, i32 0), i8* getelementptr inbounds ([23 x i8], [23 x i8]* @.str.1, i32 0, i32 0), i32 83)
  call void @perror(i8* getelementptr inbounds ([1 x i8], [1 x i8]* @.str.2, i32 0, i32 0))
  call void @exit(i32 1) #5
  unreachable

if.end7:                                          ; preds = %if.end
  store i32 0, i32* %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.end7
  %6 = load i32, i32* %i, align 4
  %7 = load i32, i32* %SIZE.addr, align 4
  %cmp8 = icmp ult i32 %6, %7
  br i1 %cmp8, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %8 = load double*, double** %ARRAY.addr, align 4
  %9 = load i32, i32* %i, align 4
  %arrayidx = getelementptr inbounds double, double* %8, i32 %9
  %10 = load double, double* %arrayidx, align 8
  %11 = load double*, double** @base_arr, align 4
  %12 = load i32, i32* %i, align 4
  %arrayidx9 = getelementptr inbounds double, double* %11, i32 %12
  store double %10, double* %arrayidx9, align 8
  %13 = load i32, i32* %i, align 4
  %14 = load i32*, i32** %idx, align 4
  %15 = load i32, i32* %i, align 4
  %arrayidx10 = getelementptr inbounds i32, i32* %14, i32 %15
  store i32 %13, i32* %arrayidx10, align 4
  br label %for.inc

for.inc:                                          ; preds = %for.body
  %16 = load i32, i32* %i, align 4
  %inc = add i32 %16, 1
  store i32 %inc, i32* %i, align 4
  br label %for.cond

for.end:                                          ; preds = %for.cond
  %17 = load i8, i8* %DECREASING.addr, align 1
  %tobool = trunc i8 %17 to i1
  %conv = zext i1 %tobool to i32
  %cmp11 = icmp eq i32 %conv, 0
  br i1 %cmp11, label %if.then13, label %if.else

if.then13:                                        ; preds = %for.end
  %18 = load i32*, i32** %idx, align 4
  %19 = bitcast i32* %18 to i8*
  %20 = load i32, i32* %SIZE.addr, align 4
  call void @qsort(i8* %19, i32 %20, i32 4, i32 (i8*, i8*)* @compar_decrease)
  br label %if.end20

if.else:                                          ; preds = %for.end
  %21 = load i8, i8* %DECREASING.addr, align 1
  %tobool14 = trunc i8 %21 to i1
  br i1 %tobool14, label %if.then18, label %if.end19

if.then18:                                        ; preds = %if.else
  %22 = load i32*, i32** %idx, align 4
  %23 = bitcast i32* %22 to i8*
  %24 = load i32, i32* %SIZE.addr, align 4
  call void @qsort(i8* %23, i32 %24, i32 4, i32 (i8*, i8*)* @compar_increase)
  br label %if.end19

if.end19:                                         ; preds = %if.then18, %if.else
  br label %if.end20

if.end20:                                         ; preds = %if.end19, %if.then13
  %25 = load double*, double** @base_arr, align 4
  %26 = bitcast double* %25 to i8*
  call void @free(i8* %26)
  store double* null, double** @base_arr, align 4
  %27 = load i32*, i32** %idx, align 4
  ret i32* %27
}

declare void @qsort(i8* %0, i32 %1, i32 %2, i32 (i8*, i8*)* %3) #1

; Function Attrs: noinline nounwind optnone
define internal i32 @compar_decrease(i8* noalias %a, i8* noalias %b) #0 {
entry:
  %retval = alloca i32, align 4
  %a.addr = alloca i8*, align 4
  %b.addr = alloca i8*, align 4
  %aa = alloca i32, align 4
  %bb = alloca i32, align 4
  store i8* %a, i8** %a.addr, align 4
  store i8* %b, i8** %b.addr, align 4
  %0 = load i8*, i8** %a.addr, align 4
  %1 = bitcast i8* %0 to i32*
  %2 = load i32, i32* %1, align 4
  store i32 %2, i32* %aa, align 4
  %3 = load i8*, i8** %b.addr, align 4
  %4 = bitcast i8* %3 to i32*
  %5 = load i32, i32* %4, align 4
  store i32 %5, i32* %bb, align 4
  %6 = load double*, double** @base_arr, align 4
  %7 = load i32, i32* %aa, align 4
  %arrayidx = getelementptr inbounds double, double* %6, i32 %7
  %8 = load double, double* %arrayidx, align 8
  %9 = load double*, double** @base_arr, align 4
  %10 = load i32, i32* %bb, align 4
  %arrayidx1 = getelementptr inbounds double, double* %9, i32 %10
  %11 = load double, double* %arrayidx1, align 8
  %cmp = fcmp olt double %8, %11
  br i1 %cmp, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  store i32 -1, i32* %retval, align 4
  br label %return

if.else:                                          ; preds = %entry
  %12 = load double*, double** @base_arr, align 4
  %13 = load i32, i32* %aa, align 4
  %arrayidx2 = getelementptr inbounds double, double* %12, i32 %13
  %14 = load double, double* %arrayidx2, align 8
  %15 = load double*, double** @base_arr, align 4
  %16 = load i32, i32* %bb, align 4
  %arrayidx3 = getelementptr inbounds double, double* %15, i32 %16
  %17 = load double, double* %arrayidx3, align 8
  %cmp4 = fcmp oeq double %14, %17
  br i1 %cmp4, label %if.then5, label %if.else6

if.then5:                                         ; preds = %if.else
  store i32 0, i32* %retval, align 4
  br label %return

if.else6:                                         ; preds = %if.else
  store i32 1, i32* %retval, align 4
  br label %return

return:                                           ; preds = %if.else6, %if.then5, %if.then
  %18 = load i32, i32* %retval, align 4
  ret i32 %18
}

; Function Attrs: noinline nounwind optnone
define internal i32 @compar_increase(i8* noalias %a, i8* noalias %b) #0 {
entry:
  %retval = alloca i32, align 4
  %a.addr = alloca i8*, align 4
  %b.addr = alloca i8*, align 4
  %aa = alloca i32, align 4
  %bb = alloca i32, align 4
  store i8* %a, i8** %a.addr, align 4
  store i8* %b, i8** %b.addr, align 4
  %0 = load i8*, i8** %a.addr, align 4
  %1 = bitcast i8* %0 to i32*
  %2 = load i32, i32* %1, align 4
  store i32 %2, i32* %aa, align 4
  %3 = load i8*, i8** %b.addr, align 4
  %4 = bitcast i8* %3 to i32*
  %5 = load i32, i32* %4, align 4
  store i32 %5, i32* %bb, align 4
  %6 = load double*, double** @base_arr, align 4
  %7 = load i32, i32* %aa, align 4
  %arrayidx = getelementptr inbounds double, double* %6, i32 %7
  %8 = load double, double* %arrayidx, align 8
  %9 = load double*, double** @base_arr, align 4
  %10 = load i32, i32* %bb, align 4
  %arrayidx1 = getelementptr inbounds double, double* %9, i32 %10
  %11 = load double, double* %arrayidx1, align 8
  %cmp = fcmp olt double %8, %11
  br i1 %cmp, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  store i32 1, i32* %retval, align 4
  br label %return

if.else:                                          ; preds = %entry
  %12 = load double*, double** @base_arr, align 4
  %13 = load i32, i32* %aa, align 4
  %arrayidx2 = getelementptr inbounds double, double* %12, i32 %13
  %14 = load double, double* %arrayidx2, align 8
  %15 = load double*, double** @base_arr, align 4
  %16 = load i32, i32* %bb, align 4
  %arrayidx3 = getelementptr inbounds double, double* %15, i32 %16
  %17 = load double, double* %arrayidx3, align 8
  %cmp4 = fcmp oeq double %14, %17
  br i1 %cmp4, label %if.then5, label %if.else6

if.then5:                                         ; preds = %if.else
  store i32 0, i32* %retval, align 4
  br label %return

if.else6:                                         ; preds = %if.else
  store i32 -1, i32* %retval, align 4
  br label %return

return:                                           ; preds = %if.else6, %if.then5, %if.then
  %18 = load i32, i32* %retval, align 4
  ret i32 %18
}

declare void @free(i8* %0) #1

; Function Attrs: noinline nounwind optnone
define hidden double* @cummin(double* noalias %ARRAY, i32 %NO_OF_ARRAY_ELEMENTS) #0 {
entry:
  %ARRAY.addr = alloca double*, align 4
  %NO_OF_ARRAY_ELEMENTS.addr = alloca i32, align 4
  %output = alloca double*, align 4
  %cumulative_min = alloca double, align 8
  %i = alloca i32, align 4
  store double* %ARRAY, double** %ARRAY.addr, align 4
  store i32 %NO_OF_ARRAY_ELEMENTS, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
  %0 = load i32, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
  %cmp = icmp ult i32 %0, 1
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %call = call i32 @puts(i8* getelementptr inbounds ([48 x i8], [48 x i8]* @.str.4, i32 0, i32 0))
  %call1 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([22 x i8], [22 x i8]* @.str.5, i32 0, i32 0), i8* getelementptr inbounds ([23 x i8], [23 x i8]* @.str.1, i32 0, i32 0), i32 105)
  call void @exit(i32 1) #5
  unreachable

if.end:                                           ; preds = %entry
  %1 = load i32, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
  %mul = mul i32 8, %1
  %call2 = call noalias i8* @malloc(i32 %mul)
  %2 = bitcast i8* %call2 to double*
  store double* %2, double** %output, align 4
  %3 = load double*, double** %output, align 4
  %cmp3 = icmp eq double* %3, null
  br i1 %cmp3, label %if.then4, label %if.end6

if.then4:                                         ; preds = %if.end
  %call5 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([33 x i8], [33 x i8]* @.str.3, i32 0, i32 0), i8* getelementptr inbounds ([23 x i8], [23 x i8]* @.str.1, i32 0, i32 0), i32 110)
  call void @perror(i8* getelementptr inbounds ([1 x i8], [1 x i8]* @.str.2, i32 0, i32 0))
  call void @exit(i32 1) #5
  unreachable

if.end6:                                          ; preds = %if.end
  %4 = load double*, double** %ARRAY.addr, align 4
  %arrayidx = getelementptr inbounds double, double* %4, i32 0
  %5 = load double, double* %arrayidx, align 8
  store double %5, double* %cumulative_min, align 8
  store i32 0, i32* %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.end6
  %6 = load i32, i32* %i, align 4
  %7 = load i32, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
  %cmp7 = icmp ult i32 %6, %7
  br i1 %cmp7, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %8 = load double*, double** %ARRAY.addr, align 4
  %9 = load i32, i32* %i, align 4
  %arrayidx8 = getelementptr inbounds double, double* %8, i32 %9
  %10 = load double, double* %arrayidx8, align 8
  %11 = load double, double* %cumulative_min, align 8
  %cmp9 = fcmp olt double %10, %11
  br i1 %cmp9, label %if.then10, label %if.end12

if.then10:                                        ; preds = %for.body
  %12 = load double*, double** %ARRAY.addr, align 4
  %13 = load i32, i32* %i, align 4
  %arrayidx11 = getelementptr inbounds double, double* %12, i32 %13
  %14 = load double, double* %arrayidx11, align 8
  store double %14, double* %cumulative_min, align 8
  br label %if.end12

if.end12:                                         ; preds = %if.then10, %for.body
  %15 = load double, double* %cumulative_min, align 8
  %16 = load double*, double** %output, align 4
  %17 = load i32, i32* %i, align 4
  %arrayidx13 = getelementptr inbounds double, double* %16, i32 %17
  store double %15, double* %arrayidx13, align 8
  br label %for.inc

for.inc:                                          ; preds = %if.end12
  %18 = load i32, i32* %i, align 4
  %inc = add i32 %18, 1
  store i32 %inc, i32* %i, align 4
  br label %for.cond

for.end:                                          ; preds = %for.cond
  %19 = load double*, double** %output, align 4
  ret double* %19
}

declare i32 @puts(i8* %0) #1

; Function Attrs: noinline nounwind optnone
define hidden double* @cummax(double* noalias %ARRAY, i32 %NO_OF_ARRAY_ELEMENTS) #0 {
entry:
  %ARRAY.addr = alloca double*, align 4
  %NO_OF_ARRAY_ELEMENTS.addr = alloca i32, align 4
  %output = alloca double*, align 4
  %cumulative_max = alloca double, align 8
  %i = alloca i32, align 4
  store double* %ARRAY, double** %ARRAY.addr, align 4
  store i32 %NO_OF_ARRAY_ELEMENTS, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
  %0 = load i32, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
  %cmp = icmp ult i32 %0, 1
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %call = call i32 @puts(i8* getelementptr inbounds ([41 x i8], [41 x i8]* @.str.6, i32 0, i32 0))
  %call1 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([22 x i8], [22 x i8]* @.str.5, i32 0, i32 0), i8* getelementptr inbounds ([23 x i8], [23 x i8]* @.str.1, i32 0, i32 0), i32 129)
  call void @exit(i32 1) #5
  unreachable

if.end:                                           ; preds = %entry
  %1 = load i32, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
  %mul = mul i32 8, %1
  %call2 = call noalias i8* @malloc(i32 %mul)
  %2 = bitcast i8* %call2 to double*
  store double* %2, double** %output, align 4
  %3 = load double*, double** %output, align 4
  %cmp3 = icmp eq double* %3, null
  br i1 %cmp3, label %if.then4, label %if.end6

if.then4:                                         ; preds = %if.end
  %call5 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([33 x i8], [33 x i8]* @.str.3, i32 0, i32 0), i8* getelementptr inbounds ([23 x i8], [23 x i8]* @.str.1, i32 0, i32 0), i32 134)
  call void @perror(i8* getelementptr inbounds ([1 x i8], [1 x i8]* @.str.2, i32 0, i32 0))
  call void @exit(i32 1) #5
  unreachable

if.end6:                                          ; preds = %if.end
  %4 = load double*, double** %ARRAY.addr, align 4
  %arrayidx = getelementptr inbounds double, double* %4, i32 0
  %5 = load double, double* %arrayidx, align 8
  store double %5, double* %cumulative_max, align 8
  store i32 0, i32* %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.end6
  %6 = load i32, i32* %i, align 4
  %7 = load i32, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
  %cmp7 = icmp ult i32 %6, %7
  br i1 %cmp7, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %8 = load double*, double** %ARRAY.addr, align 4
  %9 = load i32, i32* %i, align 4
  %arrayidx8 = getelementptr inbounds double, double* %8, i32 %9
  %10 = load double, double* %arrayidx8, align 8
  %11 = load double, double* %cumulative_max, align 8
  %cmp9 = fcmp ogt double %10, %11
  br i1 %cmp9, label %if.then10, label %if.end12

if.then10:                                        ; preds = %for.body
  %12 = load double*, double** %ARRAY.addr, align 4
  %13 = load i32, i32* %i, align 4
  %arrayidx11 = getelementptr inbounds double, double* %12, i32 %13
  %14 = load double, double* %arrayidx11, align 8
  store double %14, double* %cumulative_max, align 8
  br label %if.end12

if.end12:                                         ; preds = %if.then10, %for.body
  %15 = load double, double* %cumulative_max, align 8
  %16 = load double*, double** %output, align 4
  %17 = load i32, i32* %i, align 4
  %arrayidx13 = getelementptr inbounds double, double* %16, i32 %17
  store double %15, double* %arrayidx13, align 8
  br label %for.inc

for.inc:                                          ; preds = %if.end12
  %18 = load i32, i32* %i, align 4
  %inc = add i32 %18, 1
  store i32 %inc, i32* %i, align 4
  br label %for.cond

for.end:                                          ; preds = %for.cond
  %19 = load double*, double** %output, align 4
  ret double* %19
}

; Function Attrs: noinline nounwind optnone
define hidden double* @pminx(double* noalias %ARRAY, i32 %NO_OF_ARRAY_ELEMENTS, double %X) #0 {
entry:
  %ARRAY.addr = alloca double*, align 4
  %NO_OF_ARRAY_ELEMENTS.addr = alloca i32, align 4
  %X.addr = alloca double, align 8
  %pmin_array = alloca double*, align 4
  %index = alloca i32, align 4
  store double* %ARRAY, double** %ARRAY.addr, align 4
  store i32 %NO_OF_ARRAY_ELEMENTS, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
  store double %X, double* %X.addr, align 8
  %0 = load i32, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
  %cmp = icmp ult i32 %0, 1
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %call = call i32 @puts(i8* getelementptr inbounds ([37 x i8], [37 x i8]* @.str.7, i32 0, i32 0))
  %call1 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([22 x i8], [22 x i8]* @.str.5, i32 0, i32 0), i8* getelementptr inbounds ([23 x i8], [23 x i8]* @.str.1, i32 0, i32 0), i32 152)
  call void @exit(i32 1) #5
  unreachable

if.end:                                           ; preds = %entry
  %1 = load i32, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
  %mul = mul i32 8, %1
  %call2 = call noalias i8* @malloc(i32 %mul)
  %2 = bitcast i8* %call2 to double*
  store double* %2, double** %pmin_array, align 4
  %3 = load double*, double** %pmin_array, align 4
  %cmp3 = icmp eq double* %3, null
  br i1 %cmp3, label %if.then4, label %if.end6

if.then4:                                         ; preds = %if.end
  %call5 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([33 x i8], [33 x i8]* @.str.3, i32 0, i32 0), i8* getelementptr inbounds ([23 x i8], [23 x i8]* @.str.1, i32 0, i32 0), i32 157)
  call void @perror(i8* getelementptr inbounds ([1 x i8], [1 x i8]* @.str.2, i32 0, i32 0))
  call void @exit(i32 1) #5
  unreachable

if.end6:                                          ; preds = %if.end
  store i32 0, i32* %index, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.end6
  %4 = load i32, i32* %index, align 4
  %5 = load i32, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
  %cmp7 = icmp ult i32 %4, %5
  br i1 %cmp7, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %6 = load double*, double** %ARRAY.addr, align 4
  %7 = load i32, i32* %index, align 4
  %arrayidx = getelementptr inbounds double, double* %6, i32 %7
  %8 = load double, double* %arrayidx, align 8
  %9 = load double, double* %X.addr, align 8
  %cmp8 = fcmp olt double %8, %9
  br i1 %cmp8, label %if.then9, label %if.else

if.then9:                                         ; preds = %for.body
  %10 = load double*, double** %ARRAY.addr, align 4
  %11 = load i32, i32* %index, align 4
  %arrayidx10 = getelementptr inbounds double, double* %10, i32 %11
  %12 = load double, double* %arrayidx10, align 8
  %13 = load double*, double** %pmin_array, align 4
  %14 = load i32, i32* %index, align 4
  %arrayidx11 = getelementptr inbounds double, double* %13, i32 %14
  store double %12, double* %arrayidx11, align 8
  br label %if.end13

if.else:                                          ; preds = %for.body
  %15 = load double, double* %X.addr, align 8
  %16 = load double*, double** %pmin_array, align 4
  %17 = load i32, i32* %index, align 4
  %arrayidx12 = getelementptr inbounds double, double* %16, i32 %17
  store double %15, double* %arrayidx12, align 8
  br label %if.end13

if.end13:                                         ; preds = %if.else, %if.then9
  br label %for.inc

for.inc:                                          ; preds = %if.end13
  %18 = load i32, i32* %index, align 4
  %inc = add i32 %18, 1
  store i32 %inc, i32* %index, align 4
  br label %for.cond

for.end:                                          ; preds = %for.cond
  %19 = load double*, double** %pmin_array, align 4
  ret double* %19
}

; Function Attrs: noinline nounwind optnone
define hidden void @double_say(double* noalias %ARRAY, i32 %NO_OF_ARRAY_ELEMENTS) #0 {
entry:
  %ARRAY.addr = alloca double*, align 4
  %NO_OF_ARRAY_ELEMENTS.addr = alloca i32, align 4
  %i = alloca i32, align 4
  store double* %ARRAY, double** %ARRAY.addr, align 4
  store i32 %NO_OF_ARRAY_ELEMENTS, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
  %0 = load double*, double** %ARRAY.addr, align 4
  %arrayidx = getelementptr inbounds double, double* %0, i32 0
  %1 = load double, double* %arrayidx, align 8
  %call = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([7 x i8], [7 x i8]* @.str.8, i32 0, i32 0), double %1)
  store i32 1, i32* %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %2 = load i32, i32* %i, align 4
  %3 = load i32, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
  %cmp = icmp ult i32 %2, %3
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %4 = load double*, double** %ARRAY.addr, align 4
  %5 = load i32, i32* %i, align 4
  %arrayidx1 = getelementptr inbounds double, double* %4, i32 %5
  %6 = load double, double* %arrayidx1, align 8
  %call2 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([7 x i8], [7 x i8]* @.str.9, i32 0, i32 0), double %6)
  %7 = load i32, i32* %i, align 4
  %add = add i32 %7, 1
  %rem = urem i32 %add, 5
  %cmp3 = icmp eq i32 %rem, 0
  br i1 %cmp3, label %if.then, label %if.end

if.then:                                          ; preds = %for.body
  %8 = load i32, i32* %i, align 4
  %add4 = add i32 %8, 1
  %call5 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([6 x i8], [6 x i8]* @.str.10, i32 0, i32 0), i32 %add4)
  br label %if.end

if.end:                                           ; preds = %if.then, %for.body
  br label %for.inc

for.inc:                                          ; preds = %if.end
  %9 = load i32, i32* %i, align 4
  %inc = add i32 %9, 1
  store i32 %inc, i32* %i, align 4
  br label %for.cond

for.end:                                          ; preds = %for.cond
  %call6 = call i32 @puts(i8* getelementptr inbounds ([2 x i8], [2 x i8]* @.str.11, i32 0, i32 0))
  ret void
}

; Function Attrs: noinline nounwind optnone
define hidden double* @uint2double(i32* noalias %ARRAY, i32 %NO_OF_ARRAY_ELEMENTS) #0 {
entry:
  %ARRAY.addr = alloca i32*, align 4
  %NO_OF_ARRAY_ELEMENTS.addr = alloca i32, align 4
  %doubleArray = alloca double*, align 4
  %index = alloca i32, align 4
  store i32* %ARRAY, i32** %ARRAY.addr, align 4
  store i32 %NO_OF_ARRAY_ELEMENTS, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
  %0 = load i32, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
  %mul = mul i32 8, %0
  %call = call noalias i8* @malloc(i32 %mul)
  %1 = bitcast i8* %call to double*
  store double* %1, double** %doubleArray, align 4
  %2 = load double*, double** %doubleArray, align 4
  %cmp = icmp eq double* %2, null
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %call1 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([34 x i8], [34 x i8]* @.str.12, i32 0, i32 0), i8* getelementptr inbounds ([23 x i8], [23 x i8]* @.str.1, i32 0, i32 0), i32 194)
  call void @perror(i8* getelementptr inbounds ([1 x i8], [1 x i8]* @.str.2, i32 0, i32 0))
  call void @exit(i32 1) #5
  unreachable

if.end:                                           ; preds = %entry
  store i32 0, i32* %index, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.end
  %3 = load i32, i32* %index, align 4
  %4 = load i32, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
  %cmp2 = icmp ult i32 %3, %4
  br i1 %cmp2, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %5 = load i32*, i32** %ARRAY.addr, align 4
  %6 = load i32, i32* %index, align 4
  %arrayidx = getelementptr inbounds i32, i32* %5, i32 %6
  %7 = load i32, i32* %arrayidx, align 4
  %conv = uitofp i32 %7 to double
  %8 = load double*, double** %doubleArray, align 4
  %9 = load i32, i32* %index, align 4
  %arrayidx3 = getelementptr inbounds double, double* %8, i32 %9
  store double %conv, double* %arrayidx3, align 8
  br label %for.inc

for.inc:                                          ; preds = %for.body
  %10 = load i32, i32* %index, align 4
  %inc = add i32 %10, 1
  store i32 %inc, i32* %index, align 4
  br label %for.cond

for.end:                                          ; preds = %for.cond
  %11 = load double*, double** %doubleArray, align 4
  ret double* %11
}

; Function Attrs: noinline nounwind optnone
define hidden double @min2(double %N1, double %N2) #0 {
entry:
  %retval = alloca double, align 8
  %N1.addr = alloca double, align 8
  %N2.addr = alloca double, align 8
  store double %N1, double* %N1.addr, align 8
  store double %N2, double* %N2.addr, align 8
  %0 = load double, double* %N1.addr, align 8
  %1 = load double, double* %N2.addr, align 8
  %cmp = fcmp olt double %0, %1
  br i1 %cmp, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  %2 = load double, double* %N1.addr, align 8
  store double %2, double* %retval, align 8
  br label %return

if.else:                                          ; preds = %entry
  %3 = load double, double* %N2.addr, align 8
  store double %3, double* %retval, align 8
  br label %return

return:                                           ; preds = %if.else, %if.then
  %4 = load double, double* %retval, align 8
  ret double %4
}

; Function Attrs: noinline nounwind optnone
define hidden double* @p_adjust(double* noalias %PVALUES, i32 %NO_OF_ARRAY_ELEMENTS, i8* noalias %STRING) #0 {
entry:
  %retval = alloca double*, align 4
  %PVALUES.addr = alloca double*, align 4
  %NO_OF_ARRAY_ELEMENTS.addr = alloca i32, align 4
  %STRING.addr = alloca i8*, align 4
  %TYPE = alloca i16, align 2
  %bonferroni = alloca double*, align 4
  %index = alloca i32, align 4
  %BONFERRONI = alloca double, align 8
  %o = alloca i32*, align 4
  %o2double = alloca double*, align 4
  %cummax_input = alloca double*, align 4
  %index80 = alloca i32, align 4
  %ro = alloca i32*, align 4
  %cummax_output = alloca double*, align 4
  %pmin = alloca double*, align 4
  %qvalues = alloca double*, align 4
  %index98 = alloca i32, align 4
  %o114 = alloca i32*, align 4
  %p = alloca double*, align 4
  %index123 = alloca i32, align 4
  %o2double134 = alloca double*, align 4
  %ro136 = alloca i32*, align 4
  %q = alloca double*, align 4
  %pa = alloca double*, align 4
  %min = alloca double, align 8
  %index155 = alloca i32, align 4
  %TEMP = alloca double, align 8
  %index171 = alloca i32, align 4
  %j = alloca i32, align 4
  %ij = alloca i32*, align 4
  %I2_LENGTH = alloca i32, align 4
  %i2 = alloca i32*, align 4
  %i = alloca i32, align 4
  %q1 = alloca double, align 8
  %i208 = alloca i32, align 4
  %TEMP_Q1 = alloca double, align 8
  %i227 = alloca i32, align 4
  %i244 = alloca i32, align 4
  %i256 = alloca i32, align 4
  %index274 = alloca i32, align 4
  %o288 = alloca i32*, align 4
  %o_double = alloca double*, align 4
  %index296 = alloca i32, align 4
  %ro315 = alloca i32*, align 4
  %cummin_input = alloca double*, align 4
  %index328 = alloca i32, align 4
  %NI = alloca double, align 8
  %q349 = alloca double, align 8
  %index350 = alloca i32, align 4
  %index362 = alloca i32, align 4
  %NI367 = alloca double, align 8
  %index385 = alloca i32, align 4
  %cummin_array = alloca double*, align 4
  %pmin403 = alloca double*, align 4
  %q_array = alloca double*, align 4
  %index407 = alloca i32, align 4
  store double* %PVALUES, double** %PVALUES.addr, align 4
  store i32 %NO_OF_ARRAY_ELEMENTS, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
  store i8* %STRING, i8** %STRING.addr, align 4
  %0 = load i32, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
  %cmp = icmp ult i32 %0, 1
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %call = call i32 @puts(i8* getelementptr inbounds ([41 x i8], [41 x i8]* @.str.13, i32 0, i32 0))
  %call1 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([22 x i8], [22 x i8]* @.str.5, i32 0, i32 0), i8* getelementptr inbounds ([23 x i8], [23 x i8]* @.str.1, i32 0, i32 0), i32 217)
  call void @exit(i32 1) #5
  unreachable

if.end:                                           ; preds = %entry
  store i16 -1, i16* %TYPE, align 2
  %1 = load i8*, i8** %STRING.addr, align 4
  %cmp2 = icmp eq i8* %1, null
  br i1 %cmp2, label %if.then3, label %if.else

if.then3:                                         ; preds = %if.end
  store i16 0, i16* %TYPE, align 2
  br label %if.end41

if.else:                                          ; preds = %if.end
  %2 = load i8*, i8** %STRING.addr, align 4
  %call4 = call i32 @strcasecmp(i8* %2, i8* getelementptr inbounds ([3 x i8], [3 x i8]* @.str.14, i32 0, i32 0))
  %cmp5 = icmp eq i32 %call4, 0
  br i1 %cmp5, label %if.then6, label %if.else7

if.then6:                                         ; preds = %if.else
  store i16 0, i16* %TYPE, align 2
  br label %if.end40

if.else7:                                         ; preds = %if.else
  %3 = load i8*, i8** %STRING.addr, align 4
  %call8 = call i32 @strcasecmp(i8* %3, i8* getelementptr inbounds ([4 x i8], [4 x i8]* @.str.15, i32 0, i32 0))
  %cmp9 = icmp eq i32 %call8, 0
  br i1 %cmp9, label %if.then10, label %if.else11

if.then10:                                        ; preds = %if.else7
  store i16 0, i16* %TYPE, align 2
  br label %if.end39

if.else11:                                        ; preds = %if.else7
  %4 = load i8*, i8** %STRING.addr, align 4
  %call12 = call i32 @strcasecmp(i8* %4, i8* getelementptr inbounds ([3 x i8], [3 x i8]* @.str.16, i32 0, i32 0))
  %cmp13 = icmp eq i32 %call12, 0
  br i1 %cmp13, label %if.then14, label %if.else15

if.then14:                                        ; preds = %if.else11
  store i16 1, i16* %TYPE, align 2
  br label %if.end38

if.else15:                                        ; preds = %if.else11
  %5 = load i8*, i8** %STRING.addr, align 4
  %call16 = call i32 @strcasecmp(i8* %5, i8* getelementptr inbounds ([11 x i8], [11 x i8]* @.str.17, i32 0, i32 0))
  %cmp17 = icmp eq i32 %call16, 0
  br i1 %cmp17, label %if.then18, label %if.else19

if.then18:                                        ; preds = %if.else15
  store i16 2, i16* %TYPE, align 2
  br label %if.end37

if.else19:                                        ; preds = %if.else15
  %6 = load i8*, i8** %STRING.addr, align 4
  %call20 = call i32 @strcasecmp(i8* %6, i8* getelementptr inbounds ([9 x i8], [9 x i8]* @.str.18, i32 0, i32 0))
  %cmp21 = icmp eq i32 %call20, 0
  br i1 %cmp21, label %if.then22, label %if.else23

if.then22:                                        ; preds = %if.else19
  store i16 3, i16* %TYPE, align 2
  br label %if.end36

if.else23:                                        ; preds = %if.else19
  %7 = load i8*, i8** %STRING.addr, align 4
  %call24 = call i32 @strcasecmp(i8* %7, i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.19, i32 0, i32 0))
  %cmp25 = icmp eq i32 %call24, 0
  br i1 %cmp25, label %if.then26, label %if.else27

if.then26:                                        ; preds = %if.else23
  store i16 4, i16* %TYPE, align 2
  br label %if.end35

if.else27:                                        ; preds = %if.else23
  %8 = load i8*, i8** %STRING.addr, align 4
  %call28 = call i32 @strcasecmp(i8* %8, i8* getelementptr inbounds ([7 x i8], [7 x i8]* @.str.20, i32 0, i32 0))
  %cmp29 = icmp eq i32 %call28, 0
  br i1 %cmp29, label %if.then30, label %if.else31

if.then30:                                        ; preds = %if.else27
  store i16 5, i16* %TYPE, align 2
  br label %if.end34

if.else31:                                        ; preds = %if.else27
  %9 = load i8*, i8** %STRING.addr, align 4
  %call32 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([44 x i8], [44 x i8]* @.str.21, i32 0, i32 0), i8* %9)
  %call33 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([22 x i8], [22 x i8]* @.str.5, i32 0, i32 0), i8* getelementptr inbounds ([23 x i8], [23 x i8]* @.str.1, i32 0, i32 0), i32 239)
  call void @exit(i32 1) #5
  unreachable

if.end34:                                         ; preds = %if.then30
  br label %if.end35

if.end35:                                         ; preds = %if.end34, %if.then26
  br label %if.end36

if.end36:                                         ; preds = %if.end35, %if.then22
  br label %if.end37

if.end37:                                         ; preds = %if.end36, %if.then18
  br label %if.end38

if.end38:                                         ; preds = %if.end37, %if.then14
  br label %if.end39

if.end39:                                         ; preds = %if.end38, %if.then10
  br label %if.end40

if.end40:                                         ; preds = %if.end39, %if.then6
  br label %if.end41

if.end41:                                         ; preds = %if.end40, %if.then3
  %10 = load i16, i16* %TYPE, align 2
  %conv = sext i16 %10 to i32
  %cmp42 = icmp eq i32 %conv, 2
  br i1 %cmp42, label %if.then44, label %if.else71

if.then44:                                        ; preds = %if.end41
  %11 = load i32, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
  %mul = mul i32 8, %11
  %call45 = call noalias i8* @malloc(i32 %mul)
  %12 = bitcast i8* %call45 to double*
  store double* %12, double** %bonferroni, align 4
  %13 = load double*, double** %bonferroni, align 4
  %cmp46 = icmp eq double* %13, null
  br i1 %cmp46, label %if.then48, label %if.end50

if.then48:                                        ; preds = %if.then44
  %call49 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([33 x i8], [33 x i8]* @.str.3, i32 0, i32 0), i8* getelementptr inbounds ([23 x i8], [23 x i8]* @.str.1, i32 0, i32 0), i32 247)
  call void @perror(i8* getelementptr inbounds ([1 x i8], [1 x i8]* @.str.2, i32 0, i32 0))
  call void @exit(i32 1) #5
  unreachable

if.end50:                                         ; preds = %if.then44
  store i32 0, i32* %index, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.end50
  %14 = load i32, i32* %index, align 4
  %15 = load i32, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
  %cmp51 = icmp ult i32 %14, %15
  br i1 %cmp51, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %16 = load double*, double** %PVALUES.addr, align 4
  %17 = load i32, i32* %index, align 4
  %arrayidx = getelementptr inbounds double, double* %16, i32 %17
  %18 = load double, double* %arrayidx, align 8
  %19 = load i32, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
  %conv53 = uitofp i32 %19 to double
  %mul54 = fmul double %18, %conv53
  store double %mul54, double* %BONFERRONI, align 8
  %20 = load double, double* %BONFERRONI, align 8
  %cmp55 = fcmp oge double %20, 1.000000e+00
  br i1 %cmp55, label %if.then57, label %if.else59

if.then57:                                        ; preds = %for.body
  %21 = load double*, double** %bonferroni, align 4
  %22 = load i32, i32* %index, align 4
  %arrayidx58 = getelementptr inbounds double, double* %21, i32 %22
  store double 1.000000e+00, double* %arrayidx58, align 8
  br label %if.end70

if.else59:                                        ; preds = %for.body
  %23 = load double, double* %BONFERRONI, align 8
  %cmp60 = fcmp ole double 0.000000e+00, %23
  br i1 %cmp60, label %land.lhs.true, label %if.else66

land.lhs.true:                                    ; preds = %if.else59
  %24 = load double, double* %BONFERRONI, align 8
  %cmp62 = fcmp olt double %24, 1.000000e+00
  br i1 %cmp62, label %if.then64, label %if.else66

if.then64:                                        ; preds = %land.lhs.true
  %25 = load double, double* %BONFERRONI, align 8
  %26 = load double*, double** %bonferroni, align 4
  %27 = load i32, i32* %index, align 4
  %arrayidx65 = getelementptr inbounds double, double* %26, i32 %27
  store double %25, double* %arrayidx65, align 8
  br label %if.end69

if.else66:                                        ; preds = %land.lhs.true, %if.else59
  %28 = load double, double* %BONFERRONI, align 8
  %call67 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([42 x i8], [42 x i8]* @.str.22, i32 0, i32 0), double %28)
  %call68 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([23 x i8], [23 x i8]* @.str.23, i32 0, i32 0), i8* getelementptr inbounds ([23 x i8], [23 x i8]* @.str.1, i32 0, i32 0), i32 259)
  call void @exit(i32 1) #5
  unreachable

if.end69:                                         ; preds = %if.then64
  br label %if.end70

if.end70:                                         ; preds = %if.end69, %if.then57
  br label %for.inc

for.inc:                                          ; preds = %if.end70
  %29 = load i32, i32* %index, align 4
  %inc = add i32 %29, 1
  store i32 %inc, i32* %index, align 4
  br label %for.cond

for.end:                                          ; preds = %for.cond
  %30 = load double*, double** %bonferroni, align 4
  store double* %30, double** %retval, align 4
  br label %return

if.else71:                                        ; preds = %if.end41
  %31 = load i16, i16* %TYPE, align 2
  %conv72 = sext i16 %31 to i32
  %cmp73 = icmp eq i32 %conv72, 4
  br i1 %cmp73, label %if.then75, label %if.else109

if.then75:                                        ; preds = %if.else71
  %32 = load double*, double** %PVALUES.addr, align 4
  %33 = load i32, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
  %call76 = call i32* @order(double* %32, i32 %33, i1 zeroext false)
  store i32* %call76, i32** %o, align 4
  %34 = load i32*, i32** %o, align 4
  %35 = load i32, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
  %call77 = call double* @uint2double(i32* %34, i32 %35)
  store double* %call77, double** %o2double, align 4
  %36 = load i32, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
  %mul78 = mul i32 8, %36
  %call79 = call noalias i8* @malloc(i32 %mul78)
  %37 = bitcast i8* %call79 to double*
  store double* %37, double** %cummax_input, align 4
  store i32 0, i32* %index80, align 4
  br label %for.cond81

for.cond81:                                       ; preds = %for.inc90, %if.then75
  %38 = load i32, i32* %index80, align 4
  %39 = load i32, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
  %cmp82 = icmp ult i32 %38, %39
  br i1 %cmp82, label %for.body84, label %for.end92

for.body84:                                       ; preds = %for.cond81
  %40 = load i32, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
  %41 = load i32, i32* %index80, align 4
  %sub = sub i32 %40, %41
  %conv85 = uitofp i32 %sub to double
  %42 = load double*, double** %PVALUES.addr, align 4
  %43 = load i32*, i32** %o, align 4
  %44 = load i32, i32* %index80, align 4
  %arrayidx86 = getelementptr inbounds i32, i32* %43, i32 %44
  %45 = load i32, i32* %arrayidx86, align 4
  %arrayidx87 = getelementptr inbounds double, double* %42, i32 %45
  %46 = load double, double* %arrayidx87, align 8
  %mul88 = fmul double %conv85, %46
  %47 = load double*, double** %cummax_input, align 4
  %48 = load i32, i32* %index80, align 4
  %arrayidx89 = getelementptr inbounds double, double* %47, i32 %48
  store double %mul88, double* %arrayidx89, align 8
  br label %for.inc90

for.inc90:                                        ; preds = %for.body84
  %49 = load i32, i32* %index80, align 4
  %inc91 = add i32 %49, 1
  store i32 %inc91, i32* %index80, align 4
  br label %for.cond81

for.end92:                                        ; preds = %for.cond81
  %50 = load i32*, i32** %o, align 4
  %51 = bitcast i32* %50 to i8*
  call void @free(i8* %51)
  store i32* null, i32** %o, align 4
  %52 = load double*, double** %o2double, align 4
  %53 = load i32, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
  %call93 = call i32* @order(double* %52, i32 %53, i1 zeroext false)
  store i32* %call93, i32** %ro, align 4
  %54 = load double*, double** %o2double, align 4
  %55 = bitcast double* %54 to i8*
  call void @free(i8* %55)
  store double* null, double** %o2double, align 4
  %56 = load double*, double** %cummax_input, align 4
  %57 = load i32, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
  %call94 = call double* @cummax(double* %56, i32 %57)
  store double* %call94, double** %cummax_output, align 4
  %58 = load double*, double** %cummax_input, align 4
  %59 = bitcast double* %58 to i8*
  call void @free(i8* %59)
  store double* null, double** %cummax_input, align 4
  %60 = load double*, double** %cummax_output, align 4
  %61 = load i32, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
  %call95 = call double* @pminx(double* %60, i32 %61, double 1.000000e+00)
  store double* %call95, double** %pmin, align 4
  %62 = load double*, double** %cummax_output, align 4
  %63 = bitcast double* %62 to i8*
  call void @free(i8* %63)
  store double* null, double** %cummax_output, align 4
  %64 = load i32, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
  %mul96 = mul i32 8, %64
  %call97 = call noalias i8* @malloc(i32 %mul96)
  %65 = bitcast i8* %call97 to double*
  store double* %65, double** %qvalues, align 4
  store i32 0, i32* %index98, align 4
  br label %for.cond99

for.cond99:                                       ; preds = %for.inc106, %for.end92
  %66 = load i32, i32* %index98, align 4
  %67 = load i32, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
  %cmp100 = icmp ult i32 %66, %67
  br i1 %cmp100, label %for.body102, label %for.end108

for.body102:                                      ; preds = %for.cond99
  %68 = load double*, double** %pmin, align 4
  %69 = load i32*, i32** %ro, align 4
  %70 = load i32, i32* %index98, align 4
  %arrayidx103 = getelementptr inbounds i32, i32* %69, i32 %70
  %71 = load i32, i32* %arrayidx103, align 4
  %arrayidx104 = getelementptr inbounds double, double* %68, i32 %71
  %72 = load double, double* %arrayidx104, align 8
  %73 = load double*, double** %qvalues, align 4
  %74 = load i32, i32* %index98, align 4
  %arrayidx105 = getelementptr inbounds double, double* %73, i32 %74
  store double %72, double* %arrayidx105, align 8
  br label %for.inc106

for.inc106:                                       ; preds = %for.body102
  %75 = load i32, i32* %index98, align 4
  %inc107 = add i32 %75, 1
  store i32 %inc107, i32* %index98, align 4
  br label %for.cond99

for.end108:                                       ; preds = %for.cond99
  %76 = load double*, double** %pmin, align 4
  %77 = bitcast double* %76 to i8*
  call void @free(i8* %77)
  store double* null, double** %pmin, align 4
  %78 = load i32*, i32** %ro, align 4
  %79 = bitcast i32* %78 to i8*
  call void @free(i8* %79)
  store i32* null, i32** %ro, align 4
  %80 = load double*, double** %qvalues, align 4
  store double* %80, double** %retval, align 4
  br label %return

if.else109:                                       ; preds = %if.else71
  %81 = load i16, i16* %TYPE, align 2
  %conv110 = sext i16 %81 to i32
  %cmp111 = icmp eq i32 %conv110, 5
  br i1 %cmp111, label %if.then113, label %if.end285

if.then113:                                       ; preds = %if.else109
  %82 = load double*, double** %PVALUES.addr, align 4
  %83 = load i32, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
  %call115 = call i32* @order(double* %82, i32 %83, i1 zeroext false)
  store i32* %call115, i32** %o114, align 4
  %84 = load i32, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
  %mul116 = mul i32 8, %84
  %call117 = call noalias i8* @malloc(i32 %mul116)
  %85 = bitcast i8* %call117 to double*
  store double* %85, double** %p, align 4
  %86 = load double*, double** %p, align 4
  %cmp118 = icmp eq double* %86, null
  br i1 %cmp118, label %if.then120, label %if.end122

if.then120:                                       ; preds = %if.then113
  %call121 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([33 x i8], [33 x i8]* @.str.3, i32 0, i32 0), i8* getelementptr inbounds ([23 x i8], [23 x i8]* @.str.1, i32 0, i32 0), i32 302)
  call void @perror(i8* getelementptr inbounds ([1 x i8], [1 x i8]* @.str.2, i32 0, i32 0))
  call void @exit(i32 1) #5
  unreachable

if.end122:                                        ; preds = %if.then113
  store i32 0, i32* %index123, align 4
  br label %for.cond124

for.cond124:                                      ; preds = %for.inc131, %if.end122
  %87 = load i32, i32* %index123, align 4
  %88 = load i32, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
  %cmp125 = icmp ult i32 %87, %88
  br i1 %cmp125, label %for.body127, label %for.end133

for.body127:                                      ; preds = %for.cond124
  %89 = load double*, double** %PVALUES.addr, align 4
  %90 = load i32*, i32** %o114, align 4
  %91 = load i32, i32* %index123, align 4
  %arrayidx128 = getelementptr inbounds i32, i32* %90, i32 %91
  %92 = load i32, i32* %arrayidx128, align 4
  %arrayidx129 = getelementptr inbounds double, double* %89, i32 %92
  %93 = load double, double* %arrayidx129, align 8
  %94 = load double*, double** %p, align 4
  %95 = load i32, i32* %index123, align 4
  %arrayidx130 = getelementptr inbounds double, double* %94, i32 %95
  store double %93, double* %arrayidx130, align 8
  br label %for.inc131

for.inc131:                                       ; preds = %for.body127
  %96 = load i32, i32* %index123, align 4
  %inc132 = add i32 %96, 1
  store i32 %inc132, i32* %index123, align 4
  br label %for.cond124

for.end133:                                       ; preds = %for.cond124
  %97 = load i32*, i32** %o114, align 4
  %98 = load i32, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
  %call135 = call double* @uint2double(i32* %97, i32 %98)
  store double* %call135, double** %o2double134, align 4
  %99 = load i32*, i32** %o114, align 4
  %100 = bitcast i32* %99 to i8*
  call void @free(i8* %100)
  store i32* null, i32** %o114, align 4
  %101 = load double*, double** %o2double134, align 4
  %102 = load i32, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
  %call137 = call i32* @order(double* %101, i32 %102, i1 zeroext false)
  store i32* %call137, i32** %ro136, align 4
  %103 = load double*, double** %o2double134, align 4
  %104 = bitcast double* %103 to i8*
  call void @free(i8* %104)
  store double* null, double** %o2double134, align 4
  %105 = load i32, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
  %mul138 = mul i32 8, %105
  %call139 = call noalias i8* @malloc(i32 %mul138)
  %106 = bitcast i8* %call139 to double*
  store double* %106, double** %q, align 4
  %107 = load double*, double** %q, align 4
  %cmp140 = icmp eq double* %107, null
  br i1 %cmp140, label %if.then142, label %if.end144

if.then142:                                       ; preds = %for.end133
  %call143 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([33 x i8], [33 x i8]* @.str.3, i32 0, i32 0), i8* getelementptr inbounds ([23 x i8], [23 x i8]* @.str.1, i32 0, i32 0), i32 318)
  call void @perror(i8* getelementptr inbounds ([1 x i8], [1 x i8]* @.str.2, i32 0, i32 0))
  call void @exit(i32 1) #5
  unreachable

if.end144:                                        ; preds = %for.end133
  %108 = load i32, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
  %mul145 = mul i32 8, %108
  %call146 = call noalias i8* @malloc(i32 %mul145)
  %109 = bitcast i8* %call146 to double*
  store double* %109, double** %pa, align 4
  %110 = load double*, double** %pa, align 4
  %cmp147 = icmp eq double* %110, null
  br i1 %cmp147, label %if.then149, label %if.end151

if.then149:                                       ; preds = %if.end144
  %call150 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([33 x i8], [33 x i8]* @.str.3, i32 0, i32 0), i8* getelementptr inbounds ([23 x i8], [23 x i8]* @.str.1, i32 0, i32 0), i32 324)
  call void @perror(i8* getelementptr inbounds ([1 x i8], [1 x i8]* @.str.2, i32 0, i32 0))
  call void @exit(i32 1) #5
  unreachable

if.end151:                                        ; preds = %if.end144
  %111 = load i32, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
  %conv152 = uitofp i32 %111 to double
  %112 = load double*, double** %p, align 4
  %arrayidx153 = getelementptr inbounds double, double* %112, i32 0
  %113 = load double, double* %arrayidx153, align 8
  %mul154 = fmul double %conv152, %113
  store double %mul154, double* %min, align 8
  store i32 1, i32* %index155, align 4
  br label %for.cond156

for.cond156:                                      ; preds = %for.inc168, %if.end151
  %114 = load i32, i32* %index155, align 4
  %115 = load i32, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
  %cmp157 = icmp ult i32 %114, %115
  br i1 %cmp157, label %for.body159, label %for.end170

for.body159:                                      ; preds = %for.cond156
  %116 = load i32, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
  %conv160 = uitofp i32 %116 to double
  %117 = load double*, double** %p, align 4
  %118 = load i32, i32* %index155, align 4
  %arrayidx161 = getelementptr inbounds double, double* %117, i32 %118
  %119 = load double, double* %arrayidx161, align 8
  %mul162 = fmul double %conv160, %119
  %120 = load i32, i32* %index155, align 4
  %add = add i32 1, %120
  %conv163 = uitofp i32 %add to double
  %div = fdiv double %mul162, %conv163
  store double %div, double* %TEMP, align 8
  %121 = load double, double* %TEMP, align 8
  %122 = load double, double* %min, align 8
  %cmp164 = fcmp olt double %121, %122
  br i1 %cmp164, label %if.then166, label %if.end167

if.then166:                                       ; preds = %for.body159
  %123 = load double, double* %TEMP, align 8
  store double %123, double* %min, align 8
  br label %if.end167

if.end167:                                        ; preds = %if.then166, %for.body159
  br label %for.inc168

for.inc168:                                       ; preds = %if.end167
  %124 = load i32, i32* %index155, align 4
  %inc169 = add i32 %124, 1
  store i32 %inc169, i32* %index155, align 4
  br label %for.cond156

for.end170:                                       ; preds = %for.cond156
  store i32 0, i32* %index171, align 4
  br label %for.cond172

for.cond172:                                      ; preds = %for.inc178, %for.end170
  %125 = load i32, i32* %index171, align 4
  %126 = load i32, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
  %cmp173 = icmp ult i32 %125, %126
  br i1 %cmp173, label %for.body175, label %for.end180

for.body175:                                      ; preds = %for.cond172
  %127 = load double, double* %min, align 8
  %128 = load double*, double** %pa, align 4
  %129 = load i32, i32* %index171, align 4
  %arrayidx176 = getelementptr inbounds double, double* %128, i32 %129
  store double %127, double* %arrayidx176, align 8
  %130 = load double, double* %min, align 8
  %131 = load double*, double** %q, align 4
  %132 = load i32, i32* %index171, align 4
  %arrayidx177 = getelementptr inbounds double, double* %131, i32 %132
  store double %130, double* %arrayidx177, align 8
  br label %for.inc178

for.inc178:                                       ; preds = %for.body175
  %133 = load i32, i32* %index171, align 4
  %inc179 = add i32 %133, 1
  store i32 %inc179, i32* %index171, align 4
  br label %for.cond172

for.end180:                                       ; preds = %for.cond172
  %134 = load i32, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
  %sub181 = sub i32 %134, 1
  store i32 %sub181, i32* %j, align 4
  br label %for.cond182

for.cond182:                                      ; preds = %for.inc272, %for.end180
  %135 = load i32, i32* %j, align 4
  %cmp183 = icmp uge i32 %135, 2
  br i1 %cmp183, label %for.body185, label %for.end273

for.body185:                                      ; preds = %for.cond182
  %136 = load i32, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
  %137 = load i32, i32* %j, align 4
  %sub186 = sub i32 %136, %137
  %call187 = call i32* @seq_len(i32 0, i32 %sub186)
  store i32* %call187, i32** %ij, align 4
  %138 = load i32, i32* %j, align 4
  %sub188 = sub i32 %138, 1
  store i32 %sub188, i32* %I2_LENGTH, align 4
  %139 = load i32, i32* %I2_LENGTH, align 4
  %mul189 = mul i32 %139, 4
  %call190 = call noalias i8* @malloc(i32 %mul189)
  %140 = bitcast i8* %call190 to i32*
  store i32* %140, i32** %i2, align 4
  store i32 0, i32* %i, align 4
  br label %for.cond191

for.cond191:                                      ; preds = %for.inc200, %for.body185
  %141 = load i32, i32* %i, align 4
  %142 = load i32, i32* %I2_LENGTH, align 4
  %cmp192 = icmp ult i32 %141, %142
  br i1 %cmp192, label %for.body194, label %for.end202

for.body194:                                      ; preds = %for.cond191
  %143 = load i32, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
  %144 = load i32, i32* %j, align 4
  %sub195 = sub i32 %143, %144
  %add196 = add i32 %sub195, 2
  %145 = load i32, i32* %i, align 4
  %add197 = add i32 %add196, %145
  %sub198 = sub i32 %add197, 1
  %146 = load i32*, i32** %i2, align 4
  %147 = load i32, i32* %i, align 4
  %arrayidx199 = getelementptr inbounds i32, i32* %146, i32 %147
  store i32 %sub198, i32* %arrayidx199, align 4
  br label %for.inc200

for.inc200:                                       ; preds = %for.body194
  %148 = load i32, i32* %i, align 4
  %inc201 = add i32 %148, 1
  store i32 %inc201, i32* %i, align 4
  br label %for.cond191

for.end202:                                       ; preds = %for.cond191
  %149 = load i32, i32* %j, align 4
  %conv203 = uitofp i32 %149 to double
  %150 = load double*, double** %p, align 4
  %151 = load i32*, i32** %i2, align 4
  %arrayidx204 = getelementptr inbounds i32, i32* %151, i32 0
  %152 = load i32, i32* %arrayidx204, align 4
  %arrayidx205 = getelementptr inbounds double, double* %150, i32 %152
  %153 = load double, double* %arrayidx205, align 8
  %mul206 = fmul double %conv203, %153
  %div207 = fdiv double %mul206, 2.000000e+00
  store double %div207, double* %q1, align 8
  store i32 1, i32* %i208, align 4
  br label %for.cond209

for.cond209:                                      ; preds = %for.inc224, %for.end202
  %154 = load i32, i32* %i208, align 4
  %155 = load i32, i32* %I2_LENGTH, align 4
  %cmp210 = icmp ult i32 %154, %155
  br i1 %cmp210, label %for.body212, label %for.end226

for.body212:                                      ; preds = %for.cond209
  %156 = load i32, i32* %j, align 4
  %conv213 = uitofp i32 %156 to double
  %157 = load double*, double** %p, align 4
  %158 = load i32*, i32** %i2, align 4
  %159 = load i32, i32* %i208, align 4
  %arrayidx214 = getelementptr inbounds i32, i32* %158, i32 %159
  %160 = load i32, i32* %arrayidx214, align 4
  %arrayidx215 = getelementptr inbounds double, double* %157, i32 %160
  %161 = load double, double* %arrayidx215, align 8
  %mul216 = fmul double %conv213, %161
  %162 = load i32, i32* %i208, align 4
  %add217 = add i32 2, %162
  %conv218 = uitofp i32 %add217 to double
  %div219 = fdiv double %mul216, %conv218
  store double %div219, double* %TEMP_Q1, align 8
  %163 = load double, double* %TEMP_Q1, align 8
  %164 = load double, double* %q1, align 8
  %cmp220 = fcmp olt double %163, %164
  br i1 %cmp220, label %if.then222, label %if.end223

if.then222:                                       ; preds = %for.body212
  %165 = load double, double* %TEMP_Q1, align 8
  store double %165, double* %q1, align 8
  br label %if.end223

if.end223:                                        ; preds = %if.then222, %for.body212
  br label %for.inc224

for.inc224:                                       ; preds = %if.end223
  %166 = load i32, i32* %i208, align 4
  %inc225 = add i32 %166, 1
  store i32 %inc225, i32* %i208, align 4
  br label %for.cond209

for.end226:                                       ; preds = %for.cond209
  store i32 0, i32* %i227, align 4
  br label %for.cond228

for.cond228:                                      ; preds = %for.inc241, %for.end226
  %167 = load i32, i32* %i227, align 4
  %168 = load i32, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
  %169 = load i32, i32* %j, align 4
  %sub229 = sub i32 %168, %169
  %add230 = add i32 %sub229, 1
  %cmp231 = icmp ult i32 %167, %add230
  br i1 %cmp231, label %for.body233, label %for.end243

for.body233:                                      ; preds = %for.cond228
  %170 = load i32, i32* %j, align 4
  %conv234 = uitofp i32 %170 to double
  %171 = load double*, double** %p, align 4
  %172 = load i32*, i32** %ij, align 4
  %173 = load i32, i32* %i227, align 4
  %arrayidx235 = getelementptr inbounds i32, i32* %172, i32 %173
  %174 = load i32, i32* %arrayidx235, align 4
  %arrayidx236 = getelementptr inbounds double, double* %171, i32 %174
  %175 = load double, double* %arrayidx236, align 8
  %mul237 = fmul double %conv234, %175
  %176 = load double, double* %q1, align 8
  %call238 = call double @min2(double %mul237, double %176)
  %177 = load double*, double** %q, align 4
  %178 = load i32*, i32** %ij, align 4
  %179 = load i32, i32* %i227, align 4
  %arrayidx239 = getelementptr inbounds i32, i32* %178, i32 %179
  %180 = load i32, i32* %arrayidx239, align 4
  %arrayidx240 = getelementptr inbounds double, double* %177, i32 %180
  store double %call238, double* %arrayidx240, align 8
  br label %for.inc241

for.inc241:                                       ; preds = %for.body233
  %181 = load i32, i32* %i227, align 4
  %inc242 = add i32 %181, 1
  store i32 %inc242, i32* %i227, align 4
  br label %for.cond228

for.end243:                                       ; preds = %for.cond228
  %182 = load i32*, i32** %ij, align 4
  %183 = bitcast i32* %182 to i8*
  call void @free(i8* %183)
  store i32* null, i32** %ij, align 4
  store i32 0, i32* %i244, align 4
  br label %for.cond245

for.cond245:                                      ; preds = %for.inc253, %for.end243
  %184 = load i32, i32* %i244, align 4
  %185 = load i32, i32* %I2_LENGTH, align 4
  %cmp246 = icmp ult i32 %184, %185
  br i1 %cmp246, label %for.body248, label %for.end255

for.body248:                                      ; preds = %for.cond245
  %186 = load double*, double** %q, align 4
  %187 = load i32, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
  %188 = load i32, i32* %j, align 4
  %sub249 = sub i32 %187, %188
  %arrayidx250 = getelementptr inbounds double, double* %186, i32 %sub249
  %189 = load double, double* %arrayidx250, align 8
  %190 = load double*, double** %q, align 4
  %191 = load i32*, i32** %i2, align 4
  %192 = load i32, i32* %i244, align 4
  %arrayidx251 = getelementptr inbounds i32, i32* %191, i32 %192
  %193 = load i32, i32* %arrayidx251, align 4
  %arrayidx252 = getelementptr inbounds double, double* %190, i32 %193
  store double %189, double* %arrayidx252, align 8
  br label %for.inc253

for.inc253:                                       ; preds = %for.body248
  %194 = load i32, i32* %i244, align 4
  %inc254 = add i32 %194, 1
  store i32 %inc254, i32* %i244, align 4
  br label %for.cond245

for.end255:                                       ; preds = %for.cond245
  %195 = load i32*, i32** %i2, align 4
  %196 = bitcast i32* %195 to i8*
  call void @free(i8* %196)
  store i32* null, i32** %i2, align 4
  store i32 0, i32* %i256, align 4
  br label %for.cond257

for.cond257:                                      ; preds = %for.inc269, %for.end255
  %197 = load i32, i32* %i256, align 4
  %198 = load i32, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
  %cmp258 = icmp ult i32 %197, %198
  br i1 %cmp258, label %for.body260, label %for.end271

for.body260:                                      ; preds = %for.cond257
  %199 = load double*, double** %pa, align 4
  %200 = load i32, i32* %i256, align 4
  %arrayidx261 = getelementptr inbounds double, double* %199, i32 %200
  %201 = load double, double* %arrayidx261, align 8
  %202 = load double*, double** %q, align 4
  %203 = load i32, i32* %i256, align 4
  %arrayidx262 = getelementptr inbounds double, double* %202, i32 %203
  %204 = load double, double* %arrayidx262, align 8
  %cmp263 = fcmp olt double %201, %204
  br i1 %cmp263, label %if.then265, label %if.end268

if.then265:                                       ; preds = %for.body260
  %205 = load double*, double** %q, align 4
  %206 = load i32, i32* %i256, align 4
  %arrayidx266 = getelementptr inbounds double, double* %205, i32 %206
  %207 = load double, double* %arrayidx266, align 8
  %208 = load double*, double** %pa, align 4
  %209 = load i32, i32* %i256, align 4
  %arrayidx267 = getelementptr inbounds double, double* %208, i32 %209
  store double %207, double* %arrayidx267, align 8
  br label %if.end268

if.end268:                                        ; preds = %if.then265, %for.body260
  br label %for.inc269

for.inc269:                                       ; preds = %if.end268
  %210 = load i32, i32* %i256, align 4
  %inc270 = add i32 %210, 1
  store i32 %inc270, i32* %i256, align 4
  br label %for.cond257

for.end271:                                       ; preds = %for.cond257
  br label %for.inc272

for.inc272:                                       ; preds = %for.end271
  %211 = load i32, i32* %j, align 4
  %dec = add i32 %211, -1
  store i32 %dec, i32* %j, align 4
  br label %for.cond182

for.end273:                                       ; preds = %for.cond182
  %212 = load double*, double** %p, align 4
  %213 = bitcast double* %212 to i8*
  call void @free(i8* %213)
  store double* null, double** %p, align 4
  store i32 0, i32* %index274, align 4
  br label %for.cond275

for.cond275:                                      ; preds = %for.inc282, %for.end273
  %214 = load i32, i32* %index274, align 4
  %215 = load i32, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
  %cmp276 = icmp ult i32 %214, %215
  br i1 %cmp276, label %for.body278, label %for.end284

for.body278:                                      ; preds = %for.cond275
  %216 = load double*, double** %pa, align 4
  %217 = load i32*, i32** %ro136, align 4
  %218 = load i32, i32* %index274, align 4
  %arrayidx279 = getelementptr inbounds i32, i32* %217, i32 %218
  %219 = load i32, i32* %arrayidx279, align 4
  %arrayidx280 = getelementptr inbounds double, double* %216, i32 %219
  %220 = load double, double* %arrayidx280, align 8
  %221 = load double*, double** %q, align 4
  %222 = load i32, i32* %index274, align 4
  %arrayidx281 = getelementptr inbounds double, double* %221, i32 %222
  store double %220, double* %arrayidx281, align 8
  br label %for.inc282

for.inc282:                                       ; preds = %for.body278
  %223 = load i32, i32* %index274, align 4
  %inc283 = add i32 %223, 1
  store i32 %inc283, i32* %index274, align 4
  br label %for.cond275

for.end284:                                       ; preds = %for.cond275
  %224 = load i32*, i32** %ro136, align 4
  %225 = bitcast i32* %224 to i8*
  call void @free(i8* %225)
  store i32* null, i32** %ro136, align 4
  %226 = load double*, double** %pa, align 4
  %227 = bitcast double* %226 to i8*
  call void @free(i8* %227)
  store double* null, double** %pa, align 4
  %228 = load double*, double** %q, align 4
  store double* %228, double** %retval, align 4
  br label %return

if.end285:                                        ; preds = %if.else109
  br label %if.end286

if.end286:                                        ; preds = %if.end285
  br label %if.end287

if.end287:                                        ; preds = %if.end286
  %229 = load double*, double** %PVALUES.addr, align 4
  %230 = load i32, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
  %call289 = call i32* @order(double* %229, i32 %230, i1 zeroext true)
  store i32* %call289, i32** %o288, align 4
  %231 = load i32*, i32** %o288, align 4
  %cmp290 = icmp eq i32* %231, null
  br i1 %cmp290, label %if.then292, label %if.end294

if.then292:                                       ; preds = %if.end287
  %call293 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([33 x i8], [33 x i8]* @.str.3, i32 0, i32 0), i8* getelementptr inbounds ([23 x i8], [23 x i8]* @.str.1, i32 0, i32 0), i32 398)
  call void @perror(i8* getelementptr inbounds ([1 x i8], [1 x i8]* @.str.2, i32 0, i32 0))
  call void @exit(i32 1) #5
  unreachable

if.end294:                                        ; preds = %if.end287
  %232 = load i32*, i32** %o288, align 4
  %233 = load i32, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
  %call295 = call double* @uint2double(i32* %232, i32 %233)
  store double* %call295, double** %o_double, align 4
  store i32 0, i32* %index296, align 4
  br label %for.cond297

for.cond297:                                      ; preds = %for.inc312, %if.end294
  %234 = load i32, i32* %index296, align 4
  %235 = load i32, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
  %cmp298 = icmp ult i32 %234, %235
  br i1 %cmp298, label %for.body300, label %for.end314

for.body300:                                      ; preds = %for.cond297
  %236 = load double*, double** %PVALUES.addr, align 4
  %237 = load i32, i32* %index296, align 4
  %arrayidx301 = getelementptr inbounds double, double* %236, i32 %237
  %238 = load double, double* %arrayidx301, align 8
  %cmp302 = fcmp olt double %238, 0.000000e+00
  br i1 %cmp302, label %if.then307, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %for.body300
  %239 = load double*, double** %PVALUES.addr, align 4
  %240 = load i32, i32* %index296, align 4
  %arrayidx304 = getelementptr inbounds double, double* %239, i32 %240
  %241 = load double, double* %arrayidx304, align 8
  %cmp305 = fcmp ogt double %241, 1.000000e+00
  br i1 %cmp305, label %if.then307, label %if.end311

if.then307:                                       ; preds = %lor.lhs.false, %for.body300
  %242 = load i32, i32* %index296, align 4
  %243 = load double*, double** %PVALUES.addr, align 4
  %244 = load i32, i32* %index296, align 4
  %arrayidx308 = getelementptr inbounds double, double* %243, i32 %244
  %245 = load double, double* %arrayidx308, align 8
  %call309 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([54 x i8], [54 x i8]* @.str.24, i32 0, i32 0), i32 %242, double %245)
  %call310 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([20 x i8], [20 x i8]* @.str.25, i32 0, i32 0), i8* getelementptr inbounds ([23 x i8], [23 x i8]* @.str.1, i32 0, i32 0), i32 406)
  call void @exit(i32 1) #5
  unreachable

if.end311:                                        ; preds = %lor.lhs.false
  br label %for.inc312

for.inc312:                                       ; preds = %if.end311
  %246 = load i32, i32* %index296, align 4
  %inc313 = add i32 %246, 1
  store i32 %inc313, i32* %index296, align 4
  br label %for.cond297

for.end314:                                       ; preds = %for.cond297
  %247 = load double*, double** %o_double, align 4
  %248 = load i32, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
  %call316 = call i32* @order(double* %247, i32 %248, i1 zeroext false)
  store i32* %call316, i32** %ro315, align 4
  %249 = load i32*, i32** %ro315, align 4
  %cmp317 = icmp eq i32* %249, null
  br i1 %cmp317, label %if.then319, label %if.end321

if.then319:                                       ; preds = %for.end314
  %call320 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([33 x i8], [33 x i8]* @.str.3, i32 0, i32 0), i8* getelementptr inbounds ([23 x i8], [23 x i8]* @.str.1, i32 0, i32 0), i32 413)
  call void @perror(i8* getelementptr inbounds ([1 x i8], [1 x i8]* @.str.2, i32 0, i32 0))
  call void @exit(i32 1) #5
  unreachable

if.end321:                                        ; preds = %for.end314
  %250 = load double*, double** %o_double, align 4
  %251 = bitcast double* %250 to i8*
  call void @free(i8* %251)
  store double* null, double** %o_double, align 4
  %252 = load i32, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
  %mul322 = mul i32 8, %252
  %call323 = call noalias i8* @malloc(i32 %mul322)
  %253 = bitcast i8* %call323 to double*
  store double* %253, double** %cummin_input, align 4
  %254 = load i16, i16* %TYPE, align 2
  %conv324 = sext i16 %254 to i32
  %cmp325 = icmp eq i32 %conv324, 0
  br i1 %cmp325, label %if.then327, label %if.else344

if.then327:                                       ; preds = %if.end321
  store i32 0, i32* %index328, align 4
  br label %for.cond329

for.cond329:                                      ; preds = %for.inc341, %if.then327
  %255 = load i32, i32* %index328, align 4
  %256 = load i32, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
  %cmp330 = icmp ult i32 %255, %256
  br i1 %cmp330, label %for.body332, label %for.end343

for.body332:                                      ; preds = %for.cond329
  %257 = load i32, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
  %conv333 = uitofp i32 %257 to double
  %258 = load i32, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
  %259 = load i32, i32* %index328, align 4
  %sub334 = sub i32 %258, %259
  %conv335 = uitofp i32 %sub334 to double
  %div336 = fdiv double %conv333, %conv335
  store double %div336, double* %NI, align 8
  %260 = load double, double* %NI, align 8
  %261 = load double*, double** %PVALUES.addr, align 4
  %262 = load i32*, i32** %o288, align 4
  %263 = load i32, i32* %index328, align 4
  %arrayidx337 = getelementptr inbounds i32, i32* %262, i32 %263
  %264 = load i32, i32* %arrayidx337, align 4
  %arrayidx338 = getelementptr inbounds double, double* %261, i32 %264
  %265 = load double, double* %arrayidx338, align 8
  %mul339 = fmul double %260, %265
  %266 = load double*, double** %cummin_input, align 4
  %267 = load i32, i32* %index328, align 4
  %arrayidx340 = getelementptr inbounds double, double* %266, i32 %267
  store double %mul339, double* %arrayidx340, align 8
  br label %for.inc341

for.inc341:                                       ; preds = %for.body332
  %268 = load i32, i32* %index328, align 4
  %inc342 = add i32 %268, 1
  store i32 %inc342, i32* %index328, align 4
  br label %for.cond329

for.end343:                                       ; preds = %for.cond329
  br label %if.end401

if.else344:                                       ; preds = %if.end321
  %269 = load i16, i16* %TYPE, align 2
  %conv345 = sext i16 %269 to i32
  %cmp346 = icmp eq i32 %conv345, 1
  br i1 %cmp346, label %if.then348, label %if.else380

if.then348:                                       ; preds = %if.else344
  store double 1.000000e+00, double* %q349, align 8
  store i32 2, i32* %index350, align 4
  br label %for.cond351

for.cond351:                                      ; preds = %for.inc359, %if.then348
  %270 = load i32, i32* %index350, align 4
  %271 = load i32, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
  %add352 = add i32 1, %271
  %cmp353 = icmp ult i32 %270, %add352
  br i1 %cmp353, label %for.body355, label %for.end361

for.body355:                                      ; preds = %for.cond351
  %272 = load i32, i32* %index350, align 4
  %conv356 = uitofp i32 %272 to double
  %div357 = fdiv double 1.000000e+00, %conv356
  %273 = load double, double* %q349, align 8
  %add358 = fadd double %273, %div357
  store double %add358, double* %q349, align 8
  br label %for.inc359

for.inc359:                                       ; preds = %for.body355
  %274 = load i32, i32* %index350, align 4
  %inc360 = add i32 %274, 1
  store i32 %inc360, i32* %index350, align 4
  br label %for.cond351

for.end361:                                       ; preds = %for.cond351
  store i32 0, i32* %index362, align 4
  br label %for.cond363

for.cond363:                                      ; preds = %for.inc377, %for.end361
  %275 = load i32, i32* %index362, align 4
  %276 = load i32, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
  %cmp364 = icmp ult i32 %275, %276
  br i1 %cmp364, label %for.body366, label %for.end379

for.body366:                                      ; preds = %for.cond363
  %277 = load i32, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
  %conv368 = uitofp i32 %277 to double
  %278 = load i32, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
  %279 = load i32, i32* %index362, align 4
  %sub369 = sub i32 %278, %279
  %conv370 = uitofp i32 %sub369 to double
  %div371 = fdiv double %conv368, %conv370
  store double %div371, double* %NI367, align 8
  %280 = load double, double* %q349, align 8
  %281 = load double, double* %NI367, align 8
  %mul372 = fmul double %280, %281
  %282 = load double*, double** %PVALUES.addr, align 4
  %283 = load i32*, i32** %o288, align 4
  %284 = load i32, i32* %index362, align 4
  %arrayidx373 = getelementptr inbounds i32, i32* %283, i32 %284
  %285 = load i32, i32* %arrayidx373, align 4
  %arrayidx374 = getelementptr inbounds double, double* %282, i32 %285
  %286 = load double, double* %arrayidx374, align 8
  %mul375 = fmul double %mul372, %286
  %287 = load double*, double** %cummin_input, align 4
  %288 = load i32, i32* %index362, align 4
  %arrayidx376 = getelementptr inbounds double, double* %287, i32 %288
  store double %mul375, double* %arrayidx376, align 8
  br label %for.inc377

for.inc377:                                       ; preds = %for.body366
  %289 = load i32, i32* %index362, align 4
  %inc378 = add i32 %289, 1
  store i32 %inc378, i32* %index362, align 4
  br label %for.cond363

for.end379:                                       ; preds = %for.cond363
  br label %if.end400

if.else380:                                       ; preds = %if.else344
  %290 = load i16, i16* %TYPE, align 2
  %conv381 = sext i16 %290 to i32
  %cmp382 = icmp eq i32 %conv381, 3
  br i1 %cmp382, label %if.then384, label %if.end399

if.then384:                                       ; preds = %if.else380
  store i32 0, i32* %index385, align 4
  br label %for.cond386

for.cond386:                                      ; preds = %for.inc396, %if.then384
  %291 = load i32, i32* %index385, align 4
  %292 = load i32, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
  %cmp387 = icmp ult i32 %291, %292
  br i1 %cmp387, label %for.body389, label %for.end398

for.body389:                                      ; preds = %for.cond386
  %293 = load i32, i32* %index385, align 4
  %add390 = add i32 %293, 1
  %conv391 = uitofp i32 %add390 to double
  %294 = load double*, double** %PVALUES.addr, align 4
  %295 = load i32*, i32** %o288, align 4
  %296 = load i32, i32* %index385, align 4
  %arrayidx392 = getelementptr inbounds i32, i32* %295, i32 %296
  %297 = load i32, i32* %arrayidx392, align 4
  %arrayidx393 = getelementptr inbounds double, double* %294, i32 %297
  %298 = load double, double* %arrayidx393, align 8
  %mul394 = fmul double %conv391, %298
  %299 = load double*, double** %cummin_input, align 4
  %300 = load i32, i32* %index385, align 4
  %arrayidx395 = getelementptr inbounds double, double* %299, i32 %300
  store double %mul394, double* %arrayidx395, align 8
  br label %for.inc396

for.inc396:                                       ; preds = %for.body389
  %301 = load i32, i32* %index385, align 4
  %inc397 = add i32 %301, 1
  store i32 %inc397, i32* %index385, align 4
  br label %for.cond386

for.end398:                                       ; preds = %for.cond386
  br label %if.end399

if.end399:                                        ; preds = %for.end398, %if.else380
  br label %if.end400

if.end400:                                        ; preds = %if.end399, %for.end379
  br label %if.end401

if.end401:                                        ; preds = %if.end400, %for.end343
  %302 = load i32*, i32** %o288, align 4
  %303 = bitcast i32* %302 to i8*
  call void @free(i8* %303)
  store i32* null, i32** %o288, align 4
  store double* null, double** %cummin_array, align 4
  %304 = load double*, double** %cummin_input, align 4
  %305 = load i32, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
  %call402 = call double* @cummin(double* %304, i32 %305)
  store double* %call402, double** %cummin_array, align 4
  %306 = load double*, double** %cummin_input, align 4
  %307 = bitcast double* %306 to i8*
  call void @free(i8* %307)
  store double* null, double** %cummin_input, align 4
  %308 = load double*, double** %cummin_array, align 4
  %309 = load i32, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
  %call404 = call double* @pminx(double* %308, i32 %309, double 1.000000e+00)
  store double* %call404, double** %pmin403, align 4
  %310 = load double*, double** %cummin_array, align 4
  %311 = bitcast double* %310 to i8*
  call void @free(i8* %311)
  store double* null, double** %cummin_array, align 4
  %312 = load i32, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
  %mul405 = mul i32 %312, 8
  %call406 = call noalias i8* @malloc(i32 %mul405)
  %313 = bitcast i8* %call406 to double*
  store double* %313, double** %q_array, align 4
  store i32 0, i32* %index407, align 4
  br label %for.cond408

for.cond408:                                      ; preds = %for.inc415, %if.end401
  %314 = load i32, i32* %index407, align 4
  %315 = load i32, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
  %cmp409 = icmp ult i32 %314, %315
  br i1 %cmp409, label %for.body411, label %for.end417

for.body411:                                      ; preds = %for.cond408
  %316 = load double*, double** %pmin403, align 4
  %317 = load i32*, i32** %ro315, align 4
  %318 = load i32, i32* %index407, align 4
  %arrayidx412 = getelementptr inbounds i32, i32* %317, i32 %318
  %319 = load i32, i32* %arrayidx412, align 4
  %arrayidx413 = getelementptr inbounds double, double* %316, i32 %319
  %320 = load double, double* %arrayidx413, align 8
  %321 = load double*, double** %q_array, align 4
  %322 = load i32, i32* %index407, align 4
  %arrayidx414 = getelementptr inbounds double, double* %321, i32 %322
  store double %320, double* %arrayidx414, align 8
  br label %for.inc415

for.inc415:                                       ; preds = %for.body411
  %323 = load i32, i32* %index407, align 4
  %inc416 = add i32 %323, 1
  store i32 %inc416, i32* %index407, align 4
  br label %for.cond408

for.end417:                                       ; preds = %for.cond408
  %324 = load i32*, i32** %ro315, align 4
  %325 = bitcast i32* %324 to i8*
  call void @free(i8* %325)
  store i32* null, i32** %ro315, align 4
  %326 = load double*, double** %pmin403, align 4
  %327 = bitcast double* %326 to i8*
  call void @free(i8* %327)
  store double* null, double** %pmin403, align 4
  %328 = load double*, double** %q_array, align 4
  store double* %328, double** %retval, align 4
  br label %return

return:                                           ; preds = %for.end417, %for.end284, %for.end108, %for.end
  %329 = load double*, double** %retval, align 4
  ret double* %329
}

declare i32 @strcasecmp(i8* %0, i8* %1) #1

; Function Attrs: noinline nounwind optnone
define hidden i32 @main() #0 {
entry:
  %retval = alloca i32, align 4
  %PVALUES = alloca [50 x double], align 16
  %CORRECT_ANSWERS = alloca [6 x [50 x double]], align 16
  %TYPES = alloca [6 x i8*], align 16
  %type = alloca i16, align 2
  %q = alloca double*, align 4
  %error = alloca double, align 8
  %i = alloca i32, align 4
  %this_error = alloca double, align 8
  store i32 0, i32* %retval, align 4
  %0 = bitcast [50 x double]* %PVALUES to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 16 %0, i8* align 16 bitcast ([50 x double]* @__const.main.PVALUES to i8*), i32 400, i1 false)
  %1 = bitcast [6 x [50 x double]]* %CORRECT_ANSWERS to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 16 %1, i8* align 16 bitcast ([6 x [50 x double]]* @__const.main.CORRECT_ANSWERS to i8*), i32 2400, i1 false)
  %2 = bitcast [6 x i8*]* %TYPES to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 16 %2, i8* align 16 bitcast ([6 x i8*]* @__const.main.TYPES to i8*), i32 24, i1 false)
  store i16 0, i16* %type, align 2
  br label %for.cond

for.cond:                                         ; preds = %for.inc19, %entry
  %3 = load i16, i16* %type, align 2
  %conv = zext i16 %3 to i32
  %cmp = icmp sle i32 %conv, 5
  br i1 %cmp, label %for.body, label %for.end21

for.body:                                         ; preds = %for.cond
  %arraydecay = getelementptr inbounds [50 x double], [50 x double]* %PVALUES, i32 0, i32 0
  %4 = load i16, i16* %type, align 2
  %idxprom = zext i16 %4 to i32
  %arrayidx = getelementptr inbounds [6 x i8*], [6 x i8*]* %TYPES, i32 0, i32 %idxprom
  %5 = load i8*, i8** %arrayidx, align 4
  %call = call double* @p_adjust(double* %arraydecay, i32 50, i8* %5)
  store double* %call, double** %q, align 4
  %6 = load double*, double** %q, align 4
  %arrayidx2 = getelementptr inbounds double, double* %6, i32 0
  %7 = load double, double* %arrayidx2, align 8
  %8 = load i16, i16* %type, align 2
  %idxprom3 = zext i16 %8 to i32
  %arrayidx4 = getelementptr inbounds [6 x [50 x double]], [6 x [50 x double]]* %CORRECT_ANSWERS, i32 0, i32 %idxprom3
  %arrayidx5 = getelementptr inbounds [50 x double], [50 x double]* %arrayidx4, i32 0, i32 0
  %9 = load double, double* %arrayidx5, align 16
  %sub = fsub double %7, %9
  %10 = call double @llvm.fabs.f64(double %sub)
  store double %10, double* %error, align 8
  store i32 1, i32* %i, align 4
  br label %for.cond6

for.cond6:                                        ; preds = %for.inc, %for.body
  %11 = load i32, i32* %i, align 4
  %cmp7 = icmp ult i32 %11, 50
  br i1 %cmp7, label %for.body9, label %for.end

for.body9:                                        ; preds = %for.cond6
  %12 = load double*, double** %q, align 4
  %13 = load i32, i32* %i, align 4
  %arrayidx10 = getelementptr inbounds double, double* %12, i32 %13
  %14 = load double, double* %arrayidx10, align 8
  %15 = load i16, i16* %type, align 2
  %idxprom11 = zext i16 %15 to i32
  %arrayidx12 = getelementptr inbounds [6 x [50 x double]], [6 x [50 x double]]* %CORRECT_ANSWERS, i32 0, i32 %idxprom11
  %16 = load i32, i32* %i, align 4
  %arrayidx13 = getelementptr inbounds [50 x double], [50 x double]* %arrayidx12, i32 0, i32 %16
  %17 = load double, double* %arrayidx13, align 8
  %sub14 = fsub double %14, %17
  %18 = call double @llvm.fabs.f64(double %sub14)
  store double %18, double* %this_error, align 8
  %19 = load double, double* %this_error, align 8
  %20 = load double, double* %error, align 8
  %add = fadd double %20, %19
  store double %add, double* %error, align 8
  br label %for.inc

for.inc:                                          ; preds = %for.body9
  %21 = load i32, i32* %i, align 4
  %inc = add i32 %21, 1
  store i32 %inc, i32* %i, align 4
  br label %for.cond6

for.end:                                          ; preds = %for.cond6
  %22 = load double*, double** %q, align 4
  call void @double_say(double* %22, i32 50)
  %23 = load double*, double** %q, align 4
  %24 = bitcast double* %23 to i8*
  call void @free(i8* %24)
  store double* null, double** %q, align 4
  %25 = load i16, i16* %type, align 2
  %conv15 = zext i16 %25 to i32
  %26 = load i16, i16* %type, align 2
  %idxprom16 = zext i16 %26 to i32
  %arrayidx17 = getelementptr inbounds [6 x i8*], [6 x i8*]* %TYPES, i32 0, i32 %idxprom16
  %27 = load i8*, i8** %arrayidx17, align 4
  %28 = load double, double* %error, align 8
  %call18 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([44 x i8], [44 x i8]* @.str.28, i32 0, i32 0), i32 %conv15, i8* %27, double %28)
  br label %for.inc19

for.inc19:                                        ; preds = %for.end
  %29 = load i16, i16* %type, align 2
  %inc20 = add i16 %29, 1
  store i16 %inc20, i16* %type, align 2
  br label %for.cond

for.end21:                                        ; preds = %for.cond
  ret i32 0
}

; Function Attrs: argmemonly nounwind willreturn
declare void @llvm.memcpy.p0i8.p0i8.i32(i8* noalias nocapture writeonly %0, i8* noalias nocapture readonly %1, i32 %2, i1 immarg %3) #3

; Function Attrs: nounwind readnone speculatable willreturn
declare double @llvm.fabs.f64(double %0) #4

attributes #0 = { noinline nounwind optnone "correctly-rounded-divide-sqrt-fp-math"="false" "disable-tail-calls"="false" "frame-pointer"="none" "less-precise-fpmad"="false" "min-legal-vector-width"="0" "no-infs-fp-math"="false" "no-jump-tables"="false" "no-nans-fp-math"="false" "no-signed-zeros-fp-math"="false" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="generic" "unsafe-fp-math"="false" "use-soft-float"="false" }
attributes #1 = { "correctly-rounded-divide-sqrt-fp-math"="false" "disable-tail-calls"="false" "frame-pointer"="none" "less-precise-fpmad"="false" "no-infs-fp-math"="false" "no-nans-fp-math"="false" "no-signed-zeros-fp-math"="false" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="generic" "unsafe-fp-math"="false" "use-soft-float"="false" }
attributes #2 = { noreturn "correctly-rounded-divide-sqrt-fp-math"="false" "disable-tail-calls"="false" "frame-pointer"="none" "less-precise-fpmad"="false" "no-infs-fp-math"="false" "no-nans-fp-math"="false" "no-signed-zeros-fp-math"="false" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="generic" "unsafe-fp-math"="false" "use-soft-float"="false" }
attributes #3 = { argmemonly nounwind willreturn }
attributes #4 = { nounwind readnone speculatable willreturn }
attributes #5 = { noreturn }

!llvm.module.flags = !{!0}
!llvm.ident = !{!1}

!0 = !{i32 1, !"wchar_size", i32 4}
!1 = !{!"clang version 11.0.0 (https://github.com/Jacarte/llvm-project.git 0f6dea67136cc1e0b3d200eb2bb165628970c44b)"}

; extracted candidates

; *****
; For LLVM instruction:
;  %0 = load i32, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %mul = mul i32 8, %0
; Looking for a replacement for:
%0:i32 = var
%1:i32 = mul 8:i32, %0
infer %1

; *****
; For LLVM instruction:
;  %cmp = icmp eq double* %2, null
; Looking for a replacement for:
%0:i32 = var
%1:i1 = eq 0:i32, %0
infer %1

; *****
; For LLVM instruction:
;  %3 = load i32, i32* %index, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %4 = load i32, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %cmp2 = icmp ult i32 %3, %4
; Looking for a replacement for:
%0:i32 = var
%1:i32 = var
%2:i1 = ult %0, %1
infer %2

; *****
; For LLVM instruction:
;  %6 = load i32, i32* %index, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %7 = load i32, i32* %arrayidx, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %9 = load i32, i32* %index, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %10 = load i32, i32* %index, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %inc = add i32 %10, 1
; Looking for a replacement for:
%0:i32 = var
%1:i32 = add 1:i32, %0
infer %1
#########################################################
; exiting Souper's runOnFunction() for uint2double()

; entering Souper's runOnFunction() for min2()

; ModuleID = './P-value_correction.c.bc'
source_filename = "./P-value_correction.c"
target datalayout = "e-m:e-p:32:32-i64:64-n32:64-S128"
target triple = "wasm32-unknown-wasi"

@.str = private unnamed_addr constant [29 x i8] c"malloc failed at %s line %u\0A\00", align 1
@.str.1 = private unnamed_addr constant [23 x i8] c"./P-value_correction.c\00", align 1
@.str.2 = private unnamed_addr constant [1 x i8] zeroinitializer, align 1
@base_arr = hidden global double* null, align 4
@.str.3 = private unnamed_addr constant [33 x i8] c"failed to malloc at %s line %u.\0A\00", align 1
@.str.4 = private unnamed_addr constant [48 x i8] c"cummin function requires at least one element.\0A\00", align 1
@.str.5 = private unnamed_addr constant [22 x i8] c"Failed at %s line %u\0A\00", align 1
@.str.6 = private unnamed_addr constant [41 x i8] c"function requires at least one element.\0A\00", align 1
@.str.7 = private unnamed_addr constant [37 x i8] c"pmin requires at least one element.\0A\00", align 1
@.str.8 = private unnamed_addr constant [7 x i8] c"[1] %e\00", align 1
@.str.9 = private unnamed_addr constant [7 x i8] c" %.10f\00", align 1
@.str.10 = private unnamed_addr constant [6 x i8] c"\0A[%u]\00", align 1
@.str.11 = private unnamed_addr constant [2 x i8] c"\0A\00", align 1
@.str.12 = private unnamed_addr constant [34 x i8] c"Failure to malloc at %s line %u.\0A\00", align 1
@.str.13 = private unnamed_addr constant [41 x i8] c"p_adjust requires at least one element.\0A\00", align 1
@.str.14 = private unnamed_addr constant [3 x i8] c"BH\00", align 1
@.str.15 = private unnamed_addr constant [4 x i8] c"fdr\00", align 1
@.str.16 = private unnamed_addr constant [3 x i8] c"by\00", align 1
@.str.17 = private unnamed_addr constant [11 x i8] c"Bonferroni\00", align 1
@.str.18 = private unnamed_addr constant [9 x i8] c"hochberg\00", align 1
@.str.19 = private unnamed_addr constant [5 x i8] c"holm\00", align 1
@.str.20 = private unnamed_addr constant [7 x i8] c"hommel\00", align 1
@.str.21 = private unnamed_addr constant [44 x i8] c"%s doesn't match any accepted FDR methods.\0A\00", align 1
@.str.22 = private unnamed_addr constant [42 x i8] c"%g is outside of the interval I planned.\0A\00", align 1
@.str.23 = private unnamed_addr constant [23 x i8] c"Failure at %s line %u\0A\00", align 1
@.str.24 = private unnamed_addr constant [54 x i8] c"array[%u] = %lf, which is outside the interval [0,1]\0A\00", align 1
@.str.25 = private unnamed_addr constant [20 x i8] c"died at %s line %u\0A\00", align 1
@__const.main.PVALUES = private unnamed_addr constant [50 x double] [double 0x3FDD04160F35FDE9, double 0x3FE758E721E2A8D7, double 0x3FB96FAC8B38D8BA, double 0x3FB73E71D5B04B37, double 0x3FC710AB48EE865B, double 0x3FEC01D953C3CC73, double 0x3FD2B3C4BE0A922A, double 0x3FED2B5A568DAB4F, double 0x3FDBE08D73F16964, double 0x3FE10A218C41C242, double 0x3FDF8810DB1996AA, double 0x3FE291CCB11E1A9D, double 0x3FD64E8C550D788F, double 7.883130e-01, double 0x3FD177B2BF048D2D, double 0x3FEB3543434BAF2B, double 0x3FDB50EAD41ED0A6, double 0x3FE49D4AFF01D33F, double 0x3FD364C9AE345B51, double 0x3FA99BA35F15394D, double 3.194810e-01, double 0x3FE941E405CE761A, double 0x3FEFF94F77369843, double 0x3FC65847BFB23217, double 0x3FECEB8879B6A543, double 0x3FBEAF00332BA677, double 0x3FD96207C7749E38, double 0x3F8CC02620502C93, double 0x3FE773A5B45A0F40, double 0x3FB1642C24762C01, double 4.040730e-03, double 0x3F33E11D79A90777, double 0x3F870B02BD749528, double 0x3F98521BD6A0353F, double 0x3F4310F26148FFAA, double 0x3F3427CD76006778, double 0x3F80E60AFB1F8A4E, double 0x3F5639B74A9E4DA2, double 0x3F8BDDF74195769F, double 0x3F38ABEE3BFA8581, double 0x3EF2E2E96B5466FE, double 0x3E90CE9F65B58A88, double 0x3FA0F2D097879B95, double 0x3F834EE7216A6684, double 0x3F4CCE8DBB40BD9D, double 0x3F2C8B969590F2ED, double 0x3F4FC31F7F1541AD, double 6.610250e-05, double 0x3F9DB44EA6AC26BA, double 5.735490e-03], align 16
@__const.main.CORRECT_ANSWERS = private unnamed_addr constant [6 x [50 x double]] [[50 x double] [double 0x3FE39AFA2199ADBC, double 8.521710e-01, double 0x3FC96FAC6045BAF5, double 0x3FC83660E51D25AB, double 0x3FD498068702BE20, double 0x3FEDC3BF727136A4, double 4.870370e-01, double 0x3FEDC3BF727136A4, double 0x3FE35BF08BEEB62C, double 0x3FE5D879DEE92F03, double 0x3FE4BE91D656B94A, double 0x3FE7363FC28DAEAA, double 0x3FE0E62C4F13638A, double 0x3FEC1052C8FAB035, double 0x3FDE1DD2E43E029A, double 0x3FED92EFFC7CBDC1, double 0x3FE35BF08BEEB62C, double 0x3FE923B90CFC67C5, double 0x3FDF47B8FC357024, double 0x3FBD1996A9FB10AD, double 0x3FDFF2B6D6C14255, double 0x3FEC1052C8FAB035, double 0x3FEFF94F77369843, double 0x3FD498068702BE20, double 0x3FEDC3BF727136A4, double 0x3FCD80E2E96EC403, double 0x3FE2A9F6A93F290B, double 0x3FA3F736D8AF2E2B, double 8.521710e-01, double 0x3FC2E751B350FAC4, double 0x3F913D8E55EE9F05, double 0x3F64FECB88BB3633, double 0x3FA2009A03CCBE34, double 0x3FB0001FB57CF9FC, double 0x3F6DCA7ADA5E274A, double 0x3F64FECB88BB3633, double 0x3F9E2D13B467D120, double 0x3F7941963399C6A1, double 0x3FA3F736D8AF2E2B, double 0x3F6607390CEF853C, double 0x3F3D828C80BA213A, double 0x3EEA42D90EEBA875, double 0x3FB42D4181AA8F8B, double 0x3FA01715F12E0018, double 0x3F73D9F3AF6D490C, double 0x3F64FECB88BB3633, double 0x3F73D9F3AF6D490C, double 0x3F520CE5F51A7C61, double 0x3FB290B112B20952, double 0x3F9696C95AA76B69], [50 x double] [double 1.000000e+00, double 1.000000e+00, double 0x3FEC9C56E33BA41B, double 0x3FEB3BF21E95ED3D, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 0x3FE05DA74553C727, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 0x3FC675198790829A, double 1.000000e+00, double 0x3FE54345648E1F12, double 0x3FB3645F501CA2F9, double 0x3F879D934E50F0DE, double 0x3FC43FC3646E3EA2, double 0x3FD1FF539D36064C, double 0x3F90C123206B855F, double 0x3F879D934E50F0DE, double 0x3FC0F8967F32E606, double 0x3F9C6880470D2FBE, double 0x3FC675198790829A, double 0x3F88C70105E47082, double 2.025930e-03, double 0x3F0D89DE4FA8F818, double 0x3FD6B1E2D11B1027, double 0x3FC219271872BD8D, double 0x3F96542FAD16CEF9, double 0x3F879D934E50F0DE, double 0x3F96542FAD16CEF9, double 0x3F744D9816EB319A, double 0x3FD4E1D5728DBC16, double 0x3FB9687C40426555], [50 x double] [double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 0x3FE6761DC93EA2D3, double 1.000000e+00, double 1.000000e+00, double 0x3FC9DC55000C953A, double 0x3F8F0FBD624BA499, double 0x3FE2009A24031487, double 1.000000e+00, double 0x3F9DCA7AB8020F7A, double 0x3F8F7E310860A1AB, double 0x3FDA677128614819, double 6.782670e-02, double 6.803480e-01, double 0x3F9346521EDBB84D, double 0x3F4D828CB7B3E0EE, double 0x3EEA42D90EEBA875, double 1.000000e+00, double 4.713920e-01, double 0x3FA6815EE53DB1E7, double 0x3F864D0CF90CC6B8, double 0x3FA8D0709B489B4F, double 0x3F6B1359791819D2, double 1.000000e+00, double 0x3FD25A836EB4E981], [50 x double] [double 0x3FEFF94F77369843, double 0x3FEFF94F77369843, double 0x3FEFF94F77369843, double 0x3FEFF94F77369843, double 0x3FEFF94F77369843, double 0x3FEFF94F77369843, double 0x3FEFF94F77369843, double 0x3FEFF94F77369843, double 0x3FEFF94F77369843, double 0x3FEFF94F77369843, double 0x3FEFF94F77369843, double 0x3FEFF94F77369843, double 0x3FEFF94F77369843, double 0x3FEFF94F77369843, double 0x3FEFF94F77369843, double 0x3FEFF94F77369843, double 0x3FEFF94F77369843, double 0x3FEFF94F77369843, double 0x3FEFF94F77369843, double 0x3FEFF94F77369843, double 0x3FEFF94F77369843, double 0x3FEFF94F77369843, double 0x3FEFF94F77369843, double 0x3FEFF94F77369843, double 0x3FEFF94F77369843, double 0x3FEFF94F77369843, double 0x3FEFF94F77369843, double 0x3FDDA6274695E687, double 0x3FEFF94F77369843, double 0x3FEFF94F77369843, double 0x3FC42BDC26DCE39B, double 0x3F8C57F9104CA951, double 0x3FD9340AC9879DEF, double 7.600230e-01, double 0x3F999EC5A86B439B, double 0x3F8C57F9104CA951, double 0x3FD389FCD90412B4, double 0x3FABC8251D45E10B, double 0x3FDD9BD68ABBB045, double 0x3F90F633F956C386, double 8.825610e-04, double 0x3EEA42D90EEBA875, double 0x3FEFC7471C1E43B8, double 0x3FD5B8C4014C305A, double 0x3FA2E78CEC8D068E, double 0x3F84F6832995A599, double 0x3FA459002162FC24, double 3.172920e-03, double 8.992520e-01, double 0x3FCBE5BD5E9AC00A], [50 x double] [double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 0x3FDDA6274695E687, double 1.000000e+00, double 1.000000e+00, double 0x3FC42BDC26DCE39B, double 0x3F8C939AFCF101E0, double 0x3FD9340AC9879DEF, double 7.600230e-01, double 0x3F999EC5A86B439B, double 0x3F8C939AFCF101E0, double 0x3FD389FCD90412B4, double 0x3FABC8251D45E10B, double 0x3FDD9BD68ABBB045, double 0x3F90F633F956C386, double 8.825610e-04, double 0x3EEA42D90EEBA875, double 0x3FEFC7471C1E43B8, double 0x3FD5B8C4014C305A, double 0x3FA2E78CEC8D068E, double 0x3F84F6832995A599, double 0x3FA459002162FC24, double 3.172920e-03, double 8.992520e-01, double 0x3FCBE5BD5E9AC00A], [50 x double] [double 0x3FEFF94F77369843, double 0x3FEFF94F77369843, double 0x3FEFF94F77369843, double 0x3FEFF5DC908F2EDD, double 0x3FEFF94F77369843, double 0x3FEFF94F77369843, double 0x3FEFF94F77369843, double 0x3FEFF94F77369843, double 0x3FEFF94F77369843, double 0x3FEFF94F77369843, double 0x3FEFF94F77369843, double 0x3FEFF94F77369843, double 0x3FEFF94F77369843, double 0x3FEFF94F77369843, double 0x3FEFF94F77369843, double 0x3FEFF94F77369843, double 0x3FEFF94F77369843, double 0x3FEFF94F77369843, double 0x3FEFF94F77369843, double 0x3FEEB45F17BD8BE7, double 0x3FEFF94F77369843, double 0x3FEFF94F77369843, double 0x3FEFF94F77369843, double 0x3FEFF94F77369843, double 0x3FEFF94F77369843, double 0x3FEFF94F77369843, double 0x3FEFF94F77369843, double 0x3FDBDA250F840182, double 0x3FEFF94F77369843, double 0x3FEF40BC1D52205E, double 0x3FC21A3BEB689947, double 1.304340e-02, double 0x3FD69916517B1CD7, double 0x3FE60A69453DF7B2, double 0x3F986DB666D9D3C6, double 0x3F8B157BBD3AB385, double 2.722920e-01, double 0x3FABC8251D45E10B, double 0x3FDAFF07B27BE8AF, double 0x3F9030D45E3B9F93, double 8.825610e-04, double 0x3EEA42D90EEBA875, double 0x3FEBFACC1948A662, double 0x3FD34EE6EDE042CB, double 0x3FA2011883DA6A9A, double 0x3F839FF779153716, double 0x3FA3D9F3D1C960DD, double 3.172920e-03, double 0x3FE9FDC4BC5D1301, double 0x3FC8F5FAC3801CF1]], align 16
@.str.26 = private unnamed_addr constant [3 x i8] c"bh\00", align 1
@.str.27 = private unnamed_addr constant [11 x i8] c"bonferroni\00", align 1
@__const.main.TYPES = private unnamed_addr constant [6 x i8*] [i8* getelementptr inbounds ([3 x i8], [3 x i8]* @.str.26, i32 0, i32 0), i8* getelementptr inbounds ([3 x i8], [3 x i8]* @.str.16, i32 0, i32 0), i8* getelementptr inbounds ([11 x i8], [11 x i8]* @.str.27, i32 0, i32 0), i8* getelementptr inbounds ([9 x i8], [9 x i8]* @.str.18, i32 0, i32 0), i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.19, i32 0, i32 0), i8* getelementptr inbounds ([7 x i8], [7 x i8]* @.str.20, i32 0, i32 0)], align 16
@.str.28 = private unnamed_addr constant [44 x i8] c"\0Atype %u = '%s' has cumulative error of %g\0A\00", align 1
@llvm.used = appending global [1 x i8*] [i8* bitcast (i32 ()* @__main_void to i8*)], section "llvm.metadata"

@__main_void = alias i32 (), i32 ()* @main

; Function Attrs: noinline nounwind optnone
define hidden i32* @seq_len(i32 %START, i32 %END) #0 {
entry:
  %retval = alloca i32*, align 4
  %START.addr = alloca i32, align 4
  %END.addr = alloca i32, align 4
  %start = alloca i32, align 4
  %end = alloca i32, align 4
  %sequence = alloca i32*, align 4
  %i = alloca i32, align 4
  %LENGTH = alloca i32, align 4
  %sequence10 = alloca i32*, align 4
  %index = alloca i32, align 4
  %index28 = alloca i32, align 4
  store i32 %START, i32* %START.addr, align 4
  store i32 %END, i32* %END.addr, align 4
  %0 = load i32, i32* %START.addr, align 4
  store i32 %0, i32* %start, align 4
  %1 = load i32, i32* %END.addr, align 4
  store i32 %1, i32* %end, align 4
  %2 = load i32, i32* %START.addr, align 4
  %3 = load i32, i32* %END.addr, align 4
  %cmp = icmp eq i32 %2, %3
  br i1 %cmp, label %if.then, label %if.end6

if.then:                                          ; preds = %entry
  %4 = load i32, i32* %end, align 4
  %add = add i32 %4, 1
  %mul = mul i32 %add, 4
  %call = call noalias i8* @malloc(i32 %mul)
  %5 = bitcast i8* %call to i32*
  store i32* %5, i32** %sequence, align 4
  %6 = load i32*, i32** %sequence, align 4
  %cmp1 = icmp eq i32* %6, null
  br i1 %cmp1, label %if.then2, label %if.end

if.then2:                                         ; preds = %if.then
  %call3 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([29 x i8], [29 x i8]* @.str, i32 0, i32 0), i8* getelementptr inbounds ([23 x i8], [23 x i8]* @.str.1, i32 0, i32 0), i32 15)
  call void @perror(i8* getelementptr inbounds ([1 x i8], [1 x i8]* @.str.2, i32 0, i32 0))
  call void @exit(i32 1) #5
  unreachable

if.end:                                           ; preds = %if.then
  store i32 0, i32* %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.end
  %7 = load i32, i32* %i, align 4
  %8 = load i32, i32* %end, align 4
  %cmp4 = icmp ult i32 %7, %8
  br i1 %cmp4, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %9 = load i32, i32* %i, align 4
  %add5 = add i32 %9, 1
  %10 = load i32*, i32** %sequence, align 4
  %11 = load i32, i32* %i, align 4
  %arrayidx = getelementptr inbounds i32, i32* %10, i32 %11
  store i32 %add5, i32* %arrayidx, align 4
  br label %for.inc

for.inc:                                          ; preds = %for.body
  %12 = load i32, i32* %i, align 4
  %inc = add i32 %12, 1
  store i32 %inc, i32* %i, align 4
  br label %for.cond

for.end:                                          ; preds = %for.cond
  %13 = load i32*, i32** %sequence, align 4
  store i32* %13, i32** %retval, align 4
  br label %return

if.end6:                                          ; preds = %entry
  %14 = load i32, i32* %START.addr, align 4
  %15 = load i32, i32* %END.addr, align 4
  %cmp7 = icmp ugt i32 %14, %15
  br i1 %cmp7, label %if.then8, label %if.end9

if.then8:                                         ; preds = %if.end6
  %16 = load i32, i32* %START.addr, align 4
  store i32 %16, i32* %end, align 4
  %17 = load i32, i32* %END.addr, align 4
  store i32 %17, i32* %start, align 4
  br label %if.end9

if.end9:                                          ; preds = %if.then8, %if.end6
  %18 = load i32, i32* %end, align 4
  %19 = load i32, i32* %start, align 4
  %sub = sub i32 %18, %19
  store i32 %sub, i32* %LENGTH, align 4
  %20 = load i32, i32* %LENGTH, align 4
  %add11 = add i32 1, %20
  %mul12 = mul i32 %add11, 4
  %call13 = call noalias i8* @malloc(i32 %mul12)
  %21 = bitcast i8* %call13 to i32*
  store i32* %21, i32** %sequence10, align 4
  %22 = load i32*, i32** %sequence10, align 4
  %cmp14 = icmp eq i32* %22, null
  br i1 %cmp14, label %if.then15, label %if.end17

if.then15:                                        ; preds = %if.end9
  %call16 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([29 x i8], [29 x i8]* @.str, i32 0, i32 0), i8* getelementptr inbounds ([23 x i8], [23 x i8]* @.str.1, i32 0, i32 0), i32 31)
  call void @perror(i8* getelementptr inbounds ([1 x i8], [1 x i8]* @.str.2, i32 0, i32 0))
  call void @exit(i32 1) #5
  unreachable

if.end17:                                         ; preds = %if.end9
  %23 = load i32, i32* %START.addr, align 4
  %24 = load i32, i32* %END.addr, align 4
  %cmp18 = icmp ult i32 %23, %24
  br i1 %cmp18, label %if.then19, label %if.else

if.then19:                                        ; preds = %if.end17
  store i32 0, i32* %index, align 4
  br label %for.cond20

for.cond20:                                       ; preds = %for.inc25, %if.then19
  %25 = load i32, i32* %index, align 4
  %26 = load i32, i32* %LENGTH, align 4
  %cmp21 = icmp ule i32 %25, %26
  br i1 %cmp21, label %for.body22, label %for.end27

for.body22:                                       ; preds = %for.cond20
  %27 = load i32, i32* %start, align 4
  %28 = load i32, i32* %index, align 4
  %add23 = add i32 %27, %28
  %29 = load i32*, i32** %sequence10, align 4
  %30 = load i32, i32* %index, align 4
  %arrayidx24 = getelementptr inbounds i32, i32* %29, i32 %30
  store i32 %add23, i32* %arrayidx24, align 4
  br label %for.inc25

for.inc25:                                        ; preds = %for.body22
  %31 = load i32, i32* %index, align 4
  %inc26 = add i32 %31, 1
  store i32 %inc26, i32* %index, align 4
  br label %for.cond20

for.end27:                                        ; preds = %for.cond20
  br label %if.end37

if.else:                                          ; preds = %if.end17
  store i32 0, i32* %index28, align 4
  br label %for.cond29

for.cond29:                                       ; preds = %for.inc34, %if.else
  %32 = load i32, i32* %index28, align 4
  %33 = load i32, i32* %LENGTH, align 4
  %cmp30 = icmp ule i32 %32, %33
  br i1 %cmp30, label %for.body31, label %for.end36

for.body31:                                       ; preds = %for.cond29
  %34 = load i32, i32* %end, align 4
  %35 = load i32, i32* %index28, align 4
  %sub32 = sub i32 %34, %35
  %36 = load i32*, i32** %sequence10, align 4
  %37 = load i32, i32* %index28, align 4
  %arrayidx33 = getelementptr inbounds i32, i32* %36, i32 %37
  store i32 %sub32, i32* %arrayidx33, align 4
  br label %for.inc34

for.inc34:                                        ; preds = %for.body31
  %38 = load i32, i32* %index28, align 4
  %inc35 = add i32 %38, 1
  store i32 %inc35, i32* %index28, align 4
  br label %for.cond29

for.end36:                                        ; preds = %for.cond29
  br label %if.end37

if.end37:                                         ; preds = %for.end36, %for.end27
  %39 = load i32*, i32** %sequence10, align 4
  store i32* %39, i32** %retval, align 4
  br label %return

return:                                           ; preds = %if.end37, %for.end
  %40 = load i32*, i32** %retval, align 4
  ret i32* %40
}

declare noalias i8* @malloc(i32 %0) #1

declare i32 @printf(i8* %0, ...) #1

declare void @perror(i8* %0) #1

; Function Attrs: noreturn
declare void @exit(i32 %0) #2

; Function Attrs: noinline nounwind optnone
define hidden i32* @order(double* noalias %ARRAY, i32 %SIZE, i1 zeroext %DECREASING) #0 {
entry:
  %ARRAY.addr = alloca double*, align 4
  %SIZE.addr = alloca i32, align 4
  %DECREASING.addr = alloca i8, align 1
  %idx = alloca i32*, align 4
  %i = alloca i32, align 4
  store double* %ARRAY, double** %ARRAY.addr, align 4
  store i32 %SIZE, i32* %SIZE.addr, align 4
  %frombool = zext i1 %DECREASING to i8
  store i8 %frombool, i8* %DECREASING.addr, align 1
  %0 = load i32, i32* %SIZE.addr, align 4
  %mul = mul i32 %0, 4
  %call = call noalias i8* @malloc(i32 %mul)
  %1 = bitcast i8* %call to i32*
  store i32* %1, i32** %idx, align 4
  %2 = load i32*, i32** %idx, align 4
  %cmp = icmp eq i32* %2, null
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %call1 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([33 x i8], [33 x i8]* @.str.3, i32 0, i32 0), i8* getelementptr inbounds ([23 x i8], [23 x i8]* @.str.1, i32 0, i32 0), i32 77)
  call void @perror(i8* getelementptr inbounds ([1 x i8], [1 x i8]* @.str.2, i32 0, i32 0))
  call void @exit(i32 1) #5
  unreachable

if.end:                                           ; preds = %entry
  %3 = load i32, i32* %SIZE.addr, align 4
  %mul2 = mul i32 8, %3
  %call3 = call noalias i8* @malloc(i32 %mul2)
  %4 = bitcast i8* %call3 to double*
  store double* %4, double** @base_arr, align 4
  %5 = load double*, double** @base_arr, align 4
  %cmp4 = icmp eq double* %5, null
  br i1 %cmp4, label %if.then5, label %if.end7

if.then5:                                         ; preds = %if.end
  %call6 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([33 x i8], [33 x i8]* @.str.3, i32 0, i32 0), i8* getelementptr inbounds ([23 x i8], [23 x i8]* @.str.1, i32 0, i32 0), i32 83)
  call void @perror(i8* getelementptr inbounds ([1 x i8], [1 x i8]* @.str.2, i32 0, i32 0))
  call void @exit(i32 1) #5
  unreachable

if.end7:                                          ; preds = %if.end
  store i32 0, i32* %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.end7
  %6 = load i32, i32* %i, align 4
  %7 = load i32, i32* %SIZE.addr, align 4
  %cmp8 = icmp ult i32 %6, %7
  br i1 %cmp8, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %8 = load double*, double** %ARRAY.addr, align 4
  %9 = load i32, i32* %i, align 4
  %arrayidx = getelementptr inbounds double, double* %8, i32 %9
  %10 = load double, double* %arrayidx, align 8
  %11 = load double*, double** @base_arr, align 4
  %12 = load i32, i32* %i, align 4
  %arrayidx9 = getelementptr inbounds double, double* %11, i32 %12
  store double %10, double* %arrayidx9, align 8
  %13 = load i32, i32* %i, align 4
  %14 = load i32*, i32** %idx, align 4
  %15 = load i32, i32* %i, align 4
  %arrayidx10 = getelementptr inbounds i32, i32* %14, i32 %15
  store i32 %13, i32* %arrayidx10, align 4
  br label %for.inc

for.inc:                                          ; preds = %for.body
  %16 = load i32, i32* %i, align 4
  %inc = add i32 %16, 1
  store i32 %inc, i32* %i, align 4
  br label %for.cond

for.end:                                          ; preds = %for.cond
  %17 = load i8, i8* %DECREASING.addr, align 1
  %tobool = trunc i8 %17 to i1
  %conv = zext i1 %tobool to i32
  %cmp11 = icmp eq i32 %conv, 0
  br i1 %cmp11, label %if.then13, label %if.else

if.then13:                                        ; preds = %for.end
  %18 = load i32*, i32** %idx, align 4
  %19 = bitcast i32* %18 to i8*
  %20 = load i32, i32* %SIZE.addr, align 4
  call void @qsort(i8* %19, i32 %20, i32 4, i32 (i8*, i8*)* @compar_decrease)
  br label %if.end20

if.else:                                          ; preds = %for.end
  %21 = load i8, i8* %DECREASING.addr, align 1
  %tobool14 = trunc i8 %21 to i1
  br i1 %tobool14, label %if.then18, label %if.end19

if.then18:                                        ; preds = %if.else
  %22 = load i32*, i32** %idx, align 4
  %23 = bitcast i32* %22 to i8*
  %24 = load i32, i32* %SIZE.addr, align 4
  call void @qsort(i8* %23, i32 %24, i32 4, i32 (i8*, i8*)* @compar_increase)
  br label %if.end19

if.end19:                                         ; preds = %if.then18, %if.else
  br label %if.end20

if.end20:                                         ; preds = %if.end19, %if.then13
  %25 = load double*, double** @base_arr, align 4
  %26 = bitcast double* %25 to i8*
  call void @free(i8* %26)
  store double* null, double** @base_arr, align 4
  %27 = load i32*, i32** %idx, align 4
  ret i32* %27
}

declare void @qsort(i8* %0, i32 %1, i32 %2, i32 (i8*, i8*)* %3) #1

; Function Attrs: noinline nounwind optnone
define internal i32 @compar_decrease(i8* noalias %a, i8* noalias %b) #0 {
entry:
  %retval = alloca i32, align 4
  %a.addr = alloca i8*, align 4
  %b.addr = alloca i8*, align 4
  %aa = alloca i32, align 4
  %bb = alloca i32, align 4
  store i8* %a, i8** %a.addr, align 4
  store i8* %b, i8** %b.addr, align 4
  %0 = load i8*, i8** %a.addr, align 4
  %1 = bitcast i8* %0 to i32*
  %2 = load i32, i32* %1, align 4
  store i32 %2, i32* %aa, align 4
  %3 = load i8*, i8** %b.addr, align 4
  %4 = bitcast i8* %3 to i32*
  %5 = load i32, i32* %4, align 4
  store i32 %5, i32* %bb, align 4
  %6 = load double*, double** @base_arr, align 4
  %7 = load i32, i32* %aa, align 4
  %arrayidx = getelementptr inbounds double, double* %6, i32 %7
  %8 = load double, double* %arrayidx, align 8
  %9 = load double*, double** @base_arr, align 4
  %10 = load i32, i32* %bb, align 4
  %arrayidx1 = getelementptr inbounds double, double* %9, i32 %10
  %11 = load double, double* %arrayidx1, align 8
  %cmp = fcmp olt double %8, %11
  br i1 %cmp, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  store i32 -1, i32* %retval, align 4
  br label %return

if.else:                                          ; preds = %entry
  %12 = load double*, double** @base_arr, align 4
  %13 = load i32, i32* %aa, align 4
  %arrayidx2 = getelementptr inbounds double, double* %12, i32 %13
  %14 = load double, double* %arrayidx2, align 8
  %15 = load double*, double** @base_arr, align 4
  %16 = load i32, i32* %bb, align 4
  %arrayidx3 = getelementptr inbounds double, double* %15, i32 %16
  %17 = load double, double* %arrayidx3, align 8
  %cmp4 = fcmp oeq double %14, %17
  br i1 %cmp4, label %if.then5, label %if.else6

if.then5:                                         ; preds = %if.else
  store i32 0, i32* %retval, align 4
  br label %return

if.else6:                                         ; preds = %if.else
  store i32 1, i32* %retval, align 4
  br label %return

return:                                           ; preds = %if.else6, %if.then5, %if.then
  %18 = load i32, i32* %retval, align 4
  ret i32 %18
}

; Function Attrs: noinline nounwind optnone
define internal i32 @compar_increase(i8* noalias %a, i8* noalias %b) #0 {
entry:
  %retval = alloca i32, align 4
  %a.addr = alloca i8*, align 4
  %b.addr = alloca i8*, align 4
  %aa = alloca i32, align 4
  %bb = alloca i32, align 4
  store i8* %a, i8** %a.addr, align 4
  store i8* %b, i8** %b.addr, align 4
  %0 = load i8*, i8** %a.addr, align 4
  %1 = bitcast i8* %0 to i32*
  %2 = load i32, i32* %1, align 4
  store i32 %2, i32* %aa, align 4
  %3 = load i8*, i8** %b.addr, align 4
  %4 = bitcast i8* %3 to i32*
  %5 = load i32, i32* %4, align 4
  store i32 %5, i32* %bb, align 4
  %6 = load double*, double** @base_arr, align 4
  %7 = load i32, i32* %aa, align 4
  %arrayidx = getelementptr inbounds double, double* %6, i32 %7
  %8 = load double, double* %arrayidx, align 8
  %9 = load double*, double** @base_arr, align 4
  %10 = load i32, i32* %bb, align 4
  %arrayidx1 = getelementptr inbounds double, double* %9, i32 %10
  %11 = load double, double* %arrayidx1, align 8
  %cmp = fcmp olt double %8, %11
  br i1 %cmp, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  store i32 1, i32* %retval, align 4
  br label %return

if.else:                                          ; preds = %entry
  %12 = load double*, double** @base_arr, align 4
  %13 = load i32, i32* %aa, align 4
  %arrayidx2 = getelementptr inbounds double, double* %12, i32 %13
  %14 = load double, double* %arrayidx2, align 8
  %15 = load double*, double** @base_arr, align 4
  %16 = load i32, i32* %bb, align 4
  %arrayidx3 = getelementptr inbounds double, double* %15, i32 %16
  %17 = load double, double* %arrayidx3, align 8
  %cmp4 = fcmp oeq double %14, %17
  br i1 %cmp4, label %if.then5, label %if.else6

if.then5:                                         ; preds = %if.else
  store i32 0, i32* %retval, align 4
  br label %return

if.else6:                                         ; preds = %if.else
  store i32 -1, i32* %retval, align 4
  br label %return

return:                                           ; preds = %if.else6, %if.then5, %if.then
  %18 = load i32, i32* %retval, align 4
  ret i32 %18
}

declare void @free(i8* %0) #1

; Function Attrs: noinline nounwind optnone
define hidden double* @cummin(double* noalias %ARRAY, i32 %NO_OF_ARRAY_ELEMENTS) #0 {
entry:
  %ARRAY.addr = alloca double*, align 4
  %NO_OF_ARRAY_ELEMENTS.addr = alloca i32, align 4
  %output = alloca double*, align 4
  %cumulative_min = alloca double, align 8
  %i = alloca i32, align 4
  store double* %ARRAY, double** %ARRAY.addr, align 4
  store i32 %NO_OF_ARRAY_ELEMENTS, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
  %0 = load i32, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
  %cmp = icmp ult i32 %0, 1
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %call = call i32 @puts(i8* getelementptr inbounds ([48 x i8], [48 x i8]* @.str.4, i32 0, i32 0))
  %call1 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([22 x i8], [22 x i8]* @.str.5, i32 0, i32 0), i8* getelementptr inbounds ([23 x i8], [23 x i8]* @.str.1, i32 0, i32 0), i32 105)
  call void @exit(i32 1) #5
  unreachable

if.end:                                           ; preds = %entry
  %1 = load i32, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
  %mul = mul i32 8, %1
  %call2 = call noalias i8* @malloc(i32 %mul)
  %2 = bitcast i8* %call2 to double*
  store double* %2, double** %output, align 4
  %3 = load double*, double** %output, align 4
  %cmp3 = icmp eq double* %3, null
  br i1 %cmp3, label %if.then4, label %if.end6

if.then4:                                         ; preds = %if.end
  %call5 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([33 x i8], [33 x i8]* @.str.3, i32 0, i32 0), i8* getelementptr inbounds ([23 x i8], [23 x i8]* @.str.1, i32 0, i32 0), i32 110)
  call void @perror(i8* getelementptr inbounds ([1 x i8], [1 x i8]* @.str.2, i32 0, i32 0))
  call void @exit(i32 1) #5
  unreachable

if.end6:                                          ; preds = %if.end
  %4 = load double*, double** %ARRAY.addr, align 4
  %arrayidx = getelementptr inbounds double, double* %4, i32 0
  %5 = load double, double* %arrayidx, align 8
  store double %5, double* %cumulative_min, align 8
  store i32 0, i32* %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.end6
  %6 = load i32, i32* %i, align 4
  %7 = load i32, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
  %cmp7 = icmp ult i32 %6, %7
  br i1 %cmp7, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %8 = load double*, double** %ARRAY.addr, align 4
  %9 = load i32, i32* %i, align 4
  %arrayidx8 = getelementptr inbounds double, double* %8, i32 %9
  %10 = load double, double* %arrayidx8, align 8
  %11 = load double, double* %cumulative_min, align 8
  %cmp9 = fcmp olt double %10, %11
  br i1 %cmp9, label %if.then10, label %if.end12

if.then10:                                        ; preds = %for.body
  %12 = load double*, double** %ARRAY.addr, align 4
  %13 = load i32, i32* %i, align 4
  %arrayidx11 = getelementptr inbounds double, double* %12, i32 %13
  %14 = load double, double* %arrayidx11, align 8
  store double %14, double* %cumulative_min, align 8
  br label %if.end12

if.end12:                                         ; preds = %if.then10, %for.body
  %15 = load double, double* %cumulative_min, align 8
  %16 = load double*, double** %output, align 4
  %17 = load i32, i32* %i, align 4
  %arrayidx13 = getelementptr inbounds double, double* %16, i32 %17
  store double %15, double* %arrayidx13, align 8
  br label %for.inc

for.inc:                                          ; preds = %if.end12
  %18 = load i32, i32* %i, align 4
  %inc = add i32 %18, 1
  store i32 %inc, i32* %i, align 4
  br label %for.cond

for.end:                                          ; preds = %for.cond
  %19 = load double*, double** %output, align 4
  ret double* %19
}

declare i32 @puts(i8* %0) #1

; Function Attrs: noinline nounwind optnone
define hidden double* @cummax(double* noalias %ARRAY, i32 %NO_OF_ARRAY_ELEMENTS) #0 {
entry:
  %ARRAY.addr = alloca double*, align 4
  %NO_OF_ARRAY_ELEMENTS.addr = alloca i32, align 4
  %output = alloca double*, align 4
  %cumulative_max = alloca double, align 8
  %i = alloca i32, align 4
  store double* %ARRAY, double** %ARRAY.addr, align 4
  store i32 %NO_OF_ARRAY_ELEMENTS, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
  %0 = load i32, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
  %cmp = icmp ult i32 %0, 1
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %call = call i32 @puts(i8* getelementptr inbounds ([41 x i8], [41 x i8]* @.str.6, i32 0, i32 0))
  %call1 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([22 x i8], [22 x i8]* @.str.5, i32 0, i32 0), i8* getelementptr inbounds ([23 x i8], [23 x i8]* @.str.1, i32 0, i32 0), i32 129)
  call void @exit(i32 1) #5
  unreachable

if.end:                                           ; preds = %entry
  %1 = load i32, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
  %mul = mul i32 8, %1
  %call2 = call noalias i8* @malloc(i32 %mul)
  %2 = bitcast i8* %call2 to double*
  store double* %2, double** %output, align 4
  %3 = load double*, double** %output, align 4
  %cmp3 = icmp eq double* %3, null
  br i1 %cmp3, label %if.then4, label %if.end6

if.then4:                                         ; preds = %if.end
  %call5 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([33 x i8], [33 x i8]* @.str.3, i32 0, i32 0), i8* getelementptr inbounds ([23 x i8], [23 x i8]* @.str.1, i32 0, i32 0), i32 134)
  call void @perror(i8* getelementptr inbounds ([1 x i8], [1 x i8]* @.str.2, i32 0, i32 0))
  call void @exit(i32 1) #5
  unreachable

if.end6:                                          ; preds = %if.end
  %4 = load double*, double** %ARRAY.addr, align 4
  %arrayidx = getelementptr inbounds double, double* %4, i32 0
  %5 = load double, double* %arrayidx, align 8
  store double %5, double* %cumulative_max, align 8
  store i32 0, i32* %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.end6
  %6 = load i32, i32* %i, align 4
  %7 = load i32, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
  %cmp7 = icmp ult i32 %6, %7
  br i1 %cmp7, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %8 = load double*, double** %ARRAY.addr, align 4
  %9 = load i32, i32* %i, align 4
  %arrayidx8 = getelementptr inbounds double, double* %8, i32 %9
  %10 = load double, double* %arrayidx8, align 8
  %11 = load double, double* %cumulative_max, align 8
  %cmp9 = fcmp ogt double %10, %11
  br i1 %cmp9, label %if.then10, label %if.end12

if.then10:                                        ; preds = %for.body
  %12 = load double*, double** %ARRAY.addr, align 4
  %13 = load i32, i32* %i, align 4
  %arrayidx11 = getelementptr inbounds double, double* %12, i32 %13
  %14 = load double, double* %arrayidx11, align 8
  store double %14, double* %cumulative_max, align 8
  br label %if.end12

if.end12:                                         ; preds = %if.then10, %for.body
  %15 = load double, double* %cumulative_max, align 8
  %16 = load double*, double** %output, align 4
  %17 = load i32, i32* %i, align 4
  %arrayidx13 = getelementptr inbounds double, double* %16, i32 %17
  store double %15, double* %arrayidx13, align 8
  br label %for.inc

for.inc:                                          ; preds = %if.end12
  %18 = load i32, i32* %i, align 4
  %inc = add i32 %18, 1
  store i32 %inc, i32* %i, align 4
  br label %for.cond

for.end:                                          ; preds = %for.cond
  %19 = load double*, double** %output, align 4
  ret double* %19
}

; Function Attrs: noinline nounwind optnone
define hidden double* @pminx(double* noalias %ARRAY, i32 %NO_OF_ARRAY_ELEMENTS, double %X) #0 {
entry:
  %ARRAY.addr = alloca double*, align 4
  %NO_OF_ARRAY_ELEMENTS.addr = alloca i32, align 4
  %X.addr = alloca double, align 8
  %pmin_array = alloca double*, align 4
  %index = alloca i32, align 4
  store double* %ARRAY, double** %ARRAY.addr, align 4
  store i32 %NO_OF_ARRAY_ELEMENTS, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
  store double %X, double* %X.addr, align 8
  %0 = load i32, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
  %cmp = icmp ult i32 %0, 1
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %call = call i32 @puts(i8* getelementptr inbounds ([37 x i8], [37 x i8]* @.str.7, i32 0, i32 0))
  %call1 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([22 x i8], [22 x i8]* @.str.5, i32 0, i32 0), i8* getelementptr inbounds ([23 x i8], [23 x i8]* @.str.1, i32 0, i32 0), i32 152)
  call void @exit(i32 1) #5
  unreachable

if.end:                                           ; preds = %entry
  %1 = load i32, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
  %mul = mul i32 8, %1
  %call2 = call noalias i8* @malloc(i32 %mul)
  %2 = bitcast i8* %call2 to double*
  store double* %2, double** %pmin_array, align 4
  %3 = load double*, double** %pmin_array, align 4
  %cmp3 = icmp eq double* %3, null
  br i1 %cmp3, label %if.then4, label %if.end6

if.then4:                                         ; preds = %if.end
  %call5 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([33 x i8], [33 x i8]* @.str.3, i32 0, i32 0), i8* getelementptr inbounds ([23 x i8], [23 x i8]* @.str.1, i32 0, i32 0), i32 157)
  call void @perror(i8* getelementptr inbounds ([1 x i8], [1 x i8]* @.str.2, i32 0, i32 0))
  call void @exit(i32 1) #5
  unreachable

if.end6:                                          ; preds = %if.end
  store i32 0, i32* %index, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.end6
  %4 = load i32, i32* %index, align 4
  %5 = load i32, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
  %cmp7 = icmp ult i32 %4, %5
  br i1 %cmp7, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %6 = load double*, double** %ARRAY.addr, align 4
  %7 = load i32, i32* %index, align 4
  %arrayidx = getelementptr inbounds double, double* %6, i32 %7
  %8 = load double, double* %arrayidx, align 8
  %9 = load double, double* %X.addr, align 8
  %cmp8 = fcmp olt double %8, %9
  br i1 %cmp8, label %if.then9, label %if.else

if.then9:                                         ; preds = %for.body
  %10 = load double*, double** %ARRAY.addr, align 4
  %11 = load i32, i32* %index, align 4
  %arrayidx10 = getelementptr inbounds double, double* %10, i32 %11
  %12 = load double, double* %arrayidx10, align 8
  %13 = load double*, double** %pmin_array, align 4
  %14 = load i32, i32* %index, align 4
  %arrayidx11 = getelementptr inbounds double, double* %13, i32 %14
  store double %12, double* %arrayidx11, align 8
  br label %if.end13

if.else:                                          ; preds = %for.body
  %15 = load double, double* %X.addr, align 8
  %16 = load double*, double** %pmin_array, align 4
  %17 = load i32, i32* %index, align 4
  %arrayidx12 = getelementptr inbounds double, double* %16, i32 %17
  store double %15, double* %arrayidx12, align 8
  br label %if.end13

if.end13:                                         ; preds = %if.else, %if.then9
  br label %for.inc

for.inc:                                          ; preds = %if.end13
  %18 = load i32, i32* %index, align 4
  %inc = add i32 %18, 1
  store i32 %inc, i32* %index, align 4
  br label %for.cond

for.end:                                          ; preds = %for.cond
  %19 = load double*, double** %pmin_array, align 4
  ret double* %19
}

; Function Attrs: noinline nounwind optnone
define hidden void @double_say(double* noalias %ARRAY, i32 %NO_OF_ARRAY_ELEMENTS) #0 {
entry:
  %ARRAY.addr = alloca double*, align 4
  %NO_OF_ARRAY_ELEMENTS.addr = alloca i32, align 4
  %i = alloca i32, align 4
  store double* %ARRAY, double** %ARRAY.addr, align 4
  store i32 %NO_OF_ARRAY_ELEMENTS, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
  %0 = load double*, double** %ARRAY.addr, align 4
  %arrayidx = getelementptr inbounds double, double* %0, i32 0
  %1 = load double, double* %arrayidx, align 8
  %call = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([7 x i8], [7 x i8]* @.str.8, i32 0, i32 0), double %1)
  store i32 1, i32* %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %2 = load i32, i32* %i, align 4
  %3 = load i32, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
  %cmp = icmp ult i32 %2, %3
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %4 = load double*, double** %ARRAY.addr, align 4
  %5 = load i32, i32* %i, align 4
  %arrayidx1 = getelementptr inbounds double, double* %4, i32 %5
  %6 = load double, double* %arrayidx1, align 8
  %call2 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([7 x i8], [7 x i8]* @.str.9, i32 0, i32 0), double %6)
  %7 = load i32, i32* %i, align 4
  %add = add i32 %7, 1
  %rem = urem i32 %add, 5
  %cmp3 = icmp eq i32 %rem, 0
  br i1 %cmp3, label %if.then, label %if.end

if.then:                                          ; preds = %for.body
  %8 = load i32, i32* %i, align 4
  %add4 = add i32 %8, 1
  %call5 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([6 x i8], [6 x i8]* @.str.10, i32 0, i32 0), i32 %add4)
  br label %if.end

if.end:                                           ; preds = %if.then, %for.body
  br label %for.inc

for.inc:                                          ; preds = %if.end
  %9 = load i32, i32* %i, align 4
  %inc = add i32 %9, 1
  store i32 %inc, i32* %i, align 4
  br label %for.cond

for.end:                                          ; preds = %for.cond
  %call6 = call i32 @puts(i8* getelementptr inbounds ([2 x i8], [2 x i8]* @.str.11, i32 0, i32 0))
  ret void
}

; Function Attrs: noinline nounwind optnone
define hidden double* @uint2double(i32* noalias %ARRAY, i32 %NO_OF_ARRAY_ELEMENTS) #0 {
entry:
  %ARRAY.addr = alloca i32*, align 4
  %NO_OF_ARRAY_ELEMENTS.addr = alloca i32, align 4
  %doubleArray = alloca double*, align 4
  %index = alloca i32, align 4
  store i32* %ARRAY, i32** %ARRAY.addr, align 4
  store i32 %NO_OF_ARRAY_ELEMENTS, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
  %0 = load i32, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
  %mul = mul i32 8, %0
  %call = call noalias i8* @malloc(i32 %mul)
  %1 = bitcast i8* %call to double*
  store double* %1, double** %doubleArray, align 4
  %2 = load double*, double** %doubleArray, align 4
  %cmp = icmp eq double* %2, null
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %call1 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([34 x i8], [34 x i8]* @.str.12, i32 0, i32 0), i8* getelementptr inbounds ([23 x i8], [23 x i8]* @.str.1, i32 0, i32 0), i32 194)
  call void @perror(i8* getelementptr inbounds ([1 x i8], [1 x i8]* @.str.2, i32 0, i32 0))
  call void @exit(i32 1) #5
  unreachable

if.end:                                           ; preds = %entry
  store i32 0, i32* %index, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.end
  %3 = load i32, i32* %index, align 4
  %4 = load i32, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
  %cmp2 = icmp ult i32 %3, %4
  br i1 %cmp2, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %5 = load i32*, i32** %ARRAY.addr, align 4
  %6 = load i32, i32* %index, align 4
  %arrayidx = getelementptr inbounds i32, i32* %5, i32 %6
  %7 = load i32, i32* %arrayidx, align 4
  %conv = uitofp i32 %7 to double
  %8 = load double*, double** %doubleArray, align 4
  %9 = load i32, i32* %index, align 4
  %arrayidx3 = getelementptr inbounds double, double* %8, i32 %9
  store double %conv, double* %arrayidx3, align 8
  br label %for.inc

for.inc:                                          ; preds = %for.body
  %10 = load i32, i32* %index, align 4
  %inc = add i32 %10, 1
  store i32 %inc, i32* %index, align 4
  br label %for.cond

for.end:                                          ; preds = %for.cond
  %11 = load double*, double** %doubleArray, align 4
  ret double* %11
}

; Function Attrs: noinline nounwind optnone
define hidden double @min2(double %N1, double %N2) #0 {
entry:
  %retval = alloca double, align 8
  %N1.addr = alloca double, align 8
  %N2.addr = alloca double, align 8
  store double %N1, double* %N1.addr, align 8
  store double %N2, double* %N2.addr, align 8
  %0 = load double, double* %N1.addr, align 8
  %1 = load double, double* %N2.addr, align 8
  %cmp = fcmp olt double %0, %1
  br i1 %cmp, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  %2 = load double, double* %N1.addr, align 8
  store double %2, double* %retval, align 8
  br label %return

if.else:                                          ; preds = %entry
  %3 = load double, double* %N2.addr, align 8
  store double %3, double* %retval, align 8
  br label %return

return:                                           ; preds = %if.else, %if.then
  %4 = load double, double* %retval, align 8
  ret double %4
}

; Function Attrs: noinline nounwind optnone
define hidden double* @p_adjust(double* noalias %PVALUES, i32 %NO_OF_ARRAY_ELEMENTS, i8* noalias %STRING) #0 {
entry:
  %retval = alloca double*, align 4
  %PVALUES.addr = alloca double*, align 4
  %NO_OF_ARRAY_ELEMENTS.addr = alloca i32, align 4
  %STRING.addr = alloca i8*, align 4
  %TYPE = alloca i16, align 2
  %bonferroni = alloca double*, align 4
  %index = alloca i32, align 4
  %BONFERRONI = alloca double, align 8
  %o = alloca i32*, align 4
  %o2double = alloca double*, align 4
  %cummax_input = alloca double*, align 4
  %index80 = alloca i32, align 4
  %ro = alloca i32*, align 4
  %cummax_output = alloca double*, align 4
  %pmin = alloca double*, align 4
  %qvalues = alloca double*, align 4
  %index98 = alloca i32, align 4
  %o114 = alloca i32*, align 4
  %p = alloca double*, align 4
  %index123 = alloca i32, align 4
  %o2double134 = alloca double*, align 4
  %ro136 = alloca i32*, align 4
  %q = alloca double*, align 4
  %pa = alloca double*, align 4
  %min = alloca double, align 8
  %index155 = alloca i32, align 4
  %TEMP = alloca double, align 8
  %index171 = alloca i32, align 4
  %j = alloca i32, align 4
  %ij = alloca i32*, align 4
  %I2_LENGTH = alloca i32, align 4
  %i2 = alloca i32*, align 4
  %i = alloca i32, align 4
  %q1 = alloca double, align 8
  %i208 = alloca i32, align 4
  %TEMP_Q1 = alloca double, align 8
  %i227 = alloca i32, align 4
  %i244 = alloca i32, align 4
  %i256 = alloca i32, align 4
  %index274 = alloca i32, align 4
  %o288 = alloca i32*, align 4
  %o_double = alloca double*, align 4
  %index296 = alloca i32, align 4
  %ro315 = alloca i32*, align 4
  %cummin_input = alloca double*, align 4
  %index328 = alloca i32, align 4
  %NI = alloca double, align 8
  %q349 = alloca double, align 8
  %index350 = alloca i32, align 4
  %index362 = alloca i32, align 4
  %NI367 = alloca double, align 8
  %index385 = alloca i32, align 4
  %cummin_array = alloca double*, align 4
  %pmin403 = alloca double*, align 4
  %q_array = alloca double*, align 4
  %index407 = alloca i32, align 4
  store double* %PVALUES, double** %PVALUES.addr, align 4
  store i32 %NO_OF_ARRAY_ELEMENTS, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
  store i8* %STRING, i8** %STRING.addr, align 4
  %0 = load i32, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
  %cmp = icmp ult i32 %0, 1
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %call = call i32 @puts(i8* getelementptr inbounds ([41 x i8], [41 x i8]* @.str.13, i32 0, i32 0))
  %call1 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([22 x i8], [22 x i8]* @.str.5, i32 0, i32 0), i8* getelementptr inbounds ([23 x i8], [23 x i8]* @.str.1, i32 0, i32 0), i32 217)
  call void @exit(i32 1) #5
  unreachable

if.end:                                           ; preds = %entry
  store i16 -1, i16* %TYPE, align 2
  %1 = load i8*, i8** %STRING.addr, align 4
  %cmp2 = icmp eq i8* %1, null
  br i1 %cmp2, label %if.then3, label %if.else

if.then3:                                         ; preds = %if.end
  store i16 0, i16* %TYPE, align 2
  br label %if.end41

if.else:                                          ; preds = %if.end
  %2 = load i8*, i8** %STRING.addr, align 4
  %call4 = call i32 @strcasecmp(i8* %2, i8* getelementptr inbounds ([3 x i8], [3 x i8]* @.str.14, i32 0, i32 0))
  %cmp5 = icmp eq i32 %call4, 0
  br i1 %cmp5, label %if.then6, label %if.else7

if.then6:                                         ; preds = %if.else
  store i16 0, i16* %TYPE, align 2
  br label %if.end40

if.else7:                                         ; preds = %if.else
  %3 = load i8*, i8** %STRING.addr, align 4
  %call8 = call i32 @strcasecmp(i8* %3, i8* getelementptr inbounds ([4 x i8], [4 x i8]* @.str.15, i32 0, i32 0))
  %cmp9 = icmp eq i32 %call8, 0
  br i1 %cmp9, label %if.then10, label %if.else11

if.then10:                                        ; preds = %if.else7
  store i16 0, i16* %TYPE, align 2
  br label %if.end39

if.else11:                                        ; preds = %if.else7
  %4 = load i8*, i8** %STRING.addr, align 4
  %call12 = call i32 @strcasecmp(i8* %4, i8* getelementptr inbounds ([3 x i8], [3 x i8]* @.str.16, i32 0, i32 0))
  %cmp13 = icmp eq i32 %call12, 0
  br i1 %cmp13, label %if.then14, label %if.else15

if.then14:                                        ; preds = %if.else11
  store i16 1, i16* %TYPE, align 2
  br label %if.end38

if.else15:                                        ; preds = %if.else11
  %5 = load i8*, i8** %STRING.addr, align 4
  %call16 = call i32 @strcasecmp(i8* %5, i8* getelementptr inbounds ([11 x i8], [11 x i8]* @.str.17, i32 0, i32 0))
  %cmp17 = icmp eq i32 %call16, 0
  br i1 %cmp17, label %if.then18, label %if.else19

if.then18:                                        ; preds = %if.else15
  store i16 2, i16* %TYPE, align 2
  br label %if.end37

if.else19:                                        ; preds = %if.else15
  %6 = load i8*, i8** %STRING.addr, align 4
  %call20 = call i32 @strcasecmp(i8* %6, i8* getelementptr inbounds ([9 x i8], [9 x i8]* @.str.18, i32 0, i32 0))
  %cmp21 = icmp eq i32 %call20, 0
  br i1 %cmp21, label %if.then22, label %if.else23

if.then22:                                        ; preds = %if.else19
  store i16 3, i16* %TYPE, align 2
  br label %if.end36

if.else23:                                        ; preds = %if.else19
  %7 = load i8*, i8** %STRING.addr, align 4
  %call24 = call i32 @strcasecmp(i8* %7, i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.19, i32 0, i32 0))
  %cmp25 = icmp eq i32 %call24, 0
  br i1 %cmp25, label %if.then26, label %if.else27

if.then26:                                        ; preds = %if.else23
  store i16 4, i16* %TYPE, align 2
  br label %if.end35

if.else27:                                        ; preds = %if.else23
  %8 = load i8*, i8** %STRING.addr, align 4
  %call28 = call i32 @strcasecmp(i8* %8, i8* getelementptr inbounds ([7 x i8], [7 x i8]* @.str.20, i32 0, i32 0))
  %cmp29 = icmp eq i32 %call28, 0
  br i1 %cmp29, label %if.then30, label %if.else31

if.then30:                                        ; preds = %if.else27
  store i16 5, i16* %TYPE, align 2
  br label %if.end34

if.else31:                                        ; preds = %if.else27
  %9 = load i8*, i8** %STRING.addr, align 4
  %call32 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([44 x i8], [44 x i8]* @.str.21, i32 0, i32 0), i8* %9)
  %call33 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([22 x i8], [22 x i8]* @.str.5, i32 0, i32 0), i8* getelementptr inbounds ([23 x i8], [23 x i8]* @.str.1, i32 0, i32 0), i32 239)
  call void @exit(i32 1) #5
  unreachable

if.end34:                                         ; preds = %if.then30
  br label %if.end35

if.end35:                                         ; preds = %if.end34, %if.then26
  br label %if.end36

if.end36:                                         ; preds = %if.end35, %if.then22
  br label %if.end37

if.end37:                                         ; preds = %if.end36, %if.then18
  br label %if.end38

if.end38:                                         ; preds = %if.end37, %if.then14
  br label %if.end39

if.end39:                                         ; preds = %if.end38, %if.then10
  br label %if.end40

if.end40:                                         ; preds = %if.end39, %if.then6
  br label %if.end41

if.end41:                                         ; preds = %if.end40, %if.then3
  %10 = load i16, i16* %TYPE, align 2
  %conv = sext i16 %10 to i32
  %cmp42 = icmp eq i32 %conv, 2
  br i1 %cmp42, label %if.then44, label %if.else71

if.then44:                                        ; preds = %if.end41
  %11 = load i32, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
  %mul = mul i32 8, %11
  %call45 = call noalias i8* @malloc(i32 %mul)
  %12 = bitcast i8* %call45 to double*
  store double* %12, double** %bonferroni, align 4
  %13 = load double*, double** %bonferroni, align 4
  %cmp46 = icmp eq double* %13, null
  br i1 %cmp46, label %if.then48, label %if.end50

if.then48:                                        ; preds = %if.then44
  %call49 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([33 x i8], [33 x i8]* @.str.3, i32 0, i32 0), i8* getelementptr inbounds ([23 x i8], [23 x i8]* @.str.1, i32 0, i32 0), i32 247)
  call void @perror(i8* getelementptr inbounds ([1 x i8], [1 x i8]* @.str.2, i32 0, i32 0))
  call void @exit(i32 1) #5
  unreachable

if.end50:                                         ; preds = %if.then44
  store i32 0, i32* %index, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.end50
  %14 = load i32, i32* %index, align 4
  %15 = load i32, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
  %cmp51 = icmp ult i32 %14, %15
  br i1 %cmp51, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %16 = load double*, double** %PVALUES.addr, align 4
  %17 = load i32, i32* %index, align 4
  %arrayidx = getelementptr inbounds double, double* %16, i32 %17
  %18 = load double, double* %arrayidx, align 8
  %19 = load i32, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
  %conv53 = uitofp i32 %19 to double
  %mul54 = fmul double %18, %conv53
  store double %mul54, double* %BONFERRONI, align 8
  %20 = load double, double* %BONFERRONI, align 8
  %cmp55 = fcmp oge double %20, 1.000000e+00
  br i1 %cmp55, label %if.then57, label %if.else59

if.then57:                                        ; preds = %for.body
  %21 = load double*, double** %bonferroni, align 4
  %22 = load i32, i32* %index, align 4
  %arrayidx58 = getelementptr inbounds double, double* %21, i32 %22
  store double 1.000000e+00, double* %arrayidx58, align 8
  br label %if.end70

if.else59:                                        ; preds = %for.body
  %23 = load double, double* %BONFERRONI, align 8
  %cmp60 = fcmp ole double 0.000000e+00, %23
  br i1 %cmp60, label %land.lhs.true, label %if.else66

land.lhs.true:                                    ; preds = %if.else59
  %24 = load double, double* %BONFERRONI, align 8
  %cmp62 = fcmp olt double %24, 1.000000e+00
  br i1 %cmp62, label %if.then64, label %if.else66

if.then64:                                        ; preds = %land.lhs.true
  %25 = load double, double* %BONFERRONI, align 8
  %26 = load double*, double** %bonferroni, align 4
  %27 = load i32, i32* %index, align 4
  %arrayidx65 = getelementptr inbounds double, double* %26, i32 %27
  store double %25, double* %arrayidx65, align 8
  br label %if.end69

if.else66:                                        ; preds = %land.lhs.true, %if.else59
  %28 = load double, double* %BONFERRONI, align 8
  %call67 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([42 x i8], [42 x i8]* @.str.22, i32 0, i32 0), double %28)
  %call68 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([23 x i8], [23 x i8]* @.str.23, i32 0, i32 0), i8* getelementptr inbounds ([23 x i8], [23 x i8]* @.str.1, i32 0, i32 0), i32 259)
  call void @exit(i32 1) #5
  unreachable

if.end69:                                         ; preds = %if.then64
  br label %if.end70

if.end70:                                         ; preds = %if.end69, %if.then57
  br label %for.inc

for.inc:                                          ; preds = %if.end70
  %29 = load i32, i32* %index, align 4
  %inc = add i32 %29, 1
  store i32 %inc, i32* %index, align 4
  br label %for.cond

for.end:                                          ; preds = %for.cond
  %30 = load double*, double** %bonferroni, align 4
  store double* %30, double** %retval, align 4
  br label %return

if.else71:                                        ; preds = %if.end41
  %31 = load i16, i16* %TYPE, align 2
  %conv72 = sext i16 %31 to i32
  %cmp73 = icmp eq i32 %conv72, 4
  br i1 %cmp73, label %if.then75, label %if.else109

if.then75:                                        ; preds = %if.else71
  %32 = load double*, double** %PVALUES.addr, align 4
  %33 = load i32, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
  %call76 = call i32* @order(double* %32, i32 %33, i1 zeroext false)
  store i32* %call76, i32** %o, align 4
  %34 = load i32*, i32** %o, align 4
  %35 = load i32, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
  %call77 = call double* @uint2double(i32* %34, i32 %35)
  store double* %call77, double** %o2double, align 4
  %36 = load i32, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
  %mul78 = mul i32 8, %36
  %call79 = call noalias i8* @malloc(i32 %mul78)
  %37 = bitcast i8* %call79 to double*
  store double* %37, double** %cummax_input, align 4
  store i32 0, i32* %index80, align 4
  br label %for.cond81

for.cond81:                                       ; preds = %for.inc90, %if.then75
  %38 = load i32, i32* %index80, align 4
  %39 = load i32, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
  %cmp82 = icmp ult i32 %38, %39
  br i1 %cmp82, label %for.body84, label %for.end92

for.body84:                                       ; preds = %for.cond81
  %40 = load i32, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
  %41 = load i32, i32* %index80, align 4
  %sub = sub i32 %40, %41
  %conv85 = uitofp i32 %sub to double
  %42 = load double*, double** %PVALUES.addr, align 4
  %43 = load i32*, i32** %o, align 4
  %44 = load i32, i32* %index80, align 4
  %arrayidx86 = getelementptr inbounds i32, i32* %43, i32 %44
  %45 = load i32, i32* %arrayidx86, align 4
  %arrayidx87 = getelementptr inbounds double, double* %42, i32 %45
  %46 = load double, double* %arrayidx87, align 8
  %mul88 = fmul double %conv85, %46
  %47 = load double*, double** %cummax_input, align 4
  %48 = load i32, i32* %index80, align 4
  %arrayidx89 = getelementptr inbounds double, double* %47, i32 %48
  store double %mul88, double* %arrayidx89, align 8
  br label %for.inc90

for.inc90:                                        ; preds = %for.body84
  %49 = load i32, i32* %index80, align 4
  %inc91 = add i32 %49, 1
  store i32 %inc91, i32* %index80, align 4
  br label %for.cond81

for.end92:                                        ; preds = %for.cond81
  %50 = load i32*, i32** %o, align 4
  %51 = bitcast i32* %50 to i8*
  call void @free(i8* %51)
  store i32* null, i32** %o, align 4
  %52 = load double*, double** %o2double, align 4
  %53 = load i32, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
  %call93 = call i32* @order(double* %52, i32 %53, i1 zeroext false)
  store i32* %call93, i32** %ro, align 4
  %54 = load double*, double** %o2double, align 4
  %55 = bitcast double* %54 to i8*
  call void @free(i8* %55)
  store double* null, double** %o2double, align 4
  %56 = load double*, double** %cummax_input, align 4
  %57 = load i32, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
  %call94 = call double* @cummax(double* %56, i32 %57)
  store double* %call94, double** %cummax_output, align 4
  %58 = load double*, double** %cummax_input, align 4
  %59 = bitcast double* %58 to i8*
  call void @free(i8* %59)
  store double* null, double** %cummax_input, align 4
  %60 = load double*, double** %cummax_output, align 4
  %61 = load i32, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
  %call95 = call double* @pminx(double* %60, i32 %61, double 1.000000e+00)
  store double* %call95, double** %pmin, align 4
  %62 = load double*, double** %cummax_output, align 4
  %63 = bitcast double* %62 to i8*
  call void @free(i8* %63)
  store double* null, double** %cummax_output, align 4
  %64 = load i32, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
  %mul96 = mul i32 8, %64
  %call97 = call noalias i8* @malloc(i32 %mul96)
  %65 = bitcast i8* %call97 to double*
  store double* %65, double** %qvalues, align 4
  store i32 0, i32* %index98, align 4
  br label %for.cond99

for.cond99:                                       ; preds = %for.inc106, %for.end92
  %66 = load i32, i32* %index98, align 4
  %67 = load i32, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
  %cmp100 = icmp ult i32 %66, %67
  br i1 %cmp100, label %for.body102, label %for.end108

for.body102:                                      ; preds = %for.cond99
  %68 = load double*, double** %pmin, align 4
  %69 = load i32*, i32** %ro, align 4
  %70 = load i32, i32* %index98, align 4
  %arrayidx103 = getelementptr inbounds i32, i32* %69, i32 %70
  %71 = load i32, i32* %arrayidx103, align 4
  %arrayidx104 = getelementptr inbounds double, double* %68, i32 %71
  %72 = load double, double* %arrayidx104, align 8
  %73 = load double*, double** %qvalues, align 4
  %74 = load i32, i32* %index98, align 4
  %arrayidx105 = getelementptr inbounds double, double* %73, i32 %74
  store double %72, double* %arrayidx105, align 8
  br label %for.inc106

for.inc106:                                       ; preds = %for.body102
  %75 = load i32, i32* %index98, align 4
  %inc107 = add i32 %75, 1
  store i32 %inc107, i32* %index98, align 4
  br label %for.cond99

for.end108:                                       ; preds = %for.cond99
  %76 = load double*, double** %pmin, align 4
  %77 = bitcast double* %76 to i8*
  call void @free(i8* %77)
  store double* null, double** %pmin, align 4
  %78 = load i32*, i32** %ro, align 4
  %79 = bitcast i32* %78 to i8*
  call void @free(i8* %79)
  store i32* null, i32** %ro, align 4
  %80 = load double*, double** %qvalues, align 4
  store double* %80, double** %retval, align 4
  br label %return

if.else109:                                       ; preds = %if.else71
  %81 = load i16, i16* %TYPE, align 2
  %conv110 = sext i16 %81 to i32
  %cmp111 = icmp eq i32 %conv110, 5
  br i1 %cmp111, label %if.then113, label %if.end285

if.then113:                                       ; preds = %if.else109
  %82 = load double*, double** %PVALUES.addr, align 4
  %83 = load i32, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
  %call115 = call i32* @order(double* %82, i32 %83, i1 zeroext false)
  store i32* %call115, i32** %o114, align 4
  %84 = load i32, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
  %mul116 = mul i32 8, %84
  %call117 = call noalias i8* @malloc(i32 %mul116)
  %85 = bitcast i8* %call117 to double*
  store double* %85, double** %p, align 4
  %86 = load double*, double** %p, align 4
  %cmp118 = icmp eq double* %86, null
  br i1 %cmp118, label %if.then120, label %if.end122

if.then120:                                       ; preds = %if.then113
  %call121 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([33 x i8], [33 x i8]* @.str.3, i32 0, i32 0), i8* getelementptr inbounds ([23 x i8], [23 x i8]* @.str.1, i32 0, i32 0), i32 302)
  call void @perror(i8* getelementptr inbounds ([1 x i8], [1 x i8]* @.str.2, i32 0, i32 0))
  call void @exit(i32 1) #5
  unreachable

if.end122:                                        ; preds = %if.then113
  store i32 0, i32* %index123, align 4
  br label %for.cond124

for.cond124:                                      ; preds = %for.inc131, %if.end122
  %87 = load i32, i32* %index123, align 4
  %88 = load i32, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
  %cmp125 = icmp ult i32 %87, %88
  br i1 %cmp125, label %for.body127, label %for.end133

for.body127:                                      ; preds = %for.cond124
  %89 = load double*, double** %PVALUES.addr, align 4
  %90 = load i32*, i32** %o114, align 4
  %91 = load i32, i32* %index123, align 4
  %arrayidx128 = getelementptr inbounds i32, i32* %90, i32 %91
  %92 = load i32, i32* %arrayidx128, align 4
  %arrayidx129 = getelementptr inbounds double, double* %89, i32 %92
  %93 = load double, double* %arrayidx129, align 8
  %94 = load double*, double** %p, align 4
  %95 = load i32, i32* %index123, align 4
  %arrayidx130 = getelementptr inbounds double, double* %94, i32 %95
  store double %93, double* %arrayidx130, align 8
  br label %for.inc131

for.inc131:                                       ; preds = %for.body127
  %96 = load i32, i32* %index123, align 4
  %inc132 = add i32 %96, 1
  store i32 %inc132, i32* %index123, align 4
  br label %for.cond124

for.end133:                                       ; preds = %for.cond124
  %97 = load i32*, i32** %o114, align 4
  %98 = load i32, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
  %call135 = call double* @uint2double(i32* %97, i32 %98)
  store double* %call135, double** %o2double134, align 4
  %99 = load i32*, i32** %o114, align 4
  %100 = bitcast i32* %99 to i8*
  call void @free(i8* %100)
  store i32* null, i32** %o114, align 4
  %101 = load double*, double** %o2double134, align 4
  %102 = load i32, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
  %call137 = call i32* @order(double* %101, i32 %102, i1 zeroext false)
  store i32* %call137, i32** %ro136, align 4
  %103 = load double*, double** %o2double134, align 4
  %104 = bitcast double* %103 to i8*
  call void @free(i8* %104)
  store double* null, double** %o2double134, align 4
  %105 = load i32, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
  %mul138 = mul i32 8, %105
  %call139 = call noalias i8* @malloc(i32 %mul138)
  %106 = bitcast i8* %call139 to double*
  store double* %106, double** %q, align 4
  %107 = load double*, double** %q, align 4
  %cmp140 = icmp eq double* %107, null
  br i1 %cmp140, label %if.then142, label %if.end144

if.then142:                                       ; preds = %for.end133
  %call143 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([33 x i8], [33 x i8]* @.str.3, i32 0, i32 0), i8* getelementptr inbounds ([23 x i8], [23 x i8]* @.str.1, i32 0, i32 0), i32 318)
  call void @perror(i8* getelementptr inbounds ([1 x i8], [1 x i8]* @.str.2, i32 0, i32 0))
  call void @exit(i32 1) #5
  unreachable

if.end144:                                        ; preds = %for.end133
  %108 = load i32, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
  %mul145 = mul i32 8, %108
  %call146 = call noalias i8* @malloc(i32 %mul145)
  %109 = bitcast i8* %call146 to double*
  store double* %109, double** %pa, align 4
  %110 = load double*, double** %pa, align 4
  %cmp147 = icmp eq double* %110, null
  br i1 %cmp147, label %if.then149, label %if.end151

if.then149:                                       ; preds = %if.end144
  %call150 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([33 x i8], [33 x i8]* @.str.3, i32 0, i32 0), i8* getelementptr inbounds ([23 x i8], [23 x i8]* @.str.1, i32 0, i32 0), i32 324)
  call void @perror(i8* getelementptr inbounds ([1 x i8], [1 x i8]* @.str.2, i32 0, i32 0))
  call void @exit(i32 1) #5
  unreachable

if.end151:                                        ; preds = %if.end144
  %111 = load i32, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
  %conv152 = uitofp i32 %111 to double
  %112 = load double*, double** %p, align 4
  %arrayidx153 = getelementptr inbounds double, double* %112, i32 0
  %113 = load double, double* %arrayidx153, align 8
  %mul154 = fmul double %conv152, %113
  store double %mul154, double* %min, align 8
  store i32 1, i32* %index155, align 4
  br label %for.cond156

for.cond156:                                      ; preds = %for.inc168, %if.end151
  %114 = load i32, i32* %index155, align 4
  %115 = load i32, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
  %cmp157 = icmp ult i32 %114, %115
  br i1 %cmp157, label %for.body159, label %for.end170

for.body159:                                      ; preds = %for.cond156
  %116 = load i32, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
  %conv160 = uitofp i32 %116 to double
  %117 = load double*, double** %p, align 4
  %118 = load i32, i32* %index155, align 4
  %arrayidx161 = getelementptr inbounds double, double* %117, i32 %118
  %119 = load double, double* %arrayidx161, align 8
  %mul162 = fmul double %conv160, %119
  %120 = load i32, i32* %index155, align 4
  %add = add i32 1, %120
  %conv163 = uitofp i32 %add to double
  %div = fdiv double %mul162, %conv163
  store double %div, double* %TEMP, align 8
  %121 = load double, double* %TEMP, align 8
  %122 = load double, double* %min, align 8
  %cmp164 = fcmp olt double %121, %122
  br i1 %cmp164, label %if.then166, label %if.end167

if.then166:                                       ; preds = %for.body159
  %123 = load double, double* %TEMP, align 8
  store double %123, double* %min, align 8
  br label %if.end167

if.end167:                                        ; preds = %if.then166, %for.body159
  br label %for.inc168

for.inc168:                                       ; preds = %if.end167
  %124 = load i32, i32* %index155, align 4
  %inc169 = add i32 %124, 1
  store i32 %inc169, i32* %index155, align 4
  br label %for.cond156

for.end170:                                       ; preds = %for.cond156
  store i32 0, i32* %index171, align 4
  br label %for.cond172

for.cond172:                                      ; preds = %for.inc178, %for.end170
  %125 = load i32, i32* %index171, align 4
  %126 = load i32, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
  %cmp173 = icmp ult i32 %125, %126
  br i1 %cmp173, label %for.body175, label %for.end180

for.body175:                                      ; preds = %for.cond172
  %127 = load double, double* %min, align 8
  %128 = load double*, double** %pa, align 4
  %129 = load i32, i32* %index171, align 4
  %arrayidx176 = getelementptr inbounds double, double* %128, i32 %129
  store double %127, double* %arrayidx176, align 8
  %130 = load double, double* %min, align 8
  %131 = load double*, double** %q, align 4
  %132 = load i32, i32* %index171, align 4
  %arrayidx177 = getelementptr inbounds double, double* %131, i32 %132
  store double %130, double* %arrayidx177, align 8
  br label %for.inc178

for.inc178:                                       ; preds = %for.body175
  %133 = load i32, i32* %index171, align 4
  %inc179 = add i32 %133, 1
  store i32 %inc179, i32* %index171, align 4
  br label %for.cond172

for.end180:                                       ; preds = %for.cond172
  %134 = load i32, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
  %sub181 = sub i32 %134, 1
  store i32 %sub181, i32* %j, align 4
  br label %for.cond182

for.cond182:                                      ; preds = %for.inc272, %for.end180
  %135 = load i32, i32* %j, align 4
  %cmp183 = icmp uge i32 %135, 2
  br i1 %cmp183, label %for.body185, label %for.end273

for.body185:                                      ; preds = %for.cond182
  %136 = load i32, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
  %137 = load i32, i32* %j, align 4
  %sub186 = sub i32 %136, %137
  %call187 = call i32* @seq_len(i32 0, i32 %sub186)
  store i32* %call187, i32** %ij, align 4
  %138 = load i32, i32* %j, align 4
  %sub188 = sub i32 %138, 1
  store i32 %sub188, i32* %I2_LENGTH, align 4
  %139 = load i32, i32* %I2_LENGTH, align 4
  %mul189 = mul i32 %139, 4
  %call190 = call noalias i8* @malloc(i32 %mul189)
  %140 = bitcast i8* %call190 to i32*
  store i32* %140, i32** %i2, align 4
  store i32 0, i32* %i, align 4
  br label %for.cond191

for.cond191:                                      ; preds = %for.inc200, %for.body185
  %141 = load i32, i32* %i, align 4
  %142 = load i32, i32* %I2_LENGTH, align 4
  %cmp192 = icmp ult i32 %141, %142
  br i1 %cmp192, label %for.body194, label %for.end202

for.body194:                                      ; preds = %for.cond191
  %143 = load i32, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
  %144 = load i32, i32* %j, align 4
  %sub195 = sub i32 %143, %144
  %add196 = add i32 %sub195, 2
  %145 = load i32, i32* %i, align 4
  %add197 = add i32 %add196, %145
  %sub198 = sub i32 %add197, 1
  %146 = load i32*, i32** %i2, align 4
  %147 = load i32, i32* %i, align 4
  %arrayidx199 = getelementptr inbounds i32, i32* %146, i32 %147
  store i32 %sub198, i32* %arrayidx199, align 4
  br label %for.inc200

for.inc200:                                       ; preds = %for.body194
  %148 = load i32, i32* %i, align 4
  %inc201 = add i32 %148, 1
  store i32 %inc201, i32* %i, align 4
  br label %for.cond191

for.end202:                                       ; preds = %for.cond191
  %149 = load i32, i32* %j, align 4
  %conv203 = uitofp i32 %149 to double
  %150 = load double*, double** %p, align 4
  %151 = load i32*, i32** %i2, align 4
  %arrayidx204 = getelementptr inbounds i32, i32* %151, i32 0
  %152 = load i32, i32* %arrayidx204, align 4
  %arrayidx205 = getelementptr inbounds double, double* %150, i32 %152
  %153 = load double, double* %arrayidx205, align 8
  %mul206 = fmul double %conv203, %153
  %div207 = fdiv double %mul206, 2.000000e+00
  store double %div207, double* %q1, align 8
  store i32 1, i32* %i208, align 4
  br label %for.cond209

for.cond209:                                      ; preds = %for.inc224, %for.end202
  %154 = load i32, i32* %i208, align 4
  %155 = load i32, i32* %I2_LENGTH, align 4
  %cmp210 = icmp ult i32 %154, %155
  br i1 %cmp210, label %for.body212, label %for.end226

for.body212:                                      ; preds = %for.cond209
  %156 = load i32, i32* %j, align 4
  %conv213 = uitofp i32 %156 to double
  %157 = load double*, double** %p, align 4
  %158 = load i32*, i32** %i2, align 4
  %159 = load i32, i32* %i208, align 4
  %arrayidx214 = getelementptr inbounds i32, i32* %158, i32 %159
  %160 = load i32, i32* %arrayidx214, align 4
  %arrayidx215 = getelementptr inbounds double, double* %157, i32 %160
  %161 = load double, double* %arrayidx215, align 8
  %mul216 = fmul double %conv213, %161
  %162 = load i32, i32* %i208, align 4
  %add217 = add i32 2, %162
  %conv218 = uitofp i32 %add217 to double
  %div219 = fdiv double %mul216, %conv218
  store double %div219, double* %TEMP_Q1, align 8
  %163 = load double, double* %TEMP_Q1, align 8
  %164 = load double, double* %q1, align 8
  %cmp220 = fcmp olt double %163, %164
  br i1 %cmp220, label %if.then222, label %if.end223

if.then222:                                       ; preds = %for.body212
  %165 = load double, double* %TEMP_Q1, align 8
  store double %165, double* %q1, align 8
  br label %if.end223

if.end223:                                        ; preds = %if.then222, %for.body212
  br label %for.inc224

for.inc224:                                       ; preds = %if.end223
  %166 = load i32, i32* %i208, align 4
  %inc225 = add i32 %166, 1
  store i32 %inc225, i32* %i208, align 4
  br label %for.cond209

for.end226:                                       ; preds = %for.cond209
  store i32 0, i32* %i227, align 4
  br label %for.cond228

for.cond228:                                      ; preds = %for.inc241, %for.end226
  %167 = load i32, i32* %i227, align 4
  %168 = load i32, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
  %169 = load i32, i32* %j, align 4
  %sub229 = sub i32 %168, %169
  %add230 = add i32 %sub229, 1
  %cmp231 = icmp ult i32 %167, %add230
  br i1 %cmp231, label %for.body233, label %for.end243

for.body233:                                      ; preds = %for.cond228
  %170 = load i32, i32* %j, align 4
  %conv234 = uitofp i32 %170 to double
  %171 = load double*, double** %p, align 4
  %172 = load i32*, i32** %ij, align 4
  %173 = load i32, i32* %i227, align 4
  %arrayidx235 = getelementptr inbounds i32, i32* %172, i32 %173
  %174 = load i32, i32* %arrayidx235, align 4
  %arrayidx236 = getelementptr inbounds double, double* %171, i32 %174
  %175 = load double, double* %arrayidx236, align 8
  %mul237 = fmul double %conv234, %175
  %176 = load double, double* %q1, align 8
  %call238 = call double @min2(double %mul237, double %176)
  %177 = load double*, double** %q, align 4
  %178 = load i32*, i32** %ij, align 4
  %179 = load i32, i32* %i227, align 4
  %arrayidx239 = getelementptr inbounds i32, i32* %178, i32 %179
  %180 = load i32, i32* %arrayidx239, align 4
  %arrayidx240 = getelementptr inbounds double, double* %177, i32 %180
  store double %call238, double* %arrayidx240, align 8
  br label %for.inc241

for.inc241:                                       ; preds = %for.body233
  %181 = load i32, i32* %i227, align 4
  %inc242 = add i32 %181, 1
  store i32 %inc242, i32* %i227, align 4
  br label %for.cond228

for.end243:                                       ; preds = %for.cond228
  %182 = load i32*, i32** %ij, align 4
  %183 = bitcast i32* %182 to i8*
  call void @free(i8* %183)
  store i32* null, i32** %ij, align 4
  store i32 0, i32* %i244, align 4
  br label %for.cond245

for.cond245:                                      ; preds = %for.inc253, %for.end243
  %184 = load i32, i32* %i244, align 4
  %185 = load i32, i32* %I2_LENGTH, align 4
  %cmp246 = icmp ult i32 %184, %185
  br i1 %cmp246, label %for.body248, label %for.end255

for.body248:                                      ; preds = %for.cond245
  %186 = load double*, double** %q, align 4
  %187 = load i32, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
  %188 = load i32, i32* %j, align 4
  %sub249 = sub i32 %187, %188
  %arrayidx250 = getelementptr inbounds double, double* %186, i32 %sub249
  %189 = load double, double* %arrayidx250, align 8
  %190 = load double*, double** %q, align 4
  %191 = load i32*, i32** %i2, align 4
  %192 = load i32, i32* %i244, align 4
  %arrayidx251 = getelementptr inbounds i32, i32* %191, i32 %192
  %193 = load i32, i32* %arrayidx251, align 4
  %arrayidx252 = getelementptr inbounds double, double* %190, i32 %193
  store double %189, double* %arrayidx252, align 8
  br label %for.inc253

for.inc253:                                       ; preds = %for.body248
  %194 = load i32, i32* %i244, align 4
  %inc254 = add i32 %194, 1
  store i32 %inc254, i32* %i244, align 4
  br label %for.cond245

for.end255:                                       ; preds = %for.cond245
  %195 = load i32*, i32** %i2, align 4
  %196 = bitcast i32* %195 to i8*
  call void @free(i8* %196)
  store i32* null, i32** %i2, align 4
  store i32 0, i32* %i256, align 4
  br label %for.cond257

for.cond257:                                      ; preds = %for.inc269, %for.end255
  %197 = load i32, i32* %i256, align 4
  %198 = load i32, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
  %cmp258 = icmp ult i32 %197, %198
  br i1 %cmp258, label %for.body260, label %for.end271

for.body260:                                      ; preds = %for.cond257
  %199 = load double*, double** %pa, align 4
  %200 = load i32, i32* %i256, align 4
  %arrayidx261 = getelementptr inbounds double, double* %199, i32 %200
  %201 = load double, double* %arrayidx261, align 8
  %202 = load double*, double** %q, align 4
  %203 = load i32, i32* %i256, align 4
  %arrayidx262 = getelementptr inbounds double, double* %202, i32 %203
  %204 = load double, double* %arrayidx262, align 8
  %cmp263 = fcmp olt double %201, %204
  br i1 %cmp263, label %if.then265, label %if.end268

if.then265:                                       ; preds = %for.body260
  %205 = load double*, double** %q, align 4
  %206 = load i32, i32* %i256, align 4
  %arrayidx266 = getelementptr inbounds double, double* %205, i32 %206
  %207 = load double, double* %arrayidx266, align 8
  %208 = load double*, double** %pa, align 4
  %209 = load i32, i32* %i256, align 4
  %arrayidx267 = getelementptr inbounds double, double* %208, i32 %209
  store double %207, double* %arrayidx267, align 8
  br label %if.end268

if.end268:                                        ; preds = %if.then265, %for.body260
  br label %for.inc269

for.inc269:                                       ; preds = %if.end268
  %210 = load i32, i32* %i256, align 4
  %inc270 = add i32 %210, 1
  store i32 %inc270, i32* %i256, align 4
  br label %for.cond257

for.end271:                                       ; preds = %for.cond257
  br label %for.inc272

for.inc272:                                       ; preds = %for.end271
  %211 = load i32, i32* %j, align 4
  %dec = add i32 %211, -1
  store i32 %dec, i32* %j, align 4
  br label %for.cond182

for.end273:                                       ; preds = %for.cond182
  %212 = load double*, double** %p, align 4
  %213 = bitcast double* %212 to i8*
  call void @free(i8* %213)
  store double* null, double** %p, align 4
  store i32 0, i32* %index274, align 4
  br label %for.cond275

for.cond275:                                      ; preds = %for.inc282, %for.end273
  %214 = load i32, i32* %index274, align 4
  %215 = load i32, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
  %cmp276 = icmp ult i32 %214, %215
  br i1 %cmp276, label %for.body278, label %for.end284

for.body278:                                      ; preds = %for.cond275
  %216 = load double*, double** %pa, align 4
  %217 = load i32*, i32** %ro136, align 4
  %218 = load i32, i32* %index274, align 4
  %arrayidx279 = getelementptr inbounds i32, i32* %217, i32 %218
  %219 = load i32, i32* %arrayidx279, align 4
  %arrayidx280 = getelementptr inbounds double, double* %216, i32 %219
  %220 = load double, double* %arrayidx280, align 8
  %221 = load double*, double** %q, align 4
  %222 = load i32, i32* %index274, align 4
  %arrayidx281 = getelementptr inbounds double, double* %221, i32 %222
  store double %220, double* %arrayidx281, align 8
  br label %for.inc282

for.inc282:                                       ; preds = %for.body278
  %223 = load i32, i32* %index274, align 4
  %inc283 = add i32 %223, 1
  store i32 %inc283, i32* %index274, align 4
  br label %for.cond275

for.end284:                                       ; preds = %for.cond275
  %224 = load i32*, i32** %ro136, align 4
  %225 = bitcast i32* %224 to i8*
  call void @free(i8* %225)
  store i32* null, i32** %ro136, align 4
  %226 = load double*, double** %pa, align 4
  %227 = bitcast double* %226 to i8*
  call void @free(i8* %227)
  store double* null, double** %pa, align 4
  %228 = load double*, double** %q, align 4
  store double* %228, double** %retval, align 4
  br label %return

if.end285:                                        ; preds = %if.else109
  br label %if.end286

if.end286:                                        ; preds = %if.end285
  br label %if.end287

if.end287:                                        ; preds = %if.end286
  %229 = load double*, double** %PVALUES.addr, align 4
  %230 = load i32, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
  %call289 = call i32* @order(double* %229, i32 %230, i1 zeroext true)
  store i32* %call289, i32** %o288, align 4
  %231 = load i32*, i32** %o288, align 4
  %cmp290 = icmp eq i32* %231, null
  br i1 %cmp290, label %if.then292, label %if.end294

if.then292:                                       ; preds = %if.end287
  %call293 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([33 x i8], [33 x i8]* @.str.3, i32 0, i32 0), i8* getelementptr inbounds ([23 x i8], [23 x i8]* @.str.1, i32 0, i32 0), i32 398)
  call void @perror(i8* getelementptr inbounds ([1 x i8], [1 x i8]* @.str.2, i32 0, i32 0))
  call void @exit(i32 1) #5
  unreachable

if.end294:                                        ; preds = %if.end287
  %232 = load i32*, i32** %o288, align 4
  %233 = load i32, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
  %call295 = call double* @uint2double(i32* %232, i32 %233)
  store double* %call295, double** %o_double, align 4
  store i32 0, i32* %index296, align 4
  br label %for.cond297

for.cond297:                                      ; preds = %for.inc312, %if.end294
  %234 = load i32, i32* %index296, align 4
  %235 = load i32, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
  %cmp298 = icmp ult i32 %234, %235
  br i1 %cmp298, label %for.body300, label %for.end314

for.body300:                                      ; preds = %for.cond297
  %236 = load double*, double** %PVALUES.addr, align 4
  %237 = load i32, i32* %index296, align 4
  %arrayidx301 = getelementptr inbounds double, double* %236, i32 %237
  %238 = load double, double* %arrayidx301, align 8
  %cmp302 = fcmp olt double %238, 0.000000e+00
  br i1 %cmp302, label %if.then307, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %for.body300
  %239 = load double*, double** %PVALUES.addr, align 4
  %240 = load i32, i32* %index296, align 4
  %arrayidx304 = getelementptr inbounds double, double* %239, i32 %240
  %241 = load double, double* %arrayidx304, align 8
  %cmp305 = fcmp ogt double %241, 1.000000e+00
  br i1 %cmp305, label %if.then307, label %if.end311

if.then307:                                       ; preds = %lor.lhs.false, %for.body300
  %242 = load i32, i32* %index296, align 4
  %243 = load double*, double** %PVALUES.addr, align 4
  %244 = load i32, i32* %index296, align 4
  %arrayidx308 = getelementptr inbounds double, double* %243, i32 %244
  %245 = load double, double* %arrayidx308, align 8
  %call309 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([54 x i8], [54 x i8]* @.str.24, i32 0, i32 0), i32 %242, double %245)
  %call310 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([20 x i8], [20 x i8]* @.str.25, i32 0, i32 0), i8* getelementptr inbounds ([23 x i8], [23 x i8]* @.str.1, i32 0, i32 0), i32 406)
  call void @exit(i32 1) #5
  unreachable

if.end311:                                        ; preds = %lor.lhs.false
  br label %for.inc312

for.inc312:                                       ; preds = %if.end311
  %246 = load i32, i32* %index296, align 4
  %inc313 = add i32 %246, 1
  store i32 %inc313, i32* %index296, align 4
  br label %for.cond297

for.end314:                                       ; preds = %for.cond297
  %247 = load double*, double** %o_double, align 4
  %248 = load i32, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
  %call316 = call i32* @order(double* %247, i32 %248, i1 zeroext false)
  store i32* %call316, i32** %ro315, align 4
  %249 = load i32*, i32** %ro315, align 4
  %cmp317 = icmp eq i32* %249, null
  br i1 %cmp317, label %if.then319, label %if.end321

if.then319:                                       ; preds = %for.end314
  %call320 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([33 x i8], [33 x i8]* @.str.3, i32 0, i32 0), i8* getelementptr inbounds ([23 x i8], [23 x i8]* @.str.1, i32 0, i32 0), i32 413)
  call void @perror(i8* getelementptr inbounds ([1 x i8], [1 x i8]* @.str.2, i32 0, i32 0))
  call void @exit(i32 1) #5
  unreachable

if.end321:                                        ; preds = %for.end314
  %250 = load double*, double** %o_double, align 4
  %251 = bitcast double* %250 to i8*
  call void @free(i8* %251)
  store double* null, double** %o_double, align 4
  %252 = load i32, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
  %mul322 = mul i32 8, %252
  %call323 = call noalias i8* @malloc(i32 %mul322)
  %253 = bitcast i8* %call323 to double*
  store double* %253, double** %cummin_input, align 4
  %254 = load i16, i16* %TYPE, align 2
  %conv324 = sext i16 %254 to i32
  %cmp325 = icmp eq i32 %conv324, 0
  br i1 %cmp325, label %if.then327, label %if.else344

if.then327:                                       ; preds = %if.end321
  store i32 0, i32* %index328, align 4
  br label %for.cond329

for.cond329:                                      ; preds = %for.inc341, %if.then327
  %255 = load i32, i32* %index328, align 4
  %256 = load i32, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
  %cmp330 = icmp ult i32 %255, %256
  br i1 %cmp330, label %for.body332, label %for.end343

for.body332:                                      ; preds = %for.cond329
  %257 = load i32, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
  %conv333 = uitofp i32 %257 to double
  %258 = load i32, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
  %259 = load i32, i32* %index328, align 4
  %sub334 = sub i32 %258, %259
  %conv335 = uitofp i32 %sub334 to double
  %div336 = fdiv double %conv333, %conv335
  store double %div336, double* %NI, align 8
  %260 = load double, double* %NI, align 8
  %261 = load double*, double** %PVALUES.addr, align 4
  %262 = load i32*, i32** %o288, align 4
  %263 = load i32, i32* %index328, align 4
  %arrayidx337 = getelementptr inbounds i32, i32* %262, i32 %263
  %264 = load i32, i32* %arrayidx337, align 4
  %arrayidx338 = getelementptr inbounds double, double* %261, i32 %264
  %265 = load double, double* %arrayidx338, align 8
  %mul339 = fmul double %260, %265
  %266 = load double*, double** %cummin_input, align 4
  %267 = load i32, i32* %index328, align 4
  %arrayidx340 = getelementptr inbounds double, double* %266, i32 %267
  store double %mul339, double* %arrayidx340, align 8
  br label %for.inc341

for.inc341:                                       ; preds = %for.body332
  %268 = load i32, i32* %index328, align 4
  %inc342 = add i32 %268, 1
  store i32 %inc342, i32* %index328, align 4
  br label %for.cond329

for.end343:                                       ; preds = %for.cond329
  br label %if.end401

if.else344:                                       ; preds = %if.end321
  %269 = load i16, i16* %TYPE, align 2
  %conv345 = sext i16 %269 to i32
  %cmp346 = icmp eq i32 %conv345, 1
  br i1 %cmp346, label %if.then348, label %if.else380

if.then348:                                       ; preds = %if.else344
  store double 1.000000e+00, double* %q349, align 8
  store i32 2, i32* %index350, align 4
  br label %for.cond351

for.cond351:                                      ; preds = %for.inc359, %if.then348
  %270 = load i32, i32* %index350, align 4
  %271 = load i32, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
  %add352 = add i32 1, %271
  %cmp353 = icmp ult i32 %270, %add352
  br i1 %cmp353, label %for.body355, label %for.end361

for.body355:                                      ; preds = %for.cond351
  %272 = load i32, i32* %index350, align 4
  %conv356 = uitofp i32 %272 to double
  %div357 = fdiv double 1.000000e+00, %conv356
  %273 = load double, double* %q349, align 8
  %add358 = fadd double %273, %div357
  store double %add358, double* %q349, align 8
  br label %for.inc359

for.inc359:                                       ; preds = %for.body355
  %274 = load i32, i32* %index350, align 4
  %inc360 = add i32 %274, 1
  store i32 %inc360, i32* %index350, align 4
  br label %for.cond351

for.end361:                                       ; preds = %for.cond351
  store i32 0, i32* %index362, align 4
  br label %for.cond363

for.cond363:                                      ; preds = %for.inc377, %for.end361
  %275 = load i32, i32* %index362, align 4
  %276 = load i32, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
  %cmp364 = icmp ult i32 %275, %276
  br i1 %cmp364, label %for.body366, label %for.end379

for.body366:                                      ; preds = %for.cond363
  %277 = load i32, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
  %conv368 = uitofp i32 %277 to double
  %278 = load i32, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
  %279 = load i32, i32* %index362, align 4
  %sub369 = sub i32 %278, %279
  %conv370 = uitofp i32 %sub369 to double
  %div371 = fdiv double %conv368, %conv370
  store double %div371, double* %NI367, align 8
  %280 = load double, double* %q349, align 8
  %281 = load double, double* %NI367, align 8
  %mul372 = fmul double %280, %281
  %282 = load double*, double** %PVALUES.addr, align 4
  %283 = load i32*, i32** %o288, align 4
  %284 = load i32, i32* %index362, align 4
  %arrayidx373 = getelementptr inbounds i32, i32* %283, i32 %284
  %285 = load i32, i32* %arrayidx373, align 4
  %arrayidx374 = getelementptr inbounds double, double* %282, i32 %285
  %286 = load double, double* %arrayidx374, align 8
  %mul375 = fmul double %mul372, %286
  %287 = load double*, double** %cummin_input, align 4
  %288 = load i32, i32* %index362, align 4
  %arrayidx376 = getelementptr inbounds double, double* %287, i32 %288
  store double %mul375, double* %arrayidx376, align 8
  br label %for.inc377

for.inc377:                                       ; preds = %for.body366
  %289 = load i32, i32* %index362, align 4
  %inc378 = add i32 %289, 1
  store i32 %inc378, i32* %index362, align 4
  br label %for.cond363

for.end379:                                       ; preds = %for.cond363
  br label %if.end400

if.else380:                                       ; preds = %if.else344
  %290 = load i16, i16* %TYPE, align 2
  %conv381 = sext i16 %290 to i32
  %cmp382 = icmp eq i32 %conv381, 3
  br i1 %cmp382, label %if.then384, label %if.end399

if.then384:                                       ; preds = %if.else380
  store i32 0, i32* %index385, align 4
  br label %for.cond386

for.cond386:                                      ; preds = %for.inc396, %if.then384
  %291 = load i32, i32* %index385, align 4
  %292 = load i32, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
  %cmp387 = icmp ult i32 %291, %292
  br i1 %cmp387, label %for.body389, label %for.end398

for.body389:                                      ; preds = %for.cond386
  %293 = load i32, i32* %index385, align 4
  %add390 = add i32 %293, 1
  %conv391 = uitofp i32 %add390 to double
  %294 = load double*, double** %PVALUES.addr, align 4
  %295 = load i32*, i32** %o288, align 4
  %296 = load i32, i32* %index385, align 4
  %arrayidx392 = getelementptr inbounds i32, i32* %295, i32 %296
  %297 = load i32, i32* %arrayidx392, align 4
  %arrayidx393 = getelementptr inbounds double, double* %294, i32 %297
  %298 = load double, double* %arrayidx393, align 8
  %mul394 = fmul double %conv391, %298
  %299 = load double*, double** %cummin_input, align 4
  %300 = load i32, i32* %index385, align 4
  %arrayidx395 = getelementptr inbounds double, double* %299, i32 %300
  store double %mul394, double* %arrayidx395, align 8
  br label %for.inc396

for.inc396:                                       ; preds = %for.body389
  %301 = load i32, i32* %index385, align 4
  %inc397 = add i32 %301, 1
  store i32 %inc397, i32* %index385, align 4
  br label %for.cond386

for.end398:                                       ; preds = %for.cond386
  br label %if.end399

if.end399:                                        ; preds = %for.end398, %if.else380
  br label %if.end400

if.end400:                                        ; preds = %if.end399, %for.end379
  br label %if.end401

if.end401:                                        ; preds = %if.end400, %for.end343
  %302 = load i32*, i32** %o288, align 4
  %303 = bitcast i32* %302 to i8*
  call void @free(i8* %303)
  store i32* null, i32** %o288, align 4
  store double* null, double** %cummin_array, align 4
  %304 = load double*, double** %cummin_input, align 4
  %305 = load i32, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
  %call402 = call double* @cummin(double* %304, i32 %305)
  store double* %call402, double** %cummin_array, align 4
  %306 = load double*, double** %cummin_input, align 4
  %307 = bitcast double* %306 to i8*
  call void @free(i8* %307)
  store double* null, double** %cummin_input, align 4
  %308 = load double*, double** %cummin_array, align 4
  %309 = load i32, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
  %call404 = call double* @pminx(double* %308, i32 %309, double 1.000000e+00)
  store double* %call404, double** %pmin403, align 4
  %310 = load double*, double** %cummin_array, align 4
  %311 = bitcast double* %310 to i8*
  call void @free(i8* %311)
  store double* null, double** %cummin_array, align 4
  %312 = load i32, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
  %mul405 = mul i32 %312, 8
  %call406 = call noalias i8* @malloc(i32 %mul405)
  %313 = bitcast i8* %call406 to double*
  store double* %313, double** %q_array, align 4
  store i32 0, i32* %index407, align 4
  br label %for.cond408

for.cond408:                                      ; preds = %for.inc415, %if.end401
  %314 = load i32, i32* %index407, align 4
  %315 = load i32, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
  %cmp409 = icmp ult i32 %314, %315
  br i1 %cmp409, label %for.body411, label %for.end417

for.body411:                                      ; preds = %for.cond408
  %316 = load double*, double** %pmin403, align 4
  %317 = load i32*, i32** %ro315, align 4
  %318 = load i32, i32* %index407, align 4
  %arrayidx412 = getelementptr inbounds i32, i32* %317, i32 %318
  %319 = load i32, i32* %arrayidx412, align 4
  %arrayidx413 = getelementptr inbounds double, double* %316, i32 %319
  %320 = load double, double* %arrayidx413, align 8
  %321 = load double*, double** %q_array, align 4
  %322 = load i32, i32* %index407, align 4
  %arrayidx414 = getelementptr inbounds double, double* %321, i32 %322
  store double %320, double* %arrayidx414, align 8
  br label %for.inc415

for.inc415:                                       ; preds = %for.body411
  %323 = load i32, i32* %index407, align 4
  %inc416 = add i32 %323, 1
  store i32 %inc416, i32* %index407, align 4
  br label %for.cond408

for.end417:                                       ; preds = %for.cond408
  %324 = load i32*, i32** %ro315, align 4
  %325 = bitcast i32* %324 to i8*
  call void @free(i8* %325)
  store i32* null, i32** %ro315, align 4
  %326 = load double*, double** %pmin403, align 4
  %327 = bitcast double* %326 to i8*
  call void @free(i8* %327)
  store double* null, double** %pmin403, align 4
  %328 = load double*, double** %q_array, align 4
  store double* %328, double** %retval, align 4
  br label %return

return:                                           ; preds = %for.end417, %for.end284, %for.end108, %for.end
  %329 = load double*, double** %retval, align 4
  ret double* %329
}

declare i32 @strcasecmp(i8* %0, i8* %1) #1

; Function Attrs: noinline nounwind optnone
define hidden i32 @main() #0 {
entry:
  %retval = alloca i32, align 4
  %PVALUES = alloca [50 x double], align 16
  %CORRECT_ANSWERS = alloca [6 x [50 x double]], align 16
  %TYPES = alloca [6 x i8*], align 16
  %type = alloca i16, align 2
  %q = alloca double*, align 4
  %error = alloca double, align 8
  %i = alloca i32, align 4
  %this_error = alloca double, align 8
  store i32 0, i32* %retval, align 4
  %0 = bitcast [50 x double]* %PVALUES to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 16 %0, i8* align 16 bitcast ([50 x double]* @__const.main.PVALUES to i8*), i32 400, i1 false)
  %1 = bitcast [6 x [50 x double]]* %CORRECT_ANSWERS to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 16 %1, i8* align 16 bitcast ([6 x [50 x double]]* @__const.main.CORRECT_ANSWERS to i8*), i32 2400, i1 false)
  %2 = bitcast [6 x i8*]* %TYPES to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 16 %2, i8* align 16 bitcast ([6 x i8*]* @__const.main.TYPES to i8*), i32 24, i1 false)
  store i16 0, i16* %type, align 2
  br label %for.cond

for.cond:                                         ; preds = %for.inc19, %entry
  %3 = load i16, i16* %type, align 2
  %conv = zext i16 %3 to i32
  %cmp = icmp sle i32 %conv, 5
  br i1 %cmp, label %for.body, label %for.end21

for.body:                                         ; preds = %for.cond
  %arraydecay = getelementptr inbounds [50 x double], [50 x double]* %PVALUES, i32 0, i32 0
  %4 = load i16, i16* %type, align 2
  %idxprom = zext i16 %4 to i32
  %arrayidx = getelementptr inbounds [6 x i8*], [6 x i8*]* %TYPES, i32 0, i32 %idxprom
  %5 = load i8*, i8** %arrayidx, align 4
  %call = call double* @p_adjust(double* %arraydecay, i32 50, i8* %5)
  store double* %call, double** %q, align 4
  %6 = load double*, double** %q, align 4
  %arrayidx2 = getelementptr inbounds double, double* %6, i32 0
  %7 = load double, double* %arrayidx2, align 8
  %8 = load i16, i16* %type, align 2
  %idxprom3 = zext i16 %8 to i32
  %arrayidx4 = getelementptr inbounds [6 x [50 x double]], [6 x [50 x double]]* %CORRECT_ANSWERS, i32 0, i32 %idxprom3
  %arrayidx5 = getelementptr inbounds [50 x double], [50 x double]* %arrayidx4, i32 0, i32 0
  %9 = load double, double* %arrayidx5, align 16
  %sub = fsub double %7, %9
  %10 = call double @llvm.fabs.f64(double %sub)
  store double %10, double* %error, align 8
  store i32 1, i32* %i, align 4
  br label %for.cond6

for.cond6:                                        ; preds = %for.inc, %for.body
  %11 = load i32, i32* %i, align 4
  %cmp7 = icmp ult i32 %11, 50
  br i1 %cmp7, label %for.body9, label %for.end

for.body9:                                        ; preds = %for.cond6
  %12 = load double*, double** %q, align 4
  %13 = load i32, i32* %i, align 4
  %arrayidx10 = getelementptr inbounds double, double* %12, i32 %13
  %14 = load double, double* %arrayidx10, align 8
  %15 = load i16, i16* %type, align 2
  %idxprom11 = zext i16 %15 to i32
  %arrayidx12 = getelementptr inbounds [6 x [50 x double]], [6 x [50 x double]]* %CORRECT_ANSWERS, i32 0, i32 %idxprom11
  %16 = load i32, i32* %i, align 4
  %arrayidx13 = getelementptr inbounds [50 x double], [50 x double]* %arrayidx12, i32 0, i32 %16
  %17 = load double, double* %arrayidx13, align 8
  %sub14 = fsub double %14, %17
  %18 = call double @llvm.fabs.f64(double %sub14)
  store double %18, double* %this_error, align 8
  %19 = load double, double* %this_error, align 8
  %20 = load double, double* %error, align 8
  %add = fadd double %20, %19
  store double %add, double* %error, align 8
  br label %for.inc

for.inc:                                          ; preds = %for.body9
  %21 = load i32, i32* %i, align 4
  %inc = add i32 %21, 1
  store i32 %inc, i32* %i, align 4
  br label %for.cond6

for.end:                                          ; preds = %for.cond6
  %22 = load double*, double** %q, align 4
  call void @double_say(double* %22, i32 50)
  %23 = load double*, double** %q, align 4
  %24 = bitcast double* %23 to i8*
  call void @free(i8* %24)
  store double* null, double** %q, align 4
  %25 = load i16, i16* %type, align 2
  %conv15 = zext i16 %25 to i32
  %26 = load i16, i16* %type, align 2
  %idxprom16 = zext i16 %26 to i32
  %arrayidx17 = getelementptr inbounds [6 x i8*], [6 x i8*]* %TYPES, i32 0, i32 %idxprom16
  %27 = load i8*, i8** %arrayidx17, align 4
  %28 = load double, double* %error, align 8
  %call18 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([44 x i8], [44 x i8]* @.str.28, i32 0, i32 0), i32 %conv15, i8* %27, double %28)
  br label %for.inc19

for.inc19:                                        ; preds = %for.end
  %29 = load i16, i16* %type, align 2
  %inc20 = add i16 %29, 1
  store i16 %inc20, i16* %type, align 2
  br label %for.cond

for.end21:                                        ; preds = %for.cond
  ret i32 0
}

; Function Attrs: argmemonly nounwind willreturn
declare void @llvm.memcpy.p0i8.p0i8.i32(i8* noalias nocapture writeonly %0, i8* noalias nocapture readonly %1, i32 %2, i1 immarg %3) #3

; Function Attrs: nounwind readnone speculatable willreturn
declare double @llvm.fabs.f64(double %0) #4

attributes #0 = { noinline nounwind optnone "correctly-rounded-divide-sqrt-fp-math"="false" "disable-tail-calls"="false" "frame-pointer"="none" "less-precise-fpmad"="false" "min-legal-vector-width"="0" "no-infs-fp-math"="false" "no-jump-tables"="false" "no-nans-fp-math"="false" "no-signed-zeros-fp-math"="false" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="generic" "unsafe-fp-math"="false" "use-soft-float"="false" }
attributes #1 = { "correctly-rounded-divide-sqrt-fp-math"="false" "disable-tail-calls"="false" "frame-pointer"="none" "less-precise-fpmad"="false" "no-infs-fp-math"="false" "no-nans-fp-math"="false" "no-signed-zeros-fp-math"="false" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="generic" "unsafe-fp-math"="false" "use-soft-float"="false" }
attributes #2 = { noreturn "correctly-rounded-divide-sqrt-fp-math"="false" "disable-tail-calls"="false" "frame-pointer"="none" "less-precise-fpmad"="false" "no-infs-fp-math"="false" "no-nans-fp-math"="false" "no-signed-zeros-fp-math"="false" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="generic" "unsafe-fp-math"="false" "use-soft-float"="false" }
attributes #3 = { argmemonly nounwind willreturn }
attributes #4 = { nounwind readnone speculatable willreturn }
attributes #5 = { noreturn }

!llvm.module.flags = !{!0}
!llvm.ident = !{!1}

!0 = !{i32 1, !"wchar_size", i32 4}
!1 = !{!"clang version 11.0.0 (https://github.com/Jacarte/llvm-project.git 0f6dea67136cc1e0b3d200eb2bb165628970c44b)"}

; extracted candidates

; *****
; For LLVM instruction:
;  %cmp = fcmp olt double %0, %1
; Looking for a replacement for:
%0:i1 = var
infer %0
#########################################################
; exiting Souper's runOnFunction() for min2()

; entering Souper's runOnFunction() for p_adjust()

; ModuleID = './P-value_correction.c.bc'
source_filename = "./P-value_correction.c"
target datalayout = "e-m:e-p:32:32-i64:64-n32:64-S128"
target triple = "wasm32-unknown-wasi"

@.str = private unnamed_addr constant [29 x i8] c"malloc failed at %s line %u\0A\00", align 1
@.str.1 = private unnamed_addr constant [23 x i8] c"./P-value_correction.c\00", align 1
@.str.2 = private unnamed_addr constant [1 x i8] zeroinitializer, align 1
@base_arr = hidden global double* null, align 4
@.str.3 = private unnamed_addr constant [33 x i8] c"failed to malloc at %s line %u.\0A\00", align 1
@.str.4 = private unnamed_addr constant [48 x i8] c"cummin function requires at least one element.\0A\00", align 1
@.str.5 = private unnamed_addr constant [22 x i8] c"Failed at %s line %u\0A\00", align 1
@.str.6 = private unnamed_addr constant [41 x i8] c"function requires at least one element.\0A\00", align 1
@.str.7 = private unnamed_addr constant [37 x i8] c"pmin requires at least one element.\0A\00", align 1
@.str.8 = private unnamed_addr constant [7 x i8] c"[1] %e\00", align 1
@.str.9 = private unnamed_addr constant [7 x i8] c" %.10f\00", align 1
@.str.10 = private unnamed_addr constant [6 x i8] c"\0A[%u]\00", align 1
@.str.11 = private unnamed_addr constant [2 x i8] c"\0A\00", align 1
@.str.12 = private unnamed_addr constant [34 x i8] c"Failure to malloc at %s line %u.\0A\00", align 1
@.str.13 = private unnamed_addr constant [41 x i8] c"p_adjust requires at least one element.\0A\00", align 1
@.str.14 = private unnamed_addr constant [3 x i8] c"BH\00", align 1
@.str.15 = private unnamed_addr constant [4 x i8] c"fdr\00", align 1
@.str.16 = private unnamed_addr constant [3 x i8] c"by\00", align 1
@.str.17 = private unnamed_addr constant [11 x i8] c"Bonferroni\00", align 1
@.str.18 = private unnamed_addr constant [9 x i8] c"hochberg\00", align 1
@.str.19 = private unnamed_addr constant [5 x i8] c"holm\00", align 1
@.str.20 = private unnamed_addr constant [7 x i8] c"hommel\00", align 1
@.str.21 = private unnamed_addr constant [44 x i8] c"%s doesn't match any accepted FDR methods.\0A\00", align 1
@.str.22 = private unnamed_addr constant [42 x i8] c"%g is outside of the interval I planned.\0A\00", align 1
@.str.23 = private unnamed_addr constant [23 x i8] c"Failure at %s line %u\0A\00", align 1
@.str.24 = private unnamed_addr constant [54 x i8] c"array[%u] = %lf, which is outside the interval [0,1]\0A\00", align 1
@.str.25 = private unnamed_addr constant [20 x i8] c"died at %s line %u\0A\00", align 1
@__const.main.PVALUES = private unnamed_addr constant [50 x double] [double 0x3FDD04160F35FDE9, double 0x3FE758E721E2A8D7, double 0x3FB96FAC8B38D8BA, double 0x3FB73E71D5B04B37, double 0x3FC710AB48EE865B, double 0x3FEC01D953C3CC73, double 0x3FD2B3C4BE0A922A, double 0x3FED2B5A568DAB4F, double 0x3FDBE08D73F16964, double 0x3FE10A218C41C242, double 0x3FDF8810DB1996AA, double 0x3FE291CCB11E1A9D, double 0x3FD64E8C550D788F, double 7.883130e-01, double 0x3FD177B2BF048D2D, double 0x3FEB3543434BAF2B, double 0x3FDB50EAD41ED0A6, double 0x3FE49D4AFF01D33F, double 0x3FD364C9AE345B51, double 0x3FA99BA35F15394D, double 3.194810e-01, double 0x3FE941E405CE761A, double 0x3FEFF94F77369843, double 0x3FC65847BFB23217, double 0x3FECEB8879B6A543, double 0x3FBEAF00332BA677, double 0x3FD96207C7749E38, double 0x3F8CC02620502C93, double 0x3FE773A5B45A0F40, double 0x3FB1642C24762C01, double 4.040730e-03, double 0x3F33E11D79A90777, double 0x3F870B02BD749528, double 0x3F98521BD6A0353F, double 0x3F4310F26148FFAA, double 0x3F3427CD76006778, double 0x3F80E60AFB1F8A4E, double 0x3F5639B74A9E4DA2, double 0x3F8BDDF74195769F, double 0x3F38ABEE3BFA8581, double 0x3EF2E2E96B5466FE, double 0x3E90CE9F65B58A88, double 0x3FA0F2D097879B95, double 0x3F834EE7216A6684, double 0x3F4CCE8DBB40BD9D, double 0x3F2C8B969590F2ED, double 0x3F4FC31F7F1541AD, double 6.610250e-05, double 0x3F9DB44EA6AC26BA, double 5.735490e-03], align 16
@__const.main.CORRECT_ANSWERS = private unnamed_addr constant [6 x [50 x double]] [[50 x double] [double 0x3FE39AFA2199ADBC, double 8.521710e-01, double 0x3FC96FAC6045BAF5, double 0x3FC83660E51D25AB, double 0x3FD498068702BE20, double 0x3FEDC3BF727136A4, double 4.870370e-01, double 0x3FEDC3BF727136A4, double 0x3FE35BF08BEEB62C, double 0x3FE5D879DEE92F03, double 0x3FE4BE91D656B94A, double 0x3FE7363FC28DAEAA, double 0x3FE0E62C4F13638A, double 0x3FEC1052C8FAB035, double 0x3FDE1DD2E43E029A, double 0x3FED92EFFC7CBDC1, double 0x3FE35BF08BEEB62C, double 0x3FE923B90CFC67C5, double 0x3FDF47B8FC357024, double 0x3FBD1996A9FB10AD, double 0x3FDFF2B6D6C14255, double 0x3FEC1052C8FAB035, double 0x3FEFF94F77369843, double 0x3FD498068702BE20, double 0x3FEDC3BF727136A4, double 0x3FCD80E2E96EC403, double 0x3FE2A9F6A93F290B, double 0x3FA3F736D8AF2E2B, double 8.521710e-01, double 0x3FC2E751B350FAC4, double 0x3F913D8E55EE9F05, double 0x3F64FECB88BB3633, double 0x3FA2009A03CCBE34, double 0x3FB0001FB57CF9FC, double 0x3F6DCA7ADA5E274A, double 0x3F64FECB88BB3633, double 0x3F9E2D13B467D120, double 0x3F7941963399C6A1, double 0x3FA3F736D8AF2E2B, double 0x3F6607390CEF853C, double 0x3F3D828C80BA213A, double 0x3EEA42D90EEBA875, double 0x3FB42D4181AA8F8B, double 0x3FA01715F12E0018, double 0x3F73D9F3AF6D490C, double 0x3F64FECB88BB3633, double 0x3F73D9F3AF6D490C, double 0x3F520CE5F51A7C61, double 0x3FB290B112B20952, double 0x3F9696C95AA76B69], [50 x double] [double 1.000000e+00, double 1.000000e+00, double 0x3FEC9C56E33BA41B, double 0x3FEB3BF21E95ED3D, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 0x3FE05DA74553C727, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 0x3FC675198790829A, double 1.000000e+00, double 0x3FE54345648E1F12, double 0x3FB3645F501CA2F9, double 0x3F879D934E50F0DE, double 0x3FC43FC3646E3EA2, double 0x3FD1FF539D36064C, double 0x3F90C123206B855F, double 0x3F879D934E50F0DE, double 0x3FC0F8967F32E606, double 0x3F9C6880470D2FBE, double 0x3FC675198790829A, double 0x3F88C70105E47082, double 2.025930e-03, double 0x3F0D89DE4FA8F818, double 0x3FD6B1E2D11B1027, double 0x3FC219271872BD8D, double 0x3F96542FAD16CEF9, double 0x3F879D934E50F0DE, double 0x3F96542FAD16CEF9, double 0x3F744D9816EB319A, double 0x3FD4E1D5728DBC16, double 0x3FB9687C40426555], [50 x double] [double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 0x3FE6761DC93EA2D3, double 1.000000e+00, double 1.000000e+00, double 0x3FC9DC55000C953A, double 0x3F8F0FBD624BA499, double 0x3FE2009A24031487, double 1.000000e+00, double 0x3F9DCA7AB8020F7A, double 0x3F8F7E310860A1AB, double 0x3FDA677128614819, double 6.782670e-02, double 6.803480e-01, double 0x3F9346521EDBB84D, double 0x3F4D828CB7B3E0EE, double 0x3EEA42D90EEBA875, double 1.000000e+00, double 4.713920e-01, double 0x3FA6815EE53DB1E7, double 0x3F864D0CF90CC6B8, double 0x3FA8D0709B489B4F, double 0x3F6B1359791819D2, double 1.000000e+00, double 0x3FD25A836EB4E981], [50 x double] [double 0x3FEFF94F77369843, double 0x3FEFF94F77369843, double 0x3FEFF94F77369843, double 0x3FEFF94F77369843, double 0x3FEFF94F77369843, double 0x3FEFF94F77369843, double 0x3FEFF94F77369843, double 0x3FEFF94F77369843, double 0x3FEFF94F77369843, double 0x3FEFF94F77369843, double 0x3FEFF94F77369843, double 0x3FEFF94F77369843, double 0x3FEFF94F77369843, double 0x3FEFF94F77369843, double 0x3FEFF94F77369843, double 0x3FEFF94F77369843, double 0x3FEFF94F77369843, double 0x3FEFF94F77369843, double 0x3FEFF94F77369843, double 0x3FEFF94F77369843, double 0x3FEFF94F77369843, double 0x3FEFF94F77369843, double 0x3FEFF94F77369843, double 0x3FEFF94F77369843, double 0x3FEFF94F77369843, double 0x3FEFF94F77369843, double 0x3FEFF94F77369843, double 0x3FDDA6274695E687, double 0x3FEFF94F77369843, double 0x3FEFF94F77369843, double 0x3FC42BDC26DCE39B, double 0x3F8C57F9104CA951, double 0x3FD9340AC9879DEF, double 7.600230e-01, double 0x3F999EC5A86B439B, double 0x3F8C57F9104CA951, double 0x3FD389FCD90412B4, double 0x3FABC8251D45E10B, double 0x3FDD9BD68ABBB045, double 0x3F90F633F956C386, double 8.825610e-04, double 0x3EEA42D90EEBA875, double 0x3FEFC7471C1E43B8, double 0x3FD5B8C4014C305A, double 0x3FA2E78CEC8D068E, double 0x3F84F6832995A599, double 0x3FA459002162FC24, double 3.172920e-03, double 8.992520e-01, double 0x3FCBE5BD5E9AC00A], [50 x double] [double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 0x3FDDA6274695E687, double 1.000000e+00, double 1.000000e+00, double 0x3FC42BDC26DCE39B, double 0x3F8C939AFCF101E0, double 0x3FD9340AC9879DEF, double 7.600230e-01, double 0x3F999EC5A86B439B, double 0x3F8C939AFCF101E0, double 0x3FD389FCD90412B4, double 0x3FABC8251D45E10B, double 0x3FDD9BD68ABBB045, double 0x3F90F633F956C386, double 8.825610e-04, double 0x3EEA42D90EEBA875, double 0x3FEFC7471C1E43B8, double 0x3FD5B8C4014C305A, double 0x3FA2E78CEC8D068E, double 0x3F84F6832995A599, double 0x3FA459002162FC24, double 3.172920e-03, double 8.992520e-01, double 0x3FCBE5BD5E9AC00A], [50 x double] [double 0x3FEFF94F77369843, double 0x3FEFF94F77369843, double 0x3FEFF94F77369843, double 0x3FEFF5DC908F2EDD, double 0x3FEFF94F77369843, double 0x3FEFF94F77369843, double 0x3FEFF94F77369843, double 0x3FEFF94F77369843, double 0x3FEFF94F77369843, double 0x3FEFF94F77369843, double 0x3FEFF94F77369843, double 0x3FEFF94F77369843, double 0x3FEFF94F77369843, double 0x3FEFF94F77369843, double 0x3FEFF94F77369843, double 0x3FEFF94F77369843, double 0x3FEFF94F77369843, double 0x3FEFF94F77369843, double 0x3FEFF94F77369843, double 0x3FEEB45F17BD8BE7, double 0x3FEFF94F77369843, double 0x3FEFF94F77369843, double 0x3FEFF94F77369843, double 0x3FEFF94F77369843, double 0x3FEFF94F77369843, double 0x3FEFF94F77369843, double 0x3FEFF94F77369843, double 0x3FDBDA250F840182, double 0x3FEFF94F77369843, double 0x3FEF40BC1D52205E, double 0x3FC21A3BEB689947, double 1.304340e-02, double 0x3FD69916517B1CD7, double 0x3FE60A69453DF7B2, double 0x3F986DB666D9D3C6, double 0x3F8B157BBD3AB385, double 2.722920e-01, double 0x3FABC8251D45E10B, double 0x3FDAFF07B27BE8AF, double 0x3F9030D45E3B9F93, double 8.825610e-04, double 0x3EEA42D90EEBA875, double 0x3FEBFACC1948A662, double 0x3FD34EE6EDE042CB, double 0x3FA2011883DA6A9A, double 0x3F839FF779153716, double 0x3FA3D9F3D1C960DD, double 3.172920e-03, double 0x3FE9FDC4BC5D1301, double 0x3FC8F5FAC3801CF1]], align 16
@.str.26 = private unnamed_addr constant [3 x i8] c"bh\00", align 1
@.str.27 = private unnamed_addr constant [11 x i8] c"bonferroni\00", align 1
@__const.main.TYPES = private unnamed_addr constant [6 x i8*] [i8* getelementptr inbounds ([3 x i8], [3 x i8]* @.str.26, i32 0, i32 0), i8* getelementptr inbounds ([3 x i8], [3 x i8]* @.str.16, i32 0, i32 0), i8* getelementptr inbounds ([11 x i8], [11 x i8]* @.str.27, i32 0, i32 0), i8* getelementptr inbounds ([9 x i8], [9 x i8]* @.str.18, i32 0, i32 0), i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.19, i32 0, i32 0), i8* getelementptr inbounds ([7 x i8], [7 x i8]* @.str.20, i32 0, i32 0)], align 16
@.str.28 = private unnamed_addr constant [44 x i8] c"\0Atype %u = '%s' has cumulative error of %g\0A\00", align 1
@llvm.used = appending global [1 x i8*] [i8* bitcast (i32 ()* @__main_void to i8*)], section "llvm.metadata"

@__main_void = alias i32 (), i32 ()* @main

; Function Attrs: noinline nounwind optnone
define hidden i32* @seq_len(i32 %START, i32 %END) #0 {
entry:
  %retval = alloca i32*, align 4
  %START.addr = alloca i32, align 4
  %END.addr = alloca i32, align 4
  %start = alloca i32, align 4
  %end = alloca i32, align 4
  %sequence = alloca i32*, align 4
  %i = alloca i32, align 4
  %LENGTH = alloca i32, align 4
  %sequence10 = alloca i32*, align 4
  %index = alloca i32, align 4
  %index28 = alloca i32, align 4
  store i32 %START, i32* %START.addr, align 4
  store i32 %END, i32* %END.addr, align 4
  %0 = load i32, i32* %START.addr, align 4
  store i32 %0, i32* %start, align 4
  %1 = load i32, i32* %END.addr, align 4
  store i32 %1, i32* %end, align 4
  %2 = load i32, i32* %START.addr, align 4
  %3 = load i32, i32* %END.addr, align 4
  %cmp = icmp eq i32 %2, %3
  br i1 %cmp, label %if.then, label %if.end6

if.then:                                          ; preds = %entry
  %4 = load i32, i32* %end, align 4
  %add = add i32 %4, 1
  %mul = mul i32 %add, 4
  %call = call noalias i8* @malloc(i32 %mul)
  %5 = bitcast i8* %call to i32*
  store i32* %5, i32** %sequence, align 4
  %6 = load i32*, i32** %sequence, align 4
  %cmp1 = icmp eq i32* %6, null
  br i1 %cmp1, label %if.then2, label %if.end

if.then2:                                         ; preds = %if.then
  %call3 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([29 x i8], [29 x i8]* @.str, i32 0, i32 0), i8* getelementptr inbounds ([23 x i8], [23 x i8]* @.str.1, i32 0, i32 0), i32 15)
  call void @perror(i8* getelementptr inbounds ([1 x i8], [1 x i8]* @.str.2, i32 0, i32 0))
  call void @exit(i32 1) #5
  unreachable

if.end:                                           ; preds = %if.then
  store i32 0, i32* %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.end
  %7 = load i32, i32* %i, align 4
  %8 = load i32, i32* %end, align 4
  %cmp4 = icmp ult i32 %7, %8
  br i1 %cmp4, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %9 = load i32, i32* %i, align 4
  %add5 = add i32 %9, 1
  %10 = load i32*, i32** %sequence, align 4
  %11 = load i32, i32* %i, align 4
  %arrayidx = getelementptr inbounds i32, i32* %10, i32 %11
  store i32 %add5, i32* %arrayidx, align 4
  br label %for.inc

for.inc:                                          ; preds = %for.body
  %12 = load i32, i32* %i, align 4
  %inc = add i32 %12, 1
  store i32 %inc, i32* %i, align 4
  br label %for.cond

for.end:                                          ; preds = %for.cond
  %13 = load i32*, i32** %sequence, align 4
  store i32* %13, i32** %retval, align 4
  br label %return

if.end6:                                          ; preds = %entry
  %14 = load i32, i32* %START.addr, align 4
  %15 = load i32, i32* %END.addr, align 4
  %cmp7 = icmp ugt i32 %14, %15
  br i1 %cmp7, label %if.then8, label %if.end9

if.then8:                                         ; preds = %if.end6
  %16 = load i32, i32* %START.addr, align 4
  store i32 %16, i32* %end, align 4
  %17 = load i32, i32* %END.addr, align 4
  store i32 %17, i32* %start, align 4
  br label %if.end9

if.end9:                                          ; preds = %if.then8, %if.end6
  %18 = load i32, i32* %end, align 4
  %19 = load i32, i32* %start, align 4
  %sub = sub i32 %18, %19
  store i32 %sub, i32* %LENGTH, align 4
  %20 = load i32, i32* %LENGTH, align 4
  %add11 = add i32 1, %20
  %mul12 = mul i32 %add11, 4
  %call13 = call noalias i8* @malloc(i32 %mul12)
  %21 = bitcast i8* %call13 to i32*
  store i32* %21, i32** %sequence10, align 4
  %22 = load i32*, i32** %sequence10, align 4
  %cmp14 = icmp eq i32* %22, null
  br i1 %cmp14, label %if.then15, label %if.end17

if.then15:                                        ; preds = %if.end9
  %call16 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([29 x i8], [29 x i8]* @.str, i32 0, i32 0), i8* getelementptr inbounds ([23 x i8], [23 x i8]* @.str.1, i32 0, i32 0), i32 31)
  call void @perror(i8* getelementptr inbounds ([1 x i8], [1 x i8]* @.str.2, i32 0, i32 0))
  call void @exit(i32 1) #5
  unreachable

if.end17:                                         ; preds = %if.end9
  %23 = load i32, i32* %START.addr, align 4
  %24 = load i32, i32* %END.addr, align 4
  %cmp18 = icmp ult i32 %23, %24
  br i1 %cmp18, label %if.then19, label %if.else

if.then19:                                        ; preds = %if.end17
  store i32 0, i32* %index, align 4
  br label %for.cond20

for.cond20:                                       ; preds = %for.inc25, %if.then19
  %25 = load i32, i32* %index, align 4
  %26 = load i32, i32* %LENGTH, align 4
  %cmp21 = icmp ule i32 %25, %26
  br i1 %cmp21, label %for.body22, label %for.end27

for.body22:                                       ; preds = %for.cond20
  %27 = load i32, i32* %start, align 4
  %28 = load i32, i32* %index, align 4
  %add23 = add i32 %27, %28
  %29 = load i32*, i32** %sequence10, align 4
  %30 = load i32, i32* %index, align 4
  %arrayidx24 = getelementptr inbounds i32, i32* %29, i32 %30
  store i32 %add23, i32* %arrayidx24, align 4
  br label %for.inc25

for.inc25:                                        ; preds = %for.body22
  %31 = load i32, i32* %index, align 4
  %inc26 = add i32 %31, 1
  store i32 %inc26, i32* %index, align 4
  br label %for.cond20

for.end27:                                        ; preds = %for.cond20
  br label %if.end37

if.else:                                          ; preds = %if.end17
  store i32 0, i32* %index28, align 4
  br label %for.cond29

for.cond29:                                       ; preds = %for.inc34, %if.else
  %32 = load i32, i32* %index28, align 4
  %33 = load i32, i32* %LENGTH, align 4
  %cmp30 = icmp ule i32 %32, %33
  br i1 %cmp30, label %for.body31, label %for.end36

for.body31:                                       ; preds = %for.cond29
  %34 = load i32, i32* %end, align 4
  %35 = load i32, i32* %index28, align 4
  %sub32 = sub i32 %34, %35
  %36 = load i32*, i32** %sequence10, align 4
  %37 = load i32, i32* %index28, align 4
  %arrayidx33 = getelementptr inbounds i32, i32* %36, i32 %37
  store i32 %sub32, i32* %arrayidx33, align 4
  br label %for.inc34

for.inc34:                                        ; preds = %for.body31
  %38 = load i32, i32* %index28, align 4
  %inc35 = add i32 %38, 1
  store i32 %inc35, i32* %index28, align 4
  br label %for.cond29

for.end36:                                        ; preds = %for.cond29
  br label %if.end37

if.end37:                                         ; preds = %for.end36, %for.end27
  %39 = load i32*, i32** %sequence10, align 4
  store i32* %39, i32** %retval, align 4
  br label %return

return:                                           ; preds = %if.end37, %for.end
  %40 = load i32*, i32** %retval, align 4
  ret i32* %40
}

declare noalias i8* @malloc(i32 %0) #1

declare i32 @printf(i8* %0, ...) #1

declare void @perror(i8* %0) #1

; Function Attrs: noreturn
declare void @exit(i32 %0) #2

; Function Attrs: noinline nounwind optnone
define hidden i32* @order(double* noalias %ARRAY, i32 %SIZE, i1 zeroext %DECREASING) #0 {
entry:
  %ARRAY.addr = alloca double*, align 4
  %SIZE.addr = alloca i32, align 4
  %DECREASING.addr = alloca i8, align 1
  %idx = alloca i32*, align 4
  %i = alloca i32, align 4
  store double* %ARRAY, double** %ARRAY.addr, align 4
  store i32 %SIZE, i32* %SIZE.addr, align 4
  %frombool = zext i1 %DECREASING to i8
  store i8 %frombool, i8* %DECREASING.addr, align 1
  %0 = load i32, i32* %SIZE.addr, align 4
  %mul = mul i32 %0, 4
  %call = call noalias i8* @malloc(i32 %mul)
  %1 = bitcast i8* %call to i32*
  store i32* %1, i32** %idx, align 4
  %2 = load i32*, i32** %idx, align 4
  %cmp = icmp eq i32* %2, null
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %call1 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([33 x i8], [33 x i8]* @.str.3, i32 0, i32 0), i8* getelementptr inbounds ([23 x i8], [23 x i8]* @.str.1, i32 0, i32 0), i32 77)
  call void @perror(i8* getelementptr inbounds ([1 x i8], [1 x i8]* @.str.2, i32 0, i32 0))
  call void @exit(i32 1) #5
  unreachable

if.end:                                           ; preds = %entry
  %3 = load i32, i32* %SIZE.addr, align 4
  %mul2 = mul i32 8, %3
  %call3 = call noalias i8* @malloc(i32 %mul2)
  %4 = bitcast i8* %call3 to double*
  store double* %4, double** @base_arr, align 4
  %5 = load double*, double** @base_arr, align 4
  %cmp4 = icmp eq double* %5, null
  br i1 %cmp4, label %if.then5, label %if.end7

if.then5:                                         ; preds = %if.end
  %call6 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([33 x i8], [33 x i8]* @.str.3, i32 0, i32 0), i8* getelementptr inbounds ([23 x i8], [23 x i8]* @.str.1, i32 0, i32 0), i32 83)
  call void @perror(i8* getelementptr inbounds ([1 x i8], [1 x i8]* @.str.2, i32 0, i32 0))
  call void @exit(i32 1) #5
  unreachable

if.end7:                                          ; preds = %if.end
  store i32 0, i32* %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.end7
  %6 = load i32, i32* %i, align 4
  %7 = load i32, i32* %SIZE.addr, align 4
  %cmp8 = icmp ult i32 %6, %7
  br i1 %cmp8, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %8 = load double*, double** %ARRAY.addr, align 4
  %9 = load i32, i32* %i, align 4
  %arrayidx = getelementptr inbounds double, double* %8, i32 %9
  %10 = load double, double* %arrayidx, align 8
  %11 = load double*, double** @base_arr, align 4
  %12 = load i32, i32* %i, align 4
  %arrayidx9 = getelementptr inbounds double, double* %11, i32 %12
  store double %10, double* %arrayidx9, align 8
  %13 = load i32, i32* %i, align 4
  %14 = load i32*, i32** %idx, align 4
  %15 = load i32, i32* %i, align 4
  %arrayidx10 = getelementptr inbounds i32, i32* %14, i32 %15
  store i32 %13, i32* %arrayidx10, align 4
  br label %for.inc

for.inc:                                          ; preds = %for.body
  %16 = load i32, i32* %i, align 4
  %inc = add i32 %16, 1
  store i32 %inc, i32* %i, align 4
  br label %for.cond

for.end:                                          ; preds = %for.cond
  %17 = load i8, i8* %DECREASING.addr, align 1
  %tobool = trunc i8 %17 to i1
  %conv = zext i1 %tobool to i32
  %cmp11 = icmp eq i32 %conv, 0
  br i1 %cmp11, label %if.then13, label %if.else

if.then13:                                        ; preds = %for.end
  %18 = load i32*, i32** %idx, align 4
  %19 = bitcast i32* %18 to i8*
  %20 = load i32, i32* %SIZE.addr, align 4
  call void @qsort(i8* %19, i32 %20, i32 4, i32 (i8*, i8*)* @compar_decrease)
  br label %if.end20

if.else:                                          ; preds = %for.end
  %21 = load i8, i8* %DECREASING.addr, align 1
  %tobool14 = trunc i8 %21 to i1
  br i1 %tobool14, label %if.then18, label %if.end19

if.then18:                                        ; preds = %if.else
  %22 = load i32*, i32** %idx, align 4
  %23 = bitcast i32* %22 to i8*
  %24 = load i32, i32* %SIZE.addr, align 4
  call void @qsort(i8* %23, i32 %24, i32 4, i32 (i8*, i8*)* @compar_increase)
  br label %if.end19

if.end19:                                         ; preds = %if.then18, %if.else
  br label %if.end20

if.end20:                                         ; preds = %if.end19, %if.then13
  %25 = load double*, double** @base_arr, align 4
  %26 = bitcast double* %25 to i8*
  call void @free(i8* %26)
  store double* null, double** @base_arr, align 4
  %27 = load i32*, i32** %idx, align 4
  ret i32* %27
}

declare void @qsort(i8* %0, i32 %1, i32 %2, i32 (i8*, i8*)* %3) #1

; Function Attrs: noinline nounwind optnone
define internal i32 @compar_decrease(i8* noalias %a, i8* noalias %b) #0 {
entry:
  %retval = alloca i32, align 4
  %a.addr = alloca i8*, align 4
  %b.addr = alloca i8*, align 4
  %aa = alloca i32, align 4
  %bb = alloca i32, align 4
  store i8* %a, i8** %a.addr, align 4
  store i8* %b, i8** %b.addr, align 4
  %0 = load i8*, i8** %a.addr, align 4
  %1 = bitcast i8* %0 to i32*
  %2 = load i32, i32* %1, align 4
  store i32 %2, i32* %aa, align 4
  %3 = load i8*, i8** %b.addr, align 4
  %4 = bitcast i8* %3 to i32*
  %5 = load i32, i32* %4, align 4
  store i32 %5, i32* %bb, align 4
  %6 = load double*, double** @base_arr, align 4
  %7 = load i32, i32* %aa, align 4
  %arrayidx = getelementptr inbounds double, double* %6, i32 %7
  %8 = load double, double* %arrayidx, align 8
  %9 = load double*, double** @base_arr, align 4
  %10 = load i32, i32* %bb, align 4
  %arrayidx1 = getelementptr inbounds double, double* %9, i32 %10
  %11 = load double, double* %arrayidx1, align 8
  %cmp = fcmp olt double %8, %11
  br i1 %cmp, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  store i32 -1, i32* %retval, align 4
  br label %return

if.else:                                          ; preds = %entry
  %12 = load double*, double** @base_arr, align 4
  %13 = load i32, i32* %aa, align 4
  %arrayidx2 = getelementptr inbounds double, double* %12, i32 %13
  %14 = load double, double* %arrayidx2, align 8
  %15 = load double*, double** @base_arr, align 4
  %16 = load i32, i32* %bb, align 4
  %arrayidx3 = getelementptr inbounds double, double* %15, i32 %16
  %17 = load double, double* %arrayidx3, align 8
  %cmp4 = fcmp oeq double %14, %17
  br i1 %cmp4, label %if.then5, label %if.else6

if.then5:                                         ; preds = %if.else
  store i32 0, i32* %retval, align 4
  br label %return

if.else6:                                         ; preds = %if.else
  store i32 1, i32* %retval, align 4
  br label %return

return:                                           ; preds = %if.else6, %if.then5, %if.then
  %18 = load i32, i32* %retval, align 4
  ret i32 %18
}

; Function Attrs: noinline nounwind optnone
define internal i32 @compar_increase(i8* noalias %a, i8* noalias %b) #0 {
entry:
  %retval = alloca i32, align 4
  %a.addr = alloca i8*, align 4
  %b.addr = alloca i8*, align 4
  %aa = alloca i32, align 4
  %bb = alloca i32, align 4
  store i8* %a, i8** %a.addr, align 4
  store i8* %b, i8** %b.addr, align 4
  %0 = load i8*, i8** %a.addr, align 4
  %1 = bitcast i8* %0 to i32*
  %2 = load i32, i32* %1, align 4
  store i32 %2, i32* %aa, align 4
  %3 = load i8*, i8** %b.addr, align 4
  %4 = bitcast i8* %3 to i32*
  %5 = load i32, i32* %4, align 4
  store i32 %5, i32* %bb, align 4
  %6 = load double*, double** @base_arr, align 4
  %7 = load i32, i32* %aa, align 4
  %arrayidx = getelementptr inbounds double, double* %6, i32 %7
  %8 = load double, double* %arrayidx, align 8
  %9 = load double*, double** @base_arr, align 4
  %10 = load i32, i32* %bb, align 4
  %arrayidx1 = getelementptr inbounds double, double* %9, i32 %10
  %11 = load double, double* %arrayidx1, align 8
  %cmp = fcmp olt double %8, %11
  br i1 %cmp, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  store i32 1, i32* %retval, align 4
  br label %return

if.else:                                          ; preds = %entry
  %12 = load double*, double** @base_arr, align 4
  %13 = load i32, i32* %aa, align 4
  %arrayidx2 = getelementptr inbounds double, double* %12, i32 %13
  %14 = load double, double* %arrayidx2, align 8
  %15 = load double*, double** @base_arr, align 4
  %16 = load i32, i32* %bb, align 4
  %arrayidx3 = getelementptr inbounds double, double* %15, i32 %16
  %17 = load double, double* %arrayidx3, align 8
  %cmp4 = fcmp oeq double %14, %17
  br i1 %cmp4, label %if.then5, label %if.else6

if.then5:                                         ; preds = %if.else
  store i32 0, i32* %retval, align 4
  br label %return

if.else6:                                         ; preds = %if.else
  store i32 -1, i32* %retval, align 4
  br label %return

return:                                           ; preds = %if.else6, %if.then5, %if.then
  %18 = load i32, i32* %retval, align 4
  ret i32 %18
}

declare void @free(i8* %0) #1

; Function Attrs: noinline nounwind optnone
define hidden double* @cummin(double* noalias %ARRAY, i32 %NO_OF_ARRAY_ELEMENTS) #0 {
entry:
  %ARRAY.addr = alloca double*, align 4
  %NO_OF_ARRAY_ELEMENTS.addr = alloca i32, align 4
  %output = alloca double*, align 4
  %cumulative_min = alloca double, align 8
  %i = alloca i32, align 4
  store double* %ARRAY, double** %ARRAY.addr, align 4
  store i32 %NO_OF_ARRAY_ELEMENTS, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
  %0 = load i32, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
  %cmp = icmp ult i32 %0, 1
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %call = call i32 @puts(i8* getelementptr inbounds ([48 x i8], [48 x i8]* @.str.4, i32 0, i32 0))
  %call1 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([22 x i8], [22 x i8]* @.str.5, i32 0, i32 0), i8* getelementptr inbounds ([23 x i8], [23 x i8]* @.str.1, i32 0, i32 0), i32 105)
  call void @exit(i32 1) #5
  unreachable

if.end:                                           ; preds = %entry
  %1 = load i32, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
  %mul = mul i32 8, %1
  %call2 = call noalias i8* @malloc(i32 %mul)
  %2 = bitcast i8* %call2 to double*
  store double* %2, double** %output, align 4
  %3 = load double*, double** %output, align 4
  %cmp3 = icmp eq double* %3, null
  br i1 %cmp3, label %if.then4, label %if.end6

if.then4:                                         ; preds = %if.end
  %call5 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([33 x i8], [33 x i8]* @.str.3, i32 0, i32 0), i8* getelementptr inbounds ([23 x i8], [23 x i8]* @.str.1, i32 0, i32 0), i32 110)
  call void @perror(i8* getelementptr inbounds ([1 x i8], [1 x i8]* @.str.2, i32 0, i32 0))
  call void @exit(i32 1) #5
  unreachable

if.end6:                                          ; preds = %if.end
  %4 = load double*, double** %ARRAY.addr, align 4
  %arrayidx = getelementptr inbounds double, double* %4, i32 0
  %5 = load double, double* %arrayidx, align 8
  store double %5, double* %cumulative_min, align 8
  store i32 0, i32* %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.end6
  %6 = load i32, i32* %i, align 4
  %7 = load i32, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
  %cmp7 = icmp ult i32 %6, %7
  br i1 %cmp7, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %8 = load double*, double** %ARRAY.addr, align 4
  %9 = load i32, i32* %i, align 4
  %arrayidx8 = getelementptr inbounds double, double* %8, i32 %9
  %10 = load double, double* %arrayidx8, align 8
  %11 = load double, double* %cumulative_min, align 8
  %cmp9 = fcmp olt double %10, %11
  br i1 %cmp9, label %if.then10, label %if.end12

if.then10:                                        ; preds = %for.body
  %12 = load double*, double** %ARRAY.addr, align 4
  %13 = load i32, i32* %i, align 4
  %arrayidx11 = getelementptr inbounds double, double* %12, i32 %13
  %14 = load double, double* %arrayidx11, align 8
  store double %14, double* %cumulative_min, align 8
  br label %if.end12

if.end12:                                         ; preds = %if.then10, %for.body
  %15 = load double, double* %cumulative_min, align 8
  %16 = load double*, double** %output, align 4
  %17 = load i32, i32* %i, align 4
  %arrayidx13 = getelementptr inbounds double, double* %16, i32 %17
  store double %15, double* %arrayidx13, align 8
  br label %for.inc

for.inc:                                          ; preds = %if.end12
  %18 = load i32, i32* %i, align 4
  %inc = add i32 %18, 1
  store i32 %inc, i32* %i, align 4
  br label %for.cond

for.end:                                          ; preds = %for.cond
  %19 = load double*, double** %output, align 4
  ret double* %19
}

declare i32 @puts(i8* %0) #1

; Function Attrs: noinline nounwind optnone
define hidden double* @cummax(double* noalias %ARRAY, i32 %NO_OF_ARRAY_ELEMENTS) #0 {
entry:
  %ARRAY.addr = alloca double*, align 4
  %NO_OF_ARRAY_ELEMENTS.addr = alloca i32, align 4
  %output = alloca double*, align 4
  %cumulative_max = alloca double, align 8
  %i = alloca i32, align 4
  store double* %ARRAY, double** %ARRAY.addr, align 4
  store i32 %NO_OF_ARRAY_ELEMENTS, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
  %0 = load i32, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
  %cmp = icmp ult i32 %0, 1
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %call = call i32 @puts(i8* getelementptr inbounds ([41 x i8], [41 x i8]* @.str.6, i32 0, i32 0))
  %call1 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([22 x i8], [22 x i8]* @.str.5, i32 0, i32 0), i8* getelementptr inbounds ([23 x i8], [23 x i8]* @.str.1, i32 0, i32 0), i32 129)
  call void @exit(i32 1) #5
  unreachable

if.end:                                           ; preds = %entry
  %1 = load i32, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
  %mul = mul i32 8, %1
  %call2 = call noalias i8* @malloc(i32 %mul)
  %2 = bitcast i8* %call2 to double*
  store double* %2, double** %output, align 4
  %3 = load double*, double** %output, align 4
  %cmp3 = icmp eq double* %3, null
  br i1 %cmp3, label %if.then4, label %if.end6

if.then4:                                         ; preds = %if.end
  %call5 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([33 x i8], [33 x i8]* @.str.3, i32 0, i32 0), i8* getelementptr inbounds ([23 x i8], [23 x i8]* @.str.1, i32 0, i32 0), i32 134)
  call void @perror(i8* getelementptr inbounds ([1 x i8], [1 x i8]* @.str.2, i32 0, i32 0))
  call void @exit(i32 1) #5
  unreachable

if.end6:                                          ; preds = %if.end
  %4 = load double*, double** %ARRAY.addr, align 4
  %arrayidx = getelementptr inbounds double, double* %4, i32 0
  %5 = load double, double* %arrayidx, align 8
  store double %5, double* %cumulative_max, align 8
  store i32 0, i32* %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.end6
  %6 = load i32, i32* %i, align 4
  %7 = load i32, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
  %cmp7 = icmp ult i32 %6, %7
  br i1 %cmp7, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %8 = load double*, double** %ARRAY.addr, align 4
  %9 = load i32, i32* %i, align 4
  %arrayidx8 = getelementptr inbounds double, double* %8, i32 %9
  %10 = load double, double* %arrayidx8, align 8
  %11 = load double, double* %cumulative_max, align 8
  %cmp9 = fcmp ogt double %10, %11
  br i1 %cmp9, label %if.then10, label %if.end12

if.then10:                                        ; preds = %for.body
  %12 = load double*, double** %ARRAY.addr, align 4
  %13 = load i32, i32* %i, align 4
  %arrayidx11 = getelementptr inbounds double, double* %12, i32 %13
  %14 = load double, double* %arrayidx11, align 8
  store double %14, double* %cumulative_max, align 8
  br label %if.end12

if.end12:                                         ; preds = %if.then10, %for.body
  %15 = load double, double* %cumulative_max, align 8
  %16 = load double*, double** %output, align 4
  %17 = load i32, i32* %i, align 4
  %arrayidx13 = getelementptr inbounds double, double* %16, i32 %17
  store double %15, double* %arrayidx13, align 8
  br label %for.inc

for.inc:                                          ; preds = %if.end12
  %18 = load i32, i32* %i, align 4
  %inc = add i32 %18, 1
  store i32 %inc, i32* %i, align 4
  br label %for.cond

for.end:                                          ; preds = %for.cond
  %19 = load double*, double** %output, align 4
  ret double* %19
}

; Function Attrs: noinline nounwind optnone
define hidden double* @pminx(double* noalias %ARRAY, i32 %NO_OF_ARRAY_ELEMENTS, double %X) #0 {
entry:
  %ARRAY.addr = alloca double*, align 4
  %NO_OF_ARRAY_ELEMENTS.addr = alloca i32, align 4
  %X.addr = alloca double, align 8
  %pmin_array = alloca double*, align 4
  %index = alloca i32, align 4
  store double* %ARRAY, double** %ARRAY.addr, align 4
  store i32 %NO_OF_ARRAY_ELEMENTS, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
  store double %X, double* %X.addr, align 8
  %0 = load i32, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
  %cmp = icmp ult i32 %0, 1
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %call = call i32 @puts(i8* getelementptr inbounds ([37 x i8], [37 x i8]* @.str.7, i32 0, i32 0))
  %call1 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([22 x i8], [22 x i8]* @.str.5, i32 0, i32 0), i8* getelementptr inbounds ([23 x i8], [23 x i8]* @.str.1, i32 0, i32 0), i32 152)
  call void @exit(i32 1) #5
  unreachable

if.end:                                           ; preds = %entry
  %1 = load i32, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
  %mul = mul i32 8, %1
  %call2 = call noalias i8* @malloc(i32 %mul)
  %2 = bitcast i8* %call2 to double*
  store double* %2, double** %pmin_array, align 4
  %3 = load double*, double** %pmin_array, align 4
  %cmp3 = icmp eq double* %3, null
  br i1 %cmp3, label %if.then4, label %if.end6

if.then4:                                         ; preds = %if.end
  %call5 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([33 x i8], [33 x i8]* @.str.3, i32 0, i32 0), i8* getelementptr inbounds ([23 x i8], [23 x i8]* @.str.1, i32 0, i32 0), i32 157)
  call void @perror(i8* getelementptr inbounds ([1 x i8], [1 x i8]* @.str.2, i32 0, i32 0))
  call void @exit(i32 1) #5
  unreachable

if.end6:                                          ; preds = %if.end
  store i32 0, i32* %index, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.end6
  %4 = load i32, i32* %index, align 4
  %5 = load i32, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
  %cmp7 = icmp ult i32 %4, %5
  br i1 %cmp7, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %6 = load double*, double** %ARRAY.addr, align 4
  %7 = load i32, i32* %index, align 4
  %arrayidx = getelementptr inbounds double, double* %6, i32 %7
  %8 = load double, double* %arrayidx, align 8
  %9 = load double, double* %X.addr, align 8
  %cmp8 = fcmp olt double %8, %9
  br i1 %cmp8, label %if.then9, label %if.else

if.then9:                                         ; preds = %for.body
  %10 = load double*, double** %ARRAY.addr, align 4
  %11 = load i32, i32* %index, align 4
  %arrayidx10 = getelementptr inbounds double, double* %10, i32 %11
  %12 = load double, double* %arrayidx10, align 8
  %13 = load double*, double** %pmin_array, align 4
  %14 = load i32, i32* %index, align 4
  %arrayidx11 = getelementptr inbounds double, double* %13, i32 %14
  store double %12, double* %arrayidx11, align 8
  br label %if.end13

if.else:                                          ; preds = %for.body
  %15 = load double, double* %X.addr, align 8
  %16 = load double*, double** %pmin_array, align 4
  %17 = load i32, i32* %index, align 4
  %arrayidx12 = getelementptr inbounds double, double* %16, i32 %17
  store double %15, double* %arrayidx12, align 8
  br label %if.end13

if.end13:                                         ; preds = %if.else, %if.then9
  br label %for.inc

for.inc:                                          ; preds = %if.end13
  %18 = load i32, i32* %index, align 4
  %inc = add i32 %18, 1
  store i32 %inc, i32* %index, align 4
  br label %for.cond

for.end:                                          ; preds = %for.cond
  %19 = load double*, double** %pmin_array, align 4
  ret double* %19
}

; Function Attrs: noinline nounwind optnone
define hidden void @double_say(double* noalias %ARRAY, i32 %NO_OF_ARRAY_ELEMENTS) #0 {
entry:
  %ARRAY.addr = alloca double*, align 4
  %NO_OF_ARRAY_ELEMENTS.addr = alloca i32, align 4
  %i = alloca i32, align 4
  store double* %ARRAY, double** %ARRAY.addr, align 4
  store i32 %NO_OF_ARRAY_ELEMENTS, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
  %0 = load double*, double** %ARRAY.addr, align 4
  %arrayidx = getelementptr inbounds double, double* %0, i32 0
  %1 = load double, double* %arrayidx, align 8
  %call = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([7 x i8], [7 x i8]* @.str.8, i32 0, i32 0), double %1)
  store i32 1, i32* %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %2 = load i32, i32* %i, align 4
  %3 = load i32, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
  %cmp = icmp ult i32 %2, %3
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %4 = load double*, double** %ARRAY.addr, align 4
  %5 = load i32, i32* %i, align 4
  %arrayidx1 = getelementptr inbounds double, double* %4, i32 %5
  %6 = load double, double* %arrayidx1, align 8
  %call2 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([7 x i8], [7 x i8]* @.str.9, i32 0, i32 0), double %6)
  %7 = load i32, i32* %i, align 4
  %add = add i32 %7, 1
  %rem = urem i32 %add, 5
  %cmp3 = icmp eq i32 %rem, 0
  br i1 %cmp3, label %if.then, label %if.end

if.then:                                          ; preds = %for.body
  %8 = load i32, i32* %i, align 4
  %add4 = add i32 %8, 1
  %call5 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([6 x i8], [6 x i8]* @.str.10, i32 0, i32 0), i32 %add4)
  br label %if.end

if.end:                                           ; preds = %if.then, %for.body
  br label %for.inc

for.inc:                                          ; preds = %if.end
  %9 = load i32, i32* %i, align 4
  %inc = add i32 %9, 1
  store i32 %inc, i32* %i, align 4
  br label %for.cond

for.end:                                          ; preds = %for.cond
  %call6 = call i32 @puts(i8* getelementptr inbounds ([2 x i8], [2 x i8]* @.str.11, i32 0, i32 0))
  ret void
}

; Function Attrs: noinline nounwind optnone
define hidden double* @uint2double(i32* noalias %ARRAY, i32 %NO_OF_ARRAY_ELEMENTS) #0 {
entry:
  %ARRAY.addr = alloca i32*, align 4
  %NO_OF_ARRAY_ELEMENTS.addr = alloca i32, align 4
  %doubleArray = alloca double*, align 4
  %index = alloca i32, align 4
  store i32* %ARRAY, i32** %ARRAY.addr, align 4
  store i32 %NO_OF_ARRAY_ELEMENTS, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
  %0 = load i32, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
  %mul = mul i32 8, %0
  %call = call noalias i8* @malloc(i32 %mul)
  %1 = bitcast i8* %call to double*
  store double* %1, double** %doubleArray, align 4
  %2 = load double*, double** %doubleArray, align 4
  %cmp = icmp eq double* %2, null
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %call1 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([34 x i8], [34 x i8]* @.str.12, i32 0, i32 0), i8* getelementptr inbounds ([23 x i8], [23 x i8]* @.str.1, i32 0, i32 0), i32 194)
  call void @perror(i8* getelementptr inbounds ([1 x i8], [1 x i8]* @.str.2, i32 0, i32 0))
  call void @exit(i32 1) #5
  unreachable

if.end:                                           ; preds = %entry
  store i32 0, i32* %index, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.end
  %3 = load i32, i32* %index, align 4
  %4 = load i32, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
  %cmp2 = icmp ult i32 %3, %4
  br i1 %cmp2, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %5 = load i32*, i32** %ARRAY.addr, align 4
  %6 = load i32, i32* %index, align 4
  %arrayidx = getelementptr inbounds i32, i32* %5, i32 %6
  %7 = load i32, i32* %arrayidx, align 4
  %conv = uitofp i32 %7 to double
  %8 = load double*, double** %doubleArray, align 4
  %9 = load i32, i32* %index, align 4
  %arrayidx3 = getelementptr inbounds double, double* %8, i32 %9
  store double %conv, double* %arrayidx3, align 8
  br label %for.inc

for.inc:                                          ; preds = %for.body
  %10 = load i32, i32* %index, align 4
  %inc = add i32 %10, 1
  store i32 %inc, i32* %index, align 4
  br label %for.cond

for.end:                                          ; preds = %for.cond
  %11 = load double*, double** %doubleArray, align 4
  ret double* %11
}

; Function Attrs: noinline nounwind optnone
define hidden double @min2(double %N1, double %N2) #0 {
entry:
  %retval = alloca double, align 8
  %N1.addr = alloca double, align 8
  %N2.addr = alloca double, align 8
  store double %N1, double* %N1.addr, align 8
  store double %N2, double* %N2.addr, align 8
  %0 = load double, double* %N1.addr, align 8
  %1 = load double, double* %N2.addr, align 8
  %cmp = fcmp olt double %0, %1
  br i1 %cmp, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  %2 = load double, double* %N1.addr, align 8
  store double %2, double* %retval, align 8
  br label %return

if.else:                                          ; preds = %entry
  %3 = load double, double* %N2.addr, align 8
  store double %3, double* %retval, align 8
  br label %return

return:                                           ; preds = %if.else, %if.then
  %4 = load double, double* %retval, align 8
  ret double %4
}

; Function Attrs: noinline nounwind optnone
define hidden double* @p_adjust(double* noalias %PVALUES, i32 %NO_OF_ARRAY_ELEMENTS, i8* noalias %STRING) #0 {
entry:
  %retval = alloca double*, align 4
  %PVALUES.addr = alloca double*, align 4
  %NO_OF_ARRAY_ELEMENTS.addr = alloca i32, align 4
  %STRING.addr = alloca i8*, align 4
  %TYPE = alloca i16, align 2
  %bonferroni = alloca double*, align 4
  %index = alloca i32, align 4
  %BONFERRONI = alloca double, align 8
  %o = alloca i32*, align 4
  %o2double = alloca double*, align 4
  %cummax_input = alloca double*, align 4
  %index80 = alloca i32, align 4
  %ro = alloca i32*, align 4
  %cummax_output = alloca double*, align 4
  %pmin = alloca double*, align 4
  %qvalues = alloca double*, align 4
  %index98 = alloca i32, align 4
  %o114 = alloca i32*, align 4
  %p = alloca double*, align 4
  %index123 = alloca i32, align 4
  %o2double134 = alloca double*, align 4
  %ro136 = alloca i32*, align 4
  %q = alloca double*, align 4
  %pa = alloca double*, align 4
  %min = alloca double, align 8
  %index155 = alloca i32, align 4
  %TEMP = alloca double, align 8
  %index171 = alloca i32, align 4
  %j = alloca i32, align 4
  %ij = alloca i32*, align 4
  %I2_LENGTH = alloca i32, align 4
  %i2 = alloca i32*, align 4
  %i = alloca i32, align 4
  %q1 = alloca double, align 8
  %i208 = alloca i32, align 4
  %TEMP_Q1 = alloca double, align 8
  %i227 = alloca i32, align 4
  %i244 = alloca i32, align 4
  %i256 = alloca i32, align 4
  %index274 = alloca i32, align 4
  %o288 = alloca i32*, align 4
  %o_double = alloca double*, align 4
  %index296 = alloca i32, align 4
  %ro315 = alloca i32*, align 4
  %cummin_input = alloca double*, align 4
  %index328 = alloca i32, align 4
  %NI = alloca double, align 8
  %q349 = alloca double, align 8
  %index350 = alloca i32, align 4
  %index362 = alloca i32, align 4
  %NI367 = alloca double, align 8
  %index385 = alloca i32, align 4
  %cummin_array = alloca double*, align 4
  %pmin403 = alloca double*, align 4
  %q_array = alloca double*, align 4
  %index407 = alloca i32, align 4
  store double* %PVALUES, double** %PVALUES.addr, align 4
  store i32 %NO_OF_ARRAY_ELEMENTS, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
  store i8* %STRING, i8** %STRING.addr, align 4
  %0 = load i32, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
  %cmp = icmp ult i32 %0, 1
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %call = call i32 @puts(i8* getelementptr inbounds ([41 x i8], [41 x i8]* @.str.13, i32 0, i32 0))
  %call1 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([22 x i8], [22 x i8]* @.str.5, i32 0, i32 0), i8* getelementptr inbounds ([23 x i8], [23 x i8]* @.str.1, i32 0, i32 0), i32 217)
  call void @exit(i32 1) #5
  unreachable

if.end:                                           ; preds = %entry
  store i16 -1, i16* %TYPE, align 2
  %1 = load i8*, i8** %STRING.addr, align 4
  %cmp2 = icmp eq i8* %1, null
  br i1 %cmp2, label %if.then3, label %if.else

if.then3:                                         ; preds = %if.end
  store i16 0, i16* %TYPE, align 2
  br label %if.end41

if.else:                                          ; preds = %if.end
  %2 = load i8*, i8** %STRING.addr, align 4
  %call4 = call i32 @strcasecmp(i8* %2, i8* getelementptr inbounds ([3 x i8], [3 x i8]* @.str.14, i32 0, i32 0))
  %cmp5 = icmp eq i32 %call4, 0
  br i1 %cmp5, label %if.then6, label %if.else7

if.then6:                                         ; preds = %if.else
  store i16 0, i16* %TYPE, align 2
  br label %if.end40

if.else7:                                         ; preds = %if.else
  %3 = load i8*, i8** %STRING.addr, align 4
  %call8 = call i32 @strcasecmp(i8* %3, i8* getelementptr inbounds ([4 x i8], [4 x i8]* @.str.15, i32 0, i32 0))
  %cmp9 = icmp eq i32 %call8, 0
  br i1 %cmp9, label %if.then10, label %if.else11

if.then10:                                        ; preds = %if.else7
  store i16 0, i16* %TYPE, align 2
  br label %if.end39

if.else11:                                        ; preds = %if.else7
  %4 = load i8*, i8** %STRING.addr, align 4
  %call12 = call i32 @strcasecmp(i8* %4, i8* getelementptr inbounds ([3 x i8], [3 x i8]* @.str.16, i32 0, i32 0))
  %cmp13 = icmp eq i32 %call12, 0
  br i1 %cmp13, label %if.then14, label %if.else15

if.then14:                                        ; preds = %if.else11
  store i16 1, i16* %TYPE, align 2
  br label %if.end38

if.else15:                                        ; preds = %if.else11
  %5 = load i8*, i8** %STRING.addr, align 4
  %call16 = call i32 @strcasecmp(i8* %5, i8* getelementptr inbounds ([11 x i8], [11 x i8]* @.str.17, i32 0, i32 0))
  %cmp17 = icmp eq i32 %call16, 0
  br i1 %cmp17, label %if.then18, label %if.else19

if.then18:                                        ; preds = %if.else15
  store i16 2, i16* %TYPE, align 2
  br label %if.end37

if.else19:                                        ; preds = %if.else15
  %6 = load i8*, i8** %STRING.addr, align 4
  %call20 = call i32 @strcasecmp(i8* %6, i8* getelementptr inbounds ([9 x i8], [9 x i8]* @.str.18, i32 0, i32 0))
  %cmp21 = icmp eq i32 %call20, 0
  br i1 %cmp21, label %if.then22, label %if.else23

if.then22:                                        ; preds = %if.else19
  store i16 3, i16* %TYPE, align 2
  br label %if.end36

if.else23:                                        ; preds = %if.else19
  %7 = load i8*, i8** %STRING.addr, align 4
  %call24 = call i32 @strcasecmp(i8* %7, i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.19, i32 0, i32 0))
  %cmp25 = icmp eq i32 %call24, 0
  br i1 %cmp25, label %if.then26, label %if.else27

if.then26:                                        ; preds = %if.else23
  store i16 4, i16* %TYPE, align 2
  br label %if.end35

if.else27:                                        ; preds = %if.else23
  %8 = load i8*, i8** %STRING.addr, align 4
  %call28 = call i32 @strcasecmp(i8* %8, i8* getelementptr inbounds ([7 x i8], [7 x i8]* @.str.20, i32 0, i32 0))
  %cmp29 = icmp eq i32 %call28, 0
  br i1 %cmp29, label %if.then30, label %if.else31

if.then30:                                        ; preds = %if.else27
  store i16 5, i16* %TYPE, align 2
  br label %if.end34

if.else31:                                        ; preds = %if.else27
  %9 = load i8*, i8** %STRING.addr, align 4
  %call32 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([44 x i8], [44 x i8]* @.str.21, i32 0, i32 0), i8* %9)
  %call33 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([22 x i8], [22 x i8]* @.str.5, i32 0, i32 0), i8* getelementptr inbounds ([23 x i8], [23 x i8]* @.str.1, i32 0, i32 0), i32 239)
  call void @exit(i32 1) #5
  unreachable

if.end34:                                         ; preds = %if.then30
  br label %if.end35

if.end35:                                         ; preds = %if.end34, %if.then26
  br label %if.end36

if.end36:                                         ; preds = %if.end35, %if.then22
  br label %if.end37

if.end37:                                         ; preds = %if.end36, %if.then18
  br label %if.end38

if.end38:                                         ; preds = %if.end37, %if.then14
  br label %if.end39

if.end39:                                         ; preds = %if.end38, %if.then10
  br label %if.end40

if.end40:                                         ; preds = %if.end39, %if.then6
  br label %if.end41

if.end41:                                         ; preds = %if.end40, %if.then3
  %10 = load i16, i16* %TYPE, align 2
  %conv = sext i16 %10 to i32
  %cmp42 = icmp eq i32 %conv, 2
  br i1 %cmp42, label %if.then44, label %if.else71

if.then44:                                        ; preds = %if.end41
  %11 = load i32, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
  %mul = mul i32 8, %11
  %call45 = call noalias i8* @malloc(i32 %mul)
  %12 = bitcast i8* %call45 to double*
  store double* %12, double** %bonferroni, align 4
  %13 = load double*, double** %bonferroni, align 4
  %cmp46 = icmp eq double* %13, null
  br i1 %cmp46, label %if.then48, label %if.end50

if.then48:                                        ; preds = %if.then44
  %call49 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([33 x i8], [33 x i8]* @.str.3, i32 0, i32 0), i8* getelementptr inbounds ([23 x i8], [23 x i8]* @.str.1, i32 0, i32 0), i32 247)
  call void @perror(i8* getelementptr inbounds ([1 x i8], [1 x i8]* @.str.2, i32 0, i32 0))
  call void @exit(i32 1) #5
  unreachable

if.end50:                                         ; preds = %if.then44
  store i32 0, i32* %index, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.end50
  %14 = load i32, i32* %index, align 4
  %15 = load i32, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
  %cmp51 = icmp ult i32 %14, %15
  br i1 %cmp51, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %16 = load double*, double** %PVALUES.addr, align 4
  %17 = load i32, i32* %index, align 4
  %arrayidx = getelementptr inbounds double, double* %16, i32 %17
  %18 = load double, double* %arrayidx, align 8
  %19 = load i32, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
  %conv53 = uitofp i32 %19 to double
  %mul54 = fmul double %18, %conv53
  store double %mul54, double* %BONFERRONI, align 8
  %20 = load double, double* %BONFERRONI, align 8
  %cmp55 = fcmp oge double %20, 1.000000e+00
  br i1 %cmp55, label %if.then57, label %if.else59

if.then57:                                        ; preds = %for.body
  %21 = load double*, double** %bonferroni, align 4
  %22 = load i32, i32* %index, align 4
  %arrayidx58 = getelementptr inbounds double, double* %21, i32 %22
  store double 1.000000e+00, double* %arrayidx58, align 8
  br label %if.end70

if.else59:                                        ; preds = %for.body
  %23 = load double, double* %BONFERRONI, align 8
  %cmp60 = fcmp ole double 0.000000e+00, %23
  br i1 %cmp60, label %land.lhs.true, label %if.else66

land.lhs.true:                                    ; preds = %if.else59
  %24 = load double, double* %BONFERRONI, align 8
  %cmp62 = fcmp olt double %24, 1.000000e+00
  br i1 %cmp62, label %if.then64, label %if.else66

if.then64:                                        ; preds = %land.lhs.true
  %25 = load double, double* %BONFERRONI, align 8
  %26 = load double*, double** %bonferroni, align 4
  %27 = load i32, i32* %index, align 4
  %arrayidx65 = getelementptr inbounds double, double* %26, i32 %27
  store double %25, double* %arrayidx65, align 8
  br label %if.end69

if.else66:                                        ; preds = %land.lhs.true, %if.else59
  %28 = load double, double* %BONFERRONI, align 8
  %call67 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([42 x i8], [42 x i8]* @.str.22, i32 0, i32 0), double %28)
  %call68 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([23 x i8], [23 x i8]* @.str.23, i32 0, i32 0), i8* getelementptr inbounds ([23 x i8], [23 x i8]* @.str.1, i32 0, i32 0), i32 259)
  call void @exit(i32 1) #5
  unreachable

if.end69:                                         ; preds = %if.then64
  br label %if.end70

if.end70:                                         ; preds = %if.end69, %if.then57
  br label %for.inc

for.inc:                                          ; preds = %if.end70
  %29 = load i32, i32* %index, align 4
  %inc = add i32 %29, 1
  store i32 %inc, i32* %index, align 4
  br label %for.cond

for.end:                                          ; preds = %for.cond
  %30 = load double*, double** %bonferroni, align 4
  store double* %30, double** %retval, align 4
  br label %return

if.else71:                                        ; preds = %if.end41
  %31 = load i16, i16* %TYPE, align 2
  %conv72 = sext i16 %31 to i32
  %cmp73 = icmp eq i32 %conv72, 4
  br i1 %cmp73, label %if.then75, label %if.else109

if.then75:                                        ; preds = %if.else71
  %32 = load double*, double** %PVALUES.addr, align 4
  %33 = load i32, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
  %call76 = call i32* @order(double* %32, i32 %33, i1 zeroext false)
  store i32* %call76, i32** %o, align 4
  %34 = load i32*, i32** %o, align 4
  %35 = load i32, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
  %call77 = call double* @uint2double(i32* %34, i32 %35)
  store double* %call77, double** %o2double, align 4
  %36 = load i32, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
  %mul78 = mul i32 8, %36
  %call79 = call noalias i8* @malloc(i32 %mul78)
  %37 = bitcast i8* %call79 to double*
  store double* %37, double** %cummax_input, align 4
  store i32 0, i32* %index80, align 4
  br label %for.cond81

for.cond81:                                       ; preds = %for.inc90, %if.then75
  %38 = load i32, i32* %index80, align 4
  %39 = load i32, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
  %cmp82 = icmp ult i32 %38, %39
  br i1 %cmp82, label %for.body84, label %for.end92

for.body84:                                       ; preds = %for.cond81
  %40 = load i32, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
  %41 = load i32, i32* %index80, align 4
  %sub = sub i32 %40, %41
  %conv85 = uitofp i32 %sub to double
  %42 = load double*, double** %PVALUES.addr, align 4
  %43 = load i32*, i32** %o, align 4
  %44 = load i32, i32* %index80, align 4
  %arrayidx86 = getelementptr inbounds i32, i32* %43, i32 %44
  %45 = load i32, i32* %arrayidx86, align 4
  %arrayidx87 = getelementptr inbounds double, double* %42, i32 %45
  %46 = load double, double* %arrayidx87, align 8
  %mul88 = fmul double %conv85, %46
  %47 = load double*, double** %cummax_input, align 4
  %48 = load i32, i32* %index80, align 4
  %arrayidx89 = getelementptr inbounds double, double* %47, i32 %48
  store double %mul88, double* %arrayidx89, align 8
  br label %for.inc90

for.inc90:                                        ; preds = %for.body84
  %49 = load i32, i32* %index80, align 4
  %inc91 = add i32 %49, 1
  store i32 %inc91, i32* %index80, align 4
  br label %for.cond81

for.end92:                                        ; preds = %for.cond81
  %50 = load i32*, i32** %o, align 4
  %51 = bitcast i32* %50 to i8*
  call void @free(i8* %51)
  store i32* null, i32** %o, align 4
  %52 = load double*, double** %o2double, align 4
  %53 = load i32, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
  %call93 = call i32* @order(double* %52, i32 %53, i1 zeroext false)
  store i32* %call93, i32** %ro, align 4
  %54 = load double*, double** %o2double, align 4
  %55 = bitcast double* %54 to i8*
  call void @free(i8* %55)
  store double* null, double** %o2double, align 4
  %56 = load double*, double** %cummax_input, align 4
  %57 = load i32, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
  %call94 = call double* @cummax(double* %56, i32 %57)
  store double* %call94, double** %cummax_output, align 4
  %58 = load double*, double** %cummax_input, align 4
  %59 = bitcast double* %58 to i8*
  call void @free(i8* %59)
  store double* null, double** %cummax_input, align 4
  %60 = load double*, double** %cummax_output, align 4
  %61 = load i32, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
  %call95 = call double* @pminx(double* %60, i32 %61, double 1.000000e+00)
  store double* %call95, double** %pmin, align 4
  %62 = load double*, double** %cummax_output, align 4
  %63 = bitcast double* %62 to i8*
  call void @free(i8* %63)
  store double* null, double** %cummax_output, align 4
  %64 = load i32, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
  %mul96 = mul i32 8, %64
  %call97 = call noalias i8* @malloc(i32 %mul96)
  %65 = bitcast i8* %call97 to double*
  store double* %65, double** %qvalues, align 4
  store i32 0, i32* %index98, align 4
  br label %for.cond99

for.cond99:                                       ; preds = %for.inc106, %for.end92
  %66 = load i32, i32* %index98, align 4
  %67 = load i32, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
  %cmp100 = icmp ult i32 %66, %67
  br i1 %cmp100, label %for.body102, label %for.end108

for.body102:                                      ; preds = %for.cond99
  %68 = load double*, double** %pmin, align 4
  %69 = load i32*, i32** %ro, align 4
  %70 = load i32, i32* %index98, align 4
  %arrayidx103 = getelementptr inbounds i32, i32* %69, i32 %70
  %71 = load i32, i32* %arrayidx103, align 4
  %arrayidx104 = getelementptr inbounds double, double* %68, i32 %71
  %72 = load double, double* %arrayidx104, align 8
  %73 = load double*, double** %qvalues, align 4
  %74 = load i32, i32* %index98, align 4
  %arrayidx105 = getelementptr inbounds double, double* %73, i32 %74
  store double %72, double* %arrayidx105, align 8
  br label %for.inc106

for.inc106:                                       ; preds = %for.body102
  %75 = load i32, i32* %index98, align 4
  %inc107 = add i32 %75, 1
  store i32 %inc107, i32* %index98, align 4
  br label %for.cond99

for.end108:                                       ; preds = %for.cond99
  %76 = load double*, double** %pmin, align 4
  %77 = bitcast double* %76 to i8*
  call void @free(i8* %77)
  store double* null, double** %pmin, align 4
  %78 = load i32*, i32** %ro, align 4
  %79 = bitcast i32* %78 to i8*
  call void @free(i8* %79)
  store i32* null, i32** %ro, align 4
  %80 = load double*, double** %qvalues, align 4
  store double* %80, double** %retval, align 4
  br label %return

if.else109:                                       ; preds = %if.else71
  %81 = load i16, i16* %TYPE, align 2
  %conv110 = sext i16 %81 to i32
  %cmp111 = icmp eq i32 %conv110, 5
  br i1 %cmp111, label %if.then113, label %if.end285

if.then113:                                       ; preds = %if.else109
  %82 = load double*, double** %PVALUES.addr, align 4
  %83 = load i32, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
  %call115 = call i32* @order(double* %82, i32 %83, i1 zeroext false)
  store i32* %call115, i32** %o114, align 4
  %84 = load i32, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
  %mul116 = mul i32 8, %84
  %call117 = call noalias i8* @malloc(i32 %mul116)
  %85 = bitcast i8* %call117 to double*
  store double* %85, double** %p, align 4
  %86 = load double*, double** %p, align 4
  %cmp118 = icmp eq double* %86, null
  br i1 %cmp118, label %if.then120, label %if.end122

if.then120:                                       ; preds = %if.then113
  %call121 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([33 x i8], [33 x i8]* @.str.3, i32 0, i32 0), i8* getelementptr inbounds ([23 x i8], [23 x i8]* @.str.1, i32 0, i32 0), i32 302)
  call void @perror(i8* getelementptr inbounds ([1 x i8], [1 x i8]* @.str.2, i32 0, i32 0))
  call void @exit(i32 1) #5
  unreachable

if.end122:                                        ; preds = %if.then113
  store i32 0, i32* %index123, align 4
  br label %for.cond124

for.cond124:                                      ; preds = %for.inc131, %if.end122
  %87 = load i32, i32* %index123, align 4
  %88 = load i32, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
  %cmp125 = icmp ult i32 %87, %88
  br i1 %cmp125, label %for.body127, label %for.end133

for.body127:                                      ; preds = %for.cond124
  %89 = load double*, double** %PVALUES.addr, align 4
  %90 = load i32*, i32** %o114, align 4
  %91 = load i32, i32* %index123, align 4
  %arrayidx128 = getelementptr inbounds i32, i32* %90, i32 %91
  %92 = load i32, i32* %arrayidx128, align 4
  %arrayidx129 = getelementptr inbounds double, double* %89, i32 %92
  %93 = load double, double* %arrayidx129, align 8
  %94 = load double*, double** %p, align 4
  %95 = load i32, i32* %index123, align 4
  %arrayidx130 = getelementptr inbounds double, double* %94, i32 %95
  store double %93, double* %arrayidx130, align 8
  br label %for.inc131

for.inc131:                                       ; preds = %for.body127
  %96 = load i32, i32* %index123, align 4
  %inc132 = add i32 %96, 1
  store i32 %inc132, i32* %index123, align 4
  br label %for.cond124

for.end133:                                       ; preds = %for.cond124
  %97 = load i32*, i32** %o114, align 4
  %98 = load i32, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
  %call135 = call double* @uint2double(i32* %97, i32 %98)
  store double* %call135, double** %o2double134, align 4
  %99 = load i32*, i32** %o114, align 4
  %100 = bitcast i32* %99 to i8*
  call void @free(i8* %100)
  store i32* null, i32** %o114, align 4
  %101 = load double*, double** %o2double134, align 4
  %102 = load i32, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
  %call137 = call i32* @order(double* %101, i32 %102, i1 zeroext false)
  store i32* %call137, i32** %ro136, align 4
  %103 = load double*, double** %o2double134, align 4
  %104 = bitcast double* %103 to i8*
  call void @free(i8* %104)
  store double* null, double** %o2double134, align 4
  %105 = load i32, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
  %mul138 = mul i32 8, %105
  %call139 = call noalias i8* @malloc(i32 %mul138)
  %106 = bitcast i8* %call139 to double*
  store double* %106, double** %q, align 4
  %107 = load double*, double** %q, align 4
  %cmp140 = icmp eq double* %107, null
  br i1 %cmp140, label %if.then142, label %if.end144

if.then142:                                       ; preds = %for.end133
  %call143 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([33 x i8], [33 x i8]* @.str.3, i32 0, i32 0), i8* getelementptr inbounds ([23 x i8], [23 x i8]* @.str.1, i32 0, i32 0), i32 318)
  call void @perror(i8* getelementptr inbounds ([1 x i8], [1 x i8]* @.str.2, i32 0, i32 0))
  call void @exit(i32 1) #5
  unreachable

if.end144:                                        ; preds = %for.end133
  %108 = load i32, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
  %mul145 = mul i32 8, %108
  %call146 = call noalias i8* @malloc(i32 %mul145)
  %109 = bitcast i8* %call146 to double*
  store double* %109, double** %pa, align 4
  %110 = load double*, double** %pa, align 4
  %cmp147 = icmp eq double* %110, null
  br i1 %cmp147, label %if.then149, label %if.end151

if.then149:                                       ; preds = %if.end144
  %call150 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([33 x i8], [33 x i8]* @.str.3, i32 0, i32 0), i8* getelementptr inbounds ([23 x i8], [23 x i8]* @.str.1, i32 0, i32 0), i32 324)
  call void @perror(i8* getelementptr inbounds ([1 x i8], [1 x i8]* @.str.2, i32 0, i32 0))
  call void @exit(i32 1) #5
  unreachable

if.end151:                                        ; preds = %if.end144
  %111 = load i32, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
  %conv152 = uitofp i32 %111 to double
  %112 = load double*, double** %p, align 4
  %arrayidx153 = getelementptr inbounds double, double* %112, i32 0
  %113 = load double, double* %arrayidx153, align 8
  %mul154 = fmul double %conv152, %113
  store double %mul154, double* %min, align 8
  store i32 1, i32* %index155, align 4
  br label %for.cond156

for.cond156:                                      ; preds = %for.inc168, %if.end151
  %114 = load i32, i32* %index155, align 4
  %115 = load i32, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
  %cmp157 = icmp ult i32 %114, %115
  br i1 %cmp157, label %for.body159, label %for.end170

for.body159:                                      ; preds = %for.cond156
  %116 = load i32, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
  %conv160 = uitofp i32 %116 to double
  %117 = load double*, double** %p, align 4
  %118 = load i32, i32* %index155, align 4
  %arrayidx161 = getelementptr inbounds double, double* %117, i32 %118
  %119 = load double, double* %arrayidx161, align 8
  %mul162 = fmul double %conv160, %119
  %120 = load i32, i32* %index155, align 4
  %add = add i32 1, %120
  %conv163 = uitofp i32 %add to double
  %div = fdiv double %mul162, %conv163
  store double %div, double* %TEMP, align 8
  %121 = load double, double* %TEMP, align 8
  %122 = load double, double* %min, align 8
  %cmp164 = fcmp olt double %121, %122
  br i1 %cmp164, label %if.then166, label %if.end167

if.then166:                                       ; preds = %for.body159
  %123 = load double, double* %TEMP, align 8
  store double %123, double* %min, align 8
  br label %if.end167

if.end167:                                        ; preds = %if.then166, %for.body159
  br label %for.inc168

for.inc168:                                       ; preds = %if.end167
  %124 = load i32, i32* %index155, align 4
  %inc169 = add i32 %124, 1
  store i32 %inc169, i32* %index155, align 4
  br label %for.cond156

for.end170:                                       ; preds = %for.cond156
  store i32 0, i32* %index171, align 4
  br label %for.cond172

for.cond172:                                      ; preds = %for.inc178, %for.end170
  %125 = load i32, i32* %index171, align 4
  %126 = load i32, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
  %cmp173 = icmp ult i32 %125, %126
  br i1 %cmp173, label %for.body175, label %for.end180

for.body175:                                      ; preds = %for.cond172
  %127 = load double, double* %min, align 8
  %128 = load double*, double** %pa, align 4
  %129 = load i32, i32* %index171, align 4
  %arrayidx176 = getelementptr inbounds double, double* %128, i32 %129
  store double %127, double* %arrayidx176, align 8
  %130 = load double, double* %min, align 8
  %131 = load double*, double** %q, align 4
  %132 = load i32, i32* %index171, align 4
  %arrayidx177 = getelementptr inbounds double, double* %131, i32 %132
  store double %130, double* %arrayidx177, align 8
  br label %for.inc178

for.inc178:                                       ; preds = %for.body175
  %133 = load i32, i32* %index171, align 4
  %inc179 = add i32 %133, 1
  store i32 %inc179, i32* %index171, align 4
  br label %for.cond172

for.end180:                                       ; preds = %for.cond172
  %134 = load i32, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
  %sub181 = sub i32 %134, 1
  store i32 %sub181, i32* %j, align 4
  br label %for.cond182

for.cond182:                                      ; preds = %for.inc272, %for.end180
  %135 = load i32, i32* %j, align 4
  %cmp183 = icmp uge i32 %135, 2
  br i1 %cmp183, label %for.body185, label %for.end273

for.body185:                                      ; preds = %for.cond182
  %136 = load i32, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
  %137 = load i32, i32* %j, align 4
  %sub186 = sub i32 %136, %137
  %call187 = call i32* @seq_len(i32 0, i32 %sub186)
  store i32* %call187, i32** %ij, align 4
  %138 = load i32, i32* %j, align 4
  %sub188 = sub i32 %138, 1
  store i32 %sub188, i32* %I2_LENGTH, align 4
  %139 = load i32, i32* %I2_LENGTH, align 4
  %mul189 = mul i32 %139, 4
  %call190 = call noalias i8* @malloc(i32 %mul189)
  %140 = bitcast i8* %call190 to i32*
  store i32* %140, i32** %i2, align 4
  store i32 0, i32* %i, align 4
  br label %for.cond191

for.cond191:                                      ; preds = %for.inc200, %for.body185
  %141 = load i32, i32* %i, align 4
  %142 = load i32, i32* %I2_LENGTH, align 4
  %cmp192 = icmp ult i32 %141, %142
  br i1 %cmp192, label %for.body194, label %for.end202

for.body194:                                      ; preds = %for.cond191
  %143 = load i32, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
  %144 = load i32, i32* %j, align 4
  %sub195 = sub i32 %143, %144
  %add196 = add i32 %sub195, 2
  %145 = load i32, i32* %i, align 4
  %add197 = add i32 %add196, %145
  %sub198 = sub i32 %add197, 1
  %146 = load i32*, i32** %i2, align 4
  %147 = load i32, i32* %i, align 4
  %arrayidx199 = getelementptr inbounds i32, i32* %146, i32 %147
  store i32 %sub198, i32* %arrayidx199, align 4
  br label %for.inc200

for.inc200:                                       ; preds = %for.body194
  %148 = load i32, i32* %i, align 4
  %inc201 = add i32 %148, 1
  store i32 %inc201, i32* %i, align 4
  br label %for.cond191

for.end202:                                       ; preds = %for.cond191
  %149 = load i32, i32* %j, align 4
  %conv203 = uitofp i32 %149 to double
  %150 = load double*, double** %p, align 4
  %151 = load i32*, i32** %i2, align 4
  %arrayidx204 = getelementptr inbounds i32, i32* %151, i32 0
  %152 = load i32, i32* %arrayidx204, align 4
  %arrayidx205 = getelementptr inbounds double, double* %150, i32 %152
  %153 = load double, double* %arrayidx205, align 8
  %mul206 = fmul double %conv203, %153
  %div207 = fdiv double %mul206, 2.000000e+00
  store double %div207, double* %q1, align 8
  store i32 1, i32* %i208, align 4
  br label %for.cond209

for.cond209:                                      ; preds = %for.inc224, %for.end202
  %154 = load i32, i32* %i208, align 4
  %155 = load i32, i32* %I2_LENGTH, align 4
  %cmp210 = icmp ult i32 %154, %155
  br i1 %cmp210, label %for.body212, label %for.end226

for.body212:                                      ; preds = %for.cond209
  %156 = load i32, i32* %j, align 4
  %conv213 = uitofp i32 %156 to double
  %157 = load double*, double** %p, align 4
  %158 = load i32*, i32** %i2, align 4
  %159 = load i32, i32* %i208, align 4
  %arrayidx214 = getelementptr inbounds i32, i32* %158, i32 %159
  %160 = load i32, i32* %arrayidx214, align 4
  %arrayidx215 = getelementptr inbounds double, double* %157, i32 %160
  %161 = load double, double* %arrayidx215, align 8
  %mul216 = fmul double %conv213, %161
  %162 = load i32, i32* %i208, align 4
  %add217 = add i32 2, %162
  %conv218 = uitofp i32 %add217 to double
  %div219 = fdiv double %mul216, %conv218
  store double %div219, double* %TEMP_Q1, align 8
  %163 = load double, double* %TEMP_Q1, align 8
  %164 = load double, double* %q1, align 8
  %cmp220 = fcmp olt double %163, %164
  br i1 %cmp220, label %if.then222, label %if.end223

if.then222:                                       ; preds = %for.body212
  %165 = load double, double* %TEMP_Q1, align 8
  store double %165, double* %q1, align 8
  br label %if.end223

if.end223:                                        ; preds = %if.then222, %for.body212
  br label %for.inc224

for.inc224:                                       ; preds = %if.end223
  %166 = load i32, i32* %i208, align 4
  %inc225 = add i32 %166, 1
  store i32 %inc225, i32* %i208, align 4
  br label %for.cond209

for.end226:                                       ; preds = %for.cond209
  store i32 0, i32* %i227, align 4
  br label %for.cond228

for.cond228:                                      ; preds = %for.inc241, %for.end226
  %167 = load i32, i32* %i227, align 4
  %168 = load i32, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
  %169 = load i32, i32* %j, align 4
  %sub229 = sub i32 %168, %169
  %add230 = add i32 %sub229, 1
  %cmp231 = icmp ult i32 %167, %add230
  br i1 %cmp231, label %for.body233, label %for.end243

for.body233:                                      ; preds = %for.cond228
  %170 = load i32, i32* %j, align 4
  %conv234 = uitofp i32 %170 to double
  %171 = load double*, double** %p, align 4
  %172 = load i32*, i32** %ij, align 4
  %173 = load i32, i32* %i227, align 4
  %arrayidx235 = getelementptr inbounds i32, i32* %172, i32 %173
  %174 = load i32, i32* %arrayidx235, align 4
  %arrayidx236 = getelementptr inbounds double, double* %171, i32 %174
  %175 = load double, double* %arrayidx236, align 8
  %mul237 = fmul double %conv234, %175
  %176 = load double, double* %q1, align 8
  %call238 = call double @min2(double %mul237, double %176)
  %177 = load double*, double** %q, align 4
  %178 = load i32*, i32** %ij, align 4
  %179 = load i32, i32* %i227, align 4
  %arrayidx239 = getelementptr inbounds i32, i32* %178, i32 %179
  %180 = load i32, i32* %arrayidx239, align 4
  %arrayidx240 = getelementptr inbounds double, double* %177, i32 %180
  store double %call238, double* %arrayidx240, align 8
  br label %for.inc241

for.inc241:                                       ; preds = %for.body233
  %181 = load i32, i32* %i227, align 4
  %inc242 = add i32 %181, 1
  store i32 %inc242, i32* %i227, align 4
  br label %for.cond228

for.end243:                                       ; preds = %for.cond228
  %182 = load i32*, i32** %ij, align 4
  %183 = bitcast i32* %182 to i8*
  call void @free(i8* %183)
  store i32* null, i32** %ij, align 4
  store i32 0, i32* %i244, align 4
  br label %for.cond245

for.cond245:                                      ; preds = %for.inc253, %for.end243
  %184 = load i32, i32* %i244, align 4
  %185 = load i32, i32* %I2_LENGTH, align 4
  %cmp246 = icmp ult i32 %184, %185
  br i1 %cmp246, label %for.body248, label %for.end255

for.body248:                                      ; preds = %for.cond245
  %186 = load double*, double** %q, align 4
  %187 = load i32, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
  %188 = load i32, i32* %j, align 4
  %sub249 = sub i32 %187, %188
  %arrayidx250 = getelementptr inbounds double, double* %186, i32 %sub249
  %189 = load double, double* %arrayidx250, align 8
  %190 = load double*, double** %q, align 4
  %191 = load i32*, i32** %i2, align 4
  %192 = load i32, i32* %i244, align 4
  %arrayidx251 = getelementptr inbounds i32, i32* %191, i32 %192
  %193 = load i32, i32* %arrayidx251, align 4
  %arrayidx252 = getelementptr inbounds double, double* %190, i32 %193
  store double %189, double* %arrayidx252, align 8
  br label %for.inc253

for.inc253:                                       ; preds = %for.body248
  %194 = load i32, i32* %i244, align 4
  %inc254 = add i32 %194, 1
  store i32 %inc254, i32* %i244, align 4
  br label %for.cond245

for.end255:                                       ; preds = %for.cond245
  %195 = load i32*, i32** %i2, align 4
  %196 = bitcast i32* %195 to i8*
  call void @free(i8* %196)
  store i32* null, i32** %i2, align 4
  store i32 0, i32* %i256, align 4
  br label %for.cond257

for.cond257:                                      ; preds = %for.inc269, %for.end255
  %197 = load i32, i32* %i256, align 4
  %198 = load i32, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
  %cmp258 = icmp ult i32 %197, %198
  br i1 %cmp258, label %for.body260, label %for.end271

for.body260:                                      ; preds = %for.cond257
  %199 = load double*, double** %pa, align 4
  %200 = load i32, i32* %i256, align 4
  %arrayidx261 = getelementptr inbounds double, double* %199, i32 %200
  %201 = load double, double* %arrayidx261, align 8
  %202 = load double*, double** %q, align 4
  %203 = load i32, i32* %i256, align 4
  %arrayidx262 = getelementptr inbounds double, double* %202, i32 %203
  %204 = load double, double* %arrayidx262, align 8
  %cmp263 = fcmp olt double %201, %204
  br i1 %cmp263, label %if.then265, label %if.end268

if.then265:                                       ; preds = %for.body260
  %205 = load double*, double** %q, align 4
  %206 = load i32, i32* %i256, align 4
  %arrayidx266 = getelementptr inbounds double, double* %205, i32 %206
  %207 = load double, double* %arrayidx266, align 8
  %208 = load double*, double** %pa, align 4
  %209 = load i32, i32* %i256, align 4
  %arrayidx267 = getelementptr inbounds double, double* %208, i32 %209
  store double %207, double* %arrayidx267, align 8
  br label %if.end268

if.end268:                                        ; preds = %if.then265, %for.body260
  br label %for.inc269

for.inc269:                                       ; preds = %if.end268
  %210 = load i32, i32* %i256, align 4
  %inc270 = add i32 %210, 1
  store i32 %inc270, i32* %i256, align 4
  br label %for.cond257

for.end271:                                       ; preds = %for.cond257
  br label %for.inc272

for.inc272:                                       ; preds = %for.end271
  %211 = load i32, i32* %j, align 4
  %dec = add i32 %211, -1
  store i32 %dec, i32* %j, align 4
  br label %for.cond182

for.end273:                                       ; preds = %for.cond182
  %212 = load double*, double** %p, align 4
  %213 = bitcast double* %212 to i8*
  call void @free(i8* %213)
  store double* null, double** %p, align 4
  store i32 0, i32* %index274, align 4
  br label %for.cond275

for.cond275:                                      ; preds = %for.inc282, %for.end273
  %214 = load i32, i32* %index274, align 4
  %215 = load i32, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
  %cmp276 = icmp ult i32 %214, %215
  br i1 %cmp276, label %for.body278, label %for.end284

for.body278:                                      ; preds = %for.cond275
  %216 = load double*, double** %pa, align 4
  %217 = load i32*, i32** %ro136, align 4
  %218 = load i32, i32* %index274, align 4
  %arrayidx279 = getelementptr inbounds i32, i32* %217, i32 %218
  %219 = load i32, i32* %arrayidx279, align 4
  %arrayidx280 = getelementptr inbounds double, double* %216, i32 %219
  %220 = load double, double* %arrayidx280, align 8
  %221 = load double*, double** %q, align 4
  %222 = load i32, i32* %index274, align 4
  %arrayidx281 = getelementptr inbounds double, double* %221, i32 %222
  store double %220, double* %arrayidx281, align 8
  br label %for.inc282

for.inc282:                                       ; preds = %for.body278
  %223 = load i32, i32* %index274, align 4
  %inc283 = add i32 %223, 1
  store i32 %inc283, i32* %index274, align 4
  br label %for.cond275

for.end284:                                       ; preds = %for.cond275
  %224 = load i32*, i32** %ro136, align 4
  %225 = bitcast i32* %224 to i8*
  call void @free(i8* %225)
  store i32* null, i32** %ro136, align 4
  %226 = load double*, double** %pa, align 4
  %227 = bitcast double* %226 to i8*
  call void @free(i8* %227)
  store double* null, double** %pa, align 4
  %228 = load double*, double** %q, align 4
  store double* %228, double** %retval, align 4
  br label %return

if.end285:                                        ; preds = %if.else109
  br label %if.end286

if.end286:                                        ; preds = %if.end285
  br label %if.end287

if.end287:                                        ; preds = %if.end286
  %229 = load double*, double** %PVALUES.addr, align 4
  %230 = load i32, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
  %call289 = call i32* @order(double* %229, i32 %230, i1 zeroext true)
  store i32* %call289, i32** %o288, align 4
  %231 = load i32*, i32** %o288, align 4
  %cmp290 = icmp eq i32* %231, null
  br i1 %cmp290, label %if.then292, label %if.end294

if.then292:                                       ; preds = %if.end287
  %call293 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([33 x i8], [33 x i8]* @.str.3, i32 0, i32 0), i8* getelementptr inbounds ([23 x i8], [23 x i8]* @.str.1, i32 0, i32 0), i32 398)
  call void @perror(i8* getelementptr inbounds ([1 x i8], [1 x i8]* @.str.2, i32 0, i32 0))
  call void @exit(i32 1) #5
  unreachable

if.end294:                                        ; preds = %if.end287
  %232 = load i32*, i32** %o288, align 4
  %233 = load i32, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
  %call295 = call double* @uint2double(i32* %232, i32 %233)
  store double* %call295, double** %o_double, align 4
  store i32 0, i32* %index296, align 4
  br label %for.cond297

for.cond297:                                      ; preds = %for.inc312, %if.end294
  %234 = load i32, i32* %index296, align 4
  %235 = load i32, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
  %cmp298 = icmp ult i32 %234, %235
  br i1 %cmp298, label %for.body300, label %for.end314

for.body300:                                      ; preds = %for.cond297
  %236 = load double*, double** %PVALUES.addr, align 4
  %237 = load i32, i32* %index296, align 4
  %arrayidx301 = getelementptr inbounds double, double* %236, i32 %237
  %238 = load double, double* %arrayidx301, align 8
  %cmp302 = fcmp olt double %238, 0.000000e+00
  br i1 %cmp302, label %if.then307, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %for.body300
  %239 = load double*, double** %PVALUES.addr, align 4
  %240 = load i32, i32* %index296, align 4
  %arrayidx304 = getelementptr inbounds double, double* %239, i32 %240
  %241 = load double, double* %arrayidx304, align 8
  %cmp305 = fcmp ogt double %241, 1.000000e+00
  br i1 %cmp305, label %if.then307, label %if.end311

if.then307:                                       ; preds = %lor.lhs.false, %for.body300
  %242 = load i32, i32* %index296, align 4
  %243 = load double*, double** %PVALUES.addr, align 4
  %244 = load i32, i32* %index296, align 4
  %arrayidx308 = getelementptr inbounds double, double* %243, i32 %244
  %245 = load double, double* %arrayidx308, align 8
  %call309 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([54 x i8], [54 x i8]* @.str.24, i32 0, i32 0), i32 %242, double %245)
  %call310 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([20 x i8], [20 x i8]* @.str.25, i32 0, i32 0), i8* getelementptr inbounds ([23 x i8], [23 x i8]* @.str.1, i32 0, i32 0), i32 406)
  call void @exit(i32 1) #5
  unreachable

if.end311:                                        ; preds = %lor.lhs.false
  br label %for.inc312

for.inc312:                                       ; preds = %if.end311
  %246 = load i32, i32* %index296, align 4
  %inc313 = add i32 %246, 1
  store i32 %inc313, i32* %index296, align 4
  br label %for.cond297

for.end314:                                       ; preds = %for.cond297
  %247 = load double*, double** %o_double, align 4
  %248 = load i32, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
  %call316 = call i32* @order(double* %247, i32 %248, i1 zeroext false)
  store i32* %call316, i32** %ro315, align 4
  %249 = load i32*, i32** %ro315, align 4
  %cmp317 = icmp eq i32* %249, null
  br i1 %cmp317, label %if.then319, label %if.end321

if.then319:                                       ; preds = %for.end314
  %call320 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([33 x i8], [33 x i8]* @.str.3, i32 0, i32 0), i8* getelementptr inbounds ([23 x i8], [23 x i8]* @.str.1, i32 0, i32 0), i32 413)
  call void @perror(i8* getelementptr inbounds ([1 x i8], [1 x i8]* @.str.2, i32 0, i32 0))
  call void @exit(i32 1) #5
  unreachable

if.end321:                                        ; preds = %for.end314
  %250 = load double*, double** %o_double, align 4
  %251 = bitcast double* %250 to i8*
  call void @free(i8* %251)
  store double* null, double** %o_double, align 4
  %252 = load i32, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
  %mul322 = mul i32 8, %252
  %call323 = call noalias i8* @malloc(i32 %mul322)
  %253 = bitcast i8* %call323 to double*
  store double* %253, double** %cummin_input, align 4
  %254 = load i16, i16* %TYPE, align 2
  %conv324 = sext i16 %254 to i32
  %cmp325 = icmp eq i32 %conv324, 0
  br i1 %cmp325, label %if.then327, label %if.else344

if.then327:                                       ; preds = %if.end321
  store i32 0, i32* %index328, align 4
  br label %for.cond329

for.cond329:                                      ; preds = %for.inc341, %if.then327
  %255 = load i32, i32* %index328, align 4
  %256 = load i32, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
  %cmp330 = icmp ult i32 %255, %256
  br i1 %cmp330, label %for.body332, label %for.end343

for.body332:                                      ; preds = %for.cond329
  %257 = load i32, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
  %conv333 = uitofp i32 %257 to double
  %258 = load i32, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
  %259 = load i32, i32* %index328, align 4
  %sub334 = sub i32 %258, %259
  %conv335 = uitofp i32 %sub334 to double
  %div336 = fdiv double %conv333, %conv335
  store double %div336, double* %NI, align 8
  %260 = load double, double* %NI, align 8
  %261 = load double*, double** %PVALUES.addr, align 4
  %262 = load i32*, i32** %o288, align 4
  %263 = load i32, i32* %index328, align 4
  %arrayidx337 = getelementptr inbounds i32, i32* %262, i32 %263
  %264 = load i32, i32* %arrayidx337, align 4
  %arrayidx338 = getelementptr inbounds double, double* %261, i32 %264
  %265 = load double, double* %arrayidx338, align 8
  %mul339 = fmul double %260, %265
  %266 = load double*, double** %cummin_input, align 4
  %267 = load i32, i32* %index328, align 4
  %arrayidx340 = getelementptr inbounds double, double* %266, i32 %267
  store double %mul339, double* %arrayidx340, align 8
  br label %for.inc341

for.inc341:                                       ; preds = %for.body332
  %268 = load i32, i32* %index328, align 4
  %inc342 = add i32 %268, 1
  store i32 %inc342, i32* %index328, align 4
  br label %for.cond329

for.end343:                                       ; preds = %for.cond329
  br label %if.end401

if.else344:                                       ; preds = %if.end321
  %269 = load i16, i16* %TYPE, align 2
  %conv345 = sext i16 %269 to i32
  %cmp346 = icmp eq i32 %conv345, 1
  br i1 %cmp346, label %if.then348, label %if.else380

if.then348:                                       ; preds = %if.else344
  store double 1.000000e+00, double* %q349, align 8
  store i32 2, i32* %index350, align 4
  br label %for.cond351

for.cond351:                                      ; preds = %for.inc359, %if.then348
  %270 = load i32, i32* %index350, align 4
  %271 = load i32, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
  %add352 = add i32 1, %271
  %cmp353 = icmp ult i32 %270, %add352
  br i1 %cmp353, label %for.body355, label %for.end361

for.body355:                                      ; preds = %for.cond351
  %272 = load i32, i32* %index350, align 4
  %conv356 = uitofp i32 %272 to double
  %div357 = fdiv double 1.000000e+00, %conv356
  %273 = load double, double* %q349, align 8
  %add358 = fadd double %273, %div357
  store double %add358, double* %q349, align 8
  br label %for.inc359

for.inc359:                                       ; preds = %for.body355
  %274 = load i32, i32* %index350, align 4
  %inc360 = add i32 %274, 1
  store i32 %inc360, i32* %index350, align 4
  br label %for.cond351

for.end361:                                       ; preds = %for.cond351
  store i32 0, i32* %index362, align 4
  br label %for.cond363

for.cond363:                                      ; preds = %for.inc377, %for.end361
  %275 = load i32, i32* %index362, align 4
  %276 = load i32, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
  %cmp364 = icmp ult i32 %275, %276
  br i1 %cmp364, label %for.body366, label %for.end379

for.body366:                                      ; preds = %for.cond363
  %277 = load i32, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
  %conv368 = uitofp i32 %277 to double
  %278 = load i32, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
  %279 = load i32, i32* %index362, align 4
  %sub369 = sub i32 %278, %279
  %conv370 = uitofp i32 %sub369 to double
  %div371 = fdiv double %conv368, %conv370
  store double %div371, double* %NI367, align 8
  %280 = load double, double* %q349, align 8
  %281 = load double, double* %NI367, align 8
  %mul372 = fmul double %280, %281
  %282 = load double*, double** %PVALUES.addr, align 4
  %283 = load i32*, i32** %o288, align 4
  %284 = load i32, i32* %index362, align 4
  %arrayidx373 = getelementptr inbounds i32, i32* %283, i32 %284
  %285 = load i32, i32* %arrayidx373, align 4
  %arrayidx374 = getelementptr inbounds double, double* %282, i32 %285
  %286 = load double, double* %arrayidx374, align 8
  %mul375 = fmul double %mul372, %286
  %287 = load double*, double** %cummin_input, align 4
  %288 = load i32, i32* %index362, align 4
  %arrayidx376 = getelementptr inbounds double, double* %287, i32 %288
  store double %mul375, double* %arrayidx376, align 8
  br label %for.inc377

for.inc377:                                       ; preds = %for.body366
  %289 = load i32, i32* %index362, align 4
  %inc378 = add i32 %289, 1
  store i32 %inc378, i32* %index362, align 4
  br label %for.cond363

for.end379:                                       ; preds = %for.cond363
  br label %if.end400

if.else380:                                       ; preds = %if.else344
  %290 = load i16, i16* %TYPE, align 2
  %conv381 = sext i16 %290 to i32
  %cmp382 = icmp eq i32 %conv381, 3
  br i1 %cmp382, label %if.then384, label %if.end399

if.then384:                                       ; preds = %if.else380
  store i32 0, i32* %index385, align 4
  br label %for.cond386

for.cond386:                                      ; preds = %for.inc396, %if.then384
  %291 = load i32, i32* %index385, align 4
  %292 = load i32, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
  %cmp387 = icmp ult i32 %291, %292
  br i1 %cmp387, label %for.body389, label %for.end398

for.body389:                                      ; preds = %for.cond386
  %293 = load i32, i32* %index385, align 4
  %add390 = add i32 %293, 1
  %conv391 = uitofp i32 %add390 to double
  %294 = load double*, double** %PVALUES.addr, align 4
  %295 = load i32*, i32** %o288, align 4
  %296 = load i32, i32* %index385, align 4
  %arrayidx392 = getelementptr inbounds i32, i32* %295, i32 %296
  %297 = load i32, i32* %arrayidx392, align 4
  %arrayidx393 = getelementptr inbounds double, double* %294, i32 %297
  %298 = load double, double* %arrayidx393, align 8
  %mul394 = fmul double %conv391, %298
  %299 = load double*, double** %cummin_input, align 4
  %300 = load i32, i32* %index385, align 4
  %arrayidx395 = getelementptr inbounds double, double* %299, i32 %300
  store double %mul394, double* %arrayidx395, align 8
  br label %for.inc396

for.inc396:                                       ; preds = %for.body389
  %301 = load i32, i32* %index385, align 4
  %inc397 = add i32 %301, 1
  store i32 %inc397, i32* %index385, align 4
  br label %for.cond386

for.end398:                                       ; preds = %for.cond386
  br label %if.end399

if.end399:                                        ; preds = %for.end398, %if.else380
  br label %if.end400

if.end400:                                        ; preds = %if.end399, %for.end379
  br label %if.end401

if.end401:                                        ; preds = %if.end400, %for.end343
  %302 = load i32*, i32** %o288, align 4
  %303 = bitcast i32* %302 to i8*
  call void @free(i8* %303)
  store i32* null, i32** %o288, align 4
  store double* null, double** %cummin_array, align 4
  %304 = load double*, double** %cummin_input, align 4
  %305 = load i32, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
  %call402 = call double* @cummin(double* %304, i32 %305)
  store double* %call402, double** %cummin_array, align 4
  %306 = load double*, double** %cummin_input, align 4
  %307 = bitcast double* %306 to i8*
  call void @free(i8* %307)
  store double* null, double** %cummin_input, align 4
  %308 = load double*, double** %cummin_array, align 4
  %309 = load i32, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
  %call404 = call double* @pminx(double* %308, i32 %309, double 1.000000e+00)
  store double* %call404, double** %pmin403, align 4
  %310 = load double*, double** %cummin_array, align 4
  %311 = bitcast double* %310 to i8*
  call void @free(i8* %311)
  store double* null, double** %cummin_array, align 4
  %312 = load i32, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
  %mul405 = mul i32 %312, 8
  %call406 = call noalias i8* @malloc(i32 %mul405)
  %313 = bitcast i8* %call406 to double*
  store double* %313, double** %q_array, align 4
  store i32 0, i32* %index407, align 4
  br label %for.cond408

for.cond408:                                      ; preds = %for.inc415, %if.end401
  %314 = load i32, i32* %index407, align 4
  %315 = load i32, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
  %cmp409 = icmp ult i32 %314, %315
  br i1 %cmp409, label %for.body411, label %for.end417

for.body411:                                      ; preds = %for.cond408
  %316 = load double*, double** %pmin403, align 4
  %317 = load i32*, i32** %ro315, align 4
  %318 = load i32, i32* %index407, align 4
  %arrayidx412 = getelementptr inbounds i32, i32* %317, i32 %318
  %319 = load i32, i32* %arrayidx412, align 4
  %arrayidx413 = getelementptr inbounds double, double* %316, i32 %319
  %320 = load double, double* %arrayidx413, align 8
  %321 = load double*, double** %q_array, align 4
  %322 = load i32, i32* %index407, align 4
  %arrayidx414 = getelementptr inbounds double, double* %321, i32 %322
  store double %320, double* %arrayidx414, align 8
  br label %for.inc415

for.inc415:                                       ; preds = %for.body411
  %323 = load i32, i32* %index407, align 4
  %inc416 = add i32 %323, 1
  store i32 %inc416, i32* %index407, align 4
  br label %for.cond408

for.end417:                                       ; preds = %for.cond408
  %324 = load i32*, i32** %ro315, align 4
  %325 = bitcast i32* %324 to i8*
  call void @free(i8* %325)
  store i32* null, i32** %ro315, align 4
  %326 = load double*, double** %pmin403, align 4
  %327 = bitcast double* %326 to i8*
  call void @free(i8* %327)
  store double* null, double** %pmin403, align 4
  %328 = load double*, double** %q_array, align 4
  store double* %328, double** %retval, align 4
  br label %return

return:                                           ; preds = %for.end417, %for.end284, %for.end108, %for.end
  %329 = load double*, double** %retval, align 4
  ret double* %329
}

declare i32 @strcasecmp(i8* %0, i8* %1) #1

; Function Attrs: noinline nounwind optnone
define hidden i32 @main() #0 {
entry:
  %retval = alloca i32, align 4
  %PVALUES = alloca [50 x double], align 16
  %CORRECT_ANSWERS = alloca [6 x [50 x double]], align 16
  %TYPES = alloca [6 x i8*], align 16
  %type = alloca i16, align 2
  %q = alloca double*, align 4
  %error = alloca double, align 8
  %i = alloca i32, align 4
  %this_error = alloca double, align 8
  store i32 0, i32* %retval, align 4
  %0 = bitcast [50 x double]* %PVALUES to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 16 %0, i8* align 16 bitcast ([50 x double]* @__const.main.PVALUES to i8*), i32 400, i1 false)
  %1 = bitcast [6 x [50 x double]]* %CORRECT_ANSWERS to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 16 %1, i8* align 16 bitcast ([6 x [50 x double]]* @__const.main.CORRECT_ANSWERS to i8*), i32 2400, i1 false)
  %2 = bitcast [6 x i8*]* %TYPES to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 16 %2, i8* align 16 bitcast ([6 x i8*]* @__const.main.TYPES to i8*), i32 24, i1 false)
  store i16 0, i16* %type, align 2
  br label %for.cond

for.cond:                                         ; preds = %for.inc19, %entry
  %3 = load i16, i16* %type, align 2
  %conv = zext i16 %3 to i32
  %cmp = icmp sle i32 %conv, 5
  br i1 %cmp, label %for.body, label %for.end21

for.body:                                         ; preds = %for.cond
  %arraydecay = getelementptr inbounds [50 x double], [50 x double]* %PVALUES, i32 0, i32 0
  %4 = load i16, i16* %type, align 2
  %idxprom = zext i16 %4 to i32
  %arrayidx = getelementptr inbounds [6 x i8*], [6 x i8*]* %TYPES, i32 0, i32 %idxprom
  %5 = load i8*, i8** %arrayidx, align 4
  %call = call double* @p_adjust(double* %arraydecay, i32 50, i8* %5)
  store double* %call, double** %q, align 4
  %6 = load double*, double** %q, align 4
  %arrayidx2 = getelementptr inbounds double, double* %6, i32 0
  %7 = load double, double* %arrayidx2, align 8
  %8 = load i16, i16* %type, align 2
  %idxprom3 = zext i16 %8 to i32
  %arrayidx4 = getelementptr inbounds [6 x [50 x double]], [6 x [50 x double]]* %CORRECT_ANSWERS, i32 0, i32 %idxprom3
  %arrayidx5 = getelementptr inbounds [50 x double], [50 x double]* %arrayidx4, i32 0, i32 0
  %9 = load double, double* %arrayidx5, align 16
  %sub = fsub double %7, %9
  %10 = call double @llvm.fabs.f64(double %sub)
  store double %10, double* %error, align 8
  store i32 1, i32* %i, align 4
  br label %for.cond6

for.cond6:                                        ; preds = %for.inc, %for.body
  %11 = load i32, i32* %i, align 4
  %cmp7 = icmp ult i32 %11, 50
  br i1 %cmp7, label %for.body9, label %for.end

for.body9:                                        ; preds = %for.cond6
  %12 = load double*, double** %q, align 4
  %13 = load i32, i32* %i, align 4
  %arrayidx10 = getelementptr inbounds double, double* %12, i32 %13
  %14 = load double, double* %arrayidx10, align 8
  %15 = load i16, i16* %type, align 2
  %idxprom11 = zext i16 %15 to i32
  %arrayidx12 = getelementptr inbounds [6 x [50 x double]], [6 x [50 x double]]* %CORRECT_ANSWERS, i32 0, i32 %idxprom11
  %16 = load i32, i32* %i, align 4
  %arrayidx13 = getelementptr inbounds [50 x double], [50 x double]* %arrayidx12, i32 0, i32 %16
  %17 = load double, double* %arrayidx13, align 8
  %sub14 = fsub double %14, %17
  %18 = call double @llvm.fabs.f64(double %sub14)
  store double %18, double* %this_error, align 8
  %19 = load double, double* %this_error, align 8
  %20 = load double, double* %error, align 8
  %add = fadd double %20, %19
  store double %add, double* %error, align 8
  br label %for.inc

for.inc:                                          ; preds = %for.body9
  %21 = load i32, i32* %i, align 4
  %inc = add i32 %21, 1
  store i32 %inc, i32* %i, align 4
  br label %for.cond6

for.end:                                          ; preds = %for.cond6
  %22 = load double*, double** %q, align 4
  call void @double_say(double* %22, i32 50)
  %23 = load double*, double** %q, align 4
  %24 = bitcast double* %23 to i8*
  call void @free(i8* %24)
  store double* null, double** %q, align 4
  %25 = load i16, i16* %type, align 2
  %conv15 = zext i16 %25 to i32
  %26 = load i16, i16* %type, align 2
  %idxprom16 = zext i16 %26 to i32
  %arrayidx17 = getelementptr inbounds [6 x i8*], [6 x i8*]* %TYPES, i32 0, i32 %idxprom16
  %27 = load i8*, i8** %arrayidx17, align 4
  %28 = load double, double* %error, align 8
  %call18 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([44 x i8], [44 x i8]* @.str.28, i32 0, i32 0), i32 %conv15, i8* %27, double %28)
  br label %for.inc19

for.inc19:                                        ; preds = %for.end
  %29 = load i16, i16* %type, align 2
  %inc20 = add i16 %29, 1
  store i16 %inc20, i16* %type, align 2
  br label %for.cond

for.end21:                                        ; preds = %for.cond
  ret i32 0
}

; Function Attrs: argmemonly nounwind willreturn
declare void @llvm.memcpy.p0i8.p0i8.i32(i8* noalias nocapture writeonly %0, i8* noalias nocapture readonly %1, i32 %2, i1 immarg %3) #3

; Function Attrs: nounwind readnone speculatable willreturn
declare double @llvm.fabs.f64(double %0) #4

attributes #0 = { noinline nounwind optnone "correctly-rounded-divide-sqrt-fp-math"="false" "disable-tail-calls"="false" "frame-pointer"="none" "less-precise-fpmad"="false" "min-legal-vector-width"="0" "no-infs-fp-math"="false" "no-jump-tables"="false" "no-nans-fp-math"="false" "no-signed-zeros-fp-math"="false" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="generic" "unsafe-fp-math"="false" "use-soft-float"="false" }
attributes #1 = { "correctly-rounded-divide-sqrt-fp-math"="false" "disable-tail-calls"="false" "frame-pointer"="none" "less-precise-fpmad"="false" "no-infs-fp-math"="false" "no-nans-fp-math"="false" "no-signed-zeros-fp-math"="false" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="generic" "unsafe-fp-math"="false" "use-soft-float"="false" }
attributes #2 = { noreturn "correctly-rounded-divide-sqrt-fp-math"="false" "disable-tail-calls"="false" "frame-pointer"="none" "less-precise-fpmad"="false" "no-infs-fp-math"="false" "no-nans-fp-math"="false" "no-signed-zeros-fp-math"="false" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="generic" "unsafe-fp-math"="false" "use-soft-float"="false" }
attributes #3 = { argmemonly nounwind willreturn }
attributes #4 = { nounwind readnone speculatable willreturn }
attributes #5 = { noreturn }

!llvm.module.flags = !{!0}
!llvm.ident = !{!1}

!0 = !{i32 1, !"wchar_size", i32 4}
!1 = !{!"clang version 11.0.0 (https://github.com/Jacarte/llvm-project.git 0f6dea67136cc1e0b3d200eb2bb165628970c44b)"}

; extracted candidates

; *****
; For LLVM instruction:
;  %0 = load i32, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %cmp = icmp ult i32 %0, 1
; Looking for a replacement for:
%0:i32 = var
%1:i1 = ult %0, 1:i32
infer %1

; *****
; For LLVM instruction:
;  %cmp2 = icmp eq i8* %1, null
; Looking for a replacement for:
%0:i32 = var
%1:i1 = eq 0:i32, %0
infer %1

; *****
; For LLVM instruction:
;  %call4 = call i32 @strcasecmp(i8* %2, i8* getelementptr inbounds ([3 x i8], [3 x i8]* @.str.14, i32 0, i32 0))
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %cmp5 = icmp eq i32 %call4, 0
; Looking for a replacement for:
%0:i32 = var
%1:i1 = eq 0:i32, %0
infer %1

; *****
; For LLVM instruction:
;  %call8 = call i32 @strcasecmp(i8* %3, i8* getelementptr inbounds ([4 x i8], [4 x i8]* @.str.15, i32 0, i32 0))
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %cmp9 = icmp eq i32 %call8, 0
; Looking for a replacement for:
%0:i32 = var
%1:i1 = eq 0:i32, %0
infer %1

; *****
; For LLVM instruction:
;  %call12 = call i32 @strcasecmp(i8* %4, i8* getelementptr inbounds ([3 x i8], [3 x i8]* @.str.16, i32 0, i32 0))
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %cmp13 = icmp eq i32 %call12, 0
; Looking for a replacement for:
%0:i32 = var
%1:i1 = eq 0:i32, %0
infer %1

; *****
; For LLVM instruction:
;  %call16 = call i32 @strcasecmp(i8* %5, i8* getelementptr inbounds ([11 x i8], [11 x i8]* @.str.17, i32 0, i32 0))
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %cmp17 = icmp eq i32 %call16, 0
; Looking for a replacement for:
%0:i32 = var
%1:i1 = eq 0:i32, %0
infer %1

; *****
; For LLVM instruction:
;  %call20 = call i32 @strcasecmp(i8* %6, i8* getelementptr inbounds ([9 x i8], [9 x i8]* @.str.18, i32 0, i32 0))
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %cmp21 = icmp eq i32 %call20, 0
; Looking for a replacement for:
%0:i32 = var
%1:i1 = eq 0:i32, %0
infer %1

; *****
; For LLVM instruction:
;  %call24 = call i32 @strcasecmp(i8* %7, i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.19, i32 0, i32 0))
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %cmp25 = icmp eq i32 %call24, 0
; Looking for a replacement for:
%0:i32 = var
%1:i1 = eq 0:i32, %0
infer %1

; *****
; For LLVM instruction:
;  %call28 = call i32 @strcasecmp(i8* %8, i8* getelementptr inbounds ([7 x i8], [7 x i8]* @.str.20, i32 0, i32 0))
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %cmp29 = icmp eq i32 %call28, 0
; Looking for a replacement for:
%0:i32 = var
%1:i1 = eq 0:i32, %0
infer %1

; *****
; For LLVM instruction:
;  %10 = load i16, i16* %TYPE, align 2
; Looking for a replacement for:
%0:i16 = var
infer %0

; *****
; For LLVM instruction:
;  %conv = sext i16 %10 to i32
; Looking for a replacement for:
%0:i16 = var
%1:i32 = sext %0
infer %1

; *****
; For LLVM instruction:
;  %cmp42 = icmp eq i32 %conv, 2
; Looking for a replacement for:
%0:i16 = var
%1:i32 = sext %0
%2:i1 = eq 2:i32, %1
infer %2

; *****
; For LLVM instruction:
;  %11 = load i32, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %mul = mul i32 8, %11
; Looking for a replacement for:
%0:i32 = var
%1:i32 = mul 8:i32, %0
infer %1

; *****
; For LLVM instruction:
;  %cmp46 = icmp eq double* %13, null
; Looking for a replacement for:
%0:i32 = var
%1:i1 = eq 0:i32, %0
infer %1

; *****
; For LLVM instruction:
;  %14 = load i32, i32* %index, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %15 = load i32, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %cmp51 = icmp ult i32 %14, %15
; Looking for a replacement for:
%0:i32 = var
%1:i32 = var
%2:i1 = ult %0, %1
infer %2

; *****
; For LLVM instruction:
;  %17 = load i32, i32* %index, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %19 = load i32, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %cmp55 = fcmp oge double %20, 1.000000e+00
; Looking for a replacement for:
%0:i1 = var
infer %0

; *****
; For LLVM instruction:
;  %22 = load i32, i32* %index, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %cmp60 = fcmp ole double 0.000000e+00, %23
; Looking for a replacement for:
%0:i1 = var
infer %0

; *****
; For LLVM instruction:
;  %cmp62 = fcmp olt double %24, 1.000000e+00
; Looking for a replacement for:
%0:i1 = var
infer %0

; *****
; For LLVM instruction:
;  %27 = load i32, i32* %index, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %29 = load i32, i32* %index, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %inc = add i32 %29, 1
; Looking for a replacement for:
%0:i32 = var
%1:i32 = add 1:i32, %0
infer %1

; *****
; For LLVM instruction:
;  %31 = load i16, i16* %TYPE, align 2
; Looking for a replacement for:
%0:i16 = var
infer %0

; *****
; For LLVM instruction:
;  %conv72 = sext i16 %31 to i32
; Looking for a replacement for:
%0:i16 = var
%1:i32 = sext %0
infer %1

; *****
; For LLVM instruction:
;  %cmp73 = icmp eq i32 %conv72, 4
; Looking for a replacement for:
%0:i16 = var
%1:i32 = sext %0
%2:i1 = eq 4:i32, %1
infer %2

; *****
; For LLVM instruction:
;  %33 = load i32, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %35 = load i32, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %36 = load i32, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %mul78 = mul i32 8, %36
; Looking for a replacement for:
%0:i32 = var
%1:i32 = mul 8:i32, %0
infer %1

; *****
; For LLVM instruction:
;  %38 = load i32, i32* %index80, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %39 = load i32, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %cmp82 = icmp ult i32 %38, %39
; Looking for a replacement for:
%0:i32 = var
%1:i32 = var
%2:i1 = ult %0, %1
infer %2

; *****
; For LLVM instruction:
;  %40 = load i32, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %41 = load i32, i32* %index80, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %sub = sub i32 %40, %41
; Looking for a replacement for:
%0:i32 = var
%1:i32 = var
%2:i32 = sub %0, %1
infer %2

; *****
; For LLVM instruction:
;  %44 = load i32, i32* %index80, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %45 = load i32, i32* %arrayidx86, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %48 = load i32, i32* %index80, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %49 = load i32, i32* %index80, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %inc91 = add i32 %49, 1
; Looking for a replacement for:
%0:i32 = var
%1:i32 = add 1:i32, %0
infer %1

; *****
; For LLVM instruction:
;  %53 = load i32, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %57 = load i32, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %61 = load i32, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %64 = load i32, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %mul96 = mul i32 8, %64
; Looking for a replacement for:
%0:i32 = var
%1:i32 = mul 8:i32, %0
infer %1

; *****
; For LLVM instruction:
;  %66 = load i32, i32* %index98, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %67 = load i32, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %cmp100 = icmp ult i32 %66, %67
; Looking for a replacement for:
%0:i32 = var
%1:i32 = var
%2:i1 = ult %0, %1
infer %2

; *****
; For LLVM instruction:
;  %70 = load i32, i32* %index98, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %71 = load i32, i32* %arrayidx103, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %74 = load i32, i32* %index98, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %75 = load i32, i32* %index98, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %inc107 = add i32 %75, 1
; Looking for a replacement for:
%0:i32 = var
%1:i32 = add 1:i32, %0
infer %1

; *****
; For LLVM instruction:
;  %81 = load i16, i16* %TYPE, align 2
; Looking for a replacement for:
%0:i16 = var
infer %0

; *****
; For LLVM instruction:
;  %conv110 = sext i16 %81 to i32
; Looking for a replacement for:
%0:i16 = var
%1:i32 = sext %0
infer %1

; *****
; For LLVM instruction:
;  %cmp111 = icmp eq i32 %conv110, 5
; Looking for a replacement for:
%0:i16 = var
%1:i32 = sext %0
%2:i1 = eq 5:i32, %1
infer %2

; *****
; For LLVM instruction:
;  %83 = load i32, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %84 = load i32, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %mul116 = mul i32 8, %84
; Looking for a replacement for:
%0:i32 = var
%1:i32 = mul 8:i32, %0
infer %1

; *****
; For LLVM instruction:
;  %cmp118 = icmp eq double* %86, null
; Looking for a replacement for:
%0:i32 = var
%1:i1 = eq 0:i32, %0
infer %1

; *****
; For LLVM instruction:
;  %87 = load i32, i32* %index123, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %88 = load i32, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %cmp125 = icmp ult i32 %87, %88
; Looking for a replacement for:
%0:i32 = var
%1:i32 = var
%2:i1 = ult %0, %1
infer %2

; *****
; For LLVM instruction:
;  %91 = load i32, i32* %index123, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %92 = load i32, i32* %arrayidx128, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %95 = load i32, i32* %index123, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %96 = load i32, i32* %index123, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %inc132 = add i32 %96, 1
; Looking for a replacement for:
%0:i32 = var
%1:i32 = add 1:i32, %0
infer %1

; *****
; For LLVM instruction:
;  %98 = load i32, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %102 = load i32, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %105 = load i32, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %mul138 = mul i32 8, %105
; Looking for a replacement for:
%0:i32 = var
%1:i32 = mul 8:i32, %0
infer %1

; *****
; For LLVM instruction:
;  %cmp140 = icmp eq double* %107, null
; Looking for a replacement for:
%0:i32 = var
%1:i1 = eq 0:i32, %0
infer %1

; *****
; For LLVM instruction:
;  %108 = load i32, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %mul145 = mul i32 8, %108
; Looking for a replacement for:
%0:i32 = var
%1:i32 = mul 8:i32, %0
infer %1

; *****
; For LLVM instruction:
;  %cmp147 = icmp eq double* %110, null
; Looking for a replacement for:
%0:i32 = var
%1:i1 = eq 0:i32, %0
infer %1

; *****
; For LLVM instruction:
;  %111 = load i32, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %114 = load i32, i32* %index155, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %115 = load i32, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %cmp157 = icmp ult i32 %114, %115
; Looking for a replacement for:
%0:i32 = var
%1:i32 = var
%2:i1 = ult %0, %1
infer %2

; *****
; For LLVM instruction:
;  %116 = load i32, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %118 = load i32, i32* %index155, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %120 = load i32, i32* %index155, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %add = add i32 1, %120
; Looking for a replacement for:
%0:i32 = var
%1:i32 = add 1:i32, %0
infer %1

; *****
; For LLVM instruction:
;  %cmp164 = fcmp olt double %121, %122
; Looking for a replacement for:
%0:i1 = var
infer %0

; *****
; For LLVM instruction:
;  %124 = load i32, i32* %index155, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %inc169 = add i32 %124, 1
; Looking for a replacement for:
%0:i32 = var
%1:i32 = add 1:i32, %0
infer %1

; *****
; For LLVM instruction:
;  %125 = load i32, i32* %index171, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %126 = load i32, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %cmp173 = icmp ult i32 %125, %126
; Looking for a replacement for:
%0:i32 = var
%1:i32 = var
%2:i1 = ult %0, %1
infer %2

; *****
; For LLVM instruction:
;  %129 = load i32, i32* %index171, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %132 = load i32, i32* %index171, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %133 = load i32, i32* %index171, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %inc179 = add i32 %133, 1
; Looking for a replacement for:
%0:i32 = var
%1:i32 = add 1:i32, %0
infer %1

; *****
; For LLVM instruction:
;  %134 = load i32, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %sub181 = sub i32 %134, 1
; Looking for a replacement for:
%0:i32 = var
%1:i32 = sub %0, 1:i32
infer %1

; *****
; For LLVM instruction:
;  %135 = load i32, i32* %j, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %cmp183 = icmp uge i32 %135, 2
; Looking for a replacement for:
%0:i32 = var
%1:i1 = ule 2:i32, %0
infer %1

; *****
; For LLVM instruction:
;  %136 = load i32, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %137 = load i32, i32* %j, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %sub186 = sub i32 %136, %137
; Looking for a replacement for:
%0:i32 = var
%1:i32 = var
%2:i32 = sub %0, %1
infer %2

; *****
; For LLVM instruction:
;  %138 = load i32, i32* %j, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %sub188 = sub i32 %138, 1
; Looking for a replacement for:
%0:i32 = var
%1:i32 = sub %0, 1:i32
infer %1

; *****
; For LLVM instruction:
;  %139 = load i32, i32* %I2_LENGTH, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %mul189 = mul i32 %139, 4
; Looking for a replacement for:
%0:i32 = var
%1:i32 = mul 4:i32, %0
infer %1

; *****
; For LLVM instruction:
;  %141 = load i32, i32* %i, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %142 = load i32, i32* %I2_LENGTH, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %cmp192 = icmp ult i32 %141, %142
; Looking for a replacement for:
%0:i32 = var
%1:i32 = var
%2:i1 = ult %0, %1
infer %2

; *****
; For LLVM instruction:
;  %143 = load i32, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %144 = load i32, i32* %j, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %sub195 = sub i32 %143, %144
; Looking for a replacement for:
%0:i32 = var
%1:i32 = var
%2:i32 = sub %0, %1
infer %2

; *****
; For LLVM instruction:
;  %add196 = add i32 %sub195, 2
; Looking for a replacement for:
%0:i32 = var
%1:i32 = var
%2:i32 = sub %0, %1
%3:i32 = add 2:i32, %2
infer %3

; *****
; For LLVM instruction:
;  %145 = load i32, i32* %i, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %add197 = add i32 %add196, %145
; Looking for a replacement for:
%0:i32 = var
%1:i32 = var
%2:i32 = var
%3:i32 = sub %1, %2
%4:i32 = add 2:i32, %3
%5:i32 = add %0, %4
infer %5

; *****
; For LLVM instruction:
;  %sub198 = sub i32 %add197, 1
; Looking for a replacement for:
%0:i32 = var
%1:i32 = var
%2:i32 = var
%3:i32 = sub %1, %2
%4:i32 = add 2:i32, %3
%5:i32 = add %0, %4
%6:i32 = sub %5, 1:i32
infer %6

; *****
; For LLVM instruction:
;  %147 = load i32, i32* %i, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %148 = load i32, i32* %i, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %inc201 = add i32 %148, 1
; Looking for a replacement for:
%0:i32 = var
%1:i32 = add 1:i32, %0
infer %1

; *****
; For LLVM instruction:
;  %149 = load i32, i32* %j, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %152 = load i32, i32* %arrayidx204, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %154 = load i32, i32* %i208, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %155 = load i32, i32* %I2_LENGTH, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %cmp210 = icmp ult i32 %154, %155
; Looking for a replacement for:
%0:i32 = var
%1:i32 = var
%2:i1 = ult %0, %1
infer %2

; *****
; For LLVM instruction:
;  %156 = load i32, i32* %j, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %159 = load i32, i32* %i208, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %160 = load i32, i32* %arrayidx214, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %162 = load i32, i32* %i208, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %add217 = add i32 2, %162
; Looking for a replacement for:
%0:i32 = var
%1:i32 = add 2:i32, %0
infer %1

; *****
; For LLVM instruction:
;  %cmp220 = fcmp olt double %163, %164
; Looking for a replacement for:
%0:i1 = var
infer %0

; *****
; For LLVM instruction:
;  %166 = load i32, i32* %i208, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %inc225 = add i32 %166, 1
; Looking for a replacement for:
%0:i32 = var
%1:i32 = add 1:i32, %0
infer %1

; *****
; For LLVM instruction:
;  %167 = load i32, i32* %i227, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %168 = load i32, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %169 = load i32, i32* %j, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %sub229 = sub i32 %168, %169
; Looking for a replacement for:
%0:i32 = var
%1:i32 = var
%2:i32 = sub %0, %1
infer %2

; *****
; For LLVM instruction:
;  %add230 = add i32 %sub229, 1
; Looking for a replacement for:
%0:i32 = var
%1:i32 = var
%2:i32 = sub %0, %1
%3:i32 = add 1:i32, %2
infer %3

; *****
; For LLVM instruction:
;  %cmp231 = icmp ult i32 %167, %add230
; Looking for a replacement for:
%0:i32 = var
%1:i32 = var
%2:i32 = var
%3:i32 = sub %1, %2
%4:i32 = add 1:i32, %3
%5:i1 = ult %0, %4
infer %5

; *****
; For LLVM instruction:
;  %170 = load i32, i32* %j, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %173 = load i32, i32* %i227, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %174 = load i32, i32* %arrayidx235, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %179 = load i32, i32* %i227, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %180 = load i32, i32* %arrayidx239, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %181 = load i32, i32* %i227, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %inc242 = add i32 %181, 1
; Looking for a replacement for:
%0:i32 = var
%1:i32 = add 1:i32, %0
infer %1

; *****
; For LLVM instruction:
;  %184 = load i32, i32* %i244, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %185 = load i32, i32* %I2_LENGTH, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %cmp246 = icmp ult i32 %184, %185
; Looking for a replacement for:
%0:i32 = var
%1:i32 = var
%2:i1 = ult %0, %1
infer %2

; *****
; For LLVM instruction:
;  %187 = load i32, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %188 = load i32, i32* %j, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %sub249 = sub i32 %187, %188
; Looking for a replacement for:
%0:i32 = var
%1:i32 = var
%2:i32 = sub %0, %1
infer %2

; *****
; For LLVM instruction:
;  %192 = load i32, i32* %i244, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %193 = load i32, i32* %arrayidx251, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %194 = load i32, i32* %i244, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %inc254 = add i32 %194, 1
; Looking for a replacement for:
%0:i32 = var
%1:i32 = add 1:i32, %0
infer %1

; *****
; For LLVM instruction:
;  %197 = load i32, i32* %i256, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %198 = load i32, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %cmp258 = icmp ult i32 %197, %198
; Looking for a replacement for:
%0:i32 = var
%1:i32 = var
%2:i1 = ult %0, %1
infer %2

; *****
; For LLVM instruction:
;  %200 = load i32, i32* %i256, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %203 = load i32, i32* %i256, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %cmp263 = fcmp olt double %201, %204
; Looking for a replacement for:
%0:i1 = var
infer %0

; *****
; For LLVM instruction:
;  %206 = load i32, i32* %i256, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %209 = load i32, i32* %i256, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %210 = load i32, i32* %i256, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %inc270 = add i32 %210, 1
; Looking for a replacement for:
%0:i32 = var
%1:i32 = add 1:i32, %0
infer %1

; *****
; For LLVM instruction:
;  %211 = load i32, i32* %j, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %dec = add i32 %211, -1
; Looking for a replacement for:
%0:i32 = var
%1:i32 = add 4294967295:i32, %0
infer %1

; *****
; For LLVM instruction:
;  %214 = load i32, i32* %index274, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %215 = load i32, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %cmp276 = icmp ult i32 %214, %215
; Looking for a replacement for:
%0:i32 = var
%1:i32 = var
%2:i1 = ult %0, %1
infer %2

; *****
; For LLVM instruction:
;  %218 = load i32, i32* %index274, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %219 = load i32, i32* %arrayidx279, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %222 = load i32, i32* %index274, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %223 = load i32, i32* %index274, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %inc283 = add i32 %223, 1
; Looking for a replacement for:
%0:i32 = var
%1:i32 = add 1:i32, %0
infer %1

; *****
; For LLVM instruction:
;  %230 = load i32, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %cmp290 = icmp eq i32* %231, null
; Looking for a replacement for:
%0:i32 = var
%1:i1 = eq 0:i32, %0
infer %1

; *****
; For LLVM instruction:
;  %233 = load i32, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %234 = load i32, i32* %index296, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %235 = load i32, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %cmp298 = icmp ult i32 %234, %235
; Looking for a replacement for:
%0:i32 = var
%1:i32 = var
%2:i1 = ult %0, %1
infer %2

; *****
; For LLVM instruction:
;  %237 = load i32, i32* %index296, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %cmp302 = fcmp olt double %238, 0.000000e+00
; Looking for a replacement for:
%0:i1 = var
infer %0

; *****
; For LLVM instruction:
;  %240 = load i32, i32* %index296, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %cmp305 = fcmp ogt double %241, 1.000000e+00
; Looking for a replacement for:
%0:i1 = var
infer %0

; *****
; For LLVM instruction:
;  %242 = load i32, i32* %index296, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %244 = load i32, i32* %index296, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %246 = load i32, i32* %index296, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %inc313 = add i32 %246, 1
; Looking for a replacement for:
%0:i32 = var
%1:i32 = add 1:i32, %0
infer %1

; *****
; For LLVM instruction:
;  %248 = load i32, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %cmp317 = icmp eq i32* %249, null
; Looking for a replacement for:
%0:i32 = var
%1:i1 = eq 0:i32, %0
infer %1

; *****
; For LLVM instruction:
;  %252 = load i32, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %mul322 = mul i32 8, %252
; Looking for a replacement for:
%0:i32 = var
%1:i32 = mul 8:i32, %0
infer %1

; *****
; For LLVM instruction:
;  %254 = load i16, i16* %TYPE, align 2
; Looking for a replacement for:
%0:i16 = var
infer %0

; *****
; For LLVM instruction:
;  %conv324 = sext i16 %254 to i32
; Looking for a replacement for:
%0:i16 = var
%1:i32 = sext %0
infer %1

; *****
; For LLVM instruction:
;  %cmp325 = icmp eq i32 %conv324, 0
; Looking for a replacement for:
%0:i16 = var
%1:i32 = sext %0
%2:i1 = eq 0:i32, %1
infer %2

; *****
; For LLVM instruction:
;  %255 = load i32, i32* %index328, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %256 = load i32, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %cmp330 = icmp ult i32 %255, %256
; Looking for a replacement for:
%0:i32 = var
%1:i32 = var
%2:i1 = ult %0, %1
infer %2

; *****
; For LLVM instruction:
;  %257 = load i32, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %258 = load i32, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %259 = load i32, i32* %index328, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %sub334 = sub i32 %258, %259
; Looking for a replacement for:
%0:i32 = var
%1:i32 = var
%2:i32 = sub %0, %1
infer %2

; *****
; For LLVM instruction:
;  %263 = load i32, i32* %index328, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %264 = load i32, i32* %arrayidx337, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %267 = load i32, i32* %index328, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %268 = load i32, i32* %index328, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %inc342 = add i32 %268, 1
; Looking for a replacement for:
%0:i32 = var
%1:i32 = add 1:i32, %0
infer %1

; *****
; For LLVM instruction:
;  %269 = load i16, i16* %TYPE, align 2
; Looking for a replacement for:
%0:i16 = var
infer %0

; *****
; For LLVM instruction:
;  %conv345 = sext i16 %269 to i32
; Looking for a replacement for:
%0:i16 = var
%1:i32 = sext %0
infer %1

; *****
; For LLVM instruction:
;  %cmp346 = icmp eq i32 %conv345, 1
; Looking for a replacement for:
%0:i16 = var
%1:i32 = sext %0
%2:i1 = eq 1:i32, %1
infer %2

; *****
; For LLVM instruction:
;  %270 = load i32, i32* %index350, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %271 = load i32, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %add352 = add i32 1, %271
; Looking for a replacement for:
%0:i32 = var
%1:i32 = add 1:i32, %0
infer %1

; *****
; For LLVM instruction:
;  %cmp353 = icmp ult i32 %270, %add352
; Looking for a replacement for:
%0:i32 = var
%1:i32 = var
%2:i32 = add 1:i32, %1
%3:i1 = ult %0, %2
infer %3

; *****
; For LLVM instruction:
;  %272 = load i32, i32* %index350, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %274 = load i32, i32* %index350, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %inc360 = add i32 %274, 1
; Looking for a replacement for:
%0:i32 = var
%1:i32 = add 1:i32, %0
infer %1

; *****
; For LLVM instruction:
;  %275 = load i32, i32* %index362, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %276 = load i32, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %cmp364 = icmp ult i32 %275, %276
; Looking for a replacement for:
%0:i32 = var
%1:i32 = var
%2:i1 = ult %0, %1
infer %2

; *****
; For LLVM instruction:
;  %277 = load i32, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %278 = load i32, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %279 = load i32, i32* %index362, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %sub369 = sub i32 %278, %279
; Looking for a replacement for:
%0:i32 = var
%1:i32 = var
%2:i32 = sub %0, %1
infer %2

; *****
; For LLVM instruction:
;  %284 = load i32, i32* %index362, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %285 = load i32, i32* %arrayidx373, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %288 = load i32, i32* %index362, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %289 = load i32, i32* %index362, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %inc378 = add i32 %289, 1
; Looking for a replacement for:
%0:i32 = var
%1:i32 = add 1:i32, %0
infer %1

; *****
; For LLVM instruction:
;  %290 = load i16, i16* %TYPE, align 2
; Looking for a replacement for:
%0:i16 = var
infer %0

; *****
; For LLVM instruction:
;  %conv381 = sext i16 %290 to i32
; Looking for a replacement for:
%0:i16 = var
%1:i32 = sext %0
infer %1

; *****
; For LLVM instruction:
;  %cmp382 = icmp eq i32 %conv381, 3
; Looking for a replacement for:
%0:i16 = var
%1:i32 = sext %0
%2:i1 = eq 3:i32, %1
infer %2

; *****
; For LLVM instruction:
;  %291 = load i32, i32* %index385, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %292 = load i32, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %cmp387 = icmp ult i32 %291, %292
; Looking for a replacement for:
%0:i32 = var
%1:i32 = var
%2:i1 = ult %0, %1
infer %2

; *****
; For LLVM instruction:
;  %293 = load i32, i32* %index385, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %add390 = add i32 %293, 1
; Looking for a replacement for:
%0:i32 = var
%1:i32 = add 1:i32, %0
infer %1

; *****
; For LLVM instruction:
;  %296 = load i32, i32* %index385, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %297 = load i32, i32* %arrayidx392, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %300 = load i32, i32* %index385, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %301 = load i32, i32* %index385, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %inc397 = add i32 %301, 1
; Looking for a replacement for:
%0:i32 = var
%1:i32 = add 1:i32, %0
infer %1

; *****
; For LLVM instruction:
;  %305 = load i32, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %309 = load i32, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %312 = load i32, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %mul405 = mul i32 %312, 8
; Looking for a replacement for:
%0:i32 = var
%1:i32 = mul 8:i32, %0
infer %1

; *****
; For LLVM instruction:
;  %314 = load i32, i32* %index407, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %315 = load i32, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %cmp409 = icmp ult i32 %314, %315
; Looking for a replacement for:
%0:i32 = var
%1:i32 = var
%2:i1 = ult %0, %1
infer %2

; *****
; For LLVM instruction:
;  %318 = load i32, i32* %index407, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %319 = load i32, i32* %arrayidx412, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %322 = load i32, i32* %index407, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %323 = load i32, i32* %index407, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %inc416 = add i32 %323, 1
; Looking for a replacement for:
%0:i32 = var
%1:i32 = add 1:i32, %0
infer %1
got 1 candidates from LHS

-------------------------------------------------
%0:i16 = var
infer %0


--------------------------------
guess 0

%0:i16 = var ; reservedconst_1

Cost = 0
first query is SAT, returning the model:
reservedconst_1: 0
0 th attempt: second query is SAT-- constant doesn't work
first query is SAT, returning the model:
reservedconst_1: -1
1 th attempt: second query is SAT-- constant doesn't work
first query is UNSAT-- no more guesses
Dataflow Pruned 0/0
There are 1 Guesses
There are 0 RHSs before deduplication
There are 0 RHSs after deduplication
got 2 candidates from LHS

-------------------------------------------------
%0:i16 = var
%1:i32 = sext %0
infer %1


--------------------------------
guess 0

%0:i32 = var ; reservedconst_1

Cost = 0
first query is SAT, returning the model:
reservedconst_1: 0
0 th attempt: second query is SAT-- constant doesn't work
first query is SAT, returning the model:
reservedconst_1: -1
1 th attempt: second query is SAT-- constant doesn't work
first query is UNSAT-- no more guesses
Dataflow Pruned 0/0
There are 1 Guesses
There are 0 RHSs before deduplication
There are 0 RHSs after deduplication
got 3 candidates from LHS

-------------------------------------------------
%0:i16 = var
%1:i32 = sext %0
%2:i1 = eq 2:i32, %1
infer %2


--------------------------------
guess 0

%0:i1 = var ; reservedconst_1

Cost = 0
first query is SAT, returning the model:
reservedconst_1: 0
0 th attempt: second query is SAT-- constant doesn't work
first query is SAT, returning the model:
reservedconst_1: -1
1 th attempt: second query is SAT-- constant doesn't work
first query is UNSAT-- no more guesses
Dataflow Pruned 0/0
There are 1 Guesses
There are 0 RHSs before deduplication
There are 0 RHSs after deduplication
got 3 candidates from LHS

-------------------------------------------------
%0:i16 = var
%1:i32 = sext %0
%2:i1 = eq 4:i32, %1
infer %2


--------------------------------
guess 0

%0:i1 = var ; reservedconst_1

Cost = 0
first query is SAT, returning the model:
reservedconst_1: 0
0 th attempt: second query is SAT-- constant doesn't work
first query is SAT, returning the model:
reservedconst_1: -1
1 th attempt: second query is SAT-- constant doesn't work
first query is UNSAT-- no more guesses
Dataflow Pruned 0/0
There are 1 Guesses
There are 0 RHSs before deduplication
There are 0 RHSs after deduplication
got 3 candidates from LHS

-------------------------------------------------
%0:i16 = var
%1:i32 = sext %0
%2:i1 = eq 5:i32, %1
infer %2


--------------------------------
guess 0

%0:i1 = var ; reservedconst_1

Cost = 0
first query is SAT, returning the model:
reservedconst_1: 0
0 th attempt: second query is SAT-- constant doesn't work
first query is SAT, returning the model:
reservedconst_1: -1
1 th attempt: second query is SAT-- constant doesn't work
first query is UNSAT-- no more guesses
Dataflow Pruned 0/0
There are 1 Guesses
There are 0 RHSs before deduplication
There are 0 RHSs after deduplication
got 2 candidates from LHS

-------------------------------------------------
%0:i32 = var
%1:i32 = sub %0, 1:i32
infer %1


--------------------------------
guess 0

%0:i32 = var ; reservedconst_1

Cost = 0
first query is SAT, returning the model:
reservedconst_1: -1
0 th attempt: second query is SAT-- constant doesn't work
first query is SAT, returning the model:
reservedconst_1: -2
1 th attempt: second query is SAT-- constant doesn't work
first query is UNSAT-- no more guesses

--------------------------------
guess 1

%0:i32 = var

Cost = 0
second query is SAT-- constant doesn't work
Dataflow Pruned 0/0
There are 2 Guesses
There are 0 RHSs before deduplication
There are 0 RHSs after deduplication
got 2 candidates from LHS

-------------------------------------------------
%0:i32 = var
%1:i1 = ule 2:i32, %0
infer %1


--------------------------------
guess 0

%0:i1 = var ; reservedconst_1

Cost = 0
first query is SAT, returning the model:
reservedconst_1: 0
0 th attempt: second query is SAT-- constant doesn't work
first query is SAT, returning the model:
reservedconst_1: -1
1 th attempt: second query is SAT-- constant doesn't work
first query is UNSAT-- no more guesses
Dataflow Pruned 0/0
There are 1 Guesses
There are 0 RHSs before deduplication
There are 0 RHSs after deduplication
got 4 candidates from LHS

-------------------------------------------------
%0:i32 = var
%1:i32 = var
%2:i32 = sub %0, %1
%3:i32 = add 2:i32, %2
infer %3


--------------------------------
guess 0

%0:i32 = var ; reservedconst_1

Cost = 0
first query is SAT, returning the model:
reservedconst_1: 2
0 th attempt: second query is SAT-- constant doesn't work
first query is SAT, returning the model:
reservedconst_1: 1
1 th attempt: second query is SAT-- constant doesn't work
first query is UNSAT-- no more guesses

--------------------------------
guess 1

%0:i32 = var

Cost = 0
second query is SAT-- constant doesn't work

--------------------------------
guess 2

%0:i32 = var

Cost = 0
second query is SAT-- constant doesn't work

--------------------------------
guess 3

%0:i32 = var
%1:i32 = var
%2:i32 = sub %0, %1

Cost = 1
second query is SAT-- constant doesn't work
Dataflow Pruned 0/0
There are 4 Guesses
There are 0 RHSs before deduplication
There are 0 RHSs after deduplication
got 6 candidates from LHS

-------------------------------------------------
%0:i32 = var
%1:i32 = var
%2:i32 = var
%3:i32 = sub %1, %2
%4:i32 = add 2:i32, %3
%5:i32 = add %0, %4
infer %5


--------------------------------
guess 0

%0:i32 = var ; reservedconst_1

Cost = 0
first query is SAT, returning the model:
reservedconst_1: 2
0 th attempt: second query is SAT-- constant doesn't work
first query is SAT, returning the model:
reservedconst_1: 1
1 th attempt: second query is SAT-- constant doesn't work
first query is UNSAT-- no more guesses

--------------------------------
guess 1

%0:i32 = var

Cost = 0
second query is SAT-- constant doesn't work

--------------------------------
guess 2

%0:i32 = var

Cost = 0
second query is SAT-- constant doesn't work

--------------------------------
guess 3

%0:i32 = var

Cost = 0
second query is SAT-- constant doesn't work

--------------------------------
guess 4

%0:i32 = var
%1:i32 = var
%2:i32 = sub %0, %1

Cost = 1
second query is SAT-- constant doesn't work

--------------------------------
guess 5

%0:i32 = var
%1:i32 = var
%2:i32 = sub %0, %1
%3:i32 = add 2:i32, %2

Cost = 2
second query is SAT-- constant doesn't work
Dataflow Pruned 0/0
There are 6 Guesses
There are 0 RHSs before deduplication
There are 0 RHSs after deduplication
got 7 candidates from LHS

-------------------------------------------------
%0:i32 = var
%1:i32 = var
%2:i32 = var
%3:i32 = sub %1, %2
%4:i32 = add 2:i32, %3
%5:i32 = add %0, %4
%6:i32 = sub %5, 1:i32
infer %6


--------------------------------
guess 0

%0:i32 = var ; reservedconst_1

Cost = 0
first query is SAT, returning the model:
reservedconst_1: 1
0 th attempt: second query is SAT-- constant doesn't work
first query is SAT, returning the model:
reservedconst_1: 0
1 th attempt: second query is SAT-- constant doesn't work
first query is UNSAT-- no more guesses

--------------------------------
guess 1

%0:i32 = var

Cost = 0
second query is SAT-- constant doesn't work

--------------------------------
guess 2

%0:i32 = var

Cost = 0
second query is SAT-- constant doesn't work

--------------------------------
guess 3

%0:i32 = var

Cost = 0
second query is SAT-- constant doesn't work

--------------------------------
guess 4

%0:i32 = var
%1:i32 = var
%2:i32 = sub %0, %1

Cost = 1
second query is SAT-- constant doesn't work

--------------------------------
guess 5

%0:i32 = var
%1:i32 = var
%2:i32 = sub %0, %1
%3:i32 = add 2:i32, %2

Cost = 2
second query is SAT-- constant doesn't work

--------------------------------
guess 6

%0:i32 = var
%1:i32 = var
%2:i32 = var
%3:i32 = sub %1, %2
%4:i32 = add 2:i32, %3
%5:i32 = add %0, %4

Cost = 3
second query is SAT-- constant doesn't work
Dataflow Pruned 0/0
There are 7 Guesses
There are 0 RHSs before deduplication
There are 0 RHSs after deduplication
got 2 candidates from LHS

-------------------------------------------------
%0:i32 = var
%1:i32 = add 2:i32, %0
infer %1


--------------------------------
guess 0

%0:i32 = var ; reservedconst_1

Cost = 0
first query is SAT, returning the model:
reservedconst_1: 2
0 th attempt: second query is SAT-- constant doesn't work
first query is SAT, returning the model:
reservedconst_1: 1
1 th attempt: second query is SAT-- constant doesn't work
first query is UNSAT-- no more guesses

--------------------------------
guess 1

%0:i32 = var

Cost = 0
second query is SAT-- constant doesn't work
Dataflow Pruned 0/0
There are 2 Guesses
There are 0 RHSs before deduplication
There are 0 RHSs after deduplication
got 4 candidates from LHS

-------------------------------------------------
%0:i32 = var
%1:i32 = var
%2:i32 = sub %0, %1
%3:i32 = add 1:i32, %2
infer %3


--------------------------------
guess 0

%0:i32 = var ; reservedconst_1

Cost = 0
first query is SAT, returning the model:
reservedconst_1: 1
0 th attempt: second query is SAT-- constant doesn't work
first query is SAT, returning the model:
reservedconst_1: 0
1 th attempt: second query is SAT-- constant doesn't work
first query is UNSAT-- no more guesses

--------------------------------
guess 1

%0:i32 = var

Cost = 0
second query is SAT-- constant doesn't work

--------------------------------
guess 2

%0:i32 = var

Cost = 0
second query is SAT-- constant doesn't work

--------------------------------
guess 3

%0:i32 = var
%1:i32 = var
%2:i32 = sub %0, %1

Cost = 1
second query is SAT-- constant doesn't work
Dataflow Pruned 0/0
There are 4 Guesses
There are 0 RHSs before deduplication
There are 0 RHSs after deduplication
got 6 candidates from LHS

-------------------------------------------------
%0:i32 = var
%1:i32 = var
%2:i32 = var
%3:i32 = sub %1, %2
%4:i32 = add 1:i32, %3
%5:i1 = ult %0, %4
infer %5


--------------------------------
guess 0

%0:i1 = var ; reservedconst_1

Cost = 0
first query is SAT, returning the model:
reservedconst_1: -1
0 th attempt: second query is SAT-- constant doesn't work
first query is SAT, returning the model:
reservedconst_1: 0
1 th attempt: second query is SAT-- constant doesn't work
first query is UNSAT-- no more guesses
Dataflow Pruned 0/0
There are 1 Guesses
There are 0 RHSs before deduplication
There are 0 RHSs after deduplication
got 2 candidates from LHS

-------------------------------------------------
%0:i32 = var
%1:i32 = add 4294967295:i32, %0
infer %1


--------------------------------
guess 0

%0:i32 = var ; reservedconst_1

Cost = 0
first query is SAT, returning the model:
reservedconst_1: -1
0 th attempt: second query is SAT-- constant doesn't work
first query is SAT, returning the model:
reservedconst_1: -2
1 th attempt: second query is SAT-- constant doesn't work
first query is UNSAT-- no more guesses

--------------------------------
guess 1

%0:i32 = var

Cost = 0
second query is SAT-- constant doesn't work
Dataflow Pruned 0/0
There are 2 Guesses
There are 0 RHSs before deduplication
There are 0 RHSs after deduplication
got 3 candidates from LHS

-------------------------------------------------
%0:i16 = var
%1:i32 = sext %0
%2:i1 = eq 0:i32, %1
infer %2


--------------------------------
guess 0

%0:i1 = var ; reservedconst_1

Cost = 0
first query is SAT, returning the model:
reservedconst_1: -1
0 th attempt: second query is SAT-- constant doesn't work
first query is SAT, returning the model:
reservedconst_1: 0
1 th attempt: second query is SAT-- constant doesn't work
first query is UNSAT-- no more guesses
Dataflow Pruned 0/0
There are 1 Guesses
There are 0 RHSs before deduplication
There are 0 RHSs after deduplication
got 3 candidates from LHS

-------------------------------------------------
%0:i16 = var
%1:i32 = sext %0
%2:i1 = eq 1:i32, %1
infer %2


--------------------------------
guess 0

%0:i1 = var ; reservedconst_1

Cost = 0
first query is SAT, returning the model:
reservedconst_1: 0
0 th attempt: second query is SAT-- constant doesn't work
first query is SAT, returning the model:
reservedconst_1: -1
1 th attempt: second query is SAT-- constant doesn't work
first query is UNSAT-- no more guesses
Dataflow Pruned 0/0
There are 1 Guesses
There are 0 RHSs before deduplication
There are 0 RHSs after deduplication
got 4 candidates from LHS

-------------------------------------------------
%0:i32 = var
%1:i32 = var
%2:i32 = add 1:i32, %1
%3:i1 = ult %0, %2
infer %3


--------------------------------
guess 0

%0:i1 = var ; reservedconst_1

Cost = 0
first query is SAT, returning the model:
reservedconst_1: -1
0 th attempt: second query is SAT-- constant doesn't work
first query is SAT, returning the model:
reservedconst_1: 0
1 th attempt: second query is SAT-- constant doesn't work
first query is UNSAT-- no more guesses
Dataflow Pruned 0/0
There are 1 Guesses
There are 0 RHSs before deduplication
There are 0 RHSs after deduplication
got 3 candidates from LHS

-------------------------------------------------
%0:i16 = var
%1:i32 = sext %0
%2:i1 = eq 3:i32, %1
infer %2


--------------------------------
guess 0

%0:i1 = var ; reservedconst_1

Cost = 0
first query is SAT, returning the model:
reservedconst_1: 0
0 th attempt: second query is SAT-- constant doesn't work
first query is SAT, returning the model:
reservedconst_1: -1
1 th attempt: second query is SAT-- constant doesn't work
first query is UNSAT-- no more guesses
Dataflow Pruned 0/0
There are 1 Guesses
There are 0 RHSs before deduplication
There are 0 RHSs after deduplication
#########################################################
; exiting Souper's runOnFunction() for p_adjust()

; entering Souper's runOnFunction() for main()

; ModuleID = './P-value_correction.c.bc'
source_filename = "./P-value_correction.c"
target datalayout = "e-m:e-p:32:32-i64:64-n32:64-S128"
target triple = "wasm32-unknown-wasi"

@.str = private unnamed_addr constant [29 x i8] c"malloc failed at %s line %u\0A\00", align 1
@.str.1 = private unnamed_addr constant [23 x i8] c"./P-value_correction.c\00", align 1
@.str.2 = private unnamed_addr constant [1 x i8] zeroinitializer, align 1
@base_arr = hidden global double* null, align 4
@.str.3 = private unnamed_addr constant [33 x i8] c"failed to malloc at %s line %u.\0A\00", align 1
@.str.4 = private unnamed_addr constant [48 x i8] c"cummin function requires at least one element.\0A\00", align 1
@.str.5 = private unnamed_addr constant [22 x i8] c"Failed at %s line %u\0A\00", align 1
@.str.6 = private unnamed_addr constant [41 x i8] c"function requires at least one element.\0A\00", align 1
@.str.7 = private unnamed_addr constant [37 x i8] c"pmin requires at least one element.\0A\00", align 1
@.str.8 = private unnamed_addr constant [7 x i8] c"[1] %e\00", align 1
@.str.9 = private unnamed_addr constant [7 x i8] c" %.10f\00", align 1
@.str.10 = private unnamed_addr constant [6 x i8] c"\0A[%u]\00", align 1
@.str.11 = private unnamed_addr constant [2 x i8] c"\0A\00", align 1
@.str.12 = private unnamed_addr constant [34 x i8] c"Failure to malloc at %s line %u.\0A\00", align 1
@.str.13 = private unnamed_addr constant [41 x i8] c"p_adjust requires at least one element.\0A\00", align 1
@.str.14 = private unnamed_addr constant [3 x i8] c"BH\00", align 1
@.str.15 = private unnamed_addr constant [4 x i8] c"fdr\00", align 1
@.str.16 = private unnamed_addr constant [3 x i8] c"by\00", align 1
@.str.17 = private unnamed_addr constant [11 x i8] c"Bonferroni\00", align 1
@.str.18 = private unnamed_addr constant [9 x i8] c"hochberg\00", align 1
@.str.19 = private unnamed_addr constant [5 x i8] c"holm\00", align 1
@.str.20 = private unnamed_addr constant [7 x i8] c"hommel\00", align 1
@.str.21 = private unnamed_addr constant [44 x i8] c"%s doesn't match any accepted FDR methods.\0A\00", align 1
@.str.22 = private unnamed_addr constant [42 x i8] c"%g is outside of the interval I planned.\0A\00", align 1
@.str.23 = private unnamed_addr constant [23 x i8] c"Failure at %s line %u\0A\00", align 1
@.str.24 = private unnamed_addr constant [54 x i8] c"array[%u] = %lf, which is outside the interval [0,1]\0A\00", align 1
@.str.25 = private unnamed_addr constant [20 x i8] c"died at %s line %u\0A\00", align 1
@__const.main.PVALUES = private unnamed_addr constant [50 x double] [double 0x3FDD04160F35FDE9, double 0x3FE758E721E2A8D7, double 0x3FB96FAC8B38D8BA, double 0x3FB73E71D5B04B37, double 0x3FC710AB48EE865B, double 0x3FEC01D953C3CC73, double 0x3FD2B3C4BE0A922A, double 0x3FED2B5A568DAB4F, double 0x3FDBE08D73F16964, double 0x3FE10A218C41C242, double 0x3FDF8810DB1996AA, double 0x3FE291CCB11E1A9D, double 0x3FD64E8C550D788F, double 7.883130e-01, double 0x3FD177B2BF048D2D, double 0x3FEB3543434BAF2B, double 0x3FDB50EAD41ED0A6, double 0x3FE49D4AFF01D33F, double 0x3FD364C9AE345B51, double 0x3FA99BA35F15394D, double 3.194810e-01, double 0x3FE941E405CE761A, double 0x3FEFF94F77369843, double 0x3FC65847BFB23217, double 0x3FECEB8879B6A543, double 0x3FBEAF00332BA677, double 0x3FD96207C7749E38, double 0x3F8CC02620502C93, double 0x3FE773A5B45A0F40, double 0x3FB1642C24762C01, double 4.040730e-03, double 0x3F33E11D79A90777, double 0x3F870B02BD749528, double 0x3F98521BD6A0353F, double 0x3F4310F26148FFAA, double 0x3F3427CD76006778, double 0x3F80E60AFB1F8A4E, double 0x3F5639B74A9E4DA2, double 0x3F8BDDF74195769F, double 0x3F38ABEE3BFA8581, double 0x3EF2E2E96B5466FE, double 0x3E90CE9F65B58A88, double 0x3FA0F2D097879B95, double 0x3F834EE7216A6684, double 0x3F4CCE8DBB40BD9D, double 0x3F2C8B969590F2ED, double 0x3F4FC31F7F1541AD, double 6.610250e-05, double 0x3F9DB44EA6AC26BA, double 5.735490e-03], align 16
@__const.main.CORRECT_ANSWERS = private unnamed_addr constant [6 x [50 x double]] [[50 x double] [double 0x3FE39AFA2199ADBC, double 8.521710e-01, double 0x3FC96FAC6045BAF5, double 0x3FC83660E51D25AB, double 0x3FD498068702BE20, double 0x3FEDC3BF727136A4, double 4.870370e-01, double 0x3FEDC3BF727136A4, double 0x3FE35BF08BEEB62C, double 0x3FE5D879DEE92F03, double 0x3FE4BE91D656B94A, double 0x3FE7363FC28DAEAA, double 0x3FE0E62C4F13638A, double 0x3FEC1052C8FAB035, double 0x3FDE1DD2E43E029A, double 0x3FED92EFFC7CBDC1, double 0x3FE35BF08BEEB62C, double 0x3FE923B90CFC67C5, double 0x3FDF47B8FC357024, double 0x3FBD1996A9FB10AD, double 0x3FDFF2B6D6C14255, double 0x3FEC1052C8FAB035, double 0x3FEFF94F77369843, double 0x3FD498068702BE20, double 0x3FEDC3BF727136A4, double 0x3FCD80E2E96EC403, double 0x3FE2A9F6A93F290B, double 0x3FA3F736D8AF2E2B, double 8.521710e-01, double 0x3FC2E751B350FAC4, double 0x3F913D8E55EE9F05, double 0x3F64FECB88BB3633, double 0x3FA2009A03CCBE34, double 0x3FB0001FB57CF9FC, double 0x3F6DCA7ADA5E274A, double 0x3F64FECB88BB3633, double 0x3F9E2D13B467D120, double 0x3F7941963399C6A1, double 0x3FA3F736D8AF2E2B, double 0x3F6607390CEF853C, double 0x3F3D828C80BA213A, double 0x3EEA42D90EEBA875, double 0x3FB42D4181AA8F8B, double 0x3FA01715F12E0018, double 0x3F73D9F3AF6D490C, double 0x3F64FECB88BB3633, double 0x3F73D9F3AF6D490C, double 0x3F520CE5F51A7C61, double 0x3FB290B112B20952, double 0x3F9696C95AA76B69], [50 x double] [double 1.000000e+00, double 1.000000e+00, double 0x3FEC9C56E33BA41B, double 0x3FEB3BF21E95ED3D, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 0x3FE05DA74553C727, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 0x3FC675198790829A, double 1.000000e+00, double 0x3FE54345648E1F12, double 0x3FB3645F501CA2F9, double 0x3F879D934E50F0DE, double 0x3FC43FC3646E3EA2, double 0x3FD1FF539D36064C, double 0x3F90C123206B855F, double 0x3F879D934E50F0DE, double 0x3FC0F8967F32E606, double 0x3F9C6880470D2FBE, double 0x3FC675198790829A, double 0x3F88C70105E47082, double 2.025930e-03, double 0x3F0D89DE4FA8F818, double 0x3FD6B1E2D11B1027, double 0x3FC219271872BD8D, double 0x3F96542FAD16CEF9, double 0x3F879D934E50F0DE, double 0x3F96542FAD16CEF9, double 0x3F744D9816EB319A, double 0x3FD4E1D5728DBC16, double 0x3FB9687C40426555], [50 x double] [double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 0x3FE6761DC93EA2D3, double 1.000000e+00, double 1.000000e+00, double 0x3FC9DC55000C953A, double 0x3F8F0FBD624BA499, double 0x3FE2009A24031487, double 1.000000e+00, double 0x3F9DCA7AB8020F7A, double 0x3F8F7E310860A1AB, double 0x3FDA677128614819, double 6.782670e-02, double 6.803480e-01, double 0x3F9346521EDBB84D, double 0x3F4D828CB7B3E0EE, double 0x3EEA42D90EEBA875, double 1.000000e+00, double 4.713920e-01, double 0x3FA6815EE53DB1E7, double 0x3F864D0CF90CC6B8, double 0x3FA8D0709B489B4F, double 0x3F6B1359791819D2, double 1.000000e+00, double 0x3FD25A836EB4E981], [50 x double] [double 0x3FEFF94F77369843, double 0x3FEFF94F77369843, double 0x3FEFF94F77369843, double 0x3FEFF94F77369843, double 0x3FEFF94F77369843, double 0x3FEFF94F77369843, double 0x3FEFF94F77369843, double 0x3FEFF94F77369843, double 0x3FEFF94F77369843, double 0x3FEFF94F77369843, double 0x3FEFF94F77369843, double 0x3FEFF94F77369843, double 0x3FEFF94F77369843, double 0x3FEFF94F77369843, double 0x3FEFF94F77369843, double 0x3FEFF94F77369843, double 0x3FEFF94F77369843, double 0x3FEFF94F77369843, double 0x3FEFF94F77369843, double 0x3FEFF94F77369843, double 0x3FEFF94F77369843, double 0x3FEFF94F77369843, double 0x3FEFF94F77369843, double 0x3FEFF94F77369843, double 0x3FEFF94F77369843, double 0x3FEFF94F77369843, double 0x3FEFF94F77369843, double 0x3FDDA6274695E687, double 0x3FEFF94F77369843, double 0x3FEFF94F77369843, double 0x3FC42BDC26DCE39B, double 0x3F8C57F9104CA951, double 0x3FD9340AC9879DEF, double 7.600230e-01, double 0x3F999EC5A86B439B, double 0x3F8C57F9104CA951, double 0x3FD389FCD90412B4, double 0x3FABC8251D45E10B, double 0x3FDD9BD68ABBB045, double 0x3F90F633F956C386, double 8.825610e-04, double 0x3EEA42D90EEBA875, double 0x3FEFC7471C1E43B8, double 0x3FD5B8C4014C305A, double 0x3FA2E78CEC8D068E, double 0x3F84F6832995A599, double 0x3FA459002162FC24, double 3.172920e-03, double 8.992520e-01, double 0x3FCBE5BD5E9AC00A], [50 x double] [double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 0x3FDDA6274695E687, double 1.000000e+00, double 1.000000e+00, double 0x3FC42BDC26DCE39B, double 0x3F8C939AFCF101E0, double 0x3FD9340AC9879DEF, double 7.600230e-01, double 0x3F999EC5A86B439B, double 0x3F8C939AFCF101E0, double 0x3FD389FCD90412B4, double 0x3FABC8251D45E10B, double 0x3FDD9BD68ABBB045, double 0x3F90F633F956C386, double 8.825610e-04, double 0x3EEA42D90EEBA875, double 0x3FEFC7471C1E43B8, double 0x3FD5B8C4014C305A, double 0x3FA2E78CEC8D068E, double 0x3F84F6832995A599, double 0x3FA459002162FC24, double 3.172920e-03, double 8.992520e-01, double 0x3FCBE5BD5E9AC00A], [50 x double] [double 0x3FEFF94F77369843, double 0x3FEFF94F77369843, double 0x3FEFF94F77369843, double 0x3FEFF5DC908F2EDD, double 0x3FEFF94F77369843, double 0x3FEFF94F77369843, double 0x3FEFF94F77369843, double 0x3FEFF94F77369843, double 0x3FEFF94F77369843, double 0x3FEFF94F77369843, double 0x3FEFF94F77369843, double 0x3FEFF94F77369843, double 0x3FEFF94F77369843, double 0x3FEFF94F77369843, double 0x3FEFF94F77369843, double 0x3FEFF94F77369843, double 0x3FEFF94F77369843, double 0x3FEFF94F77369843, double 0x3FEFF94F77369843, double 0x3FEEB45F17BD8BE7, double 0x3FEFF94F77369843, double 0x3FEFF94F77369843, double 0x3FEFF94F77369843, double 0x3FEFF94F77369843, double 0x3FEFF94F77369843, double 0x3FEFF94F77369843, double 0x3FEFF94F77369843, double 0x3FDBDA250F840182, double 0x3FEFF94F77369843, double 0x3FEF40BC1D52205E, double 0x3FC21A3BEB689947, double 1.304340e-02, double 0x3FD69916517B1CD7, double 0x3FE60A69453DF7B2, double 0x3F986DB666D9D3C6, double 0x3F8B157BBD3AB385, double 2.722920e-01, double 0x3FABC8251D45E10B, double 0x3FDAFF07B27BE8AF, double 0x3F9030D45E3B9F93, double 8.825610e-04, double 0x3EEA42D90EEBA875, double 0x3FEBFACC1948A662, double 0x3FD34EE6EDE042CB, double 0x3FA2011883DA6A9A, double 0x3F839FF779153716, double 0x3FA3D9F3D1C960DD, double 3.172920e-03, double 0x3FE9FDC4BC5D1301, double 0x3FC8F5FAC3801CF1]], align 16
@.str.26 = private unnamed_addr constant [3 x i8] c"bh\00", align 1
@.str.27 = private unnamed_addr constant [11 x i8] c"bonferroni\00", align 1
@__const.main.TYPES = private unnamed_addr constant [6 x i8*] [i8* getelementptr inbounds ([3 x i8], [3 x i8]* @.str.26, i32 0, i32 0), i8* getelementptr inbounds ([3 x i8], [3 x i8]* @.str.16, i32 0, i32 0), i8* getelementptr inbounds ([11 x i8], [11 x i8]* @.str.27, i32 0, i32 0), i8* getelementptr inbounds ([9 x i8], [9 x i8]* @.str.18, i32 0, i32 0), i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.19, i32 0, i32 0), i8* getelementptr inbounds ([7 x i8], [7 x i8]* @.str.20, i32 0, i32 0)], align 16
@.str.28 = private unnamed_addr constant [44 x i8] c"\0Atype %u = '%s' has cumulative error of %g\0A\00", align 1
@llvm.used = appending global [1 x i8*] [i8* bitcast (i32 ()* @__main_void to i8*)], section "llvm.metadata"

@__main_void = alias i32 (), i32 ()* @main

; Function Attrs: noinline nounwind optnone
define hidden i32* @seq_len(i32 %START, i32 %END) #0 {
entry:
  %retval = alloca i32*, align 4
  %START.addr = alloca i32, align 4
  %END.addr = alloca i32, align 4
  %start = alloca i32, align 4
  %end = alloca i32, align 4
  %sequence = alloca i32*, align 4
  %i = alloca i32, align 4
  %LENGTH = alloca i32, align 4
  %sequence10 = alloca i32*, align 4
  %index = alloca i32, align 4
  %index28 = alloca i32, align 4
  store i32 %START, i32* %START.addr, align 4
  store i32 %END, i32* %END.addr, align 4
  %0 = load i32, i32* %START.addr, align 4
  store i32 %0, i32* %start, align 4
  %1 = load i32, i32* %END.addr, align 4
  store i32 %1, i32* %end, align 4
  %2 = load i32, i32* %START.addr, align 4
  %3 = load i32, i32* %END.addr, align 4
  %cmp = icmp eq i32 %2, %3
  br i1 %cmp, label %if.then, label %if.end6

if.then:                                          ; preds = %entry
  %4 = load i32, i32* %end, align 4
  %add = add i32 %4, 1
  %mul = mul i32 %add, 4
  %call = call noalias i8* @malloc(i32 %mul)
  %5 = bitcast i8* %call to i32*
  store i32* %5, i32** %sequence, align 4
  %6 = load i32*, i32** %sequence, align 4
  %cmp1 = icmp eq i32* %6, null
  br i1 %cmp1, label %if.then2, label %if.end

if.then2:                                         ; preds = %if.then
  %call3 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([29 x i8], [29 x i8]* @.str, i32 0, i32 0), i8* getelementptr inbounds ([23 x i8], [23 x i8]* @.str.1, i32 0, i32 0), i32 15)
  call void @perror(i8* getelementptr inbounds ([1 x i8], [1 x i8]* @.str.2, i32 0, i32 0))
  call void @exit(i32 1) #5
  unreachable

if.end:                                           ; preds = %if.then
  store i32 0, i32* %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.end
  %7 = load i32, i32* %i, align 4
  %8 = load i32, i32* %end, align 4
  %cmp4 = icmp ult i32 %7, %8
  br i1 %cmp4, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %9 = load i32, i32* %i, align 4
  %add5 = add i32 %9, 1
  %10 = load i32*, i32** %sequence, align 4
  %11 = load i32, i32* %i, align 4
  %arrayidx = getelementptr inbounds i32, i32* %10, i32 %11
  store i32 %add5, i32* %arrayidx, align 4
  br label %for.inc

for.inc:                                          ; preds = %for.body
  %12 = load i32, i32* %i, align 4
  %inc = add i32 %12, 1
  store i32 %inc, i32* %i, align 4
  br label %for.cond

for.end:                                          ; preds = %for.cond
  %13 = load i32*, i32** %sequence, align 4
  store i32* %13, i32** %retval, align 4
  br label %return

if.end6:                                          ; preds = %entry
  %14 = load i32, i32* %START.addr, align 4
  %15 = load i32, i32* %END.addr, align 4
  %cmp7 = icmp ugt i32 %14, %15
  br i1 %cmp7, label %if.then8, label %if.end9

if.then8:                                         ; preds = %if.end6
  %16 = load i32, i32* %START.addr, align 4
  store i32 %16, i32* %end, align 4
  %17 = load i32, i32* %END.addr, align 4
  store i32 %17, i32* %start, align 4
  br label %if.end9

if.end9:                                          ; preds = %if.then8, %if.end6
  %18 = load i32, i32* %end, align 4
  %19 = load i32, i32* %start, align 4
  %sub = sub i32 %18, %19
  store i32 %sub, i32* %LENGTH, align 4
  %20 = load i32, i32* %LENGTH, align 4
  %add11 = add i32 1, %20
  %mul12 = mul i32 %add11, 4
  %call13 = call noalias i8* @malloc(i32 %mul12)
  %21 = bitcast i8* %call13 to i32*
  store i32* %21, i32** %sequence10, align 4
  %22 = load i32*, i32** %sequence10, align 4
  %cmp14 = icmp eq i32* %22, null
  br i1 %cmp14, label %if.then15, label %if.end17

if.then15:                                        ; preds = %if.end9
  %call16 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([29 x i8], [29 x i8]* @.str, i32 0, i32 0), i8* getelementptr inbounds ([23 x i8], [23 x i8]* @.str.1, i32 0, i32 0), i32 31)
  call void @perror(i8* getelementptr inbounds ([1 x i8], [1 x i8]* @.str.2, i32 0, i32 0))
  call void @exit(i32 1) #5
  unreachable

if.end17:                                         ; preds = %if.end9
  %23 = load i32, i32* %START.addr, align 4
  %24 = load i32, i32* %END.addr, align 4
  %cmp18 = icmp ult i32 %23, %24
  br i1 %cmp18, label %if.then19, label %if.else

if.then19:                                        ; preds = %if.end17
  store i32 0, i32* %index, align 4
  br label %for.cond20

for.cond20:                                       ; preds = %for.inc25, %if.then19
  %25 = load i32, i32* %index, align 4
  %26 = load i32, i32* %LENGTH, align 4
  %cmp21 = icmp ule i32 %25, %26
  br i1 %cmp21, label %for.body22, label %for.end27

for.body22:                                       ; preds = %for.cond20
  %27 = load i32, i32* %start, align 4
  %28 = load i32, i32* %index, align 4
  %add23 = add i32 %27, %28
  %29 = load i32*, i32** %sequence10, align 4
  %30 = load i32, i32* %index, align 4
  %arrayidx24 = getelementptr inbounds i32, i32* %29, i32 %30
  store i32 %add23, i32* %arrayidx24, align 4
  br label %for.inc25

for.inc25:                                        ; preds = %for.body22
  %31 = load i32, i32* %index, align 4
  %inc26 = add i32 %31, 1
  store i32 %inc26, i32* %index, align 4
  br label %for.cond20

for.end27:                                        ; preds = %for.cond20
  br label %if.end37

if.else:                                          ; preds = %if.end17
  store i32 0, i32* %index28, align 4
  br label %for.cond29

for.cond29:                                       ; preds = %for.inc34, %if.else
  %32 = load i32, i32* %index28, align 4
  %33 = load i32, i32* %LENGTH, align 4
  %cmp30 = icmp ule i32 %32, %33
  br i1 %cmp30, label %for.body31, label %for.end36

for.body31:                                       ; preds = %for.cond29
  %34 = load i32, i32* %end, align 4
  %35 = load i32, i32* %index28, align 4
  %sub32 = sub i32 %34, %35
  %36 = load i32*, i32** %sequence10, align 4
  %37 = load i32, i32* %index28, align 4
  %arrayidx33 = getelementptr inbounds i32, i32* %36, i32 %37
  store i32 %sub32, i32* %arrayidx33, align 4
  br label %for.inc34

for.inc34:                                        ; preds = %for.body31
  %38 = load i32, i32* %index28, align 4
  %inc35 = add i32 %38, 1
  store i32 %inc35, i32* %index28, align 4
  br label %for.cond29

for.end36:                                        ; preds = %for.cond29
  br label %if.end37

if.end37:                                         ; preds = %for.end36, %for.end27
  %39 = load i32*, i32** %sequence10, align 4
  store i32* %39, i32** %retval, align 4
  br label %return

return:                                           ; preds = %if.end37, %for.end
  %40 = load i32*, i32** %retval, align 4
  ret i32* %40
}

declare noalias i8* @malloc(i32 %0) #1

declare i32 @printf(i8* %0, ...) #1

declare void @perror(i8* %0) #1

; Function Attrs: noreturn
declare void @exit(i32 %0) #2

; Function Attrs: noinline nounwind optnone
define hidden i32* @order(double* noalias %ARRAY, i32 %SIZE, i1 zeroext %DECREASING) #0 {
entry:
  %ARRAY.addr = alloca double*, align 4
  %SIZE.addr = alloca i32, align 4
  %DECREASING.addr = alloca i8, align 1
  %idx = alloca i32*, align 4
  %i = alloca i32, align 4
  store double* %ARRAY, double** %ARRAY.addr, align 4
  store i32 %SIZE, i32* %SIZE.addr, align 4
  %frombool = zext i1 %DECREASING to i8
  store i8 %frombool, i8* %DECREASING.addr, align 1
  %0 = load i32, i32* %SIZE.addr, align 4
  %mul = mul i32 %0, 4
  %call = call noalias i8* @malloc(i32 %mul)
  %1 = bitcast i8* %call to i32*
  store i32* %1, i32** %idx, align 4
  %2 = load i32*, i32** %idx, align 4
  %cmp = icmp eq i32* %2, null
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %call1 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([33 x i8], [33 x i8]* @.str.3, i32 0, i32 0), i8* getelementptr inbounds ([23 x i8], [23 x i8]* @.str.1, i32 0, i32 0), i32 77)
  call void @perror(i8* getelementptr inbounds ([1 x i8], [1 x i8]* @.str.2, i32 0, i32 0))
  call void @exit(i32 1) #5
  unreachable

if.end:                                           ; preds = %entry
  %3 = load i32, i32* %SIZE.addr, align 4
  %mul2 = mul i32 8, %3
  %call3 = call noalias i8* @malloc(i32 %mul2)
  %4 = bitcast i8* %call3 to double*
  store double* %4, double** @base_arr, align 4
  %5 = load double*, double** @base_arr, align 4
  %cmp4 = icmp eq double* %5, null
  br i1 %cmp4, label %if.then5, label %if.end7

if.then5:                                         ; preds = %if.end
  %call6 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([33 x i8], [33 x i8]* @.str.3, i32 0, i32 0), i8* getelementptr inbounds ([23 x i8], [23 x i8]* @.str.1, i32 0, i32 0), i32 83)
  call void @perror(i8* getelementptr inbounds ([1 x i8], [1 x i8]* @.str.2, i32 0, i32 0))
  call void @exit(i32 1) #5
  unreachable

if.end7:                                          ; preds = %if.end
  store i32 0, i32* %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.end7
  %6 = load i32, i32* %i, align 4
  %7 = load i32, i32* %SIZE.addr, align 4
  %cmp8 = icmp ult i32 %6, %7
  br i1 %cmp8, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %8 = load double*, double** %ARRAY.addr, align 4
  %9 = load i32, i32* %i, align 4
  %arrayidx = getelementptr inbounds double, double* %8, i32 %9
  %10 = load double, double* %arrayidx, align 8
  %11 = load double*, double** @base_arr, align 4
  %12 = load i32, i32* %i, align 4
  %arrayidx9 = getelementptr inbounds double, double* %11, i32 %12
  store double %10, double* %arrayidx9, align 8
  %13 = load i32, i32* %i, align 4
  %14 = load i32*, i32** %idx, align 4
  %15 = load i32, i32* %i, align 4
  %arrayidx10 = getelementptr inbounds i32, i32* %14, i32 %15
  store i32 %13, i32* %arrayidx10, align 4
  br label %for.inc

for.inc:                                          ; preds = %for.body
  %16 = load i32, i32* %i, align 4
  %inc = add i32 %16, 1
  store i32 %inc, i32* %i, align 4
  br label %for.cond

for.end:                                          ; preds = %for.cond
  %17 = load i8, i8* %DECREASING.addr, align 1
  %tobool = trunc i8 %17 to i1
  %conv = zext i1 %tobool to i32
  %cmp11 = icmp eq i32 %conv, 0
  br i1 %cmp11, label %if.then13, label %if.else

if.then13:                                        ; preds = %for.end
  %18 = load i32*, i32** %idx, align 4
  %19 = bitcast i32* %18 to i8*
  %20 = load i32, i32* %SIZE.addr, align 4
  call void @qsort(i8* %19, i32 %20, i32 4, i32 (i8*, i8*)* @compar_decrease)
  br label %if.end20

if.else:                                          ; preds = %for.end
  %21 = load i8, i8* %DECREASING.addr, align 1
  %tobool14 = trunc i8 %21 to i1
  br i1 %tobool14, label %if.then18, label %if.end19

if.then18:                                        ; preds = %if.else
  %22 = load i32*, i32** %idx, align 4
  %23 = bitcast i32* %22 to i8*
  %24 = load i32, i32* %SIZE.addr, align 4
  call void @qsort(i8* %23, i32 %24, i32 4, i32 (i8*, i8*)* @compar_increase)
  br label %if.end19

if.end19:                                         ; preds = %if.then18, %if.else
  br label %if.end20

if.end20:                                         ; preds = %if.end19, %if.then13
  %25 = load double*, double** @base_arr, align 4
  %26 = bitcast double* %25 to i8*
  call void @free(i8* %26)
  store double* null, double** @base_arr, align 4
  %27 = load i32*, i32** %idx, align 4
  ret i32* %27
}

declare void @qsort(i8* %0, i32 %1, i32 %2, i32 (i8*, i8*)* %3) #1

; Function Attrs: noinline nounwind optnone
define internal i32 @compar_decrease(i8* noalias %a, i8* noalias %b) #0 {
entry:
  %retval = alloca i32, align 4
  %a.addr = alloca i8*, align 4
  %b.addr = alloca i8*, align 4
  %aa = alloca i32, align 4
  %bb = alloca i32, align 4
  store i8* %a, i8** %a.addr, align 4
  store i8* %b, i8** %b.addr, align 4
  %0 = load i8*, i8** %a.addr, align 4
  %1 = bitcast i8* %0 to i32*
  %2 = load i32, i32* %1, align 4
  store i32 %2, i32* %aa, align 4
  %3 = load i8*, i8** %b.addr, align 4
  %4 = bitcast i8* %3 to i32*
  %5 = load i32, i32* %4, align 4
  store i32 %5, i32* %bb, align 4
  %6 = load double*, double** @base_arr, align 4
  %7 = load i32, i32* %aa, align 4
  %arrayidx = getelementptr inbounds double, double* %6, i32 %7
  %8 = load double, double* %arrayidx, align 8
  %9 = load double*, double** @base_arr, align 4
  %10 = load i32, i32* %bb, align 4
  %arrayidx1 = getelementptr inbounds double, double* %9, i32 %10
  %11 = load double, double* %arrayidx1, align 8
  %cmp = fcmp olt double %8, %11
  br i1 %cmp, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  store i32 -1, i32* %retval, align 4
  br label %return

if.else:                                          ; preds = %entry
  %12 = load double*, double** @base_arr, align 4
  %13 = load i32, i32* %aa, align 4
  %arrayidx2 = getelementptr inbounds double, double* %12, i32 %13
  %14 = load double, double* %arrayidx2, align 8
  %15 = load double*, double** @base_arr, align 4
  %16 = load i32, i32* %bb, align 4
  %arrayidx3 = getelementptr inbounds double, double* %15, i32 %16
  %17 = load double, double* %arrayidx3, align 8
  %cmp4 = fcmp oeq double %14, %17
  br i1 %cmp4, label %if.then5, label %if.else6

if.then5:                                         ; preds = %if.else
  store i32 0, i32* %retval, align 4
  br label %return

if.else6:                                         ; preds = %if.else
  store i32 1, i32* %retval, align 4
  br label %return

return:                                           ; preds = %if.else6, %if.then5, %if.then
  %18 = load i32, i32* %retval, align 4
  ret i32 %18
}

; Function Attrs: noinline nounwind optnone
define internal i32 @compar_increase(i8* noalias %a, i8* noalias %b) #0 {
entry:
  %retval = alloca i32, align 4
  %a.addr = alloca i8*, align 4
  %b.addr = alloca i8*, align 4
  %aa = alloca i32, align 4
  %bb = alloca i32, align 4
  store i8* %a, i8** %a.addr, align 4
  store i8* %b, i8** %b.addr, align 4
  %0 = load i8*, i8** %a.addr, align 4
  %1 = bitcast i8* %0 to i32*
  %2 = load i32, i32* %1, align 4
  store i32 %2, i32* %aa, align 4
  %3 = load i8*, i8** %b.addr, align 4
  %4 = bitcast i8* %3 to i32*
  %5 = load i32, i32* %4, align 4
  store i32 %5, i32* %bb, align 4
  %6 = load double*, double** @base_arr, align 4
  %7 = load i32, i32* %aa, align 4
  %arrayidx = getelementptr inbounds double, double* %6, i32 %7
  %8 = load double, double* %arrayidx, align 8
  %9 = load double*, double** @base_arr, align 4
  %10 = load i32, i32* %bb, align 4
  %arrayidx1 = getelementptr inbounds double, double* %9, i32 %10
  %11 = load double, double* %arrayidx1, align 8
  %cmp = fcmp olt double %8, %11
  br i1 %cmp, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  store i32 1, i32* %retval, align 4
  br label %return

if.else:                                          ; preds = %entry
  %12 = load double*, double** @base_arr, align 4
  %13 = load i32, i32* %aa, align 4
  %arrayidx2 = getelementptr inbounds double, double* %12, i32 %13
  %14 = load double, double* %arrayidx2, align 8
  %15 = load double*, double** @base_arr, align 4
  %16 = load i32, i32* %bb, align 4
  %arrayidx3 = getelementptr inbounds double, double* %15, i32 %16
  %17 = load double, double* %arrayidx3, align 8
  %cmp4 = fcmp oeq double %14, %17
  br i1 %cmp4, label %if.then5, label %if.else6

if.then5:                                         ; preds = %if.else
  store i32 0, i32* %retval, align 4
  br label %return

if.else6:                                         ; preds = %if.else
  store i32 -1, i32* %retval, align 4
  br label %return

return:                                           ; preds = %if.else6, %if.then5, %if.then
  %18 = load i32, i32* %retval, align 4
  ret i32 %18
}

declare void @free(i8* %0) #1

; Function Attrs: noinline nounwind optnone
define hidden double* @cummin(double* noalias %ARRAY, i32 %NO_OF_ARRAY_ELEMENTS) #0 {
entry:
  %ARRAY.addr = alloca double*, align 4
  %NO_OF_ARRAY_ELEMENTS.addr = alloca i32, align 4
  %output = alloca double*, align 4
  %cumulative_min = alloca double, align 8
  %i = alloca i32, align 4
  store double* %ARRAY, double** %ARRAY.addr, align 4
  store i32 %NO_OF_ARRAY_ELEMENTS, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
  %0 = load i32, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
  %cmp = icmp ult i32 %0, 1
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %call = call i32 @puts(i8* getelementptr inbounds ([48 x i8], [48 x i8]* @.str.4, i32 0, i32 0))
  %call1 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([22 x i8], [22 x i8]* @.str.5, i32 0, i32 0), i8* getelementptr inbounds ([23 x i8], [23 x i8]* @.str.1, i32 0, i32 0), i32 105)
  call void @exit(i32 1) #5
  unreachable

if.end:                                           ; preds = %entry
  %1 = load i32, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
  %mul = mul i32 8, %1
  %call2 = call noalias i8* @malloc(i32 %mul)
  %2 = bitcast i8* %call2 to double*
  store double* %2, double** %output, align 4
  %3 = load double*, double** %output, align 4
  %cmp3 = icmp eq double* %3, null
  br i1 %cmp3, label %if.then4, label %if.end6

if.then4:                                         ; preds = %if.end
  %call5 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([33 x i8], [33 x i8]* @.str.3, i32 0, i32 0), i8* getelementptr inbounds ([23 x i8], [23 x i8]* @.str.1, i32 0, i32 0), i32 110)
  call void @perror(i8* getelementptr inbounds ([1 x i8], [1 x i8]* @.str.2, i32 0, i32 0))
  call void @exit(i32 1) #5
  unreachable

if.end6:                                          ; preds = %if.end
  %4 = load double*, double** %ARRAY.addr, align 4
  %arrayidx = getelementptr inbounds double, double* %4, i32 0
  %5 = load double, double* %arrayidx, align 8
  store double %5, double* %cumulative_min, align 8
  store i32 0, i32* %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.end6
  %6 = load i32, i32* %i, align 4
  %7 = load i32, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
  %cmp7 = icmp ult i32 %6, %7
  br i1 %cmp7, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %8 = load double*, double** %ARRAY.addr, align 4
  %9 = load i32, i32* %i, align 4
  %arrayidx8 = getelementptr inbounds double, double* %8, i32 %9
  %10 = load double, double* %arrayidx8, align 8
  %11 = load double, double* %cumulative_min, align 8
  %cmp9 = fcmp olt double %10, %11
  br i1 %cmp9, label %if.then10, label %if.end12

if.then10:                                        ; preds = %for.body
  %12 = load double*, double** %ARRAY.addr, align 4
  %13 = load i32, i32* %i, align 4
  %arrayidx11 = getelementptr inbounds double, double* %12, i32 %13
  %14 = load double, double* %arrayidx11, align 8
  store double %14, double* %cumulative_min, align 8
  br label %if.end12

if.end12:                                         ; preds = %if.then10, %for.body
  %15 = load double, double* %cumulative_min, align 8
  %16 = load double*, double** %output, align 4
  %17 = load i32, i32* %i, align 4
  %arrayidx13 = getelementptr inbounds double, double* %16, i32 %17
  store double %15, double* %arrayidx13, align 8
  br label %for.inc

for.inc:                                          ; preds = %if.end12
  %18 = load i32, i32* %i, align 4
  %inc = add i32 %18, 1
  store i32 %inc, i32* %i, align 4
  br label %for.cond

for.end:                                          ; preds = %for.cond
  %19 = load double*, double** %output, align 4
  ret double* %19
}

declare i32 @puts(i8* %0) #1

; Function Attrs: noinline nounwind optnone
define hidden double* @cummax(double* noalias %ARRAY, i32 %NO_OF_ARRAY_ELEMENTS) #0 {
entry:
  %ARRAY.addr = alloca double*, align 4
  %NO_OF_ARRAY_ELEMENTS.addr = alloca i32, align 4
  %output = alloca double*, align 4
  %cumulative_max = alloca double, align 8
  %i = alloca i32, align 4
  store double* %ARRAY, double** %ARRAY.addr, align 4
  store i32 %NO_OF_ARRAY_ELEMENTS, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
  %0 = load i32, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
  %cmp = icmp ult i32 %0, 1
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %call = call i32 @puts(i8* getelementptr inbounds ([41 x i8], [41 x i8]* @.str.6, i32 0, i32 0))
  %call1 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([22 x i8], [22 x i8]* @.str.5, i32 0, i32 0), i8* getelementptr inbounds ([23 x i8], [23 x i8]* @.str.1, i32 0, i32 0), i32 129)
  call void @exit(i32 1) #5
  unreachable

if.end:                                           ; preds = %entry
  %1 = load i32, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
  %mul = mul i32 8, %1
  %call2 = call noalias i8* @malloc(i32 %mul)
  %2 = bitcast i8* %call2 to double*
  store double* %2, double** %output, align 4
  %3 = load double*, double** %output, align 4
  %cmp3 = icmp eq double* %3, null
  br i1 %cmp3, label %if.then4, label %if.end6

if.then4:                                         ; preds = %if.end
  %call5 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([33 x i8], [33 x i8]* @.str.3, i32 0, i32 0), i8* getelementptr inbounds ([23 x i8], [23 x i8]* @.str.1, i32 0, i32 0), i32 134)
  call void @perror(i8* getelementptr inbounds ([1 x i8], [1 x i8]* @.str.2, i32 0, i32 0))
  call void @exit(i32 1) #5
  unreachable

if.end6:                                          ; preds = %if.end
  %4 = load double*, double** %ARRAY.addr, align 4
  %arrayidx = getelementptr inbounds double, double* %4, i32 0
  %5 = load double, double* %arrayidx, align 8
  store double %5, double* %cumulative_max, align 8
  store i32 0, i32* %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.end6
  %6 = load i32, i32* %i, align 4
  %7 = load i32, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
  %cmp7 = icmp ult i32 %6, %7
  br i1 %cmp7, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %8 = load double*, double** %ARRAY.addr, align 4
  %9 = load i32, i32* %i, align 4
  %arrayidx8 = getelementptr inbounds double, double* %8, i32 %9
  %10 = load double, double* %arrayidx8, align 8
  %11 = load double, double* %cumulative_max, align 8
  %cmp9 = fcmp ogt double %10, %11
  br i1 %cmp9, label %if.then10, label %if.end12

if.then10:                                        ; preds = %for.body
  %12 = load double*, double** %ARRAY.addr, align 4
  %13 = load i32, i32* %i, align 4
  %arrayidx11 = getelementptr inbounds double, double* %12, i32 %13
  %14 = load double, double* %arrayidx11, align 8
  store double %14, double* %cumulative_max, align 8
  br label %if.end12

if.end12:                                         ; preds = %if.then10, %for.body
  %15 = load double, double* %cumulative_max, align 8
  %16 = load double*, double** %output, align 4
  %17 = load i32, i32* %i, align 4
  %arrayidx13 = getelementptr inbounds double, double* %16, i32 %17
  store double %15, double* %arrayidx13, align 8
  br label %for.inc

for.inc:                                          ; preds = %if.end12
  %18 = load i32, i32* %i, align 4
  %inc = add i32 %18, 1
  store i32 %inc, i32* %i, align 4
  br label %for.cond

for.end:                                          ; preds = %for.cond
  %19 = load double*, double** %output, align 4
  ret double* %19
}

; Function Attrs: noinline nounwind optnone
define hidden double* @pminx(double* noalias %ARRAY, i32 %NO_OF_ARRAY_ELEMENTS, double %X) #0 {
entry:
  %ARRAY.addr = alloca double*, align 4
  %NO_OF_ARRAY_ELEMENTS.addr = alloca i32, align 4
  %X.addr = alloca double, align 8
  %pmin_array = alloca double*, align 4
  %index = alloca i32, align 4
  store double* %ARRAY, double** %ARRAY.addr, align 4
  store i32 %NO_OF_ARRAY_ELEMENTS, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
  store double %X, double* %X.addr, align 8
  %0 = load i32, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
  %cmp = icmp ult i32 %0, 1
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %call = call i32 @puts(i8* getelementptr inbounds ([37 x i8], [37 x i8]* @.str.7, i32 0, i32 0))
  %call1 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([22 x i8], [22 x i8]* @.str.5, i32 0, i32 0), i8* getelementptr inbounds ([23 x i8], [23 x i8]* @.str.1, i32 0, i32 0), i32 152)
  call void @exit(i32 1) #5
  unreachable

if.end:                                           ; preds = %entry
  %1 = load i32, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
  %mul = mul i32 8, %1
  %call2 = call noalias i8* @malloc(i32 %mul)
  %2 = bitcast i8* %call2 to double*
  store double* %2, double** %pmin_array, align 4
  %3 = load double*, double** %pmin_array, align 4
  %cmp3 = icmp eq double* %3, null
  br i1 %cmp3, label %if.then4, label %if.end6

if.then4:                                         ; preds = %if.end
  %call5 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([33 x i8], [33 x i8]* @.str.3, i32 0, i32 0), i8* getelementptr inbounds ([23 x i8], [23 x i8]* @.str.1, i32 0, i32 0), i32 157)
  call void @perror(i8* getelementptr inbounds ([1 x i8], [1 x i8]* @.str.2, i32 0, i32 0))
  call void @exit(i32 1) #5
  unreachable

if.end6:                                          ; preds = %if.end
  store i32 0, i32* %index, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.end6
  %4 = load i32, i32* %index, align 4
  %5 = load i32, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
  %cmp7 = icmp ult i32 %4, %5
  br i1 %cmp7, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %6 = load double*, double** %ARRAY.addr, align 4
  %7 = load i32, i32* %index, align 4
  %arrayidx = getelementptr inbounds double, double* %6, i32 %7
  %8 = load double, double* %arrayidx, align 8
  %9 = load double, double* %X.addr, align 8
  %cmp8 = fcmp olt double %8, %9
  br i1 %cmp8, label %if.then9, label %if.else

if.then9:                                         ; preds = %for.body
  %10 = load double*, double** %ARRAY.addr, align 4
  %11 = load i32, i32* %index, align 4
  %arrayidx10 = getelementptr inbounds double, double* %10, i32 %11
  %12 = load double, double* %arrayidx10, align 8
  %13 = load double*, double** %pmin_array, align 4
  %14 = load i32, i32* %index, align 4
  %arrayidx11 = getelementptr inbounds double, double* %13, i32 %14
  store double %12, double* %arrayidx11, align 8
  br label %if.end13

if.else:                                          ; preds = %for.body
  %15 = load double, double* %X.addr, align 8
  %16 = load double*, double** %pmin_array, align 4
  %17 = load i32, i32* %index, align 4
  %arrayidx12 = getelementptr inbounds double, double* %16, i32 %17
  store double %15, double* %arrayidx12, align 8
  br label %if.end13

if.end13:                                         ; preds = %if.else, %if.then9
  br label %for.inc

for.inc:                                          ; preds = %if.end13
  %18 = load i32, i32* %index, align 4
  %inc = add i32 %18, 1
  store i32 %inc, i32* %index, align 4
  br label %for.cond

for.end:                                          ; preds = %for.cond
  %19 = load double*, double** %pmin_array, align 4
  ret double* %19
}

; Function Attrs: noinline nounwind optnone
define hidden void @double_say(double* noalias %ARRAY, i32 %NO_OF_ARRAY_ELEMENTS) #0 {
entry:
  %ARRAY.addr = alloca double*, align 4
  %NO_OF_ARRAY_ELEMENTS.addr = alloca i32, align 4
  %i = alloca i32, align 4
  store double* %ARRAY, double** %ARRAY.addr, align 4
  store i32 %NO_OF_ARRAY_ELEMENTS, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
  %0 = load double*, double** %ARRAY.addr, align 4
  %arrayidx = getelementptr inbounds double, double* %0, i32 0
  %1 = load double, double* %arrayidx, align 8
  %call = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([7 x i8], [7 x i8]* @.str.8, i32 0, i32 0), double %1)
  store i32 1, i32* %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %2 = load i32, i32* %i, align 4
  %3 = load i32, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
  %cmp = icmp ult i32 %2, %3
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %4 = load double*, double** %ARRAY.addr, align 4
  %5 = load i32, i32* %i, align 4
  %arrayidx1 = getelementptr inbounds double, double* %4, i32 %5
  %6 = load double, double* %arrayidx1, align 8
  %call2 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([7 x i8], [7 x i8]* @.str.9, i32 0, i32 0), double %6)
  %7 = load i32, i32* %i, align 4
  %add = add i32 %7, 1
  %rem = urem i32 %add, 5
  %cmp3 = icmp eq i32 %rem, 0
  br i1 %cmp3, label %if.then, label %if.end

if.then:                                          ; preds = %for.body
  %8 = load i32, i32* %i, align 4
  %add4 = add i32 %8, 1
  %call5 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([6 x i8], [6 x i8]* @.str.10, i32 0, i32 0), i32 %add4)
  br label %if.end

if.end:                                           ; preds = %if.then, %for.body
  br label %for.inc

for.inc:                                          ; preds = %if.end
  %9 = load i32, i32* %i, align 4
  %inc = add i32 %9, 1
  store i32 %inc, i32* %i, align 4
  br label %for.cond

for.end:                                          ; preds = %for.cond
  %call6 = call i32 @puts(i8* getelementptr inbounds ([2 x i8], [2 x i8]* @.str.11, i32 0, i32 0))
  ret void
}

; Function Attrs: noinline nounwind optnone
define hidden double* @uint2double(i32* noalias %ARRAY, i32 %NO_OF_ARRAY_ELEMENTS) #0 {
entry:
  %ARRAY.addr = alloca i32*, align 4
  %NO_OF_ARRAY_ELEMENTS.addr = alloca i32, align 4
  %doubleArray = alloca double*, align 4
  %index = alloca i32, align 4
  store i32* %ARRAY, i32** %ARRAY.addr, align 4
  store i32 %NO_OF_ARRAY_ELEMENTS, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
  %0 = load i32, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
  %mul = mul i32 8, %0
  %call = call noalias i8* @malloc(i32 %mul)
  %1 = bitcast i8* %call to double*
  store double* %1, double** %doubleArray, align 4
  %2 = load double*, double** %doubleArray, align 4
  %cmp = icmp eq double* %2, null
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %call1 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([34 x i8], [34 x i8]* @.str.12, i32 0, i32 0), i8* getelementptr inbounds ([23 x i8], [23 x i8]* @.str.1, i32 0, i32 0), i32 194)
  call void @perror(i8* getelementptr inbounds ([1 x i8], [1 x i8]* @.str.2, i32 0, i32 0))
  call void @exit(i32 1) #5
  unreachable

if.end:                                           ; preds = %entry
  store i32 0, i32* %index, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.end
  %3 = load i32, i32* %index, align 4
  %4 = load i32, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
  %cmp2 = icmp ult i32 %3, %4
  br i1 %cmp2, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %5 = load i32*, i32** %ARRAY.addr, align 4
  %6 = load i32, i32* %index, align 4
  %arrayidx = getelementptr inbounds i32, i32* %5, i32 %6
  %7 = load i32, i32* %arrayidx, align 4
  %conv = uitofp i32 %7 to double
  %8 = load double*, double** %doubleArray, align 4
  %9 = load i32, i32* %index, align 4
  %arrayidx3 = getelementptr inbounds double, double* %8, i32 %9
  store double %conv, double* %arrayidx3, align 8
  br label %for.inc

for.inc:                                          ; preds = %for.body
  %10 = load i32, i32* %index, align 4
  %inc = add i32 %10, 1
  store i32 %inc, i32* %index, align 4
  br label %for.cond

for.end:                                          ; preds = %for.cond
  %11 = load double*, double** %doubleArray, align 4
  ret double* %11
}

; Function Attrs: noinline nounwind optnone
define hidden double @min2(double %N1, double %N2) #0 {
entry:
  %retval = alloca double, align 8
  %N1.addr = alloca double, align 8
  %N2.addr = alloca double, align 8
  store double %N1, double* %N1.addr, align 8
  store double %N2, double* %N2.addr, align 8
  %0 = load double, double* %N1.addr, align 8
  %1 = load double, double* %N2.addr, align 8
  %cmp = fcmp olt double %0, %1
  br i1 %cmp, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  %2 = load double, double* %N1.addr, align 8
  store double %2, double* %retval, align 8
  br label %return

if.else:                                          ; preds = %entry
  %3 = load double, double* %N2.addr, align 8
  store double %3, double* %retval, align 8
  br label %return

return:                                           ; preds = %if.else, %if.then
  %4 = load double, double* %retval, align 8
  ret double %4
}

; Function Attrs: noinline nounwind optnone
define hidden double* @p_adjust(double* noalias %PVALUES, i32 %NO_OF_ARRAY_ELEMENTS, i8* noalias %STRING) #0 {
entry:
  %retval = alloca double*, align 4
  %PVALUES.addr = alloca double*, align 4
  %NO_OF_ARRAY_ELEMENTS.addr = alloca i32, align 4
  %STRING.addr = alloca i8*, align 4
  %TYPE = alloca i16, align 2
  %bonferroni = alloca double*, align 4
  %index = alloca i32, align 4
  %BONFERRONI = alloca double, align 8
  %o = alloca i32*, align 4
  %o2double = alloca double*, align 4
  %cummax_input = alloca double*, align 4
  %index80 = alloca i32, align 4
  %ro = alloca i32*, align 4
  %cummax_output = alloca double*, align 4
  %pmin = alloca double*, align 4
  %qvalues = alloca double*, align 4
  %index98 = alloca i32, align 4
  %o114 = alloca i32*, align 4
  %p = alloca double*, align 4
  %index123 = alloca i32, align 4
  %o2double134 = alloca double*, align 4
  %ro136 = alloca i32*, align 4
  %q = alloca double*, align 4
  %pa = alloca double*, align 4
  %min = alloca double, align 8
  %index155 = alloca i32, align 4
  %TEMP = alloca double, align 8
  %index171 = alloca i32, align 4
  %j = alloca i32, align 4
  %ij = alloca i32*, align 4
  %I2_LENGTH = alloca i32, align 4
  %i2 = alloca i32*, align 4
  %i = alloca i32, align 4
  %q1 = alloca double, align 8
  %i208 = alloca i32, align 4
  %TEMP_Q1 = alloca double, align 8
  %i227 = alloca i32, align 4
  %i244 = alloca i32, align 4
  %i256 = alloca i32, align 4
  %index274 = alloca i32, align 4
  %o288 = alloca i32*, align 4
  %o_double = alloca double*, align 4
  %index296 = alloca i32, align 4
  %ro315 = alloca i32*, align 4
  %cummin_input = alloca double*, align 4
  %index328 = alloca i32, align 4
  %NI = alloca double, align 8
  %q349 = alloca double, align 8
  %index350 = alloca i32, align 4
  %index362 = alloca i32, align 4
  %NI367 = alloca double, align 8
  %index385 = alloca i32, align 4
  %cummin_array = alloca double*, align 4
  %pmin403 = alloca double*, align 4
  %q_array = alloca double*, align 4
  %index407 = alloca i32, align 4
  store double* %PVALUES, double** %PVALUES.addr, align 4
  store i32 %NO_OF_ARRAY_ELEMENTS, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
  store i8* %STRING, i8** %STRING.addr, align 4
  %0 = load i32, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
  %cmp = icmp ult i32 %0, 1
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %call = call i32 @puts(i8* getelementptr inbounds ([41 x i8], [41 x i8]* @.str.13, i32 0, i32 0))
  %call1 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([22 x i8], [22 x i8]* @.str.5, i32 0, i32 0), i8* getelementptr inbounds ([23 x i8], [23 x i8]* @.str.1, i32 0, i32 0), i32 217)
  call void @exit(i32 1) #5
  unreachable

if.end:                                           ; preds = %entry
  store i16 -1, i16* %TYPE, align 2
  %1 = load i8*, i8** %STRING.addr, align 4
  %cmp2 = icmp eq i8* %1, null
  br i1 %cmp2, label %if.then3, label %if.else

if.then3:                                         ; preds = %if.end
  store i16 0, i16* %TYPE, align 2
  br label %if.end41

if.else:                                          ; preds = %if.end
  %2 = load i8*, i8** %STRING.addr, align 4
  %call4 = call i32 @strcasecmp(i8* %2, i8* getelementptr inbounds ([3 x i8], [3 x i8]* @.str.14, i32 0, i32 0))
  %cmp5 = icmp eq i32 %call4, 0
  br i1 %cmp5, label %if.then6, label %if.else7

if.then6:                                         ; preds = %if.else
  store i16 0, i16* %TYPE, align 2
  br label %if.end40

if.else7:                                         ; preds = %if.else
  %3 = load i8*, i8** %STRING.addr, align 4
  %call8 = call i32 @strcasecmp(i8* %3, i8* getelementptr inbounds ([4 x i8], [4 x i8]* @.str.15, i32 0, i32 0))
  %cmp9 = icmp eq i32 %call8, 0
  br i1 %cmp9, label %if.then10, label %if.else11

if.then10:                                        ; preds = %if.else7
  store i16 0, i16* %TYPE, align 2
  br label %if.end39

if.else11:                                        ; preds = %if.else7
  %4 = load i8*, i8** %STRING.addr, align 4
  %call12 = call i32 @strcasecmp(i8* %4, i8* getelementptr inbounds ([3 x i8], [3 x i8]* @.str.16, i32 0, i32 0))
  %cmp13 = icmp eq i32 %call12, 0
  br i1 %cmp13, label %if.then14, label %if.else15

if.then14:                                        ; preds = %if.else11
  store i16 1, i16* %TYPE, align 2
  br label %if.end38

if.else15:                                        ; preds = %if.else11
  %5 = load i8*, i8** %STRING.addr, align 4
  %call16 = call i32 @strcasecmp(i8* %5, i8* getelementptr inbounds ([11 x i8], [11 x i8]* @.str.17, i32 0, i32 0))
  %cmp17 = icmp eq i32 %call16, 0
  br i1 %cmp17, label %if.then18, label %if.else19

if.then18:                                        ; preds = %if.else15
  store i16 2, i16* %TYPE, align 2
  br label %if.end37

if.else19:                                        ; preds = %if.else15
  %6 = load i8*, i8** %STRING.addr, align 4
  %call20 = call i32 @strcasecmp(i8* %6, i8* getelementptr inbounds ([9 x i8], [9 x i8]* @.str.18, i32 0, i32 0))
  %cmp21 = icmp eq i32 %call20, 0
  br i1 %cmp21, label %if.then22, label %if.else23

if.then22:                                        ; preds = %if.else19
  store i16 3, i16* %TYPE, align 2
  br label %if.end36

if.else23:                                        ; preds = %if.else19
  %7 = load i8*, i8** %STRING.addr, align 4
  %call24 = call i32 @strcasecmp(i8* %7, i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.19, i32 0, i32 0))
  %cmp25 = icmp eq i32 %call24, 0
  br i1 %cmp25, label %if.then26, label %if.else27

if.then26:                                        ; preds = %if.else23
  store i16 4, i16* %TYPE, align 2
  br label %if.end35

if.else27:                                        ; preds = %if.else23
  %8 = load i8*, i8** %STRING.addr, align 4
  %call28 = call i32 @strcasecmp(i8* %8, i8* getelementptr inbounds ([7 x i8], [7 x i8]* @.str.20, i32 0, i32 0))
  %cmp29 = icmp eq i32 %call28, 0
  br i1 %cmp29, label %if.then30, label %if.else31

if.then30:                                        ; preds = %if.else27
  store i16 5, i16* %TYPE, align 2
  br label %if.end34

if.else31:                                        ; preds = %if.else27
  %9 = load i8*, i8** %STRING.addr, align 4
  %call32 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([44 x i8], [44 x i8]* @.str.21, i32 0, i32 0), i8* %9)
  %call33 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([22 x i8], [22 x i8]* @.str.5, i32 0, i32 0), i8* getelementptr inbounds ([23 x i8], [23 x i8]* @.str.1, i32 0, i32 0), i32 239)
  call void @exit(i32 1) #5
  unreachable

if.end34:                                         ; preds = %if.then30
  br label %if.end35

if.end35:                                         ; preds = %if.end34, %if.then26
  br label %if.end36

if.end36:                                         ; preds = %if.end35, %if.then22
  br label %if.end37

if.end37:                                         ; preds = %if.end36, %if.then18
  br label %if.end38

if.end38:                                         ; preds = %if.end37, %if.then14
  br label %if.end39

if.end39:                                         ; preds = %if.end38, %if.then10
  br label %if.end40

if.end40:                                         ; preds = %if.end39, %if.then6
  br label %if.end41

if.end41:                                         ; preds = %if.end40, %if.then3
  %10 = load i16, i16* %TYPE, align 2
  %conv = sext i16 %10 to i32
  %cmp42 = icmp eq i32 %conv, 2
  br i1 %cmp42, label %if.then44, label %if.else71

if.then44:                                        ; preds = %if.end41
  %11 = load i32, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
  %mul = mul i32 8, %11
  %call45 = call noalias i8* @malloc(i32 %mul)
  %12 = bitcast i8* %call45 to double*
  store double* %12, double** %bonferroni, align 4
  %13 = load double*, double** %bonferroni, align 4
  %cmp46 = icmp eq double* %13, null
  br i1 %cmp46, label %if.then48, label %if.end50

if.then48:                                        ; preds = %if.then44
  %call49 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([33 x i8], [33 x i8]* @.str.3, i32 0, i32 0), i8* getelementptr inbounds ([23 x i8], [23 x i8]* @.str.1, i32 0, i32 0), i32 247)
  call void @perror(i8* getelementptr inbounds ([1 x i8], [1 x i8]* @.str.2, i32 0, i32 0))
  call void @exit(i32 1) #5
  unreachable

if.end50:                                         ; preds = %if.then44
  store i32 0, i32* %index, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.end50
  %14 = load i32, i32* %index, align 4
  %15 = load i32, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
  %cmp51 = icmp ult i32 %14, %15
  br i1 %cmp51, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %16 = load double*, double** %PVALUES.addr, align 4
  %17 = load i32, i32* %index, align 4
  %arrayidx = getelementptr inbounds double, double* %16, i32 %17
  %18 = load double, double* %arrayidx, align 8
  %19 = load i32, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
  %conv53 = uitofp i32 %19 to double
  %mul54 = fmul double %18, %conv53
  store double %mul54, double* %BONFERRONI, align 8
  %20 = load double, double* %BONFERRONI, align 8
  %cmp55 = fcmp oge double %20, 1.000000e+00
  br i1 %cmp55, label %if.then57, label %if.else59

if.then57:                                        ; preds = %for.body
  %21 = load double*, double** %bonferroni, align 4
  %22 = load i32, i32* %index, align 4
  %arrayidx58 = getelementptr inbounds double, double* %21, i32 %22
  store double 1.000000e+00, double* %arrayidx58, align 8
  br label %if.end70

if.else59:                                        ; preds = %for.body
  %23 = load double, double* %BONFERRONI, align 8
  %cmp60 = fcmp ole double 0.000000e+00, %23
  br i1 %cmp60, label %land.lhs.true, label %if.else66

land.lhs.true:                                    ; preds = %if.else59
  %24 = load double, double* %BONFERRONI, align 8
  %cmp62 = fcmp olt double %24, 1.000000e+00
  br i1 %cmp62, label %if.then64, label %if.else66

if.then64:                                        ; preds = %land.lhs.true
  %25 = load double, double* %BONFERRONI, align 8
  %26 = load double*, double** %bonferroni, align 4
  %27 = load i32, i32* %index, align 4
  %arrayidx65 = getelementptr inbounds double, double* %26, i32 %27
  store double %25, double* %arrayidx65, align 8
  br label %if.end69

if.else66:                                        ; preds = %land.lhs.true, %if.else59
  %28 = load double, double* %BONFERRONI, align 8
  %call67 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([42 x i8], [42 x i8]* @.str.22, i32 0, i32 0), double %28)
  %call68 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([23 x i8], [23 x i8]* @.str.23, i32 0, i32 0), i8* getelementptr inbounds ([23 x i8], [23 x i8]* @.str.1, i32 0, i32 0), i32 259)
  call void @exit(i32 1) #5
  unreachable

if.end69:                                         ; preds = %if.then64
  br label %if.end70

if.end70:                                         ; preds = %if.end69, %if.then57
  br label %for.inc

for.inc:                                          ; preds = %if.end70
  %29 = load i32, i32* %index, align 4
  %inc = add i32 %29, 1
  store i32 %inc, i32* %index, align 4
  br label %for.cond

for.end:                                          ; preds = %for.cond
  %30 = load double*, double** %bonferroni, align 4
  store double* %30, double** %retval, align 4
  br label %return

if.else71:                                        ; preds = %if.end41
  %31 = load i16, i16* %TYPE, align 2
  %conv72 = sext i16 %31 to i32
  %cmp73 = icmp eq i32 %conv72, 4
  br i1 %cmp73, label %if.then75, label %if.else109

if.then75:                                        ; preds = %if.else71
  %32 = load double*, double** %PVALUES.addr, align 4
  %33 = load i32, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
  %call76 = call i32* @order(double* %32, i32 %33, i1 zeroext false)
  store i32* %call76, i32** %o, align 4
  %34 = load i32*, i32** %o, align 4
  %35 = load i32, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
  %call77 = call double* @uint2double(i32* %34, i32 %35)
  store double* %call77, double** %o2double, align 4
  %36 = load i32, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
  %mul78 = mul i32 8, %36
  %call79 = call noalias i8* @malloc(i32 %mul78)
  %37 = bitcast i8* %call79 to double*
  store double* %37, double** %cummax_input, align 4
  store i32 0, i32* %index80, align 4
  br label %for.cond81

for.cond81:                                       ; preds = %for.inc90, %if.then75
  %38 = load i32, i32* %index80, align 4
  %39 = load i32, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
  %cmp82 = icmp ult i32 %38, %39
  br i1 %cmp82, label %for.body84, label %for.end92

for.body84:                                       ; preds = %for.cond81
  %40 = load i32, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
  %41 = load i32, i32* %index80, align 4
  %sub = sub i32 %40, %41
  %conv85 = uitofp i32 %sub to double
  %42 = load double*, double** %PVALUES.addr, align 4
  %43 = load i32*, i32** %o, align 4
  %44 = load i32, i32* %index80, align 4
  %arrayidx86 = getelementptr inbounds i32, i32* %43, i32 %44
  %45 = load i32, i32* %arrayidx86, align 4
  %arrayidx87 = getelementptr inbounds double, double* %42, i32 %45
  %46 = load double, double* %arrayidx87, align 8
  %mul88 = fmul double %conv85, %46
  %47 = load double*, double** %cummax_input, align 4
  %48 = load i32, i32* %index80, align 4
  %arrayidx89 = getelementptr inbounds double, double* %47, i32 %48
  store double %mul88, double* %arrayidx89, align 8
  br label %for.inc90

for.inc90:                                        ; preds = %for.body84
  %49 = load i32, i32* %index80, align 4
  %inc91 = add i32 %49, 1
  store i32 %inc91, i32* %index80, align 4
  br label %for.cond81

for.end92:                                        ; preds = %for.cond81
  %50 = load i32*, i32** %o, align 4
  %51 = bitcast i32* %50 to i8*
  call void @free(i8* %51)
  store i32* null, i32** %o, align 4
  %52 = load double*, double** %o2double, align 4
  %53 = load i32, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
  %call93 = call i32* @order(double* %52, i32 %53, i1 zeroext false)
  store i32* %call93, i32** %ro, align 4
  %54 = load double*, double** %o2double, align 4
  %55 = bitcast double* %54 to i8*
  call void @free(i8* %55)
  store double* null, double** %o2double, align 4
  %56 = load double*, double** %cummax_input, align 4
  %57 = load i32, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
  %call94 = call double* @cummax(double* %56, i32 %57)
  store double* %call94, double** %cummax_output, align 4
  %58 = load double*, double** %cummax_input, align 4
  %59 = bitcast double* %58 to i8*
  call void @free(i8* %59)
  store double* null, double** %cummax_input, align 4
  %60 = load double*, double** %cummax_output, align 4
  %61 = load i32, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
  %call95 = call double* @pminx(double* %60, i32 %61, double 1.000000e+00)
  store double* %call95, double** %pmin, align 4
  %62 = load double*, double** %cummax_output, align 4
  %63 = bitcast double* %62 to i8*
  call void @free(i8* %63)
  store double* null, double** %cummax_output, align 4
  %64 = load i32, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
  %mul96 = mul i32 8, %64
  %call97 = call noalias i8* @malloc(i32 %mul96)
  %65 = bitcast i8* %call97 to double*
  store double* %65, double** %qvalues, align 4
  store i32 0, i32* %index98, align 4
  br label %for.cond99

for.cond99:                                       ; preds = %for.inc106, %for.end92
  %66 = load i32, i32* %index98, align 4
  %67 = load i32, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
  %cmp100 = icmp ult i32 %66, %67
  br i1 %cmp100, label %for.body102, label %for.end108

for.body102:                                      ; preds = %for.cond99
  %68 = load double*, double** %pmin, align 4
  %69 = load i32*, i32** %ro, align 4
  %70 = load i32, i32* %index98, align 4
  %arrayidx103 = getelementptr inbounds i32, i32* %69, i32 %70
  %71 = load i32, i32* %arrayidx103, align 4
  %arrayidx104 = getelementptr inbounds double, double* %68, i32 %71
  %72 = load double, double* %arrayidx104, align 8
  %73 = load double*, double** %qvalues, align 4
  %74 = load i32, i32* %index98, align 4
  %arrayidx105 = getelementptr inbounds double, double* %73, i32 %74
  store double %72, double* %arrayidx105, align 8
  br label %for.inc106

for.inc106:                                       ; preds = %for.body102
  %75 = load i32, i32* %index98, align 4
  %inc107 = add i32 %75, 1
  store i32 %inc107, i32* %index98, align 4
  br label %for.cond99

for.end108:                                       ; preds = %for.cond99
  %76 = load double*, double** %pmin, align 4
  %77 = bitcast double* %76 to i8*
  call void @free(i8* %77)
  store double* null, double** %pmin, align 4
  %78 = load i32*, i32** %ro, align 4
  %79 = bitcast i32* %78 to i8*
  call void @free(i8* %79)
  store i32* null, i32** %ro, align 4
  %80 = load double*, double** %qvalues, align 4
  store double* %80, double** %retval, align 4
  br label %return

if.else109:                                       ; preds = %if.else71
  %81 = load i16, i16* %TYPE, align 2
  %conv110 = sext i16 %81 to i32
  %cmp111 = icmp eq i32 %conv110, 5
  br i1 %cmp111, label %if.then113, label %if.end285

if.then113:                                       ; preds = %if.else109
  %82 = load double*, double** %PVALUES.addr, align 4
  %83 = load i32, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
  %call115 = call i32* @order(double* %82, i32 %83, i1 zeroext false)
  store i32* %call115, i32** %o114, align 4
  %84 = load i32, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
  %mul116 = mul i32 8, %84
  %call117 = call noalias i8* @malloc(i32 %mul116)
  %85 = bitcast i8* %call117 to double*
  store double* %85, double** %p, align 4
  %86 = load double*, double** %p, align 4
  %cmp118 = icmp eq double* %86, null
  br i1 %cmp118, label %if.then120, label %if.end122

if.then120:                                       ; preds = %if.then113
  %call121 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([33 x i8], [33 x i8]* @.str.3, i32 0, i32 0), i8* getelementptr inbounds ([23 x i8], [23 x i8]* @.str.1, i32 0, i32 0), i32 302)
  call void @perror(i8* getelementptr inbounds ([1 x i8], [1 x i8]* @.str.2, i32 0, i32 0))
  call void @exit(i32 1) #5
  unreachable

if.end122:                                        ; preds = %if.then113
  store i32 0, i32* %index123, align 4
  br label %for.cond124

for.cond124:                                      ; preds = %for.inc131, %if.end122
  %87 = load i32, i32* %index123, align 4
  %88 = load i32, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
  %cmp125 = icmp ult i32 %87, %88
  br i1 %cmp125, label %for.body127, label %for.end133

for.body127:                                      ; preds = %for.cond124
  %89 = load double*, double** %PVALUES.addr, align 4
  %90 = load i32*, i32** %o114, align 4
  %91 = load i32, i32* %index123, align 4
  %arrayidx128 = getelementptr inbounds i32, i32* %90, i32 %91
  %92 = load i32, i32* %arrayidx128, align 4
  %arrayidx129 = getelementptr inbounds double, double* %89, i32 %92
  %93 = load double, double* %arrayidx129, align 8
  %94 = load double*, double** %p, align 4
  %95 = load i32, i32* %index123, align 4
  %arrayidx130 = getelementptr inbounds double, double* %94, i32 %95
  store double %93, double* %arrayidx130, align 8
  br label %for.inc131

for.inc131:                                       ; preds = %for.body127
  %96 = load i32, i32* %index123, align 4
  %inc132 = add i32 %96, 1
  store i32 %inc132, i32* %index123, align 4
  br label %for.cond124

for.end133:                                       ; preds = %for.cond124
  %97 = load i32*, i32** %o114, align 4
  %98 = load i32, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
  %call135 = call double* @uint2double(i32* %97, i32 %98)
  store double* %call135, double** %o2double134, align 4
  %99 = load i32*, i32** %o114, align 4
  %100 = bitcast i32* %99 to i8*
  call void @free(i8* %100)
  store i32* null, i32** %o114, align 4
  %101 = load double*, double** %o2double134, align 4
  %102 = load i32, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
  %call137 = call i32* @order(double* %101, i32 %102, i1 zeroext false)
  store i32* %call137, i32** %ro136, align 4
  %103 = load double*, double** %o2double134, align 4
  %104 = bitcast double* %103 to i8*
  call void @free(i8* %104)
  store double* null, double** %o2double134, align 4
  %105 = load i32, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
  %mul138 = mul i32 8, %105
  %call139 = call noalias i8* @malloc(i32 %mul138)
  %106 = bitcast i8* %call139 to double*
  store double* %106, double** %q, align 4
  %107 = load double*, double** %q, align 4
  %cmp140 = icmp eq double* %107, null
  br i1 %cmp140, label %if.then142, label %if.end144

if.then142:                                       ; preds = %for.end133
  %call143 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([33 x i8], [33 x i8]* @.str.3, i32 0, i32 0), i8* getelementptr inbounds ([23 x i8], [23 x i8]* @.str.1, i32 0, i32 0), i32 318)
  call void @perror(i8* getelementptr inbounds ([1 x i8], [1 x i8]* @.str.2, i32 0, i32 0))
  call void @exit(i32 1) #5
  unreachable

if.end144:                                        ; preds = %for.end133
  %108 = load i32, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
  %mul145 = mul i32 8, %108
  %call146 = call noalias i8* @malloc(i32 %mul145)
  %109 = bitcast i8* %call146 to double*
  store double* %109, double** %pa, align 4
  %110 = load double*, double** %pa, align 4
  %cmp147 = icmp eq double* %110, null
  br i1 %cmp147, label %if.then149, label %if.end151

if.then149:                                       ; preds = %if.end144
  %call150 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([33 x i8], [33 x i8]* @.str.3, i32 0, i32 0), i8* getelementptr inbounds ([23 x i8], [23 x i8]* @.str.1, i32 0, i32 0), i32 324)
  call void @perror(i8* getelementptr inbounds ([1 x i8], [1 x i8]* @.str.2, i32 0, i32 0))
  call void @exit(i32 1) #5
  unreachable

if.end151:                                        ; preds = %if.end144
  %111 = load i32, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
  %conv152 = uitofp i32 %111 to double
  %112 = load double*, double** %p, align 4
  %arrayidx153 = getelementptr inbounds double, double* %112, i32 0
  %113 = load double, double* %arrayidx153, align 8
  %mul154 = fmul double %conv152, %113
  store double %mul154, double* %min, align 8
  store i32 1, i32* %index155, align 4
  br label %for.cond156

for.cond156:                                      ; preds = %for.inc168, %if.end151
  %114 = load i32, i32* %index155, align 4
  %115 = load i32, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
  %cmp157 = icmp ult i32 %114, %115
  br i1 %cmp157, label %for.body159, label %for.end170

for.body159:                                      ; preds = %for.cond156
  %116 = load i32, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
  %conv160 = uitofp i32 %116 to double
  %117 = load double*, double** %p, align 4
  %118 = load i32, i32* %index155, align 4
  %arrayidx161 = getelementptr inbounds double, double* %117, i32 %118
  %119 = load double, double* %arrayidx161, align 8
  %mul162 = fmul double %conv160, %119
  %120 = load i32, i32* %index155, align 4
  %add = add i32 1, %120
  %conv163 = uitofp i32 %add to double
  %div = fdiv double %mul162, %conv163
  store double %div, double* %TEMP, align 8
  %121 = load double, double* %TEMP, align 8
  %122 = load double, double* %min, align 8
  %cmp164 = fcmp olt double %121, %122
  br i1 %cmp164, label %if.then166, label %if.end167

if.then166:                                       ; preds = %for.body159
  %123 = load double, double* %TEMP, align 8
  store double %123, double* %min, align 8
  br label %if.end167

if.end167:                                        ; preds = %if.then166, %for.body159
  br label %for.inc168

for.inc168:                                       ; preds = %if.end167
  %124 = load i32, i32* %index155, align 4
  %inc169 = add i32 %124, 1
  store i32 %inc169, i32* %index155, align 4
  br label %for.cond156

for.end170:                                       ; preds = %for.cond156
  store i32 0, i32* %index171, align 4
  br label %for.cond172

for.cond172:                                      ; preds = %for.inc178, %for.end170
  %125 = load i32, i32* %index171, align 4
  %126 = load i32, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
  %cmp173 = icmp ult i32 %125, %126
  br i1 %cmp173, label %for.body175, label %for.end180

for.body175:                                      ; preds = %for.cond172
  %127 = load double, double* %min, align 8
  %128 = load double*, double** %pa, align 4
  %129 = load i32, i32* %index171, align 4
  %arrayidx176 = getelementptr inbounds double, double* %128, i32 %129
  store double %127, double* %arrayidx176, align 8
  %130 = load double, double* %min, align 8
  %131 = load double*, double** %q, align 4
  %132 = load i32, i32* %index171, align 4
  %arrayidx177 = getelementptr inbounds double, double* %131, i32 %132
  store double %130, double* %arrayidx177, align 8
  br label %for.inc178

for.inc178:                                       ; preds = %for.body175
  %133 = load i32, i32* %index171, align 4
  %inc179 = add i32 %133, 1
  store i32 %inc179, i32* %index171, align 4
  br label %for.cond172

for.end180:                                       ; preds = %for.cond172
  %134 = load i32, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
  %sub181 = sub i32 %134, 1
  store i32 %sub181, i32* %j, align 4
  br label %for.cond182

for.cond182:                                      ; preds = %for.inc272, %for.end180
  %135 = load i32, i32* %j, align 4
  %cmp183 = icmp uge i32 %135, 2
  br i1 %cmp183, label %for.body185, label %for.end273

for.body185:                                      ; preds = %for.cond182
  %136 = load i32, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
  %137 = load i32, i32* %j, align 4
  %sub186 = sub i32 %136, %137
  %call187 = call i32* @seq_len(i32 0, i32 %sub186)
  store i32* %call187, i32** %ij, align 4
  %138 = load i32, i32* %j, align 4
  %sub188 = sub i32 %138, 1
  store i32 %sub188, i32* %I2_LENGTH, align 4
  %139 = load i32, i32* %I2_LENGTH, align 4
  %mul189 = mul i32 %139, 4
  %call190 = call noalias i8* @malloc(i32 %mul189)
  %140 = bitcast i8* %call190 to i32*
  store i32* %140, i32** %i2, align 4
  store i32 0, i32* %i, align 4
  br label %for.cond191

for.cond191:                                      ; preds = %for.inc200, %for.body185
  %141 = load i32, i32* %i, align 4
  %142 = load i32, i32* %I2_LENGTH, align 4
  %cmp192 = icmp ult i32 %141, %142
  br i1 %cmp192, label %for.body194, label %for.end202

for.body194:                                      ; preds = %for.cond191
  %143 = load i32, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
  %144 = load i32, i32* %j, align 4
  %sub195 = sub i32 %143, %144
  %add196 = add i32 %sub195, 2
  %145 = load i32, i32* %i, align 4
  %add197 = add i32 %add196, %145
  %sub198 = sub i32 %add197, 1
  %146 = load i32*, i32** %i2, align 4
  %147 = load i32, i32* %i, align 4
  %arrayidx199 = getelementptr inbounds i32, i32* %146, i32 %147
  store i32 %sub198, i32* %arrayidx199, align 4
  br label %for.inc200

for.inc200:                                       ; preds = %for.body194
  %148 = load i32, i32* %i, align 4
  %inc201 = add i32 %148, 1
  store i32 %inc201, i32* %i, align 4
  br label %for.cond191

for.end202:                                       ; preds = %for.cond191
  %149 = load i32, i32* %j, align 4
  %conv203 = uitofp i32 %149 to double
  %150 = load double*, double** %p, align 4
  %151 = load i32*, i32** %i2, align 4
  %arrayidx204 = getelementptr inbounds i32, i32* %151, i32 0
  %152 = load i32, i32* %arrayidx204, align 4
  %arrayidx205 = getelementptr inbounds double, double* %150, i32 %152
  %153 = load double, double* %arrayidx205, align 8
  %mul206 = fmul double %conv203, %153
  %div207 = fdiv double %mul206, 2.000000e+00
  store double %div207, double* %q1, align 8
  store i32 1, i32* %i208, align 4
  br label %for.cond209

for.cond209:                                      ; preds = %for.inc224, %for.end202
  %154 = load i32, i32* %i208, align 4
  %155 = load i32, i32* %I2_LENGTH, align 4
  %cmp210 = icmp ult i32 %154, %155
  br i1 %cmp210, label %for.body212, label %for.end226

for.body212:                                      ; preds = %for.cond209
  %156 = load i32, i32* %j, align 4
  %conv213 = uitofp i32 %156 to double
  %157 = load double*, double** %p, align 4
  %158 = load i32*, i32** %i2, align 4
  %159 = load i32, i32* %i208, align 4
  %arrayidx214 = getelementptr inbounds i32, i32* %158, i32 %159
  %160 = load i32, i32* %arrayidx214, align 4
  %arrayidx215 = getelementptr inbounds double, double* %157, i32 %160
  %161 = load double, double* %arrayidx215, align 8
  %mul216 = fmul double %conv213, %161
  %162 = load i32, i32* %i208, align 4
  %add217 = add i32 2, %162
  %conv218 = uitofp i32 %add217 to double
  %div219 = fdiv double %mul216, %conv218
  store double %div219, double* %TEMP_Q1, align 8
  %163 = load double, double* %TEMP_Q1, align 8
  %164 = load double, double* %q1, align 8
  %cmp220 = fcmp olt double %163, %164
  br i1 %cmp220, label %if.then222, label %if.end223

if.then222:                                       ; preds = %for.body212
  %165 = load double, double* %TEMP_Q1, align 8
  store double %165, double* %q1, align 8
  br label %if.end223

if.end223:                                        ; preds = %if.then222, %for.body212
  br label %for.inc224

for.inc224:                                       ; preds = %if.end223
  %166 = load i32, i32* %i208, align 4
  %inc225 = add i32 %166, 1
  store i32 %inc225, i32* %i208, align 4
  br label %for.cond209

for.end226:                                       ; preds = %for.cond209
  store i32 0, i32* %i227, align 4
  br label %for.cond228

for.cond228:                                      ; preds = %for.inc241, %for.end226
  %167 = load i32, i32* %i227, align 4
  %168 = load i32, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
  %169 = load i32, i32* %j, align 4
  %sub229 = sub i32 %168, %169
  %add230 = add i32 %sub229, 1
  %cmp231 = icmp ult i32 %167, %add230
  br i1 %cmp231, label %for.body233, label %for.end243

for.body233:                                      ; preds = %for.cond228
  %170 = load i32, i32* %j, align 4
  %conv234 = uitofp i32 %170 to double
  %171 = load double*, double** %p, align 4
  %172 = load i32*, i32** %ij, align 4
  %173 = load i32, i32* %i227, align 4
  %arrayidx235 = getelementptr inbounds i32, i32* %172, i32 %173
  %174 = load i32, i32* %arrayidx235, align 4
  %arrayidx236 = getelementptr inbounds double, double* %171, i32 %174
  %175 = load double, double* %arrayidx236, align 8
  %mul237 = fmul double %conv234, %175
  %176 = load double, double* %q1, align 8
  %call238 = call double @min2(double %mul237, double %176)
  %177 = load double*, double** %q, align 4
  %178 = load i32*, i32** %ij, align 4
  %179 = load i32, i32* %i227, align 4
  %arrayidx239 = getelementptr inbounds i32, i32* %178, i32 %179
  %180 = load i32, i32* %arrayidx239, align 4
  %arrayidx240 = getelementptr inbounds double, double* %177, i32 %180
  store double %call238, double* %arrayidx240, align 8
  br label %for.inc241

for.inc241:                                       ; preds = %for.body233
  %181 = load i32, i32* %i227, align 4
  %inc242 = add i32 %181, 1
  store i32 %inc242, i32* %i227, align 4
  br label %for.cond228

for.end243:                                       ; preds = %for.cond228
  %182 = load i32*, i32** %ij, align 4
  %183 = bitcast i32* %182 to i8*
  call void @free(i8* %183)
  store i32* null, i32** %ij, align 4
  store i32 0, i32* %i244, align 4
  br label %for.cond245

for.cond245:                                      ; preds = %for.inc253, %for.end243
  %184 = load i32, i32* %i244, align 4
  %185 = load i32, i32* %I2_LENGTH, align 4
  %cmp246 = icmp ult i32 %184, %185
  br i1 %cmp246, label %for.body248, label %for.end255

for.body248:                                      ; preds = %for.cond245
  %186 = load double*, double** %q, align 4
  %187 = load i32, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
  %188 = load i32, i32* %j, align 4
  %sub249 = sub i32 %187, %188
  %arrayidx250 = getelementptr inbounds double, double* %186, i32 %sub249
  %189 = load double, double* %arrayidx250, align 8
  %190 = load double*, double** %q, align 4
  %191 = load i32*, i32** %i2, align 4
  %192 = load i32, i32* %i244, align 4
  %arrayidx251 = getelementptr inbounds i32, i32* %191, i32 %192
  %193 = load i32, i32* %arrayidx251, align 4
  %arrayidx252 = getelementptr inbounds double, double* %190, i32 %193
  store double %189, double* %arrayidx252, align 8
  br label %for.inc253

for.inc253:                                       ; preds = %for.body248
  %194 = load i32, i32* %i244, align 4
  %inc254 = add i32 %194, 1
  store i32 %inc254, i32* %i244, align 4
  br label %for.cond245

for.end255:                                       ; preds = %for.cond245
  %195 = load i32*, i32** %i2, align 4
  %196 = bitcast i32* %195 to i8*
  call void @free(i8* %196)
  store i32* null, i32** %i2, align 4
  store i32 0, i32* %i256, align 4
  br label %for.cond257

for.cond257:                                      ; preds = %for.inc269, %for.end255
  %197 = load i32, i32* %i256, align 4
  %198 = load i32, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
  %cmp258 = icmp ult i32 %197, %198
  br i1 %cmp258, label %for.body260, label %for.end271

for.body260:                                      ; preds = %for.cond257
  %199 = load double*, double** %pa, align 4
  %200 = load i32, i32* %i256, align 4
  %arrayidx261 = getelementptr inbounds double, double* %199, i32 %200
  %201 = load double, double* %arrayidx261, align 8
  %202 = load double*, double** %q, align 4
  %203 = load i32, i32* %i256, align 4
  %arrayidx262 = getelementptr inbounds double, double* %202, i32 %203
  %204 = load double, double* %arrayidx262, align 8
  %cmp263 = fcmp olt double %201, %204
  br i1 %cmp263, label %if.then265, label %if.end268

if.then265:                                       ; preds = %for.body260
  %205 = load double*, double** %q, align 4
  %206 = load i32, i32* %i256, align 4
  %arrayidx266 = getelementptr inbounds double, double* %205, i32 %206
  %207 = load double, double* %arrayidx266, align 8
  %208 = load double*, double** %pa, align 4
  %209 = load i32, i32* %i256, align 4
  %arrayidx267 = getelementptr inbounds double, double* %208, i32 %209
  store double %207, double* %arrayidx267, align 8
  br label %if.end268

if.end268:                                        ; preds = %if.then265, %for.body260
  br label %for.inc269

for.inc269:                                       ; preds = %if.end268
  %210 = load i32, i32* %i256, align 4
  %inc270 = add i32 %210, 1
  store i32 %inc270, i32* %i256, align 4
  br label %for.cond257

for.end271:                                       ; preds = %for.cond257
  br label %for.inc272

for.inc272:                                       ; preds = %for.end271
  %211 = load i32, i32* %j, align 4
  %dec = add i32 %211, -1
  store i32 %dec, i32* %j, align 4
  br label %for.cond182

for.end273:                                       ; preds = %for.cond182
  %212 = load double*, double** %p, align 4
  %213 = bitcast double* %212 to i8*
  call void @free(i8* %213)
  store double* null, double** %p, align 4
  store i32 0, i32* %index274, align 4
  br label %for.cond275

for.cond275:                                      ; preds = %for.inc282, %for.end273
  %214 = load i32, i32* %index274, align 4
  %215 = load i32, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
  %cmp276 = icmp ult i32 %214, %215
  br i1 %cmp276, label %for.body278, label %for.end284

for.body278:                                      ; preds = %for.cond275
  %216 = load double*, double** %pa, align 4
  %217 = load i32*, i32** %ro136, align 4
  %218 = load i32, i32* %index274, align 4
  %arrayidx279 = getelementptr inbounds i32, i32* %217, i32 %218
  %219 = load i32, i32* %arrayidx279, align 4
  %arrayidx280 = getelementptr inbounds double, double* %216, i32 %219
  %220 = load double, double* %arrayidx280, align 8
  %221 = load double*, double** %q, align 4
  %222 = load i32, i32* %index274, align 4
  %arrayidx281 = getelementptr inbounds double, double* %221, i32 %222
  store double %220, double* %arrayidx281, align 8
  br label %for.inc282

for.inc282:                                       ; preds = %for.body278
  %223 = load i32, i32* %index274, align 4
  %inc283 = add i32 %223, 1
  store i32 %inc283, i32* %index274, align 4
  br label %for.cond275

for.end284:                                       ; preds = %for.cond275
  %224 = load i32*, i32** %ro136, align 4
  %225 = bitcast i32* %224 to i8*
  call void @free(i8* %225)
  store i32* null, i32** %ro136, align 4
  %226 = load double*, double** %pa, align 4
  %227 = bitcast double* %226 to i8*
  call void @free(i8* %227)
  store double* null, double** %pa, align 4
  %228 = load double*, double** %q, align 4
  store double* %228, double** %retval, align 4
  br label %return

if.end285:                                        ; preds = %if.else109
  br label %if.end286

if.end286:                                        ; preds = %if.end285
  br label %if.end287

if.end287:                                        ; preds = %if.end286
  %229 = load double*, double** %PVALUES.addr, align 4
  %230 = load i32, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
  %call289 = call i32* @order(double* %229, i32 %230, i1 zeroext true)
  store i32* %call289, i32** %o288, align 4
  %231 = load i32*, i32** %o288, align 4
  %cmp290 = icmp eq i32* %231, null
  br i1 %cmp290, label %if.then292, label %if.end294

if.then292:                                       ; preds = %if.end287
  %call293 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([33 x i8], [33 x i8]* @.str.3, i32 0, i32 0), i8* getelementptr inbounds ([23 x i8], [23 x i8]* @.str.1, i32 0, i32 0), i32 398)
  call void @perror(i8* getelementptr inbounds ([1 x i8], [1 x i8]* @.str.2, i32 0, i32 0))
  call void @exit(i32 1) #5
  unreachable

if.end294:                                        ; preds = %if.end287
  %232 = load i32*, i32** %o288, align 4
  %233 = load i32, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
  %call295 = call double* @uint2double(i32* %232, i32 %233)
  store double* %call295, double** %o_double, align 4
  store i32 0, i32* %index296, align 4
  br label %for.cond297

for.cond297:                                      ; preds = %for.inc312, %if.end294
  %234 = load i32, i32* %index296, align 4
  %235 = load i32, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
  %cmp298 = icmp ult i32 %234, %235
  br i1 %cmp298, label %for.body300, label %for.end314

for.body300:                                      ; preds = %for.cond297
  %236 = load double*, double** %PVALUES.addr, align 4
  %237 = load i32, i32* %index296, align 4
  %arrayidx301 = getelementptr inbounds double, double* %236, i32 %237
  %238 = load double, double* %arrayidx301, align 8
  %cmp302 = fcmp olt double %238, 0.000000e+00
  br i1 %cmp302, label %if.then307, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %for.body300
  %239 = load double*, double** %PVALUES.addr, align 4
  %240 = load i32, i32* %index296, align 4
  %arrayidx304 = getelementptr inbounds double, double* %239, i32 %240
  %241 = load double, double* %arrayidx304, align 8
  %cmp305 = fcmp ogt double %241, 1.000000e+00
  br i1 %cmp305, label %if.then307, label %if.end311

if.then307:                                       ; preds = %lor.lhs.false, %for.body300
  %242 = load i32, i32* %index296, align 4
  %243 = load double*, double** %PVALUES.addr, align 4
  %244 = load i32, i32* %index296, align 4
  %arrayidx308 = getelementptr inbounds double, double* %243, i32 %244
  %245 = load double, double* %arrayidx308, align 8
  %call309 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([54 x i8], [54 x i8]* @.str.24, i32 0, i32 0), i32 %242, double %245)
  %call310 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([20 x i8], [20 x i8]* @.str.25, i32 0, i32 0), i8* getelementptr inbounds ([23 x i8], [23 x i8]* @.str.1, i32 0, i32 0), i32 406)
  call void @exit(i32 1) #5
  unreachable

if.end311:                                        ; preds = %lor.lhs.false
  br label %for.inc312

for.inc312:                                       ; preds = %if.end311
  %246 = load i32, i32* %index296, align 4
  %inc313 = add i32 %246, 1
  store i32 %inc313, i32* %index296, align 4
  br label %for.cond297

for.end314:                                       ; preds = %for.cond297
  %247 = load double*, double** %o_double, align 4
  %248 = load i32, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
  %call316 = call i32* @order(double* %247, i32 %248, i1 zeroext false)
  store i32* %call316, i32** %ro315, align 4
  %249 = load i32*, i32** %ro315, align 4
  %cmp317 = icmp eq i32* %249, null
  br i1 %cmp317, label %if.then319, label %if.end321

if.then319:                                       ; preds = %for.end314
  %call320 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([33 x i8], [33 x i8]* @.str.3, i32 0, i32 0), i8* getelementptr inbounds ([23 x i8], [23 x i8]* @.str.1, i32 0, i32 0), i32 413)
  call void @perror(i8* getelementptr inbounds ([1 x i8], [1 x i8]* @.str.2, i32 0, i32 0))
  call void @exit(i32 1) #5
  unreachable

if.end321:                                        ; preds = %for.end314
  %250 = load double*, double** %o_double, align 4
  %251 = bitcast double* %250 to i8*
  call void @free(i8* %251)
  store double* null, double** %o_double, align 4
  %252 = load i32, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
  %mul322 = mul i32 8, %252
  %call323 = call noalias i8* @malloc(i32 %mul322)
  %253 = bitcast i8* %call323 to double*
  store double* %253, double** %cummin_input, align 4
  %254 = load i16, i16* %TYPE, align 2
  %conv324 = sext i16 %254 to i32
  %cmp325 = icmp eq i32 %conv324, 0
  br i1 %cmp325, label %if.then327, label %if.else344

if.then327:                                       ; preds = %if.end321
  store i32 0, i32* %index328, align 4
  br label %for.cond329

for.cond329:                                      ; preds = %for.inc341, %if.then327
  %255 = load i32, i32* %index328, align 4
  %256 = load i32, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
  %cmp330 = icmp ult i32 %255, %256
  br i1 %cmp330, label %for.body332, label %for.end343

for.body332:                                      ; preds = %for.cond329
  %257 = load i32, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
  %conv333 = uitofp i32 %257 to double
  %258 = load i32, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
  %259 = load i32, i32* %index328, align 4
  %sub334 = sub i32 %258, %259
  %conv335 = uitofp i32 %sub334 to double
  %div336 = fdiv double %conv333, %conv335
  store double %div336, double* %NI, align 8
  %260 = load double, double* %NI, align 8
  %261 = load double*, double** %PVALUES.addr, align 4
  %262 = load i32*, i32** %o288, align 4
  %263 = load i32, i32* %index328, align 4
  %arrayidx337 = getelementptr inbounds i32, i32* %262, i32 %263
  %264 = load i32, i32* %arrayidx337, align 4
  %arrayidx338 = getelementptr inbounds double, double* %261, i32 %264
  %265 = load double, double* %arrayidx338, align 8
  %mul339 = fmul double %260, %265
  %266 = load double*, double** %cummin_input, align 4
  %267 = load i32, i32* %index328, align 4
  %arrayidx340 = getelementptr inbounds double, double* %266, i32 %267
  store double %mul339, double* %arrayidx340, align 8
  br label %for.inc341

for.inc341:                                       ; preds = %for.body332
  %268 = load i32, i32* %index328, align 4
  %inc342 = add i32 %268, 1
  store i32 %inc342, i32* %index328, align 4
  br label %for.cond329

for.end343:                                       ; preds = %for.cond329
  br label %if.end401

if.else344:                                       ; preds = %if.end321
  %269 = load i16, i16* %TYPE, align 2
  %conv345 = sext i16 %269 to i32
  %cmp346 = icmp eq i32 %conv345, 1
  br i1 %cmp346, label %if.then348, label %if.else380

if.then348:                                       ; preds = %if.else344
  store double 1.000000e+00, double* %q349, align 8
  store i32 2, i32* %index350, align 4
  br label %for.cond351

for.cond351:                                      ; preds = %for.inc359, %if.then348
  %270 = load i32, i32* %index350, align 4
  %271 = load i32, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
  %add352 = add i32 1, %271
  %cmp353 = icmp ult i32 %270, %add352
  br i1 %cmp353, label %for.body355, label %for.end361

for.body355:                                      ; preds = %for.cond351
  %272 = load i32, i32* %index350, align 4
  %conv356 = uitofp i32 %272 to double
  %div357 = fdiv double 1.000000e+00, %conv356
  %273 = load double, double* %q349, align 8
  %add358 = fadd double %273, %div357
  store double %add358, double* %q349, align 8
  br label %for.inc359

for.inc359:                                       ; preds = %for.body355
  %274 = load i32, i32* %index350, align 4
  %inc360 = add i32 %274, 1
  store i32 %inc360, i32* %index350, align 4
  br label %for.cond351

for.end361:                                       ; preds = %for.cond351
  store i32 0, i32* %index362, align 4
  br label %for.cond363

for.cond363:                                      ; preds = %for.inc377, %for.end361
  %275 = load i32, i32* %index362, align 4
  %276 = load i32, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
  %cmp364 = icmp ult i32 %275, %276
  br i1 %cmp364, label %for.body366, label %for.end379

for.body366:                                      ; preds = %for.cond363
  %277 = load i32, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
  %conv368 = uitofp i32 %277 to double
  %278 = load i32, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
  %279 = load i32, i32* %index362, align 4
  %sub369 = sub i32 %278, %279
  %conv370 = uitofp i32 %sub369 to double
  %div371 = fdiv double %conv368, %conv370
  store double %div371, double* %NI367, align 8
  %280 = load double, double* %q349, align 8
  %281 = load double, double* %NI367, align 8
  %mul372 = fmul double %280, %281
  %282 = load double*, double** %PVALUES.addr, align 4
  %283 = load i32*, i32** %o288, align 4
  %284 = load i32, i32* %index362, align 4
  %arrayidx373 = getelementptr inbounds i32, i32* %283, i32 %284
  %285 = load i32, i32* %arrayidx373, align 4
  %arrayidx374 = getelementptr inbounds double, double* %282, i32 %285
  %286 = load double, double* %arrayidx374, align 8
  %mul375 = fmul double %mul372, %286
  %287 = load double*, double** %cummin_input, align 4
  %288 = load i32, i32* %index362, align 4
  %arrayidx376 = getelementptr inbounds double, double* %287, i32 %288
  store double %mul375, double* %arrayidx376, align 8
  br label %for.inc377

for.inc377:                                       ; preds = %for.body366
  %289 = load i32, i32* %index362, align 4
  %inc378 = add i32 %289, 1
  store i32 %inc378, i32* %index362, align 4
  br label %for.cond363

for.end379:                                       ; preds = %for.cond363
  br label %if.end400

if.else380:                                       ; preds = %if.else344
  %290 = load i16, i16* %TYPE, align 2
  %conv381 = sext i16 %290 to i32
  %cmp382 = icmp eq i32 %conv381, 3
  br i1 %cmp382, label %if.then384, label %if.end399

if.then384:                                       ; preds = %if.else380
  store i32 0, i32* %index385, align 4
  br label %for.cond386

for.cond386:                                      ; preds = %for.inc396, %if.then384
  %291 = load i32, i32* %index385, align 4
  %292 = load i32, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
  %cmp387 = icmp ult i32 %291, %292
  br i1 %cmp387, label %for.body389, label %for.end398

for.body389:                                      ; preds = %for.cond386
  %293 = load i32, i32* %index385, align 4
  %add390 = add i32 %293, 1
  %conv391 = uitofp i32 %add390 to double
  %294 = load double*, double** %PVALUES.addr, align 4
  %295 = load i32*, i32** %o288, align 4
  %296 = load i32, i32* %index385, align 4
  %arrayidx392 = getelementptr inbounds i32, i32* %295, i32 %296
  %297 = load i32, i32* %arrayidx392, align 4
  %arrayidx393 = getelementptr inbounds double, double* %294, i32 %297
  %298 = load double, double* %arrayidx393, align 8
  %mul394 = fmul double %conv391, %298
  %299 = load double*, double** %cummin_input, align 4
  %300 = load i32, i32* %index385, align 4
  %arrayidx395 = getelementptr inbounds double, double* %299, i32 %300
  store double %mul394, double* %arrayidx395, align 8
  br label %for.inc396

for.inc396:                                       ; preds = %for.body389
  %301 = load i32, i32* %index385, align 4
  %inc397 = add i32 %301, 1
  store i32 %inc397, i32* %index385, align 4
  br label %for.cond386

for.end398:                                       ; preds = %for.cond386
  br label %if.end399

if.end399:                                        ; preds = %for.end398, %if.else380
  br label %if.end400

if.end400:                                        ; preds = %if.end399, %for.end379
  br label %if.end401

if.end401:                                        ; preds = %if.end400, %for.end343
  %302 = load i32*, i32** %o288, align 4
  %303 = bitcast i32* %302 to i8*
  call void @free(i8* %303)
  store i32* null, i32** %o288, align 4
  store double* null, double** %cummin_array, align 4
  %304 = load double*, double** %cummin_input, align 4
  %305 = load i32, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
  %call402 = call double* @cummin(double* %304, i32 %305)
  store double* %call402, double** %cummin_array, align 4
  %306 = load double*, double** %cummin_input, align 4
  %307 = bitcast double* %306 to i8*
  call void @free(i8* %307)
  store double* null, double** %cummin_input, align 4
  %308 = load double*, double** %cummin_array, align 4
  %309 = load i32, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
  %call404 = call double* @pminx(double* %308, i32 %309, double 1.000000e+00)
  store double* %call404, double** %pmin403, align 4
  %310 = load double*, double** %cummin_array, align 4
  %311 = bitcast double* %310 to i8*
  call void @free(i8* %311)
  store double* null, double** %cummin_array, align 4
  %312 = load i32, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
  %mul405 = mul i32 %312, 8
  %call406 = call noalias i8* @malloc(i32 %mul405)
  %313 = bitcast i8* %call406 to double*
  store double* %313, double** %q_array, align 4
  store i32 0, i32* %index407, align 4
  br label %for.cond408

for.cond408:                                      ; preds = %for.inc415, %if.end401
  %314 = load i32, i32* %index407, align 4
  %315 = load i32, i32* %NO_OF_ARRAY_ELEMENTS.addr, align 4
  %cmp409 = icmp ult i32 %314, %315
  br i1 %cmp409, label %for.body411, label %for.end417

for.body411:                                      ; preds = %for.cond408
  %316 = load double*, double** %pmin403, align 4
  %317 = load i32*, i32** %ro315, align 4
  %318 = load i32, i32* %index407, align 4
  %arrayidx412 = getelementptr inbounds i32, i32* %317, i32 %318
  %319 = load i32, i32* %arrayidx412, align 4
  %arrayidx413 = getelementptr inbounds double, double* %316, i32 %319
  %320 = load double, double* %arrayidx413, align 8
  %321 = load double*, double** %q_array, align 4
  %322 = load i32, i32* %index407, align 4
  %arrayidx414 = getelementptr inbounds double, double* %321, i32 %322
  store double %320, double* %arrayidx414, align 8
  br label %for.inc415

for.inc415:                                       ; preds = %for.body411
  %323 = load i32, i32* %index407, align 4
  %inc416 = add i32 %323, 1
  store i32 %inc416, i32* %index407, align 4
  br label %for.cond408

for.end417:                                       ; preds = %for.cond408
  %324 = load i32*, i32** %ro315, align 4
  %325 = bitcast i32* %324 to i8*
  call void @free(i8* %325)
  store i32* null, i32** %ro315, align 4
  %326 = load double*, double** %pmin403, align 4
  %327 = bitcast double* %326 to i8*
  call void @free(i8* %327)
  store double* null, double** %pmin403, align 4
  %328 = load double*, double** %q_array, align 4
  store double* %328, double** %retval, align 4
  br label %return

return:                                           ; preds = %for.end417, %for.end284, %for.end108, %for.end
  %329 = load double*, double** %retval, align 4
  ret double* %329
}

declare i32 @strcasecmp(i8* %0, i8* %1) #1

; Function Attrs: noinline nounwind optnone
define hidden i32 @main() #0 {
entry:
  %retval = alloca i32, align 4
  %PVALUES = alloca [50 x double], align 16
  %CORRECT_ANSWERS = alloca [6 x [50 x double]], align 16
  %TYPES = alloca [6 x i8*], align 16
  %type = alloca i16, align 2
  %q = alloca double*, align 4
  %error = alloca double, align 8
  %i = alloca i32, align 4
  %this_error = alloca double, align 8
  store i32 0, i32* %retval, align 4
  %0 = bitcast [50 x double]* %PVALUES to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 16 %0, i8* align 16 bitcast ([50 x double]* @__const.main.PVALUES to i8*), i32 400, i1 false)
  %1 = bitcast [6 x [50 x double]]* %CORRECT_ANSWERS to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 16 %1, i8* align 16 bitcast ([6 x [50 x double]]* @__const.main.CORRECT_ANSWERS to i8*), i32 2400, i1 false)
  %2 = bitcast [6 x i8*]* %TYPES to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 16 %2, i8* align 16 bitcast ([6 x i8*]* @__const.main.TYPES to i8*), i32 24, i1 false)
  store i16 0, i16* %type, align 2
  br label %for.cond

for.cond:                                         ; preds = %for.inc19, %entry
  %3 = load i16, i16* %type, align 2
  %conv = zext i16 %3 to i32
  %cmp = icmp sle i32 %conv, 5
  br i1 %cmp, label %for.body, label %for.end21

for.body:                                         ; preds = %for.cond
  %arraydecay = getelementptr inbounds [50 x double], [50 x double]* %PVALUES, i32 0, i32 0
  %4 = load i16, i16* %type, align 2
  %idxprom = zext i16 %4 to i32
  %arrayidx = getelementptr inbounds [6 x i8*], [6 x i8*]* %TYPES, i32 0, i32 %idxprom
  %5 = load i8*, i8** %arrayidx, align 4
  %call = call double* @p_adjust(double* %arraydecay, i32 50, i8* %5)
  store double* %call, double** %q, align 4
  %6 = load double*, double** %q, align 4
  %arrayidx2 = getelementptr inbounds double, double* %6, i32 0
  %7 = load double, double* %arrayidx2, align 8
  %8 = load i16, i16* %type, align 2
  %idxprom3 = zext i16 %8 to i32
  %arrayidx4 = getelementptr inbounds [6 x [50 x double]], [6 x [50 x double]]* %CORRECT_ANSWERS, i32 0, i32 %idxprom3
  %arrayidx5 = getelementptr inbounds [50 x double], [50 x double]* %arrayidx4, i32 0, i32 0
  %9 = load double, double* %arrayidx5, align 16
  %sub = fsub double %7, %9
  %10 = call double @llvm.fabs.f64(double %sub)
  store double %10, double* %error, align 8
  store i32 1, i32* %i, align 4
  br label %for.cond6

for.cond6:                                        ; preds = %for.inc, %for.body
  %11 = load i32, i32* %i, align 4
  %cmp7 = icmp ult i32 %11, 50
  br i1 %cmp7, label %for.body9, label %for.end

for.body9:                                        ; preds = %for.cond6
  %12 = load double*, double** %q, align 4
  %13 = load i32, i32* %i, align 4
  %arrayidx10 = getelementptr inbounds double, double* %12, i32 %13
  %14 = load double, double* %arrayidx10, align 8
  %15 = load i16, i16* %type, align 2
  %idxprom11 = zext i16 %15 to i32
  %arrayidx12 = getelementptr inbounds [6 x [50 x double]], [6 x [50 x double]]* %CORRECT_ANSWERS, i32 0, i32 %idxprom11
  %16 = load i32, i32* %i, align 4
  %arrayidx13 = getelementptr inbounds [50 x double], [50 x double]* %arrayidx12, i32 0, i32 %16
  %17 = load double, double* %arrayidx13, align 8
  %sub14 = fsub double %14, %17
  %18 = call double @llvm.fabs.f64(double %sub14)
  store double %18, double* %this_error, align 8
  %19 = load double, double* %this_error, align 8
  %20 = load double, double* %error, align 8
  %add = fadd double %20, %19
  store double %add, double* %error, align 8
  br label %for.inc

for.inc:                                          ; preds = %for.body9
  %21 = load i32, i32* %i, align 4
  %inc = add i32 %21, 1
  store i32 %inc, i32* %i, align 4
  br label %for.cond6

for.end:                                          ; preds = %for.cond6
  %22 = load double*, double** %q, align 4
  call void @double_say(double* %22, i32 50)
  %23 = load double*, double** %q, align 4
  %24 = bitcast double* %23 to i8*
  call void @free(i8* %24)
  store double* null, double** %q, align 4
  %25 = load i16, i16* %type, align 2
  %conv15 = zext i16 %25 to i32
  %26 = load i16, i16* %type, align 2
  %idxprom16 = zext i16 %26 to i32
  %arrayidx17 = getelementptr inbounds [6 x i8*], [6 x i8*]* %TYPES, i32 0, i32 %idxprom16
  %27 = load i8*, i8** %arrayidx17, align 4
  %28 = load double, double* %error, align 8
  %call18 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([44 x i8], [44 x i8]* @.str.28, i32 0, i32 0), i32 %conv15, i8* %27, double %28)
  br label %for.inc19

for.inc19:                                        ; preds = %for.end
  %29 = load i16, i16* %type, align 2
  %inc20 = add i16 %29, 1
  store i16 %inc20, i16* %type, align 2
  br label %for.cond

for.end21:                                        ; preds = %for.cond
  ret i32 0
}

; Function Attrs: argmemonly nounwind willreturn
declare void @llvm.memcpy.p0i8.p0i8.i32(i8* noalias nocapture writeonly %0, i8* noalias nocapture readonly %1, i32 %2, i1 immarg %3) #3

; Function Attrs: nounwind readnone speculatable willreturn
declare double @llvm.fabs.f64(double %0) #4

attributes #0 = { noinline nounwind optnone "correctly-rounded-divide-sqrt-fp-math"="false" "disable-tail-calls"="false" "frame-pointer"="none" "less-precise-fpmad"="false" "min-legal-vector-width"="0" "no-infs-fp-math"="false" "no-jump-tables"="false" "no-nans-fp-math"="false" "no-signed-zeros-fp-math"="false" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="generic" "unsafe-fp-math"="false" "use-soft-float"="false" }
attributes #1 = { "correctly-rounded-divide-sqrt-fp-math"="false" "disable-tail-calls"="false" "frame-pointer"="none" "less-precise-fpmad"="false" "no-infs-fp-math"="false" "no-nans-fp-math"="false" "no-signed-zeros-fp-math"="false" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="generic" "unsafe-fp-math"="false" "use-soft-float"="false" }
attributes #2 = { noreturn "correctly-rounded-divide-sqrt-fp-math"="false" "disable-tail-calls"="false" "frame-pointer"="none" "less-precise-fpmad"="false" "no-infs-fp-math"="false" "no-nans-fp-math"="false" "no-signed-zeros-fp-math"="false" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="generic" "unsafe-fp-math"="false" "use-soft-float"="false" }
attributes #3 = { argmemonly nounwind willreturn }
attributes #4 = { nounwind readnone speculatable willreturn }
attributes #5 = { noreturn }

!llvm.module.flags = !{!0}
!llvm.ident = !{!1}

!0 = !{i32 1, !"wchar_size", i32 4}
!1 = !{!"clang version 11.0.0 (https://github.com/Jacarte/llvm-project.git 0f6dea67136cc1e0b3d200eb2bb165628970c44b)"}

; extracted candidates

; *****
; For LLVM instruction:
;  %3 = load i16, i16* %type, align 2
; Looking for a replacement for:
%0:i16 = var
infer %0

; *****
; For LLVM instruction:
;  %conv = zext i16 %3 to i32
; Looking for a replacement for:
%0:i16 = var
%1:i32 = zext %0
infer %1

; *****
; For LLVM instruction:
;  %cmp = icmp sle i32 %conv, 5
; Looking for a replacement for:
%0:i16 = var
%1:i32 = zext %0
%2:i1 = sle %1, 5:i32
infer %2

; *****
; For LLVM instruction:
;  %4 = load i16, i16* %type, align 2
; Looking for a replacement for:
%0:i16 = var
infer %0

; *****
; For LLVM instruction:
;  %idxprom = zext i16 %4 to i32
; Looking for a replacement for:
%0:i16 = var
%1:i32 = zext %0
infer %1

; *****
; For LLVM instruction:
;  %8 = load i16, i16* %type, align 2
; Looking for a replacement for:
%0:i16 = var
infer %0

; *****
; For LLVM instruction:
;  %idxprom3 = zext i16 %8 to i32
; Looking for a replacement for:
%0:i16 = var
%1:i32 = zext %0
infer %1

; *****
; For LLVM instruction:
;  %11 = load i32, i32* %i, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %cmp7 = icmp ult i32 %11, 50
; Looking for a replacement for:
%0:i32 = var
%1:i1 = ult %0, 50:i32
infer %1

; *****
; For LLVM instruction:
;  %13 = load i32, i32* %i, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %15 = load i16, i16* %type, align 2
; Looking for a replacement for:
%0:i16 = var
infer %0

; *****
; For LLVM instruction:
;  %idxprom11 = zext i16 %15 to i32
; Looking for a replacement for:
%0:i16 = var
%1:i32 = zext %0
infer %1

; *****
; For LLVM instruction:
;  %16 = load i32, i32* %i, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %21 = load i32, i32* %i, align 4
; Looking for a replacement for:
%0:i32 = var
infer %0

; *****
; For LLVM instruction:
;  %inc = add i32 %21, 1
; Looking for a replacement for:
%0:i32 = var
%1:i32 = add 1:i32, %0
infer %1

; *****
; For LLVM instruction:
;  %25 = load i16, i16* %type, align 2
; Looking for a replacement for:
%0:i16 = var
infer %0

; *****
; For LLVM instruction:
;  %conv15 = zext i16 %25 to i32
; Looking for a replacement for:
%0:i16 = var
%1:i32 = zext %0
infer %1

; *****
; For LLVM instruction:
;  %26 = load i16, i16* %type, align 2
; Looking for a replacement for:
%0:i16 = var
infer %0

; *****
; For LLVM instruction:
;  %idxprom16 = zext i16 %26 to i32
; Looking for a replacement for:
%0:i16 = var
%1:i32 = zext %0
infer %1

; *****
; For LLVM instruction:
;  %29 = load i16, i16* %type, align 2
; Looking for a replacement for:
%0:i16 = var
infer %0

; *****
; For LLVM instruction:
;  %inc20 = add i16 %29, 1
; Looking for a replacement for:
%0:i16 = var
%1:i16 = add 1:i16, %0
infer %1
got 2 candidates from LHS

-------------------------------------------------
%0:i16 = var
%1:i32 = zext %0
infer %1


--------------------------------
guess 0

%0:i32 = var ; reservedconst_1

Cost = 0
first query is SAT, returning the model:
reservedconst_1: 0
0 th attempt: second query is SAT-- constant doesn't work
first query is SAT, returning the model:
reservedconst_1: 65535
1 th attempt: second query is SAT-- constant doesn't work
first query is UNSAT-- no more guesses
Dataflow Pruned 0/0
There are 1 Guesses
There are 0 RHSs before deduplication
There are 0 RHSs after deduplication
got 3 candidates from LHS

-------------------------------------------------
%0:i16 = var
%1:i32 = zext %0
%2:i1 = sle %1, 5:i32
infer %2


--------------------------------
guess 0

%0:i1 = var ; reservedconst_1

Cost = 0
first query is SAT, returning the model:
reservedconst_1: -1
0 th attempt: second query is SAT-- constant doesn't work
first query is SAT, returning the model:
reservedconst_1: 0
1 th attempt: second query is SAT-- constant doesn't work
first query is UNSAT-- no more guesses
Dataflow Pruned 0/0
There are 1 Guesses
There are 0 RHSs before deduplication
There are 0 RHSs after deduplication
got 2 candidates from LHS

-------------------------------------------------
%0:i32 = var
%1:i1 = ult %0, 50:i32
infer %1


--------------------------------
guess 0

%0:i1 = var ; reservedconst_1

Cost = 0
first query is SAT, returning the model:
reservedconst_1: -1
0 th attempt: second query is SAT-- constant doesn't work
first query is SAT, returning the model:
reservedconst_1: 0
1 th attempt: second query is SAT-- constant doesn't work
first query is UNSAT-- no more guesses
Dataflow Pruned 0/0
There are 1 Guesses
There are 0 RHSs before deduplication
There are 0 RHSs after deduplication
got 2 candidates from LHS

-------------------------------------------------
%0:i16 = var
%1:i16 = add 1:i16, %0
infer %1


--------------------------------
guess 0

%0:i16 = var ; reservedconst_1

Cost = 0
first query is SAT, returning the model:
reservedconst_1: 1
0 th attempt: second query is SAT-- constant doesn't work
first query is SAT, returning the model:
reservedconst_1: 0
1 th attempt: second query is SAT-- constant doesn't work
first query is UNSAT-- no more guesses

--------------------------------
guess 1

%0:i16 = var

Cost = 0
second query is SAT-- constant doesn't work
Dataflow Pruned 0/0
There are 2 Guesses
There are 0 RHSs before deduplication
There are 0 RHSs after deduplication
#########################################################
; exiting Souper's runOnFunction() for main()
Total of 1 replacements done on this module
Total of 1 replacements candidates on this module
